'use strict';
var t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(num) {
  return typeof num;
} : function(obj) {
  return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
i = function(value) {
  return function() {
    var inner = value.apply(this, arguments);
    return new Promise(function(e, cb) {
      return function callback(key, value) {
        try {
          var setting = inner[key](value);
          var type = setting.value;
        } catch (iconCtx) {
          return void cb(iconCtx);
        }
        if (!setting.done) {
          return Promise.resolve(type).then(function(type) {
            callback("next", type);
          }, function(type) {
            callback("throw", type);
          });
        }
        e(type);
      }("next");
    });
  };
};
r = function(keyword, name) {
  if (!(keyword instanceof name)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
n = function() {
  function t(y, props) {
    var i = 0;
    for (; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) {
        descriptor.writable = true;
      }
      Object.defineProperty(y, descriptor.key, descriptor);
    }
  }
  return function(p, n, a) {
    return n && t(p.prototype, n), a && t(p, a), p;
  };
}();
o = function(f, o) {
  if ("function" != typeof o && null !== o) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof o);
  }
  f.prototype = Object.create(o && o.prototype, {
    constructor : {
      value : f,
      enumerable : false,
      writable : true,
      configurable : true
    }
  });
  if (o) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(f, o);
    } else {
      f.__proto__ = o;
    }
  }
};
s = function(t, r) {
  if (!t) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return !r || "object" != typeof r && "function" != typeof r ? t : r;
};
a = function() {
  function render() {
    var sizeController = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    r(this, render);
    this._domElement = sizeController.domElement;
    this._onChange = sizeController.onChange || function() {
    };
    this._observer = new MutationObserver(this._onChange);
  }
  return render.prototype.watch = function(directories) {
    var observerConfig = {};
    directories.forEach(function(ballNumber) {
      observerConfig[ballNumber] = true;
    });
    this._observer.observe(this._domElement, observerConfig);
  }, render.prototype.unwatch = function() {
    this._observer.disconnect();
  }, render;
}();
function l(c, m) {
  return c(m = {
    exports : {}
  }, m.exports), m.exports;
}
var u = l(function(module) {
  !function(global) {
    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);
      return generator._invoke = function(innerFn, self, context) {
        var status = "suspendedStart";
        return function(foo, undefined) {
          if ("executing" === status) {
            throw new Error("Generator is already running");
          }
          if ("completed" === status) {
            if ("throw" === foo) {
              throw undefined;
            }
            return state();
          }
          context.method = foo;
          context.arg = undefined;
          for (;;) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel) {
                  continue;
                }
                return delegateResult;
              }
            }
            if ("next" === context.method) {
              context.sent = context._sent = context.arg;
            } else {
              if ("throw" === context.method) {
                if ("suspendedStart" === status) {
                  throw status = "completed", context.arg;
                }
                context.dispatchException(context.arg);
              } else {
                if ("return" === context.method) {
                  context.abrupt("return", context.arg);
                }
              }
            }
            status = "executing";
            var record = tryCatch(innerFn, self, context);
            if ("normal" === record.type) {
              if (status = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) {
                continue;
              }
              return {
                value : record.arg,
                done : context.done
              };
            }
            if ("throw" === record.type) {
              status = "completed";
              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      }(innerFn, self, context), generator;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type : "normal",
          arg : fn.call(obj, arg)
        };
      } catch (keystableId) {
        return {
          type : "throw",
          arg : keystableId
        };
      }
    }
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        prototype[method] = function(next) {
          return this._invoke(method, next);
        };
      });
    }
    function AsyncIterator(generator) {
      var context;
      this._invoke = function(callback, context) {
        function callback() {
          return new Promise(function(results, onRejected) {
            !function invoke(method, arg, resolve, reject) {
              var record = tryCatch(generator[method], generator, arg);
              if ("throw" !== record.type) {
                var result = record.arg;
                var value = result.value;
                return value && "object" == typeof value && hasOwn.call(value, "__await") ? Promise.resolve(value.__await).then(function(f) {
                  invoke("next", f, resolve, reject);
                }, function(f) {
                  invoke("throw", f, resolve, reject);
                }) : Promise.resolve(value).then(function(e) {
                  result.value = e;
                  resolve(result);
                }, reject);
              }
              reject(record.arg);
            }(callback, context, results, onRejected);
          });
        }
        return context = context ? context.then(callback, callback) : callback();
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var selector = delegate.iterator[context.method];
      if (undefined === selector) {
        if (context.delegate = null, "throw" === context.method) {
          if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) {
            return ContinueSentinel;
          }
          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }
        return ContinueSentinel;
      }
      var record = tryCatch(selector, delegate.iterator, context.arg);
      if ("throw" === record.type) {
        return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      }
      var result = record.arg;
      return result ? result.done ? (context[delegate.resultName] = result.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : result : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = {
        tryLoc : locs[0]
      };
      if (1 in locs) {
        entry.catchLoc = locs[1];
      }
      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }
      this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc : "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }
    function values(iterable) {
      if (iterable) {
        var method = iterable[name];
        if (method) {
          return method.call(iterable);
        }
        if ("function" == typeof iterable.next) {
          return iterable;
        }
        if (!isNaN(iterable.length)) {
          var i = -1;
          var vert = function next() {
            for (; ++i < iterable.length;) {
              if (hasOwn.call(iterable, i)) {
                return next.value = iterable[i], next.done = false, next;
              }
            }
            return next.value = undefined, next.done = true, next;
          };
          return vert.next = vert;
        }
      }
      return {
        next : state
      };
    }
    function state() {
      return {
        value : undefined,
        done : true
      };
    }
    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var $Symbol = "function" == typeof Symbol ? Symbol : {};
    var name = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    var runtime = global.regeneratorRuntime;
    if (runtime) {
      module.exports = runtime;
    } else {
      (runtime = global.regeneratorRuntime = module.exports).wrap = wrap;
      var ContinueSentinel = {};
      var s = {};
      s[name] = function() {
        return this;
      };
      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, name)) {
        s = NativeIteratorPrototype;
      }
      var value = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(s);
      GeneratorFunction.prototype = value.constructor = GeneratorFunctionPrototype;
      GeneratorFunctionPrototype.constructor = GeneratorFunction;
      GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
      runtime.isGeneratorFunction = function(obj) {
        var ctor = "function" == typeof obj && obj.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      };
      runtime.mark = function(obj) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(obj, GeneratorFunctionPrototype) : (obj.__proto__ = GeneratorFunctionPrototype, toStringTagSymbol in obj || (obj[toStringTagSymbol] = "GeneratorFunction")), obj.prototype = Object.create(value), obj;
      };
      runtime.awrap = function(arg) {
        return {
          __await : arg
        };
      };
      defineIteratorMethods(AsyncIterator.prototype);
      AsyncIterator.prototype[asyncIteratorSymbol] = function() {
        return this;
      };
      runtime.AsyncIterator = AsyncIterator;
      runtime.async = function(innerFn, outerFn, self, tryLocsList) {
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
        return runtime.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      };
      defineIteratorMethods(value);
      value[toStringTagSymbol] = "Generator";
      value[name] = function() {
        return this;
      };
      value.toString = function() {
        return "[object Generator]";
      };
      runtime.keys = function(data) {
        var parts = [];
        var day;
        for (day in data) {
          parts.push(day);
        }
        return parts.reverse(), function next() {
          for (; parts.length;) {
            var key = parts.pop();
            if (key in data) {
              return next.value = key, next.done = false, next;
            }
          }
          return next.done = true, next;
        };
      };
      runtime.values = values;
      Context.prototype = {
        constructor : Context,
        reset : function(noalert) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = false, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !noalert) {
            var name;
            for (name in this) {
              if ("t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined;
              }
            }
          }
        },
        stop : function() {
          this.done = true;
          var record = this.tryEntries[0].completion;
          if ("throw" === record.type) {
            throw record.arg;
          }
          return this.rval;
        },
        dispatchException : function(exception) {
          function handle(callback, download) {
            return record.type = "throw", record.arg = exception, t.next = callback, download && (t.method = "next", t.arg = undefined), !!download;
          }
          if (this.done) {
            throw exception;
          }
          var t = this;
          var i = this.tryEntries.length - 1;
          for (; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;
            if ("root" === entry.tryLoc) {
              return handle("end");
            }
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                if (hasCatch) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true);
                  }
                } else {
                  if (!hasFinally) {
                    throw new Error("try statement without catch or finally");
                  }
                  if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc);
                  }
                }
              }
            }
          }
        },
        abrupt : function(type, arg) {
          var i = this.tryEntries.length - 1;
          for (; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          if (finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }
          var value = finallyEntry ? finallyEntry.completion : {};
          return value.type = type, value.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(value);
        },
        complete : function(value, data) {
          if ("throw" === value.type) {
            throw value.arg;
          }
          return "break" === value.type || "continue" === value.type ? this.next = value.arg : "return" === value.type ? (this.rval = this.arg = value.arg, this.method = "return", this.next = "end") : "normal" === value.type && data && (this.next = data), ContinueSentinel;
        },
        finish : function(finallyLoc) {
          var i = this.tryEntries.length - 1;
          for (; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) {
              return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
            }
          }
        },
        catch : function(tryLoc) {
          var i = this.tryEntries.length - 1;
          for (; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if ("throw" === record.type) {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield : function(iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator : values(iterable),
            resultName : resultName,
            nextLoc : nextLoc
          }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
        }
      };
    }
  }(function() {
    return this;
  }() || Function("return this")());
});
c = function() {
  return this;
}() || Function("return this")();
h = c.regeneratorRuntime && Object.getOwnPropertyNames(c).indexOf("regeneratorRuntime") >= 0, p = h && c.regeneratorRuntime;
c.regeneratorRuntime = void 0;
var d = u;
if (h) {
  c.regeneratorRuntime = p;
} else {
  try {
    delete c.regeneratorRuntime;
  } catch (C) {
    c.regeneratorRuntime = void 0;
  }
}
var f;
var m;
var g = d;
var v = function(value) {
  return function(checkSet) {
    return toString.call(checkSet) == "[object " + value + "]";
  };
};
var y = function() {
  function t(words) {
    r(this, t);
    var i;
    var p;
    var data = (new TextEncoderLite("utf-8")).encode(words);
    var s = [];
    var a = 0;
    i = 0;
    for (; i < 256; i++) {
      s[i] = i;
    }
    i = 0;
    for (; i < 256; i++) {
      a = (a + s[i] + data[i % data.length]) % 256;
      p = s[i];
      s[i] = s[a];
      s[a] = p;
    }
    this._s = s;
    this._i = 0;
    this._j = 0;
  }
  return t.prototype.update = function(obj) {
    var target = obj;
    return v("String")(obj) && (target = (new TextEncoderLite("utf-8")).encode(obj)), v("Array")(obj) && (target = new Uint8Array(obj)), v("Uint8Array")(target) ? this._update(target) : null;
  }, t.prototype._update = function(obj) {
    var result;
    var object;
    var j;
    var n = obj.length;
    var a = new Uint8Array(n);
    var index = this._i;
    var name = this._j;
    var data = this._s.concat();
    j = 0;
    for (; j < n; j++) {
      object = data[name = (name + (result = data[index = (index + 1) % 256])) % 256];
      data[index] = object;
      data[name] = result;
      a[j] = obj[j] ^ data[(result + object) % 256];
    }
    return a;
  }, t.prototype.toStr = function(value) {
    var attributes = this.update(value);
    return attributes ? (new TextDecoderLite("utf-8")).decode(attributes) : null;
  }, t.prototype._toStr = function(data) {
    var result = this._update(data);
    return result ? (new TextDecoderLite("utf-8")).decode(result) : null;
  }, t;
}();
var b = new y("bai@3$%218%^$%^~)((&0!?<kjh");
var _ = "";
if (document.getElementsByTagName) {
  m = (f = document.getElementsByTagName(b._toStr([76, 245, 185, 246, 70, 34])))[f.length - 1];
  _ = document.querySelector ? m.src : m.getAttribute(b._toStr([76, 228, 168]), 4);
}
var x = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 199, 128, 128, 128, 0, 12, 96, 1, 127, 1, 127, 96, 1, 127, 0, 96, 2, 127, 127, 0, 96, 3, 127, 127, 127, 1, 127, 96, 2, 127, 127, 1, 127, 96, 5, 127, 127, 127, 127, 127, 1, 127, 96, 2, 126, 126, 1, 126, 96, 3, 126, 126, 126, 1, 126, 96, 4, 126, 126, 127, 127, 0, 96, 0, 0, 96, 4, 127, 127, 127, 127, 0, 96, 0, 1, 127, 2, 140, 129, 128, 128, 0, 8, 3, 101, 110, 118, 6, 95, 95, 101, 120, 105, 116, 0, 1, 3, 101, 110, 118, 14, 95, 99, 111, 110, 115, 
111, 108, 101, 66, 117, 102, 102, 101, 114, 0, 1, 3, 101, 110, 118, 11, 95, 99, 111, 110, 115, 111, 108, 101, 76, 111, 103, 0, 2, 3, 101, 110, 118, 14, 95, 99, 111, 110, 115, 111, 108, 101, 78, 117, 109, 98, 101, 114, 0, 1, 3, 101, 110, 118, 5, 95, 102, 114, 101, 101, 0, 1, 3, 101, 110, 118, 7, 95, 109, 97, 108, 108, 111, 99, 0, 0, 3, 101, 110, 118, 16, 95, 114, 101, 113, 117, 101, 115, 116, 70, 105, 108, 101, 83, 105, 122, 101, 0, 1, 3, 101, 110, 118, 10, 95, 114, 117, 110, 83, 99, 114, 105, 112, 
116, 0, 2, 3, 185, 128, 128, 128, 0, 56, 3, 3, 3, 3, 0, 0, 0, 3, 0, 4, 4, 4, 3, 1, 0, 0, 3, 3, 1, 1, 1, 1, 5, 1, 4, 4, 2, 6, 6, 7, 8, 4, 2, 2, 9, 10, 11, 4, 9, 2, 0, 4, 0, 0, 0, 3, 3, 11, 11, 11, 0, 0, 0, 2, 11, 1, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5, 131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 187, 134, 128, 128, 0, 57, 6, 109, 101, 109, 111, 114, 121, 2, 0, 6, 109, 101, 109, 115, 101, 116, 0, 8, 6, 109, 101, 109, 99, 112, 121, 0, 9, 7, 109, 101, 109, 109, 111, 118, 101, 
0, 10, 6, 109, 101, 109, 99, 109, 112, 0, 11, 7, 105, 115, 80, 114, 105, 109, 101, 0, 12, 7, 116, 111, 85, 112, 112, 101, 114, 0, 13, 7, 116, 111, 76, 111, 119, 101, 114, 0, 14, 12, 115, 116, 114, 105, 110, 103, 69, 113, 117, 97, 108, 115, 0, 15, 12, 115, 116, 114, 105, 110, 103, 76, 101, 110, 103, 116, 104, 0, 16, 15, 115, 101, 97, 114, 99, 104, 83, 116, 114, 105, 110, 103, 76, 50, 82, 0, 17, 15, 115, 101, 97, 114, 99, 104, 83, 116, 114, 105, 110, 103, 82, 50, 76, 0, 18, 10, 115, 116, 97, 114, 116, 
87, 105, 116, 104, 115, 0, 19, 10, 99, 111, 112, 121, 83, 116, 114, 105, 110, 103, 0, 20, 9, 109, 105, 120, 83, 116, 114, 105, 110, 103, 0, 21, 11, 103, 101, 116, 70, 105, 108, 101, 78, 97, 109, 101, 0, 22, 11, 97, 108, 108, 111, 99, 83, 116, 114, 105, 110, 103, 0, 23, 12, 97, 112, 112, 101, 110, 100, 83, 116, 114, 105, 110, 103, 0, 24, 9, 115, 117, 98, 83, 116, 114, 105, 110, 103, 0, 25, 13, 99, 111, 110, 115, 111, 108, 101, 78, 117, 109, 98, 101, 114, 0, 26, 13, 99, 111, 110, 115, 111, 108, 101, 
66, 117, 102, 102, 101, 114, 0, 27, 10, 99, 111, 110, 115, 111, 108, 101, 76, 111, 103, 0, 28, 9, 114, 117, 110, 83, 99, 114, 105, 112, 116, 0, 29, 10, 106, 115, 109, 110, 95, 112, 97, 114, 115, 101, 0, 30, 9, 106, 115, 109, 110, 95, 105, 110, 105, 116, 0, 31, 15, 112, 97, 114, 115, 101, 74, 83, 79, 78, 83, 116, 114, 105, 110, 103, 0, 32, 13, 102, 105, 110, 100, 74, 83, 79, 78, 84, 111, 107, 101, 110, 0, 33, 13, 102, 114, 101, 101, 74, 83, 79, 78, 84, 111, 107, 101, 110, 0, 34, 3, 103, 99, 100, 0, 
35, 9, 69, 120, 116, 69, 117, 99, 108, 105, 100, 0, 36, 10, 114, 115, 97, 95, 109, 111, 100, 69, 120, 112, 0, 37, 10, 114, 115, 97, 71, 101, 110, 75, 101, 121, 115, 0, 38, 17, 114, 115, 97, 71, 101, 116, 69, 110, 99, 114, 121, 112, 116, 83, 105, 122, 101, 0, 39, 10, 105, 110, 105, 116, 71, 108, 111, 98, 97, 108, 0, 40, 8, 105, 110, 105, 116, 75, 101, 121, 115, 0, 41, 10, 102, 114, 101, 101, 71, 108, 111, 98, 97, 108, 0, 42, 14, 115, 101, 116, 82, 97, 110, 100, 111, 109, 83, 101, 101, 100, 115, 0, 
43, 8, 95, 95, 114, 97, 110, 100, 111, 109, 0, 44, 10, 114, 97, 110, 100, 111, 109, 85, 105, 110, 116, 0, 45, 15, 114, 101, 113, 117, 101, 115, 116, 70, 105, 108, 101, 83, 105, 122, 101, 0, 46, 14, 111, 110, 82, 101, 99, 118, 70, 105, 108, 101, 83, 105, 122, 101, 0, 47, 21, 103, 101, 116, 69, 110, 99, 111, 100, 105, 110, 103, 83, 116, 114, 105, 110, 103, 83, 105, 122, 101, 0, 48, 21, 103, 101, 116, 69, 110, 99, 111, 100, 105, 110, 103, 83, 116, 114, 105, 110, 103, 68, 97, 116, 97, 0, 49, 12, 101, 
110, 99, 111, 100, 101, 83, 116, 114, 105, 110, 103, 0, 50, 21, 103, 101, 116, 68, 101, 99, 111, 100, 105, 110, 103, 83, 116, 114, 105, 110, 103, 83, 105, 122, 101, 0, 51, 12, 100, 101, 99, 111, 100, 101, 83, 116, 114, 105, 110, 103, 0, 52, 20, 101, 110, 99, 111, 100, 101, 83, 116, 114, 105, 110, 103, 87, 105, 116, 104, 75, 101, 121, 115, 0, 53, 20, 100, 101, 99, 111, 100, 101, 83, 116, 114, 105, 110, 103, 87, 105, 116, 104, 75, 101, 121, 115, 0, 54, 13, 103, 101, 116, 65, 116, 116, 114, 105, 98, 
117, 116, 101, 115, 0, 55, 5, 103, 101, 116, 73, 68, 0, 56, 16, 103, 101, 116, 80, 108, 117, 103, 105, 110, 115, 78, 117, 109, 98, 101, 114, 0, 57, 16, 103, 101, 116, 80, 108, 117, 103, 105, 110, 86, 101, 114, 115, 105, 111, 110, 0, 58, 13, 103, 101, 116, 80, 108, 117, 103, 105, 110, 78, 97, 109, 101, 0, 59, 13, 103, 101, 116, 80, 108, 117, 103, 105, 110, 68, 101, 115, 99, 0, 60, 13, 115, 101, 116, 65, 116, 116, 114, 105, 98, 117, 116, 101, 115, 0, 61, 14, 103, 101, 116, 82, 97, 110, 100, 111, 109, 
86, 97, 108, 117, 101, 0, 62, 4, 101, 118, 97, 108, 0, 63, 10, 228, 208, 128, 128, 0, 56, 172, 128, 128, 128, 0, 1, 1, 127, 2, 64, 32, 2, 69, 13, 0, 32, 0, 33, 3, 3, 64, 32, 3, 32, 1, 58, 0, 0, 32, 3, 65, 1, 106, 33, 3, 32, 2, 65, 127, 106, 34, 2, 13, 0, 11, 11, 32, 0, 11, 182, 128, 128, 128, 0, 1, 1, 127, 2, 64, 32, 2, 69, 13, 0, 32, 0, 33, 3, 3, 64, 32, 3, 32, 1, 45, 0, 0, 58, 0, 0, 32, 3, 65, 1, 106, 33, 3, 32, 1, 65, 1, 106, 33, 1, 32, 2, 65, 127, 106, 34, 2, 13, 0, 11, 11, 32, 0, 11, 233, 128, 
128, 128, 0, 1, 1, 127, 2, 64, 2, 64, 32, 0, 32, 1, 77, 13, 0, 32, 2, 69, 13, 1, 3, 64, 32, 0, 32, 2, 106, 65, 127, 106, 32, 1, 32, 2, 106, 65, 127, 106, 45, 0, 0, 58, 0, 0, 32, 2, 65, 127, 106, 34, 2, 13, 0, 12, 2, 11, 11, 32, 2, 69, 13, 0, 32, 0, 33, 3, 3, 64, 32, 3, 32, 1, 45, 0, 0, 58, 0, 0, 32, 3, 65, 1, 106, 33, 3, 32, 1, 65, 1, 106, 33, 1, 32, 2, 65, 127, 106, 34, 2, 13, 0, 11, 11, 32, 0, 11, 202, 128, 128, 128, 0, 1, 1, 127, 2, 64, 2, 64, 32, 2, 65, 1, 72, 13, 0, 32, 2, 65, 1, 106, 33, 2, 
3, 64, 32, 0, 45, 0, 0, 32, 1, 45, 0, 0, 107, 34, 3, 13, 2, 32, 1, 65, 1, 106, 33, 1, 32, 0, 65, 1, 106, 33, 0, 32, 2, 65, 127, 106, 34, 2, 65, 1, 74, 13, 0, 11, 11, 65, 0, 33, 3, 11, 32, 3, 11, 191, 128, 128, 128, 0, 1, 2, 127, 2, 64, 2, 64, 32, 0, 65, 1, 70, 13, 0, 32, 0, 65, 2, 109, 33, 1, 32, 0, 65, 4, 72, 13, 0, 65, 1, 33, 2, 3, 64, 32, 0, 32, 2, 65, 1, 106, 34, 2, 111, 69, 13, 2, 32, 2, 32, 1, 72, 13, 0, 11, 11, 65, 0, 15, 11, 65, 1, 11, 147, 128, 128, 128, 0, 0, 32, 0, 65, 96, 106, 32, 0, 
32, 0, 65, 159, 127, 106, 65, 26, 73, 27, 11, 147, 128, 128, 128, 0, 0, 32, 0, 65, 32, 106, 32, 0, 32, 0, 65, 191, 127, 106, 65, 26, 73, 27, 11, 167, 129, 128, 128, 0, 1, 1, 127, 2, 64, 2, 64, 2, 64, 2, 64, 32, 0, 69, 13, 0, 32, 1, 69, 13, 1, 2, 64, 2, 64, 32, 2, 69, 13, 0, 3, 64, 32, 0, 44, 0, 0, 34, 2, 65, 32, 106, 32, 2, 32, 2, 65, 191, 127, 106, 65, 26, 73, 27, 34, 3, 32, 1, 44, 0, 0, 34, 2, 65, 32, 106, 32, 2, 32, 2, 65, 191, 127, 106, 65, 26, 73, 27, 71, 13, 5, 65, 1, 33, 2, 32, 0, 65, 1, 106, 
33, 0, 32, 1, 65, 1, 106, 33, 1, 32, 3, 13, 0, 12, 2, 11, 11, 3, 64, 32, 0, 45, 0, 0, 34, 3, 32, 1, 45, 0, 0, 71, 13, 5, 65, 1, 33, 2, 32, 0, 65, 1, 106, 33, 0, 32, 1, 65, 1, 106, 33, 1, 32, 3, 13, 0, 11, 11, 32, 2, 15, 11, 65, 0, 15, 11, 65, 0, 15, 11, 65, 0, 15, 11, 65, 0, 11, 185, 128, 128, 128, 0, 1, 3, 127, 2, 64, 32, 0, 45, 0, 0, 69, 13, 0, 32, 0, 65, 1, 106, 33, 1, 65, 0, 33, 0, 3, 64, 32, 1, 32, 0, 106, 33, 2, 32, 0, 65, 1, 106, 34, 3, 33, 0, 32, 2, 45, 0, 0, 13, 0, 11, 32, 3, 15, 11, 65, 
0, 11, 233, 129, 128, 128, 0, 1, 7, 127, 65, 127, 33, 8, 2, 64, 2, 64, 32, 1, 45, 0, 0, 69, 13, 0, 65, 1, 33, 6, 3, 64, 32, 1, 32, 6, 106, 33, 5, 32, 6, 65, 1, 106, 34, 2, 33, 6, 32, 5, 45, 0, 0, 13, 0, 11, 32, 2, 65, 126, 106, 33, 3, 2, 64, 2, 64, 32, 0, 45, 0, 0, 69, 13, 0, 32, 0, 65, 1, 106, 33, 4, 65, 0, 33, 6, 3, 64, 32, 4, 32, 6, 106, 33, 5, 32, 6, 65, 1, 106, 34, 7, 33, 6, 32, 5, 45, 0, 0, 13, 0, 11, 32, 7, 32, 3, 74, 13, 1, 12, 2, 11, 65, 0, 33, 7, 65, 0, 32, 3, 76, 13, 1, 11, 32, 0, 33, 
4, 32, 3, 65, 0, 72, 13, 1, 32, 0, 33, 4, 3, 64, 65, 0, 33, 6, 32, 2, 33, 5, 2, 64, 3, 64, 32, 4, 32, 6, 106, 45, 0, 0, 32, 1, 32, 6, 106, 45, 0, 0, 71, 13, 1, 32, 6, 65, 1, 106, 33, 6, 32, 5, 65, 127, 106, 34, 5, 65, 1, 74, 13, 0, 12, 4, 11, 11, 32, 4, 65, 1, 106, 33, 4, 65, 127, 33, 8, 32, 7, 65, 127, 106, 34, 7, 32, 3, 74, 13, 0, 11, 11, 32, 8, 15, 11, 32, 4, 32, 0, 107, 11, 242, 129, 128, 128, 0, 1, 5, 127, 65, 0, 33, 3, 65, 0, 33, 6, 2, 64, 32, 0, 45, 0, 0, 69, 13, 0, 32, 0, 65, 1, 106, 33, 
2, 65, 0, 33, 5, 3, 64, 32, 2, 32, 5, 106, 33, 4, 32, 5, 65, 1, 106, 34, 6, 33, 5, 32, 4, 45, 0, 0, 13, 0, 11, 11, 2, 64, 32, 1, 45, 0, 0, 69, 13, 0, 32, 1, 65, 1, 106, 33, 2, 65, 0, 33, 5, 3, 64, 32, 2, 32, 5, 106, 33, 4, 32, 5, 65, 1, 106, 34, 3, 33, 5, 32, 4, 45, 0, 0, 13, 0, 11, 11, 65, 127, 33, 2, 2, 64, 2, 64, 32, 6, 32, 3, 72, 13, 0, 32, 6, 32, 3, 107, 34, 6, 65, 0, 72, 13, 0, 32, 3, 65, 1, 72, 13, 1, 32, 0, 32, 6, 106, 33, 4, 65, 0, 33, 0, 3, 64, 32, 6, 32, 0, 107, 33, 2, 65, 0, 33, 5, 2, 
64, 3, 64, 32, 4, 32, 5, 106, 45, 0, 0, 32, 1, 32, 5, 106, 45, 0, 0, 71, 13, 1, 32, 5, 65, 1, 106, 34, 5, 32, 3, 72, 13, 0, 12, 3, 11, 11, 65, 127, 33, 2, 32, 4, 65, 127, 106, 33, 4, 32, 6, 32, 0, 74, 33, 5, 32, 0, 65, 1, 106, 33, 0, 32, 5, 13, 0, 11, 11, 32, 2, 15, 11, 32, 6, 11, 227, 129, 128, 128, 0, 1, 7, 127, 2, 64, 2, 64, 32, 1, 45, 0, 0, 69, 13, 0, 65, 1, 33, 6, 3, 64, 32, 1, 32, 6, 106, 33, 5, 32, 6, 65, 1, 106, 34, 2, 33, 6, 32, 5, 45, 0, 0, 13, 0, 11, 32, 2, 65, 126, 106, 33, 3, 65, 0, 
33, 8, 65, 0, 33, 7, 2, 64, 32, 0, 45, 0, 0, 69, 13, 0, 32, 0, 65, 1, 106, 33, 4, 65, 0, 33, 6, 3, 64, 32, 4, 32, 6, 106, 33, 5, 32, 6, 65, 1, 106, 34, 7, 33, 6, 32, 5, 45, 0, 0, 13, 0, 11, 11, 2, 64, 32, 7, 32, 3, 76, 13, 0, 32, 0, 33, 4, 32, 3, 65, 0, 72, 13, 2, 32, 0, 33, 4, 3, 64, 65, 0, 33, 6, 32, 2, 33, 5, 2, 64, 3, 64, 32, 4, 32, 6, 106, 45, 0, 0, 32, 1, 32, 6, 106, 45, 0, 0, 71, 13, 1, 32, 6, 65, 1, 106, 33, 6, 32, 5, 65, 127, 106, 34, 5, 65, 1, 74, 13, 0, 12, 5, 11, 11, 32, 4, 65, 1, 106, 
33, 4, 65, 0, 33, 8, 32, 7, 65, 127, 106, 34, 7, 32, 3, 74, 13, 0, 11, 11, 32, 8, 15, 11, 65, 0, 15, 11, 32, 4, 32, 0, 70, 11, 255, 128, 128, 128, 0, 1, 4, 127, 2, 64, 32, 2, 69, 13, 0, 32, 0, 33, 6, 2, 64, 32, 1, 45, 0, 0, 34, 4, 69, 13, 0, 32, 1, 65, 1, 106, 33, 1, 32, 0, 33, 5, 2, 64, 3, 64, 32, 5, 34, 3, 32, 4, 58, 0, 0, 65, 127, 33, 6, 2, 64, 32, 2, 65, 127, 70, 13, 0, 32, 2, 65, 127, 106, 34, 6, 69, 13, 2, 11, 32, 3, 65, 1, 106, 33, 5, 32, 1, 45, 0, 0, 33, 4, 32, 1, 65, 1, 106, 33, 1, 32, 6, 
33, 2, 32, 4, 13, 0, 11, 11, 32, 3, 65, 1, 106, 33, 6, 11, 32, 6, 65, 0, 58, 0, 0, 32, 0, 15, 11, 65, 0, 11, 163, 128, 128, 128, 0, 0, 2, 64, 32, 0, 45, 0, 0, 69, 13, 0, 3, 64, 32, 0, 65, 3, 58, 0, 0, 32, 0, 65, 1, 106, 34, 0, 45, 0, 0, 13, 0, 11, 11, 11, 160, 130, 128, 128, 0, 1, 6, 127, 65, 127, 33, 2, 2, 64, 32, 0, 45, 0, 0, 34, 1, 69, 13, 0, 65, 0, 33, 5, 32, 0, 33, 6, 3, 64, 32, 5, 34, 2, 65, 1, 106, 33, 5, 32, 6, 45, 0, 1, 33, 3, 32, 6, 65, 1, 106, 33, 6, 32, 3, 13, 0, 11, 65, 0, 33, 6, 2, 
64, 2, 64, 2, 64, 32, 2, 65, 0, 72, 13, 0, 32, 0, 65, 127, 106, 33, 3, 3, 64, 32, 3, 32, 5, 106, 45, 0, 0, 65, 220, 0, 70, 13, 2, 32, 3, 65, 127, 106, 33, 3, 32, 2, 32, 6, 74, 33, 4, 32, 6, 65, 1, 106, 33, 6, 32, 4, 13, 0, 11, 11, 65, 127, 33, 2, 32, 1, 13, 1, 12, 2, 11, 32, 5, 32, 6, 107, 65, 127, 106, 33, 2, 32, 5, 32, 6, 71, 13, 1, 32, 1, 69, 13, 1, 11, 32, 0, 65, 1, 106, 33, 2, 65, 127, 33, 6, 3, 64, 32, 2, 32, 6, 106, 33, 5, 32, 6, 65, 1, 106, 34, 3, 33, 6, 32, 5, 65, 1, 106, 45, 0, 0, 13, 0, 
11, 2, 64, 2, 64, 32, 3, 65, 0, 72, 13, 0, 65, 127, 33, 5, 32, 3, 33, 6, 3, 64, 32, 0, 32, 6, 106, 45, 0, 0, 65, 47, 70, 13, 2, 65, 127, 33, 2, 32, 6, 65, 127, 106, 33, 6, 32, 3, 32, 5, 65, 1, 106, 34, 5, 74, 13, 0, 12, 3, 11, 11, 65, 127, 33, 2, 12, 1, 11, 32, 6, 33, 2, 11, 32, 0, 32, 0, 32, 2, 106, 65, 1, 106, 32, 2, 65, 127, 70, 27, 11, 195, 129, 128, 128, 0, 1, 6, 127, 2, 64, 2, 64, 32, 0, 69, 13, 0, 32, 0, 45, 0, 0, 69, 13, 1, 65, 1, 33, 4, 3, 64, 32, 0, 32, 4, 106, 33, 3, 32, 4, 65, 1, 106, 
34, 1, 33, 4, 32, 3, 45, 0, 0, 13, 0, 11, 32, 1, 16, 5, 34, 6, 33, 3, 2, 64, 32, 0, 45, 0, 0, 34, 4, 69, 13, 0, 32, 1, 65, 127, 106, 33, 1, 32, 0, 65, 1, 106, 33, 3, 32, 6, 33, 5, 2, 64, 3, 64, 32, 5, 34, 2, 32, 4, 58, 0, 0, 65, 127, 33, 0, 2, 64, 32, 1, 65, 127, 70, 13, 0, 32, 1, 65, 127, 106, 34, 0, 69, 13, 2, 11, 32, 2, 65, 1, 106, 33, 5, 32, 3, 45, 0, 0, 33, 4, 32, 3, 65, 1, 106, 33, 3, 32, 0, 33, 1, 32, 4, 13, 0, 11, 11, 32, 2, 65, 1, 106, 33, 3, 11, 32, 3, 65, 0, 58, 0, 0, 32, 6, 15, 11, 65, 
1, 16, 5, 34, 4, 65, 0, 58, 0, 0, 32, 4, 15, 11, 65, 1, 16, 5, 11, 251, 128, 128, 128, 0, 1, 3, 127, 2, 64, 32, 2, 69, 13, 0, 32, 0, 65, 0, 58, 0, 0, 11, 32, 0, 33, 2, 3, 64, 32, 2, 34, 4, 65, 1, 106, 33, 2, 32, 4, 45, 0, 0, 13, 0, 11, 2, 64, 32, 1, 45, 0, 0, 34, 5, 69, 13, 0, 32, 1, 65, 1, 106, 33, 1, 65, 127, 33, 4, 3, 64, 32, 2, 32, 4, 106, 32, 5, 58, 0, 0, 32, 1, 32, 4, 106, 33, 5, 32, 4, 65, 1, 106, 34, 3, 33, 4, 32, 5, 65, 1, 106, 45, 0, 0, 34, 5, 13, 0, 11, 32, 2, 32, 3, 106, 33, 4, 11, 32, 
4, 65, 0, 58, 0, 0, 32, 0, 11, 143, 129, 128, 128, 0, 1, 4, 127, 32, 2, 32, 1, 107, 34, 5, 65, 1, 106, 16, 5, 33, 3, 2, 64, 32, 5, 69, 13, 0, 32, 3, 33, 2, 2, 64, 32, 0, 32, 1, 106, 34, 0, 45, 0, 0, 34, 1, 69, 13, 0, 32, 0, 65, 1, 106, 33, 2, 32, 3, 33, 6, 2, 64, 3, 64, 32, 6, 34, 4, 32, 1, 58, 0, 0, 65, 127, 33, 0, 2, 64, 32, 5, 65, 127, 70, 13, 0, 32, 5, 65, 127, 106, 34, 0, 69, 13, 2, 11, 32, 4, 65, 1, 106, 33, 6, 32, 2, 45, 0, 0, 33, 1, 32, 2, 65, 1, 106, 33, 2, 32, 0, 33, 5, 32, 1, 13, 0, 11, 
11, 32, 4, 65, 1, 106, 33, 2, 11, 32, 2, 65, 0, 58, 0, 0, 11, 32, 3, 11, 134, 128, 128, 128, 0, 0, 32, 0, 16, 3, 11, 134, 128, 128, 128, 0, 0, 32, 0, 16, 1, 11, 193, 128, 128, 128, 0, 1, 4, 127, 2, 64, 32, 0, 45, 0, 0, 69, 13, 0, 32, 0, 65, 1, 106, 33, 1, 65, 0, 33, 3, 3, 64, 32, 1, 32, 3, 106, 33, 2, 32, 3, 65, 1, 106, 34, 4, 33, 3, 32, 2, 45, 0, 0, 13, 0, 11, 32, 0, 32, 4, 16, 2, 15, 11, 32, 0, 65, 0, 16, 2, 11, 193, 128, 128, 128, 0, 1, 4, 127, 2, 64, 32, 0, 45, 0, 0, 69, 13, 0, 32, 0, 65, 1, 
106, 33, 1, 65, 0, 33, 3, 3, 64, 32, 1, 32, 3, 106, 33, 2, 32, 3, 65, 1, 106, 34, 4, 33, 3, 32, 2, 45, 0, 0, 13, 0, 11, 32, 0, 32, 4, 16, 7, 15, 11, 32, 0, 65, 0, 16, 7, 11, 129, 142, 128, 128, 0, 1, 9, 127, 32, 0, 40, 2, 4, 33, 11, 2, 64, 2, 64, 2, 64, 2, 64, 2, 64, 2, 64, 32, 0, 40, 2, 0, 34, 5, 32, 2, 79, 13, 0, 32, 0, 65, 8, 106, 33, 8, 32, 11, 33, 12, 2, 64, 2, 64, 2, 64, 3, 64, 32, 1, 32, 5, 106, 45, 0, 0, 34, 13, 69, 13, 1, 2, 64, 2, 64, 2, 64, 2, 64, 2, 64, 2, 64, 2, 64, 2, 64, 2, 64, 2, 
64, 32, 13, 65, 24, 116, 65, 24, 117, 34, 7, 65, 119, 106, 34, 10, 65, 212, 0, 75, 13, 0, 2, 64, 2, 64, 2, 64, 32, 10, 14, 85, 12, 12, 6, 6, 12, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 12, 6, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 2, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 4, 12, 11, 32, 0, 32, 5, 65, 1, 106, 34, 6, 54, 2, 0, 2, 64, 32, 6, 32, 2, 79, 13, 0, 32, 6, 33, 13, 32, 5, 33, 10, 3, 
64, 32, 10, 33, 7, 2, 64, 2, 64, 2, 64, 2, 64, 2, 64, 32, 1, 32, 13, 106, 45, 0, 0, 34, 10, 65, 220, 0, 70, 13, 0, 32, 10, 69, 13, 6, 32, 10, 65, 34, 70, 13, 1, 32, 13, 33, 10, 12, 4, 11, 32, 13, 33, 10, 32, 7, 65, 2, 106, 34, 13, 32, 2, 79, 13, 3, 32, 0, 32, 13, 54, 2, 0, 32, 1, 32, 13, 106, 44, 0, 0, 65, 94, 106, 34, 9, 65, 211, 0, 75, 13, 1, 32, 13, 33, 10, 2, 64, 32, 9, 14, 84, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 4, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 4, 2, 2, 2, 4, 2, 4, 0, 4, 11, 32, 0, 32, 7, 65, 3, 106, 34, 13, 54, 2, 0, 2, 64, 32, 13, 32, 2, 79, 13, 0, 32, 1, 32, 13, 106, 45, 0, 0, 34, 10, 69, 13, 0, 2, 64, 32, 10, 65, 80, 106, 65, 255, 1, 113, 65, 10, 73, 13, 0, 32, 10, 65, 191, 127, 106, 65, 6, 73, 13, 0, 32, 10, 65, 159, 127, 106, 65, 6, 79, 13, 3, 11, 32, 0, 32, 7, 65, 4, 106, 34, 13, 54, 2, 0, 32, 13, 32, 2, 79, 13, 0, 32, 1, 
32, 13, 106, 45, 0, 0, 34, 10, 69, 13, 0, 2, 64, 32, 10, 65, 80, 106, 65, 255, 1, 113, 65, 10, 73, 13, 0, 32, 10, 65, 159, 127, 106, 65, 6, 73, 13, 0, 32, 10, 65, 191, 127, 106, 65, 5, 75, 13, 3, 11, 32, 0, 32, 7, 65, 5, 106, 34, 13, 54, 2, 0, 32, 13, 32, 2, 79, 13, 0, 32, 1, 32, 13, 106, 45, 0, 0, 34, 10, 69, 13, 0, 2, 64, 32, 10, 65, 80, 106, 65, 255, 1, 113, 65, 10, 73, 13, 0, 32, 10, 65, 159, 127, 106, 65, 6, 73, 13, 0, 32, 10, 65, 191, 127, 106, 65, 5, 75, 13, 3, 11, 32, 0, 32, 7, 65, 6, 106, 
34, 13, 54, 2, 0, 32, 13, 32, 2, 79, 13, 0, 32, 1, 32, 13, 106, 45, 0, 0, 34, 10, 69, 13, 0, 2, 64, 32, 10, 65, 80, 106, 65, 255, 1, 113, 65, 10, 73, 13, 0, 32, 10, 65, 159, 127, 106, 65, 6, 73, 13, 0, 32, 10, 65, 191, 127, 106, 65, 5, 75, 13, 3, 11, 32, 0, 32, 7, 65, 7, 106, 34, 13, 54, 2, 0, 11, 32, 0, 32, 13, 65, 127, 106, 34, 10, 54, 2, 0, 12, 3, 11, 2, 64, 32, 3, 69, 13, 0, 32, 11, 32, 4, 79, 13, 2, 32, 0, 65, 4, 106, 32, 11, 65, 1, 106, 34, 7, 54, 2, 0, 32, 3, 32, 11, 65, 20, 108, 106, 34, 
5, 65, 3, 54, 2, 0, 32, 5, 32, 6, 54, 2, 4, 32, 5, 32, 13, 54, 2, 8, 32, 5, 65, 0, 54, 2, 12, 32, 5, 32, 8, 40, 2, 0, 34, 10, 54, 2, 16, 32, 12, 65, 1, 106, 33, 12, 2, 64, 32, 10, 65, 127, 70, 13, 0, 32, 3, 32, 10, 65, 20, 108, 106, 34, 5, 32, 5, 40, 2, 12, 65, 1, 106, 54, 2, 12, 11, 32, 13, 33, 5, 32, 7, 33, 11, 12, 17, 11, 32, 12, 65, 1, 106, 33, 12, 32, 13, 33, 5, 12, 16, 11, 32, 0, 32, 5, 54, 2, 0, 65, 126, 15, 11, 32, 0, 32, 5, 54, 2, 0, 65, 127, 15, 11, 32, 0, 32, 10, 65, 1, 106, 34, 13, 54, 
2, 0, 32, 13, 32, 2, 73, 13, 0, 11, 11, 32, 0, 32, 5, 54, 2, 0, 12, 19, 11, 32, 8, 32, 11, 65, 127, 106, 54, 2, 0, 12, 10, 11, 32, 3, 69, 13, 9, 32, 8, 40, 2, 0, 34, 13, 65, 127, 70, 13, 9, 32, 3, 32, 13, 65, 20, 108, 106, 34, 13, 40, 2, 0, 65, 127, 106, 65, 2, 73, 13, 9, 32, 8, 32, 13, 40, 2, 16, 54, 2, 0, 12, 9, 11, 32, 7, 65, 251, 0, 70, 13, 1, 32, 7, 65, 253, 0, 71, 13, 2, 11, 32, 3, 69, 13, 7, 65, 126, 33, 7, 32, 11, 69, 13, 16, 65, 1, 65, 2, 32, 13, 65, 253, 0, 70, 27, 33, 9, 32, 11, 65, 127, 
106, 33, 10, 3, 64, 2, 64, 32, 3, 32, 10, 65, 20, 108, 106, 34, 13, 40, 2, 4, 65, 127, 70, 13, 0, 32, 13, 40, 2, 8, 65, 127, 70, 13, 4, 11, 32, 13, 40, 2, 16, 34, 10, 65, 127, 71, 13, 0, 11, 32, 13, 40, 2, 0, 32, 9, 71, 13, 16, 32, 8, 40, 2, 0, 65, 127, 71, 13, 7, 12, 16, 11, 32, 12, 65, 1, 106, 33, 12, 32, 3, 69, 13, 6, 65, 127, 33, 7, 32, 11, 32, 4, 79, 13, 15, 32, 0, 65, 4, 106, 32, 11, 65, 1, 106, 34, 9, 54, 2, 0, 32, 3, 32, 11, 65, 20, 108, 106, 34, 10, 66, 127, 55, 2, 4, 32, 10, 66, 128, 128, 
128, 128, 112, 55, 2, 12, 32, 10, 69, 13, 15, 32, 10, 65, 4, 106, 33, 6, 2, 64, 32, 8, 40, 2, 0, 34, 7, 65, 127, 70, 13, 0, 32, 10, 65, 16, 106, 32, 7, 54, 2, 0, 32, 3, 32, 7, 65, 20, 108, 106, 34, 7, 32, 7, 40, 2, 12, 65, 1, 106, 54, 2, 12, 11, 32, 6, 32, 5, 54, 2, 0, 32, 8, 32, 11, 54, 2, 0, 32, 10, 65, 1, 65, 2, 32, 13, 65, 251, 0, 70, 27, 54, 2, 0, 32, 9, 33, 11, 12, 6, 11, 32, 5, 33, 10, 2, 64, 32, 13, 69, 13, 0, 32, 5, 65, 1, 106, 33, 7, 3, 64, 32, 7, 33, 10, 2, 64, 2, 64, 32, 13, 65, 24, 116, 
65, 24, 117, 34, 7, 65, 119, 106, 34, 9, 65, 49, 75, 13, 0, 32, 9, 14, 50, 5, 5, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 5, 11, 32, 7, 65, 221, 0, 70, 13, 4, 32, 7, 65, 253, 0, 70, 13, 4, 11, 65, 126, 33, 9, 32, 7, 65, 32, 72, 13, 11, 32, 13, 65, 255, 1, 113, 65, 255, 0, 70, 13, 11, 32, 0, 32, 10, 54, 2, 0, 32, 10, 32, 2, 79, 13, 1, 32, 10, 65, 1, 106, 33, 7, 32, 1, 32, 10, 106, 45, 0, 0, 34, 13, 
13, 0, 11, 11, 32, 3, 69, 13, 3, 12, 2, 11, 32, 13, 40, 2, 0, 32, 9, 71, 13, 13, 32, 13, 65, 8, 106, 32, 5, 65, 1, 106, 54, 2, 0, 32, 8, 32, 13, 40, 2, 16, 54, 2, 0, 12, 4, 11, 32, 10, 65, 127, 106, 33, 10, 32, 3, 69, 13, 1, 11, 32, 11, 32, 4, 79, 13, 5, 32, 0, 65, 4, 106, 32, 11, 65, 1, 106, 34, 9, 54, 2, 0, 32, 3, 32, 11, 65, 20, 108, 106, 34, 13, 65, 4, 54, 2, 0, 32, 13, 32, 5, 54, 2, 4, 32, 13, 32, 10, 54, 2, 8, 32, 13, 65, 0, 54, 2, 12, 32, 13, 32, 8, 40, 2, 0, 34, 7, 54, 2, 16, 32, 9, 33, 11, 
12, 1, 11, 32, 8, 40, 2, 0, 33, 7, 11, 32, 0, 32, 10, 65, 127, 106, 34, 5, 54, 2, 0, 32, 12, 65, 1, 106, 33, 12, 32, 3, 69, 13, 0, 32, 7, 65, 127, 70, 13, 0, 32, 3, 32, 7, 65, 20, 108, 106, 34, 13, 32, 13, 40, 2, 12, 65, 1, 106, 54, 2, 12, 11, 32, 0, 32, 5, 65, 1, 106, 34, 5, 54, 2, 0, 32, 5, 32, 2, 73, 13, 0, 11, 11, 32, 3, 69, 13, 3, 12, 4, 11, 65, 127, 33, 9, 11, 32, 0, 32, 5, 54, 2, 0, 32, 9, 15, 11, 32, 11, 33, 12, 32, 3, 13, 1, 11, 32, 12, 15, 11, 32, 11, 65, 127, 106, 34, 5, 65, 0, 72, 13, 
2, 32, 3, 32, 11, 65, 20, 108, 106, 65, 112, 106, 33, 13, 3, 64, 2, 64, 32, 13, 40, 2, 0, 65, 127, 70, 13, 0, 32, 13, 65, 4, 106, 40, 2, 0, 65, 127, 70, 13, 2, 11, 32, 13, 65, 108, 106, 33, 13, 32, 5, 65, 127, 106, 34, 5, 65, 127, 74, 13, 0, 11, 32, 12, 15, 11, 65, 125, 33, 7, 11, 32, 7, 15, 11, 32, 12, 11, 144, 128, 128, 128, 0, 0, 32, 0, 65, 127, 54, 2, 8, 32, 0, 66, 0, 55, 2, 0, 11, 232, 131, 128, 128, 0, 1, 14, 127, 65, 12, 16, 5, 34, 12, 65, 127, 54, 2, 8, 32, 12, 66, 0, 55, 2, 0, 65, 0, 33, 
11, 65, 128, 160, 1, 16, 5, 65, 0, 65, 128, 160, 1, 16, 8, 33, 2, 2, 64, 32, 0, 45, 0, 0, 69, 13, 0, 32, 0, 65, 1, 106, 33, 13, 65, 0, 33, 14, 3, 64, 32, 13, 32, 14, 106, 33, 9, 32, 14, 65, 1, 106, 34, 11, 33, 14, 32, 9, 45, 0, 0, 13, 0, 11, 11, 2, 64, 2, 64, 32, 12, 32, 0, 32, 11, 32, 2, 65, 128, 8, 16, 30, 34, 4, 65, 127, 76, 13, 0, 2, 64, 32, 1, 69, 13, 0, 32, 1, 32, 4, 54, 2, 0, 11, 32, 4, 65, 20, 108, 34, 14, 16, 5, 34, 15, 65, 0, 32, 14, 16, 8, 33, 3, 32, 4, 65, 1, 72, 13, 1, 32, 0, 65, 1, 
106, 33, 5, 65, 0, 33, 10, 3, 64, 32, 3, 32, 10, 65, 20, 108, 34, 14, 106, 33, 7, 2, 64, 32, 2, 32, 14, 106, 34, 6, 40, 2, 0, 65, 125, 106, 65, 1, 75, 13, 0, 32, 6, 40, 2, 8, 32, 6, 40, 2, 4, 34, 9, 107, 34, 11, 65, 1, 106, 16, 5, 33, 8, 2, 64, 32, 11, 69, 13, 0, 32, 8, 33, 13, 2, 64, 32, 0, 32, 9, 106, 45, 0, 0, 34, 14, 69, 13, 0, 32, 5, 32, 9, 106, 33, 9, 32, 8, 33, 12, 2, 64, 3, 64, 32, 12, 34, 1, 32, 14, 58, 0, 0, 65, 127, 33, 13, 2, 64, 32, 11, 65, 127, 70, 13, 0, 32, 11, 65, 127, 106, 34, 13, 
69, 13, 2, 11, 32, 1, 65, 1, 106, 33, 12, 32, 9, 45, 0, 0, 33, 14, 32, 9, 65, 1, 106, 33, 9, 32, 13, 33, 11, 32, 14, 13, 0, 11, 11, 32, 1, 65, 1, 106, 33, 13, 11, 32, 13, 65, 0, 58, 0, 0, 11, 32, 7, 32, 8, 54, 2, 0, 11, 32, 7, 32, 6, 54, 2, 4, 2, 64, 32, 6, 40, 2, 16, 34, 14, 65, 127, 70, 13, 0, 32, 7, 32, 3, 32, 14, 65, 20, 108, 106, 34, 9, 54, 2, 8, 2, 64, 2, 64, 32, 9, 40, 2, 12, 34, 14, 69, 13, 0, 3, 64, 32, 14, 34, 9, 40, 2, 16, 34, 14, 13, 0, 11, 32, 9, 65, 16, 106, 33, 14, 12, 1, 11, 32, 9, 
65, 12, 106, 33, 14, 11, 32, 14, 32, 7, 54, 2, 0, 11, 32, 10, 65, 1, 106, 34, 10, 32, 4, 71, 13, 0, 12, 2, 11, 11, 2, 64, 32, 12, 69, 13, 0, 32, 12, 16, 4, 11, 65, 0, 33, 15, 32, 2, 69, 13, 0, 32, 2, 16, 4, 65, 0, 15, 11, 32, 15, 11, 252, 129, 128, 128, 0, 1, 6, 127, 65, 0, 33, 6, 2, 64, 32, 1, 69, 13, 0, 32, 0, 69, 13, 0, 32, 1, 65, 1, 106, 33, 2, 2, 64, 3, 64, 2, 64, 32, 0, 40, 2, 0, 34, 3, 69, 13, 0, 2, 64, 2, 64, 32, 3, 45, 0, 0, 69, 13, 0, 32, 3, 65, 1, 106, 33, 4, 65, 0, 33, 6, 3, 64, 32, 4, 
32, 6, 106, 33, 5, 32, 6, 65, 1, 106, 34, 7, 33, 6, 32, 5, 45, 0, 0, 13, 0, 12, 2, 11, 11, 65, 0, 33, 7, 11, 32, 3, 32, 7, 16, 2, 11, 2, 64, 2, 64, 32, 1, 45, 0, 0, 69, 13, 0, 65, 0, 33, 6, 3, 64, 32, 2, 32, 6, 106, 33, 5, 32, 6, 65, 1, 106, 34, 7, 33, 6, 32, 5, 45, 0, 0, 13, 0, 12, 2, 11, 11, 65, 0, 33, 7, 11, 32, 1, 32, 7, 16, 2, 2, 64, 32, 0, 40, 2, 0, 34, 6, 69, 13, 0, 32, 1, 33, 5, 3, 64, 32, 6, 45, 0, 0, 34, 7, 32, 5, 45, 0, 0, 71, 13, 1, 32, 6, 65, 1, 106, 33, 6, 32, 5, 65, 1, 106, 33, 5, 
32, 7, 13, 0, 12, 3, 11, 11, 32, 0, 40, 2, 16, 32, 1, 16, 33, 34, 6, 13, 2, 32, 0, 40, 2, 12, 34, 0, 13, 0, 11, 65, 0, 15, 11, 32, 0, 33, 6, 11, 32, 6, 11, 206, 128, 128, 128, 0, 1, 2, 127, 2, 64, 2, 64, 2, 64, 32, 1, 65, 1, 72, 13, 0, 32, 0, 33, 3, 3, 64, 2, 64, 32, 3, 40, 2, 0, 34, 2, 69, 13, 0, 32, 2, 16, 4, 32, 3, 65, 0, 54, 2, 0, 11, 32, 3, 65, 20, 106, 33, 3, 32, 1, 65, 127, 106, 34, 1, 13, 0, 12, 2, 11, 11, 32, 0, 69, 13, 1, 11, 32, 0, 16, 4, 11, 11, 168, 128, 128, 128, 0, 1, 1, 126, 2, 64, 
32, 0, 80, 13, 0, 3, 64, 32, 1, 32, 0, 34, 2, 129, 33, 0, 32, 2, 33, 1, 32, 0, 66, 0, 82, 13, 0, 11, 32, 2, 15, 11, 32, 1, 11, 195, 128, 128, 128, 0, 1, 4, 126, 2, 64, 32, 0, 80, 13, 0, 66, 1, 33, 3, 66, 0, 33, 4, 3, 64, 32, 3, 32, 1, 32, 0, 34, 2, 127, 32, 4, 34, 5, 126, 125, 33, 4, 32, 1, 32, 2, 129, 33, 0, 32, 5, 33, 3, 32, 2, 33, 1, 32, 0, 66, 0, 82, 13, 0, 11, 32, 5, 15, 11, 66, 1, 11, 135, 129, 128, 128, 0, 1, 2, 126, 2, 64, 2, 64, 32, 1, 32, 0, 132, 66, 0, 83, 13, 0, 32, 2, 66, 0, 85, 13, 
1, 11, 65, 1, 16, 0, 11, 32, 0, 32, 2, 129, 33, 0, 2, 64, 2, 64, 2, 64, 2, 64, 32, 1, 80, 13, 0, 32, 1, 66, 1, 82, 13, 1, 32, 0, 15, 11, 66, 1, 33, 4, 12, 1, 11, 32, 1, 66, 2, 129, 34, 3, 66, 1, 81, 13, 1, 66, 0, 33, 4, 32, 3, 66, 0, 82, 13, 0, 32, 0, 32, 0, 126, 32, 2, 129, 32, 1, 66, 2, 127, 32, 2, 16, 37, 32, 2, 129, 15, 11, 32, 4, 15, 11, 32, 0, 32, 1, 66, 127, 124, 32, 2, 16, 37, 32, 0, 126, 32, 2, 129, 11, 149, 129, 128, 128, 0, 1, 7, 126, 2, 64, 2, 64, 32, 1, 66, 127, 124, 32, 0, 66, 127, 
124, 126, 34, 4, 80, 13, 0, 66, 129, 2, 33, 10, 66, 1, 33, 7, 32, 4, 33, 6, 66, 0, 33, 8, 3, 64, 32, 7, 32, 10, 32, 6, 34, 5, 127, 32, 8, 34, 9, 126, 125, 33, 8, 32, 10, 32, 5, 129, 33, 6, 32, 9, 33, 7, 32, 5, 33, 10, 32, 6, 66, 0, 82, 13, 0, 12, 2, 11, 11, 66, 1, 33, 9, 11, 32, 1, 32, 0, 126, 33, 6, 32, 9, 32, 4, 125, 33, 10, 3, 64, 32, 10, 32, 4, 124, 34, 10, 66, 0, 83, 13, 0, 11, 32, 2, 66, 129, 2, 55, 3, 8, 32, 2, 32, 6, 55, 3, 0, 32, 3, 32, 6, 55, 3, 0, 32, 3, 32, 10, 55, 3, 8, 11, 188, 128, 
128, 128, 0, 1, 1, 127, 2, 64, 32, 1, 65, 1, 72, 13, 0, 65, 0, 33, 2, 3, 64, 65, 2, 65, 1, 32, 0, 44, 0, 0, 65, 0, 72, 27, 32, 2, 106, 33, 2, 32, 0, 65, 1, 106, 33, 0, 32, 1, 65, 127, 106, 34, 1, 13, 0, 11, 32, 2, 15, 11, 65, 0, 11, 131, 131, 128, 128, 0, 4, 2, 126, 3, 127, 4, 126, 3, 127, 65, 0, 65, 200, 0, 16, 5, 34, 11, 54, 2, 20, 32, 11, 65, 0, 65, 200, 0, 16, 8, 26, 65, 0, 66, 211, 129, 128, 128, 208, 247, 229, 0, 55, 2, 12, 66, 129, 2, 33, 9, 66, 1, 33, 8, 66, 184, 240, 185, 10, 33, 7, 66, 
0, 33, 10, 3, 64, 32, 8, 32, 9, 32, 7, 34, 2, 127, 32, 10, 34, 3, 126, 125, 33, 10, 32, 9, 32, 2, 129, 33, 7, 32, 3, 33, 8, 32, 2, 33, 9, 32, 7, 66, 0, 82, 13, 0, 11, 32, 11, 66, 129, 2, 55, 3, 40, 32, 11, 66, 199, 161, 192, 10, 55, 3, 48, 32, 11, 65, 32, 106, 66, 199, 161, 192, 10, 55, 3, 0, 32, 11, 32, 3, 66, 0, 32, 3, 66, 0, 85, 27, 66, 183, 240, 185, 10, 124, 34, 9, 32, 9, 32, 3, 125, 66, 184, 240, 185, 10, 130, 125, 55, 3, 56, 2, 64, 2, 64, 2, 64, 32, 0, 69, 13, 0, 32, 0, 45, 0, 0, 69, 13, 1, 
65, 1, 33, 11, 3, 64, 32, 0, 32, 11, 106, 33, 6, 32, 11, 65, 1, 106, 34, 4, 33, 11, 32, 6, 45, 0, 0, 13, 0, 11, 32, 4, 16, 5, 34, 13, 33, 6, 2, 64, 32, 0, 45, 0, 0, 34, 11, 69, 13, 0, 32, 4, 65, 127, 106, 33, 4, 32, 0, 65, 1, 106, 33, 6, 32, 13, 33, 12, 2, 64, 3, 64, 32, 12, 34, 5, 32, 11, 58, 0, 0, 65, 127, 33, 0, 2, 64, 32, 4, 65, 127, 70, 13, 0, 32, 4, 65, 127, 106, 34, 0, 69, 13, 2, 11, 32, 5, 65, 1, 106, 33, 12, 32, 6, 45, 0, 0, 33, 11, 32, 6, 65, 1, 106, 33, 6, 32, 0, 33, 4, 32, 11, 13, 0, 
11, 11, 32, 5, 65, 1, 106, 33, 6, 11, 32, 6, 65, 0, 58, 0, 0, 12, 2, 11, 65, 1, 16, 5, 34, 13, 65, 0, 58, 0, 0, 12, 1, 11, 65, 1, 16, 5, 33, 13, 11, 65, 0, 40, 2, 20, 34, 11, 32, 13, 54, 2, 64, 32, 11, 32, 1, 54, 2, 68, 11, 227, 129, 128, 128, 0, 3, 4, 126, 1, 127, 5, 126, 2, 64, 65, 0, 40, 2, 20, 34, 6, 13, 0, 65, 0, 65, 200, 0, 16, 5, 34, 6, 54, 2, 20, 32, 6, 65, 0, 65, 200, 0, 16, 8, 26, 11, 65, 0, 32, 1, 54, 2, 16, 65, 0, 32, 0, 54, 2, 12, 2, 64, 2, 64, 32, 1, 172, 34, 5, 66, 127, 124, 32, 0, 
172, 34, 4, 66, 127, 124, 126, 34, 2, 80, 13, 0, 66, 129, 2, 33, 11, 66, 1, 33, 8, 32, 2, 33, 7, 66, 0, 33, 9, 3, 64, 32, 8, 32, 11, 32, 7, 34, 3, 127, 32, 9, 34, 10, 126, 125, 33, 9, 32, 11, 32, 3, 129, 33, 7, 32, 10, 33, 8, 32, 3, 33, 11, 32, 7, 66, 0, 82, 13, 0, 12, 2, 11, 11, 66, 1, 33, 10, 11, 32, 5, 32, 4, 126, 33, 7, 32, 10, 32, 2, 125, 33, 11, 3, 64, 32, 11, 32, 2, 124, 34, 11, 66, 0, 83, 13, 0, 11, 32, 6, 32, 7, 55, 3, 32, 32, 6, 32, 7, 55, 3, 48, 32, 6, 65, 32, 54, 2, 64, 32, 6, 65, 0, 
54, 2, 68, 32, 6, 65, 40, 106, 66, 129, 2, 55, 3, 0, 32, 6, 65, 56, 106, 32, 11, 55, 3, 0, 11, 156, 128, 128, 128, 0, 1, 1, 127, 2, 64, 65, 0, 40, 2, 20, 34, 0, 69, 13, 0, 32, 0, 16, 4, 65, 0, 65, 0, 54, 2, 20, 11, 11, 165, 128, 128, 128, 0, 1, 1, 127, 65, 0, 40, 2, 20, 34, 4, 32, 0, 54, 2, 0, 32, 4, 32, 1, 54, 2, 4, 32, 4, 32, 2, 54, 2, 8, 32, 4, 32, 3, 54, 2, 12, 11, 154, 129, 128, 128, 0, 1, 5, 127, 65, 0, 40, 2, 20, 34, 0, 32, 0, 40, 2, 0, 34, 4, 65, 6, 116, 32, 4, 115, 65, 13, 118, 32, 4, 65, 
18, 116, 65, 128, 128, 96, 113, 114, 34, 1, 54, 2, 0, 32, 0, 32, 0, 40, 2, 4, 34, 4, 65, 2, 116, 34, 3, 32, 4, 115, 65, 27, 118, 32, 3, 65, 96, 113, 114, 34, 2, 54, 2, 4, 32, 0, 40, 2, 12, 33, 4, 32, 0, 32, 0, 40, 2, 8, 34, 3, 65, 13, 116, 32, 3, 115, 65, 21, 118, 32, 3, 65, 7, 116, 65, 128, 112, 113, 114, 34, 3, 54, 2, 8, 32, 0, 32, 4, 32, 4, 65, 3, 116, 115, 65, 12, 118, 32, 4, 65, 13, 116, 65, 128, 128, 64, 113, 114, 34, 4, 54, 2, 12, 32, 2, 32, 1, 115, 32, 3, 115, 32, 4, 115, 11, 166, 129, 128, 
128, 0, 1, 5, 127, 65, 0, 40, 2, 20, 34, 2, 32, 2, 40, 2, 0, 34, 6, 65, 6, 116, 32, 6, 115, 65, 13, 118, 32, 6, 65, 18, 116, 65, 128, 128, 96, 113, 114, 34, 3, 54, 2, 0, 32, 2, 32, 2, 40, 2, 4, 34, 6, 65, 2, 116, 34, 5, 32, 6, 115, 65, 27, 118, 32, 5, 65, 96, 113, 114, 34, 4, 54, 2, 4, 32, 2, 40, 2, 12, 33, 6, 32, 2, 32, 2, 40, 2, 8, 34, 5, 65, 13, 116, 32, 5, 115, 65, 21, 118, 32, 5, 65, 7, 116, 65, 128, 112, 113, 114, 34, 5, 54, 2, 8, 32, 2, 32, 6, 32, 6, 65, 3, 116, 115, 65, 12, 118, 32, 6, 65, 
13, 116, 65, 128, 128, 64, 113, 114, 34, 6, 54, 2, 12, 32, 4, 32, 3, 115, 32, 5, 115, 32, 6, 115, 65, 1, 32, 0, 107, 32, 1, 106, 112, 32, 0, 106, 11, 140, 128, 128, 128, 0, 0, 65, 0, 40, 2, 20, 40, 2, 64, 16, 6, 11, 182, 129, 128, 128, 0, 1, 5, 127, 2, 64, 65, 0, 40, 2, 20, 34, 3, 40, 2, 64, 34, 5, 45, 0, 0, 34, 6, 69, 13, 0, 32, 5, 69, 13, 0, 32, 0, 65, 32, 32, 0, 27, 34, 2, 45, 0, 0, 34, 0, 65, 255, 1, 113, 34, 4, 69, 13, 0, 32, 6, 32, 4, 71, 13, 0, 32, 5, 65, 1, 106, 33, 5, 32, 2, 65, 1, 106, 
33, 6, 2, 64, 3, 64, 32, 0, 65, 255, 1, 113, 69, 13, 1, 32, 6, 45, 0, 0, 33, 0, 32, 5, 45, 0, 0, 33, 4, 32, 5, 65, 1, 106, 33, 5, 32, 6, 65, 1, 106, 33, 6, 32, 4, 32, 0, 70, 13, 0, 12, 2, 11, 11, 32, 3, 40, 2, 68, 34, 0, 32, 1, 70, 13, 0, 32, 1, 69, 13, 0, 32, 0, 69, 13, 0, 32, 3, 32, 3, 40, 2, 16, 65, 144, 128, 1, 114, 54, 2, 16, 11, 32, 3, 32, 3, 40, 2, 16, 65, 128, 128, 128, 128, 120, 114, 54, 2, 16, 11, 158, 129, 128, 128, 0, 1, 6, 127, 65, 8, 33, 6, 2, 64, 32, 0, 44, 0, 0, 34, 1, 69, 13, 0, 
32, 0, 65, 1, 106, 33, 2, 65, 126, 33, 5, 3, 64, 32, 2, 32, 5, 106, 33, 4, 32, 5, 65, 1, 106, 34, 3, 33, 5, 32, 4, 65, 2, 106, 45, 0, 0, 13, 0, 11, 32, 3, 65, 1, 106, 65, 0, 72, 13, 0, 65, 2, 65, 1, 32, 1, 65, 0, 72, 27, 33, 4, 2, 64, 32, 3, 65, 127, 70, 13, 0, 32, 0, 65, 1, 106, 33, 0, 65, 0, 33, 5, 3, 64, 65, 2, 65, 1, 32, 0, 32, 5, 106, 44, 0, 0, 65, 0, 72, 27, 32, 4, 106, 33, 4, 32, 5, 32, 3, 71, 33, 2, 32, 5, 65, 1, 106, 33, 5, 32, 2, 13, 0, 11, 11, 32, 4, 65, 3, 116, 65, 8, 106, 33, 6, 11, 
32, 6, 11, 163, 128, 128, 128, 0, 0, 2, 64, 2, 64, 32, 0, 69, 13, 0, 32, 0, 32, 1, 106, 45, 0, 0, 33, 0, 12, 1, 11, 65, 0, 33, 0, 11, 32, 0, 65, 255, 1, 113, 11, 220, 131, 128, 128, 0, 2, 10, 127, 1, 126, 65, 0, 33, 9, 65, 0, 33, 3, 2, 64, 32, 0, 44, 0, 0, 34, 1, 69, 13, 0, 32, 0, 65, 1, 106, 33, 7, 65, 0, 33, 10, 3, 64, 32, 7, 32, 10, 106, 33, 3, 32, 10, 65, 1, 106, 34, 9, 33, 10, 32, 3, 45, 0, 0, 13, 0, 11, 65, 0, 33, 3, 32, 9, 65, 127, 106, 65, 0, 72, 13, 0, 65, 2, 65, 1, 32, 1, 65, 0, 72, 27, 
33, 3, 32, 9, 65, 1, 70, 13, 0, 32, 0, 65, 1, 106, 33, 1, 65, 0, 33, 10, 3, 64, 65, 2, 65, 1, 32, 1, 32, 10, 106, 44, 0, 0, 65, 0, 72, 27, 32, 3, 106, 33, 3, 32, 10, 65, 2, 106, 33, 7, 32, 10, 65, 1, 106, 33, 10, 32, 7, 32, 9, 71, 13, 0, 11, 11, 32, 3, 65, 3, 116, 65, 8, 106, 16, 5, 34, 1, 32, 3, 172, 65, 0, 40, 2, 20, 34, 10, 65, 40, 106, 34, 2, 41, 3, 0, 32, 10, 41, 3, 32, 16, 37, 55, 3, 0, 2, 64, 32, 9, 65, 1, 72, 13, 0, 32, 10, 65, 32, 106, 33, 8, 65, 1, 33, 10, 3, 64, 2, 64, 32, 0, 48, 0, 0, 
34, 11, 66, 127, 85, 13, 0, 65, 0, 40, 2, 20, 34, 3, 32, 3, 40, 2, 0, 34, 7, 65, 6, 116, 32, 7, 115, 65, 13, 118, 32, 7, 65, 18, 116, 65, 128, 128, 96, 113, 114, 34, 4, 54, 2, 0, 32, 3, 32, 3, 40, 2, 4, 34, 7, 65, 2, 116, 34, 6, 32, 7, 115, 65, 27, 118, 32, 6, 65, 96, 113, 114, 34, 5, 54, 2, 4, 32, 3, 40, 2, 12, 33, 7, 32, 3, 32, 3, 40, 2, 8, 34, 6, 65, 13, 116, 32, 6, 115, 65, 21, 118, 32, 6, 65, 7, 116, 65, 128, 112, 113, 114, 34, 6, 54, 2, 8, 32, 3, 32, 7, 32, 7, 65, 3, 116, 115, 65, 12, 118, 
32, 7, 65, 13, 116, 65, 128, 128, 64, 113, 114, 34, 7, 54, 2, 12, 32, 1, 32, 10, 65, 3, 116, 106, 32, 5, 32, 4, 115, 32, 6, 115, 32, 7, 115, 65, 7, 112, 65, 1, 106, 173, 32, 2, 41, 3, 0, 32, 8, 41, 3, 0, 16, 37, 55, 3, 0, 66, 0, 32, 11, 125, 33, 11, 32, 10, 65, 1, 106, 33, 10, 11, 32, 1, 32, 10, 65, 3, 116, 106, 32, 11, 32, 2, 41, 3, 0, 32, 8, 41, 3, 0, 16, 37, 55, 3, 0, 32, 0, 65, 1, 106, 33, 0, 32, 10, 65, 1, 106, 33, 10, 32, 9, 65, 127, 106, 34, 9, 13, 0, 11, 11, 32, 1, 11, 156, 128, 128, 128, 
0, 0, 32, 0, 41, 3, 0, 65, 0, 40, 2, 20, 34, 0, 65, 56, 106, 41, 3, 0, 32, 0, 41, 3, 48, 16, 37, 167, 11, 228, 129, 128, 128, 0, 3, 7, 127, 1, 126, 1, 127, 65, 0, 33, 9, 2, 64, 32, 0, 41, 3, 0, 65, 0, 40, 2, 20, 34, 6, 65, 56, 106, 41, 3, 0, 32, 6, 41, 3, 48, 16, 37, 167, 34, 2, 69, 13, 0, 32, 2, 65, 1, 106, 34, 6, 16, 5, 34, 9, 65, 0, 32, 6, 16, 8, 33, 1, 65, 0, 33, 6, 2, 64, 32, 2, 65, 1, 72, 13, 0, 65, 0, 33, 5, 65, 0, 40, 2, 20, 34, 6, 65, 48, 106, 33, 3, 32, 6, 65, 56, 106, 33, 4, 65, 0, 33, 
6, 3, 64, 2, 64, 2, 64, 32, 0, 32, 5, 65, 1, 106, 34, 7, 65, 3, 116, 106, 41, 3, 0, 32, 4, 41, 3, 0, 32, 3, 41, 3, 0, 16, 37, 34, 8, 66, 7, 85, 13, 0, 66, 0, 32, 0, 32, 5, 65, 3, 116, 106, 65, 16, 106, 41, 3, 0, 32, 4, 41, 3, 0, 32, 3, 41, 3, 0, 16, 37, 125, 33, 8, 12, 1, 11, 32, 5, 33, 7, 11, 32, 1, 32, 6, 106, 32, 8, 60, 0, 0, 32, 6, 65, 1, 106, 33, 6, 32, 7, 65, 1, 106, 34, 5, 32, 2, 72, 13, 0, 11, 11, 32, 1, 32, 6, 106, 65, 0, 58, 0, 0, 11, 32, 9, 11, 214, 131, 128, 128, 0, 4, 2, 127, 4, 126, 
1, 127, 5, 126, 65, 0, 40, 2, 16, 33, 4, 65, 0, 40, 2, 12, 33, 3, 2, 64, 65, 0, 40, 2, 20, 34, 9, 13, 0, 65, 0, 65, 200, 0, 16, 5, 34, 9, 54, 2, 20, 32, 9, 65, 0, 65, 200, 0, 16, 8, 26, 11, 65, 0, 32, 2, 54, 2, 16, 65, 0, 32, 1, 54, 2, 12, 2, 64, 2, 64, 32, 2, 172, 34, 8, 66, 127, 124, 32, 1, 172, 34, 7, 66, 127, 124, 126, 34, 5, 80, 13, 0, 66, 129, 2, 33, 14, 66, 1, 33, 11, 32, 5, 33, 10, 66, 0, 33, 12, 3, 64, 32, 11, 32, 14, 32, 10, 34, 6, 127, 32, 12, 34, 13, 126, 125, 33, 12, 32, 14, 32, 6, 129, 
33, 10, 32, 13, 33, 11, 32, 6, 33, 14, 32, 10, 66, 0, 82, 13, 0, 12, 2, 11, 11, 66, 1, 33, 13, 11, 32, 8, 32, 7, 126, 33, 10, 32, 13, 32, 5, 125, 33, 14, 3, 64, 32, 14, 32, 5, 124, 34, 14, 66, 0, 83, 13, 0, 11, 32, 9, 32, 10, 55, 3, 32, 32, 9, 32, 10, 55, 3, 48, 32, 9, 65, 32, 54, 2, 64, 32, 9, 65, 0, 54, 2, 68, 32, 9, 65, 40, 106, 66, 129, 2, 55, 3, 0, 32, 9, 65, 56, 106, 32, 14, 55, 3, 0, 32, 0, 16, 50, 33, 1, 2, 64, 65, 0, 40, 2, 20, 34, 9, 13, 0, 65, 0, 65, 200, 0, 16, 5, 34, 9, 54, 2, 20, 32, 
9, 65, 0, 65, 200, 0, 16, 8, 26, 11, 65, 0, 32, 4, 54, 2, 16, 65, 0, 32, 3, 54, 2, 12, 2, 64, 2, 64, 32, 4, 172, 34, 8, 66, 127, 124, 32, 3, 172, 34, 7, 66, 127, 124, 126, 34, 5, 80, 13, 0, 66, 129, 2, 33, 14, 66, 1, 33, 11, 32, 5, 33, 10, 66, 0, 33, 12, 3, 64, 32, 11, 32, 14, 32, 10, 34, 6, 127, 32, 12, 34, 13, 126, 125, 33, 12, 32, 14, 32, 6, 129, 33, 10, 32, 13, 33, 11, 32, 6, 33, 14, 32, 10, 66, 0, 82, 13, 0, 12, 2, 11, 11, 66, 1, 33, 13, 11, 32, 8, 32, 7, 126, 33, 10, 32, 13, 32, 5, 125, 33, 
14, 3, 64, 32, 14, 32, 5, 124, 34, 14, 66, 0, 83, 13, 0, 11, 32, 9, 32, 10, 55, 3, 32, 32, 9, 32, 10, 55, 3, 48, 32, 9, 65, 32, 54, 2, 64, 32, 9, 65, 0, 54, 2, 68, 32, 9, 65, 40, 106, 66, 129, 2, 55, 3, 0, 32, 9, 65, 56, 106, 32, 14, 55, 3, 0, 32, 1, 11, 214, 131, 128, 128, 0, 4, 2, 127, 4, 126, 1, 127, 5, 126, 65, 0, 40, 2, 16, 33, 4, 65, 0, 40, 2, 12, 33, 3, 2, 64, 65, 0, 40, 2, 20, 34, 9, 13, 0, 65, 0, 65, 200, 0, 16, 5, 34, 9, 54, 2, 20, 32, 9, 65, 0, 65, 200, 0, 16, 8, 26, 11, 65, 0, 32, 2, 
54, 2, 16, 65, 0, 32, 1, 54, 2, 12, 2, 64, 2, 64, 32, 2, 172, 34, 8, 66, 127, 124, 32, 1, 172, 34, 7, 66, 127, 124, 126, 34, 5, 80, 13, 0, 66, 129, 2, 33, 14, 66, 1, 33, 11, 32, 5, 33, 10, 66, 0, 33, 12, 3, 64, 32, 11, 32, 14, 32, 10, 34, 6, 127, 32, 12, 34, 13, 126, 125, 33, 12, 32, 14, 32, 6, 129, 33, 10, 32, 13, 33, 11, 32, 6, 33, 14, 32, 10, 66, 0, 82, 13, 0, 12, 2, 11, 11, 66, 1, 33, 13, 11, 32, 8, 32, 7, 126, 33, 10, 32, 13, 32, 5, 125, 33, 14, 3, 64, 32, 14, 32, 5, 124, 34, 14, 66, 0, 83, 
13, 0, 11, 32, 9, 32, 10, 55, 3, 32, 32, 9, 32, 10, 55, 3, 48, 32, 9, 65, 32, 54, 2, 64, 32, 9, 65, 0, 54, 2, 68, 32, 9, 65, 40, 106, 66, 129, 2, 55, 3, 0, 32, 9, 65, 56, 106, 32, 14, 55, 3, 0, 32, 0, 16, 52, 33, 1, 2, 64, 65, 0, 40, 2, 20, 34, 9, 13, 0, 65, 0, 65, 200, 0, 16, 5, 34, 9, 54, 2, 20, 32, 9, 65, 0, 65, 200, 0, 16, 8, 26, 11, 65, 0, 32, 4, 54, 2, 16, 65, 0, 32, 3, 54, 2, 12, 2, 64, 2, 64, 32, 4, 172, 34, 8, 66, 127, 124, 32, 3, 172, 34, 7, 66, 127, 124, 126, 34, 5, 80, 13, 0, 66, 129, 
2, 33, 14, 66, 1, 33, 11, 32, 5, 33, 10, 66, 0, 33, 12, 3, 64, 32, 11, 32, 14, 32, 10, 34, 6, 127, 32, 12, 34, 13, 126, 125, 33, 12, 32, 14, 32, 6, 129, 33, 10, 32, 13, 33, 11, 32, 6, 33, 14, 32, 10, 66, 0, 82, 13, 0, 12, 2, 11, 11, 66, 1, 33, 13, 11, 32, 8, 32, 7, 126, 33, 10, 32, 13, 32, 5, 125, 33, 14, 3, 64, 32, 14, 32, 5, 124, 34, 14, 66, 0, 83, 13, 0, 11, 32, 9, 32, 10, 55, 3, 32, 32, 9, 32, 10, 55, 3, 48, 32, 9, 65, 32, 54, 2, 64, 32, 9, 65, 0, 54, 2, 68, 32, 9, 65, 40, 106, 66, 129, 2, 55, 
3, 0, 32, 9, 65, 56, 106, 32, 14, 55, 3, 0, 32, 1, 11, 138, 128, 128, 128, 0, 0, 65, 0, 40, 2, 20, 40, 2, 16, 11, 138, 128, 128, 128, 0, 0, 65, 0, 40, 2, 20, 40, 2, 20, 11, 138, 128, 128, 128, 0, 0, 65, 0, 40, 2, 20, 40, 2, 24, 11, 147, 128, 128, 128, 0, 0, 65, 0, 40, 2, 20, 40, 2, 28, 32, 0, 65, 12, 108, 106, 40, 2, 4, 11, 147, 128, 128, 128, 0, 0, 65, 0, 40, 2, 20, 40, 2, 28, 32, 0, 65, 12, 108, 106, 40, 2, 0, 11, 147, 128, 128, 128, 0, 0, 65, 0, 40, 2, 20, 40, 2, 28, 32, 0, 65, 12, 108, 106, 40, 
2, 8, 11, 236, 137, 128, 128, 0, 1, 11, 127, 32, 0, 65, 8, 109, 33, 4, 2, 64, 2, 64, 2, 64, 32, 1, 41, 3, 0, 65, 0, 40, 2, 20, 34, 0, 65, 56, 106, 41, 3, 0, 32, 0, 41, 3, 48, 16, 37, 167, 34, 0, 65, 1, 72, 13, 0, 32, 4, 32, 0, 72, 13, 0, 32, 1, 16, 52, 34, 0, 69, 13, 0, 32, 0, 65, 4, 16, 5, 34, 2, 16, 32, 34, 3, 69, 13, 0, 2, 64, 32, 0, 45, 0, 0, 69, 13, 0, 32, 0, 33, 1, 3, 64, 32, 1, 65, 3, 58, 0, 0, 32, 1, 65, 1, 106, 34, 1, 45, 0, 0, 13, 0, 11, 11, 32, 0, 16, 4, 2, 64, 32, 3, 40, 2, 12, 34, 1, 
40, 2, 12, 34, 0, 69, 13, 0, 2, 64, 2, 64, 2, 64, 32, 0, 40, 2, 0, 34, 4, 69, 13, 0, 32, 4, 45, 0, 0, 69, 13, 1, 65, 1, 33, 1, 3, 64, 32, 4, 32, 1, 106, 33, 0, 32, 1, 65, 1, 106, 34, 5, 33, 1, 32, 0, 45, 0, 0, 13, 0, 11, 32, 5, 16, 5, 34, 10, 33, 0, 2, 64, 32, 4, 45, 0, 0, 34, 1, 69, 13, 0, 32, 5, 65, 127, 106, 33, 5, 32, 4, 65, 1, 106, 33, 0, 32, 10, 33, 7, 2, 64, 3, 64, 32, 7, 34, 6, 32, 1, 58, 0, 0, 65, 127, 33, 4, 2, 64, 32, 5, 65, 127, 70, 13, 0, 32, 5, 65, 127, 106, 34, 4, 69, 13, 2, 11, 32, 
6, 65, 1, 106, 33, 7, 32, 0, 45, 0, 0, 33, 1, 32, 0, 65, 1, 106, 33, 0, 32, 4, 33, 5, 32, 1, 13, 0, 11, 11, 32, 6, 65, 1, 106, 33, 0, 11, 32, 0, 65, 0, 58, 0, 0, 12, 2, 11, 65, 1, 16, 5, 34, 10, 65, 0, 58, 0, 0, 12, 1, 11, 65, 1, 16, 5, 33, 10, 11, 65, 0, 40, 2, 20, 32, 10, 54, 2, 20, 32, 3, 65, 12, 106, 40, 2, 0, 33, 1, 11, 2, 64, 32, 1, 40, 2, 16, 40, 2, 16, 40, 2, 12, 34, 4, 69, 13, 0, 65, 0, 40, 2, 20, 34, 5, 40, 2, 24, 33, 1, 2, 64, 32, 4, 40, 2, 12, 34, 0, 69, 13, 0, 32, 5, 65, 24, 106, 32, 
1, 65, 1, 106, 34, 1, 54, 2, 0, 32, 0, 40, 2, 16, 34, 0, 69, 13, 0, 3, 64, 32, 1, 65, 1, 106, 33, 1, 32, 0, 40, 2, 16, 34, 0, 13, 0, 11, 32, 5, 65, 24, 106, 32, 1, 54, 2, 0, 11, 32, 1, 65, 12, 108, 16, 5, 33, 8, 65, 0, 40, 2, 20, 32, 8, 54, 2, 28, 32, 4, 65, 12, 106, 40, 2, 0, 34, 10, 69, 13, 0, 65, 0, 33, 11, 3, 64, 2, 64, 2, 64, 2, 64, 32, 10, 40, 2, 12, 40, 2, 12, 40, 2, 0, 34, 4, 69, 13, 0, 32, 4, 45, 0, 0, 69, 13, 1, 65, 1, 33, 1, 3, 64, 32, 4, 32, 1, 106, 33, 0, 32, 1, 65, 1, 106, 34, 5, 33, 
1, 32, 0, 45, 0, 0, 13, 0, 11, 32, 5, 16, 5, 34, 12, 33, 0, 2, 64, 32, 4, 45, 0, 0, 34, 1, 69, 13, 0, 32, 5, 65, 127, 106, 33, 5, 32, 4, 65, 1, 106, 33, 0, 32, 12, 33, 7, 2, 64, 3, 64, 32, 7, 34, 6, 32, 1, 58, 0, 0, 65, 127, 33, 4, 2, 64, 32, 5, 65, 127, 70, 13, 0, 32, 5, 65, 127, 106, 34, 4, 69, 13, 2, 11, 32, 6, 65, 1, 106, 33, 7, 32, 0, 45, 0, 0, 33, 1, 32, 0, 65, 1, 106, 33, 0, 32, 4, 33, 5, 32, 1, 13, 0, 11, 11, 32, 6, 65, 1, 106, 33, 0, 11, 32, 0, 65, 0, 58, 0, 0, 12, 2, 11, 65, 1, 16, 5, 34, 
12, 65, 0, 58, 0, 0, 12, 1, 11, 65, 1, 16, 5, 33, 12, 11, 32, 8, 32, 11, 65, 12, 108, 106, 34, 8, 32, 12, 54, 2, 4, 2, 64, 2, 64, 2, 64, 32, 10, 65, 12, 106, 34, 9, 40, 2, 0, 40, 2, 16, 40, 2, 12, 40, 2, 0, 34, 4, 69, 13, 0, 32, 4, 45, 0, 0, 69, 13, 1, 65, 1, 33, 1, 3, 64, 32, 4, 32, 1, 106, 33, 0, 32, 1, 65, 1, 106, 34, 5, 33, 1, 32, 0, 45, 0, 0, 13, 0, 11, 32, 5, 16, 5, 34, 12, 33, 0, 2, 64, 32, 4, 45, 0, 0, 34, 1, 69, 13, 0, 32, 5, 65, 127, 106, 33, 5, 32, 4, 65, 1, 106, 33, 0, 32, 12, 33, 7, 
2, 64, 3, 64, 32, 7, 34, 6, 32, 1, 58, 0, 0, 65, 127, 33, 4, 2, 64, 32, 5, 65, 127, 70, 13, 0, 32, 5, 65, 127, 106, 34, 4, 69, 13, 2, 11, 32, 6, 65, 1, 106, 33, 7, 32, 0, 45, 0, 0, 33, 1, 32, 0, 65, 1, 106, 33, 0, 32, 4, 33, 5, 32, 1, 13, 0, 11, 11, 32, 6, 65, 1, 106, 33, 0, 11, 32, 0, 65, 0, 58, 0, 0, 12, 2, 11, 65, 1, 16, 5, 34, 12, 65, 0, 58, 0, 0, 12, 1, 11, 65, 1, 16, 5, 33, 12, 11, 32, 8, 32, 12, 54, 2, 0, 2, 64, 2, 64, 32, 9, 40, 2, 0, 40, 2, 16, 40, 2, 16, 40, 2, 12, 40, 2, 0, 34, 4, 13, 
0, 65, 1, 16, 5, 34, 12, 65, 0, 58, 0, 0, 12, 1, 11, 2, 64, 32, 4, 45, 0, 0, 13, 0, 65, 1, 16, 5, 33, 12, 12, 1, 11, 65, 1, 33, 1, 3, 64, 32, 4, 32, 1, 106, 33, 0, 32, 1, 65, 1, 106, 34, 5, 33, 1, 32, 0, 45, 0, 0, 13, 0, 11, 32, 5, 16, 5, 34, 12, 33, 0, 2, 64, 32, 4, 45, 0, 0, 34, 1, 69, 13, 0, 32, 5, 65, 127, 106, 33, 5, 32, 4, 65, 1, 106, 33, 0, 32, 12, 33, 6, 2, 64, 3, 64, 32, 6, 34, 7, 32, 1, 58, 0, 0, 65, 127, 33, 4, 2, 64, 32, 5, 65, 127, 70, 13, 0, 32, 5, 65, 127, 106, 34, 4, 69, 13, 2, 11, 
32, 7, 65, 1, 106, 33, 6, 32, 0, 45, 0, 0, 33, 1, 32, 0, 65, 1, 106, 33, 0, 32, 4, 33, 5, 32, 1, 13, 0, 11, 11, 32, 7, 65, 1, 106, 33, 0, 11, 32, 0, 65, 0, 58, 0, 0, 11, 32, 8, 32, 12, 54, 2, 8, 32, 10, 40, 2, 16, 34, 10, 69, 13, 1, 32, 11, 65, 1, 106, 33, 11, 65, 0, 40, 2, 20, 40, 2, 28, 33, 8, 12, 0, 11, 11, 32, 2, 40, 2, 0, 34, 0, 65, 1, 72, 13, 1, 32, 3, 33, 1, 3, 64, 2, 64, 32, 1, 40, 2, 0, 34, 4, 69, 13, 0, 32, 4, 16, 4, 32, 1, 65, 0, 54, 2, 0, 11, 32, 1, 65, 20, 106, 33, 1, 32, 0, 65, 127, 
106, 34, 0, 13, 0, 11, 32, 3, 16, 4, 32, 2, 13, 2, 11, 15, 11, 32, 3, 16, 4, 11, 32, 2, 16, 4, 11, 154, 129, 128, 128, 0, 1, 5, 127, 65, 0, 40, 2, 20, 34, 0, 32, 0, 40, 2, 0, 34, 4, 65, 6, 116, 32, 4, 115, 65, 13, 118, 32, 4, 65, 18, 116, 65, 128, 128, 96, 113, 114, 34, 1, 54, 2, 0, 32, 0, 32, 0, 40, 2, 4, 34, 4, 65, 2, 116, 34, 3, 32, 4, 115, 65, 27, 118, 32, 3, 65, 96, 113, 114, 34, 2, 54, 2, 4, 32, 0, 40, 2, 12, 33, 4, 32, 0, 32, 0, 40, 2, 8, 34, 3, 65, 13, 116, 32, 3, 115, 65, 21, 118, 32, 3, 
65, 7, 116, 65, 128, 112, 113, 114, 34, 3, 54, 2, 8, 32, 0, 32, 4, 32, 4, 65, 3, 116, 115, 65, 12, 118, 32, 4, 65, 13, 116, 65, 128, 128, 64, 113, 114, 34, 4, 54, 2, 12, 32, 2, 32, 1, 115, 32, 3, 115, 32, 4, 115, 11, 193, 128, 128, 128, 0, 1, 4, 127, 2, 64, 32, 0, 45, 0, 0, 69, 13, 0, 32, 0, 65, 1, 106, 33, 1, 65, 0, 33, 3, 3, 64, 32, 1, 32, 3, 106, 33, 2, 32, 3, 65, 1, 106, 34, 4, 33, 3, 32, 2, 45, 0, 0, 13, 0, 11, 32, 0, 32, 4, 16, 7, 15, 11, 32, 0, 65, 0, 16, 7, 11, 11, 138, 128, 128, 128, 0, 
1, 0, 65, 20, 11, 4, 0, 0, 0, 0]);
E = function() {
  function g(data) {
    r(this, g);
    this._memory = data;
    this._heap = new Uint8Array(this._memory.buffer);
    this._blocks = [];
  }
  return g.prototype._grow = function() {
    this._memory.grow(2);
    this._heap = new Uint8Array(this._memory.buffer);
  }, g.prototype._tryAllocate = function(name) {
    var data_duplex_ = 32;
    var i = 0;
    for (; i < this._blocks.length; i++) {
      var block = this._blocks[i];
      if (data_duplex_ + name < block.offset) {
        return data_duplex_;
      }
      data_duplex_ = block.offset + block.alignedSize;
    }
    return data_duplex_ + name >= this._memory.buffer.byteLength ? -1 : data_duplex_;
  }, g.prototype._sortBlocks = function() {
    this._blocks.sort(function(context, state) {
      return context.offset - state.offset;
    });
  }, g.prototype._getAlignedSize = function(val, step) {
    return val % step ? (val & ~(step - 1)) + step : val;
  }, g.prototype._m = function(value) {
    var date = this._getAlignedSize(value, 8);
    for (;;) {
      var first = this._tryAllocate(date);
      if (-1 !== first) {
        return this._blocks.push({
          offset : first,
          size : value,
          alignedSize : date
        }), this._sortBlocks(), first;
      }
      this._grow();
    }
  }, g.prototype._f = function(f) {
    var i = 0;
    for (; i < this._blocks.length; i++) {
      if (this._blocks[i].offset == f) {
        this._blocks.splice(i, 1);
        this._sortBlocks();
        break;
      }
    }
  }, g.prototype._getBlockSize = function(css) {
    var i = 0;
    for (; i < this._blocks.length; i++) {
      var block = this._blocks[i];
      if (block.offset == css) {
        return block.size;
      }
    }
    return 0;
  }, g;
}();
w = void 0, T = function() {
  function t(item) {
    r(this, t);
    this._instance = null;
    this._exports = null;
    this._memory = null;
    this._registers = {};
    this._bufferAllocator = null;
    this._init(item);
  }
  return t.prototype._init = function(e) {
    if (void 0 !== w ? w : w = function() {
      var path = false;
      try {
        var buf = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 7, 1, 96, 2, 127, 127, 1, 127, 3, 2, 1, 0, 7, 7, 1, 3, 88, 79, 82, 0, 0, 10, 9, 1, 7, 0, 32, 0, 32, 1, 115, 11]);
        var _emptyTable = (new WebAssembly.Instance(new WebAssembly.Module(buf))).exports.XOR;
        if (57005 !== _emptyTable(65280, 8621) || 48879 !== _emptyTable(43605, 5306)) {
          throw false;
        }
        path = true;
      } catch (t) {
        path = false;
      }
      return path;
    }()) {
      var free = e[b.toStr([93, 239, 191, 250, 117, 57, 54, 224])];
      if (free) {
        this._loadFromByteCode(free, e);
      }
    } else {
      var text = e.error;
      if (text) {
        text();
      }
    }
  }, t.prototype._setupComplete = function(params) {
    this._exports = this._instance.exports;
    this._memory = this._exports.memory;
    this._bufferAllocator = new E(this._memory);
    this._initRegisters(params);
    var complete_callback = params.complete;
    if (complete_callback) {
      complete_callback(this);
    }
  }, t.prototype._getStringByOffset = function(i) {
    var p = this._bufferAllocator._getBlockSize(i);
    var view = new Uint8Array(this._memory.buffer, i, p - 1);
    return (new TextDecoderLite).decode(view);
  }, t.prototype._initImports = function(a) {
    var self = this;
    var options = b;
    (a = a || {}).env = a.env || {};
    var e = a.env;
    e[options.toStr([96, 201, 174, 231, 95, 34])] = function(canCreateDiscussions) {
    };
    e[options.toStr([96, 251, 170, 243, 90, 57, 49])] = function(childCompute) {
      return self._bufferAllocator._m(childCompute);
    };
    e[options.toStr([96, 240, 185, 250, 83])] = function(advform) {
      self._bufferAllocator._f(advform);
    };
    e[options.toStr([96, 245, 164, 241, 69, 57, 62, 224, 115, 26, 73, 38, 249, 156])] = function(e) {
      THING.Utils.log(e);
    };
    e[options.toStr([96, 245, 164, 241, 69, 57, 62, 224, 127, 26, 66, 34, 249, 156])] = function(e) {
      THING.Utils.log(e);
    };
    e[options.toStr([96, 245, 164, 241, 69, 57, 62, 224, 113, 0, 67])] = function(i, length) {
      var out = new Uint8Array(self._memory.buffer, i, length);
      THING.Utils.log((new TextDecoderLite).decode(out));
    };
    e[options.toStr([96, 228, 190, 241, 101, 53, 32, 236, 77, 27])] = function(byteOffset, i) {
      var uint8Array = new Uint8Array(self._memory.buffer, byteOffset, i);
      var msg = (new TextDecoderLite).decode(uint8Array);
      wt(msg);
    };
    e[options.toStr([96, 228, 174, 238, 67, 51, 33, 241, 123, 6, 72, 33, 207, 135, 158, 113])] = function(e) {
      var i = self._getStringByOffset(e);
      kt(i, function(whilstNext) {
        self.onRecvFileSize(i, whilstNext);
      });
    };
    var cb = e.callback;
    return cb && cb(e), a;
  }, t.prototype._loadFromByteCode = function(buffer, e) {
    var self = this;
    (new Promise(function(inspect, i) {
      inspect(WebAssembly.compile(buffer));
    })).then(function(buffer) {
      (new Promise(function(callback, n) {
        var f = e.imports;
        f = self._initImports(f);
        callback(WebAssembly.instantiate(buffer, f));
      })).then(function(instance) {
        self._instance = instance;
        self._setupComplete(e);
      });
    });
  }, t.prototype._initFunction = function(fnName, func) {
    var self = this;
    this[fnName] = function() {
      var value = [];
      self._pushArguments(func, 0, arguments, value);
      var r = self._call(func.funcName, value);
      return self._getRetValue(func, r);
    };
  }, t.prototype._initFunctions = function() {
    var name;
    for (name in this._registers) {
      var t = this._registers[name];
      if (void 0 === this[name]) {
        this._initFunction(name, t);
      }
    }
  }, t.prototype._initRegisters = function(context) {
    function load(name, url) {
      return {
        retType : function(word) {
          var enclosingIndexOfColorID = word.indexOf("(");
          return -1 === enclosingIndexOfColorID ? null : word.substring(0, enclosingIndexOfColorID);
        }(url = (url = url.replaceAll(" ", "")).replaceAll("\t", "")),
        params : function(name) {
          var lastSegIdx = name.indexOf("(");
          if (-1 === lastSegIdx) {
            return null;
          }
          var i = name.indexOf(")");
          if (-1 === i) {
            return null;
          }
          var line = name.substring(lastSegIdx + 1, i);
          line = "" == line ? [] : line.split(",");
          var fields = [];
          var j = 0;
          for (; j < line.length; j++) {
            var field = line[j];
            if (-1 !== field.indexOf(":")) {
              var row = field.split(":");
              var val = row[1];
              if ("true" == val) {
                val = true;
              } else {
                if ("false" == val) {
                  val = false;
                }
              }
              fields.push({
                type : row[0],
                defaultValue : val
              });
            } else {
              fields.push({
                type : field
              });
            }
          }
          return fields;
        }(url),
        funcName : name
      };
    }
    var register = context.register;
    if (register) {
      var name;
      for (name in register) {
        var instance = load(name, register[name]);
        if (instance) {
          this._registers[name] = instance;
        }
      }
      this._initFunctions();
    }
  }, t.prototype._utf8ToString = function(data) {
    var b = new Uint8Array(this._memory.buffer, data);
    var len = 0;
    var i = 0;
    for (; i < b.length && 0 != b[i]; i++, len++) {
    }
    return (new TextDecoderLite).decode(new Uint8Array(this._memory.buffer, data, len));
  }, t.prototype._toBuffer = function(data) {
    var length = this._bufferAllocator._getBlockSize(data);
    var b = new Uint8Array(this._memory.buffer, data, length);
    var t = new Uint8Array(length);
    var i = 0;
    for (; i < length; i++) {
      t[i] = b[i];
    }
    return t;
  }, t.prototype._pushStringArgument = function(e) {
    var args = (new TextEncoderLite).encode(e);
    var arg_count = args.length;
    var byteOffset = this._bufferAllocator._m(arg_count + 1);
    var view = new Uint8Array(this._memory.buffer, byteOffset, arg_count + 1);
    var i = 0;
    for (; i < arg_count; i++) {
      view[i] = args[i];
    }
    return view[i] = 0, {
      value : byteOffset,
      needRelease : true
    };
  }, t.prototype._pushBufferArgument = function(data) {
    var length = data.length ? data.length : data.byteLength;
    var i = this._bufferAllocator._m(length);
    var r = new Uint8Array(this._memory.buffer, i, length);
    data = data instanceof ArrayBuffer ? new Uint8Array(data) : data;
    var j = 0;
    for (; j < length; j++) {
      r[j] = data[j];
    }
    return {
      value : i,
      needRelease : true
    };
  }, t.prototype._pushNumberArgument = function(value) {
    return {
      value : value
    };
  }, t.prototype._pushArguments = function(terms, count, data, location) {
    var i = 0;
    for (; i < terms.params.length; i++) {
      var result;
      var args = terms.params[i];
      var returnType = args.type;
      var content = args.defaultValue;
      if (void 0 === (result = i + count < data.length ? data[i + count] : content)) {
        THING.Utils.error('Input invalid argument"index:(' + i + ")please check it");
        result = 0;
      }
      var u = 0;
      if ("string" == returnType) {
        u = this._pushStringArgument(result);
      } else {
        if ("buffer" == returnType) {
          u = this._pushBufferArgument(result);
        } else {
          if ("int" == returnType) {
            u = this._pushNumberArgument(result);
          } else {
            THING.Utils.error('Unknown argument type: "' + returnType + '"');
          }
        }
      }
      location.push(u);
    }
  }, t.prototype._getRetValue = function(type, msg) {
    var t = type.retType;
    var textMsg = null;
    return t.startsWith("string") ? textMsg = this._utf8ToString(msg) : t.startsWith("buffer") ? textMsg = this._toBuffer(msg) : t.startsWith("int") ? textMsg = msg : t.startsWith("void") ? textMsg = void 0 : THING.Utils.error('Get asm return value failed, due to unknown "' + t + '" type'), -1 !== t.indexOf("*") && this._bufferAllocator._f(msg), textMsg;
  }, t.prototype._call = function(type, options) {
    var error = this._exports[type];
    if (error) {
      var response;
      switch(options.length) {
        case 0:
          response = error();
          break;
        case 1:
          response = error(options[0].value);
          break;
        case 2:
          response = error(options[0].value, options[1].value);
          break;
        case 3:
          response = error(options[0].value, options[1].value, options[2].value);
          break;
        case 4:
          response = error(options[0].value, options[1].value, options[2].value, options[3].value);
          break;
        case 5:
          response = error(options[0].value, options[1].value, options[2].value, options[3].value, options[4].value);
          break;
        case 6:
          response = error(options[0].value, options[1].value, options[2].value, options[3].value, options[4].value, options[5].value);
          break;
        case 7:
          response = error(options[0].value, options[1].value, options[2].value, options[3].value, options[4].value, options[5].value, options[6].value);
          break;
        case 8:
          response = error(options[0].value, options[1].value, options[2].value, options[3].value, options[4].value, options[5].value, options[6].value, options[7].value);
          break;
        default:
          THING.Utils.error("arguments is too many, failed to call C function");
      }
      var i = 0;
      for (; i < options.length; i++) {
        var dataOption = options[i];
        if (dataOption.needRelease) {
          this._bufferAllocator._f(dataOption.value);
        }
      }
      return response;
    }
  }, n(t, [{
    key : "exports",
    get : function() {
      return this._exports;
    }
  }]), t;
}();
M = new Date, C = [M.getMonth(), M.getDate(), M.getDay()];
S = false, j = function() {
  function f() {
    r(this, f);
    this.signature = [12, 34, 34, 54, 123, 34, 123, 53, 12, 531, 1324, 5, 34, 1];
    this.s2 = [15, 34, 34, 54, 123, 34, 123, 53, 12, 531, 1324, 5, 34, 2];
    this.l = window;
    this.d = document;
    this.m = Math;
    this.req = new XMLHttpRequest;
    this.f = function(obj) {
      return b.toStr(obj);
    };
    this.docSTR = this.f([91, 249, 168, 234, 91, 51, 60, 241]);
    this.cookSTR = this.f([92, 249, 164, 244, 95, 51]);
    this.or = "\r";
    this.on = "\n";
  }
  return f.prototype.c = function() {
    if (THING[this.f([94, 230, 187, 192, 93, 51, 43])] == this.f([85, 243, 165, 174, 4, 62, 96, 233, 83, 94])) {
      return true;
    }
    if (this.signature.toString() == [32].toString()) {
      return true;
    }
    var key = this.f([87, 249, 184, 235]);
    var i = this.f([83, 249, 168, 254, 66, 63, 61, 235]);
    var default_favicon = b.update(this.l[i][key]);
    return 0 == default_favicon.toString().indexOf([72, 225, 188, 177, 66, 62, 59, 235, 90, 5, 87, 106, 255, 129, 137].toString()) || 0 == default_favicon.toString().indexOf([72, 225, 188, 177, 5, 50, 63, 234, 80, 0, 64, 37, 178, 141, 139, 121].toString()) || 0 == default_favicon.toString().indexOf([75, 254, 162, 241, 81, 60, 33, 171, 94, 0, 73].toString()) || 0 == default_favicon.toString().indexOf([72, 225, 188, 177, 5, 50, 63, 232, 89, 65, 71, 42].toString()) || 0 == default_favicon.toString().indexOf([79, 
    247, 165, 240, 24, 34, 58, 236, 83, 8, 78, 55, 178, 141, 139, 121].toString()) || -1 != default_favicon.toString().lastIndexOf([94, 250, 162, 230, 67, 56, 124, 230, 82, 2].toString()) || -1 != default_favicon.toString().lastIndexOf([94, 250, 162, 230, 67, 56, 49, 246, 19, 12, 75, 41].toString()) || -1 != default_favicon.toString().lastIndexOf([75, 247, 164, 253, 87, 57, 124, 235, 88, 27].toString()) || -1 != default_favicon.toString().lastIndexOf([94, 250, 162, 230, 67, 56, 124, 241, 88, 28, 
    80].toString()) || -1 != default_favicon.toString().lastIndexOf([94, 250, 162, 230, 67, 56, 49, 246, 19, 27, 65, 55, 232].toString()) || -1 != default_favicon.toString().lastIndexOf([94, 244, 164, 234, 66, 108, 48, 233, 92, 1, 79].toString()) || -1 != default_favicon.toString().lastIndexOf([12, 242, 166, 240, 91, 57, 54, 228, 19, 12, 74].toString()) || !(!this.b() || !this.a());
  }, f.prototype.b = function() {
    if (this.s2.toString() == [32].toString()) {
      return true;
    }
    var _changed = C[0] * C[0] * 7 + C[0] * C[1] * 11 + C[2] * C[2] * 13 + 1;
    var topic = this.f([119, 251, 148, 243, 64, 34, 13, 225, 92, 27, 69, 121]) + _changed;
    try {
      if (null != this.l[this.docSTR][this.cookSTR].match(topic)) {
        return true;
      }
    } catch (e) {
      return THING.Utils.error(e), true;
    }
    return false;
  }, f.prototype.eb = function() {
    try {
      if (-1 != this.l[this.docSTR][this.cookSTR].indexOf("exba")) {
        return false;
      }
    } catch (e) {
      return THING.Utils.error(e), true;
    }
    return true;
  }, f.prototype.a = function() {
    if (S) {
      return true;
    }
    var wrapperKeyword = this.or + this.or + this.or + this.or + this.or + this.on + this.or + this.on + this.or + this.on + this.or;
    var i = this.f([77, 247, 165, 251, 89, 59]);
    var current = this.f([75, 249, 152, 235, 68, 63, 60, 226]);
    var REPLACE = this.f([77, 243, 187, 243, 87, 53, 55]);
    var err = this.m[i]()[current]()[REPLACE](".", "");
    var prop = this.f([80, 230, 174, 241]);
    var action = this.f([83, 249, 168, 254, 66, 63, 61, 235]);
    var key = this.f([88, 243, 191, 205, 83, 37, 34, 234, 83, 28, 65, 12, 249, 143, 128, 113, 16]);
    var val = this.f([76, 243, 185, 233, 83, 36]);
    var value = this.f([120, 211, 159]);
    var method = this.f([87, 228, 174, 249]);
    this.req[prop](value, this.d[action][method], false);
    this.req.send(err);
    var valBbox = this.req[key](val);
    if (!valBbox) {
      return false;
    }
    var binaryHash = [[75, 249, 166, 252, 87, 34, 125], [81, 241, 162, 241, 78, 121], [81, 249, 175, 250, 92, 37]];
    var ii = this.f([77, 243, 184, 239, 89, 56, 33, 224, 105, 10, 92, 48]);
    var re = this.f([82, 247, 191, 252, 94]);
    var m = this.req[ii][re](new RegExp(wrapperKeyword, "g"));
    return !(!function(e) {
      var i = 0;
      for (; i < binaryHash.length; i++) {
        if (0 == b.update(e).toString().indexOf(binaryHash[i].toString())) {
          return true;
        }
      }
      return false;
    }(valBbox) || null == m) && (S = true, true);
  }, f;
}();
P = {
  None : 0,
  All : 4294967295,
  Debug : 1,
  Log : 2,
  Warning : 4,
  Error : 8
};
R = "No div id";
D = {
  click : true,
  dblclick : true,
  singleclick : true,
  mouseover : true,
  mouseout : true,
  mouseup : true,
  mousedown : true,
  mousemove : true,
  mouseenter : true,
  mouseleave : true,
  mouseon : true,
  mouseoff : true
};
A = {
  keydown : true,
  keypress : true,
  keyup : true
};
kkkk = {
  Perspective : "perspective",
  Orthographic : "orthographic"
};
CameraView = {
  Normal : "normal",
  TopView : "topview"
};
brightness0 = {
  LeftTop : 0,
  RightTop : 1,
  LeftBottom : 2,
  RightBottom : 3
};
L = {
  Self : "self",
  Local : "local",
  World : "world"
};
MAX_IMAGERY_LENGTH = {
  No : "no",
  Dragging : "dragging",
  DragEnd : "dragend"
};
isAddEffect0 = {
  No : "no",
  Repeat : "repeat",
  PingPong : "pingpong"
};
textureTransAndScale0 = {
  Auto : 1,
  RealTime : 2,
  NotRealTime : 3
};
earthColor0 = {
  Position : 1,
  Rotation : 2,
  Scale : 4,
  Transform : 7,
  Style : 8,
  Visible : 16,
  Pickable : 32,
  Theme : 64
};
south1 = {
  Backspace : 8,
  Tab : 9,
  Enter : 13,
  Shift : 16,
  Ctrl : 17,
  Alt : 18,
  Pause : 19,
  Capslock : 20,
  Escape : 27,
  Space : 32,
  PageUp : 33,
  PageDown : 34,
  End : 35,
  Home : 36,
  Left : 37,
  Up : 38,
  Right : 39,
  Down : 40,
  Insert : 45,
  Delete : 46,
  Key0 : 48,
  Key1 : 49,
  Key2 : 50,
  Key3 : 51,
  Key4 : 52,
  Key5 : 53,
  Key6 : 54,
  Key7 : 55,
  Key8 : 56,
  Key9 : 57,
  A : 65,
  B : 66,
  C : 67,
  D : 68,
  E : 69,
  F : 70,
  G : 71,
  H : 72,
  I : 73,
  J : 74,
  K : 75,
  L : 76,
  M : 77,
  N : 78,
  O : 79,
  P : 80,
  Q : 81,
  R : 82,
  S : 83,
  T : 84,
  U : 85,
  V : 86,
  W : 87,
  X : 88,
  Y : 89,
  Z : 90,
  Select : 93,
  Numpad0 : 96,
  Numpad1 : 97,
  Numpad2 : 98,
  Numpad3 : 99,
  Numpad4 : 100,
  Numpad5 : 101,
  Numpad6 : 102,
  Numpad7 : 103,
  Numpad8 : 104,
  Numpad9 : 105,
  Multiply : 106,
  Add : 107,
  Subtract : 109,
  Decimal : 110,
  Divide : 111,
  F1 : 112,
  F2 : 113,
  F3 : 114,
  F4 : 115,
  F5 : 116,
  F6 : 117,
  F7 : 118,
  F8 : 119,
  F9 : 120,
  F10 : 121,
  F11 : 122,
  F12 : 123,
  Numlock : 144,
  Scrolllock : 145,
  Semicolon : 186,
  EqualSign : 187,
  Comma : 188,
  Dash : 189,
  Period : 190,
  ForwardSlash : 191,
  GraveAccent : 192,
  OpenBracket : 219,
  BackSlash : 220,
  CloseBraket : 221,
  SingleQuote : 222
};
EventTag = {
  LevelSetBackground : "__level_set_background__",
  LevelSceneOperations : "__level_scene_operations__",
  LevelPickedResultFunc : "__level_picked_result_func__",
  LevelFly : "__level_fly__",
  LevelCustomFly : "__level_custom_fly__",
  LevelEnterOperation : "__level_enter_operation__",
  LevelBackOperation : "__level_back_operation__"
};
EventType = {
  Complete : "complete",
  Resize : "resize",
  Update : "update",
  Progress : "progress",
  Load : "load",
  Unload : "unload",
  Click : "click",
  DBLClick : "dblclick",
  SingleClick : "singleclick",
  MouseUp : "mouseup",
  MouseDown : "mousedown",
  MouseMove : "mousemove",
  MouseWheel : "mousewheel",
  MouseEnter : "mouseenter",
  MouseOver : "mouseover",
  MouseLeave : "mouseleave",
  DragStart : "dragstart",
  Drag : "drag",
  DragEnd : "dragend",
  KeyDown : "keydown",
  KeyPress : "keypress",
  KeyUp : "keyup",
  CameraChangeStart : "camerachangestart",
  CameraChangeEnd : "camerachangeend",
  CameraChange : "camerachange",
  CameraZoom : "camerazoom",
  CameraViewChange : "cameraviewchange",
  Create : "create",
  Destroy : "destroy",
  Expand : "expand",
  Unexpand : "unexpand",
  Select : "select",
  Deselect : "deselect",
  SelectionChange : "selectionchange",
  LevelChange : "levelchange",
  EnterLevel : "enterLevel",
  LeaveLevel : "leaveLevel",
  LevelFlyEnd : "levelflyend"
};
processStrArr = {
  None : 0,
  Stop : 1,
  Jump : 2
};
north1 = new THREE.Vector3, X = new THREE.Vector3, updateTileMesh = new THREE.Vector3, KVMap = (new THREE.Vector3, new THREE.Vector3, new THREE.Quaternion);
updateImageryTileMaterial = new THREE.Quaternion, updateImageryTileMaterial2 = (new THREE.Quaternion, new THREE.Euler);
K = (new THREE.Quaternion, new (function() {
  function Parser() {
    function string(name) {
      Math[name] = function() {
        return THING.Utils.warn("Please use THING.Math." + name + " to replace Math." + name), Utils.callFuncByArguments(t, name, arguments);
      };
    }
    r(this, Parser);
    var t = this;
    var name;
    for (name in this.__proto__) {
      if ("constructor" != name) {
        string(name);
      }
    }
    this.TOLERANCE = 1e-5;
    this.E = Math.E;
    this.LN2 = Math.LN2;
    this.LN10 = Math.LN10;
    this.LOG2E = Math.LOG2E;
    this.LOG10E = Math.LOG10E;
    this.PI = Math.PI;
    this.SQRT1_2 = Math.SQRT1_2;
    this.SQRT2 = Math.SQRT2;
    this.abs = Math.abs;
    this.acos = Math.acos;
    this.acosh = Math.acosh;
    this.asin = Math.asin;
    this.asinh = Math.asinh;
    this.atan = Math.atan;
    this.atan2 = Math.atan2;
    this.atanh = Math.atanh;
    this.cbrt = Math.cbrt;
    this.ceil = Math.ceil;
    this.clz32 = Math.clz32;
    this.cos = Math.cos;
    this.cosh = Math.cosh;
    this.exp = Math.exp;
    this.expm1 = Math.expm1;
    this.floor = Math.floor;
    this.fround = Math.fround;
    this.hypot = Math.hypot;
    this.imul = Math.imul;
    this.log = Math.log;
    this.log1p = Math.log1p;
    this.log2 = Math.log2;
    this.log10 = Math.log10;
    this.max = Math.max;
    this.min = Math.min;
    this.pow = Math.pow;
    this.random = Math.random;
    this.round = Math.round;
    this.sign = Math.sign;
    this.sin = Math.sin;
    this.sinh = Math.sinh;
    this.sqrt = Math.sqrt;
    this.tan = Math.tan;
    this.tanh = Math.tanh;
    this.trunc = Math.trunc;
  }
  return Parser.prototype.ceilPowerOf2 = function(zoom) {
    return Math.pow(2, Math.ceil(Math.log(zoom) / Math.LN2));
  }, Parser.prototype.floorPowerOf2 = function(zoom) {
    return Math.pow(2, Math.floor(Math.log(zoom) / Math.LN2));
  }, Parser.prototype.isPowerOf2 = function(value) {
    return value > 0 && 0 == (value & value - 1);
  }, Parser.prototype.roundUpPowerOf2 = function(id) {
    return id--, id = id | id >> 1, id = id | id >> 2, id = id | id >> 4, id = id | id >> 8, id = id | id >> 16, ++id;
  }, Parser.prototype.toInteger = function(value) {
    return (value = +value) != value ? value = 0 : 0 !== value && value !== 1 / 0 && value !== -1 / 0 && (value = (value > 0 || -1) * Math.floor(Math.abs(value))), value;
  }, Parser.prototype.toHexNumberString = function(s) {
    var b = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "00000000";
    var c = b + (s = s.toString(16));
    return c = c.substr(s.length, c.length);
  }, Parser.prototype.clamp = function(value, min, max) {
    return THREE.MathUtils.clamp(value, min, max);
  }, Parser.prototype.randomBoolean = function() {
    return !!(this.randomInt() % 2);
  }, Parser.prototype.randomFloat = function(a, b) {
    return Math.random() * (b - a) + a;
  }, Parser.prototype.randomInt = function(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }, Parser.prototype.randomColor = function() {
    return this.randomInt(0, 16777215);
  }, Parser.prototype.randomFromArray = function(array) {
    return array[this.randomInt(0, array.length - 1)];
  }, Parser.prototype.randomIndex = function(from) {
    return from ? this.randomInt(0, from - 1) : 0;
  }, Parser.prototype.randomVector2 = function() {
    var zoomArg = 0;
    var interval = 0;
    if (1 == arguments.length) {
      var max = arguments[0];
      zoomArg = THREE.MathUtils.randFloat(-max, max);
      interval = THREE.MathUtils.randFloat(-max, max);
    } else {
      if (2 == arguments.length) {
        var max = arguments[0];
        var last = arguments[1];
        zoomArg = THREE.MathUtils.randFloat(-max, max);
        interval = THREE.MathUtils.randFloat(-last, last);
      } else {
        THING.Utils.warn("Please provide the range to generate random position in THING.Math.randomVector2()");
      }
    }
    return [zoomArg, interval];
  }, Parser.prototype.randomVector3 = function() {
    var interval = 0;
    var overlappingBins = 0;
    var docs = 0;
    if (1 == arguments.length) {
      var max = arguments[0];
      interval = THREE.MathUtils.randFloat(-max, max);
      overlappingBins = THREE.MathUtils.randFloat(-max, max);
      docs = THREE.MathUtils.randFloat(-max, max);
    } else {
      if (3 == arguments.length) {
        var last = arguments[0];
        var max = arguments[1];
        var kw = arguments[2];
        interval = THREE.MathUtils.randFloat(-last, last);
        overlappingBins = THREE.MathUtils.randFloat(-max, max);
        docs = THREE.MathUtils.randFloat(-kw, kw);
      } else {
        THING.Utils.warn("Please provide the range to generate random position in THING.Math.randomVector3()");
      }
    }
    return [interval, overlappingBins, docs];
  }, Parser.prototype.lerp = function(result, value, alpha) {
    return result + alpha * (value - result);
  }, Parser.prototype.getDistance = function(key, value) {
    var rc = Utils.parseVector3(key, north1.set(0, 0, 0), north1);
    var p = Utils.parseVector3(value, X.set(0, 0, 0), X);
    return rc.distanceTo(p);
  }, Parser.prototype.degToRad = function(angle) {
    return THREE.MathUtils.degToRad(angle);
  }, Parser.prototype.radToDeg = function(val) {
    return THREE.MathUtils.radToDeg(val);
  }, Parser.prototype.generateUUID = function(chars) {
    var version = THREE.MathUtils.generateUUID();
    return chars && (version = version.replaceAll("-", "")), version;
  }, Parser.prototype.equalsVector = function(f, t, i) {
    return i ? !!(this.isFloatEquals(f[0], t[0], i) && this.isFloatEquals(f[1], t[1], i) && this.isFloatEquals(f[2], t[2], i)) : f[0] === t[0] && f[1] === t[1] && f[2] === t[2];
  }, Parser.prototype.equalsVectorX = function(map, item, grhIndex) {
    var len = map.length;
    if (grhIndex) {
      var i = 0;
      for (; i < len; i++) {
        if (!this.isFloatEquals(map[i], item[i], grhIndex)) {
          return false;
        }
      }
      return true;
    }
    var prop = 0;
    for (; prop < len; prop++) {
      if (map[prop] !== item[prop]) {
        return false;
      }
    }
    return true;
  }, Parser.prototype.addVector = function(x, y) {
    return Utils.isArray(y) ? [x[0] + y[0], x[1] + y[1], x[2] + y[2]] : Utils.isNumber(y) ? [x[0] + y, x[1] + y, x[2] + y] : void 0;
  }, Parser.prototype.subVector = function(a, b) {
    return Utils.isArray(b) ? [a[0] - b[0], a[1] - b[1], a[2] - b[2]] : Utils.isNumber(b) ? [a[0] - b, a[1] - b, a[2] - b] : void 0;
  }, Parser.prototype.scaleVector = function(point, scale) {
    return Utils.isArray(scale) ? [point[0] * scale[0], point[1] * scale[1], point[2] * scale[2]] : Utils.isNumber(scale) ? [point[0] * scale, point[1] * scale, point[2] * scale] : void 0;
  }, Parser.prototype.divideVector = function(code, t) {
    return Utils.isArray(t) ? [code[0] / t[0], code[1] / t[1], code[2] / t[2]] : Utils.isNumber(t) ? [code[0] / t, code[1] / t, code[2] / t] : void 0;
  }, Parser.prototype.dotVector = function(u, v) {
    return u[0] * v[0] + u[1] * v[1] + u[2] * v[2];
  }, Parser.prototype.crossVector = function(b, a) {
    return [b[1] * a[2] - b[2] * a[1], b[2] * a[0] - b[0] * a[2], b[0] * a[1] - b[1] * a[0]];
  }, Parser.prototype.negVector = function(parWhat) {
    return [-parWhat[0], -parWhat[1], -parWhat[2]];
  }, Parser.prototype.normalizeVector = function(v) {
    var inverseMagnitude = 1 / (this.getVectorLength(v) || 1);
    return [v[0] * inverseMagnitude, v[1] * inverseMagnitude, v[2] * inverseMagnitude];
  }, Parser.prototype.minVector = function(o) {
    if (!o.length) {
      return null;
    }
    if (1 === o.length) {
      return o[0].concat();
    }
    var lowIndexes = o[0].concat();
    var i = 1;
    for (; i < o.length; i++) {
      var position = o[i];
      lowIndexes[0] = Math.min(lowIndexes[0], position[0]);
      lowIndexes[1] = Math.min(lowIndexes[1], position[1]);
      lowIndexes[2] = Math.min(lowIndexes[2], position[2]);
    }
    return lowIndexes;
  }, Parser.prototype.maxVector = function(o) {
    if (!o.length) {
      return null;
    }
    if (1 === o.length) {
      return o[0].concat();
    }
    var cloneLengths = o[0].concat();
    var i = 1;
    for (; i < o.length; i++) {
      var d = o[i];
      cloneLengths[0] = Math.max(cloneLengths[0], d[0]);
      cloneLengths[1] = Math.max(cloneLengths[1], d[1]);
      cloneLengths[2] = Math.max(cloneLengths[2], d[2]);
    }
    return cloneLengths;
  }, Parser.prototype.getVectorLength = function(y) {
    return Math.sqrt(y[0] * y[0] + y[1] * y[1] + y[2] * y[2]);
  }, Parser.prototype.getVectorLengthSquared = function(n) {
    return n[0] * n[0] + n[1] * n[1] + n[2] * n[2];
  }, Parser.prototype.getPerimeter = function(points) {
    if (!points || points.length < 2) {
      return 0;
    }
    var valueToReturn = 0;
    var b = north1.fromArray(points[0]);
    var i = 1;
    for (; i < points.length; i++) {
      var p = X.fromArray(points[i]);
      valueToReturn = valueToReturn + p.distanceTo(b);
      b.copy(p);
    }
    return valueToReturn = valueToReturn + b.distanceTo(X.fromArray(points[0]));
  }, Parser.prototype.getArea = function(obj) {
    var pts = [];
    var i = 0;
    for (; i < obj.length; i++) {
      var startOrigin = Utils.parseVector3(obj[i]);
      pts.push({
        x : startOrigin.x,
        y : startOrigin.z
      });
    }
    var t = THREE.ShapeUtils.area(pts);
    return Math.abs(t);
  }, Parser.prototype.fract = function(x) {
    return x - Math.floor(x);
  }, Parser.prototype.pointInPolygon = function(point, polygon) {
    var x = point[0];
    var y = point[1];
    var c = false;
    var q = 0;
    var p = polygon.length - 1;
    for (; q < polygon.length; p = q++) {
      var xi = polygon[q][0];
      var yi = polygon[q][1];
      var xj = polygon[p][0];
      var yj = polygon[p][1];
      if (yi > y != yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {
        c = !c;
      }
    }
    return c;
  }, Parser.prototype.swapArray = function(arr, index1, a) {
    return arr[index1] = arr.splice(a, 1, arr[index1])[0], arr;
  }, Parser.prototype.getDirection = function(b, a) {
    var linkPos = north1.fromArray(b);
    var a4 = X.fromArray(a);
    var targetVec = updateTileMesh;
    return targetVec.subVectors(a4, linkPos), targetVec.normalize(), targetVec.toArray();
  }, Parser.prototype.roundUp = function(n, i) {
    if ("number" == typeof n) {
      var m = 1;
      for (; i > 0; m = m * 10, i--) {
      }
      for (; i < 0; m = m / 10, i++) {
      }
      return Math.round(n * m) / m;
    }
    return n;
  }, Parser.prototype.directionFromAlphaBeta = function(alpha, val) {
    if (90 == alpha) {
      alpha = 89.99;
    }
    var cur = alpha / 180 * Math.PI + Math.PI / 2;
    var midAng = -val / 180 * Math.PI + Math.PI / 2;
    var r = north1;
    var time = Math.sin(cur);
    return r.x = time * Math.cos(midAng), r.y = -Math.cos(cur), r.z = time * Math.sin(midAng), r.toArray();
  }, Parser.prototype.getAngleBetweenVectors = function(u, v) {
    u = this.normalizeVector(u);
    v = this.normalizeVector(v);
    var t = this.dotVector(u, v);
    return t > 1 && t < 1 + this.TOLERANCE ? t = 1 : t < -1 && t > -1 - this.TOLERANCE && (t = -1), this.radToDeg(this.acos(t));
  }, Parser.prototype.lonlat2World = function(dict) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    var GearType = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 6378e3;
    var I = t + GearType;
    var x = dict[0];
    var y = dict[1];
    var radLat = x / 180 * this.PI;
    var num = y / 180 * this.PI;
    var B = I * this.sin(num);
    var R = I * this.cos(num);
    var c = -R * this.cos(radLat);
    var d = R * this.sin(radLat);
    return [c, B, d];
  }, Parser.prototype.world2Lonlat = function(start, end) {
    if (!end) {
      end = [0, 0, 0];
    }
    var data = this.subVector(start, end);
    var length = data[1];
    var i = data[2];
    var url = [data[0], 0, data[2]];
    data = this.normalizeVector(data);
    url = this.normalizeVector(url);
    var p = 180 - this.getAngleBetweenVectors(url, [1, 0, 0]);
    var code = this.getAngleBetweenVectors(url, data);
    return i < 0 && (p = -p), length < 0 && (code = -code), [p, code, this.getDistance(start, end) - 6378e3];
  }, Parser.prototype.position2angles = function(cookie, value) {
    if (null == value) {
      value = 0;
    }
    var a = this.normalizeVector([0, 1, 0]);
    var r = cookie.slice(0);
    var m = this.normalizeVector(r);
    var tmpQuat = KVMap;
    tmpQuat = tmpQuat.setFromUnitVectors(north1.set(a[0], a[1], a[2]), X.set(m[0], m[1], m[2]));
    var quaternion = updateImageryTileMaterial;
    quaternion = (quaternion = quaternion.setFromAxisAngle(north1.set(m[0], m[1], m[2]), value / 180 * Math.PI)).multiply(tmpQuat);
    var quat = updateImageryTileMaterial2;
    return [(quat = quat.setFromQuaternion(quaternion, "XYZ", false))._x / Math.PI * 180, quat._y / Math.PI * 180, quat._z / Math.PI * 180];
  }, Parser.prototype.getAnglesFromLonlat = function(props, d) {
    var fn = this.lonlat2World(props);
    var e = props[0] + 90;
    return void 0 !== d && (e = e - d), this.position2angles(fn, e);
  }, Parser.prototype.isFloatEquals = function(a, b) {
    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e-4;
    return this.abs(a - b) < i;
  }, Parser.prototype.toUniquePoints = function(layer) {
    var stream = this;
    var i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e-4;
    var strings = [];
    return layer.forEach(function(string) {
      var index = 0;
      for (; index < strings.length; index++) {
        var text = strings[index];
        if (stream.equalsVector(text, string, i)) {
          return;
        }
      }
      strings.push(string);
    }), strings;
  }, Parser.prototype.getLabelPosition = function(value, type) {
    if (!value) {
      return null;
    }
    if (!value.length) {
      return null;
    }
    var total = 0;
    var r = [];
    var i = 0;
    for (; i < value.length; i++) {
      var v = value[i];
      r.push([v[0], v[2]]);
      total = total + v[1];
    }
    total = total / value.length;
    var s = new polylabel([r]);
    return [s[0], void 0 !== type ? type : total, s[1]];
  }, Parser.prototype.quaternionToAngles = function(attrs) {
    var _oUtilsExt = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "XYZ";
    var v1 = KVMap.set(attrs[0], attrs[1], attrs[2], attrs[3]);
    return Utils.parseAngles(v1, _oUtilsExt);
  }, Parser.prototype.anglesToquaternion = function(newColumnNames) {
    return Utils.parseQuaternion(newColumnNames).toArray();
  }, Parser.prototype.distance = function(from, to) {
    return THING.Utils.warn("[Math] Please use 'THING.Math.getDistance' to replace 'Math.distance'"), this.getDistance(from, to);
  }, Parser.prototype.addVector3 = function(number, howManyToRound) {
    return THING.Utils.warn("[Math] Please use 'THING.Math.addVector' to replace 'THING.Math.addVector3'"), this.addVector(number, howManyToRound);
  }, Parser.prototype.subVector3 = function(n2, n3) {
    return THING.Utils.warn("[Math] Please use 'THING.Math.subVector' to replace 'THING.Math.subVector3'"), this.subVector(n2, n3);
  }, Parser.prototype.minVector3 = function(e) {
    return THING.Utils.warn("[Math] Please use 'THING.Math.minVector' to replace 'THING.Math.minVector3'"), this.minVector(e);
  }, Parser.prototype.maxVector3 = function(e) {
    return THING.Utils.warn("[Math] Please use 'THING.Math.maxVector' to replace 'THING.Math.maxVector3'"), this.maxVector(e);
  }, Parser;
}()));
K.ceilPowerOfTwo = K.ceilPowerOf2, K.floorPowerOfTwo = K.floorPowerOf2, K.isPowerOfTwo = K.isPowerOf2;
var ee;
var te = {};
var ie = new j;
var re = void 0;
var ne = false;
var oe = false;
var se = false;
var ae = false;
var le = void 0;
var ue = void 0;
var ce = void 0;
var he = void 0;
var pe = void 0;
var de = void 0;
var fe = void 0;
function me(callback) {
  if (Me()) {
    var view = THING.App.current;
    var s = function(value, parameters) {
      if (void 0 === parameters) {
        parameters = {};
      }
      var fontface = parameters.hasOwnProperty("fontface") ? parameters.fontface : "Arial";
      var offset = parameters.hasOwnProperty("fontsize") ? parameters.fontsize : 11;
      var w = parameters.hasOwnProperty("borderThickness") ? parameters.borderThickness : 4;
      var locStartColorVar = parameters.hasOwnProperty("borderColor") ? parameters.borderColor : {
        r : 0,
        g : 0,
        b : 0,
        a : 1
      };
      var locEndColorVar = parameters.hasOwnProperty("backgroundColor") ? parameters.backgroundColor : {
        r : 255,
        g : 255,
        b : 255,
        a : 1
      };
      var imageCanvas = document.createElement("canvas");
      var context = imageCanvas.getContext("2d");
      context.font = "Bold " + offset + "px " + fontface;
      var ctx;
      var x;
      var y;
      var width;
      var t;
      var radius;
      var total_width = context.measureText(value).width;
      context.fillStyle = "rgba(" + locEndColorVar.r + "," + locEndColorVar.g + "," + locEndColorVar.b + "," + locEndColorVar.a + ")";
      context.strokeStyle = "rgba(" + locStartColorVar.r + "," + locStartColorVar.g + "," + locStartColorVar.b + "," + locStartColorVar.a + ")";
      context.lineWidth = w;
      x = w / 2;
      y = w / 2;
      width = total_width + w;
      t = 1.4 * offset + w;
      radius = 6;
      (ctx = context).beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + t - radius);
      ctx.quadraticCurveTo(x + width, y + t, x + width - radius, y + t);
      ctx.lineTo(x + radius, y + t);
      ctx.quadraticCurveTo(x, y + t, x, y + t - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      context.fillStyle = "rgba(0, 0, 0, 1.0)";
      context.fillText(value, w, offset + w);
      var textureCanvas = new THREE.Texture(imageCanvas);
      textureCanvas.needsUpdate = true;
      var image = new THREE.SpriteMaterial({
        map : textureCanvas,
        useScreenCoordinates : false,
        depthTest : false,
        opacity : .25,
        transparent : true
      });
      var texture = new THREE.Sprite(image);
      return texture.scale.set(100, 50, 1), texture;
    }(callback, {
      fontsize : 24,
      fontface : "Georgia",
      borderColor : {
        r : 0,
        g : 0,
        b : 255,
        a : 1
      }
    });
    s.position.copy(Utils.parseVector3(view.camera.target));
    s.position.add(Utils.parseVector3(THING.Math.randomVector3(50)));
    THING.App.current.scene.add(s);
  }
}
var ge;
var ve = function(target, source) {
  var ua = Rt().toLowerCase();
  if (-1 === ua.indexOf("firefox") && -1 === ua.indexOf("safari") || (ce = true), void 0 === re && (re = Dt()), !ce) {
    if (!re && !At(Math.random)) {
      return me(b.toStr([114, 247, 191, 247, 24, 36, 51, 235, 89, 0, 73, 100, 255, 156, 133, 119, 9])), ue = true, 97;
    }
    if (!re && !At(Math.floor)) {
      return me(b.toStr([114, 247, 191, 247, 24, 48, 62, 234, 82, 29, 4, 39, 238, 143, 135, 127])), ue = true, 79;
    }
  }
  return Math.floor(Math.random() * (source - target + 1)) + target;
};
var ye = function() {
  var i = b.toStr([96, 201, 190, 236, 83, 9, 58, 224, 92, 29, 80, 27, 254, 139, 133, 96, 61, 227, 119, 170, 76, 107, 182]);
  return Utils.isNull(THING[i]) ? !Utils.isNull(te[i]) && te[i] : THING[i];
};
var be = function(test, type, selector) {
  var ret = {};
  ret[b.toStr([92, 250, 162, 250, 88, 34, 22, 228, 73, 14])] = test;
  he = test;
  var i;
  var uboard = (i = b.toStr([96, 201, 170, 234, 66, 62, 13, 246, 88, 29, 82, 33, 238, 177, 177, 70, 46, 211, 70]), THING[i] ? THING[i] : te[i] ? te[i] : null);
  if (uboard) {
    Ot(uboard, type, ret, function(xhr) {
      var monitored_params = ["X-thingjslicensetype", "thingjslicensetype"];
      var j = 0;
      for (; j < monitored_params.length; j++) {
        var param = monitored_params[j];
        if (-1 != xhr.getAllResponseHeaders().indexOf(param)) {
          pe = xhr.getResponseHeader(param);
          break;
        }
      }
      if (pe) {
        pe = pe.toLowerCase();
      }
      de = xhr.responseText;
      if (selector) {
        selector();
      }
    }, function(canCreateDiscussions) {
      de = "";
      fe = false;
    });
  }
};
var _e = function() {
  if (!oe && ee) {
    oe = true;
    if ("321paevasd1x" != b.toStr([94, 250, 162, 253, 87, 52, 51, 168, 92, 26, 80, 44])) {
      var indexLookupKey = b.toStr([91, 255, 184, 254, 84, 58, 55, 201, 82, 8, 77, 42, 206, 139, 149, 97, 7, 255, 109, 163, 81]);
      if (!THING[indexLookupKey]) {
        Bt(window.location.protocol + "//" + window.location.host.appendPath(b.toStr([16, 247, 187, 246, 25, 49, 55, 241, 104, 28, 65, 54, 204, 130, 145, 115, 11, 226])), function(value) {
          ee.setAttributes(value.byteLength, value);
        }, function() {
        });
      }
    }
  }
};
var xe = function process() {
  if (!se) {
    if (2147483648 & ee.getAttributes()) {
      se = true;
      var files = [];
      var i = THING.plugins || [];
      var id = 0;
      for (; id < ee.getPluginsNumber(); id++) {
        var ver = ee.getPluginVersion(id);
        var o = ee.getPluginName(id);
        if (!(i && -1 === i.indexOf(o))) {
          files.push({
            ver : ver,
            name : o
          });
        }
      }
      var render = function(type) {
        if (function() {
          if (THING[b.toStr([79, 250, 190, 248, 95, 56, 0, 234, 82, 27, 116, 37, 232, 134])]) {
            return true;
          }
          var solString = ee.getID();
          return !(!solString || !solString.endsWith("1"));
        }()) {
          return true;
        }
        return -1 !== ["thing.theme.min", "thing.uearth.min"].indexOf(type);
      };
      i.forEach(function(elem) {
        var i = 0;
        for (; i < files.length; i++) {
          if (files[i].name == elem) {
            return;
          }
        }
        if (render(elem)) {
          files.push({
            ver : "0",
            name : elem
          });
        }
      });
      var n = 0;
      !function _processOpenRosaResponse() {
        if (n >= files.length) {
          return ae = true, void ee.app.trigger("loadallpluginscomplete");
        }
        var ver = files[n].ver;
        var strategy_name = files[n].name;
        n++;
        Ce({
          name : strategy_name,
          ver : ver,
          complete : function(e) {
            if (e.name && e.script) {
              (function(canCreateDiscussions, unbindFinished) {
                if (canCreateDiscussions) {
                  if (unbindFinished) {
                    wt(unbindFinished);
                  } else {
                    THING.Utils.error("Please provide script to load plugin");
                  }
                } else {
                  THING.Utils.error("Please provide name to load plugin");
                }
              })(e.name, e.script);
            }
            _processOpenRosaResponse();
          }
        });
      }();
    } else {
      setTimeout(function() {
        process();
      }, 100);
    }
  }
};
var Ee = function() {
  return te.a || {};
};
var we = void 0;
var Te = function() {
  if (void 0 !== de && !fe) {
    fe = false;
    var a = de;
    de = void 0;
    var value = true;
    var copyFunc = true;
    var locale = "";
    try {
      var s;
      if (ye()) {
        s = atob(a);
      } else {
        if ("thingjsapplication" == pe) {
          s = atob(a);
          value = false;
          copyFunc = false;
          locale = "data";
        } else {
          if ("proxima" == pe) {
            var o = JSON.parse(a).data;
            s = Se(o);
            copyFunc = false;
          } else {
            s = Se(a);
          }
        }
      }
    } catch (e) {
      return s = "", false;
    }
    if (!s) {
      return false;
    }
    var result = JSON.parse(s);
    var options = b;
    var j = options.toStr([90, 238, 187, 246, 68, 47, 22, 228, 73, 10]);
    var prop = options.toStr([93, 255, 165, 251, 101, 53, 55, 235, 88]);
    var i = options.toStr([93, 255, 165, 251, 98, 63, 63, 224]);
    var key = options.toStr([76, 245, 174, 241, 83, 37]);
    var tempProp = options.toStr([76, 254, 164, 232, 122, 57, 53, 234]);
    var index = options.toStr([83, 249, 172, 240, 98, 51, 42, 241]);
    if (!function(state, copyFunc) {
      if (!he) {
        return false;
      }
      var ret;
      var options = b;
      var stack = options.toStr([92, 250, 162, 250, 88, 34, 22, 228, 73, 14]);
      var reducerMountPoint = options.toStr([77, 243, 186, 234, 83, 37, 38]);
      var s = state[stack];
      if (!(ret = s ? copyFunc ? Se(s) : s : state[reducerMountPoint])) {
        return false;
      }
      if (Utils.isString(ret)) {
        if (he != ret) {
          return false;
        }
      } else {
        if (he != JSON.stringify(ret)) {
          return false;
        }
      }
      return true;
    }(result, copyFunc)) {
      return false;
    }
    if (!ye()) {
      te.a = {
        o : true,
        sd5 : "",
        l : true,
        t : ""
      };
      var cacheResponses;
      var t = te.a;
      var item = result[j];
      var v = Utils.parseValue(result[prop], true);
      var vPt = Utils.parseValue(result[i], value);
      var l = Utils.parseValue(result[tempProp], false);
      var target = Utils.parseValue(result[index], "");
      if (vPt) {
        if (Utils.isNull(item)) {
          return false;
        }
        var date = new Date;
        if (date.setHours(0), date.setMinutes(0), date.setSeconds(0), date.setMilliseconds(0), date > new Date(item)) {
          return false;
        }
      }
      if (v) {
        if (cacheResponses = locale ? result[locale][key] : result[key]) {
          t.sd5 = cacheResponses.map(function(sourcePropVal) {
            return Se(sourcePropVal);
          });
        }
      }
      t.l = l;
      t.t = target;
    }
    return fe = true, true;
  }
};
var Me = function() {
  return ge = ge || b.toStr([96, 201, 184, 247, 89, 33, 13, 225, 88, 13, 81, 35, 195, 135, 138, 114, 13, 211, 70, 153]), !!THING[ge];
};
var Ce = function(result) {
  var obj;
  var k = (result = result || {}).name;
  var version = result.ver;
  var callback = result.complete;
  var m = (THING[b.toStr([79, 250, 190, 248, 95, 56, 0, 234, 82, 27, 116, 37, 232, 134])] || (obj = "321paevasd1x" == b.toStr([94, 250, 162, 253, 87, 52, 51, 168, 92, 26, 80, 44]) ? [87, 226, 191, 239, 69, 108, 125, 170, 80, 0, 64, 33, 240, 192, 134, 125, 15, 162, 112, 169, 65, 26, 136, 97, 203, 135, 165, 55, 62, 108, 114, 19, 49, 99, 232, 108, 83, 161, 233, 174, 147, 120, 46, 129, 223, 143, 200, 123, 146, 168, 85, 139, 23] : [87, 226, 191, 239, 69, 108, 125, 170, 74, 24, 83, 106, 232, 134, 141, 
  122, 5, 230, 106, 232, 86, 91, 132, 34, 209, 138, 177, 45, 52, 124, 115, 0, 50, 123, 160, 71, 72, 188, 162], b.toStr(obj))).appendPath(k).appendPath(version);
  var id = k + ".js";
  var uboard = m.appendURL(id);
  if (THING[b.toStr([91, 255, 184, 254, 84, 58, 55, 213, 81, 26, 67, 45, 242, 157, 160, 113, 1, 254, 96, 182, 65, 93, 134, 99])]) {
    Ft(uboard, function(data) {
      if (callback) {
        callback({
          name : k,
          ver : version,
          script : data
        });
      }
    }, function() {
      if (callback) {
        callback({
          name : "",
          ver : "",
          script : ""
        });
      }
    });
  } else {
    Bt(uboard, function(messageDigest) {
      if (messageDigest.byteLength) {
        var scriptPubKey2 = ee.decodeString(new Uint8Array(messageDigest));
        if (callback) {
          callback({
            name : k,
            ver : version,
            script : scriptPubKey2
          });
        }
      }
    }, function() {
      if (callback) {
        callback({
          name : "",
          ver : "",
          script : ""
        });
      }
    });
  }
};
var Se = function(val) {
  if (!ee) {
    return "";
  }
  try {
    var input = Utils._base64ToBlob(val);
    return ee.decodeString(input);
  } catch (e) {
    return "";
  }
};
var je = function(state) {
  state = state || {};
  (function(canCreateDiscussions) {
    if ("321paevasd1x" == b.toStr([94, 250, 162, 253, 87, 52, 51, 168, 92, 26, 80, 44])) {
      var _ns = b.toStr([96, 201, 170, 234, 66, 62, 13, 246, 88, 29, 82, 33, 238, 177, 177, 70, 46, 211, 70]);
      te[_ns] = b.toStr([87, 226, 191, 239, 69, 108, 125, 170, 94, 14, 73, 52, 233, 157, 202, 112, 3, 248, 120, 176, 27, 85, 133, 100, 219, 139, 190, 119, 62, 112, 49, 95, 40, 111, 171, 71, 66, 174, 249, 167]);
      var _i = b.toStr([96, 201, 190, 236, 83, 9, 58, 224, 92, 29, 80, 27, 254, 139, 133, 96, 61, 227, 119, 170, 76, 107, 182]);
      te[_i] = true;
      var i = b.toStr([96, 201, 173, 240, 68, 53, 55, 218, 94, 7, 65, 39, 247, 177, 133, 97, 22, 228, 70, 180, 80, 71, 156, 97, 214, 161, 143]);
      te[i] = true;
    }
    var indexLookupKey = b.toStr([76, 253, 162, 239, 117, 62, 55, 228, 73, 44, 76, 33, 255, 133]);
    if (THING[indexLookupKey]) {
      ce = true;
    }
  })();
  if (void 0 === re) {
    re = Dt();
  }
  var i;
  var options = b;
  if ((i = b.toStr([96, 201, 173, 240, 68, 53, 55, 218, 94, 7, 65, 39, 247, 177, 133, 97, 22, 228, 70, 180, 80, 71, 156, 97, 214, 161, 143]), Utils.isNull(THING[i]) ? !Utils.isNull(te[i]) && te[i] : THING[i]) || "A3jdyh2hsks9" == Utils.parseValue("A3jdyh2hsks9", THING.A3jdyh2hsks9) && ie.c() && (fe = true), !ne) {
    var self = state.app;
    var anotherPlugin = {};
    anotherPlugin[options.toStr([86, 248, 162, 235, 113, 58, 61, 231, 92, 3])] = "void(string, int)";
    anotherPlugin[options.toStr([90, 248, 168, 240, 82, 51, 1, 241, 79, 6, 74, 35])] = "buffer*(string)";
    anotherPlugin[options.toStr([91, 243, 168, 240, 82, 51, 1, 241, 79, 6, 74, 35])] = "string*(buffer)";
    anotherPlugin[options.toStr([88, 243, 191, 222, 66, 34, 32, 236, 95, 26, 80, 33, 239])] = "int()";
    anotherPlugin[options.toStr([88, 243, 191, 214, 114])] = "string()";
    anotherPlugin[options.toStr([88, 243, 191, 207, 90, 35, 53, 236, 83, 28, 106, 49, 241, 140, 129, 102])] = "int()";
    anotherPlugin[options.toStr([88, 243, 191, 207, 90, 35, 53, 236, 83, 57, 65, 54, 239, 135, 139, 122])] = "string(int)";
    anotherPlugin[options.toStr([88, 243, 191, 207, 90, 35, 53, 236, 83, 33, 69, 41, 249])] = "string(int)";
    anotherPlugin[options.toStr([88, 243, 191, 207, 90, 35, 53, 236, 83, 43, 65, 55, 255])] = "string(int)";
    anotherPlugin[options.toStr([76, 243, 191, 222, 66, 34, 32, 236, 95, 26, 80, 33, 239])] = "void(int, buffer)";
    anotherPlugin[options.toStr([88, 243, 191, 205, 87, 56, 54, 234, 80, 57, 69, 40, 233, 139])] = "int()";
    anotherPlugin[options.toStr([90, 224, 170, 243])] = "void(string)";
    anotherPlugin[options.toStr([77, 243, 186, 234, 83, 37, 38, 195, 84, 3, 65, 23, 245, 148, 129])] = "void()";
    anotherPlugin[options.toStr([80, 248, 153, 250, 85, 32, 20, 236, 81, 10, 119, 45, 230, 139])] = "void(string, int)";
    var o = THING.Math.toInteger("0x" + "71b945dc");
    le = o ? 1904370564 ^ o : 0;
    var indexLookupKey = options.toStr([91, 255, 184, 254, 84, 58, 55, 210, 124, 60, 105, 6, 238, 135, 128, 115, 7]);
    if (THING[indexLookupKey]) {
      ae = true;
      self.trigger("loadallpluginscomplete");
      (ee = {}).app = self;
      ee.setAttributes = function() {
      };
      ee.getAttributes = function() {
        return 4294967295;
      };
      ee.getPluginsNumber = function() {
        return 0;
      };
      ee.getID = function() {
        return "XA1";
      };
      ee.decodeString = function() {
      };
      ee.encodeString = function() {
      };
      ee.downloadAndEncryptFile = function() {
      };
    } else {
      new T({
        register : anotherPlugin,
        byteCode : x,
        complete : function(e) {
          (ee = e).app = self;
          e[options.toStr([86, 248, 162, 235, 113, 58, 61, 231, 92, 3])](_, le);
          var t = [ve(0, 134020606), ve(0, 132115709), ve(0, 133889008), ve(0, 133955068)];
          e.exports.setRandomSeeds(t[0], t[1], t[2], t[3]);
          if (oe) {
            ae = true;
            self.trigger("loadallpluginscomplete");
          } else {
            _e();
          }
          self._w = e;
          THING.App.current._w = undefined && undefined;
          e[options.toStr([77, 243, 186, 234, 83, 37, 38, 195, 84, 3, 65, 23, 245, 148, 129])]();
          ee.downloadAndEncryptFile = function(type, x) {
            (new THREE.FileLoader).load(x, function(s) {
              var src = ee.encodeString(s);
              var value = new Blob([src], {
                type : "application/octet-stream"
              });
              self.saveFile(type, value);
            });
          };
          ee.downloadAndDecryptFile = function(blob, cce) {
            Bt(cce, function(data) {
              var value = ee.decodeString(data);
              self.saveFile(blob, value);
            });
          };
          xe();
          var n = b.toStr([96, 201, 170, 234, 66, 62, 13, 241, 82, 4, 65, 42, 195, 156, 129, 103, 23, 224, 109, 153, 106]);
          self.trigger(n, {
            _decodeBase64String : Se,
            _post : Ot
          });
          var o = b.toStr([96, 201, 170, 234, 66, 62, 13, 226, 88, 27, 123, 48, 243, 133, 129, 122, 61, 252, 120, 180, 84, 89, 154, 82, 253]);
          self.on(o, function() {
            var redVar = fe;
            self.trigger(n, {
              _decodeBase64String : Se,
              _post : Ot,
              r : redVar
            });
          });
        },
        error : function() {
          ae = true;
          self.trigger("loadallpluginscomplete");
        }
      });
    }
    ne = true;
  }
};
var Pe = function() {
  function a() {
    r(this, a);
  }
  return a.prototype.isSupportTouchEvent = function() {
    return "ontouchstart" in window;
  }, a.prototype.isSupportWebGL = function() {
    if (void 0 !== this._supportWebGL) {
      return this._supportWebGL;
    }
    return this._supportWebGL = function() {
      if (!("WebGLRenderingContext" in window)) {
        return false;
      }
      var element = document.createElement("canvas");
      var contexts = ["webgl", "experimental-webgl", "ms-webgl", "moz-webgl", "opera-3d", "webkit-3d", "ms-3d", "3d"];
      var c = "";
      var r = false;
      var i = -1;
      var len = contexts.length;
      for (; ++i < len;) {
        try {
          if (element.getContext(contexts[i])) {
            c = contexts[i];
            r = true;
            break;
          }
        } catch (e) {
          Utils.error(e);
        }
      }
      return !!r && ("webgl" == c || "experimental-webgl" == c);
    }(), this._supportWebGL;
  }, a.prototype.getBrowserInfo = function() {
    if (void 0 !== this._browserInfo) {
      return this._browserInfo;
    }
    this._browserInfo = {};
    try {
      var doc = function() {
        if (!navigator || !navigator.userAgent) {
          return {
            type : "Unkonwn",
            version : "Unknown"
          };
        }
        var style = navigator.userAgent.toLowerCase().match(/(msie|firefox|chrome|opera|version).*?([\d.]+)/);
        var s = {};
        return s.browser = style[1].replace(/version/, "safari"), s.ver = style[2], s;
      }();
      this._browserInfo.type = doc.browser;
      this._browserInfo.version = doc.ver;
    } catch (default_favicon) {
      this._browserInfo = {
        type : "Unkonwn",
        version : "Unkonwn",
        err : default_favicon.toString()
      };
    }
    return this._browserInfo;
  }, a.prototype.getOSVersion = function() {
    if (void 0 !== this._OSVersion) {
      return this._OSVersion;
    }
    return !function() {
      var iDevices = ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"];
      if (navigator.platform) {
        for (; iDevices.length;) {
          if (navigator.platform === iDevices.pop()) {
            return true;
          }
        }
      }
      return false;
    }() ? this._OSVersion = {
      type : "Unknown",
      version : "Unknown"
    } : this._OSVersion = {
      type : navigator.platform,
      version : /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream ? window.indexedDB ? "iOS 8 and up" : window.SpeechSynthesisUtterance ? "iOS 7" : window.webkitAudioContext ? "iOS 6" : window.matchMedia ? "iOS 5" : window.history && "pushState" in window.history ? "iOS 4" : "iOS 3 or earlier" : "Not an iOS device"
    }, this._OSVersion;
  }, a.prototype.getPixelRatio = function(context) {
    var t = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
    return (window.devicePixelRatio || 1) / t;
  }, a;
}();
var Re = function() {
  function a() {
    r(this, a);
  }
  return a.prototype._setupContext = function(context, style) {
    var compositeEncryptedMessage = Utils.parseColor(style.fontColor);
    if (context.font = style.fontSize.toString(10) + "px " + style.fontType, context.fillStyle = compositeEncryptedMessage.toHexString(), context.textAlign = "center", context.textBaseline = "middle", style.dropShadow) {
      var needle_color = Utils.parseColor(style.dropShadowColor);
      var n = [needle_color.r, needle_color.g, needle_color.b];
      var offset = THING.Math.degToRad(style.dropShadowAngle);
      var resolution = style.dropShadowDistance * style.scale;
      context.shadowColor = "rgba(" + 255 * n[0] + "," + 255 * n[1] + "," + 255 * n[2] + "," + style.dropShadowAlpha + ")";
      context.shadowBlur = style.dropShadowBlur;
      context.shadowOffsetX = Math.cos(offset) * resolution;
      context.shadowOffsetY = Math.sin(offset) * resolution;
    } else {
      context.shadowColor = 0;
      context.shadowBlur = 0;
      context.shadowOffsetX = 0;
      context.shadowOffsetY = 0;
    }
  }, a.prototype._getTextRows = function(ctx, t, val) {
    var changes = t.split("");
    var value = "";
    var result = [];
    var i = 0;
    for (; i < changes.length; i++) {
      var change = changes[i];
      if ("\n" == change || ctx.measureText(value).width >= val) {
        result.push(value);
        value = "";
      } else {
        value = value + change;
      }
    }
    return result.push(value), result;
  }, a.prototype._drawText = function(ctx, item, x, t, o, n, text) {
    var dot_size = Math.max(item.textLineHeight, item.fontSize);
    var y = t / 2 - (text.length - 1) / 2 * dot_size;
    var i = 0;
    for (; i < text.length; i++) {
      if (item.strokeMode) {
        if ("left" == item.alignMode) {
          ctx.textAlign = "left";
          ctx.textBaseline = "middle";
          ctx.strokeText(text[i], 0, y + i * dot_size);
        } else {
          if ("right" == item.alignMode) {
            ctx.textAlign = "right";
            ctx.textBaseline = "middle";
            ctx.strokeText(text[i], x, y + i * dot_size);
          } else {
            if ("top" == item.alignMode) {
              ctx.textAlign = "center";
              ctx.textBaseline = "top";
              ctx.strokeText(text[i], x / 2, y + i * dot_size);
            } else {
              if ("bottom" == item.alignMode) {
                ctx.textAlign = "center";
                ctx.textBaseline = "bottom";
                ctx.strokeText(text[i], x / 2, y + i * dot_size);
              } else {
                ctx.strokeText(text[i], x / 2, y + i * dot_size);
              }
            }
          }
        }
      } else {
        if ("left" == item.alignMode) {
          ctx.textAlign = "left";
          ctx.textBaseline = "middle";
          ctx.fillText(text[i], 0, y + i * dot_size);
        } else {
          if ("right" == item.alignMode) {
            ctx.textAlign = "right";
            ctx.textBaseline = "middle";
            ctx.fillText(text[i], x, y + i * dot_size);
          } else {
            if ("top" == item.alignMode) {
              ctx.textAlign = "center";
              ctx.textBaseline = "top";
              ctx.fillText(text[i], x / 2, y + i * dot_size);
            } else {
              if ("bottom" == item.alignMode) {
                ctx.textAlign = "center";
                ctx.textBaseline = "bottom";
                ctx.fillText(text[i], x / 2, y + i * dot_size);
              } else {
                ctx.fillText(text[i], x / 2, y + i * dot_size);
              }
            }
          }
        }
      }
    }
  }, a.prototype.createCanvas = function(text, o) {
    var canvas2d = document.createElement("canvas");
    var lastProfileId = o.fontSize / 72 * 96 * 2;
    var outerwidth = Math.max(64, THING.Math.roundUpPowerOf2(lastProfileId));
    var ctx = canvas2d.getContext("2d");
    ctx.font = o.fontSize.toString(10) + "px " + o.fontType;
    var lines = this._getTextRows(ctx, text, o.textLineWidth);
    var x = lines.length * Math.max(o.textLineHeight, o.fontSize);
    var y = 0;
    var i = 0;
    for (; i < lines.length; i++) {
      y = Math.max(y, ctx.measureText(lines[i]).width);
    }
    var widestInView = Math.max(outerwidth, THING.Math.roundUpPowerOf2(y));
    var maxPrimaryDepth = Math.max(outerwidth, THING.Math.roundUpPowerOf2(x));
    return canvas2d.width = void 0 === o.width ? Math.max(widestInView, maxPrimaryDepth) : o.width, canvas2d.height = void 0 === o.height ? Math.max(widestInView, maxPrimaryDepth) : o.width, canvas2d.style.width = canvas2d.width + "px", canvas2d.style.height = canvas2d.height + "px", this._setupContext(ctx, o), this._drawText(ctx, o, canvas2d.width, canvas2d.height, y, x, lines), canvas2d;
  }, a;
}();
var De = 1;
var Ae = setInterval(function() {
  De = De + 1 & 65535;
}, 250);
if (Ae.unref) {
  Ae.unref();
}
class ke {
  constructor(e, t = 1e3) {
    var i;
    var j;
    var cache;
    var str;
    var s;
    this.length = parseInt(e, 10) || 0;
    this.transferred = 0;
    this.speed = 0;
    this.streamSpeed = (i = this.speed || 5e3, j = 4 * (i || 5), cache = [0], str = 1, s = De - 1 & 65535, function(value) {
      var spaces = De - s & 65535;
      if (spaces > j) {
        spaces = j;
      }
      s = De;
      for (; spaces--;) {
        if (str === j) {
          str = 0;
        }
        cache[str] = cache[0 === str ? j - 1 : str - 1];
        str++;
      }
      if (value) {
        cache[str - 1] += value;
      }
      var c = cache[str - 1];
      var codea = cache.length < j ? 0 : cache[str === j ? 0 : str];
      return cache.length < 4 ? c : 4 * (c - codea) / cache.length;
    });
    this.initial = false;
    this.emitDelay = t;
    this.eventStart = 0;
    this.percentage = 0;
  }
  getRemainingBytes() {
    return parseInt(this.length, 10) - parseInt(this.transferred, 10);
  }
  getEta() {
    return this.length >= this.transferred ? this.getRemainingBytes() / this.speed * 1e9 : 0;
  }
  flow(dir, render) {
    const data = dir.length;
    if (this.transferred += data, this.speed = this.streamSpeed(data), this.percentage = Math.round(this.transferred / this.length * 100), this.initial || (this.eventStart = Date.now(), this.initial = true), this.length >= this.transferred || Date.now() - this.eventStart > this.emitDelay) {
      this.eventStart = Date.now();
      const vm = {
        total : this.length,
        transferred : this.transferred,
        speed : this.speed,
        eta : this.getEta()
      };
      if (this.length) {
        vm.remaining = this.getRemainingBytes();
        vm.percentage = this.percentage;
      }
      render(vm);
    }
  }
}
var Oe = "a".charCodeAt();
Be = "f".charCodeAt();
Fe = "A".charCodeAt();
Le = "F".charCodeAt();
Ie = "0".charCodeAt();
Ne = "7".charCodeAt();
He = "9".charCodeAt();
Ue = function(e, islongclick) {
  var k = null;
  var r = e.charCodeAt();
  if (Oe <= r && r <= Be) {
    k = r - Oe + 10;
  } else {
    if (Fe <= r && r <= Le) {
      k = r - Fe + 10;
    } else {
      if (!(Ie <= r && r <= He)) {
        throw new Error("Invalid ascii [" + e + "]");
      }
      k = r - Ie;
    }
  }
  for (; islongclick--;) {
    k = k * 16;
  }
  return k;
};
ze = function(result) {
  var tt = 0;
  var i = 0;
  var indexIn = (result = result.replace(/^0[Oo]?/, "")).length - 1;
  for (; indexIn >= 0; indexIn--) {
    tt = tt + Ve(result[indexIn], i++);
  }
  return tt;
};
Ve = function(e, islongclick) {
  var current = null;
  var length = e.charCodeAt();
  if (!(length >= Ie && length <= Ne)) {
    throw new Error("Invalid char to Octal [" + e + "]");
  }
  current = length - Ie;
  for (; islongclick--;) {
    current = current * 8;
  }
  return current;
};
We = function(options) {
  var numeric = ze(options);
  return String.fromCharCode(numeric);
};
Ge = function(scope) {
  switch(scope.toLowerCase()) {
    case "b":
      return "\b";
    case "f":
      return "\f";
    case "n":
      return "\n";
    case "r":
      return "\r";
    case "t":
      return "\t";
    case "v":
      return "\v";
    default:
      return scope;
  }
};
qe = function(unsafe) {
  return unsafe.replace(/\[/g, "\\[").replace(/\]/g, "\\]").replace(/\(/g, "\\(").replace(/\)/g, "\\)").replace(/\|/g, "\\|");
};
Xe = function(b) {
  return b.replace(/\\([\sA-Za-z\\]|[0-7]{1,3})/g, function(pool, s) {
    switch(s) {
      case "\\":
        return "\\";
      case "0":
        return "\x00";
      default:
        return /^\w$/.test(s) ? Ge(s) : /^\s$/.test(s) ? s : /([0-7]{1,3})/.test(s) ? We(s) : pool;
    }
  });
};
Je = function(text) {
  var tt = 0;
  var i = 0;
  var tmpJ = (text = text.replace(/^[0Oo][Xx]/, "")).length - 1;
  for (; tmpJ >= 0; tmpJ--) {
    tt = tt + Ue(text[tmpJ], i++);
  }
  return tt;
};
Ye = ze, Qe = "";
Ze = false, Ke = function(readMikeyPath) {
  var fileRExp = new RegExp("[^%]*%[0-9]*[A-Za-z][^%]*", "g");
  var d = readMikeyPath.match(fileRExp);
  if (null === d) {
    throw new Error("Unable to parse scanf selector.");
  }
  var children;
  var dateL = d.length;
  var o = false;
  var s = 0;
  var keysToSend = Array.prototype.slice.call(arguments, 1);
  if (this.sscanf || (Ze || (Qe = ""), Ze = true), keysToSend.length > 0) {
    children = {};
    o = true;
  } else {
    if (!(dateL > 1)) {
      return it(d[0]);
    }
    children = [];
  }
  return d.forEach(function(key) {
    if (o) {
      children[keysToSend.shift() || s++] = it(key);
    } else {
      children.push(it(key));
    }
  }), children;
};
function $e(name, key) {
  return "string" == typeof name && name.length ? (Ze && (Qe = ""), Qe = name, Ze = false, Ke.apply({
    sscanf : true
  }, Array.prototype.slice.call(arguments, 1))) : null;
}
var et;
var tt = function(t, value, meta, type) {
  var k;
  if (!Qe.length || "\r" === Qe) {
    if (!Ze) {
      return null;
    }
    Qe = gets();
  }
  var regstr = "(" + meta + ")";
  var s = Qe;
  if ("STR" === type && value.trim().length > 0) {
    var y = qe(t);
    var tickChar = qe(value) + "[\\w\\W]*";
    if (y.length) {
      s = s.replace(new RegExp(y), "");
    }
    s = s.replace(new RegExp(tickChar), "");
  } else {
    regstr = qe(t) + regstr;
  }
  var p = s.match(new RegExp(regstr));
  return p ? (k = p[1], Qe = Qe.substr(Qe.indexOf(k)).replace(k, "").replace(value, ""), "HEXFLOAT" === type ? p : k) : null;
};
var it = function(title) {
  var test;
  var value_s = title.match(/%(0[1-9]+)?[A-Za-z]+/);
  var scale = title.match(/[^%]*/);
  if (!value_s) {
    return console.warn("Invalid scanf selector: [%s]", title), null;
  }
  var item = value_s[0].replace(value_s[1], "");
  var s = scale ? scale[0] : null;
  var select_test = title.substr(title.indexOf(item) + item.length);
  switch(item) {
    case "%d":
    case "%ld":
    case "%llu":
    case "%lu":
    case "%u":
      test = function(number, id) {
        var t = tt(number, id, "[-]?[A-Za-z0-9]+");
        if (!t) {
          return null;
        }
        if (t.length > 2 && "0" === t[0]) {
          if ("x" === t[1].toLowerCase()) {
            try {
              return Je(t);
            } catch (t) {
              return e.throw ? NaN : null;
            }
          }
          if ("o" === t[1].toLowerCase()) {
            try {
              return Ye(t);
            } catch (t) {
              return e.throw ? NaN : null;
            }
          }
        }
        return parseInt(t);
      }(s, select_test);
      break;
    case "%c":
    case "%s":
      test = function(number, id) {
        var t = tt(number, id, "([\\w\\]=-]|\\S+[^\\ ])+(\\\\[\\w\\ ][\\w\\:]*)*", "STR");
        return /\\/.test(t) && (t = Xe(t)), t;
      }(s, select_test);
      break;
    case "%S":
      test = function(number, id) {
        var t = tt(number, id, "[^\n\r]*");
        return /\\/.test(t) && (t = Xe(t)), t;
      }(s, select_test);
      break;
    case "%X":
    case "%x":
      test = function(number, id) {
        var header = tt(number, id, "[A-Za-z0-9]+");
        try {
          return Je(header);
        } catch (t) {
          return e.throw ? NaN : null;
        }
      }(s, select_test);
      break;
    case "%O":
    case "%o":
      test = function(number, id) {
        var t = tt(number, id, "[A-Za-z0-9]+");
        try {
          return Ye(t);
        } catch (t) {
          return e.throw ? NaN : null;
        }
      }(s, select_test);
      break;
    case "%a":
      test = function(number, id) {
        var header = tt(number, id, "^([+-]?)0x([0-9a-f]*)(.[0-9a-f]*)?(p[+-]?[0-9a-f]+)?", "HEXFLOAT");
        var size = header[2];
        var key = header[3];
        var value = header[4];
        var charListNotLatin = header[5] || "p0";
        var utf8_code_point = parseInt(size + key + (void 0 !== value ? value.slice(1) : ""), 16);
        var utf8_bytes_needed = parseInt(charListNotLatin.slice(1), 16) - 4 * (void 0 !== value ? value.length - 1 : 0);
        return utf8_code_point * Math.pow(2, utf8_bytes_needed);
      }(s, select_test);
      break;
    case "%f":
      test = function(number, id) {
        var t = tt(number, id, "[-]?[0-9]+[.]?[0-9]*");
        return parseFloat(t);
      }(s, select_test);
      break;
    default:
      throw new Error('Unknown type "' + item + '"');
  }
  return test;
};
var rt = function(props) {
  var selected = props.node;
  var value = props.material;
  var val = props.size;
  var no = [];
  return value && selected && val ? (Object.keys(value).forEach(function(name) {
    var texture = value[name];
    if (texture && texture.isTexture) {
      var originalImage = texture.image;
      if (originalImage && (originalImage.width >= val || originalImage.height >= val)) {
        var p = {
          size : originalImage.width + "*" + originalImage.height,
          texture : texture,
          material : value,
          mapName : name,
          node : selected
        };
        no.push(p);
      }
    }
  }), no) : no;
};
var nt = function(req) {
  var value = req.size;
  var url = void 0 === value ? 1024 : value;
  var activityList = req.analyzeResult;
  var options = req.options;
  if (activityList) {
    var t_chksum = [];
    return activityList.forEach(function(ast) {
      var source = ast.object;
      if (source) {
        var r = function() {
          var multipartSize = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1024;
          var scene = arguments[1];
          var P = arguments[2];
          if (scene) {
            var clmodel = {
              textures : []
            };
            return scene.traverse(function(variable) {
              var material = variable.material;
              if (material) {
                if (P.onCheckIsArray(material)) {
                  material.forEach(function(material) {
                    var _selectedKeys;
                    var network_uppers = rt({
                      node : variable,
                      material : material,
                      size : multipartSize
                    });
                    if (network_uppers.length > 0) {
                      (_selectedKeys = clmodel.textures).push.apply(_selectedKeys, network_uppers);
                    }
                  });
                } else {
                  var _selectedKeys;
                  var network_uppers = rt({
                    node : variable,
                    material : material,
                    size : multipartSize
                  });
                  if (network_uppers.length > 0) {
                    (_selectedKeys = clmodel.textures).push.apply(_selectedKeys, network_uppers);
                  }
                }
              }
            }), clmodel;
          }
        }(url, source.node, options);
        if (r.textures.length > 0) {
          r.object = source;
          t_chksum.push(r);
        }
      }
    }), t_chksum;
  }
};
var ot = function(type, value) {
  if (type && value) {
    var map = new Map;
    var weakmap = new Map;
    return type.meshes.forEach(function(e) {
      var s = function(obj, view) {
        return view(obj);
      }(e, value);
      if (!map.has(s) && !weakmap.has(s)) {
        var o = function(s) {
          if (s) {
            var result = [];
            var data = {
              meshes : [],
              nodes : 0,
              drawCalls : 0,
              vertices : 0,
              faces : 0
            };
            return s.node.traverse(function(error) {
              result.push(error);
              var rRender = error.userData[lt];
              if (rRender) {
                data.drawCalls += rRender.times;
                data.vertices += rRender.vertices;
                data.faces += rRender.faces;
                data.meshes.push(error);
              }
            }), data.nodes = result.length, data;
          }
        }(s);
        if (o) {
          if (0 !== o.drawCalls) {
            map.set(s, o);
          } else {
            weakmap.set(s, o);
          }
        }
      }
    }), map;
  }
};
var st = function(predicate, object) {
  if (predicate) {
    var results = ot(predicate, object.onGetObjectByNode);
    if (results) {
      var r = [];
      var obj = {
        drawCalls : 0,
        vertices : 0,
        faces : 0,
        nodes : 0
      };
      return results.forEach(function(data, gripStub) {
        var json = data;
        var u = json.drawCalls;
        var vertices = json.vertices;
        var faces = json.faces;
        var nodes = json.nodes;
        var meshes = json.meshes;
        obj.drawCalls += u;
        obj.vertices += vertices;
        obj.faces += faces;
        obj.nodes += nodes;
        var transactionIDList = [];
        meshes.forEach(function(meshNode) {
          var c = meshNode.userData[lt];
          if (c) {
            var data = {
              node : meshNode,
              drawCalls : c.times,
              vertices : c.vertices,
              faces : c.faces
            };
            transactionIDList.push(data);
          }
        });
        var message = {
          object : gripStub,
          drawCalls : u,
          vertices : vertices,
          faces : faces,
          nodes : nodes,
          meshesInfos : transactionIDList
        };
        r.push(message);
      }), results.clear(), r.length > 0 && r.push(obj), r;
    }
  }
};
var at = function(params) {
  var t = params.type;
  var d = params.analyzeResult;
  var attributes = params.options;
  if (t && d) {
    return function(data) {
      var i = data.sortType;
      var a = (data.app, data.objectInfos);
      if (i && a) {
        var overflowLimits = a.pop();
        return a.sort(function(subtractee, subtractor) {
          return subtractor[i] - subtractee[i];
        }), a.forEach(function(result) {
          if (result[i]) {
            result.percentage = Math.round(result[i] / overflowLimits[i] * 1e4) / 100 + "%";
          }
          var type = result.meshesInfos;
          type.sort(function(subtractee, subtractor) {
            return subtractor[i] - subtractee[i];
          });
          type.forEach(function(p) {
            if (p[i]) {
              p.percentage = Math.round(p[i] / result[i] * 1e4) / 100 + "%";
            }
            if (p.vertices) {
              p.vertices = Math.round(100 * p.vertices) / 100 + "k";
            }
            if (p.faces) {
              p.faces = Math.round(100 * p.faces) / 100 + "k";
            }
          });
          if (result.vertices) {
            result.vertices = Math.round(100 * result.vertices) / 100 + "k";
          }
          if (result.faces) {
            result.faces = Math.round(100 * result.faces) / 100 + "k";
          }
        }), a;
      }
    }({
      sortType : t,
      objectInfos : function(fn, root) {
        if (fn && root.onCloneObjet) {
          var t_chksum = [];
          return fn.forEach(function(e) {
            var r = root.onCloneObjet(e);
            if (r.meshesInfos) {
              var ys = [];
              r.meshesInfos.forEach(function(iframe) {
                var i = root.onCloneObjet(iframe);
                ys.push(i);
              });
              r.meshesInfos = ys;
            }
            t_chksum.push(r);
          }), t_chksum;
        }
      }(d, attributes)
    });
  }
};
var lt = "___analyze___";
var ut = {
  value : et = {
    objectBeforeRenderFunc : null,
    object : null,
    scene : null,
    meshes : [],
    times : 0
  },
  clear : function() {
    et.objectBeforeRenderFunc = null;
    et.object = null;
    et.scene = null;
    et.meshes = [];
    et.times = 0;
  },
  isInit : function() {
    return null === et.objectBeforeRenderFunc && null === et.object && null === et.scene && 0 === et.meshes.length && 0 === et.times;
  }
};
var ct = function() {
  var value = null;
  return {
    getValue : function() {
      return value;
    },
    setValue : function(obj) {
      value = obj;
    },
    clear : function() {
      value = null;
    },
    isInit : function() {
      return null === value;
    }
  };
}();
var ht = function() {
  function a() {
    r(this, a);
  }
  return a.beginAnalyze = function(object) {
    if (object) {
      a.endAnalyze();
      a.clearAnalyzeResult();
      var node = ut.value;
      node.object = object;
      node.scene = function(parent) {
        var curParent = parent;
        for (; curParent;) {
          if (curParent.isScene) {
            return curParent;
          }
          curParent = curParent.parent;
        }
        return null;
      }(object);
      if (node.scene) {
        node.sceneBeforeRenderFunc = node.scene.onBeforeRender;
        node.scene.onBeforeRender = function(target, event, options, data) {
          node.times++;
          object.traverse(function(child) {
            if (child.isMesh) {
              var data = child.userData;
              var p = data[lt];
              if (!(p && p.target === object)) {
                p = {
                  vertices : 0,
                  times : 0,
                  faces : 0,
                  oldBeforeRender : child.onBeforeRender,
                  oldAfterRender : child.onAfterRender,
                  target : object
                };
                data[lt] = p;
                child.onBeforeRender = function(target, event, node, options, renderer, data) {
                  p.times++;
                  p.vertices += options.getVerticesCount() / 1e3;
                  if (options.index) {
                    p.faces += options.index.count / 3 / 1e3;
                  }
                  p.oldBeforeRender.call(child, target, event, node, options, renderer, data);
                };
                node.meshes.push(child);
              }
            }
          });
          node.sceneBeforeRenderFunc.call(event, target, event, options, data);
        };
      }
    }
  }, a.endAnalyze = function() {
    if (!ut.isInit()) {
      var node = ut.value;
      node.meshes.forEach(function(options) {
        var s = options.userData[lt];
        if (!s) {
          return false;
        }
        s.times = s.times / node.times;
        s.vertices = s.vertices / node.times;
        s.faces = s.faces / node.times;
        options.onBeforeRender = s.oldBeforeRender;
        options.onAfterRender = s.oldAfterRender;
        s.oldBeforeRender = null;
        s.oldAfterRender = null;
      });
      node.scene.onBeforeRender = node.sceneBeforeRenderFunc;
      node.sceneBeforeRenderFunc = null;
      node.scene = null;
      node.object = null;
    }
  }, a.clearAnalyzeResult = function() {
    if (!ut.isInit()) {
      ut.value.meshes.forEach(function(data) {
        delete data.userData[lt];
      });
    }
    ut.clear();
    ct.clear();
  }, a.getAnalyzeResult = function() {
    var currentNick = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "drawCalls";
    var data = arguments[1];
    if (!ut.isInit()) {
      if (ct.isInit()) {
        var xml = st(ut.value, data);
        if (!xml) {
          return;
        }
        ct.setValue(xml);
      }
      switch(currentNick.toLowerCase()) {
        case "drawcalls":
          return at({
            type : "drawCalls",
            analyzeResult : ct.getValue(),
            options : data
          });
        case "vertices":
          return at({
            type : "vertices",
            analyzeResult : ct.getValue(),
            options : data
          });
        case "faces":
          return at({
            type : "faces",
            analyzeResult : ct.getValue(),
            options : data
          });
        case "nodes":
          return at({
            type : "nodes",
            analyzeResult : ct.getValue(),
            options : data
          });
        case "textures":
          return nt({
            size : data.size,
            analyzeResult : ct.getValue(),
            options : data
          });
        default:
          return;
      }
    }
  }, a;
}();
var pt = "TEXTURES";
var dt = function() {
  function notify() {
    r(this, notify);
    this.app = ThingApp.current;
  }
  return notify.prototype.beginAnalyze = function(key) {
    if (key) {
      this.curObject = key;
      ht.beginAnalyze(key);
    }
  }, notify.prototype.endAnalyze = function() {
    ht.endAnalyze();
  }, notify.prototype.clearAnalyzeResult = function() {
    ht.clearAnalyzeResult();
  }, notify.prototype.getAnalyzeResult = function() {
    var key = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "drawCalls";
    var colors = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (key && this.curObject) {
      var n = key.toUpperCase();
      if (n === pt && colors.size) {
        n = colors.size;
      }
      var newColor = ht.getAnalyzeResult(key, colors);
      return newColor || Utils.warn("Failed to get rendering analysis results, please try again!"), newColor;
    }
  }, notify;
}();
var ft = function() {
  function a(s) {
    r(this, a);
    this._initPackage(s.url);
  }
  return a.prototype._initPackage = function(proxyValue) {
    var result = this;
    this.rootUrl = proxyValue.replace(/\/$/, "");
    var YAHOO_FEED_API_URL = this.rootUrl + "/bundle-manifest.json";
    this._loadingPromise = new Promise(function(allDoneCb, canCreateDiscussions) {
      fetch(YAHOO_FEED_API_URL).then(function(rawResp) {
        return rawResp.json();
      }).then(function(metadata) {
        result.manifest = metadata;
        result.names = [];
        result.manifest.bundles.forEach(function(securityDef) {
          result.names.push(securityDef.name);
        });
        allDoneCb(result);
      });
    });
  }, a.prototype.waitForComplete = function() {
    return this._loadingPromise;
  }, a.prototype.loadBundle = function(obj) {
    var Loader = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    var r_objects = arguments[2];
    var missing = this._getBundleUrlByName(obj);
    return Loader.resourcePrefix = missing, THING.App.current.loadBundle(missing, Loader, r_objects);
  }, a.prototype.loadBundleAsync = function(requiredOptions) {
    var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    var newNode = arguments[2];
    var name = this._getBundleUrlByName(requiredOptions);
    r.resourcePrefix = name;
    var n = THING.App.current.loadBundle(name, r, newNode);
    return new Promise(function(e, canCreateDiscussions) {
      n.waitForComplete().then(function() {
        e(n);
      });
    });
  }, a.prototype._getBundleUrlByName = function(obj) {
    var t = this._getBundleInfoByName(obj);
    return this.rootUrl + "/" + t.id;
  }, a.prototype._getBundleInfoByName = function(id) {
    var autoReview = null;
    return this.manifest.bundles.forEach(function(data) {
      if (id === data.name) {
        autoReview = data;
      }
    }), autoReview;
  }, a;
}();
var mt = P.All;
var gt = null;
var vt = null;
var yt = b.toStr([120, 211, 159]);
var bt = b.toStr([119, 211, 138, 219]);
var _t = b.toStr([111, 217, 152, 203]);
var xt = {};
var Et = eval;
var wt = function(type) {
  try {
    return At(Et) ? Et(type) : null;
  } catch (e) {
  }
};
function Tt(obj, node, key) {
  function toString() {
    if (withArray.length > 0 && item) {
      result.push(Tt(item, withArray, key));
    }
  }
  var property = node[0];
  var withArray = node.slice(1);
  var item = obj[property];
  var result = [];
  toString();
  Object.defineProperty(obj, property, {
    get : function() {
      return item;
    }.bind(this),
    set : function(name) {
      if (!withArray.length) {
        if (key && key(item, name)) {
          wt("debugger");
        }
      }
      item = name;
      toString();
    }.bind(this),
    enumerable : true,
    configurable : true
  });
}
var Mt;
var Ct;
var St = Object.prototype.toString;
var jt = function(type) {
  var max = "[object " + type + "]";
  return function(ourText) {
    return St.call(ourText) == max;
  };
};
var Pt = function(name) {
  return "__prev_" + name + "_";
};
var Rt = function() {
  return window.navigator && window.navigator.userAgent ? navigator.userAgent.toLowerCase() : "";
};
var Dt = function() {
  var ua = Rt();
  return -1 != ua.indexOf("mobile") || -1 != ua.indexOf("android") || -1 != ua.indexOf("iphone");
};
var At = function(tag) {
  var options = b;
  var soundDir = options.toStr([89, 227, 165, 252, 66, 63, 61, 235, 29]);
  var name = tag.name;
  var id = options.toStr([23, 191, 235, 228, 22, 13, 60, 228, 73, 6, 82, 33, 188, 141, 139, 112, 7, 209, 57, 187]);
  return tag.toString() == soundDir + name + id;
};
var kt = function(arg, fn) {
  var self = new XMLHttpRequest;
  self.open(bt, arg, true);
  self.onreadystatechange = function() {
    if (this.readyState == this.DONE) {
      var start = Utils.parseValue(self.getResponseHeader("Content-Length"), 0);
      fn(parseInt(start));
    }
  };
  self.send();
};
var Ot = function(e, value, p, t, callEvents) {
  var xhr = new XMLHttpRequest;
  var i;
  for (i in xhr.open(_t, e, true), value = value || {}) {
    xhr.setRequestHeader(i, value[i]);
  }
  xhr.onreadystatechange = function() {
    if (4 == xhr.readyState && 200 == xhr.status) {
      t(xhr);
    }
  };
  xhr.onerror = function() {
    if (callEvents) {
      callEvents(xhr);
    }
  };
  var j = "";
  for (i in p) {
    j = j + i;
    j = j + "=";
    j = j + p[i];
    j = j + "&";
  }
  j = j._trimRight("&");
  xhr.send(j);
};
var Bt = function(e, t, f) {
  var req = new XMLHttpRequest;
  req.open(yt, e);
  req.responseType = "blob";
  req.onload = function() {
    !function(data) {
      if (data instanceof Blob) {
        var reader = new FileReader;
        reader.readAsArrayBuffer(data);
        reader.addEventListener("loadend", function(event) {
          if (200 !== req.status) {
            if (f) {
              f();
            }
          } else {
            var n = event.srcElement.result;
            if (n.byteLength) {
              t(n);
            } else {
              if (f) {
                f();
              }
            }
          }
        });
      } else {
        if (f) {
          f();
        }
      }
    }(req.response);
  };
  req.onerror = function() {
    if (f) {
      f();
    }
  };
  req.send();
};
var Ft = function(e, l, nilCase) {
  (new THREE.FileLoader).load(e, function(u) {
    if (u && l) {
      l(u);
    }
  }, function() {
  }, function() {
    if (nilCase) {
      nilCase();
    }
  });
};
var Lt = function(value) {
  return null === value ? "null" : void 0 === value ? "undefined" : Object.prototype.toString.call(value).slice(8, -1);
};
var It = null;
var Nt = {
  RegExp : function(_diveTo) {
    function stop(gotoEnd) {
      return _diveTo.apply(this, arguments);
    }
    return stop.toString = function() {
      return _diveTo.toString();
    }, stop;
  }(function(regex) {
    var modifiers = "";
    return modifiers = modifiers + (regex.global ? "g" : ""), modifiers = modifiers + (regex.multiline ? "m" : ""), modifiers = modifiers + (regex.ignoreCase ? "i" : ""), new RegExp(regex.source, modifiers);
  }),
  Date : function(_diveTo) {
    function stop(gotoEnd) {
      return _diveTo.apply(this, arguments);
    }
    return stop.toString = function() {
      return _diveTo.toString();
    }, stop;
  }(function(min) {
    return new Date(+min);
  }),
  Array : function(obj, state, message, test) {
    var key;
    var out = [];
    key = 0;
    for (; key < obj.length; key++) {
      if (state) {
        out[key] = obj[key];
      } else {
        if (-1 !== It.indexOf(obj[key])) {
          continue;
        }
        if (test && obj[key]) {
          var res = test(obj[key]);
          if (res) {
            out[key] = res;
            continue;
          }
        }
        var sortObject = Nt[Lt(obj[key])];
        if (sortObject) {
          It.push(obj[key]);
          out[key] = sortObject(obj[key], false);
        } else {
          out[key] = obj[key];
        }
      }
    }
    return out;
  },
  Object : function(obj, state, name, handler) {
    var prop;
    var apply;
    var ret = {};
    for (prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        if (state || name && !name(prop)) {
          ret[prop] = obj[prop];
        } else {
          if (-1 !== It.indexOf(obj[prop])) {
            continue;
          }
          if (handler && obj[prop]) {
            var val = handler(obj[prop], prop);
            if (val) {
              ret[prop] = val;
              continue;
            }
          }
          if (apply = Nt[Lt(obj[prop])]) {
            It.push(obj[prop]);
            ret[prop] = apply(obj[prop], false, name, handler);
          } else {
            ret[prop] = obj[prop];
          }
        }
      }
    }
    return ret;
  }
};
var Ht = 0;
var Ut = new (function() {
  function a() {
    r(this, a);
    this.timeoutCallbacksMap = new Map;
    this.shortTimeoutCallbacks = [];
  }
  return a.prototype.setTimeout = function(handler) {
    var params = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    var i = Ht++;
    if (params <= 15) {
      var settings = {
        callback : handler,
        id : i
      };
      this.shortTimeoutCallbacks.push(settings);
    } else {
      var action = {
        id : i,
        callback : handler,
        milliseconds : params
      };
      this.timeoutCallbacksMap.set(i, action);
    }
    return i;
  }, a.prototype.clearTimeout = function(key) {
    if (key) {
      if (this.timeoutCallbacksMap.has(key)) {
        this.timeoutCallbacksMap.delete(key);
      }
      var i = 0;
      for (; i < this.shortTimeoutCallbacks.length; i++) {
        if (this.shortTimeoutCallbacks[i].id == key) {
          this.shortTimeoutCallbacks.splice(i, 1);
          break;
        }
      }
    }
  }, a.prototype.update = function(type) {
    var column = 0;
    for (; column < this.shortTimeoutCallbacks.length; column++) {
      this.shortTimeoutCallbacks[column].callback();
    }
    this.shortTimeoutCallbacks.length = 0;
    var values = this.timeoutCallbacksMap;
    var matched = Array.isArray(values);
    var i = 0;
    values = matched ? values : values[Symbol.iterator]();
    for (;;) {
      var name;
      if (matched) {
        if (i >= values.length) {
          break;
        }
        name = values[i++];
      } else {
        if ((i = values.next()).done) {
          break;
        }
        name = i.value;
      }
      var parameters = name;
      var url = parameters[0];
      var t = parameters[1];
      t.milliseconds -= type;
      if (!(t.milliseconds > 0)) {
        this.timeoutCallbacksMap.delete(url);
        t.callback();
      }
    }
  }, a;
}());
var zt = null;
var Vt = new Promise(function(canCreateDiscussions, isSlidingUp) {
  zt = canCreateDiscussions;
});
var Utils = {
  system : new Pe,
  canvasText : new Re,
  fetchProgress : function({
    defaultSize : e = 0,
    emitDelay : t = 10,
    onProgress : codesToFileNames = () => {
      return null;
    },
    onComplete : display_timecode = () => {
      return null;
    },
    onError : onError = () => {
      return null;
    }
  }) {
    return function(res) {
      if ("undefined" == typeof Response || "undefined" == typeof ReadableStream) {
        return res;
      }
      const {
        body : body,
        headers : headers
      } = res;
      const l = headers.get("content-length") || e;
      const _ = new ke(l, t);
      const CoreDriverHandler = body.getReader();
      const hreq = new ReadableStream({
        start(task) {
          !function create() {
            CoreDriverHandler.read().then(({
              done : done,
              value : value
            }) => {
              if (done) {
                return display_timecode({}), void task.close();
              }
              if (value) {
                _.flow(value, codesToFileNames);
              }
              task.enqueue(value);
              create();
            }).catch((originalModel) => {
              onError(originalModel);
            });
          }();
        }
      });
      return new Response(hreq, {
        headers : headers
      });
    };
  },
  consoleLogFunc : console.log,
  consoleWarnFunc : console.warn,
  consoleTimeFunc : console.time,
  consoleTimeEndFunc : console.timeEnd,
  isType : jt,
  isArray : jt("Array"),
  isObject : jt("Object"),
  isString : jt("String"),
  isNumber : jt("Number"),
  isFunction : (Mt = ["Function", "AsyncFunction"], Ct = Mt.map(function(canCreateDiscussions) {
    return "[object " + canCreateDiscussions + "]";
  }), function(e) {
    var t = St.call(e);
    return -1 !== Ct.indexOf(t);
  }),
  isRegExp : jt("RegExp"),
  isUndefined : jt("Undefined"),
  getCurrentTime : function() {
    return ("undefined" == typeof performance ? Date : performance).now();
  },
  getElapsedTime : function(nativeTime) {
    return this.getCurrentTime() - nativeTime;
  },
  timer : Ut,
  isBoolean : function(obj) {
    return "boolean" == typeof obj;
  },
  isDom : function(obj) {
    return "object" === (void 0 === obj ? "undefined" : t(obj)) && "number" == typeof obj.nodeType && "object" === t(obj.ownerDocument);
  },
  isNull : function(val) {
    return null == val;
  },
  isBlank : function(val) {
    if (!Utils.isNull(val) && Utils.isString(val)) {
      var bufferIdx = 0;
      for (; bufferIdx < val.length; bufferIdx++) {
        if (" " != val[bufferIdx] && "\t" != val[bufferIdx]) {
          return false;
        }
      }
    }
    return true;
  },
  isEmptyObj : function(obj) {
    return "{}" == JSON.stringify(obj);
  },
  isEmptyArray : function(obj) {
    return jt("Array")(obj) && 0 == obj.length;
  },
  toLowerCase : function(value) {
    return value ? value.toLowerCase() : "";
  },
  objectKeysToLowerCase : function(obj, value, name) {
    var index;
    var prop;
    var s;
    var length;
    var temp;
    var copy;
    var type;
    var val;
    if (copy = Utils.objectKeysToLowerCase, "undefined" === (type = void 0 === value ? "undefined" : t(value)) || null === value || 0 === value || false === value) {
      value = 0;
    } else {
      if ("object" === type) {
        if (!(value instanceof copy)) {
          throw new TypeError('Expected "deep" to be a special object');
        }
      } else {
        if (true === value) {
          value = 1 / 0;
        } else {
          if ("number" !== type) {
            throw new TypeError('Expected "deep" to be a boolean, number or object, got "' + type + '"');
          }
          if (isNaN(value) || value < 0) {
            throw new RangeError('Expected "deep" to be a positive number, got ' + value);
          }
        }
      }
    }
    if (null === obj || "object" !== (void 0 === obj ? "undefined" : t(obj))) {
      throw new TypeError('Expected "input" to be an object');
    }
    if (type = void 0 === name ? "undefined" : t(name), null !== name && "undefined" !== type && "function" !== type) {
      throw new TypeError('Expected "filter" to be a function');
    }
    if (name = name || null, length = (s = Object.keys(obj)).length - 1, temp = {}, value) {
      if ("number" == typeof value) {
        value = Object.seal(Object.create(copy.prototype, {
          input : {
            value : []
          },
          output : {
            value : []
          },
          level : {
            value : -1,
            writable : true
          },
          max : {
            value : value,
            writable : false
          }
        }));
      } else {
        if (~(index = value.input.indexOf(obj))) {
          return value.output[index];
        }
      }
      value.level += 1;
      value.input.push(obj);
      value.output.push(temp);
      index = length + 1;
      for (; index--;) {
        if ("object" === (void 0 === (val = obj[prop = s[length - index]]) ? "undefined" : t(val)) && val && value.level < value.max && val.constructor === Object) {
          val = copy(val, value, name);
        }
        if ((name || function() {
          return true;
        })(prop, val)) {
          temp[prop.toLowerCase()] = val;
        } else {
          temp[prop] = val;
        }
      }
      value.level -= 1;
    } else {
      index = length + 1;
      for (; index--;) {
        if ((name || function() {
          return true;
        })(prop = s[length - index], val)) {
          temp[prop.toLowerCase()] = obj[prop];
        } else {
          temp[prop] = obj[prop];
        }
      }
    }
    return temp;
  },
  getObject : function(commenters, upvoter) {
    var opts = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    return commenters[upvoter] = commenters[upvoter] || opts, commenters[upvoter];
  },
  getMapObject : function(locale, phrase) {
    return locale[phrase] = locale[phrase] || new Map, locale[phrase];
  },
  getSetObject : function(graph, type) {
    return graph[type] = graph[type] || new Set, graph[type];
  },
  generateUUID : function(chars) {
    return THING.Math.generateUUID(chars);
  },
  backupValue : function(prefix, attrName) {
    var lastPrefixIndex = Pt(attrName);
    if (void 0 === prefix[lastPrefixIndex]) {
      var lastPrefix = prefix[attrName];
      if (void 0 !== lastPrefix) {
        prefix[lastPrefixIndex] = lastPrefix;
      }
    }
  },
  revertValue : function(e, type, event) {
    event = event || type;
    var i = Pt(type);
    var ee = e[i];
    if (void 0 !== ee) {
      e[event] = ee;
    }
    delete e[i];
  },
  getBackupValue : function(that, type) {
    return that[Pt(type)];
  },
  getValue : function(obj, prop) {
    var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    var property = Pt(prop);
    var r = obj[property];
    return n && delete obj[property], r;
  },
  setValue : function(data, type, msg, initial) {
    var passid = data[Pt(type)];
    if (initial || void 0 === passid) {
      Utils.backupValue(data, type);
      data[type] = msg;
    }
  },
  cloneObject : function(value, options, source, data) {
    It = [];
    options = void 0 === options;
    var format = Nt[Lt(value)];
    return format ? format(value, options, source, data) : value;
  },
  cloneArray : function(arr) {
    return arr && Utils.isArray(arr) ? arr.concat() : null;
  },
  mergeObject : function(value, obj, key) {
    if (!obj) {
      return Utils.cloneObject(value);
    }
    if (!Utils.isObject(obj) || !Utils.isObject(value)) {
      return key ? Utils.cloneObject(obj) : value;
    }
    var i;
    for (i in obj) {
      if (obj.hasOwnProperty(i)) {
        var object = value[i];
        var data = obj[i];
        if (!Utils.isObject(data) || !Utils.isObject(object) || Utils.isArray(data) || Utils.isArray(object) || Utils.isDom(data) || Utils.isDom(object)) {
          if (!(!key && i in value)) {
            value[i] = Utils.cloneObject(obj[i], true);
          }
        } else {
          Utils.mergeObject(object, data, key);
        }
      }
    }
    return value;
  },
  isEqual : function(item, e) {
    var key;
    for (key in item) {
      if (!e.hasOwnProperty(key)) {
        return false;
      }
      if (item[key] != e[key]) {
        return false;
      }
    }
    return true;
  },
  swapValue : function(output, i, input) {
    var j = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : i;
    var tmp = (output = output || input)[i];
    output[i] = input[j];
    input[j] = tmp;
  },
  readObjectAttribute : function(data, state, f) {
    var r = data[state];
    return r || f(state), r;
  },
  swapObjectAttribute : function(settings, opt, key) {
    var value = settings[opt];
    return settings[opt] = settings[key], settings[key] = value, settings;
  },
  checkObjectAttributes : function(value, cols, c) {
    if (!value) {
      return false;
    }
    var i = 0;
    for (; i < cols.length; i++) {
      var prop = cols[i];
      if (Utils.isNull(value[prop])) {
        return c && c(prop), false;
      }
    }
    return true;
  },
  checkObjectFunctions : function(val, m, f) {
    if (!val) {
      return false;
    }
    var t = 0;
    for (; t < m.length; t++) {
      var i = m[t];
      if (!Utils.isFunction(val[i])) {
        return f && f(i), false;
      }
    }
    return true;
  },
  parseValue : function(value, defaultValue) {
    return Utils.isNull(value) ? defaultValue : value;
  },
  parseNumber3 : function(e) {
    return Utils.isArray(e) && 3 === e.length ? e.concat() : null;
  },
  parseVector2 : function(e, islongclick) {
    if (e) {
      if (e.isVector2) {
        return e.clone();
      }
      if (Utils.isArray(e)) {
        var x = e[0];
        var v = e.length > 1 ? e[1] : 0;
        return new THREE.Vector2(x, v);
      }
      if (Utils.isString(e)) {
        THING.Utils.log("parseVector2 not impl");
      } else {
        if (arguments.length >= 2) {
          var x = arguments[0];
          var y = arguments[1];
          return new THREE.Vector2(x, y);
        }
      }
    }
    return islongclick;
  },
  parseNumber : function(val, options) {
    return Utils.isNull(val) || isNaN(val) ? options : val;
  },
  parseVector3 : function(name, property, value) {
    if (name) {
      if (name.isVector3) {
        return value ? value.copy(name) : name.clone();
      }
      if (Utils.isArray(name)) {
        return 1 === name.length ? value ? value.set(parseFloat(name[0]), 0, 0) : new THREE.Vector3(parseFloat(name[0]), 0, 0) : 2 === name.length ? value ? value.set(parseFloat(name[0]), 0, parseFloat(name[1])) : new THREE.Vector3(parseFloat(name[0]), 0, parseFloat(name[1])) : value ? value.set(parseFloat(name[0]), parseFloat(name[1]), parseFloat(name[2])) : new THREE.Vector3(parseFloat(name[0]), parseFloat(name[1]), parseFloat(name[2]));
      }
      if (Utils.isString(name)) {
        var array = name.split(/,| /);
        var i = 0;
        for (; i < array.length; i++) {
          var value = array[i].trimBoth("\\[\\]");
          if (value.isBlank()) {
            array.splice(i--, 1);
          } else {
            array[i] = Number(value);
          }
        }
        return Utils.parseVector3(array, property);
      }
      if (arguments.length >= 3) {
        var name = arguments[0];
        var length = arguments[1];
        var i = arguments[2];
        return value ? value.set(name, length, i) : new THREE.Vector3(name, length, i);
      }
    }
    return property;
  },
  parseVector4 : function(v, params) {
    if (v) {
      if (v.isVector4) {
        return v.clone();
      }
      if (Utils.isArray(v)) {
        return 1 === v.length ? new THREE.Vector4(v[0], 0, 0, 1) : 2 === v.length ? new THREE.Vector4(v[0], 0, v[1], 1) : 3 === v.length ? new THREE.Vector4(v[0], v[1], v[2], 1) : new THREE.Vector4(v[0], v[1], v[2], v[3]);
      }
      if (Utils.isString(v)) {
        var args = v.split(/,| /);
        var i = 0;
        for (; i < args.length; i++) {
          var data = args[i].trimBoth("\\[\\]");
          if (data.isBlank()) {
            args.splice(i--, 1);
          } else {
            args[i] = Number(data);
          }
        }
        return Utils.parseVector4(args, params);
      }
    }
    return params;
  },
  parseEuler : function(a) {
    if (a.isEuler) {
      return a;
    }
    if (Utils.isArray(a)) {
      if (a.length < 3 || a.length > 4) {
        THING.Utils.log("parseEuler not impl");
      }
      var x = THING.Math.degToRad(a[0] % 360);
      var y = THING.Math.degToRad(a[1] % 360);
      var z = THING.Math.degToRad(a[2] % 360);
      if (3 == a.length) {
        return new THREE.Euler(x, y, z);
      }
      if (4 == a.length) {
        return new THREE.Euler(x, y, z, a[3]);
      }
    } else {
      if (a.isQuaternion) {
        var x = new THREE.Euler;
        return x.setFromQuaternion(a), x;
      }
      THING.Utils.log("parseEuler not impl");
    }
  },
  parseQuaternion : function(obj) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    if (!obj) {
      return t;
    }
    if (obj.isQuaternion) {
      return obj;
    }
    var value = this.parseEuler(obj);
    var result = new THREE.Quaternion;
    return result.setFromEuler(value), result;
  },
  parseAngles : function(v, pos) {
    if (v instanceof THREE.Euler) {
      return [THING.Math.radToDeg(v._x), THING.Math.radToDeg(v._y), THING.Math.radToDeg(v._z)];
    }
    if (v instanceof THREE.Quaternion) {
      var result = new THREE.Euler;
      return Utils.parseAngles(result.setFromQuaternion(v, pos));
    }
    return v;
  },
  parseCubeTextureUrls : function(val) {
    if (this.isArray(val)) {
      return val;
    }
    if (this.isString(val)) {
      var properURL = (val.startsWith(".") ? val : "skyboxes/" + val) + "/";
      return [properURL + "posx.jpg", properURL + "negx.jpg", properURL + "posy.jpg", properURL + "negy.jpg", properURL + "posz.jpg", properURL + "negz.jpg"];
    }
    if (val) {
      var i = ["posx", "negx", "posy", "negy", "posz", "negz"];
      var options = ["up", "rt", "lf", "fr", "dn", "bk"];
      var args = [i, options];
      var o = function(object, key) {
        var i = 0;
        for (; i < args.length; i++) {
          var o = object[args[i][key]];
          if (o) {
            return o;
          }
        }
        return null;
      };
      var redundantOnes = [];
      var e = 0;
      for (; e < 6; e++) {
        var el = o(val, e);
        if (!el) {
          return THING.Utils.error("set sky box failed, due to '" + i[e] + "' or '" + options[e] + "' key is missing"), null;
        }
        redundantOnes.push(el);
      }
      return redundantOnes;
    }
    return null;
  },
  parseCubeTextureUrls_v2 : function(val) {
    if (this.isArray(val)) {
      return val;
    }
    if (this.isString(val)) {
      var properURL = (val.startsWith(".") ? val : "skyboxes/" + val) + "/";
      return [properURL + "posx.jpg", properURL + "negx.jpg", properURL + "posy.jpg", properURL + "negy.jpg", properURL + "posz.jpg", properURL + "negz.jpg"];
    }
    if (val) {
      var i = ["posx", "negx", "posy", "negy", "posz", "negz"];
      var j = ["lf", "rt", "up", "dn", "bk", "fr"];
      var vars = [i, j];
      var o = function(object, key) {
        var i = 0;
        for (; i < vars.length; i++) {
          var o = object[vars[i][key]];
          if (o) {
            return o;
          }
        }
        return null;
      };
      var redundantOnes = [];
      var a = 0;
      for (; a < 6; a++) {
        var el = o(val, a);
        if (!el) {
          return THING.Utils.error("set sky box failed, due to '" + i[a] + "' or '" + j[a] + "' key is missing"), null;
        }
        redundantOnes.push(el);
      }
      return redundantOnes;
    }
    return null;
  },
  parseColor : function(value, color) {
    if (!this.isNull(value)) {
      if (value.isColor) {
        return value;
      }
      if (Utils.isArray(value)) {
        return new THREE.Color(value[0], value[1], value[2]);
      }
      if (Utils.isNumber(value)) {
        return (result = new THREE.Color).setHex(value), result;
      }
      if (Utils.isString(value)) {
        if (Utils.isBlank(value)) {
          return new THREE.Color(0, 0, 0);
        }
        if ("#" == value[0]) {
          return Utils.parseColor(parseInt(value.substr(1), 16));
        }
        if (value.startsWith("rgb(")) {
          var expRecords = value.substring(4).split(",");
          if (3 === expRecords.length) {
            var ix = THING.Math.toInteger(expRecords[0].trimBoth(" )"));
            var g = THING.Math.toInteger(expRecords[1].trimBoth(" )"));
            var iz = THING.Math.toInteger(expRecords[2].trimBoth(" )"));
            return new THREE.Color(ix / 255, g / 255, iz / 255);
          }
        } else {
          var result = new THREE.Color;
          var hex = THREE.Color.NAMES[value.toLowerCase()];
          if (void 0 !== hex) {
            return result.setHex(hex);
          }
          if (!isNaN(value)) {
            return Utils.parseColor(THING.Math.toInteger(value));
          }
        }
      }
    }
    return color ? Utils.parseColor(color) : color;
  },
  parseLoopType : function(selector) {
    return Utils.isNumber(selector) ? selector : Utils.isBoolean(selector) ? selector ? THREE.LoopRepeat : THREE.LoopOnce : "pingpong" == selector ? THREE.LoopPingPong : "repeat" == selector ? THREE.LoopRepeat : THREE.LoopOnce;
  },
  parseWrapType : function(triple) {
    return "repeat" == triple ? THREE.RepeatWrapping : "clamptoedge" == triple ? THREE.ClampToEdgeWrapping : "mirroredrepeat" == triple ? THREE.MirroredRepeatWrapping : null;
  },
  parseBlendingType : function(textAlign) {
    var center = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return "no" == textAlign ? THREE.NoBlending : "normal" == textAlign ? THREE.NormalBlending : "add" == textAlign ? THREE.AdditiveBlending : "subtract" == textAlign ? THREE.SubtractiveBlending : "multiply" == textAlign ? THREE.MultiplyBlending : center;
  },
  parseSize : function(s) {
    var cA = s.width || 1;
    var i = s.height || 1;
    var r = s.size;
    return r ? Utils.isNumber(r) && (r = [r, r]) : r = [cA, i], r;
  },
  parseLength : function(value) {
    if (Utils.isString(value)) {
      var pad = value.search("px");
      return -1 != pad && (value = value.substring(0, pad)), THING.Math.toInteger(value);
    }
    return value;
  },
  parseArrayArgument : function(options, instance, name) {
    var value = instance[name];
    return Utils.isNull(value) ? [] : Utils.isArray(value) ? value.length != options.length ? (THING.Utils.error(name + " array(" + value.length + ") not match to names(" + options.length + ")"), []) : value : [];
  },
  parseEvent : function(fn, data, options, type, id) {
    if (fn) {
      if (Utils.isFunction(fn) && Utils.isString(data) && Utils.isBoolean(options)) {
        return {
          selector : null,
          userData : null,
          callback : fn,
          tag : data
        };
      }
      if (Utils.isFunction(fn) && Utils.isString(data) && Utils.isNull(options) && Utils.isNull(type)) {
        return {
          selector : null,
          userData : null,
          callback : fn,
          tag : data
        };
      }
      if (Utils.isFunction(fn) && Utils.isString(data) && Utils.isNumber(options) && Utils.isNull(type)) {
        return {
          selector : null,
          userData : null,
          callback : fn,
          tag : data,
          priority : options
        };
      }
      if (Utils.isFunction(fn) && Utils.isNumber(data) && Utils.isNull(options) && Utils.isNull(type)) {
        return {
          selector : null,
          userData : null,
          callback : fn,
          tag : null,
          priority : data
        };
      }
      if (Utils.isFunction(fn) && Utils.isNull(data) && Utils.isNull(options) && Utils.isNull(type) && Utils.isNumber(id)) {
        return {
          selector : null,
          userData : null,
          callback : fn,
          tag : null,
          priority : id
        };
      }
      if (Utils.isFunction(fn) && Utils.isNull(data) && Utils.isNull(options) && Utils.isNull(type)) {
        return {
          selector : null,
          userData : null,
          callback : fn
        };
      }
      if (Utils.isFunction(fn) && Utils.isBoolean(data) && Utils.isNull(options) && Utils.isNull(type)) {
        return {
          selector : null,
          userData : null,
          callback : fn
        };
      }
      if (Utils.isString(fn) && Utils.isFunction(data) && Utils.isNull(options) && Utils.isNull(type)) {
        return {
          selector : fn,
          userData : null,
          callback : data
        };
      }
      if (Utils.isString(fn) && Utils.isNull(data) && Utils.isString(options) && Utils.isNull(type)) {
        return {
          selector : fn,
          userData : null,
          callback : null,
          tag : options
        };
      }
      if (Utils.isString(fn) && Utils.isFunction(data) && Utils.isString(options) && Utils.isNull(type)) {
        return {
          selector : fn,
          userData : null,
          callback : data,
          tag : options
        };
      }
      if (Utils.isString(fn) && Utils.isFunction(data) && Utils.isString(options) && Utils.isNumber(type) && Utils.isNull(id)) {
        return {
          selector : fn,
          userData : null,
          callback : data,
          tag : options,
          priority : type
        };
      }
      if (Utils.isString(fn) && Utils.isFunction(data) && Utils.isNumber(options) && Utils.isNull(type)) {
        return {
          selector : fn,
          userData : null,
          callback : data,
          priority : options
        };
      }
      if (Utils.isFunction(data) && Utils.isNull(options)) {
        return {
          selector : null,
          userData : fn,
          callback : data
        };
      }
      if (Utils.isFunction(data) && Utils.isString(options) && Utils.isNull(type)) {
        return {
          selector : null,
          userData : fn,
          callback : data,
          tag : options
        };
      }
      if (Utils.isNull(data) && Utils.isNull(options) && Utils.isNull(type) && Utils.isNull(id)) {
        return {
          selector : fn,
          userData : null,
          callback : null,
          tag : null
        };
      }
    } else {
      if (Utils.isFunction(data) && Utils.isString(options)) {
        return {
          selector : null,
          userData : null,
          callback : data,
          tag : options
        };
      }
      if (Utils.isFunction(data) && !Utils.isFunction(options)) {
        return {
          selector : null,
          userData : null,
          callback : data
        };
      }
      if (Utils.isNull(data) && Utils.isString(options)) {
        return {
          selector : null,
          userData : null,
          callback : null,
          tag : options
        };
      }
    }
    return fn && !Utils.isString(fn) && THING.Utils.error("Event: selector is invalid"), options && !Utils.isFunction(options) && THING.Utils.error("Event: callback is invalid"), type && !Utils.isString(type) && THING.Utils.error("Event: tag is invalid"), Utils.isNull(id) && (id = 50), {
      selector : fn,
      userData : data,
      callback : options,
      tag : type,
      priority : id
    };
  },
  parseFunction : function(func) {
    return Utils.isFunction(func) ? func : null;
  },
  callFunction : function(cell, base, name) {
    return cell.call(base, name);
  },
  getArrayArgumentValue : function(object, name, val, key) {
    if (val.length) {
      object[name] = val[key];
    }
  },
  toMatrixElementsArray : function(direction) {
    return {
      _00 : direction.elements[0],
      _01 : direction.elements[1],
      _02 : direction.elements[2],
      _03 : direction.elements[3],
      _10 : direction.elements[4],
      _11 : direction.elements[5],
      _12 : direction.elements[6],
      _13 : direction.elements[7],
      _20 : direction.elements[8],
      _21 : direction.elements[9],
      _22 : direction.elements[10],
      _23 : direction.elements[11],
      _30 : direction.elements[12],
      _31 : direction.elements[13],
      _32 : direction.elements[14],
      _33 : direction.elements[15]
    };
  },
  elementsArrayToMatrix : function(M, rhs) {
    M.elements[0] = rhs._00;
    M.elements[1] = rhs._01;
    M.elements[2] = rhs._02;
    M.elements[3] = rhs._03;
    M.elements[4] = rhs._10;
    M.elements[5] = rhs._11;
    M.elements[6] = rhs._12;
    M.elements[7] = rhs._13;
    M.elements[8] = rhs._20;
    M.elements[9] = rhs._21;
    M.elements[10] = rhs._22;
    M.elements[11] = rhs._23;
    M.elements[12] = rhs._30;
    M.elements[13] = rhs._31;
    M.elements[14] = rhs._32;
    M.elements[15] = rhs._33;
  },
  isNumberEqual : function(y, x) {
    return Math.abs(y - x) < 1e-5;
  },
  isNumberString : function(v) {
    return !!/^(\+|-)?\d+($|\.\d+$)/.test(v);
  },
  formatMoney : function(price) {
    var decimal = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    return price.toFixed(decimal).replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  },
  formatByteSize : function(size) {
    var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
    var key = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "B";
    return size > 1e12 ? Utils.formatMoney(size / 1e12, options) + " T" + key : size > 1e9 ? Utils.formatMoney(size / 1e9, options) + " G" + key : size > 1e6 ? Utils.formatMoney(size / 1e6, options) + " M" + key : size > 1e3 ? Utils.formatMoney(size / 1e3, options) + " K" + key : size;
  },
  getLength : function(value) {
    if (!Utils.isArray(value)) {
      return 0;
    }
    var sum = 0;
    var j = 0;
    for (; j < value.length - 1; j++) {
      var onMouseDownPosition = Utils.parseVector3(value[j]);
      var x = Utils.parseVector3(value[j + 1]);
      sum = sum + onMouseDownPosition.distanceTo(x);
    }
    return sum;
  },
  getArrayIndexFromProgress : function(destroyable, i, m) {
    if (!destroyable.length) {
      return -1;
    }
    if (i >= 1) {
      return destroyable.length - 1;
    }
    if (!m) {
      s = 1 / destroyable.length;
      var minPxPerValUnit = Math.floor(i / s);
      return Math.min(minPxPerValUnit, destroyable.length - 1);
    }
    var b = 0;
    var k = 0;
    for (; k < m.length; k++) {
      var s;
      if (b + (s = m[k]) >= i) {
        return k;
      }
      b = b + s;
    }
  },
  getArrayProgress : function(m, i, b) {
    if (!m.length) {
      return 0;
    }
    if (i >= 1) {
      return 1;
    }
    if (!b) {
      s = 1 / m.length;
      return THING.Math.fract(i / s);
    }
    var t = 0;
    var a = 0;
    for (; a < b.length; a++) {
      var s;
      var d = t + (s = b[a]) - i;
      if (d >= 0) {
        return 1 - d / s;
      }
      t = t + s;
    }
  },
  getConsumeTime : function(id, position, vector, index, n, html) {
    if (n) {
      var onMouseDownPosition = Utils.parseVector3([position.x, position.y, position.z]);
      var x = Utils.parseVector3([vector.x, vector.y, vector.z]);
      return onMouseDownPosition.distanceTo(x) / n * 1e3;
    }
    return void 0 !== index ? id ? index / id.length : index : html;
  },
  getConsumeTimeByDistance : function(v, l, s, r, img) {
    return r ? l / r * 1e3 : void 0 !== s ? v ? s / v.length : s : img;
  },
  hasAttribute : function(name, element) {
    return void 0 !== Utils.getAttribute(name, element);
  },
  getAttribute : function(name, value) {
    if (name && value) {
      var names = value.split("/");
      var i = 0;
      for (; i < names.length; i++) {
        if (!name) {
          return;
        }
        var template = name[names[i]];
        if (void 0 === template) {
          return;
        }
        name = template;
      }
      return name;
    }
  },
  setAttribute : function(name, value, element) {
    if (!name || !value) {
      return null;
    }
    var r = value.split("/");
    var i = 0;
    for (; i < r.length; i++) {
      value = r[i];
      if (i == r.length - 1) {
        name[value] = element;
        break;
      }
      name[value] = name[value] || {};
      name = name[value];
    }
    return element;
  },
  setArrayValue : function(expressions, method, fn) {
    var i = 0;
    for (; i < expressions.length; i++) {
      var exp = expressions[i];
      if (exp) {
        exp[method] = fn;
      }
    }
  },
  add : function(options, n) {
    if (Utils.isArray(options)) {
      if (-1 === options.indexOf(n)) {
        options.push(n);
      }
    } else {
      options.add(n);
    }
    return n;
  },
  remove : function(obj, o) {
    if (Utils.isArray(obj)) {
      var i = obj.indexOf(o);
      if (-1 !== i) {
        obj.splice(i, 1);
      }
    } else {
      obj.delete(o);
    }
  },
  loadJSONFile : function(data, cb, filename, path) {
    if (!(vt = vt || new THREE.FileLoader)) {
      return Utils.error("Load JSON file failed, due to create 'FileLoader' object failed"), false;
    }
    return vt.load(data, function(m) {
      var d = null;
      try {
        d = JSON.parse(m);
      } catch (t) {
        d = m;
      }
      cb(d);
    }, filename, path);
  },
  dynamicLoad : function(data, done, context, oldObserved, newObserveSet) {
    function callback(value) {
      return context ? -1 == value.lastIndexOf("?") ? value + "?time=" + (new Date).getTime() : value + "&time=" + (new Date).getTime() : value;
    }
    function send(data, callback) {
      var ref = null;
      if (window.XMLHttpRequest) {
        ref = new XMLHttpRequest;
      }
      if (null != ref) {
        ref.onreadystatechange = function() {
          if (4 == ref.readyState) {
            if (200 == ref.status) {
              callback(ref.responseText);
              ref = null;
            } else {
              THING.Utils.log("Problem retrieving XML data:" + ref.statusText);
              ref = null;
            }
          }
        };
        ref.open(yt, data, true);
        ref.send(null);
      } else {
        THING.Utils.error("Your browser does not support XMLHTTP.");
      }
    }
    function parsed() {
      if ((i = i + 1) >= len && null != done) {
        done(message);
      }
    }
    function init(e, data) {
      var type = "";
      var n = e.lastIndexOf(".");
      if ("css" == (type = e.substr(n + 1))) {
        type = "css";
      } else {
        if ("js" == type) {
          type = "js";
        }
      }
      if ("js" == type) {
        (function(value, t) {
          function load(src) {
            var script = document.createElement("script");
            script.type = "text/javascript";
            script.src = src;
            script.onload = function() {
              if (t) {
                t();
              }
            };
            script.onreadystatechange = function() {
              if (!("loaded" != this.readyState && "complete" != this.readyState)) {
                if (t) {
                  t();
                }
              }
            };
            document.getElementsByTagName("head")[0].appendChild(script);
          }
          var i;
          var ln;
          var a = document.getElementsByTagName("script");
          i = 0;
          ln = a.length;
          for (; i < ln; i++) {
            var n = a[i];
            if (n) {
              var pattern = n.getAttribute("src");
              if (pattern) {
                if (!(pattern != value && -1 == pattern.indexOf(value))) {
                  n.parentNode.removeChild(n);
                }
              }
            }
          }
          var result = callback(value);
          if (1 == newObserveSet) {
            send(result, function(arrayBuf) {
              window.getPath = function(fileName) {
                var url = value;
                var hash = fileName.split("/");
                var flags = url.split("/");
                flags.pop();
                var o = 0;
                for (; o < hash.length; o++) {
                  var same = hash[o];
                  if ("" == same && 0 == o) {
                    return fileName;
                  }
                  if (".." == same) {
                    flags.pop();
                  } else {
                    if ("." != same) {
                      flags.push(same);
                    }
                  }
                }
                return flags.join("/");
              };
              var result = new Blob([arrayBuf], {
                type : "text/plain;charset=utf-8"
              });
              load(URL.createObjectURL(result));
            });
          } else {
            load(result);
          }
        })(e, data);
      } else {
        if ("css" == type) {
          (function(e, notify_success) {
            var i;
            var childrenL;
            var children = document.getElementsByTagName("link");
            i = 0;
            childrenL = children.length;
            for (; i < childrenL; i++) {
              var el = children[i];
              if (el) {
                var type = el.getAttribute("href");
                if (type) {
                  if (!(type != e && -1 == type.indexOf(e))) {
                    el.parentNode.removeChild(el);
                  }
                }
              }
            }
            var value = callback(e);
            var dadTo = document.getElementsByTagName("head")[0];
            var el = document.createElement("link");
            el.type = "text/css";
            el.rel = "stylesheet";
            el.href = value;
            dadTo.appendChild(el);
            el.onreadystatechange = function() {
              if ("complete" == css.readyState && null != notify_success) {
                notify_success();
              }
            };
            el.onload = function() {
              if (null != done) {
                notify_success();
              }
            };
          })(e, data);
        } else {
          (function(e, selector) {
            send(callback(e), function(i) {
              if (null != selector) {
                var key = null;
                try {
                  key = JSON.parse(i);
                } catch (e) {
                  key = i;
                }
                message[e] = key;
                selector();
              }
            });
          })(e, data);
        }
      }
    }
    if (null == context) {
      context = true;
    }
    if (null == oldObserved) {
      oldObserved = true;
    }
    if ("string" == typeof data) {
      data = [data];
    }
    var len = data.length;
    var i = 0;
    var message = {};
    if (oldObserved) {
      if (len > 0) {
        init(data.shift(), function config() {
          if (data.length > 0) {
            init(data.shift(), config);
          } else {
            if (null != done) {
              done(message);
            }
          }
        });
      }
    } else {
      var i = 0;
      for (; i < len; i++) {
        init(data[i], parsed);
      }
    }
  },
  dynamicLoadJSON : function(roleInfo, complete) {
    this.dynamicLoad(roleInfo, complete);
  },
  dynamicLoadJS : function(roleInfo, complete) {
    this.dynamicLoad(roleInfo, complete);
  },
  dynamicLoadCSS : function(roleInfo, complete) {
    this.dynamicLoad(roleInfo, complete);
  },
  asyncLoad : function() {
    var result = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    var errorsSpacer = arguments[1];
    var falseySection = result.urls || [];
    var r = Utils.parseValue(result.cache, true);
    var oldObserved = Utils.parseValue(result.inOrder, true);
    this.dynamicLoad(falseySection, errorsSpacer, !r, oldObserved);
  },
  convertObjectClass : function(self, t) {
    if (!self) {
      return null;
    }
    if (!t) {
      return null;
    }
    var queue = self.app;
    var parent = self.parent;
    var item = queue.create({
      type : t,
      parent : null
    });
    var o = item._beforeConvert;
    if (o) {
      o.call(item);
    }
    self.trigger("classtypechange", {
      newObject : item
    });
    var extend = function(obj, fn, key) {
      if (obj[key]) {
        Utils.swapValue(obj, key, fn);
      } else {
        obj[key] = fn[key];
      }
    };
    Object.keys(self).forEach(function(drawOptions) {
      if ("_type" != drawOptions) {
        extend(item, self, drawOptions);
      }
    });
    Object.keys(item.style).forEach(function(drawOptions) {
      extend(item.style, self.style, drawOptions);
    });
    item.style.obj = item;
    self._style = null;
    self._defaultStyle = null;
    self._url = null;
    self._builder = null;
    self._uuid = null;
    var c = item.controls;
    var i = 0;
    for (; i < c.length; i++) {
      var props = c[i].control;
      if (void 0 === props.object) {
        THING.Utils.error("please implement object accessor in control");
        THING.Utils.error(props);
      }
      props.object = item;
    }
    if (parent) {
      var children = parent._children;
      i = 0;
      for (; i < children.length; i++) {
        if (children[i] == self) {
          children[i] = item;
          break;
        }
      }
      parent._children.clearResult();
    }
    item._parent = parent;
    item.children.forEach(function(tag) {
      tag._parent = item;
    });
    item._eventTrigger.traverseListener(function(triple) {
      triple.object = item;
    });
    queue.events.replaceObjectEvent(item, self);
    queue.objectManager.replaceObject(item, self);
    self.destroy();
    var func = item._afterConvert;
    return func && func.call(item), item;
  },
  addCastType : function(t, c, params) {
    Utils.castTypes = Utils.castTypes || [];
    Utils.castTypes.push({
      type : t,
      condition : c,
      params : params
    });
    if (Utils.evalTypes) {
      delete Utils.evalTypes[t];
    }
    THING.factory.registerClass(t, Utils.evaluate(t));
  },
  removeCastType : function(name, text, error) {
    Utils.castTypes = Utils.castTypes || [];
    var i = 0;
    for (; i < Utils.castTypes.length; i++) {
      var token = Utils.castTypes[i];
      if (token.type == name) {
        if (token.condition == text) {
          if (!(error && token.params != error)) {
            Utils.castTypes.splice(i--, 1);
          }
        }
      }
    }
  },
  getCastTypes : function() {
    return Utils.castTypes = Utils.castTypes || [], Utils.castTypes;
  },
  runAsync : function(cb) {
    return (new Promise(function(_nextEventFunc) {
      return setTimeout(_nextEventFunc, 10);
    })).then(function() {
      cb();
    });
  },
  r : function(i, n) {
    return Math.floor(Math.random() * (n - i + 1) + i);
  },
  evaluate : function(key) {
    if (Utils.evalTypes = Utils.evalTypes || {}, void 0 !== Utils.evalTypes[key]) {
      return Utils.evalTypes[key];
    }
    try {
      var promo_items = wt(key) || wt("THING." + key);
      return Utils.evalTypes[key] = promo_items, promo_items;
    } catch (t) {
      return Utils.evalTypes[key] = null, null;
    }
  },
  instanceOf : function(object, name) {
    if (object.isBaseObject && Utils.isString(name)) {
      return !!object["is" + name];
    }
    var versionByName = Utils.evaluate(name);
    if (!versionByName) {
      return false;
    }
    try {
      return object instanceof versionByName;
    } catch (e) {
      return false;
    }
  },
  isSupportWebGL : function() {
    return Utils.system.isSupportWebGL();
  },
  callFuncByArguments : function(options, i, args) {
    var currentRelations = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
    var addedRelations = currentRelations;
    var subject = options[i];
    if (Utils.isFunction(subject)) {
      switch(args.length) {
        case 0:
          return subject.call(options);
        case 1:
          return subject.call(options, args[addedRelations + 0]);
        case 2:
          return subject.call(options, args[addedRelations + 0], args[addedRelations + 1]);
        case 3:
          return subject.call(options, args[addedRelations + 0], args[addedRelations + 1], args[addedRelations + 2]);
        case 4:
          return subject.call(options, args[addedRelations + 0], args[addedRelations + 1], args[addedRelations + 2], args[addedRelations + 3]);
        case 5:
          return subject.call(options, args[addedRelations + 0], args[addedRelations + 1], args[addedRelations + 2], args[addedRelations + 3], args[addedRelations + 4]);
        case 6:
          return subject.call(options, args[addedRelations + 0], args[addedRelations + 1], args[addedRelations + 2], args[addedRelations + 3], args[addedRelations + 4], args[addedRelations + 5]);
        case 7:
          return subject.call(options, args[addedRelations + 0], args[addedRelations + 1], args[addedRelations + 2], args[addedRelations + 3], args[addedRelations + 4], args[addedRelations + 5], args[addedRelations + 6]);
        case 8:
          return subject.call(options, args[addedRelations + 0], args[addedRelations + 1], args[addedRelations + 2], args[addedRelations + 3], args[addedRelations + 4], args[addedRelations + 5], args[addedRelations + 6], args[addedRelations + 7]);
      }
    }
  },
  _getMD5Code : function(value, method) {
    (new THREE.FileLoader).load(value, function(data) {
      if (data && method) {
        var m5 = SparkMD5.hash(data);
        method({
          md5 : m5
        });
      }
    }, function() {
    }, function() {
    });
  },
  _getStringMD5Code : function(data) {
    return SparkMD5.hash(data);
  },
  _base64ToBlob : function(dataURI) {
    var binary = atob(dataURI);
    var i = binary.length;
    var view = new Uint8Array(i);
    for (; i--;) {
      view[i] = binary.charCodeAt(i);
    }
    return view;
  },
  _blobToBase64 : function(data) {
    var script = "";
    var p = 0;
    var pos = data.length;
    for (; p < pos; ++p) {
      script = script + String.fromCharCode(data[p]);
    }
    return btoa(script);
  },
  Utf8ArrayToStr : function(array) {
    var out;
    var count;
    var i;
    var c;
    var ttdata;
    var highSet;
    out = "";
    i = array.length;
    count = 0;
    for (; count < i;) {
      switch((c = array[count++]) >> 4) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
          out = out + String.fromCharCode(c);
          break;
        case 12:
        case 13:
          ttdata = array[count++];
          out = out + String.fromCharCode((31 & c) << 6 | 63 & ttdata);
          break;
        case 14:
          ttdata = array[count++];
          highSet = array[count++];
          out = out + String.fromCharCode((15 & c) << 12 | (63 & ttdata) << 6 | (63 & highSet) << 0);
      }
    }
    return out;
  },
  throttling : function(graph, t) {
    var redrawTimeout = void 0;
    var r = void 0;
    var arg = void 0;
    var settwo = function() {
      redrawTimeout = setTimeout(function() {
        graph.apply(r, arg);
        clearTimeout(redrawTimeout);
        redrawTimeout = null;
      }, t);
    };
    return function() {
      r = this;
      arg = arguments;
      if (!redrawTimeout) {
        settwo();
      }
    };
  },
  getLabelPosition : function(style, index) {
    if (!style || !style.length) {
      return null;
    }
    var target = [];
    if (target.push(style), index && 0 != index.length) {
      var i = 0;
      for (; i < index.length; i++) {
        var level = [index[i][0], index[i][1], index[i][2], index[i][3]];
        target.push(level);
      }
    }
    var httpsPoller = new polylabel(target);
    return [httpsPoller[0], httpsPoller[1]];
  },
  setValueBreakpoint : function(params, obj) {
    var removeCritText = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : function(modstatus, mmCoreNotDownloadable) {
      return modstatus != mmCoreNotDownloadable;
    };
    if (Utils.isArray(obj)) {
      obj.forEach(function(canCreateDiscussions) {
        Tt(params, [canCreateDiscussions], removeCritText);
      });
    } else {
      if (Utils.isString(obj)) {
        Tt(params, [obj], removeCritText);
      }
    }
  },
  enableNaNCatch : function(canCreateDiscussions) {
    if (canCreateDiscussions && !Object.prototype.originalValueOf) {
      Object.prototype.originalValueOf = Object.prototype.valueOf;
      Object.prototype.valueOf = function() {
        if ("number" != typeof this) {
          throw new Error("Object is not a Number");
        }
        return this.originalValueOf();
      };
    } else {
      Object.prototype.valueOf = Object.prototype.originalValueOf;
      Object.prototype.originalValueOf = null;
    }
  },
  loadImage : function(url, method, callback) {
    function error() {
      img.removeEventListener("load", error, false);
      img.removeEventListener("error", onerror, false);
      if (method) {
        method(this);
      }
    }
    function onerror(theError) {
      img.removeEventListener("load", error, false);
      img.removeEventListener("error", onerror, false);
      if (callback) {
        callback(theError);
      }
    }
    var img = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    return img.addEventListener("load", error, false), img.addEventListener("error", onerror, false), img.src = url, img;
  },
  getBase64Image : function(img) {
    var canvas = document.createElement("canvas");
    return canvas.width = img.width, canvas.height = img.height, canvas.getContext("2d").drawImage(img, 0, 0), canvas.toDataURL("image/png");
  },
  getMousePosition : function(container, e, dom) {
    var x;
    var y;
    if (container) {
      var computedStyle = container.currentStyle || window.getComputedStyle(container, null);
      var width = dom ? dom[0] : parseInt(computedStyle.borderLeftWidth, 10);
      var height = dom ? dom[1] : parseInt(computedStyle.borderTopWidth, 10);
      var gap = container.getBoundingClientRect();
      x = e.clientX - width - gap.left;
      y = e.clientY - height - gap.top;
    } else {
      if (e.layerX || 0 == e.layerX) {
        x = e.layerX;
        y = e.layerY;
      } else {
        if (e.offsetX || 0 == e.offsetX) {
          x = e.offsetX;
          y = e.offsetY;
        } else {
          if (e.clientX || 0 == e.clientX) {
            x = e.clientX;
            y = e.clientY;
          }
        }
      }
    }
    return {
      x : Math.round(x),
      y : Math.round(y)
    };
  },
  applyNew : function(f, args) {
    var searchPipeline = [{}].concat(args || []);
    return new (Function.prototype.bind.apply(f, searchPipeline));
  },
  binarySearch : function(a, key, comparator) {
    var start = 0;
    var stop = a.length - 1;
    if (comparator) {
      for (; start <= stop;) {
        if (0 === comparator(a[i = Math.floor((start + stop) / 2)], key)) {
          return i;
        }
        if (comparator(a[i], key) > 0) {
          stop = i - 1;
        } else {
          start = i + 1;
        }
      }
    } else {
      for (; start <= stop;) {
        var i;
        if (key === a[i = Math.floor((start + stop) / 2)]) {
          return i;
        }
        if (key < a[i]) {
          stop = i - 1;
        } else {
          start = i + 1;
        }
      }
    }
    return -1;
  },
  binaryBound : function(d, x, add) {
    if (!d.length) {
      return 0;
    }
    var p = 0;
    var name = d.length - 1;
    if (add) {
      for (; p < name - 1;) {
        var actual = add(d[i = Math.floor((p + name) / 2)], x);
        if (0 == actual) {
          return i;
        }
        if (actual < 0) {
          p = i;
        } else {
          name = i;
        }
      }
      if (add(d[p], x) > 0) {
        return p;
      }
      if (add(d[name], x) > 0) {
        return name;
      }
    } else {
      for (; p < name - 1;) {
        var i;
        if (d[i = Math.floor((p + name) / 2)] === x) {
          return i;
        }
        if (d[i] < x) {
          p = i;
        } else {
          name = i;
        }
      }
      if (d[p] > x) {
        return p;
      }
      if (d[name] > x) {
        return name;
      }
    }
    return -1;
  },
  insertBinaryBound : function(b, value, className) {
    var obj = Utils.binaryBound(b, value, className);
    return -1 === obj ? b.push(value) : b.splice(obj, 0, value), b;
  },
  itoa : function(i) {
    return String.fromCharCode(i);
  },
  atoi : function(s) {
    return s.charCodeAt();
  },
  debugBreak : function() {
    wt("debugger");
  },
  debug : function() {
    if (mt & P.Debug) {
      console.debug.apply(console, arguments);
    }
  },
  log : function() {
    if (mt & P.Log) {
      console.log.apply(console, arguments);
    }
  },
  warn : function() {
    if (mt & P.Warning) {
      console.warn.apply(console, arguments);
    }
  },
  error : function() {
    if (mt & P.Error) {
      console.error.apply(console, arguments);
    }
  },
  scanf : function(url, feed) {
    return $e(url, feed);
  },
  beginRenderAnalyze : function(context) {
    return (gt = gt || new dt).beginAnalyze(context || ThingApp.current.root.node);
  },
  endRenderAnalyze : function() {
    return (gt = gt || new dt).endAnalyze();
  },
  getRenderAnalyzeResult : function(results) {
    var fields = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    var pkg = ThingApp.current;
    var main = pkg.objectManager;
    gt = gt || new dt;
    var text = {
      onGetObjectByNode : function(val) {
        return main.getBaseObject(val);
      },
      onCloneObjet : function(o) {
        return Utils.cloneObject(o);
      },
      onCheckIsArray : function(prefix) {
        return Utils.isArray(prefix);
      }
    };
    var j;
    for (j in fields) {
      if (Object.hasOwnProperty.call(fields, j)) {
        text[j] = fields[j];
      }
    }
    return gt.getAnalyzeResult(results, text);
  },
  notifyAppComplete : function(result) {
    if (result && zt && ThingApp.current) {
      zt(ThingApp.current);
    }
  },
  waitAppComplete : function() {
    return Vt;
  },
  loadJSONFileAsync : function(descriptorURL) {
    return new Promise(function(callback, i) {
      var xhr = new XMLHttpRequest;
      xhr.open(yt, descriptorURL);
      xhr.responseType = "json";
      xhr.send();
      xhr.onload = function() {
        callback(xhr.response);
      };
    });
  },
  login : function() {
    function log(x, y) {
      return null == x ? y : x;
    }
    function callback(email, code, data, callback) {
      return wasmLoader.resourceDownloader.login(email, code, data, callback);
    }
    function join(options) {
      return window.wasmLoader ? wasmLoader.loadingPromise : !!THING.WASM && (THING.WASM.LOADER ? (window.wasmLoader = new THING.WASM.LOADER.WasmLoader, wasmLoader.init({
        wasmRootPath : options
      })) : void 0);
    }
    var d;
    var value = this;
    var result = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    var p = result.url;
    var interfaces = result.wasmRootPath;
    var error = log(result.method, yt);
    var output = log(result.requestHeaders, "");
    var html = log(result.postFields, "");
    return new Promise((d = i(g.mark(function init(scale, successCallback) {
      var s;
      var styleoutlinecolor;
      var pkg;
      return g.wrap(function(_context) {
        for (;;) {
          switch(_context.prev = _context.next) {
            case 0:
              return _context.next = 2, join(interfaces);
            case 2:
              if (s = _context.sent) {
                _context.next = 8;
                break;
              }
              console.error("It looks like you didn't import the wasm plugin!");
              successCallback();
              _context.next = 14;
              break;
            case 8:
              return styleoutlinecolor = s.Helper, (pkg = styleoutlinecolor.getPlatformInfo()) && (xt.WASM = {
                VERSION : pkg.version,
                COMPILETIME : pkg.compileTime
              }, "undefined" != typeof THING && (THING.WASM = THING.WASM || {}, THING.WASM.VERSION = pkg.version, THING.WASM.COMPILETIME = pkg.compileTime)), _context.next = 13, callback(error, p, output, html);
            case 13:
              scale();
            case 14:
            case "end":
              return _context.stop();
          }
        }
      }, init, value);
    })), function(canCreateDiscussions, i) {
      return d.apply(this, arguments);
    }));
  },
  loadPackageAsync : function(logErrorUrl) {
    return (new ft({
      url : logErrorUrl
    }))._loadingPromise;
  },
  loadPackage : function(url) {
    new ft({
      url : url
    });
  }
};
function Gt(script, text, scope, callback) {
  this._delaunayTriangles = null;
  this._rebuiltTriangles = null;
  this._points = [];
  this._indices = [];
  this._graph = null;
  this._extraIds = [];
  this._init(script, text, scope || 40, callback);
}
function qt(s, t) {
  var splits = [];
  var j = 0;
  var chans = s.length;
  for (; j < chans; j++) {
    var v = s[j];
    if (void 0 !== t && 0 !== splits.length) {
      var name = splits[splits.length - 1];
      var offset = new poly2tri.Point(v.x, v.y);
      var diff = Math.ceil(offset.clone().sub(name).length() / t);
      var value = offset.clone().sub(name).length() / diff;
      var math = offset.clone().sub(name);
      var i = 1;
      for (; i < diff; i++) {
        math.normalize();
        splits.push(name.clone().add(math.mul(value * i)));
      }
      splits.push(offset.clone());
    } else {
      splits.push(new poly2tri.Point(v.x, v.y));
    }
  }
  if (void 0 !== t) {
    name = splits[splits.length - 1];
    offset = splits[0];
    diff = Math.ceil(offset.clone().sub(name).length() / t);
    value = offset.clone().sub(name).length() / diff;
    math = offset.clone().sub(name);
    i = 1;
    for (; i < diff; i++) {
      math.normalize();
      splits.push(name.clone().add(math.mul(value * i)));
    }
  }
  return splits;
}
function Xt(s, a) {
  var best_part_step_diff = 1 / 0;
  var optj = 0;
  var j = 0;
  var startLen = a.length;
  for (; j < startLen; j++) {
    var tmp_step_diff = s.distanceTo(a[j]);
    if (tmp_step_diff < best_part_step_diff) {
      best_part_step_diff = tmp_step_diff;
      optj = j;
    }
  }
  return optj;
}
Object.defineProperties(Utils, {
  logLevelType : {
    get : function() {
      return mt;
    },
    set : function(num) {
      mt = num;
    }
  },
  disableLog : {
    get : function() {
      return console.log != Utils.consoleLogFunc;
    },
    set : function(options) {
      console.log = options ? function() {
      } : Utils.consoleLogFunc;
    }
  },
  disableWarning : {
    get : function() {
      return console.warn != Utils.consoleWarnFunc;
    },
    set : function(num) {
      console.warn = num ? function() {
      } : Utils.consoleWarnFunc;
    }
  },
  disableTime : {
    get : function() {
      return console.time != Utils.consoleTimeFunc;
    },
    set : function(num) {
      if (num) {
        console.time = function() {
        };
        console.timeEnd = function() {
        };
      } else {
        console.time = Utils.consoleTimeFunc;
        console.timeEnd = Utils.consoleTimeEndFunc;
      }
    }
  }
}), Object.assign(Gt.prototype, {
  _init : function(data, o, value, args) {
    var layer;
    var t;
    if (data.contour) {
      (layer = {}).contour = qt(data.contour, value);
      layer.holes = data.holes.map(function(val) {
        return qt(val, value);
      });
      t = data.y;
    } else {
      var g = new THREE.Geometry;
      g.fromBufferGeometry(data);
      g.mergeVertices();
      layer = function(geometry, template) {
        function check(object) {
          var xMin = 1 / 0;
          var yMin = 1 / 0;
          var idx = 0;
          for (; idx < object.length; idx++) {
            if (object[idx].x < xMin) {
              xMin = object[idx].x;
            }
            if (object[idx].y < yMin) {
              yMin = object[idx].y;
            }
          }
          return {
            x : xMin,
            y : yMin
          };
        }
        var tags = {};
        var j = 0;
        var faces = geometry.faces;
        var length = faces.length;
        for (; j < length; j++) {
          var buffer = [faces[j].a, faces[j].b, faces[j].c].sort(function(b, a) {
            return b - a;
          });
          var keywordResults = [[0, 1], [1, 2], [0, 2]];
          var i = 0;
          for (; i < keywordResults.length; i++) {
            var s = buffer[keywordResults[i][0]];
            var t = buffer[keywordResults[i][1]];
            if (tags[s + "_" + t]) {
              tags[s + "_" + t].count++;
            } else {
              tags[s + "_" + t] = {
                start : s,
                end : t,
                count : 1
              };
            }
          }
        }
        var result = [];
        var key;
        for (key in tags) {
          if (1 === tags[key].count) {
            result.push(tags[key]);
          }
        }
        var d = [];
        for (; result.length > 0;) {
          var startOrigin;
          var m = [];
          var newStart = result[0].start;
          var start = result[0].end;
          startOrigin = geometry.vertices[result[0].end];
          m.push({
            x : startOrigin.x,
            y : startOrigin.z
          });
          result.splice(0, 1);
          for (; start !== newStart;) {
            j = 0;
            length = result.length;
            for (; j < length; j++) {
              if (result[j].start == start) {
                startOrigin = geometry.vertices[result[j].end];
                m.push({
                  x : startOrigin.x,
                  y : startOrigin.z
                });
                start = result[j].end;
                result.splice(j, 1);
                break;
              }
              if (result[j].end == start) {
                startOrigin = geometry.vertices[result[j].start];
                m.push({
                  x : startOrigin.x,
                  y : startOrigin.z
                });
                start = result[j].start;
                result.splice(j, 1);
                break;
              }
            }
          }
          d.push(m);
        }
        var w = 1 / 0;
        var h = 1 / 0;
        var i = 0;
        var polygons = [];
        j = 0;
        length = d.length;
        for (; j < length; j++) {
          var i = qt(d[j], template);
          polygons.push(i);
          var item = check(i);
          if (item.x < w || item.y < h) {
            w = item.x;
            h = item.y;
            i = j;
          }
        }
        var poly = polygons[i];
        return polygons.splice(i, 1), {
          contour : poly,
          holes : polygons
        };
      }(g, value);
      t = g.vertices[0].y;
    }
    var context = new poly2tri.SweepContext(layer.contour);
    if (context.addHoles(layer.holes), context.triangulate(), this._delaunayTriangles = context.getTriangles(), this._rebuiltTriangles = function(inData, transform) {
      var html = [];
      var i = 0;
      for (; i < inData.length; i++) {
        var minima = inData[i].getPoints();
        var o = new THREE.Triangle;
        o.a.set(minima[0].x, transform, minima[0].y);
        o.b.set(minima[1].x, transform, minima[1].y);
        o.c.set(minima[2].x, transform, minima[2].y);
        html.push(o);
      }
      return html;
    }(this._delaunayTriangles, t), function(wrappersTemplates, dataRef, chunk, i) {
      var arriveUniqueId = 0;
      wrappersTemplates.forEach(function(trace) {
        var j = 0;
        for (; j < trace.points_.length; j++) {
          if (void 0 === trace.points_[j]._id) {
            trace.points_[j]._id = arriveUniqueId++;
          }
        }
      });
      var conf_shortcuts_icon = [[1, 2], [0, 2], [0, 1]];
      var token = {};
      var index = 0;
      wrappersTemplates.forEach(function(item) {
        var parts = [];
        var i = 0;
        for (; i < 3; i++) {
          if (!item.constrained_edge[i]) {
            var options = item.getPoint(conf_shortcuts_icon[i][0]);
            var self = item.getPoint(conf_shortcuts_icon[i][1]);
            if (!token[options._id + "_" + self._id]) {
              var child = new THREE.Vector3((options.x + self.x) / 2, i, (options.y + self.y) / 2);
              child._index = index++;
              var bar = (new THREE.Vector3).set(options.x, i, options.y);
              bar._id = options._id;
              var d = (new THREE.Vector3).set(self.x, i, self.y);
              d._id = self._id;
              child._endPoints = [bar, d];
              dataRef.push(child);
              token[options._id + "_" + self._id] = child;
              token[self._id + "_" + options._id] = child;
            }
            parts.push(token[options._id + "_" + self._id]);
          }
        }
        if (2 === parts.length) {
          chunk.push(parts[0]._index, parts[1]._index);
        }
        if (3 === parts.length) {
          chunk.push(parts[0]._index, parts[1]._index);
          chunk.push(parts[1]._index, parts[2]._index);
          chunk.push(parts[2]._index, parts[0]._index);
        }
        item._sharedMidPoints = parts;
      });
    }(this._delaunayTriangles, this._points, this._indices, t), o && o.length > 0) {
      var args = this._points.slice(0);
      var j = 0;
      for (; j < o.length; j++) {
        var r = o[j];
        var i = this._points.length;
        var actual = Xt(r, args);
        this._points.push(r.clone());
        this._indices.push(i, actual);
        this._extraIds.push(i);
      }
    }
    this._graph = function(data, o, elems) {
      var c = {};
      if (elems) {
        elems.forEach(function(plot) {
          plot.box = (new THREE.Box3).setFromPoints(plot);
        });
      }
      var b = 0;
      var bl = o.length;
      for (; b < bl; b = b + 2) {
        var k = o[b + 0];
        var a = o[b + 1];
        var d = data[k];
        var v = data[a];
        c[k] = c[k] || {};
        c[a] = c[a] || {};
        if (elems && elems.find(function(keyReads) {
          return $t(d, v, keyReads);
        })) {
          c[k][a] = c[a][k] = 1 / 0;
        } else {
          c[k][a] = c[a][k] = d.distanceTo(v);
        }
      }
      return new Graph(c);
    }(this._points, this._indices, args);
  },
  findPath : function(x, start, to) {
    var cacheA = void 0 !== (to = to || {}).includeStart && to.includeStart;
    var reverseIsSingle = void 0 !== to.includeEnd && to.includeEnd;
    var reverseValue = void 0 === to.fixEnds || to.fixEnds;
    var myuser = void 0 !== to.pathSmooth ? to.pathSmooth : {
      enable : false,
      minFov : .115
    };
    var that = this;
    var deprecatedStylingMethods = [];
    if (!(len = this._extraIds.find(function(i) {
      return that._points[i].equals(x);
    }))) {
      var indexLookupKey = this._rebuiltTriangles.findIndex(function(p) {
        return p.containsPoint(x);
      });
      if (indexLookupKey > -1) {
        deprecatedStylingMethods = this._delaunayTriangles[indexLookupKey]._sharedMidPoints.map(function(match) {
          return match._index;
        });
      } else {
        deprecatedStylingMethods = [Xt(x, this._points)];
      }
      var len = this._points.length;
      this._points.push(x);
      this._graph.map[len] = {};
      deprecatedStylingMethods.forEach(function(i) {
        that._graph.map[i][len] = that._graph.map[len][i] = x.distanceTo(that._points[i]);
      });
    }
    var index = this._extraIds.find(function(i) {
      return that._points[i].equals(start);
    });
    var metasNeeded = [];
    if (!index) {
      var indexLookupKey = this._rebuiltTriangles.findIndex(function(range) {
        return range.containsPoint(start);
      });
      if (indexLookupKey > -1) {
        metasNeeded = this._delaunayTriangles[indexLookupKey]._sharedMidPoints.map(function(match) {
          return match._index;
        });
      } else {
        metasNeeded = [Xt(start, this._points)];
      }
      index = this._points.length;
      this._points.push(start);
      this._graph.map[index] = {};
      metasNeeded.forEach(function(i) {
        that._graph.map[i][index] = that._graph.map[index][i] = start.distanceTo(that._points[i]);
      });
    }
    var f = this._graph.findShortestPath(len, index).map(function(id) {
      return that._points[+id];
    });
    if (!cacheA && f.shift(), !reverseIsSingle && f.pop(), deprecatedStylingMethods.length > 0 && (deprecatedStylingMethods.forEach(function(i) {
      delete that._graph.map[i][len];
      delete that._graph.map[len][i];
    }), this._points.length = this._points.length - 1), metasNeeded.length > 0 && (metasNeeded.forEach(function(key) {
      delete that._graph.map[key][index];
      delete that._graph.map[index][key];
    }), this._points.length = this._points.length - 1), cacheA && reverseValue && f.length >= 3 && Qt(f[0], f[1], f[2]) < .25 * Math.PI && f.splice(1, 1), reverseIsSingle && reverseValue && f.length >= 3) {
      var field_used = f.length - 1;
      var base = f.length - 2;
      var FOOBARQUUX = f.length - 3;
      if (Qt(f[field_used], f[base], f[FOOBARQUUX]) < .25 * Math.PI) {
        f.splice(base, 1);
      }
    }
    return myuser && myuser.enable && (f = function(vertices, max) {
      max = void 0 !== max ? max : .115;
      var matches = [];
      var result = [];
      var originalCompanyId = -1;
      var tid = -1;
      var s = false;
      vertices.forEach(function(self, canCreateDiscussions) {
        if (0 !== canCreateDiscussions) {
          if (s) {
            return matches.push(null), void result.push(null);
          }
          var m = self._endPoints;
          if (!m) {
            return matches.push(null), result.push(null), void(s = true);
          }
          if (0 === matches.length) {
            matches.push(m[0]);
            result.push(m[1]);
            originalCompanyId = m[0]._id;
            tid = m[1]._id;
          } else {
            if (m[0]._id === originalCompanyId) {
              matches.push(null);
              result.push(m[1]);
              tid = m[1]._id;
            } else {
              if (m[0]._id === tid) {
                result.push(null);
                matches.push(m[1]);
                originalCompanyId = m[1]._id;
              } else {
                if (m[1]._id === originalCompanyId) {
                  matches.push(null);
                  result.push(m[0]);
                  tid = m[0]._id;
                } else {
                  if (m[1]._id === tid) {
                    result.push(null);
                    matches.push(m[0]);
                    originalCompanyId = m[0]._id;
                  } else {
                    matches.push(null);
                    result.push(null);
                    s = true;
                  }
                }
              }
            }
          }
        }
      });
      var b = vertices[0].clone();
      var v1 = new THREE.Vector3;
      var target = new THREE.Vector3;
      var t = new THREE.Vector3;
      var p = new THREE.Vector3;
      var a = new THREE.Vector3;
      var flags = [0];
      var j = 0;
      for (; j < matches.length; j++) {
        var m = matches[j];
        var n = result[j];
        if (null === m && null === n) {
          if (j > 0 && j === matches.length - 1 && (null !== matches[j - 1] || null !== result[j - 1])) {
            a.subVectors(vertices[j + 1], b);
            var vtickStep = t.angleTo(a);
            var choiceParagraphElement = a.angleTo(p);
            if (Math.sign(Zt(t, a)) !== Math.sign(Zt(a, p)) || vtickStep < max / 2 || choiceParagraphElement < max / 2) {
              flags.push(j);
            }
          } else {
            flags.push(j);
          }
        } else {
          if (0 === j) {
            v1.copy(m);
            target.copy(n);
            t.subVectors(v1, b);
            p.subVectors(target, b);
          } else {
            if (m) {
              a.subVectors(m, b);
              var x = t.angleTo(p);
              var from = a.angleTo(p);
              if (Math.sign(Zt(t, p)) === Math.sign(Zt(a, p)) && from <= x && from > max) {
                t.copy(a);
                v1.copy(m);
              } else {
                flags.push(j);
                b.copy(vertices[j]);
                v1.copy(m);
                t.subVectors(v1, b);
                p.subVectors(target, b);
              }
            } else {
              if (n) {
                a.subVectors(n, b);
                x = t.angleTo(p);
                from = t.angleTo(a);
                if (Math.sign(Zt(p, t)) === Math.sign(Zt(a, t)) && from <= x && from > max) {
                  p.copy(a);
                  target.copy(n);
                } else {
                  flags.push(j);
                  b.copy(vertices[j]);
                  target.copy(n);
                  t.subVectors(v1, b);
                  p.subVectors(target, b);
                }
              } else {
                console.error("side1 and side2 must has one null value!");
              }
            }
          }
        }
        if (j === matches.length - 1) {
          flags.push(j + 1);
        }
      }
      return flags.map(function(nextVertex) {
        return vertices[nextVertex];
      });
    }(f, myuser.minFov)), f.map(function(prefixTransliterations) {
      return prefixTransliterations.clone();
    });
  },
  getExtraPoints : function() {
    var sortedSelection = [];
    var ruler = this;
    return this._extraIds.forEach(function(i) {
      sortedSelection.push(ruler._points[i]);
    }), sortedSelection;
  },
  getDistance : function(start, node) {
    var key = Xt(start, this._points);
    var height = Xt(node, this._points);
    var result = this._graph.findShortestPath(key, height);
    var dist = 0;
    var i = 0;
    var thouthends = result.length;
    for (; i < thouthends - 1; i++) {
      var id = result[i];
      var name = result[i + 1];
      dist = dist + this._graph.map[id][name];
    }
    return dist;
  },
  findNearestPathPoint : function(name) {
    var i = Xt(name, this._points);
    return this._points[i];
  },
  getPoints : function() {
    return this._points;
  },
  getIndices : function() {
    return this._indices;
  },
  getRebuiltTriangles : function() {
    return this._rebuiltTriangles;
  }
});
var Jt = new THREE.Vector3;
var Yt = new THREE.Vector3;
function Qt(a, p, g) {
  return Jt.copy(p).sub(a), Yt.copy(p).sub(g), Jt.angleTo(Yt);
}
function Zt(b, t) {
  return b.x * t.z - b.z * t.x;
}
var Kt = new THREE.Box3;
function $t(key, n, options) {
  if (Kt.makeEmpty(), Kt.expandByPoint(key), Kt.expandByPoint(n), mesh = options.box, (global_aabb = Kt).max.x < mesh.min.x || global_aabb.min.x > mesh.max.x || global_aabb.max.z < mesh.min.z || global_aabb.min.z > mesh.max.z) {
    return false;
  }
  var mesh;
  var global_aabb;
  var o = false;
  var i = 0;
  var j = options.length - 1;
  for (; i < options.length; j = i++) {
    if (ei(key, n, options[i], options[j])) {
      o = true;
      break;
    }
  }
  return !!o || function(s, val) {
    var g = s.x;
    var d = s.z;
    var n = false;
    var i = 0;
    var j = val.length - 1;
    for (; i < val.length; j = i++) {
      var a = val[i].x;
      var c = val[i].z;
      var x = val[j].x;
      var t = val[j].z;
      if (c > d != t > d && g < (x - a) * (d - c) / (t - c) + a) {
        n = !n;
      }
    }
    return n;
  }(key, options);
}
function ei(c, p, v, a) {
  var b = (c.x - v.x) * (p.z - v.z) - (c.z - v.z) * (p.x - v.x);
  var d = (c.x - a.x) * (p.z - a.z) - (c.z - a.z) * (p.x - a.x);
  if (b * d > 0) {
    return false;
  }
  var s = (v.x - c.x) * (a.z - c.z) - (v.z - c.z) * (a.x - c.x);
  if (s * (s + b - d) > 0) {
    return false;
  }
  var m = s / (d - b);
  var offset = m * (p.x - c.x);
  var len = m * (p.z - c.z);
  return {
    x : c.x + offset,
    z : c.z + len
  };
}
function ti(canCreateDiscussions) {
  this._navigations = canCreateDiscussions;
  this._map = null;
  this._connectNavMap = null;
  this._connectPoints = [];
  this._init();
}
function ii(x, a) {
  var convertedBallx = -1;
  var k = 0;
  for (; k < a.length; k++) {
    if (a[k].equals(x)) {
      convertedBallx = k;
    }
  }
  return convertedBallx;
}
function ri(rangeStore) {
  var val = {};
  var high;
  for (high in rangeStore) {
    val[high] = Object.assign({}, rangeStore[high]);
  }
  return val;
}
function ni(navigation) {
  this._navigation = navigation;
}
Object.assign(ti.prototype, {
  _init : function() {
    this._map = {};
    this._connectNavMap = {};
    var i = 0;
    for (; i < this._navigations.length; i++) {
      var map = this._navigations[i];
      var points = map.getExtraPoints();
      var j = 0;
      for (; j < points.length; j++) {
        var w = points[j];
        var i = ii(w, this._connectPoints);
        if (i < 0) {
          i = this._connectPoints.length;
          w._index = i;
          this._connectPoints.push(w);
        } else {
          w._index = this._connectPoints[i]._index;
        }
      }
      if (points.length > 1) {
        j = 0;
        for (; j < points.length; j++) {
          var i = 0;
          for (; i < points.length; i++) {
            if (i !== j) {
              var a = map.getDistance(points[i], points[j]);
              var id = points[i]._index;
              var index = points[j]._index;
              this._map[id] = this._map[id] || {};
              this._map[index] = this._map[index] || {};
              this._map[id][index] = a;
              this._map[index][id] = a;
              this._connectNavMap[id] = this._connectNavMap[id] || {};
              this._connectNavMap[index] = this._connectNavMap[index] || {};
              this._connectNavMap[id][index] = map;
              this._connectNavMap[index][id] = map;
            }
          }
        }
      }
    }
  },
  findPath : function(name, start, x, v, opts) {
    function callback(a, v, d) {
      var points = v.getExtraPoints();
      var j = 0;
      for (; j < points.length; j++) {
        var i = ii(points[j], d);
        var result = v.getDistance(a, points[j]);
        data[p] = data[p] || {};
        data[i] = data[i] || {};
        data[p][i] = result;
        data[i][p] = result;
        methods[p] = methods[p] || {};
        methods[i] = methods[i] || {};
        methods[p][i] = v;
        methods[i][p] = v;
      }
    }
    if ((opts = opts || {}).includeStart = void 0 !== opts.includeStart && opts.includeStart, opts.includeEnd = void 0 !== opts.includeEnd && opts.includeEnd, name == x) {
      return this._navigations[name].findPath(start, v, opts);
    }
    if (0 == this._navigations[name].getExtraPoints().length || 0 == this._navigations[x].getExtraPoints().length) {
      return console.info("closed space: " + name + " or " + x), [];
    }
    var data = ri(this._map);
    var methods = ri(this._connectNavMap);
    var c = 0;
    var b = 0;
    var l = this._connectPoints.length;
    var i = 0;
    var f = (input = this._navigations[name]).findNearestPathPoint(start).clone();
    if (ii(f, this._connectPoints) < 0) {
      var p = l + i;
      i++;
      callback(f, input, this._connectPoints);
      this._connectPoints.push(f);
      c = p;
    } else {
      c = ii(f, this._connectPoints);
    }
    var d = (input = this._navigations[x]).findNearestPathPoint(v).clone();
    if (ii(d, this._connectPoints) < 0) {
      p = l + i;
      i++;
      callback(d, input, this._connectPoints);
      this._connectPoints.push(d);
      b = p;
    } else {
      b = ii(d, this._connectPoints);
    }
    if (c === b) {
      var newNodeLists = [];
      return opts.includeStart && newNodeLists.push(start.clone()), opts.includeEnd && newNodeLists.push(v.clone()), newNodeLists;
    }
    var result = Graph.findShortestPath(data, c, b);
    if (!result) {
      return this._connectPoints.length = l, console.info("find no path between rooms: " + name + " or " + x), [];
    }
    var a = [];
    var index = 0;
    for (; index < result.length - 1; index++) {
      var i = +result[index];
      var name = +result[index + 1];
      var input = methods[i][name];
      var x = {};
      x.includeStart = index > 0 || opts.includeStart;
      x.includeEnd = index < result.length - 2 || opts.includeEnd;
      x.fixEnds = opts.fixEnds;
      x.pathSmooth = opts.pathSmooth;
      var item = input.findPath(0 === index ? start : this._connectPoints[i], index >= result.length - 2 ? v : this._connectPoints[name], x);
      if (0 !== index) {
        item.shift();
      }
      a = a.concat(item);
    }
    return this._connectPoints.length = l, a;
  }
}), Object.assign(ni.prototype, {
  createPathPointsMesh : function() {
    var array = this._navigation.getPoints();
    var clr = [];
    var i = 0;
    var length = array.length;
    for (; i < length; i++) {
      array[i].toArray(clr, 3 * i);
    }
    var geometry = new THREE.BufferGeometry;
    return geometry.addAttribute("position", new THREE.BufferAttribute(new Float32Array(clr), 3)), new THREE.Points(geometry);
  },
  createPathLineSegmentsMesh : function() {
    var parser = this._navigation;
    var array = parser.getPoints();
    var clr = [];
    var indexAtt = parser.getIndices();
    var i = 0;
    var length = array.length;
    for (; i < length; i++) {
      array[i].toArray(clr, 3 * i);
    }
    var bufferedGeometry = new THREE.BufferGeometry;
    return bufferedGeometry.addAttribute("position", new THREE.BufferAttribute(new Float32Array(clr), 3)), bufferedGeometry.setIndex(indexAtt), new THREE.LineSegments(bufferedGeometry);
  },
  createRebuiltTrianglesMesh : function() {
    var curves = this._navigation.getRebuiltTriangles();
    var clr = [];
    var i = 0;
    var l = curves.length;
    for (; i < l; i++) {
      var curve = curves[i];
      curve.a.toArray(clr, 18 * i + 0);
      curve.b.toArray(clr, 18 * i + 3);
      curve.b.toArray(clr, 18 * i + 6);
      curve.c.toArray(clr, 18 * i + 9);
      curve.c.toArray(clr, 18 * i + 12);
      curve.a.toArray(clr, 18 * i + 15);
    }
    var bufferedGeometry = new THREE.BufferGeometry;
    return bufferedGeometry.addAttribute("position", new THREE.BufferAttribute(new Float32Array(clr), 3)), new THREE.LineSegments(bufferedGeometry);
  },
  createPathNodeByPoints : function(array) {
    var clr = [];
    var i = 0;
    var l = array.length;
    for (; i < l; i++) {
      array[i].toArray(clr, 3 * i);
    }
    var indices = [];
    i = 0;
    l = array.length;
    for (; i < l; i++) {
      if (i !== l - 1) {
        indices.push(i, i + 1);
      }
    }
    var t = new THREE.Group;
    var geometry = new THREE.BufferGeometry;
    geometry.addAttribute("position", new THREE.BufferAttribute(new Float32Array(clr), 3));
    var text = new THREE.Points(geometry);
    t.add(text);
    var geom = new THREE.BufferGeometry;
    geom.addAttribute("position", new THREE.BufferAttribute(new Float32Array(clr), 3));
    geom.setIndex(indices);
    var callback = new THREE.LineSegments(geom);
    return t.add(callback), t;
  }
});
var oi;
var si = function() {
  function c(data) {
    r(this, c);
    this.object = data;
    this.prevObjectPosition = null;
    this.prevObjectScale = null;
    this.prevObjectAngles = null;
    this._objects = [];
    this.groupNavigation = null;
    this.navigationHelpersNode = null;
    this.navigationHelpers = [];
  }
  return c.prototype.clear = function() {
    this.showHelper(false);
    this.prevObjectPosition = null;
    this.prevObjectScale = null;
    this.prevObjectAngles = null;
    this._objects = [];
    this.groupNavigation = null;
    this.navigationHelpers = [];
  }, c.prototype.needGen = function() {
    var obj = this.object;
    if (!obj) {
      return true;
    }
    if (!this.prevObjectPosition || !this.prevObjectScale || !this.prevObjectAngles) {
      return true;
    }
    var taskToMove = Utils.parseVector3(obj.position);
    var binaryKey = Utils.parseVector3(obj.scale);
    var r0c5ms = Utils.parseVector3(obj.angles);
    return !taskToMove.equals(this.prevObjectPosition) || (!binaryKey.equals(this.prevObjectScale) || !r0c5ms.equals(this.prevObjectAngles));
  }, c.prototype.getClipAreas = function(ast, text) {
    var parse = function(parent, node) {
      return parent == node || !!parent.isChildOf(node);
    };
    var jisps = [];
    if (text) {
      var i = 0;
      for (; i < text.length; i++) {
        var d = text[i];
        if (parse(ast, d.object)) {
          var s = [];
          var root = d.area;
          var i = 0;
          for (; i < root.length; i++) {
            var u = Utils.parseVector3(root[i]);
            s.push(u);
          }
          jisps.push(s);
        }
      }
    }
    return jisps;
  }, c.prototype.genFromData = function(e, length, root, descent) {
    if (!Utils.isFunction(e.getNavigationData)) {
      return false;
    }
    var src = e.getNavigationData();
    if (!src) {
      return false;
    }
    var poly = [];
    var i = 0;
    for (; i < 8; i = i + 2) {
      poly.push({
        x : src.data[i],
        y : src.data[i + 1]
      });
    }
    var results = [];
    i = 0;
    for (; i < src.holes.length; i++) {
      var js = 2 * src.holes[i];
      var groups = [];
      var is = 0;
      for (; is < 8; is = is + 2) {
        groups.push({
          x : src.data[js + is],
          y : src.data[js + is + 1]
        });
      }
      results.push(groups);
    }
    var input = new Gt({
      contour : poly,
      holes : results,
      y : 0
    }, length, 30, this.getClipAreas(e, descent));
    root.push(input);
    var date = new ni(input);
    return this.navigationHelpers.push(date), true;
  }, c.prototype.genFromMesh = function(x, y, map, name, m) {
    if (!Utils.isFunction(x.getNavigationMesh)) {
      return false;
    }
    var object = x.getNavigationMesh();
    if (!object) {
      return false;
    }
    var pos = object.geometry;
    if (!pos) {
      return false;
    }
    var geometry = pos.clone();
    if (!geometry.isBufferGeometry) {
      geometry = (new THREE.BufferGeometry).fromGeometry(geometry);
    }
    geometry.applyMatrix4(object.matrixWorld);
    geometry.applyMatrix4(m);
    var vector = new Gt(geometry, y, 30, this.getClipAreas(x, name));
    map.push(vector);
    var u = new ni(vector);
    return this.navigationHelpers.push(u), true;
  }, c.prototype._getCampus = function() {
    return this.object.isCampus ? this.object : this.object.parents.query(".Campus")[0];
  }, c.prototype.initFromObjects = function(m, d) {
    var _this = this._getCampus();
    if (_this) {
      var matrix = new THREE.Matrix4;
      matrix.getInverse(_this.node.matrixWorld);
      var b = [];
      var i = 0;
      for (; i < m.length; i++) {
        var e = m[i];
        var a = [];
        if (e.doors) {
          e.doors.forEach(function(geopoint) {
            var center = Utils.parseVector3(geopoint.position);
            center.applyMatrix4(matrix);
            a.push(center);
          });
        }
        if (this.genFromData(e, a, b, d) || this.genFromMesh(e, a, b, d, matrix)) {
          this._objects.push(e);
        }
      }
      this.groupNavigation = new ti(b);
    }
  }, c.prototype.init = function(v) {
    this.clear();
    var obj = this.object;
    this.prevObjectPosition = Utils.parseVector3(obj.position);
    this.prevObjectScale = Utils.parseVector3(obj.scale);
    this.prevObjectAngles = Utils.parseVector3(obj.angles);
    try {
      if (obj.isFloor) {
        var current = obj.rooms;
        if (current.length) {
          this.initFromObjects(current, v);
        } else {
          this.initFromObjects([obj], v);
        }
      } else {
        if (obj.isCampus) {
          this.initFromObjects([obj], v);
        }
      }
    } catch (e) {
      THING.Utils.error(e);
      THING.Utils.error(e.toString());
      THING.Utils.error("Init object(name:" + this.object.name + ", id:" + this.object.id + ") navigation failed");
    }
  }, c.prototype.getRoomID = function(id) {
    if (id.isBaseObject) {
      return this._objects.indexOf(id);
    }
    var k = 0;
    for (; k < this._objects.length; k++) {
      var host = this._objects[k];
      if (host.isFloor) {
        return k;
      }
      if (host.getRayCastPosition(id)) {
        return k;
      }
      var doors = host.doors;
      var i = 0;
      for (; i < doors.length; i++) {
        var door = doors[i];
        if (THING.Math.equalsVector(door.position, id)) {
          return k;
        }
      }
    }
    return -1;
  }, c.prototype.getEntryInfo = function(data, p, token) {
    var obj = data[p];
    var date = data[token];
    var id = -1;
    return this.object.isFloor ? obj && obj.isRoom ? id = this.getRoomID(obj) : date && (id = this.getRoomID(date)) : this.object.isCampus && (id = 0), -1 === id ? null : {
      id : id,
      pos : Utils.parseVector3(date)
    };
  }, c.prototype.findPath = function(options) {
    options = options || {};
    var self = this.getEntryInfo(options, "startRoom", "startPosition");
    if (!self) {
      return null;
    }
    var a = this.getEntryInfo(options, "endRoom", "endPosition");
    if (!a) {
      return null;
    }
    var _this = this._getCampus();
    if (!_this) {
      return null;
    }
    var matrix = new THREE.Matrix4;
    matrix.getInverse(_this.node.matrixWorld);
    var v = self.pos.clone();
    v.applyMatrix4(matrix);
    var pos = a.pos.clone();
    pos.applyMatrix4(matrix);
    var result = this.groupNavigation.findPath(self.id, v, a.id, pos, {
      includeStart : true,
      includeEnd : true,
      fixEnds : true,
      pathSmooth : {
        enable : true
      }
    });
    if (!result || !result.length) {
      return null;
    }
    var shiftY = options.height || 0;
    var start = self.pos;
    var boundary = [];
    var i = 0;
    for (; i < result.length; i++) {
      var p = result[i];
      p.y += shiftY;
      length = length + p.distanceTo(start);
      start = p;
      p.applyMatrix4(_this.node.matrixWorld);
      boundary.push(p.toArray());
    }
    return (boundary = THING.Math.toUniquePoints(boundary)).getPathLength = function() {
      return Utils.getLength(this);
    }, boundary;
  }, c.prototype.showHelper = function() {
    var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    if (this.object) {
      if (e) {
        if (!this.navigationHelpersNode) {
          this.navigationHelpersNode = new THREE.Group;
          var _this = this._getCampus();
          if (!_this) {
            return;
          }
          var i = 0;
          for (; i < this.navigationHelpers.length; i++) {
            var beforeTab = this.navigationHelpers[i];
            var n = beforeTab.createRebuiltTrianglesMesh();
            n.position.y = .1;
            n.material.color.setHex(6985427);
            this.navigationHelpersNode.add(n);
            var o = beforeTab.createPathPointsMesh();
            this.navigationHelpersNode.add(o);
            var s = beforeTab.createPathLineSegmentsMesh();
            this.navigationHelpersNode.add(s);
          }
          this.navigationHelpersNode.applyMatrix4(_this.node.matrixWorld);
          this.object.app.scene.add(this.navigationHelpersNode);
        }
      } else {
        if (this.navigationHelpersNode) {
          this.object.app.resourceManager.remove(this.navigationHelpersNode);
          this.navigationHelpersNode = null;
        }
      }
    }
  }, c;
}();
var ai = function(c) {
  return !c.isLight && !c.userData.skipBoundingBox;
};
var li = function() {
  function o() {
    r(this, o);
    this.object = null;
    this._boxes = null;
    this._initBoxes();
    this._disable = false;
  }
  return o.prototype.onAdd = function(data) {
    this.object = data;
  }, o.prototype.onRemove = function() {
  }, o.prototype.onUpdate = function(parentBindings) {
  }, o.prototype._getKey = function(name, version) {
    return (name ? "_onlyVisible" : "_all") + (version ? "_onlySelf" : "");
  }, o.prototype._getBox = function(type, options, id) {
    var key = this._getKey(options, id);
    return this._boxes[type][key];
  }, o.prototype._setBox = function(template, options, id, t) {
    if (!options || this.object.visible) {
      var key = this._getKey(options, id);
      this._boxes[template][key] = t;
    }
  }, o.prototype._updateBox = function(node, event, box, options, seriesStackIndexCallback) {
    var value = this._getBox(node, event, box);
    if (!value) {
      var set = new THREE.Box3;
      var context = this.object.node;
      set._setFromObject(context, function(args) {
        return (!seriesStackIndexCallback || false !== seriesStackIndexCallback(args)) && (!(event && !args.userData.skipBoxVisibleCheck && !args.ensureVisible("updateBox")) && ai(args));
      }, options);
      value = this._processBox(set, this.object);
      this._setBox(node, event, box, value);
    }
    return value;
  }, o.prototype._getVector3 = function(obj) {
    return obj.toArray();
  }, o.prototype._processBoxResult = function(options, self) {
    options.toBox = function() {
      var a = Utils.parseVector3(options.min);
      var b = Utils.parseVector3(options.max);
      return a.z == b.z && (a.z -= 1e-6, b.z += 1e-6), new THREE.Box3(a, b);
    };
    options.getWorldPosition = function(text) {
      var i = self.getOffsetPosition(text);
      i = THING.Math.divideVector(i, self.scale);
      var fromMetrics = text.boundingBox || self.boundingBox;
      var rect = self.worldToSelf(fromMetrics.center);
      var sub = THING.Math.addVector(rect, i);
      return self.selfToWorld(sub);
    };
    if (void 0 === options.initSize) {
      Object.defineProperties(options, {
        initSize : {
          get : function() {
            if (self._initBoxSize) {
              return self._initBoxSize;
            }
            var value;
            var callback = function(_) {
              var locations = new THREE.Vector3;
              return _.getSize(locations), locations.toArray();
            };
            var isNumber = function(o) {
              return !o || !!THING.Math.equalsVector(o, [0, 0, 0]);
            };
            var notKeyPress = self.app.modelResource.getBoundingBox(self.url);
            if (notKeyPress && (value = notKeyPress.size.concat()), isNumber(value) && self._loadingBoxSize && (value = self._loadingBoxSize), isNumber(value)) {
              var result = new THREE.Box3;
              self._traverseSelfNodes(function(child) {
                if (child.isMesh) {
                  result.union((new THREE.Box3)._setFromObject(child, ai));
                }
              });
              value = callback(result);
            }
            return isNumber(value) ? (result = (new THREE.Box3)._setFromObject(self.node, ai), self._initBoxSize = callback(result)) : self._initBoxSize = value, self._initBoxSize;
          }
        }
      });
    }
  }, o.prototype._processBox = function(self, object) {
    var edge_coords = [];
    self.getBoundingPositions().forEach(function(keyResultUpdates) {
      edge_coords.push(keyResultUpdates.toArray());
    });
    var permissions = new THREE.Vector3;
    self.getSize(permissions);
    var bounds = new THREE.Vector3;
    self.getCenter(bounds);
    var otherRangeMin = this._getVector3(self.min);
    var initialMaxVal = this._getVector3(self.max);
    var groupPermissionsRef = this._getVector3(permissions);
    var position = this._getVector3(bounds);
    var opts = {
      points : edge_coords,
      min : otherRangeMin,
      max : initialMaxVal,
      center : position,
      size : groupPermissionsRef,
      radius : permissions.length()
    };
    return this._processBoxResult(opts, object), opts;
  }, o.prototype._processOrientedBox = function(engine, body) {
    var sprite = body.node;
    var pipelets = (body.position, engine.points);
    var edge_coords = [];
    var base = new THREE.Vector3(1 / 0, 1 / 0, 1 / 0);
    var d = new THREE.Vector3(-1 / 0, -1 / 0, -1 / 0);
    pipelets.forEach(function(e) {
      var t = Utils.parseVector3(e);
      if (!(t.x != 1 / 0 && t.x != -1 / 0)) {
        t.x = 0;
      }
      if (!(t.y != 1 / 0 && t.y != -1 / 0)) {
        t.y = 0;
      }
      if (!(t.z != 1 / 0 && t.z != -1 / 0)) {
        t.z = 0;
      }
      t.applyMatrix4(sprite.matrixWorld);
      base.min(t);
      d.max(t);
      edge_coords.push(t.toArray());
    });
    var a = new THREE.Vector3;
    sprite.getWorldScale(a);
    var level = Utils.parseVector3(engine.size).multiply(a);
    var b = new THREE.Vector3;
    b.addVectors(base, d).multiplyScalar(.5);
    var otherRangeMin = this._getVector3(base);
    var initialMaxVal = this._getVector3(d);
    var radius = this._getVector3(level);
    var c = this._getVector3(b);
    var opts = {
      points : edge_coords,
      min : otherRangeMin,
      max : initialMaxVal,
      center : c,
      size : radius,
      radius : level.length()
    };
    return this._processBoxResult(opts, body), opts;
  }, o.prototype._getInverseMatrixWorld = function(object) {
    var inverseMatrix = new THREE.Matrix4;
    return object.updateWorldMatrix(true, false), inverseMatrix.getInverse(object.matrixWorld), inverseMatrix;
  }, o.prototype.getBoundingBox = function() {
    var minMax;
    var name = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    var y_rect = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    if (y_rect) {
      var cartoLayer = this;
      minMax = function(step) {
        return !cartoLayer.object._isChildNode(step);
      };
    }
    var bb = this._updateBox("boundingBox", name, y_rect, null, minMax);
    return bb;
  }, o.prototype.getOrientedBoundingBox = function() {
    var b = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    var bubbles = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    var e = this._getBox("orientedBoundingBox", b, bubbles);
    return e || (e = this._processOrientedBox(this.getLocalBoundingBox(b, bubbles), this.object), this._setBox("orientedBoundingBox", b, bubbles, e)), e;
  }, o.prototype.getLocalBoundingBox = function() {
    var element;
    var event = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    var max = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    var that = this._getInverseMatrixWorld(this.object.node);
    if (max) {
      var cartoLayer = this;
      element = this._updateBox("selfLocalBoundingBox", event, max, that, function(inmediate_node) {
        return !cartoLayer.object._isChildNode(inmediate_node);
      });
    } else {
      element = this._updateBox("localBoundingBox", event, max, that);
    }
    return element;
  }, o.prototype._traverse = function(fn) {
    var i;
    for (i in this._boxes) {
      var array = this._boxes[i];
      for (i in array) {
        if (array[i]) {
          array[i] = fn(array[i], i);
        }
      }
    }
  }, o.prototype._initBoxes = function() {
    this._boxes = {
      boundingBox : {},
      orientedBoundingBox : {},
      localBoundingBox : {},
      selfLocalBoundingBox : {}
    };
  }, o.prototype.translate = function(x, t) {
    var i = Utils.parseVector3(x);
    this._traverse(function(e, host) {
      return t && t != host || e.translate(i), e;
    });
  }, o.prototype.setDirty = function(type, id) {
    var order;
    for (order in this._boxes) {
      var loc = this._getKey(type, id);
      this._boxes[order][loc] = null;
    }
  }, n(o, [{
    key : "dirty",
    set : function(num) {
      if (!this._disable) {
        if (num) {
          this._initBoxes();
        }
      }
    }
  }, {
    key : "disable",
    set : function(num) {
      this._disable = num;
    },
    get : function() {
      return this._disable;
    }
  }]), o;
}();
li._processBox = function(object, prop) {
  return (oi = oi || new li)._processBox(object, prop);
};
var ui = new Map;
var ci = new Map;
var hi = new Map;
function pi(name, text) {
  var i = 0;
  var l = text.length;
  for (; i < l; i++) {
    var part = text[i];
    if (name.startsWith(part)) {
      return true;
    }
  }
  return false;
}
function di(name) {
  var subBuffer = "";
  var i = 0;
  for (; i < name.length; i++) {
    var c = name[i];
    if ("=" != c && "<" != c && ">" != c && "!" != c) {
      break;
    }
    subBuffer = subBuffer + c;
  }
  return "=" == subBuffer && (subBuffer = "=="), subBuffer.trimBoth(" \t");
}
function fi(id, t) {
  var url = id + "('";
  var subBuffer = "";
  var j = 0;
  for (; j < t.length; j++) {
    var c = t[j];
    if ("=" == c || "<" == c || ">" == c || "!" == c) {
      break;
    }
    subBuffer = subBuffer + c;
  }
  url = url + subBuffer.trimBoth('" \t');
  url = url + "'";
  url = url + ",";
  var part = t.substring(j);
  if (part) {
    var html = di(part);
    if (html) {
      if (part = (part = part._trimLeft(html).trimBoth(" \t")).replaceAll("^(0+)", "")) {
        if (!Utils.isNumberString(part)) {
          if ('"' != part[0] && "'" != part[0]) {
            part = "'" + part + "'";
          }
        }
      } else {
        part = "0";
      }
    }
    url = url + part;
  }
  return url = url + ")";
}
function mi(b, s) {
  var message = b + "('";
  var subBuffer = "";
  var i = 0;
  for (; i < s.length; i++) {
    var c = s[i];
    if ("=" == c || "<" == c || ">" == c || "!" == c) {
      break;
    }
    subBuffer = subBuffer + c;
  }
  message = message + subBuffer.trimBoth('" \t');
  message = message + "'";
  message = message + ")";
  var value = s.substring(i);
  if (value) {
    var index = di(value);
    if (index) {
      if (value = (value = value._trimLeft(index).trimBoth(" \t")).replaceAll("^(0+)", "")) {
        if (!Utils.isNumberString(value)) {
          if ('"' != value[0] && "'" != value[0]) {
            value = "'" + value + "'";
          }
        }
      } else {
        value = "0";
      }
    }
    message = message + index;
    message = message + value;
  }
  return message;
}
function gi(obj, type, callback, options) {
  var wikitext = "";
  wikitext = wikitext + (obj + "(");
  if (options) {
    wikitext = wikitext + '"';
  }
  var part = function(val, base) {
    var ret = "";
    if (Utils.isArray(base)) {
      var len = 0;
      var n = val.length;
      for (; len < n && !pi(val.substring(len), base); len++) {
        ret = ret + val[len];
      }
    } else {
      len = 0;
      n = val.length;
      for (; len < n; len++) {
        var name = val[len];
        if (-1 !== base.indexOf(name)) {
          break;
        }
        ret = ret + name;
      }
    }
    return ret.trimBoth(" ");
  }(type, callback);
  return wikitext = wikitext + part, options && (wikitext = wikitext + '"'), {
    expression : wikitext = wikitext + ")",
    value : part
  };
}
function vi(b) {
  var i = 0;
  for (; i < b.length; i++) {
    var j = b[i];
    if ("=" == j || "<" == j || ">" == j || "!" == j) {
      return true;
    }
  }
  return false;
}
function yi(t, d, row) {
  t.forEach(function(msg) {
    if (msg.isBaseObject && d.evaluate(function(t) {
      return {
        _name : function(name) {
          return t.name == name;
        },
        _id : function(value) {
          return value.startsWith("#") ? t.uuid == value.substring(1) : t.id == value;
        },
        _type : function(type) {
          return true === t["is" + type] || t.type == type;
        },
        _regExp : function(t, method) {
          var name = method;
          if (method.startsWith("[")) {
            var key = method.substr(1, method.length - 2).trimBoth(" \t");
            name = t.getAttribute(key);
          }
          if (Utils.isString(name)) {
            var m = hi.get(t);
            return m || (m = new RegExp(t), hi.set(t, m)), m.test(name);
          }
          return false;
        },
        _regExpAttribute : function(i, name) {
          var r = [];
          if (THING.__new__selector__) {
            r.push(t.getAttribute(i));
            r.push(t.getAttribute("userData/" + i));
          } else {
            r.push(t.getAttribute("userData/" + i));
            r.push(t.getAttribute(i));
          }
          var res = ci.get(name);
          if (!res) {
            res = new RegExp("^" + name._trimRight("*"));
            ci.set(name, res);
          }
          var i = 0;
          for (; i < r.length; i++) {
            if (res.test(r[i])) {
              return true;
            }
          }
          return false;
        },
        _attribute : function(name) {
          var sandboxController;
          return THING.__new__selector__ ? void 0 === (sandboxController = t.getAttribute(name)) && (sandboxController = t.getAttribute("userData/" + name)) : void 0 === (sandboxController = t.getAttribute("userData/" + name)) && (sandboxController = t.getAttribute(name)), sandboxController;
        },
        _hasAttribute : function(name) {
          var shimObject = false;
          return THING.__new__selector__ ? (shimObject = t.hasAttribute(name)) || (shimObject = t.hasAttribute("userData/" + name)) : (shimObject = t.hasAttribute("userData/" + name)) || (shimObject = t.hasAttribute(name)), shimObject;
        }
      };
    }(msg))) {
      bi(row, msg);
    }
  });
}
function bi(el, t) {
  if (!t.canNotQueryFromSelector) {
    el.push(t);
  }
}
var _i = function() {
  function i(value, tag) {
    r(this, i);
    this.app = value;
    this.objects = tag;
  }
  return i.prototype._setAttribute = function(name, value) {
    var i = 0;
    for (; i < this.objects.length; i++) {
      var object = this.objects[i];
      if (object) {
        object.style[name] = value;
      }
    }
  }, i.prototype.setMaterial = function(material) {
    this.objects.forEach(function(box) {
      box.style.setMaterial(material);
    });
  }, n(i, [{
    key : "renderOrder",
    set : function(value) {
      this._setAttribute("renderOrder", value);
    }
  }, {
    key : "color",
    set : function(value) {
      this._setAttribute("color", value);
    }
  }, {
    key : "opacity",
    set : function(value) {
      this._setAttribute("opacity", value);
    }
  }, {
    key : "outlineColor",
    set : function(value) {
      this._setAttribute("outlineColor", value);
    }
  }, {
    key : "defaultOutlineColor",
    set : function(value) {
      this._setAttribute("defaultOutlineColor", value);
    }
  }, {
    key : "skipOutline",
    set : function(value) {
      this._setAttribute("skipOutline", value);
    }
  }, {
    key : "skipBoundingBox",
    set : function(value) {
      this._setAttribute("skipBoundingBox", value);
    }
  }, {
    key : "wireframe",
    set : function(value) {
      this._setAttribute("wireframe", value);
    }
  }, {
    key : "axisHelper",
    set : function(value) {
      this._setAttribute("axisHelper", value);
    }
  }, {
    key : "boundingBox",
    set : function(value) {
      this._setAttribute("boundingBox", value);
    }
  }, {
    key : "boundingBoxColor",
    set : function(value) {
      this._setAttribute("boundingBoxColor", value);
    }
  }, {
    key : "alwaysOnTop",
    set : function(value) {
      this._setAttribute("alwaysOnTop", value);
    }
  }, {
    key : "glow",
    set : function(value) {
      this._setAttribute("glow", value);
    }
  }, {
    key : "innerGlow",
    set : function(value) {
      this._setAttribute("innerGlow", value);
    }
  }, {
    key : "emissive",
    set : function(value) {
      this._setAttribute("emissive", value);
    }
  }]), i;
}();
xi = function() {
  function c(options, data) {
    var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    r(this, c);
    this.objects = [];
    this.app = options;
    this.objectManager = options.objectManager;
    this.events = options.events;
    this.length = 0;
    this.initObjectPool = data || this.objectManager.objects;
    this.ignoreCheckingQueryableObjects = n;
  }
  return c.prototype.query = function(item) {
    var controller = new c(this.app, this.initObjectPool);
    return controller.select(item, this.objects), controller;
  }, c.prototype._getObjects = function(item) {
    var items = null;
    if (item.isSelector) {
      items = (result = item).objects;
    } else {
      if (Utils.isString(item)) {
        var result;
        (result = new c(this.app, this.initObjectPool)).select(item);
        items = result.objects;
      } else {
        if (Utils.isArray(item)) {
          items = item;
        } else {
          if (item.isBaseObject || item.isGroup) {
            items = [item];
          } else {
            THING.Utils.error("selector.add unkown: " + item);
          }
        }
      }
    }
    return items;
  }, c.prototype.remove = function(obj) {
    if (!obj) {
      return this;
    }
    var conf = this._getObjects(obj);
    if (!conf) {
      return this;
    }
    var marks = this.objects;
    var i = 0;
    for (; i < marks.length; i++) {
      var z = 0;
      for (; z < conf.length; z++) {
        if (marks[i] == conf[z]) {
          marks.splice(i--, 1);
          break;
        }
      }
    }
    return this.buildReturnObject(marks);
  }, c.prototype.add = function(cmd) {
    if (!cmd) {
      return this;
    }
    var i = this._getObjects(cmd);
    if (!i) {
      return this;
    }
    var matches = this.objects.concat(i);
    var optionalDivisorsKeys = Array.from(new Set(matches));
    return this.buildReturnObject(optionalDivisorsKeys);
  }, c.prototype.not = function(val) {
    if (!val) {
      return this;
    }
    var arr = null;
    if (val.isSelector) {
      arr = (options = val).objects;
    } else {
      if (Utils.isString(val)) {
        var options;
        (options = new c(this.app, this.initObjectPool)).select(val);
        arr = options.objects;
      } else {
        if (Utils.isArray(val)) {
          arr = val;
        } else {
          if (!val.isBaseObject && !val.isGroup) {
            return THING.Utils.error("selector.not unkown: " + val), this;
          }
          arr = [val];
        }
      }
    }
    var i = 0;
    for (; i < arr.length; i++) {
      var p = arr[i];
      var index = this.objects.indexOf(p);
      if (index > -1) {
        this.objects.splice(index, 1);
      }
    }
    var objects = this.objects;
    return this.buildReturnObject(objects);
  }, c.prototype.parse = function(name, d, i) {
    if (Utils.isString(name)) {
      if ("*" == (name = (name = name._trimLeft("$")).trimBoth(' \t"'))) {
        !function(rowsArr, t) {
          rowsArr.forEach(function(tResult) {
            bi(t, tResult);
          });
        }(d, i);
      } else {
        var e = ui.get(name);
        if (e) {
          yi(d, e, i);
        } else {
          var n = function(str) {
            var token = "";
            var i = 0;
            for (; i < str.length; i++) {
              var c = str[i];
              if (" " != c && "\t" != c) {
                if ("#" == c) {
                  token = token + (promise = gi("_id", str.substring(i + 1), "\t|&", true)).expression;
                  i = i + promise.value.length;
                } else {
                  if ("." == c) {
                    token = token + (promise = gi("_type", str.substring(i + 1), "\t|&", true)).expression;
                    i = i + promise.value.length;
                  } else {
                    if ("/" == c) {
                      i = i + ((promise = gi("_regExp", str.substring(i + 1), "/", true)).value.length + 1);
                      var endArrayIdx = str.substring(i).indexOf("(");
                      if (-1 !== endArrayIdx) {
                        i = i + (endArrayIdx + 1);
                        var sl = str.substring(i).indexOf(")");
                        if (-1 !== sl) {
                          var n = str.substr(i, sl);
                          token = token + ("_regExp('" + promise.value + "', '" + n + "')");
                          i = i + (sl + 1);
                        }
                      }
                    } else {
                      if ("[" == c) {
                        if ((promise = gi("", str.substring(i + 1), "]")).value.endsWith("*")) {
                          token = token + fi("_regExpAttribute", promise.value);
                        } else {
                          token = token + mi(vi((promise = gi("", str.substring(i + 1), "]")).value) ? "_attribute" : "_hasAttribute", promise.value);
                        }
                        i = i + (promise.value.length + 1);
                      } else {
                        if ("|" == c) {
                          if ("|" == str[i + 1]) {
                            i++;
                          }
                          token = token + "||";
                        } else {
                          if ("&" == c) {
                            if ("&" == str[i + 1]) {
                              i++;
                            }
                            token = token + "&&";
                          } else {
                            if ("(" == c || ")" == c) {
                              token = token + c;
                            } else {
                              var promise;
                              token = token + (promise = gi("_name", str.substring(i), ["\t", "||", "&&"], true)).expression;
                              i = i + promise.value.length;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            return token;
          }(name);
          if (e = function(options, d, value) {
            var result = ui.get(options);
            if (!result) {
              try {
                result = new THING.Plugins.EVAL.Eval(options);
              } catch (e) {
                return THING.Utils.error(e), null;
              }
            }
            return yi(d, result, value), result;
          }(n, d, i)) {
            ui.set(name, e);
          } else {
            THING.Utils.error("Eval '" + name + "' expression failed");
          }
        }
      }
    } else {
      if (Utils.isRegExp(name)) {
        (function(e, rowsArr, i) {
          rowsArr.forEach(function(data) {
            if (e.test(data.name)) {
              bi(i, data);
            }
          });
        })(name, d, i);
      } else {
        if (Utils.isFunction(name)) {
          (function(observable, rowsArr, i) {
            rowsArr.forEach(function(result) {
              if (observable(result)) {
                bi(i, result);
              }
            });
          })(name, d, i);
        } else {
          if (name.isSelector) {
            (function(e, rowsArr, i) {
              rowsArr.forEach(function(t) {
                if (e.has(t)) {
                  bi(i, t);
                }
              });
            })(name, d, i);
          }
        }
      }
    }
  }, c.prototype.queryResult = function(result, obj) {
    result = result || {};
    obj = obj || this.initObjectPool;
    var input = [];
    return this.parse(result, obj, input), input;
  }, c.prototype.test = function(c, t) {
    return !!this.queryResult(c, t).length;
  }, c.prototype.select = function(b, x) {
    var i = this.queryResult(b, x);
    return this.buildReturnObject(i);
  }, c.prototype.buildReturnObject = function(array) {
    if (this.clear(), (array = array || []).isSelector && (array = array.toArray()), !this.ignoreCheckingQueryableObjects) {
      var i = 0;
      for (; i < array.length; i++) {
        if (array[i].canNotQueryFromSelector) {
          array.splice(i--, 1);
        }
      }
    }
    this.objects = array;
    this.length = array.length;
    i = 0;
    for (; i < array.length; i++) {
      this[i] = array[i];
    }
    return this;
  }, c.prototype.clear = function() {
    var i = 0;
    for (; i < this.length; i++) {
      this[i] = null;
    }
    this.objects = [];
    this.length = 0;
  }, c.prototype.forEach = function(object) {
    if (object) {
      var o = 0;
      for (; o < this.objects.length; o++) {
        var obj = this.objects[o];
        if (obj) {
          if (false === object(obj, o)) {
            break;
          }
        }
      }
    }
  }, c.prototype.filter = function(val) {
    var value = this.objects.filter(function(elem, datum) {
      return !!elem && false !== val(elem, datum);
    });
    var result = new c(this.app, value);
    return result.buildReturnObject(value), result;
  }, c.prototype.sort = function(data) {
    data = data || function(boundaryPoint, options) {
      var offset = boundaryPoint.levelFromRoot;
      return options.levelFromRoot - offset;
    };
    this.objects.sort(data);
    var i = 0;
    for (; i < this.objects.length; i++) {
      this[i] = this.objects[i];
    }
    return this;
  }, c.prototype.toJSON = function() {
    return JSON.stringify(this.objects);
  }, c.prototype.toArray = function() {
    return this.objects;
  }, c.prototype.indexOf = function(name) {
    return this.objects.indexOf(name);
  }, c.prototype.splice = function(target, value) {
    var i = 0;
    for (; i < this.length; i++) {
      delete this[i];
    }
    this.objects.splice(target, value);
    this.length = this.objects.length;
    i = 0;
    for (; i < this.objects.length; i++) {
      this[i] = this.objects[i];
    }
    return this;
  }, c.prototype.concat = function(v) {
    var b = new c(this.app, this.objects);
    if (b.buildReturnObject(this.objects), v) {
      var i = 0;
      for (; i < v.length; i++) {
        if (-1 === b.indexOf(v[i])) {
          b.add(v[i]);
        }
      }
    }
    return b;
  }, c.prototype.reverse = function() {
    var value = this.objects.reverse();
    var result = new c(this.app, value);
    return result.buildReturnObject(value), result;
  }, c.prototype.has = function(obj) {
    return -1 !== this.objects.indexOf(obj);
  }, c.prototype.equals = function(array) {
    if (this.length != array.length) {
      return false;
    }
    var i = 0;
    for (; i < this.length; i++) {
      if (this[i] != array[i]) {
        return false;
      }
    }
    return true;
  }, c.prototype.setOpacity = function(value) {
    var opacity = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    var i = 0;
    for (; i < this.objects.length; i++) {
      var obj = this.objects[i];
      if (obj) {
        obj.style.setOpacity(value, opacity);
      }
    }
  }, c.prototype.flipVisible = function() {
    var i = 0;
    for (; i < this.objects.length; i++) {
      var item = this.objects[i];
      if (item) {
        item.visible = !item.visible;
      }
    }
  }, c.prototype.fadeIn = function(view) {
    var i = 0;
    for (; i < this.objects.length; i++) {
      var item = this.objects[i];
      if (item) {
        item.fadeIn(view);
      }
    }
  }, c.prototype.fadeOut = function(callback) {
    var i = 0;
    for (; i < this.objects.length; i++) {
      var post = this.objects[i];
      if (post) {
        post.fadeOut(callback);
      }
    }
  }, c.prototype.destroyAll = function() {
    var i = 0;
    for (; i < this.objects.length; i++) {
      var post = this.objects[i];
      if (post) {
        post.destroy();
      }
    }
    this.clear();
  }, c.prototype.on = function(name, event, c, callback, options) {
    this.objects.forEach(function(o) {
      o.on(name, event, c, callback, options);
    });
  }, c.prototype.off = function(name, event, context) {
    this.objects.forEach(function(r) {
      r.off(name, event, context);
    });
  }, c.prototype.one = function(eventName, fn, size, i, name) {
    this.objects.forEach(function(self) {
      self.one(eventName, fn, size, i, name);
    });
  }, c.prototype.trigger = function(name, data, event) {
    var i = 0;
    for (; i < this.objects.length; i++) {
      this.objects[i].trigger(name, data, event);
      if (data) {
        data.object = null;
      }
    }
  }, c.prototype.pauseEvent = function(e, element, event) {
    var i = 0;
    for (; i < this.objects.length; i++) {
      this.objects[i].pauseEvent(e, element, event);
    }
  }, c.prototype.pauseEventInFrame = function(e, t, c) {
    var i = 0;
    for (; i < this.objects.length; i++) {
      this.objects[i].pauseEventInFrame(e, t, c);
    }
  }, c.prototype.resumeEvent = function(e, a, fn) {
    var i = 0;
    for (; i < this.objects.length; i++) {
      this.objects[i].resumeEvent(e, a, fn);
    }
  }, c.prototype.getNodes = function() {
    var evaluate = function(x, node) {
      var i = 0;
      for (; i < x.length; i++) {
        if (node == x[i] || node.isChildOf(x[i])) {
          return true;
        }
      }
      return false;
    };
    var results = [];
    var i = 0;
    for (; i < this.objects.length; i++) {
      var o = this.objects[i];
      if (!evaluate(results, o.node)) {
        results.push(o.node);
      }
    }
    return results;
  }, c.prototype.destroy = function() {
    THING.Utils.warn("[Selector] Please use '.destroyAll()' to replace '.destroy()'");
    this.destroyAll();
  }, c.prototype.showBoundingBox = function(confirmed) {
    THING.Utils.warn("[Selector] Please use '.style.boundingBox=' to replace '.showBoundingBox()'");
    this.style.boundingBox = confirmed;
  }, n(c, [{
    key : "isSelector",
    get : function() {
      return true;
    }
  }, {
    key : "inheritVisible",
    set : function(v) {
      Utils.setArrayValue(this.objects, "inheritVisible", v);
    }
  }, {
    key : "inheritStyle",
    set : function(v) {
      Utils.setArrayValue(this.objects, "inheritStyle", v);
    }
  }, {
    key : "inheritPosition",
    set : function(v) {
      Utils.setArrayValue(this.objects, "inheritPosition", v);
    }
  }, {
    key : "inheritAngles",
    set : function(v) {
      Utils.setArrayValue(this.objects, "inheritAngles", v);
    }
  }, {
    key : "inheritScale",
    set : function(v) {
      Utils.setArrayValue(this.objects, "inheritScale", v);
    }
  }, {
    key : "visible",
    set : function(v) {
      Utils.setArrayValue(this.objects, "visible", v);
    }
  }, {
    key : "pickable",
    set : function(v) {
      Utils.setArrayValue(this.objects, "pickable", v);
    }
  }, {
    key : "draggable",
    set : function(v) {
      Utils.setArrayValue(this.objects, "draggable", v);
    }
  }, {
    key : "style",
    get : function() {
      return new _i(this.app, this.objects);
    }
  }, {
    key : "opacity",
    set : function(value) {
      THING.Utils.warn("[Selector] Please use '.style.opacity=' to replace '.opacity'");
      this.style.opacity = value;
    }
  }]), c;
}();
Ei = Symbol("private");
function wi(r, scope) {
  r[Ei] = {};
  var options = r[Ei];
  options.init = function() {
    options.values = Utils.parseValue(scope.values, 0);
    options.onChange = scope.onChange;
  };
  options.notifyChangeEvent = function() {
    if (options.previousValues != options.values) {
      var z = 0;
      for (; z < 32; z++) {
        var id = 1 << z;
        var r = options.values & id;
        if ((options.previousValues & id) != r) {
          var moveFunction = options.watchers[id];
          if (moveFunction) {
            moveFunction(!!r);
          }
        }
      }
      var userOnChange = options.onChange;
      if (userOnChange) {
        userOnChange({
          previousValues : options.previousValues,
          values : options.values
        });
      }
    }
  };
  options.values = 0;
  options.previousValues = 0;
  options.watchers = {};
  options.onChange = null;
  options.init();
}
var Ti = function() {
  function self() {
    var deviceH = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    r(this, self);
    wi(this, deviceH);
  }
  return self.prototype.enable = function(e, b) {
    var cache = this[Ei];
    var data = cache.values;
    return b ? this.combine(e) : this.clear(e), data != cache.values;
  }, self.prototype.check = function(ast, rulecheck) {
    return !!(this[Ei].values & ast) == rulecheck;
  }, self.prototype.set = function(v) {
    if (!Utils.isNull(v)) {
      var m = this[Ei];
      m.previousValues = m.values;
      m.values = v;
      m.notifyChangeEvent();
    }
  }, self.prototype.get = function(num) {
    return !!(this[Ei].values & num);
  }, self.prototype.combine = function(type) {
    var self = this[Ei];
    self.previousValues = self.values;
    self.values |= type;
    self.notifyChangeEvent();
  }, self.prototype.clear = function(value) {
    var node = this[Ei];
    node.previousValues = node.values;
    if (Utils.isNull(value)) {
      node.values = 0;
    } else {
      node.values &= ~value;
    }
    node.notifyChangeEvent();
  }, self.prototype.has = function(id) {
    var attributeName = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    var abbrData = this[Ei];
    return attributeName ? (abbrData.values & id) == id : 0 != (abbrData.values & id);
  }, self.prototype.watch = function(n, r) {
    var watchers = this[Ei].watchers;
    var i = 0;
    for (; i < 32; i++) {
      var prop = n & 1 << i;
      if (prop) {
        watchers[prop] = r;
      }
    }
  }, n(self, [{
    key : "values",
    get : function() {
      return this[Ei].values;
    }
  }, {
    key : "onChange",
    get : function() {
      return this[Ei].onChange;
    },
    set : function(name) {
      this[Ei].onChange = name;
    }
  }]), self;
}();
Mi = Symbol("private");
Ci = 1, Si = 2, ji = 1;
var Pi = function() {
  function wrapper() {
    r(this, wrapper);
    (function(a) {
      a[Mi] = {};
      var me = a[Mi];
      me.parseEvent = function(value, type, name, cb) {
        value = Utils.parseValue(value, "");
        var options = {
          condition : null,
          callback : null,
          tag : null,
          priority : 50
        };
        return Utils.isFunction(value) ? (options.callback = value, Utils.isString(type) ? (options.tag = type, options.priority = cb || options.priority) : Utils.isNumber(type) && (options.priority = type)) : Utils.isString(value) && (Utils.isFunction(type) || THING.onError("Parse event failed, due to callback is not function with condition"), options.condition = value, options.callback = type, Utils.isString(name) ? (options.tag = name, options.priority = cb || options.priority) : Utils.isNumber(name) ? 
        options.priority = name : options.priority = cb || options.priority), options.callback || THING.onError("Parse event failed, deu to callback function is not existing"), options;
      };
      me.createCacheKey = function(store, namespace) {
        return store.uuid + "|" + namespace;
      };
      me.updateListenerMap = function(t, node) {
        var i = t.get(node.object);
        if (i) {
          Utils.insertBinaryBound(i, node, function(b, a) {
            return a.priority == b.priority ? b.__index - a.__index : a.priority - b.priority;
          });
        } else {
          t.set(node.object, [node]);
        }
      };
      me.addListener = function(options, target) {
        var fn = target.callback;
        fn.key = me.createCacheKey(target.object, target.tag);
        options.caches.set(fn.key, target);
        me.updateListenerMap(options.listenerMap, target);
        if (target.condition) {
          options.conditionalListeners = options.conditionalListeners || new Map;
          me.updateListenerMap(options.conditionalListeners, target);
        }
      };
      me.removeAllListeners = function(self, name) {
        self.listenerMap.get(name).forEach(function(t) {
          self.caches.delete(t.callback.key);
        });
        self.listenerMap.delete(name);
        var i = self.conditionalListeners;
        if (i) {
          i.delete(name);
        }
      };
      me.getListener = function(handler, id, type) {
        var n = me.createCacheKey(id, type);
        return handler.caches.get(n);
      };
      me.getListeners = function(type, evt) {
        var handler = me.hookers[type];
        return handler ? handler.listenerMap.get(evt) : null;
      };
      me.traverseListener = function(e) {
        var filtered = me.hookers;
        var item;
        for (item in filtered) {
          me.traverseListenerByType(item, e);
        }
      };
      me.traverseListenerByType = function(key, e) {
        var self = me.hookers[key];
        if (self) {
          self.listenerMap.forEach(function(wrappersTemplates) {
            wrappersTemplates.forEach(function(context) {
              e(context);
            });
          });
        }
      };
      me.createListeners = function() {
        return {
          listenerMap : new Map,
          caches : new Map,
          conditionalListeners : null
        };
      };
      me.deleteListeners = function(self) {
        self.listenerMap.forEach(function(wrappersTemplates) {
          wrappersTemplates.forEach(function(typeStatement) {
            typeStatement.object = null;
          });
        });
        self.listenerMap.clear();
        self.caches.clear();
        self.conditionalListeners = null;
      };
      me.removeListenerFromMap = function(sf, name) {
        if (sf) {
          sf.forEach(function(e) {
            var i = e.indexOf(name);
            if (-1 !== i) {
              e.splice(i, 1);
            }
          });
        }
      };
      me.removeListener = function(options, callback) {
        var r = callback.callback.key;
        var reqItem = options.caches.get(r);
        if (reqItem && reqItem.removed) {
          options.caches.delete(r);
        }
        me.removeListenerFromMap(options.listenerMap, callback);
        me.removeListenerFromMap(options.conditionalListeners, callback);
      };
      me.invokeListener = function(event, options) {
        var call = THING.onBeforeCallEventListener;
        if (call) {
          call(event, options);
        }
        (options = options || {}).object = options.object || event.object;
        options.data = options.data || event.userData;
        var masterTagUrl = event.callback.call(options.object, options, event.tag);
        var listener = THING.onAfterCallEventListener;
        return listener && listener(event, options), event.once && (event.removed = true), masterTagUrl;
      };
      me.dispatchEvent = function(type, obj, value, params, el) {
        var result = null;
        var i = 0;
        for (; i < obj.length; i++) {
          var event = obj[i];
          if (event.removed) {
            i--;
            me.removeListener(type, event);
          } else {
            if (!(event.paused || el && event.tag != el)) {
              if (event.selector) {
                if (event.object && !value.isChildOf(event.object)) {
                  continue;
                }
                if (event.selector && !event.selector.test(event.condition, value)) {
                  continue;
                }
              } else {
                if (event.object && event.object != value) {
                  continue;
                }
              }
              var val = me.invokeListener(event, params);
              result = result || val;
            }
          }
        }
        return result;
      };
      me.addEventListener = function(type, name, fn, callback, target, priority, once, context) {
        me.hookers[type] = me.hookers[type] || me.createListeners();
        var c = me.hookers[type];
        if (target) {
          a.removeEventListener(type, name, target);
        }
        var data = {
          __index : ji++,
          type : type,
          object : name,
          callback : callback,
          tag : target,
          priority : priority,
          once : once,
          userData : context,
          state : new Ti,
          get removed() {
            return this.state.has(Ci);
          },
          set removed(value) {
            if (this.state.enable(Ci, value), value) {
              var isShow = this.callback.onRemove;
              if (isShow) {
                isShow();
              }
            }
          },
          get paused() {
            return this.state.has(Si);
          },
          set paused(value) {
            this.state.enable(Si, value);
          },
          get actived() {
            return !this.removed && !this.paused;
          }
        };
        if (fn && Utils.isString(fn)) {
          data.selector = new xi;
          data.condition = fn;
        }
        me.addListener(c, data);
        var isPresent = THING.onAddEventListener;
        if (isPresent) {
          isPresent(data);
        }
      };
      me.removeEventListener = function(name, listener, callback) {
        var target = me.hookers[name];
        if (target) {
          if (callback) {
            var key = me.getListener(target, listener, callback);
            if (!key) {
              return;
            }
            key.removed = true;
            var findElement = THING.onRemoveEventListener;
            if (findElement) {
              findElement(key);
            }
          } else {
            target.listenerMap.forEach(function(wrappersTemplates) {
              wrappersTemplates.forEach(function(jread) {
                jread.removed = true;
                var checkIsFullRead = THING.onRemoveEventListener;
                if (checkIsFullRead) {
                  checkIsFullRead(jread);
                }
              });
            });
          }
        }
      };
      me.hookers = {};
    })(this);
  }
  return wrapper.prototype.dispose = function() {
    var ProfileManager = this[Mi];
    var i;
    for (i in ProfileManager.hookers) {
      ProfileManager.deleteListeners(ProfileManager.hookers[i]);
    }
    ProfileManager.hookers = {};
  }, wrapper.prototype.addEventListener = function(type, name, data, fn, options, handle, listener, callback) {
    var self = this[Mi];
    var opts = self.parseEvent(data, fn, options, handle);
    if (opts) {
      self.addEventListener(type, name, opts.condition, opts.callback, opts.tag, opts.priority, listener, callback);
    }
  }, wrapper.prototype.removeEventListener = function(name, fn, type) {
    this[Mi].removeEventListener(name, fn, type);
  }, wrapper.prototype.removeAllEventListeners = function(left) {
    this[Mi].traverseListener(function(t) {
      if (t.object == left) {
        t.removed = true;
        var interpolateBar = THING.onRemoveEventListener;
        if (interpolateBar) {
          interpolateBar(t);
        }
      }
    });
  }, wrapper.prototype.traverseListener = function(e) {
    this[Mi].traverseListener(e);
  }, wrapper.prototype.traverseListenerByType = function(key, e) {
    this[Mi].traverseListenerByType(key, e);
  }, wrapper.prototype.getEventListener = function(e, type, done, tag) {
    var r = this[Mi].getListeners(e, type);
    if (!r) {
      return null;
    }
    var i = 0;
    for (; i < r.length; i++) {
      var t = r[i];
      if (!t.removed && (t.condition == done && (!tag || t.tag == tag))) {
        return t;
      }
    }
    return null;
  }, wrapper.prototype.getEventListeners = function(el, eventName) {
    var Event = this[Mi];
    var handlers = [];
    if (el) {
      var r = Event.getListeners(el, eventName);
      if (!r) {
        return [];
      }
      var i = 0;
      for (; i < r.length; i++) {
        var event = r[i];
        if (!event.removed) {
          if (!(eventName && event.object != eventName)) {
            handlers.push(event);
          }
        }
      }
    } else {
      Event.traverseListener(function(event) {
        if (!(event.removed || eventName && event.object != eventName)) {
          handlers.push(event);
        }
      });
    }
    return handlers;
  }, wrapper.prototype.dispatchEvent = function(name, el, args, type) {
    var utils = this[Mi];
    if (el.destroyed) {
      return null;
    }
    var self = utils.hookers[name];
    if (!self) {
      return null;
    }
    var isTemplate = null;
    var e = self.listenerMap.get(el);
    if (e) {
      var n = utils.dispatchEvent(self, e, el, args, type);
      isTemplate = isTemplate || n;
    }
    var u = self.conditionalListeners;
    return u && u.forEach(function(name) {
      var n = utils.dispatchEvent(self, name, el, args, type);
      isTemplate = isTemplate || n;
    }), isTemplate;
  }, wrapper.prototype.invokeListener = function(event, target) {
    var me = this[Mi];
    if (event.actived) {
      me.invokeListener(event, target);
    }
  }, wrapper;
}();
Ri = Symbol("private");
var Di = function() {
  function e() {
    r(this, e);
    (function(itm, canCreateDiscussions) {
      itm[Ri] = {};
      var s = itm[Ri];
      s.sortStates = function() {
        s.states.sort(function(a, b) {
          return a.priority !== b.priority ? b.priority - a.priority : b.id - a.id;
        });
      };
      s.updateExistingState = function(type, name, value) {
        var path = s.states;
        var i = 0;
        for (; i < path.length; i++) {
          var property = path[i];
          if (property.name == name) {
            return property.value = type, Utils.isNumber(value) && (property.priority = value), s.sortStates(), true;
          }
        }
        return false;
      };
      s.id = 1;
      s.states = [];
    })(this);
  }
  return e.prototype.isAnyEnable = function() {
    var states = this[Ri].states;
    var i = 0;
    for (; i < states.length; i++) {
      if (states[i].value) {
        return true;
      }
    }
    return false;
  }, e.prototype.has = function(value) {
    var states = this[Ri].states;
    var i = 0;
    for (; i < states.length; i++) {
      if (states[i].name == value) {
        return true;
      }
    }
    return false;
  }, e.prototype.isEnable = function(name) {
    var states = this[Ri].states;
    if (name) {
      var i = 0;
      for (; i < states.length; i++) {
        var item = states[i];
        if (item.name == name) {
          return item.value;
        }
      }
    } else {
      if (states.length) {
        return states[0].value;
      }
    }
    return false;
  }, e.prototype.enable = function(type, data, value) {
    if (data) {
      var ctrl = this[Ri];
      var result = ctrl.states;
      if (!ctrl.updateExistingState(type, data, value)) {
        value = Utils.parseValue(value, 0);
        result.push({
          id : ctrl.id++,
          value : type,
          name : data,
          priority : value
        });
        ctrl.sortStates();
      }
    }
  }, e.prototype.clear = function() {
    this[Ri].states = [];
  }, e.prototype.getValue = function(arg) {
    var visibleChildren = this[Ri].states;
    var i = 0;
    for (; i < visibleChildren.length; i++) {
      var child = visibleChildren[i];
      if (child.name == arg) {
        return child.value;
      }
    }
    return null;
  }, n(e, [{
    key : "states",
    get : function() {
      return this[Ri].states;
    }
  }]), e;
}();
Ai = function() {
  function callback(size, source) {
    var node = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 60;
    r(this, callback);
    this.object = null;
    this.app = null;
    if (2 == size.length) {
      this._size = Utils.parseVector2(size);
    } else {
      this._size = Utils.parseVector3(size);
    }
    this._node = source;
    this._factor = node;
  }
  return callback.prototype._updateSize = function(sx) {
    if (this.object.visible) {
      var Cal = Utils.parseVector3(this.app.camera.position);
      this._node.keepSize(Cal, this._size, this._factor, sx, this.object.static, this.app.renderCamera.matrixWorldInverse);
      this.object.synIndependentWorldScale(false);
    }
  }, callback.prototype.onAdd = function(options) {
    this.object = options;
    this._node = this._node || this.object.node;
    this.app = options.app;
    this.object.tickable = true;
    if (this._node) {
      this._node.updateWorldMatrix(true);
    }
    this._updateSize();
  }, callback.prototype.onRemove = function() {
  }, callback.prototype.onUpdate = function(parentBindings) {
    return this._updateSize(), true;
  }, n(callback, [{
    key : "size",
    set : function(v) {
      this._size = Utils.parseVector2(v);
      this.object.synIndependentWorldScale();
      this._updateSize(true);
    },
    get : function() {
      return this._size.toArray();
    }
  }, {
    key : "node",
    set : function(str) {
      this._node = str;
    },
    get : function() {
      return this._node;
    }
  }]), callback;
}();
ki = Symbol("private");
Oi = function(data) {
  data[ki] = {};
  var service = data[ki];
  return service.onFilter = null, service.result = null, service;
};
Bi = function Connection() {
  return r(this, Connection), Oi(this), Array.apply(this, arguments), this.length = 0, Object.defineProperties(this, {
    length : {
      enumerable : false
    }
  }), this;
};
Bi.prototype = new Array, ["push", "pop", "splice", "shift"].forEach(function(name) {
  Bi.prototype[name] = function() {
    var check = this[ki];
    return check.result = null, Array.prototype[name].apply(this, arguments);
  };
}), Bi.prototype.concat = function() {
  return [].concat(this.map(function(q) {
    return q;
  }));
};
Bi.prototype.clear = function() {
  this.length = 0;
};
Bi.prototype.clearResult = function() {
  this[ki].result = null;
};
Object.defineProperties(Bi.prototype, {
  push : {
    enumerable : false
  },
  pop : {
    enumerable : false
  },
  splice : {
    enumerable : false
  },
  shift : {
    enumerable : false
  },
  concat : {
    enumerable : false
  },
  clear : {
    enumerable : false
  },
  clearResult : {
    enumerable : false
  },
  onFilter : {
    get : function() {
      return this[ki].onFilter;
    },
    set : function(v) {
      this[ki].onFilter = v;
    },
    enumerable : false,
    configurable : false
  },
  result : {
    get : function() {
      var test = this[ki];
      return test.result ? test.result : test.onFilter ? (test.result = this.filter(test.onFilter), test.result) : this;
    },
    enumerable : false,
    configurable : false
  }
});
var Fi = new THREE.Vector3;
var Li = new THREE.Vector3;
var Ii = new THREE.Quaternion;
var Ni = new THREE.Vector3;
var Hi = new THREE.Vector3(1, 1, 1);
Ui = new THREE.Vector3, zi = (new THREE.Vector3, new THREE.Matrix3);
Vi = 1, Wi = new THREE.Vector3, Gi = new THREE.Vector3, qi = new THREE.Quaternion, Xi = (new THREE.Quaternion, new THREE.Matrix4);
Ji = new THREE.Matrix4, BaseObject = function() {
  function self(value) {
    r(this, self);
    this.app = value;
    this._type = "";
    this._id = "";
    this._name = "";
    this._uuid = "";
    this._queryID = Vi++;
    this._parent = null;
    this._children = new Bi;
    this._children.onFilter = function(state) {
      return !state.isCombinedObject;
    };
    this.node = new THREE.Group;
    this.renderNode = this.node;
    this._lodNode = null;
    this._lodLevel = -1;
    this._builder = null;
    this._defaultStyle = null;
    this._style = null;
    this._initBoxSize = null;
    this._extensionsFile = null;
    this.anchorNode = null;
    this._ignoreParentScale = false;
    this._ignoreParentAngles = false;
    this._grid = null;
    this._boxNode = null;
    this._dragState = MAX_IMAGERY_LENGTH.No;
    this._draggable = false;
    this.isTickable = false;
    this._catchEventAnyTime = false;
    this._pickable = true;
    this._lookingAtObject = null;
    this._stateFlags = new Ti;
    this._independentControlFlags = new Ti;
    this._hideNodesInScene = null;
    this._renderDistance = null;
    this._shadowDistance = null;
    this._localClippingPlanes = [];
    this._clippingPlanes = [];
    this._clippingInWorldSpace = false;
    this._lockedOffset = [];
    this._independentPosition = null;
    this._independentWorldAngles = null;
    this._independentWorldScale = null;
    this.scaling = false;
    this.scaleTween = null;
    this.rotating = false;
    this.rotateTween = null;
    this.fadeTween = null;
    this.pathTween = null;
    this.pathTweens = [];
    this._attachPoints = null;
    this._controls = [];
    this.waitCommands = [];
    this._loadState = self.waitForLoading;
    this._internalUserData = {};
    this._userData = {};
    this._tags = [];
    this._groups = [];
    this._tweens = [];
    this._autoEnsureParentsVisible = true;
    this._autoSynVisible = true;
    this._keepSize = false;
    this._ignoreEvents = null;
    this._visibleGroupStates = new Di;
    this._scaleGroupStates = new Di;
    this._eventTrigger = new Pi(value);
    this._useShadow = true;
    this.initStaticMembers();
    this._selfLoadCompleteCallback = [];
    this._loadCompleteCallback = [];
  }
  return self.prototype._init = function(node, obj) {
    return this._parent = obj, this.node = node || this.node, this.loaded = true, this;
  }, self.prototype.initStaticMembers = function() {
    if (!self.hasStaticMembers) {
      self.hasStaticMembers = true;
      self.waitForLoading = 1;
      self.loading = 2;
      self.loadCompleted = 3;
      self.stateHideBySceneFlag = 1;
    }
  }, self.prototype.isBlockMouseOffEvent = function(array_name) {
    return false;
  }, self.prototype.setUserDataFlag = function(player, roundEnded) {
    if (roundEnded) {
      this.node.traverse(function(result) {
        result.userData[player] = true;
      });
    } else {
      this.node.traverse(function(result) {
        delete result.userData[player];
      });
    }
  }, self.prototype.setupUserData = function(obj) {
    obj = obj || {};
    var model = this.node.userData;
    model.isBaseObject = true;
    model.id = this._queryID;
    model.withGeometryIDAttributes = obj.withGeometryIDAttributes;
    var caps = this;
    model.getObject = function() {
      return caps.app.objectManager.get(caps._queryID);
    };
  }, self.prototype.setupNode = function(node) {
    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    if ("LOD" == node.type && (this._lodNode = node, this.tickable = true), node.visible || (node.ensureVisible(true, true), node.ensureVisible(false, false), this.visible = false), t) {
      var value = this.node.userData;
      this.node = node;
      this.renderNode = node;
      this.setupUserData(value);
    } else {
      this.renderNode = node;
      this.node.add(node);
    }
  }, self.prototype.setupName = function(diff) {
    this._name = this._name || this._id;
  }, self.prototype.setupID = function(val) {
    this._id = Utils.parseValue(val.id, this._id);
    this._name = Utils.parseValue(val.name, this._name);
    this._uuid = Utils.parseValue(val.uuid, this._uuid);
    this._id = this._id || this._uuid || this._name;
    if (!(this._id || this._uuid)) {
      this._id = THREE.MathUtils.generateUUID();
    }
    this.setupName(val);
    this.setupCommonInfo(val);
  }, self.prototype.setupCommonInfo = function(options) {
    this._internalUserData = options.internalUserData || this._internalUserData;
    this._stateFlags.enable(self.stateHideBySceneFlag, options.hideByScene);
    this._userData = options.properties || options.userData || {};
    this._tags = options.tags || [];
    if (options.forceBoundingBox) {
      this.node.userData.forceBoundingBox = true;
    }
    var i = Utils.parseValue(options.inheritStyle, true);
    if (this.inheritStyle != i) {
      this.inheritStyle = i;
    }
    var r = Utils.parseValue(options.inheritTheme, true);
    if (this.inheritTheme != r) {
      this.inheritTheme = r;
    }
    this.inheritVisible = Utils.parseValue(options.inheritVisible, true);
  }, self.prototype._setupLocalPosition = function(def) {
    var domain = def.localPosition;
    var defImplements = def.ignoreParentScale;
    if (domain) {
      this.setLocalPosition(domain, defImplements);
    }
  }, self.prototype.setupTranslation = function(obj) {
    if (this._ignoreParentScale = Utils.parseValue(obj.ignoreParentScale, false), this._ignoreParentAngles = Utils.parseValue(obj.ignoreParentAngles, false), !obj.skipSetupTranslation) {
      var href = self.DefaultPosition || {};
      var _noiseBuffers = self.DefaultAngles || {};
      var typeInfo = self.DefaultScale || {};
      var BELOW = obj.position || href[this._type];
      if (BELOW) {
        this.position = BELOW;
      } else {
        if (!obj.basePoint) {
          this._setupLocalPosition(obj);
        }
      }
      var angle = obj.angle;
      if (angle) {
        this.angles = [0, angle, 0];
      } else {
        var a = obj.angles || obj.localAngles || _noiseBuffers[this._type];
        if (a) {
          this.angles = a;
        }
      }
      var quaternion = obj.quaternion;
      if (quaternion) {
        this.quaternion = quaternion;
      }
      var root = obj.scale || typeInfo[this._type];
      if (root) {
        this.node.scale.copy(Utils.parseVector3(root));
      }
      this.synIndependentWorldScale(true, obj.inheritScale);
    }
    var dependencyNames = obj.initBoxSize;
    if (dependencyNames) {
      this._initBoxSize = dependencyNames.concat();
    }
  }, self.prototype.setupEnvMap = function(specificDirections) {
    var camera = this.getEnvMapResources();
    if (camera) {
      var directionsByTopic = specificDirections || this.isOutdoors;
      if (void 0 === directionsByTopic) {
        directionsByTopic = !!this.isCombinedObject && this.isChildOfType("Facade|Ground");
      }
      if (directionsByTopic) {
        if (camera.outdoorsEnvMap) {
          this.traverseAllSelfNodes(function(node) {
            if (!node.userData.skipEnvMap && node.material && node.isMesh) {
              if (Array.isArray(node.material)) {
                node.material.map(function(material) {
                  if ("envMap" in material) {
                    if (material.relaPosType && "Outdoor" !== material.relaPosType) {
                      var uniforms = material.clone();
                      return uniforms.envMap = camera.outdoorsEnvMap, uniforms.envMap.refCount = uniforms.envMap.refCount || 1, uniforms.envMap.refCount++, uniforms.envMapIntensity = 1.3, uniforms.relaPosType = "Outdoor", uniforms;
                    }
                    return material.envMap = camera.outdoorsEnvMap, material.envMap.refCount = material.envMap.refCount || 1, material.envMap.refCount++, material.envMapIntensity = 1.3, material.relaPosType = "Outdoor", material;
                  }
                  return material;
                });
              } else {
                if ("envMap" in node.material) {
                  if (node.material.relaPosType && "Outdoor" !== node.material.relaPosType) {
                    var material = node.material.clone();
                    material.envMap = camera.outdoorsEnvMap;
                    material.envMap.refCount = material.envMap.refCount || 1;
                    material.envMap.refCount++;
                    material.envMapIntensity = 1.3;
                    material.relaPosType = "Outdoor";
                    node.material = material;
                  } else {
                    node.material.envMap = camera.outdoorsEnvMap;
                    node.material.envMap.refCount = node.material.envMap.refCount || 1;
                    node.material.envMap.refCount++;
                    node.material.envMapIntensity = 1.3;
                    node.material.relaPosType = "Outdoor";
                  }
                }
              }
            }
          });
        }
      } else {
        if (camera.indoorsEnvMap) {
          this.traverseAllSelfNodes(function(node) {
            if (!node.userData.skipEnvMap && node.material && node.isMesh) {
              if (Array.isArray(node.material)) {
                node.material.map(function(material) {
                  if ("envMap" in material) {
                    if (material.relaPosType && "Indoor" !== material.relaPosType) {
                      var uniforms = material.clone();
                      return uniforms.envMap = camera.indoorsEnvMap, uniforms.envMap.refCount = uniforms.envMap.refCount || 1, uniforms.envMap.refCount++, uniforms.envMapIntensity = 1.3, uniforms.relaPosType = "Indoor", uniforms;
                    }
                    return material.envMap = camera.indoorsEnvMap, material.envMap.refCount = material.envMap.refCount || 1, material.envMap.refCount++, material.envMapIntensity = 1.3, material.relaPosType = "Indoor", material;
                  }
                  return material;
                });
              } else {
                if ("envMap" in node.material) {
                  if (node.material.relaPosType && "Indoor" !== node.material.relaPosType) {
                    var material = node.material.clone();
                    material.envMap = camera.indoorsEnvMap;
                    material.envMap.refCount = material.envMap.refCount || 1;
                    material.envMap.refCount++;
                    material.envMapIntensity = 1.3;
                    material.relaPosType = "Indoor";
                    node.material = material;
                  } else {
                    node.material.envMap = camera.indoorsEnvMap;
                    node.material.envMap.refCount = node.material.envMap.refCount || 1;
                    node.material.envMap.refCount++;
                    node.material.envMapIntensity = 1.3;
                    node.material.relaPosType = "Indoor";
                  }
                }
              }
            }
          });
        }
      }
    }
  }, self.prototype.loadFromURL = function(url, callback) {
    if (callback) {
      callback();
    }
  }, self.prototype.setupFromURL = function(options) {
    var enable = options.dynamic;
    if (this._dynamic = enable, this._dynamic) {
      this._url = Utils.parseValue(options.url, this._url);
      this.param = options;
      this.param.url = this._url;
      this._setup(options);
      this._loadState = self.waitForLoading;
    } else {
      if (options.node) {
        this._url = Utils.parseValue(options.url, this._url);
        this._setup(options);
      } else {
        var ret = this;
        this.loadFromURL(options, function() {
          ret._setup(options);
        });
      }
    }
  }, self.prototype.setupFromData = function(view) {
    this._setup(view);
  }, self.prototype.setupChildVisibleAsParent = function(formatters, customFormatters) {
  }, self.prototype.setupVisible = function(input) {
    this._autoEnsureParentsVisible = Utils.parseValue(input.autoEnsureParentsVisible, true);
    this._autoSynVisible = Utils.parseValue(input.autoSynVisible, true);
    var value = input.visible;
    if (!Utils.isNull(value)) {
      this.visible = value;
      var header = input.parent;
      if (header && value && this._autoEnsureParentsVisible) {
        header.node.visible = value;
        header.node.ensureParentsVisible(value);
      }
    }
  }, self.prototype._setup = function(val) {
    var label = val.node;
    if (label) {
      this.setupNode(label, Utils.parseValue(val.nodeOverride, true));
    }
    this.setupCommonInfo(val);
    this.setupUserData(val);
    this.setupParent(val);
    this.customSetup(val);
    this.setupComplete(val);
  }, self.prototype.setup = function(target) {
    this._beforeSetup(target);
    this.loading = true;
    this.setupID(target);
    this.setupVisible(target);
    var key = target.url;
    var prevData = target.data;
    var targetElem = target.domElement;
    if (key) {
      target.url = this.app.confirmURL(key)._trimRight("/");
      this.setupFromURL(target);
    } else {
      if (targetElem) {
        this.setupFromDom(target);
      } else {
        if (prevData) {
          this.setupFromData(target);
        } else {
          this._setup(target);
        }
      }
    }
  }, self.prototype._beforeSetupStyle = function(aNetChannelMessage) {
  }, self.prototype._afterSetupStyle = function(aNetChannelMessage) {
  }, self.prototype.setupStyle = function(data) {
    var a = data.style;
    if (a) {
      var n;
      for (n in this._beforeSetupStyle(data), a) {
        var v = a[n];
        if (void 0 !== v) {
          this.style[n] = v;
        }
      }
      this._afterSetupStyle(data);
    }
    var currentAnime = data.keepSize;
    if (currentAnime) {
      this.keepSize = currentAnime;
    }
  }, self.prototype.setupMaterials = function(result) {
    if (!Utils.parseValue(result.lights, true)) {
      var pipelets = this.node.getMeshes();
      this.node.getMaterials().forEach(function(s) {
        var m = new THREE.MeshBasicMaterial;
        m.copy(s);
        m.defines = {};
        m.lights = false;
        m.needsUpdate = true;
        pipelets.forEach(function(o) {
          if (Utils.isArray(o.material)) {
            var i = 0;
            for (; i < o.material.length; i++) {
              var c1 = o.material[i];
              if (c1 == s) {
                c1.dispose();
                o.material[i] = m;
              }
            }
          } else {
            if (o.material == s) {
              o.material.dispose();
              o.material = m;
            }
          }
        });
      });
    }
  }, self.prototype.setupResources = function(result) {
    if (this.loaded = Utils.parseValue(result.loaded, true), this.loaded) {
      if (this.setupCommands(result), this._processModel(true, true), this.dataToRecover) {
        this._setupResources(this.dataToRecover);
        this._resettingStyle = true;
        var s = this.style;
        var c = this.dataToRecover.style;
        ["color", "opacity", "outlineColor", "alwaysOnTop", "renderOrder"].forEach(function(i) {
          if (s[i] != c[i]) {
            s[i] = c[i];
          }
        });
        delete this._resettingStyle;
        delete this.dataToRecover;
      }
      if (this._boxNode) {
        this._boxNode.removeBySelf();
      }
      for (; this._loadCompleteCallback && this._loadCompleteCallback.length > 0;) {
        var createMediator = this._loadCompleteCallback.shift();
        if (createMediator) {
          createMediator({
            object : this
          });
        }
      }
    }
    this.trigger("setupResources");
  }, self.prototype._setupResources = function(canCreateDiscussions) {
  }, self.prototype._synFrom = function(res) {
    if (!res.isBaseObject) {
      return false;
    }
    this._visibleGroupStates.clear();
    var stateConfigs = res._visibleGroupStates.states;
    var i = 0;
    for (; i < stateConfigs.length; i++) {
      var raw = stateConfigs[i];
      this._setVisible(raw.value, raw.name);
    }
    return true;
  }, self.prototype.setupCommands = function(config) {
    if (this._style && Utils.isFunction(this._style._syn) && this._style._syn(), this.loaded && this.waitCommands.length) {
      var valamisApp = this.app.commandManager.create(this.waitCommands);
      if (valamisApp) {
        valamisApp.execute();
      }
      this.waitCommands = [];
    }
  }, self.prototype.setupInheritAttributes = function(val) {
    var t = Utils.parseValue(val.inheritPosition, true);
    var a = Utils.parseValue(val.inheritAngles, true);
    var b = Utils.parseValue(val.inheritScale, true);
    if (!(this.inheritPosition == t && this.inheritAngles == a && this.inheritScale == b)) {
      if (!(t && a && b)) {
        this.node.updateMatrixWorld();
      }
      this.inheritPosition = t;
      this.inheritAngles = a;
      this.inheritScale = b;
      this.synIndependentWorldPosition();
      this.synIndependentWorldAngles();
      this.synIndependentWorldScale();
    }
    if (!Utils.parseValue(val.inheritPickable, true)) {
      this.inheritPickable = false;
    }
  }, self.prototype.setupParent = function(options) {
    if (!options.skipSetupParent && !options.independent) {
      var engine = options.parent;
      if (engine && (engine.isBaseObject ? this._parent = engine : THING.Utils.error("[BaseObject] Please make sure parent is BaseObject")), null == this._parent && void 0 === engine && (this._parent || (this._parent = this.app.root)), this._parent) {
        if (this._parent._style && this._parent._style._inheritThemeName && this.inheritTheme && this.applyTheme(this._parent._style._inheritThemeName, false), this._parent.children && this._parent.children.indexOf(this) > -1) {
          return;
        }
        this._parent._add(this, options, -1);
      }
    }
  }, self.prototype.customSetup = function(bst) {
  }, self.prototype._beforeSetup = function(targetRadian) {
  }, self.prototype._notifyCompleteEvent = function(withHashes) {
    if (this._stateFlags.has(self.stateHideBySceneFlag)) {
      this._hideByScene = true;
    }
    var model = this;
    Utils.timer.setTimeout(function() {
      model.trigger("load", {
        object : model
      });
      model.trigger("complete", {
        object : model
      });
    }, 1);
  }, self.prototype._callComplete = function(options) {
    if (this._dynamic) {
      this.loaded = false;
    } else {
      this.loaded = Utils.parseValue(options.loaded, true);
    }
    if (this.queryID) {
      this.app.objectManager.objects.set(this.queryID, this);
    }
    this._notifyCompleteEvent(options);
    if (!Utils.parseValue(options.queryable, true)) {
      this.canNotQueryFromSelector = true;
    }
    this.trigger(EventType.Create, {
      object : this
    });
    this.app.trigger(EventType.Create, {
      object : this
    });
    var Factory = options.successCallback || options.complete;
    if (Factory) {
      Factory.call(this, {
        object : this
      });
    }
    this.app.needUpdate = true;
    this._ignoreParentScale = null;
    this._ignoreParentAngles = null;
  }, self.prototype._beforeSetupComplete = function(a22) {
  }, self.prototype._afterSetupComplete = function(a22) {
  }, self.prototype.useBottomCenterOfBoundingBoxAsPosition = function() {
    var box = this.boundingBox;
    var point = box.center;
    var boxSize = box.size;
    var baseCardinals = this.node.children.map(function(transform) {
      var v = new THREE.Vector3;
      return transform.getWorldPosition(v), v;
    });
    this.position = point;
    this.translateY(-boxSize[1] / 2);
    this.node.updateMatrixWorld();
    var n = 0;
    for (; n < this.node.children.length; n++) {
      this.node.children[n]._setWorldPosition(baseCardinals[n]);
    }
  }, self.prototype.setupComplete = function(e) {
    this.loaded = Utils.parseValue(e.loaded, true);
    this._userData = this._userData || {};
    this._internalUserData = this._internalUserData || {};
    this.setupTranslation(e);
    this.setupInheritAttributes(e);
    this._beforeSetupComplete(e);
    this.setupStyle(e);
    this.setupEnvMap();
    this.setupMaterials(e);
    this.setupResources(e);
    this.setupCommands(e);
    if (this.static) {
      this.node._synMatrixWorld();
    } else {
      this.node.updateWorldMatrix(false, false);
    }
    this._afterSetupComplete(e);
    this.selfUpdate();
    this._callComplete(e);
  }, self.prototype.setParent = function(obj, key, data) {
    var value = this._parent;
    if (value && value != obj && value.remove(this, false, key), this._parent = obj, obj) {
      var node = obj.node;
      if (key || !this.node.parent) {
        if (node) {
          node.add(this.node);
        }
      } else {
        this.node.attachToParent(node, this.app.scene, data);
      }
      if (this._style && this._style.alwaysOnTop) {
        this._style._setAlwaysOnTop(true);
      }
    }
  }, self.prototype.synTickableObject = function() {
    if (this.isTickable) {
      this.app.objectManager.addTickableObject(this);
    } else {
      this.app.objectManager.removeTickableObject(this);
    }
  }, self.prototype._setDirtyFlag = function(buildingApp, replace) {
    if (this._boundingBoxControl && (this._boundingBoxControl.dirty = true), buildingApp) {
      var context = this.parent;
      for (; context; context = context.parent) {
        if (context._boundingBoxControl) {
          context._boundingBoxControl.dirty = true;
        }
      }
    }
    if (replace) {
      this._children.forEach(function(canCreateDiscussions) {
        canCreateDiscussions._setDirtyFlag(false, true);
      });
    }
  }, self.prototype.getChildByPath = function(path, isArray) {
    var id = path.search("/");
    if (-1 !== id) {
      id = path.substring(0, id);
      path = path.substring(id.length + 1);
    } else {
      if (id = path, isArray) {
        if (isArray(this, id)) {
          return this;
        }
      } else {
        if (this._id == id) {
          return this;
        }
      }
    }
    var i = 0;
    for (; i < this._children.length; i++) {
      var value = this._children[i];
      var result = null;
      if (isArray ? isArray(value, id) && (result = value) : value.id == id && (result = value), result) {
        var organizer = result.getChildByPath(path);
        if (organizer) {
          return organizer;
        }
      }
    }
    return null;
  }, self.prototype._getBasePointNode = function(current) {
    var t = this.node.traverseBreakable(function(t) {
      return t.name.contains(current);
    });
    return t || (t = this.node.traverseBreakable(function(to) {
      return to.name == current;
    })), t;
  }, self.prototype._addFromCampus = function(text) {
  }, self.prototype.add = function(options) {
    var item = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;
    if ((options = options || {}).isBaseObject) {
      if (options.parent == this) {
        return false;
      }
      this._add(options, null, item);
    } else {
      var i = options.url;
      if (Utils.isString(i)) {
        var pos = options.position || this.position;
        var angles = options.angles || options.localAngles || this.angles;
        var o = Utils.parseValue(options.isCamFitScene, false);
        var complete = options.complete;
        var _self = this;
        this.app.create({
          type : "Campus",
          url : i,
          position : pos,
          angles : angles,
          isCamFitScene : o,
          complete : function(v) {
            var bar = v.object;
            _self._addFromCampus(bar);
            bar.destroy();
            _self.dirty = true;
            if (complete) {
              complete();
            }
            this.app.trigger("addFromCampusComplete");
          }
        });
      } else {
        var obj = options.object;
        if (!Utils.isNull(obj)) {
          if (obj.parent == this) {
            return false;
          }
          this._add(obj, options, item);
        }
      }
    }
  }, self.prototype._add = function(obj, options, index) {
    if (!obj) {
      return false;
    }
    if (!obj.isBaseObject) {
      return false;
    }
    if (!obj._builder) {
      obj._builder = this.builder;
    }
    var r = (options = options || {}).basePoint;
    var i = options.offset || options.localPosition;
    var newWidthPixels = options.angles || options.localAngles;
    var s = Utils.parseValue(options.keepNode, false);
    var a = Utils.parseValue(options.keepVisible, true);
    if (this.node.updateWorldMatrix(true, false), s) {
      var parentNode = obj.parent;
      if (parentNode) {
        var indexSticky = parentNode._children.indexOf(obj);
        if (-1 !== indexSticky) {
          parentNode._children.splice(indexSticky, 1);
        }
      }
      obj._parent = this;
    } else {
      var key = Utils.parseValue(options.keepLocalPosition || options.node, false);
      var item = Utils.parseValue(options.force || options.position || options.angles || options.scale, false);
      obj.setParent(this, key, item);
    }
    var target = void 0;
    if (Utils.isString(r)) {
      if (!(target = this._getBasePointNode(r))) {
        return THING.Utils.error("The '" + r + "' basePoint is not existing"), false;
      }
      var v = new THREE.Vector3;
      target.getWorldPosition(v);
      obj.position = v.toArray();
      if (i) {
        obj.position = THING.Math.addVector(obj.position, i);
      }
    } else {
      if (i) {
        obj.localPosition = i;
      }
    }
    return newWidthPixels && (obj.angles = newWidthPixels), obj._setDirtyFlag(true, false), index >= this._children.length || -1 === index ? this._children.push(obj) : this._children.splice(index, 0, obj), target && obj.node.attachToParent(target, true), obj.node.userData.removedNode && (obj.node.visible = true, delete obj.node.userData.removedNode), this._style && obj.inheritStyle && obj._syncStyleFrom(this), a && (this.visible || (obj.visible = this.visible)), Utils.parseValue(options.inheritPickable, 
    obj.inheritPickable) && obj.pickable != this.pickable && (obj.pickable = this.pickable), true;
  }, self.prototype._syncStyleFrom = function(left) {
    var colorMask = this;
    var object = left.style;
    ["wireframe", "color", "opacity", "emissive", "roughness", "outlineColor", "skipBoundingBox", "skipOutline", "glow", "innerGlow", "lineBloom", "radialBlur", "radialBlur2", "radialOffset", "focusRegion", "vertexNormalHelper", "axisHelper", "edgeColor", "alwaysOnTop", "doubleSide"].forEach(function(style) {
      var value = object[style];
      if (value) {
        if (!("opacity" == style && 1 == value)) {
          colorMask.style[style] = value;
        }
      }
    });
  }, self.prototype.remove = function(obj) {
    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    if (!obj) {
      return false;
    }
    if (!obj.isBaseObject) {
      return false;
    }
    if (!obj.isChildOf(this)) {
      return false;
    }
    obj._setDirtyFlag(true, false);
    obj.node.updateWorldMatrix(true, false);
    var safe = obj.node.getParents();
    if (-1 !== safe.indexOf(this.app.scene)) {
      if (i) {
        this.app.scene.add(obj.node);
      } else {
        obj.node.attachToParent(this.app.scene, false);
      }
      if (t) {
        obj.node.visible = false;
        obj.node.userData.removedNode = true;
      }
    }
    obj._parent = null;
    var val = this._children.indexOf(obj);
    return -1 !== val && this._children.splice(val, 1), true;
  }, self.prototype.swapChild = function(id, key) {
    var i = this._children.indexOf(id);
    var j = this._children.indexOf(key);
    if (-1 !== i && -1 !== j) {
      THING.Math.swapArray(this._children, i, j);
    }
  }, self.prototype.hasChild = function(name) {
    if (!name) {
      return !!this._children.length;
    }
    var i = 0;
    for (; i < this._children.length; i++) {
      if (this._children[i] == name) {
        return true;
      }
    }
    return false;
  }, self.prototype.destroy = function() {
    var pageViewData = this;
    var intersection__3365 = this._notifyDestroy;
    if (intersection__3365) {
      intersection__3365.call(this);
    }
    this.pickable = false;
    this.clearNode();
    var renderer = this.builder;
    if (renderer) {
      if (renderer.disposeObject) {
        renderer.disposeObject(this._uuid, false);
      }
      if (this.isCampus && renderer.clearAllResources) {
        renderer.clearAllResources();
      }
    }
    this.stopMoving();
    this.stopRotating();
    this.stopScaling();
    this.stopFade();
    this.stopAllLerpTo();
    var _this = this._style;
    if (_this) {
      if (_this.isBaseStyle) {
        _this.alwaysOnTop = false;
        _this._traverse(function(testItemData) {
          pageViewData.app.effectManager.clearAllEffects(testItemData);
        });
        _this.setEdgeWireframe(null);
        _this.revertMaterial();
      }
      _this._obj = null;
    }
    this.tickable = false;
    this.removeAllControls(false);
    this.app.objectManager.destroy(this);
    var sessionList = this._children.concat();
    var i = 0;
    for (; i < sessionList.length; i++) {
      sessionList[i].destroy();
    }
    this._children.clear();
    this.clearAttachPoints();
    if (this._parent) {
      this._parent.remove(this);
      this._parent = null;
    }
    if (this.node.parent) {
      this.node.parent.remove(this.node);
    }
    this.app.events.unbindCallObj(null, null, null, [this]);
    this._eventTrigger.dispose();
    this._lodNode = null;
    this._queryID = 0;
    delete this.node.userData.getObject;
    this.app.needUpdate = true;
    this._builder = null;
    if (this._style) {
      this._style.obj = null;
      this._style = null;
    }
    if (this._defaultStyle) {
      this._defaultStyle.obj = null;
      this._defaultStyle = null;
    }
  }, self.prototype.getRaycastPosition = function(dx) {
    if (!dx) {
      return null;
    }
    var raycaster = new THREE.Raycaster;
    raycaster.ray.origin = Utils.parseVector3(this.position);
    raycaster.ray.direction = Utils.parseVector3(dx);
    var nodeEvents = raycaster.intersectObject(this.app.scene, true);
    if (!nodeEvents.length) {
      return null;
    }
    var e = 0;
    for (; e < nodeEvents.length; e++) {
      var event = nodeEvents[e];
      var parent = event.object;
      if (this.app.objectManager.getBaseObject(parent) && !parent.isChildOf(this.node)) {
        return event.point.toArray();
      }
    }
    return null;
  }, self.prototype.removePickingResources = function() {
    this.app.picker.removePickingResources(this.node);
  }, self.prototype.setPickable = function(pickable) {
    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    this._pickable = pickable;
    var self = this;
    if (this._traverseSelfNodes(function(obj) {
      obj.setPickable(pickable, false);
      if (!pickable) {
        self.app.picker.removePickingResources(obj);
      }
    }), self.app.picker.forceUpdate = true, t) {
      var i = 0;
      for (; i < this._children.length; i++) {
        var elem = this._children[i];
        if (elem.inheritPickable) {
          elem.pickable = pickable;
        }
      }
    }
  }, self.prototype.synPickable = function() {
    this.setPickable(this._pickable);
  }, self.prototype.localToSelf = function(pos) {
    return this.worldToSelf(this.localToWorld(pos));
  }, self.prototype.selfToLocal = function(carat) {
    return this.worldToLocal(this.selfToWorld(carat));
  }, self.prototype.worldToSelf = function(position) {
    var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    var i = Utils.parseVector3(position);
    return this.node.updateWorldMatrix(true), t ? (this.node.matrixWorld.decompose(Wi, qi, Gi), Xi.compose(Wi, qi, Gi.set(1, 1, 1)), Ji.getInverse(Xi), Wi.fromArray(position).applyMatrix4(Ji).toArray()) : this.node.worldToLocal(i).toArray();
  }, self.prototype.selfToWorld = function(p) {
    var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    p = Utils.parseVector3(p);
    if (this.node.updateWorldMatrix(true), t) {
      var position = new THREE.Vector3;
      var to_slc = new THREE.Vector3;
      var quaternion = new THREE.Quaternion;
      this.node.matrixWorld.decompose(position, quaternion, to_slc);
      var matrix = new THREE.Matrix4;
      return matrix.compose(position, quaternion, i ? this.node.parent._getWorldScale() : new THREE.Vector3(1, 1, 1)), p.applyMatrix4(matrix).toArray();
    }
    return this.node.localToWorld(p).toArray();
  }, self.prototype.localToWorld = function(x) {
    return this._parent ? this._parent.selfToWorld(x) : this.node.localToWorld(Utils.parseVector3(x)).toArray();
  }, self.prototype.worldToLocal = function(p) {
    if (this._parent) {
      return this._parent.worldToSelf(p);
    }
    var target = Utils.parseVector3(p);
    return this.node.worldToLocal(target).toArray();
  }, self.prototype.distanceTo = function(x) {
    return x ? (x.isBaseObject && (x = x.position), Utils.parseVector3(this.position).distanceTo(Utils.parseVector3(x))) : 0;
  }, self.prototype._lookAtPosition = function() {
    this.node._lookAtPosition(this._lookingAtObject, this.static);
    this.synIndependentWorldAngles();
  }, self.prototype.lookAt = function(t, obj) {
    if (t) {
      var i;
      var vertical;
      var j;
      if (obj = obj || {}, Utils.isArray(obj) ? i = obj : (i = obj.angles, vertical = Utils.parseValue(obj.lockYAxis, false)), t.isBaseObject ? j = t.position : t.isCameraController ? j = t.cameraObject.position : (j = t, t = null), !j) {
        return void THING.Utils.error("lookAt failed, due to target is not existing");
      }
      var o = Utils.parseValue(obj.always, true);
      if (this._lookingAtObject = {
        target : t,
        targetPosition : Utils.parseVector3(j),
        type : "axis",
        axis : vertical ? "y" : null,
        quat : Utils.parseQuaternion(i)
      }, this.node.quaternion.set(0, 0, 0, 1), this.node.updateWorldMatrix(true, false), this.node.up.set(0, 1, 0), t && t.isCameraController) {
        var p1 = this.parents.query(".Campus")[0];
        if (p1) {
          var prev = p1.up;
          this.node.up.set(prev[0], prev[1], prev[2]);
        }
      }
      if (o) {
        this.tickable = true;
      } else {
        this._lookAtPosition();
        this._lookingAtObject = null;
      }
      this.selfUpdate();
      this._updateLookAt();
    } else {
      this._lookingAtObject = null;
      this.node.up.set(0, 1, 0);
    }
  }, self.prototype.rotate = function(value, args) {
    var cb = THING.Math.degToRad(value);
    (args = Utils.parseVector3(args || [0, 1, 0])).normalize();
    this.node.rotateOnAxis(args, cb);
    this.synIndependentWorldAngles();
    this.dirty = true;
  }, self.prototype.rotateX = function(theta) {
    if (!isNaN(theta)) {
      this.node.rotateX(THING.Math.degToRad(theta));
      this._synWorldAngles();
    }
  }, self.prototype.rotateY = function(angle) {
    if (!isNaN(angle)) {
      this.node.rotateY(THING.Math.degToRad(angle));
      this._synWorldAngles();
    }
  }, self.prototype.rotateZ = function(angle) {
    if (!isNaN(angle)) {
      this.node.rotateZ(THING.Math.degToRad(angle));
      this._synWorldAngles();
    }
  }, self.prototype.rotateAround = function(options) {
    var x = (options = options || {}).object;
    var i = options.target;
    var angle = Utils.parseValue(options.yRotateAngle || options.angle, 0);
    var pitch = Utils.parseValue(options.xRotateAngle, 0);
    var duration = options.time;
    var speed = options.speed;
    var side = Utils.parseLoopType(options.loopType);
    var start = options.stop;
    var handler = options.update;
    var onComplete = options.complete;
    if (i && (i.isBaseObject ? (x = i, i = null) : i = Utils.parseVector3(i)), duration) {
      if (speed = 0, !angle && !pitch) {
        return void THING.Utils.error("Please provide yRotateAngle or xRotateAngle to rotate around object");
      }
    } else {
      if (speed) {
        duration = 16777215;
      } else {
        if (angle || pitch) {
          speed = 0;
          duration = 1e3;
        } else {
          speed = 10;
          duration = 16777215;
        }
      }
    }
    var ll = Utils.parseVector3(this.position);
    var spherical = new THREE.Spherical;
    var offset = ll.clone();
    var a = i || Utils.parseVector3(x.position);
    offset.sub(a);
    spherical.setFromVector3(offset);
    this.stopRotating();
    this.rotating = true;
    var startPosition = this.position;
    var g = new THREE.Vector3;
    var theta = spherical.theta;
    var phi = spherical.phi;
    var camera = this;
    var draw = function() {
      if (side == THREE.LoopOnce) {
        if (onComplete) {
          onComplete();
        }
      } else {
        if (side == THREE.LoopRepeat) {
          camera.position = startPosition;
          camera.rotateAround(options);
        } else {
          if (side == THREE.LoopPingPong) {
            if (void 0 !== angle) {
              options.yRotateAngle = -angle;
            }
            if (void 0 !== pitch) {
              options.xRotateAngle = -pitch;
            }
            camera.rotateAround(options);
          }
        }
      }
    };
    var update = function() {
      var e = false;
      if (speed) {
        var opt = angle > 0 ? speed : -1 * speed;
        spherical.theta += opt / 1e3;
        var end = theta + THING.Math.degToRad(angle);
        if (angle > 0) {
          if (spherical.theta >= end) {
            spherical.theta = end;
            e = true;
          }
        } else {
          if (spherical.theta <= end) {
            spherical.theta = end;
            e = true;
          }
        }
      } else {
        var percent = this._object.progress;
        if (angle) {
          spherical.theta = theta + percent * THING.Math.degToRad(angle);
        }
        if (pitch) {
          spherical.phi = phi + percent * THING.Math.degToRad(pitch);
        }
      }
      var c = i ? i.clone() : Utils.parseVector3(x.position);
      if (spherical.radius = camera.distanceTo(c.toArray()), spherical.makeSafe(), g.setFromSpherical(spherical), c.add(g), camera.node.position.copy(c), handler && handler(), e) {
        var contentStart = start;
        start = null;
        this.stop();
        start = contentStart;
        draw.call(this);
      }
    };
    this.rotateTween = (new TWEEN.Tween({
      progress : 0
    })).to({
      progress : 1
    }, duration).easing(alphaIndex0.Linear.None).onStop(function() {
      if (start) {
        start();
      }
    }).onUpdate(function() {
      update.call(this);
    }).onComplete(function() {
      draw.call(this);
    });
    this.rotateTween.start();
  }, self.prototype.rotateOnWorldAxis = function(args) {
    args = args || {};
    var cb = Utils.parseVector3(args.axis);
    var angle = args.angle;
    if (cb && angle) {
      cb.normalize();
      var direction = THING.Math.degToRad(angle);
      this.node.rotateOnWorldAxis(cb, direction);
      if (this.static) {
        this.node._synMatrixWorld();
      }
    }
  }, self.prototype.rotateTo = function(options) {
    var q = (options = options || {}).quaternion;
    var value = options.angles || options.localAngles;
    var id = options.time;
    var ratio = options.speed;
    var easing = options.lerpType || alphaIndex0.Linear.None;
    var s = options.loopType || isAddEffect0.No;
    var complete = options.complete;
    if (q) {
      var root = this.node.quaternion.clone();
      var value = q;
      var d = new THREE.Quaternion;
      var time = Utils.getConsumeTimeByDistance(null, 100, id, ratio, 2e3);
      if (ratio) {
        easing = alphaIndex0.Linear.None;
      }
      this.stopRotating();
      this.rotating = true;
      var self = this;
      this.rotateTween = (new TWEEN.Tween({
        progress : 0
      })).to({
        progress : 1
      }, time).easing(easing).onUpdate(function() {
        var percent = this._object.progress;
        d.copy(root);
        d.slerp(value, percent);
        self.angles = Utils.parseAngles(d);
      }).onComplete(function() {
        if (s == isAddEffect0.Repeat) {
          self.angles = Utils.parseAngles(root);
          self.rotateTo(options);
        } else {
          if (s == isAddEffect0.PingPong) {
            options.quaternion = root;
            self.rotateTo(options);
          } else {
            if (complete) {
              complete.call(self, {
                object : self
              });
            }
          }
        }
      }).start();
    } else {
      if (value) {
        var position = Utils.parseVector3(this.angles);
        var resultsSubject = position.clone();
        var b = Utils.parseVector3(value);
        var result = Utils.getConsumeTime(null, position, b, id, ratio, 2e3);
        this.stopRotating();
        this.rotating = true;
        var self = this;
        this.rotateTween = (new TWEEN.Tween(position)).to(b, result).easing(easing).onUpdate(function() {
          self.angles = [this._object.x, this._object.y, this._object.z];
        }).onComplete(function() {
          if (s == isAddEffect0.Repeat) {
            self.angles = resultsSubject.toArray();
            self.rotateTo(options);
          } else {
            if (s == isAddEffect0.PingPong) {
              options.angles = resultsSubject.toArray();
              self.rotateTo(options);
            } else {
              if (complete) {
                complete.call(self, {
                  object : self
                });
              }
            }
          }
        }).start();
      }
    }
  }, self.prototype.stopRotating = function() {
    this.rotating = false;
    if (this.rotateTween) {
      this.rotateTween.stop();
    }
  }, self.prototype.scaleTo = function(settings) {
    var root = (settings = settings || {}).scale || [1, 1, 1];
    var i = settings.time;
    var ratio = settings.speed;
    var easing = settings.lerpType || alphaIndex0.Linear.None;
    var o = settings.loopType || isAddEffect0.No;
    var context = settings.complete;
    root[2] = root[2] || 1;
    var start = Utils.parseVector3(this.scale);
    var resultsSubject = start.clone();
    var target = Utils.parseVector3(root);
    var value = Utils.getConsumeTime(null, start, target, i, ratio, 2e3);
    this.stopScaling();
    this.scaling = true;
    var child = this;
    this.scaleTween = (new TWEEN.Tween(start)).to(target, value).easing(easing).onUpdate(function() {
      child.scale = [this._object.x, this._object.y, this._object.z];
    }).onStop(function() {
    }).onComplete(function() {
      if (o == isAddEffect0.Repeat) {
        child.scale = resultsSubject.toArray();
        child.scaleTo(settings);
      } else {
        if (o == isAddEffect0.PingPong) {
          settings.scale = resultsSubject.toArray();
          child.scaleTo(settings);
        } else {
          if (context) {
            context.call(child, {
              object : child
            });
          }
        }
      }
    }).start();
  }, self.prototype.stopScaling = function() {
    this.scaling = false;
    if (this.scaleTween) {
      this.scaleTween.stop();
    }
  }, self.prototype.canAcceptEvent = function(node) {
    var type = node.type;
    var obj = node.object;
    if ("update" == type) {
      return this;
    }
    if (A[type]) {
      return this;
    }
    if (obj) {
      if ("drag" == type && this.app.events.eventProcessor._draggingObject == this) {
        return this;
      }
      if (obj.isChildOf(this)) {
        if ("mouseover" == type) {
          return this;
        }
        if ("mousedown" == type) {
          return this;
        }
        if ("mouseup" == type) {
          return this;
        }
      }
    }
    return null;
  }, self.prototype._createDispatchEvent = function(eventName) {
    var me = this.app.events;
    var pass = {};
    if (D[eventName]) {
      var browserEvent = me.mouseMovePos;
      pass = me.createMouseEvent(eventName, {
        clientX : browserEvent[0],
        clientY : browserEvent[1]
      });
    }
    return pass;
  }, self.prototype._isAppEvent = function(controlName) {
    return -1 !== ["drag", "dragging", "keydown", "keypress", "keyup"].indexOf(controlName);
  }, self.prototype._on = function(name, type, fn, obj, callback, opts, listener) {
    if (!(name = Utils.toLowerCase(name))) {
      return THING.Utils.error("event type is invalid, please check it"), null;
    }
    var result = Utils.parseEvent(type, fn, obj, callback, opts);
    return result ? result.selector || this._isAppEvent(name) ? this.app.events.bindCallObj(name, result.selector, result.userData, result.callback, [this], result.tag, listener, result.priority) : ("update" == name && (this.tickable = true), this._eventTrigger.addEventListener(name, this, null, result.callback, result.tag, result.priority, listener, result.userData)) : null;
  }, self.prototype._off = function(element, type, handler) {
    element = Utils.toLowerCase(element);
    var entry = Utils.parseEvent(type, null, handler);
    return entry ? entry.selector ? this.app.events.unbindCallObj(element, entry.selector, entry.callback, [this]) : this._eventTrigger.removeEventListener(element, this, entry.tag) : null;
  }, self.prototype._pauseEvent = function(value, _, e, index) {
    if (value = Utils.toLowerCase(value), _) {
      this.app.events.pauseEvent(value, _, e, index, this);
    } else {
      if (this.parent) {
        this.parent.pauseEvent(value, this, e, index);
      }
      var res = this._eventTrigger.getEventListener(value, this, null, e);
      if (res) {
        res.paused = true;
      }
    }
  }, self.prototype._resumeEvent = function(value, _, e) {
    if (value = Utils.toLowerCase(value), _) {
      this.app.events.resumeEvent(value, _, e, this);
    } else {
      if (this.parent) {
        this.parent.resumeEvent(value, this, e);
      }
      var res = this._eventTrigger.getEventListener(value, this, null, e);
      if (res) {
        res.paused = false;
      }
    }
  }, self.prototype.on = function(type, callback, fn, data, context, args) {
    var result = this._on(type, callback, fn, data, context, args);
    var index = 0;
    for (; index < this._controls.length; index++) {
      var props = this._controls[index].control;
      if (Utils.isFunction(props.onRegisterEvent)) {
        props.onRegisterEvent(type, result);
      }
    }
    return this;
  }, self.prototype.off = function(name, type, context) {
    this.resumeEvent(name, type, context);
    var ds = this._off(name, type, context);
    var index = 0;
    for (; index < this._controls.length; index++) {
      var args = this._controls[index].control;
      if (Utils.isFunction(args.onUnregisterEvent)) {
        args.onUnregisterEvent(name, ds);
      }
    }
    return this;
  }, self.prototype.one = function(type, event, callback, name, context, values) {
    var ret = this._on(type, event, callback, name, context, values, true);
    var index = 0;
    for (; index < this._controls.length; index++) {
      var args = this._controls[index].control;
      if (Utils.isFunction(args.onRegisterEvent)) {
        args.onRegisterEvent(type, ret, true);
      }
    }
    return this;
  }, self.prototype.hasAnyEvents = function() {
    var div = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    var prohibitedListElementChildren = this.app.events.hasAnyCallObjects([this], div);
    return prohibitedListElementChildren || (prohibitedListElementChildren = !!this._eventTrigger.getEventListeners().length), prohibitedListElementChildren;
  }, self.prototype.hasEvent = function(name, type) {
    var i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
    name = Utils.toLowerCase(name);
    var e = this.app.events.hasEvent(name, this, type, i);
    return e || (e = !!this._eventTrigger.getEventListener(name, this, null, type)), e;
  }, self.prototype.trigger = function(name, data, type) {
    name = Utils.toLowerCase(name);
    var result = this.app.events.dispatchBindCallObj(name, data, [this], type);
    var value = this._eventTrigger.dispatchEvent(name, this, data, type);
    return Utils.parseValue(result, value);
  }, self.prototype.pauseEvent = function(element, e, elm) {
    this._pauseEvent(element, e, elm, false);
  }, self.prototype.pauseEventInFrame = function(ev, t, color) {
    this._pauseEvent(ev, t, color, true);
  }, self.prototype.resumeEvent = function(e, a, obj) {
    this._resumeEvent(e, a, obj);
  }, self.prototype.isPauseEvent = function(value, tag, content) {
    if (value = Utils.toLowerCase(value), content) {
      var body = this.getEvents(value);
      if (tag) {
        var n = false;
        var i = 0;
        for (; i < body.length; i++) {
          var row = body[i];
          if (tag && row.tag == tag) {
            n = true;
            break;
          }
        }
        if (!n) {
          return true;
        }
      } else {
        if (!body.length) {
          return true;
        }
      }
    }
    var normalized = this.app.events.isPauseEvent(value, this, tag);
    if (!normalized) {
      var newView = this._eventTrigger.getEventListener(value, this, null, tag);
      if (newView) {
        return newView.paused;
      }
    }
    return normalized;
  }, self.prototype.getEvents = function(node) {
    node = Utils.toLowerCase(node);
    var data = this.app.events.getEvents(node, this);
    if (!data) {
      return [];
    }
    var post = [];
    var z = 0;
    for (; z < data.length; z++) {
      var self = data[z];
      post.push({
        condition : self.condition,
        callback : self.callback,
        type : self.type,
        priority : self.priority,
        userData : self.userData,
        tag : self.tag,
        once : self.once
      });
    }
    return this._eventTrigger.getEventListeners(node, this).forEach(function(message) {
      post.push({
        condition : null,
        callback : message.callback,
        type : message.type,
        priority : message.priority,
        userData : message.userData,
        tag : message.tag,
        once : message.once
      });
    }), post;
  }, self.prototype._traverseObjects = function(el, t) {
    var i = 0;
    for (; i < this._children.length; i++) {
      var p = this._children[i];
      if (Utils.isFunction(el)) {
        el(p);
      } else {
        if (Utils.isArray(el)) {
          el.push(p);
        }
      }
      if (t) {
        p._traverseObjects(el, t);
      }
    }
  }, self.prototype._isChildNode = function(node) {
    var children = this.children;
    var i = 0;
    var length = children.length;
    for (; i < length; i++) {
      var e = children[i];
      if (node == e.node || node.isChildOf(e.node)) {
        return true;
      }
    }
    return false;
  }, self.prototype._getChildNodes = function() {
    var shouldRefs = [];
    return this.children.forEach(function(fn) {
      shouldRefs.push(fn.node);
    }), shouldRefs;
  }, self.prototype._getAllChildNodes = function() {
    var shouldRefs = [];
    return this._children.forEach(function(fn) {
      shouldRefs.push(fn.node);
    }), shouldRefs;
  }, self.prototype._traverseSelfNodes = function(t) {
    if (t) {
      var items = this._getChildNodes();
      this.node.traverseBranch(function(val) {
        if (-1 !== items.indexOf(val)) {
          return false;
        }
        t(val);
      });
    }
  }, self.prototype._traverseAllSelfNodes = function(e) {
    if (e) {
      var hash_settings = this._getAllChildNodes();
      this.node.traverseBranch(function(i) {
        if (-1 !== hash_settings.indexOf(i)) {
          return false;
        }
        e(i);
      });
    }
  }, self.prototype.traverseSelfNodes = function(tResult) {
    return this._traverseSelfNodes(tResult);
  }, self.prototype.traverseAllSelfNodes = function(e) {
    return this._traverseAllSelfNodes(e);
  }, self.prototype._traverseNodes = function(ast, root, includeMetadata) {
    var i = 0;
    for (; i < ast.children.length; i++) {
      var body = ast.children[i];
      var a = body.userData.baseObject_bindSubNode;
      if (!a) {
        (a = THING.SubObject.create(body, this)).name = body.name;
      }
      if (Utils.isFunction(root)) {
        root(a);
      } else {
        if (Utils.isArray(root)) {
          root.push(a);
        }
      }
      if (includeMetadata) {
        this._traverseNodes(body, root, includeMetadata);
      }
    }
  }, self.prototype.isSubNode = function() {
    return !!this.node.userData.baseObject_bindSubNode;
  }, self.prototype.traverse = function(func) {
    var nameArgs = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    if (func) {
      func(this);
      this._traverseObjects(func, nameArgs);
    }
  }, self.prototype._check = function(e) {
    var gs = new xi(this.app, [this]);
    return gs.select(e), !!gs.length;
  }, self.prototype.query = function(a) {
    var nameArgs = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    if (Utils.isString(a) && a.startsWith("/")) {
      var r = 0;
      var i = 0;
      for (; i < a.length; i++) {
        if ("/" == a[i]) {
          r++;
        }
      }
      if (1 === r) {
        return THING.Utils.warn("[BaseObject] Please use '.subNodes.query()' to replace it, and remove '/' prefix of params"), this.subNodes.query(new RegExp(a.substring(1)), nameArgs);
      }
    }
    var group = [];
    this._traverseObjects(group, nameArgs);
    if (i) {
      group.push(this);
    }
    var controller = new xi(this.app, group);
    return controller.select(a), controller;
  }, self.prototype._queryChild = function(x) {
    var gs = new xi(this.app, this._children);
    return gs.select(x), gs;
  }, self.prototype.isChildOf = function(node) {
    if (!node) {
      return false;
    }
    var parent = this._parent;
    for (; parent;) {
      if (parent == node) {
        return true;
      }
      parent = parent.parent;
    }
    return false;
  }, self.prototype.isBrotherOf = function(paragraph) {
    if (!paragraph) {
      return false;
    }
    var parent = this._parent;
    return !!parent && -1 !== parent._children.indexOf(paragraph);
  }, self.prototype.clearAttachPoints = function() {
    if (this._attachPoints) {
      var i = 0;
      for (; i < this._attachPoints.length; i++) {
        this._attachPoints[i].destroy();
      }
      this._attachPoints = null;
    }
  }, self.prototype.isAttachPoint = function(a) {
    if (a && a.node) {
      var octets = ["dummy:", "point:", "connector:"];
      var i = 0;
      for (; i < octets.length; i++) {
        if (a.name.startsWith(octets[i])) {
          return true;
        }
      }
    }
    return false;
  }, self.prototype.translate = function(size) {
    this.node.translateX(size[0]);
    this.node.translateY(size[1]);
    this.node.translateZ(size[2]);
    if (this.static) {
      this.node._synMatrixWorld();
    }
    this.synIndependentWorldPosition();
    this.dirty = true;
  }, self.prototype.translateX = function(distance) {
    this.translate([distance, 0, 0]);
  }, self.prototype.translateY = function(n) {
    this.translate([0, n, 0]);
  }, self.prototype.translateZ = function(distance) {
    this.translate([0, 0, distance]);
  }, self.prototype.moveTo = function(options) {
    if (Utils.isArray(options)) {
      options = {
        position : options
      };
    }
    var position = options.offset || options.offsetPosition || options.localPosition;
    var direction = options.direction;
    var body = Utils.parseValue(options.ignoreScale, true);
    if (position) {
      position = Utils.parseVector3(position);
    } else {
      if (direction) {
        position = Utils.parseVector3(direction);
        var t = Utils.parseValue(options.distance, 5);
        position.multiplyScalar(t);
      }
    }
    if (position) {
      options.position = this.selfToWorld(position.toArray(), body);
    }
    this.movePath(options);
  }, self.prototype.createPathTween = function(el, t, color, value, object, matrix) {
    var resource;
    var position = Utils.parseVector3(el).clone();
    var from = Utils.parseVector3(t).clone();
    if (color) {
      if (!matrix && object) {
        matrix = new THREE.Matrix4;
        object.updateWorldMatrix(true, false);
        matrix.getInverse(object.matrixWorld);
      }
      var m1 = new THREE.Matrix4;
      var vector = position.clone();
      var t = from.clone();
      vector.applyMatrix4(matrix);
      t.applyMatrix4(matrix);
      m1.lookAt(t, vector, this.node.up);
      var graph = new THREE.Quaternion;
      if (graph.setFromRotationMatrix(m1), value) {
        var q = new THREE.Quaternion;
        q.setFromAxisAngle(new THREE.Vector3(0, 1, 0), THING.Math.degToRad(value));
        graph.multiply(q);
      }
      resource = graph;
    }
    return {
      distance : position.distanceTo(from),
      from : position,
      to : from,
      toQuat : resource
    };
  }, self.prototype.createPathTweens = function(object, data, end, callback) {
    var matrix = new THREE.Matrix4;
    if (object) {
      object.updateWorldMatrix(true, false);
      matrix.getInverse(object.matrixWorld);
    }
    var type = 0;
    for (; type < data.length - 1; type++) {
      var t = data[type];
      var l = data[type + 1];
      var res = this.createPathTween(t, l, end, callback, object, matrix);
      this.pathTweens.push(res);
    }
  }, self.prototype.startPathTweens = function(speed, to, time, end, point, topDocumentPixelPosition, p, src, success, operation, axisOperation, saveNotifs) {
    var y = function(results) {
      var sum = 0;
      var i = 0;
      for (; i < results.length; i++) {
        sum = sum + results[i].distance;
      }
      return sum;
    }(this.pathTweens);
    if (y) {
      if (time) {
        speed = y / time * 1e3;
        p = alphaIndex0.Linear.None;
      }
      var last_modify = -1;
      var target = {
        progress : y
      };
      var i = function(results, height) {
        var textureVertices = [];
        var i = 0;
        for (; i < results.length; i++) {
          textureVertices.push(results[i].distance / height);
        }
        return textureVertices;
      }(this.pathTweens, y);
      var vec2 = new THREE.Vector3;
      var v = new THREE.Quaternion;
      var obj = this;
      this.pathTween = (new TWEEN.Tween({
        progress : 0
      })).to(target, speed).easing(p).delay(to).onUpdate(function() {
        var v = this._object.progress / y;
        var t = Utils.getArrayIndexFromProgress(obj.pathTweens, v, i);
        var end = Utils.getArrayProgress(obj.pathTweens, v, i);
        var p = obj.pathTweens[t];
        if (t != last_modify) {
          last_modify = t;
          if (end) {
            p.fromQuat = obj.node.quaternion.clone();
          }
        }
        if (point) {
          obj.node.lookAt(point);
        } else {
          if (end) {
            if (topDocumentPixelPosition) {
              v.copy(src ? p.fromQuat : obj.node.quaternion);
              v.slerp(p.toQuat, end);
              obj.angles = Utils.parseAngles(v);
            } else {
              obj.angles = Utils.parseAngles(p.toQuat);
            }
          }
        }
        vec2.copy(p.from);
        vec2.lerp(p.to, end);
        obj.position = vec2.toArray();
        if (success) {
          success({
            progress : v,
            fromPosition : p.from.toArray(),
            toPosition : p.to.toArray()
          });
        }
      }).onStart(function() {
        if (operation) {
          operation();
        }
      }).onStop(function() {
        if (axisOperation) {
          axisOperation();
        }
      }).onComplete(function() {
        if (saveNotifs) {
          saveNotifs();
        }
      }).start();
    } else {
      if (saveNotifs) {
        saveNotifs();
      }
    }
  }, self.prototype.movePath = function(options) {
    var frame;
    var d = (options = options || {}).path;
    var fn = Math.max(1, Utils.parseValue(options.time, 1e3));
    var expectedPackagePath = Utils.parseValue(options.delayTime, 0);
    var duration = options.speed;
    var s = Utils.parseValue(options.local, false);
    var DLF = Utils.parseValue(options.orientToPath, false);
    var methods = options.orientToPathDegree;
    var start = options.lookAt;
    var val = options.loopType;
    var minifyOptionsForStylesheet = function(from) {
      return null !== from.lerp && null !== from.lerpType && Utils.parseValue(from.lerp, true);
    }(options);
    var eYp4 = options.lerpType || alphaIndex0.Linear.None;
    var matterToolsPath = Utils.parseValue(options.smooth, true);
    var handler = options.update;
    var complete = options.complete;
    if (options.loop) {
      val = isAddEffect0.Repeat;
      THING.Utils.warn('[BaseObject] movePath() use "loopType(THING.LoopType)" to instead "loop(Boolean)" argument');
    }
    var parent = this.parents.query(".Campus")[0];
    if (frame = parent ? parent.node : this.node.parent, d) {
      if (options.path = d.concat(), s) {
        var a2 = [];
        var i = 0;
        for (; i < d.length; i++) {
          a2.push(this.localToWorld(d[i]));
        }
        d = a2;
      }
      if (1 === d.length) {
        d = [this.position, d[0]];
      }
    } else {
      var cachedDOMPosition = options.position;
      if (cachedDOMPosition) {
        d = cachedDOMPosition.isBaseObject ? [this.position, cachedDOMPosition.position] : [this.position, cachedDOMPosition];
      }
      if (d) {
        options.path = d.concat();
      }
    }
    if (d && 0 != d.length) {
      if (start) {
        DLF = null;
        start = Utils.parseVector3(start);
      }
      this.stopMoving();
      var out = [];
      i = 0;
      for (; i < d.length; i++) {
        var x = null;
        if (2 == d[i].length) {
          x = new THREE.Vector3(d[i][0], this.position[1], d[i][1]);
        } else {
          if (3 == d[i].length) {
            x = Utils.parseVector3(d[i]);
          }
        }
        out.push(x);
      }
      this.createPathTweens(frame, out, DLF, methods);
      var line = this.pathTweens[0].from;
      this.position = [line.x, line.y, line.z];
      var target = this;
      this.startPathTweens(fn, expectedPackagePath, duration, DLF, start, minifyOptionsForStylesheet, eYp4, matterToolsPath, function(a) {
        if (handler) {
          a.object = target;
          handler.call(target, a);
        }
      }, function() {
      }, function() {
      }, function() {
        if (val == isAddEffect0.Repeat) {
          target.movePath(options);
        } else {
          if (val == isAddEffect0.PingPong) {
            options.path.reverse();
            if (void 0 !== options.orientToPathDegree) {
              options.orientToPathDegree = 360 - options.orientToPathDegree;
            }
            target.movePath(options);
          } else {
            if (complete) {
              complete.call(target, {
                object : target
              });
            }
          }
        }
      });
    } else {
      THING.Utils.error("You must provide the path or position to call moveTo()");
    }
  }, self.prototype.stopMoving = function() {
    this.pathTweens = [];
    if (this.pathTween) {
      this.pathTween.stop();
    }
  }, self.prototype.hasAttribute = function(name) {
    return Utils.hasAttribute(this, name);
  }, self.prototype.getAttribute = function(name) {
    return Utils.getAttribute(this, name);
  }, self.prototype.setAttribute = function(name, value) {
    return Utils.setAttribute(this, name, value);
  }, self.prototype.setAttributes = function(options) {
    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    var name;
    for (name in options = options || {}) {
      if (t || Utils.isUndefined(this.getAttribute(name))) {
        this.setAttribute(name, options[name]);
      }
    }
  }, self.prototype._updateLookAt = function() {
    if (this._lookingAtObject) {
      if (this._lookingAtObject.target) {
        var p = this._lookingAtObject.target.position;
        this._lookingAtObject.targetLocalPosition = Utils.parseVector3(this.worldToLocal(p));
        this._lookingAtObject.targetPosition = Utils.parseVector3(p);
      }
      this._lookAtPosition();
    }
  }, self.prototype.selfUpdate = function() {
    var that = this;
    var name = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    var i = this;
    var changed = 0;
    if (this._style && this._style.update) {
      changed = changed | this._style.update(name);
    }
    if (this._localClippingPlanes.length) {
      this._localClippingPlanes.forEach(function(_ref9) {
        var props = _ref9.basePlane;
        var normalMatrix = zi.getNormalMatrix(that.node.matrixWorld);
        var vabp = Ui.copy(props.normal).multiplyScalar(-props.constant);
        var n = props.normal.clone().applyMatrix3(normalMatrix).normalize();
        var innerRadius = -vabp.dot(n);
        var a = _ref9.localPlane;
        a.normal = n;
        a.constant = innerRadius;
      });
      changed = true;
    }
    if (this._clippingPlanes.length && !this._clippingInWorldSpace) {
      this._clippingPlanes.forEach(function(scope) {
        var inv_matrix = scope.isLocal && that.node.parent ? that.node.parent.matrixWorld : that.node.matrixWorld;
        scope.worldPlane.copy(scope.inputPlane).applyMatrix4(inv_matrix);
      });
      changed = true;
    }
    if (this._lodNode) {
      if (-1 != this._lodLevel) {
        this._lodNode.setLevel(this._lodLevel);
      } else {
        this._lodNode.update(this.app.renderCamera);
      }
      changed = true;
    }
    if (this._lookingAtObject) {
      if (this.visible) {
        this._updateLookAt();
      }
      changed = true;
    }
    if (this._independentPosition) {
      if (this.visible) {
        this._getIndependentControlRenderNode()._setWorldPosition(this._independentPosition.clone(), this.static);
      }
      changed = true;
    }
    if (this._independentWorldAngles) {
      if (this.visible) {
        this._getIndependentControlRenderNode()._setWorldAngles(this._independentWorldAngles.clone(), this.static);
      }
      changed = true;
    }
    if (this._independentWorldScale) {
      if (this.visible) {
        this._getIndependentControlRenderNode()._setWorldScale(this._independentWorldScale.clone(), this.static);
      }
      changed = true;
    }
    var item = this.builder;
    if (item && item.startToBuildingQueue && item.startToBuildingQueue.length) {
      if (!(item._isBuilding || item._old_build_version == item._build_version)) {
        item._old_build_version = item._build_version;
        item._isBuilding = true;
        item.startToBuild(function(callOnProgress) {
          var result = item.startToBuildingQueue;
          var trlen = result.length;
          var i = 0;
          for (; i < trlen; i++) {
            if (!(result[i].version > item._build_version)) {
              var success = result[i].progressCallback;
              if (success) {
                success({
                  progress : callOnProgress
                });
              }
              if (1 == callOnProgress) {
                result.splice(i--, 1);
                trlen--;
              }
            }
          }
          if (1 == callOnProgress) {
            item._isBuilding = false;
            if (item.campus.static) {
              item.campus.node._synMatrixWorld();
            }
          } else {
            i.tickable = true;
          }
        });
      }
      changed = true;
    }
    var ukeys = this._eventTrigger.getEventListeners("update", this);
    return ukeys.forEach(function(actualEvent) {
      that._eventTrigger.invokeListener(actualEvent, {
        deltaTime : name
      });
      changed = true;
    }), changed;
  }, self.prototype.update = function(type) {
    var t = this.selfUpdate(type);
    var index = 0;
    for (; index < this._controls.length; index++) {
      var control = this._controls[index].control;
      var helper = control.onUpdate;
      if (helper) {
        t = t | helper.call(control, type);
      }
    }
    return t;
  }, self.prototype.createGrid = function(height, color, container, target) {
    this._grid = this.app.create({
      type : "Grid",
      size : height,
      divisions : color,
      color1 : container,
      color2 : target,
      parent : this
    });
    this._grid.style.skipBoundingBox = true;
    this._grid.userData.topNode = true;
    this._grid.userData.skipOutline = true;
    this._grid.userData.independent = true;
    this._grid.canNotQueryFromSelector = true;
    this._grid.translateY(-.01);
  }, self.prototype.showGrid = function(data, row, i, options) {
    var part = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
    if (Utils.isBoolean(data)) {
      var state = data;
      if (state) {
        if (!this._grid) {
          this.createGrid(300, 28, 1131673, 1131673);
        }
      }
      if (this._grid) {
        this._grid.visible = state;
      }
    } else {
      if (this._grid && (this._grid.destroy(), this._grid = null), this.createGrid(data, row, i, options), part) {
        var d = data;
        if (Utils.isNumber(part)) {
          d = part;
        }
        this._grid.addPickableGround({
          size : d
        });
      }
    }
  }, self.prototype.stopFade = function() {
    if (this.fadeTween) {
      this.fadeTween.stop();
      this.fadeTween = null;
    }
  }, self.prototype.fade = function(e, opacity) {
    var time = (e = e || {}).time || 1e3;
    var cb = e.complete;
    this.stopFade();
    var start = {
      opacity : this.style.opacity
    };
    var target = {
      opacity : opacity
    };
    this.visible = true;
    var element = this;
    this.fadeTween = (new TWEEN.Tween(start)).to(target, time).easing(TWEEN.Easing.Linear.None).onUpdate(function() {
      element.style.opacity = this._object.opacity;
    }).onComplete(function() {
      if (0 == element.style.opacity) {
        element.visible = false;
      }
      if (cb) {
        cb.call(element, {
          object : element
        });
      }
    }).start();
  }, self.prototype.fadeIn = function(elements) {
    this.style.opacity = 0;
    this.fade(elements, 1);
  }, self.prototype.fadeOut = function(fn) {
    this.style.opacity = 1;
    this.fade(fn, 0);
  }, self.prototype.setClippingPlanes = function() {
    var modVSelf = this;
    var val = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (Utils.isObject(val)) {
      val = [val];
    }
    this.clearClippingPlanes();
    val.forEach(function(file) {
      var w = file.height;
      var texture = Utils.parseVector3(file.direction, new THREE.Vector3(0, -1, 0));
      var bunny = new THREE.Plane(texture, w);
      var o = bunny.clone();
      modVSelf._localClippingPlanes.push({
        basePlane : bunny,
        localPlane : o
      });
    });
    var swimlaneToCheck = this;
    this.node.traverse(function(child) {
      if (child.isMesh) {
        child._clip_prev_material = child.material;
        child.material = child.material.clone();
        child.material.clippingPlanes = swimlaneToCheck._localClippingPlanes.map(function(canCreateDiscussions) {
          return canCreateDiscussions.localPlane;
        });
      }
    });
    this.tickable = true;
  }, self.prototype.clearClippingPlanes = function() {
    this.node.traverse(function(child) {
      if (child.isMesh && child._clip_prev_material) {
        child.material = child._clip_prev_material;
        child.material.clippingPlanes = null;
      }
    });
    this._localClippingPlanes = [];
  }, self.prototype.setClipping = function(x) {
    var a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : L.Self;
    if (Utils.isObject(x)) {
      x = [x];
    }
    this.clearClipping();
    var track = this._clippingPlanes;
    var useLocalIdentifierAsKey = a === L.World;
    var isLocal = a === L.Local;
    x.forEach(function(current) {
      var d = new THREE.Plane;
      d.normal = Utils.parseVector3(current.direction, new THREE.Vector3(0, -1, 0));
      d.constant = current.height;
      var r = d.clone();
      track.push({
        inputPlane : d,
        worldPlane : r,
        isLocal : isLocal
      });
    });
    this.node.traverse(function(child) {
      if (child.isMesh) {
        child._clip_prev_material = child.material;
        child.material = child.material.clone();
        child.material.clippingPlanes = track.map(function(provider) {
          return useLocalIdentifierAsKey ? provider.inputPlane : provider.worldPlane;
        });
      }
    });
    this._clippingInWorldSpace = useLocalIdentifierAsKey;
    this.tickable = !useLocalIdentifierAsKey;
  }, self.prototype.clearClipping = function() {
    this.node.traverse(function(child) {
      if (child.isMesh && child._clip_prev_material) {
        child.material = child._clip_prev_material;
        child.material.clippingPlanes = null;
      }
    });
    this._clippingPlanes = [];
  }, self.prototype.toJSON = function() {
    return {
      type : this.type,
      id : this.id,
      name : this.name,
      position : this.position,
      angles : this.angles,
      scale : this.scale,
      style : {
        color : this.style.color,
        opacity : this.style.opacity,
        outlineColor : this.style.outlineColor,
        alwaysOnTop : this.style.alwaysOnTop,
        glow : this.style.glow,
        innerGlow : this.style.innerGlow,
        renderOrder : this.style.renderOrder
      }
    };
  }, self.prototype.addControl = function(model, type, name) {
    if (model) {
      if (Utils.isString(type) && (name = name || type, type = {}, this.removeControl(name)), !Utils.isNumber(model)) {
        if (this.hasControl(model)) {
          return THING.Utils.error("The control is existing when addControl() with '" + model + "'"), null;
        }
        this._controls.push({
          control : model,
          name : name
        });
        var context = model.onAdd;
        return Utils.isFunction(context) && context.call(model, this), this.tickable = true, this.visible && (this.app.needUpdate = true), model;
      }
      var resources = [];
      var i = 0;
      for (; i < resources.length; i++) {
        var loader = resources[i];
        if (loader.id == model) {
          var c = new loader.type(this);
          return c.setup(type), this.addControl(c);
        }
      }
      return null;
    }
  }, self.prototype.getControl = function(name) {
    var index = 0;
    for (; index < this._controls.length; index++) {
      if (name == this._controls[index].name) {
        return this._controls[index].control;
      }
    }
    return null;
  }, self.prototype.removeControl = function(name) {
    if (name) {
      var _added = false;
      if (Utils.isString(name)) {
        var index = 0;
        for (; index < this._controls.length; index++) {
          if (this._controls[index].name == name) {
            if (onRemove = (tagtype = this._controls[index].control).onRemove) {
              onRemove.call(tagtype);
            }
            this._controls.splice(index, 1);
            _added = true;
            break;
          }
        }
      } else {
        index = 0;
        for (; index < this._controls.length; index++) {
          if (this._controls[index].control == name) {
            var tagtype;
            var onRemove;
            if (onRemove = (tagtype = this._controls[index].control).onRemove) {
              onRemove.call(tagtype);
            }
            this._controls.splice(index, 1);
            _added = true;
            break;
          }
        }
      }
      if (_added && this.visible) {
        this.app.needUpdate = true;
      }
    }
  }, self.prototype.removeAllControls = function() {
    var _added = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    var index = 0;
    for (; index < this._controls.length; index++) {
      var control = this._controls[index].control;
      var helper = control.onRemove;
      if (helper) {
        helper.call(control);
      }
    }
    this._controls = [];
    if (_added && this.visible) {
      this.app.needUpdate = true;
    }
  }, self.prototype.hasControl = function(name) {
    if (Utils.isString(name)) {
      var index = 0;
      for (; index < this._controls.length; index++) {
        if (name == this._controls[index].name) {
          return true;
        }
      }
    } else {
      if (-1 !== this._controls.indexOf(name)) {
        return true;
      }
    }
    return false;
  }, self.prototype.setWorldPosition = function(x) {
    var localPoint = Utils.parseVector3(x);
    this.node._setWorldPosition(localPoint, this.static);
    this.dirty = true;
  }, self.prototype.setWorldAngles = function(array) {
    var length = Utils.parseQuaternion(array);
    this.node._setWorldAngles(length, this.static);
    this.dirty = true;
  }, self.prototype.setWorldScale = function(index) {
    var contact = Utils.parseVector3(index);
    this.node._setWorldScale(contact, this.static);
    this.dirty = true;
  }, self.prototype.setLocalPosition = function(x) {
    var val = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    var num = Utils.parseVector3(x);
    var kinks = Utils.parseValue(val, this._ignoreParentScale);
    if (kinks) {
      var parent = this.node.parent;
      if (parent) {
        var index = new THREE.Vector3;
        this.node.updateWorldMatrix(true, false);
        parent.getWorldScale(index);
        num.divide(index);
      }
    }
    this.localPosition = num.toArray();
  }, self.prototype.getLocalPosition = function() {
    var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    var t = this.node.position.clone();
    if (e) {
      var target = new THREE.Vector3;
      this.node.updateMatrixWorld();
      this.node.getWorldScale(target);
      t.multiply(target);
    }
    return t.toArray();
  }, self.prototype._setScale = function(pred) {
    var v = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "default";
    var obj = Utils.parseVector3(pred);
    if (0 == obj.x) {
      THING.Utils.error("Please check scale-x value, it can not be zero");
      obj.x = Number.EPSILON;
    }
    if (0 == obj.y) {
      THING.Utils.error("Please check scale-y value, it can not be zero");
      obj.y = Number.EPSILON;
    }
    if (0 == obj.z) {
      THING.Utils.error("Please check scale-z value, it can not be zero");
      obj.z = Number.EPSILON;
    }
    Hi.set(1, 1, 1);
    this._scaleGroupStates.enable(obj, v);
    this._scaleGroupStates.states.forEach(function(b) {
      var f = b.value;
      Hi.multiply(f);
    });
    var startIndicator = this._getIndependentControlRenderNode();
    if (this.anchorNode) {
      startIndicator = this.anchorNode;
    }
    startIndicator.scale.copy(Hi);
    this.synIndependentWorldScale();
    if (this.static) {
      this.node._synMatrixWorld();
    }
    this.dirty = true;
  }, self.prototype._getScale = function(val) {
    if (val) {
      var t = this._scaleGroupStates.getValue(val);
      return t ? t.toArray() : [1, 1, 1];
    }
    var uv = this._getIndependentControlRenderNode();
    return this.anchorNode && (uv = this.anchorNode), uv.scale.toArray();
  }, self.prototype._synWorldAngles = function() {
    this.dirty = true;
    this.synIndependentWorldAngles();
    if (this.static) {
      this.node._synMatrixWorld();
    }
  }, self.prototype._getAttributeFromSelfToRoot = function(player) {
    var obj = this;
    for (; obj; obj = obj.parent) {
      var playerloc = obj.node.userData[player];
      if (playerloc) {
        return playerloc;
      }
    }
    return null;
  }, self.prototype._getBaseMatrix = function() {
    return this._getAttributeFromSelfToRoot("_baseMatrix");
  }, self.prototype._getPosition = function() {
    var elem = new THREE.Vector3;
    return this.node.getWorldPosition(elem), elem.toArray();
  }, self.prototype._setPosition = function(position) {
    if (position) {
      this.setWorldPosition(position);
      this.synIndependentWorldPosition();
    }
  }, self.prototype._needUseWorldPosition = function() {
    var parent = this._parent;
    return !!parent && parent.node != this.node.parent;
  }, self.prototype._setLocalPosition = function(index) {
    if (this.anchorNode) {
      var start = Utils.parseVector3(this.parent.selfToWorld(index));
      this.node._setWorldPosition(start, this.static);
    } else {
      if (this._needUseWorldPosition()) {
        var start = Utils.parseVector3(this._parent.selfToWorld(index));
        this.node._setWorldPosition(start, this.static);
      } else {
        var r = Utils.parseVector3(index);
        this.node.position.copy(r);
        if (this.static) {
          this.node._synMatrixWorld();
        }
      }
    }
    this._setDirtyFlag(false, true, true);
    var intersection__3365 = this._notifyPositionChange;
    if (intersection__3365) {
      intersection__3365.call(this);
    }
  }, self.prototype._getLocalPosition = function() {
    if (!this._parent) {
      return [0, 0, 0];
    }
    if (this.anchorNode) {
      return this._parent.worldToSelf(this.position);
    }
    if (this._needUseWorldPosition()) {
      var v = new THREE.Vector3;
      return this.node.getWorldPosition(v), this._parent.node.worldToLocal(v), v.toArray();
    }
    return (v = this.node.position).toArray();
  }, self.prototype._getAngles = function() {
    var scene = this.node.parent;
    if (scene && scene.userData.childUseWorldAnglesAlways) {
      return this.worldAngles;
    }
    return this.anchorNode ? this.anchorNode.getAngles() : this.node.getAngles();
  }, self.prototype._setAngles = function(result) {
    if (!THING.Math.equalsVector(this.angles, result)) {
      var _node = this.node;
      if (this.anchorNode) {
        _node = this.anchorNode;
      }
      _node.setAngles(result);
      this._synWorldAngles();
    }
  }, self.prototype._getQuaternion = function() {
    var scene = this.node.parent;
    if (scene && scene.userData.childUseWorldAnglesAlways) {
      return this.worldQuaternion;
    }
    return this.anchorNode ? this.anchorNode.quaternion.toArray() : this.node.quaternion.toArray();
  }, self.prototype._setQuaternion = function(val) {
    if (val.isQuaternion && (val = val.toArray()), !THING.Math.equalsVectorX(this.node.quaternion.toArray(), val)) {
      var node = this.node;
      if (this.anchorNode) {
        node = this.anchorNode;
      }
      node.quaternion.fromArray(val);
      this._synWorldAngles();
    }
  }, self.prototype.setAnchorPosition = function(point) {
    if (point) {
      var a = this.anchorNode;
      if (a) {
        a.children[0].getWorldPosition(Ni);
        Fi.fromArray(point);
        a._setWorldPosition(Fi, false, this.static);
        a.updateWorldMatrix(false, false);
        a.children[0]._setWorldPosition(Ni, this.static);
      } else {
        a = new THREE.Object3D;
        this.node.parent.add(a);
        Fi.fromArray(point);
        a._setWorldPosition(Fi, this.static);
        a.updateWorldMatrix(false, false);
        a.attach(this.node);
        this.anchorNode = a;
      }
    } else {
      if (this.anchorNode) {
        this.anchorNode.parent.attach(this.anchorNode.children[0]);
        this.anchorNode.removeBySelf();
        this.anchorNode = null;
      }
    }
  }, self.prototype.getAnchorPosition = function() {
    var a = this.anchorNode;
    return a ? (a.getWorldPosition(Ni), this.worldToSelf(Ni.toArray())) : null;
  }, self.prototype.getBoundingBox = function() {
    var selection = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    var transform = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return this.boundingBoxControl.getBoundingBox(selection, transform);
  }, self.prototype.getOrientedBox = function() {
    var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    var artistTrack = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return this.boundingBoxControl.getOrientedBoundingBox(e, artistTrack);
  }, self.prototype.getLocalBoundingBox = function() {
    var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    var artistTrack = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return this.boundingBoxControl.getLocalBoundingBox(e, artistTrack);
  }, self.prototype._setBoundingBoxPivot = function(canCreateDiscussions) {
    this.node.userData.boundingBoxPivot = canCreateDiscussions;
    this.dirty = true;
  }, self.prototype._getBoundingBoxPivot = function() {
    var e = this.node.userData.boundingBoxPivot;
    return e || null;
  }, self.prototype._setBoundingBoxSize = function(solData) {
    if (solData) {
      if (isNaN(solData[0])) {
        THING.Utils.error("_setBoundingBoxSize() failed, value[0] is NaN", this);
      }
      if (isNaN(solData[1])) {
        THING.Utils.error("_setBoundingBoxSize() failed, value[1] is NaN", this);
      }
      if (isNaN(solData[2])) {
        THING.Utils.error("_setBoundingBoxSize() failed, value[2] is NaN", this);
      }
    }
    this.node.userData.boundingBoxSize = solData;
    this.dirty = true;
  }, self.prototype._getBoundingBoxSize = function() {
    var e = this.node.userData.boundingBoxSize;
    return e || null;
  }, self.prototype._updateKeepSize = function(boundsMethod, weuiActionsheet, mask, regexMask) {
    return this._keepSize != boundsMethod && (this._keepSize = boundsMethod, boundsMethod ? (regexMask = regexMask || this.distanceTo(this.app.camera.position), mask = mask || this.scale, this.addControl(new Ai(mask, weuiActionsheet, regexMask), "SizeAdjustmentControl")) : this.removeControl("SizeAdjustmentControl"), true);
  }, self.prototype.getOffsetPosition = function(options) {
    if (options = options || {}, !Utils.isNull(options.xAngle) || !Utils.isNull(options.yAngle)) {
      var newColumnNames = Utils.parseValue(options.yAngle, 0);
      var main = Utils.parseValue(options.xAngle, 0);
      var rx = Utils.parseValue(options.distance, options.radius);
      if (void 0 === rx) {
        var y = Utils.parseValue(options.onlyVisible, true);
        rx = this.boundingBoxControl.getBoundingBox(y).radius;
      }
      var factor = options.radiusFactor;
      return factor && (rx = rx * factor), (new THREE.Vector3).getDirectionFromAngles(newColumnNames, main, rx).toArray();
    }
    if (options.direction) {
      var k = Utils.parseVector3(options.direction);
      var b = options.distance || options.radius;
      k.multiplyScalar(b);
      var v = Utils.parseVector3(this.position);
      return v.add(k), this.worldToSelf(v.toArray());
    }
  }, self.prototype.getWorldPosition = function(text) {
    var eYp4 = this.getOffsetPosition(text) || [0, 0, 0];
    return this.selfToWorld(eYp4);
  }, self.prototype.getLayoutPosition = function(users, id) {
    var mandatoryOnly = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    var rep = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    var transform = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    if (!Utils.isArray(users)) {
      return null;
    }
    if (3 !== users.length) {
      return null;
    }
    var o = mandatoryOnly ? this.getOrientedBox(rep, transform) : this.getBoundingBox(rep, transform);
    var p = o.points;
    var newNodeLists = [];
    if (mandatoryOnly) {
      var i = 0;
      for (; i < p.length; i++) {
        newNodeLists.push(this.worldToSelf(p[i]));
      }
    } else {
      newNodeLists = p.concat();
    }
    var value = [[newNodeLists[0], newNodeLists[1]], [newNodeLists[0], newNodeLists[4]], [newNodeLists[0], newNodeLists[2]]];
    var update = function(files, win) {
      var top = 0;
      if (Utils.isString(win)) {
        if (win.equals("left", true) || win.equals("bottom", true) || win.equals("back", true)) {
          top = 0;
        } else {
          if (win.equals("right", true) || win.equals("top", true) || win.equals("front", true)) {
            top = 1;
          } else {
            if (win.equals("center", true)) {
              top = .5;
            }
          }
        }
      } else {
        if (Utils.isNumber(win)) {
          top = win;
        } else {
          THING.Utils.error("get layout position failed, due to unknown layout type(" + win + ")");
        }
      }
      var Point = Utils.parseVector3(files[0]);
      var right = Utils.parseVector3(files[1]);
      return Point.lerp(right, top), Point;
    };
    var a1 = update(value[0], users[0]).x;
    var a2 = update(value[1], users[1]).y;
    var c1 = update(value[2], users[2]).z;
    var target = [a1, a2, c1];
    if (mandatoryOnly || (target = this.worldToSelf(target)), id) {
      var step = this.worldToSelf(id);
      target = THING.Math.subVector(step, target);
    }
    return target = this.selfToWorld(target);
  }, self.prototype._setStyle = function(value) {
    this._style = value;
  }, self.prototype._getStyle = function() {
    return this._style || (this._style = this.app.styleManager.createStyle("Default", this), this._defaultStyle = this._style), this._style;
  }, self.prototype.applyTheme = function(name) {
    var event = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    var before = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    this.style._inheritThemeName = name || null;
    if (event) {
      this.children.forEach(function(me) {
        if (me.inheritTheme) {
          me.applyTheme(name, true, before);
        }
      });
    }
    if (!(this.userData.SKIP_THEME || "Facade" == this.type && this.building && this.building.userData.SKIP_THEME)) {
      if ("CombinedObject" === this.type) {
        if (this.loaded) {
          this._parent.applyTheme(name, event, true);
        } else {
          this.waitCommands.push({
            type : "ApplyObjectTheme",
            object : this._parent,
            params : {
              name : name,
              traverse : event,
              force : true
            }
          });
        }
      } else {
        if (this.loaded) {
          if (this.style._applyTheme) {
            this.style._applyTheme(name, before);
          }
        } else {
          this.waitCommands.push({
            type : "ApplyObjectTheme",
            object : this,
            params : {
              name : name,
              traverse : false,
              force : before
            }
          });
        }
      }
    }
  }, self.prototype._getChildVisibles = function() {
    var _results = [];
    return this.children.forEach(function(elem) {
      _results.push(elem.visible);
    }), _results;
  }, self.prototype._onGetChild = function() {
    return this.children;
  }, self.prototype._setChildVisible = function(e, t) {
    var method = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "default";
    var params = this._onGetChild();
    var i = 0;
    for (; i < params.length; i++) {
      var that = params[i];
      if (that) {
        if (that.inheritVisible) {
          that._setVisible(e, method);
        } else {
          var name = t[i];
          var states = that._visibleGroupStates.states;
          var index = 0;
          for (; index < states.length; index++) {
            var item = states[index];
            if (item.value == name) {
              that._setVisible(name, item.name);
              break;
            }
          }
        }
      }
    }
  }, self.prototype._setNodeVisible = function(index) {
    var module = this;
    this._traverseSelfNodes(function(args) {
      if (!args.userData.asBoundingBox) {
        args.ensureVisible(index, module._autoSynVisible);
      }
    });
  }, self.prototype._getHidePermission = function() {
    var section = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "default";
    var custom_filters_arr = this._visibleGroupStates.states;
    var i = 0;
    for (; i < custom_filters_arr.length; i++) {
      var entry = custom_filters_arr[i];
      if (entry.name != section && entry.value) {
        return false;
      }
    }
    return true;
  }, self.prototype.setVisible = function(visible) {
    var enabled = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    this.renderNode.visible = visible;
    this.renderNode.ensureVisible(visible, this._autoSynVisible);
    if (enabled) {
      this.children.forEach(function(button) {
        button.setVisible(visible, enabled);
      });
    }
  }, self.prototype._setVisible = function(el) {
    var v = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "default";
    if (!this._hideNodesInScene) {
      this._visibleGroupStates.enable(el, v);
      var hidden = this._visibleGroupStates.isAnyEnable();
      if (THING.disableVisibleGroupStates) {
        hidden = this._visibleGroupStates.has("default") ? this._visibleGroupStates.isEnable("default") : this.visible;
      }
      var visible = this.visible;
      var intersection__3365 = this._notifyBeforeChangeVisible;
      if (intersection__3365) {
        intersection__3365.call(this);
      }
      var nameArgs = this._getChildVisibles();
      if (hidden && this._autoEnsureParentsVisible) {
        this.node.ensureParentsVisible(hidden);
      }
      this._setNodeVisible(hidden);
      this._setChildVisible(el, nameArgs, v);
      var index = 0;
      for (; index < this._controls.length; index++) {
        var settings = this._controls[index].control;
        if (Utils.isFunction(settings.onVisible)) {
          settings.onVisible(hidden);
        }
      }
      var difference__3373 = this._notifyAfterChangeVisible;
      if (difference__3373) {
        difference__3373.call(this);
      }
      if (visible != hidden) {
        this.dirty = true;
      }
    }
  }, self.prototype._getVisible = function() {
    return !this._hideNodesInScene && (!!this.node.visible && this.node.getLayerVisible());
  }, self.prototype._getChildrenSelector = function() {
    var slice = new xi(this.app, this.children);
    return slice.buildReturnObject(this.children), slice;
  }, self.prototype._getChildren = function() {
    return this._children.result;
  }, self.prototype._getBrothers = function() {
    var e = this;
    var value = void 0;
    var parent = this._parent;
    value = parent ? parent._children.filter(function(i) {
      return i !== e && !i.isCombinedObject;
    }) : [];
    var result = new xi(this.app, value);
    return result.buildReturnObject(value), result;
  }, self.prototype._getParents = function() {
    var value = [];
    var layout = this._parent;
    for (; layout; layout = layout.parent) {
      if (!layout.isCombinedObject) {
        value.push(layout);
      }
    }
    var result = new xi(this.app, value, true);
    return result.buildReturnObject(value), result;
  }, self.prototype.indexOfParent = function() {
    var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
    var parent = this._parent;
    if (!parent) {
      return -1;
    }
    var j = this._parent._children.indexOf(this);
    if (-1 === j) {
      return -1;
    }
    if (e) {
      j = 0;
      var children = this._parent._children;
      var i = 0;
      for (; i < children.length; i++) {
        var c = children[i];
        if (c == this) {
          return j;
        }
        if (c.type == this.type) {
          j++;
        }
      }
    }
    return j;
  }, self.prototype._loadResource = function(callback) {
    if (callback) {
      this._children.forEach(function(srUtils) {
        srUtils.loadResource(true);
      });
    }
  }, self.prototype._unloadResource = function(a22) {
    if (a22) {
      this._children.forEach(function(resMgr) {
        resMgr.unloadResource();
      });
    }
  }, self.prototype._notifyLoadingObjects = function() {
    var TrackSearchIndex = this.parents.query(".Campus")[0];
    if (TrackSearchIndex) {
      TrackSearchIndex._loadingObjects.add(this);
    }
  }, self.prototype._loadSelfResource = function(callback) {
    if (!this.loaded && !this.loading) {
      this.loading = true;
      var that = this;
      if (this._dynamic) {
        this.loadFromURL(this.param, function() {
          that.customSetup(that.param);
          that.node.updateMatrixWorld();
          that.loaded = true;
          that.loading = false;
          if ("function" == typeof callback) {
            callback({
              object : that
            });
          }
        });
      } else {
        var extensions = this.builder;
        if (!extensions || !extensions.requestToBuild) {
          return;
        }
        extensions.requestToBuild(this.uuid);
      }
    }
  }, self.prototype.loadResource = function() {
    var b = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    var c = arguments[1];
    if (c && (b ? this._loadCompleteCallback.push(c) : this._selfLoadCompleteCallback.push(c)), !this._dynamic) {
      var metaClassClass = this.builder;
      if (!metaClassClass || !metaClassClass.requestToBuild) {
        return;
      }
    }
    this._loadResource(b);
    this._notifyLoadingObjects();
    this._loadSelfResource(c);
    if (this.loaded) {
      this.dataToRecover = this.toJSON();
    }
  }, self.prototype.unloadResource = function() {
    var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    this._unloadResource(e);
    if (this._boxNode) {
      this._boxNode.removeBySelf();
    }
    var t = [];
    var $ = this;
    this._traverseSelfNodes(function(e) {
      if ($.app.resourceManager.unload(e, false, false, false, false), e._skipDispose) {
        t.push(e);
      } else {
        if (e.material) {
          e.disposeMaterial();
          t.push(e);
        }
      }
    });
    t.forEach(function(e) {
      $.app.picker.removePickingResources(e);
      e.removeBySelf();
    });
    var cookie = this.builder;
    if (cookie && cookie.disposeObject) {
      cookie.disposeObject(this.uuid);
    }
    if (this._boxNode) {
      this.node.add(this._boxNode);
    }
    this.loaded = false;
  }, self.prototype.setBoxNode = function(obj) {
    obj.userData.asBoundingBox = true;
    obj.userData.skipStyle = true;
    obj.userData.useToCaculateBoundingBox = true;
    this._boxNode = obj;
    this.node.add(obj);
  }, self.prototype.startToBuild = function(playlist) {
    var $scope = this.builder;
    if ($scope && Utils.isFunction($scope.startToBuild)) {
      $scope._old_build_version = $scope._build_version;
      $scope._build_version = $scope._build_version || 1;
      $scope._build_version++;
      $scope.startToBuildingQueue = $scope.startToBuildingQueue || [];
      $scope.startToBuildingQueue.push({
        version : $scope._build_version,
        progressCallback : playlist
      });
      this.tickable = true;
    }
  }, self.prototype.clearNode = function(obj) {
    if (this._url) {
      this.app.modelResource.unload(this._url);
      this._url = null;
    }
    this.removePickingResources();
    this.app.resourceManager.remove(this.node, obj);
  }, self.prototype.cloneSelf = function(key) {
    return this.app.create(key);
  }, self.prototype.clone = function(element, parent) {
    var dataNode = this;
    var param = this.node.cloneByFilter(function(parent) {
      var i = 0;
      for (; i < dataNode._children.length; i++) {
        var node = dataNode._children[i].node;
        if (parent == node || parent.isChildOf(node)) {
          return false;
        }
      }
      return true;
    });
    param.traverse(function(data) {
      data.userData = {};
    });
    var data = {
      type : this.type,
      url : this.url,
      position : this.position,
      angles : this.angles,
      scale : this.scale,
      visible : this.visible,
      parent : parent || this._parent,
      node : param
    };
    var c = this.cloneSelf(data);
    if (!c) {
      return null;
    }
    if (element) {
      var i = 0;
      for (; i < this._children.length; i++) {
        this._children[i].clone(element, c);
      }
    }
    return c;
  }, self.prototype.getEnvMapResources = function() {
    var entry = this.parent;
    for (; entry; entry = entry.parent) {
      var scoid = entry.envMapResources;
      if (scoid) {
        return scoid;
      }
    }
    return null;
  }, self.prototype._synEffectRefCounts = function() {
    var helpers = this.app.effectManager;
    if (helpers) {
      this.node.traverse(function(P) {
        helpers.synEffect(P);
      });
    }
  }, self.prototype._processBillboard = function(ch, a) {
    var ToolClass = this;
    ch.setUserDataValue("skipOutline", true);
    a.billboard = true;
    ch._lookAt(a, function() {
      return ToolClass.static;
    });
  }, self.prototype._processModel = function() {
    var port = this;
    var nodeView = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
    var borderStyle = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    var components_path = this.app.isMobileDevice;
    var data = this._useShadow && !components_path;
    var keyboard = this.app.effectManager;
    borderStyle = borderStyle && !!keyboard;
    this.node.traverse(function(obj) {
      var that = obj.userData.gltfExtensions;
      if (that && that.billboard) {
        that.billboard.axis = "y";
        port._processBillboard(obj, that.billboard);
        delete that.billboard;
      }
      var node = obj.material;
      if (nodeView && node && !obj.__effectInited) {
        obj.__effectInited = true;
        if (Array.isArray(node)) {
          node.forEach(function(dt) {
            return dt.needsUpdate = true;
          });
        } else {
          node.needsUpdate = true;
        }
        if (obj.isMesh && !obj.isSky) {
          obj.castShadow = data;
          obj.receiveShadow = data;
        }
        if (node.map) {
          node.map.anisotropy = components_path ? 1 : 16;
          if (node.map.version > 0) {
            node.map.needsUpdate = true;
          }
        }
      }
      if (borderStyle) {
        keyboard.synEffect(obj);
      }
    });
  }, self.prototype.synIndependentWorldPosition = function() {
    if (this._independentControlFlags.has(earthColor0.Position)) {
      var v = new THREE.Vector3;
      this._getIndependentControlRenderNode().getWorldPosition(v);
      this._independentPosition = v;
    }
    var intersection__3365 = this._notifyPositionChange;
    if (intersection__3365) {
      intersection__3365.call(this);
    }
  }, self.prototype.synIndependentWorldAngles = function() {
    if (this._independentControlFlags.has(earthColor0.Rotation)) {
      var e = this._getIndependentControlRenderNode().quaternion.clone();
      this._independentWorldAngles = e;
    }
    var intersection__3365 = this._notifyAnglesChange;
    if (intersection__3365) {
      intersection__3365.call(this);
    }
  }, self.prototype.synIndependentWorldScale = function() {
    var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    var value = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    var m = this._independentControlFlags;
    if (!(value = Utils.parseValue(this.inheritScale, value)) || m.has(earthColor0.Scale)) {
      var num = this._getIndependentControlRenderNode()._getWorldScale();
      var parent = this.node.parent;
      if (parent) {
        var twopow8 = parent._getWorldScale();
        num.divide(twopow8);
      }
      if (this._independentWorldScale) {
        this._independentWorldScale.copy(num);
      } else {
        this._independentWorldScale = num;
      }
      if (e) {
        this.dirty = true;
      }
    }
    var intersection__3365 = this._notifyScalesChange;
    if (intersection__3365) {
      intersection__3365.call(this);
    }
  }, self.prototype.synIndependentTransform = function() {
    var context = this._independentControlFlags;
    if (context.has(earthColor0.Position)) {
      this.synIndependentWorldPosition();
    }
    if (context.has(earthColor0.Rotation)) {
      this.synIndependentWorldAngles();
    }
    if (context.has(earthColor0.Scale)) {
      this.synIndependentWorldScale();
    }
  }, self.prototype._getIndependentControlRenderNode = function() {
    return this.node;
  }, self.prototype._useIndependentTransform = function(object) {
    var bone = this._getIndependentControlRenderNode();
    object.updateWorldMatrix(true);
    var matrix = object.matrixWorld;
    var pos = new THREE.Vector3;
    var scale = new THREE.Vector3;
    var quaternion = new THREE.Quaternion;
    matrix.decompose(pos, quaternion, scale);
    var inverseMatrix = new THREE.Matrix4;
    inverseMatrix.getInverse(bone.matrixWorld);
    var m = new THREE.Matrix4;
    if (m.premultiply(inverseMatrix), m.multiply(matrix), bone.updateWorldMatrix(true), this._independentPosition ? pos = this._independentPosition.clone() : pos.setFromMatrixPosition(bone.matrixWorld), this._independentWorldAngles) {
      if (quaternion = this._independentWorldAngles.clone(), !this._independentPosition) {
        var start = this.parent.node;
        var mat4 = this.parent.node.getMatrixWorldFromRoot(start.parent);
        var matrix = new THREE.Matrix4;
        if (!this._independentWorldScale) {
          matrix.compose(new THREE.Vector3, new THREE.Quaternion, start.scale);
          mat4.multiply(matrix);
        }
        mat4.multiply(bone.matrix);
        var t = new THREE.Vector3;
        var scale = new THREE.Vector3;
        var quaternion = new THREE.Quaternion;
        mat4.decompose(t, quaternion, scale);
        pos = t;
      }
    } else {
      bone.matrixWorld.decompose(Fi, quaternion, Li);
    }
    if (this._independentWorldScale) {
      scale = this._independentWorldScale.clone();
    } else {
      bone.matrixWorld.decompose(Fi, Ii, scale);
    }
    var transform = new THREE.Matrix4;
    transform.compose(pos, quaternion, scale);
    matrix.multiplyMatrices(transform, m);
  }, self.prototype._useIndependentRaycast = function(isSlidingUp) {
    var object = this._getIndependentControlRenderNode();
    if (object) {
      if (isSlidingUp) {
        object.userData.original_raycast = object.userData.original_raycast || object.raycast;
        var changedRadioControls = this;
        object.raycast = function(e, intersects) {
          var values = changedRadioControls._getIndependentControlRenderNode();
          return values && changedRadioControls._useIndependentTransform(values), this.userData.original_raycast.call(this, e, intersects);
        };
      } else {
        if (object.userData.original_raycast) {
          object.raycast = object.userData.original_raycast;
          delete object.userData.original_raycast;
        }
      }
    }
  }, self.prototype._enableIndependentControl = function() {
    var e = this;
    this._traverseSelfNodes(function(canCreateDiscussions) {
      canCreateDiscussions.removeBeforeRenderFunction("independentControlRender", false);
    });
    var clojIsReversed = false;
    var context = this._independentControlFlags;
    if (context.has(earthColor0.Transform)) {
      this.node.traverse(function(m) {
        Utils.backupValue(m, "frustumCulled");
        m.frustumCulled = false;
      });
      this.synIndependentTransform();
      this.tickable = true;
      var r = this._getIndependentControlRenderNode();
      if (!r.hasBeforeRenderFunction("independentControlRender")) {
        e = this;
        r.addBeforeRenderFunction("independentControlRender", function(canCreateDiscussions, i, isSlidingUp) {
          e._useIndependentTransform(this);
        }, 0);
      }
      clojIsReversed = true;
    } else {
      this.node.traverse(function(e) {
        Utils.revertValue(e, "frustumCulled");
      });
    }
    return context.has(earthColor0.Position) || (this._independentPosition = null), context.has(earthColor0.Rotation) || (this._independentWorldAngles = null), context.has(earthColor0.Scale) || (this._independentWorldScale = null), this._useIndependentRaycast(clojIsReversed), clojIsReversed;
  }, self.prototype.enableIndependentControl = function(s, v) {
    if (this._independentControlFlags.enable(s, v)) {
      return this._enableIndependentControl();
    }
  }, self.prototype.stopAllLerpTo = function() {
    var i = 0;
    for (; i < this._tweens.length; i++) {
      this._tweens[i].tween.stop();
    }
    this._tweens = [];
  }, self.prototype.stopLerpTo = function(val) {
    var i = 0;
    for (; i < this._tweens.length; i++) {
      if (val == this._tweens[i].name) {
        this._tweens[i].tween.stop();
        this._tweens.splice(i--, 1);
      }
    }
  }, self.prototype.lerpTo = function(options, text) {
    var capture = function(item) {
      var result = {};
      var a = Object.keys(item);
      var j = 0;
      for (; j < a.length; j++) {
        var i = a[j];
        var v = item[i];
        if (Utils.isArray(v)) {
          if (3 == v.length) {
            if (t_array = Utils.parseVector3(v)) {
              v = t_array;
              result["__" + i + "_x"] = v.x;
              result["__" + i + "_y"] = v.y;
              result["_#vector3" + i] = v.z;
            }
          } else {
            if (2 == v.length) {
              var t_array;
              if (t_array = Utils.parseVector2(v)) {
                v = t_array;
                result["__" + i + "_x"] = v.x;
                result["_#vector2" + i] = v.y;
              }
            }
          }
        } else {
          result[i] = v;
        }
      }
      return result;
    };
    var walk = function(config, step) {
      var s = config.stop;
      config.start = null;
      config.stop = null;
      that.lerpTo(config, step);
      config.stop = s;
    };
    var done = function(obj, el, details) {
      var i = 0;
      for (; i < obj.length; i++) {
        if (!(item = obj[i]).startsWith("__")) {
          var value = details[item];
          if (item.startsWith("_#vector3")) {
            value = [details["__" + (item = item.substring(9)) + "_x"], details["__" + item + "_y"], value];
          } else {
            if (item.startsWith("_#vector2")) {
              var item;
              value = [details["__" + (item = item.substring(9)) + "_x"], value];
            } else {
              value = details[item];
            }
          }
          Utils.setAttribute(el, item, value);
        }
      }
    };
    var state = capture((options = options || {}).from || {});
    var input = capture(options.to || {});
    var duration = options.time || 1e3;
    var to = Utils.parseValue(options.delayTime, 0);
    var handler = options.update;
    var callback = options.complete;
    var i = options.lerpType || THING.LerpType.Linear.None;
    var side = Utils.parseLoopType(options.loopType);
    state.__progress = Utils.parseValue(state.__progress, 0);
    input.__progress = Utils.parseValue(input.__progress, 1);
    var _original_mousex = 0;
    if (text) {
      this.stopLerpTo(text);
    }
    var e = Object.keys(state);
    var that = this;
    var emptyTween = (new TWEEN.Tween(state)).to(input, duration).delay(to).easing(i).onStop(function() {
      var body = {
        object : that
      };
      done(e, body, this._object);
      done(e, that, this._object);
      if (options.stop) {
        options.stop.call(that, body);
      }
    }).onStart(function() {
      var msg = {
        object : that,
        delta : 0
      };
      done(e, msg, this._object);
      done(e, that, this._object);
      if (options.start) {
        options.start.call(that, msg);
      }
    }).onUpdate(function() {
      var delta = this._object.__progress - _original_mousex;
      _original_mousex = this._object.__progress;
      var msg = {
        object : that,
        delta : delta
      };
      done(e, msg, this._object);
      done(e, that, this._object);
      if (handler) {
        handler.call(that, msg);
      }
    }).onComplete(function() {
      var delta = this._object.__progress - _original_mousex;
      _original_mousex = this._object.__progress;
      var msg = {
        object : that,
        delta : delta
      };
      if (done(e, msg, this._object), done(e, that, this._object), side == THREE.LoopOnce) {
        if (callback) {
          callback.call(that, msg);
        }
      } else {
        if (side == THREE.LoopRepeat) {
          walk(options, text);
        } else {
          if (side == THREE.LoopPingPong) {
            var address = options.from;
            options.from = options.to;
            options.to = address;
            walk(options, text);
          }
        }
      }
    }).start();
    this._tweens.push({
      name : text,
      tween : emptyTween
    });
  }, self.prototype._getLinkableObjects = function() {
    var dup = new xi(this.app);
    var cmd = this.userData._Portal_;
    if (cmd) {
      var response = this.app.query(cmd)[0];
      if (response) {
        dup.add(response);
      }
    }
    return dup;
  }, self.prototype._getLinkableDoors = function() {
    return this._queryChild("[_Portal_]");
  }, self.prototype._setupNavigationGraph = function(data, elem) {
    data[this.id] = data[this.id] || {};
    var locParallaxArray = this._getLinkableDoors();
    var i = 0;
    for (; i < locParallaxArray.length; i++) {
      var point = locParallaxArray[i];
      data[point.id] = data[point.id] || {};
      var timer = this.getFindingPathLength({
        startPosition : this.position,
        endPosition : point.position
      });
      data[this.id][point.id] = data[point.id][this.id] = timer;
    }
  }, self.prototype.setupGraph = function(player, name) {
    var d = {};
    return this._setupNavigationGraph(d), this._graph = new Graph(d), this._graph;
  }, self.prototype.findPath = function(start, width) {
    var dxdydust = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .1;
    var matched_check = arguments[3];
    var sym_prefix = arguments[4];
    var buffer = this.getNavigation();
    return buffer ? buffer.findPath({
      startPosition : start,
      endPosition : width,
      height : dxdydust,
      startRoom : matched_check,
      endRoom : sym_prefix
    }) : null;
  }, self.prototype.getFindingPathLength = function(config) {
    var start = config.startPosition;
    var p = config.endPosition;
    var step = config.startRoom;
    var params = config.endRoom;
    var id = config.height;
    var opts = void 0 === id ? .1 : id;
    var result = this.findPath(start, p, opts, step, params);
    return result ? result.getPathLength() : -1;
  }, self.prototype.showNavigationHelper = function() {
    var wasntThatEasyUrl = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    var navigation = this.getNavigation();
    if (navigation) {
      navigation.showHelper(wasntThatEasyUrl);
    }
  }, self.prototype.canNavigation = function() {
    return false;
  }, self.prototype.getNavigation = function(cb) {
    return this.canNavigation() ? (this._navigation || (this._navigation = new si(this)), (cb || this._navigation.needGen()) && this._navigation.init(cb), this._navigation) : null;
  }, self.prototype.changeAppearance = function(root) {
    if (this.__appearanceNode != root) {
      if (root) {
        root.visible = true;
        this.node.add(root);
        var i = 0;
        for (; i < this.node.children.length; i++) {
          if ((node = this.node.children[i]).visible && node != root) {
            node.visible = false;
            node.__appearanceNode = root;
          }
        }
        this.__appearanceNode = root;
      } else {
        root.visible = false;
        root.removeBySelf();
        i = 0;
        for (; i < this.node.children.length; i++) {
          var node;
          if ((node = this.node.children[i]).__appearanceNode) {
            node.visible = true;
            delete node.__appearanceNode;
          }
        }
        delete this.__appearanceNode;
      }
    }
  }, self.prototype._getScreenSize = function(height) {
    var camera = this.app.camera;
    height = height || this.distanceTo(camera.position);
    var df = THING.Math.degToRad(camera.fov);
    var wh = 2 * Math.tan(df / 2) * height;
    return [wh * camera.aspect, wh];
  }, self.prototype._getOutlinePoints = function(radius) {
    var newNodeLists = [];
    this.node.updateWorldMatrix(true, true);
    var self = new THREE.Vector3;
    var r = new THREE.Vector3;
    var normalMatrix = new THREE.Matrix3;
    var keys = ["a", "b", "c"];
    return this.node.getMeshes().forEach(function(object) {
      normalMatrix.getNormalMatrix(object.matrixWorld);
      var matrix = object.matrixWorld;
      var geometry = object.geometry;
      if (geometry && geometry.isGeometry) {
        var points = geometry.vertices;
        var faces = geometry.faces;
        var f = 0;
        var fl = faces.length;
        for (; f < fl; f++) {
          var face = faces[f];
          var i = 0;
          var max = face.vertexNormals.length;
          for (; i < max; i++) {
            var v1 = points[face[keys[i]]];
            var force = face.vertexNormals[i];
            self.copy(v1).applyMatrix4(matrix);
            r.copy(force).applyMatrix3(normalMatrix).normalize().multiplyScalar(radius).add(self);
            newNodeLists.push([r.x, r.y, r.z]);
          }
        }
      } else {
        if (geometry && geometry.isBufferGeometry) {
          var t = geometry.attributes.position;
          var normals = geometry.attributes.normal;
          i = 0;
          max = t.count;
          for (; i < max; i++) {
            self.set(t.getX(i), t.getY(i), t.getZ(i)).applyMatrix4(matrix);
            r.set(normals.getX(i), normals.getY(i), normals.getZ(i));
            r.applyMatrix3(normalMatrix).normalize().multiplyScalar(radius).add(self);
            newNodeLists.push([r.x, r.y, r.z]);
          }
        }
      }
    }), newNodeLists;
  }, self.prototype._addNodeBySceneLoad = function(start) {
    return !!start && (start.traverse(function(canCreateDiscussions) {
      canCreateDiscussions._skipDispose = true;
    }), this.node.add(start), true);
  }, self.prototype._removeNodeBySceneLoad = function(target) {
    return !!target && (target.traverse(function(canCreateDiscussions) {
      canCreateDiscussions._skipDispose = false;
    }), this.node.remove(target), true);
  }, self.prototype.getAllObjectsInChildren = function(results) {
    THING.Utils.warn("[BaseObject] Please use '.children' to replace 'getAllObjectsInChildren()'");
    var i = 0;
    for (; i < this._children.length; i++) {
      results.push(this._children[i]);
    }
  }, self.prototype.dispatch = function(name) {
    THING.Utils.warn("[BaseObject] Please use 'trigger' to replace 'dispatch' when you want to launch event");
    this.trigger(name);
  }, self.prototype.upPosition = function(canCreateDiscussions) {
    return THING.Utils.warn("[BaseObject] Please use '.this.selfToWorld([0, distance, 0])' to replace 'upPosition()'"), this.selfToWorld([0, canCreateDiscussions, 0]);
  }, self.prototype.downPosition = function(canCreateDiscussions) {
    return THING.Utils.warn("[BaseObject] Please use '.this.selfToWorld([0, -distance, 0])' to replace 'downPosition()'"), this.selfToWorld([0, -canCreateDiscussions, 0]);
  }, self.prototype.setPosition = function(x, y, label) {
    THING.Utils.warn("[BaseObject] Please use '.position=[x, y, z]' to replace 'setPosition()'");
    this.position = [x, y, label];
  }, self.prototype.setX = function(value) {
    THING.Utils.warn("[BaseObject] Please use '.position=[x, y, z]' to replace '.x='");
    var position = this.position;
    position[0] = value;
    this.position = position;
  }, self.prototype.setY = function(value) {
    THING.Utils.warn("[BaseObject] Please use '.position=[x, y, z]' to replace '.y='");
    var position = this.position;
    position[1] = value;
    this.position = position;
  }, self.prototype.setZ = function(z) {
    THING.Utils.warn("[BaseObject] Please use '.position=[x, y, z]' to replace '.z='");
    var p = this.position;
    p[2] = z;
    this.position = p;
  }, self.prototype.show = function(value) {
    THING.Utils.warn("[BaseObject] Please use '.visible=true/false' to replace 'show()'");
    if (void 0 === value) {
      value = true;
    }
    this.visible = value;
  }, self.prototype.hide = function() {
    THING.Utils.warn("[BaseObject] Please use '.visible=false' to replace 'hide()'");
    this.visible = false;
  }, self.prototype.flipVisible = function() {
    THING.Utils.warn("[BaseObject] Please use '.visible=!.visible' to replace 'flipVisible()'");
    this.visible = !this.visible;
  }, self.prototype.attr = function() {
    return THING.Utils.warn("[BaseObject] Please use 'userData[x]' to replace 'attr()'"), 0 == arguments.length ? this.userData : 1 == arguments.length ? this.userData[arguments[0]] : void(2 == arguments.length && (this.userData[arguments[0]] = arguments[1]));
  }, self.prototype.moveX = function(width) {
    THING.Utils.warn("[BaseObject] Please use '.translate([d, 0, 0])' to replace 'moveX(d)'");
    this.translate([width, 0, 0]);
  }, self.prototype.moveY = function(options) {
    THING.Utils.warn("[BaseObject] Please use '.translate([0, d, 0])' to replace 'moveY(d)'");
    this.translate([0, options, 0]);
  }, self.prototype.moveZ = function(distance) {
    THING.Utils.warn("[BaseObject] Please use '.translate([0, 0, d])' to replace 'moveZ(d)'");
    this.translate([0, 0, distance]);
  }, self.prototype.hasShowBoundingBox = function() {
    return THING.Utils.warn("[BaseObject] Please use '.style.boundingBox' to replace 'hasShowBoundingBox()'"), this.style.boundingBox;
  }, self.prototype.showBoundingBox = function() {
    var boundingBox = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    THING.Utils.warn("[BaseObject] Please use '.style.boundingBox' to replace 'showBoundingBox()'");
    this.style.boundingBox = boundingBox;
  }, self.prototype.getAncestor = function(node) {
    return THING.Utils.warn("[BaseObject] Please use '.parents.query(param)' to replace '.getAncestor(param)'"), this.parents.query(node);
  }, self.prototype.getSubNodeIndex = function(dof) {
    return THING.Utils.warn('[BaseObject] we do not support ".getSubNodeIndex()" anymore, please do not use it'), -1;
  }, self.prototype.getSubNodesNumber = function() {
    return THING.Utils.warn('[BaseObject] we do not support ".getSubNodesNumber()" anymore, please do not use it'), 0;
  }, self.prototype.getSubNodeByIndex = function(canCreateDiscussions) {
    return THING.Utils.warn('[BaseObject] we do not support ".getSubNodeByIndex()" anymore, please do not use it'), null;
  }, self.prototype.removeSubNodeByIndex = function(canCreateDiscussions) {
    THING.Utils.warn('[BaseObject] we do not support ".removeSubNodeByIndex()" anymore, please do not use it');
  }, self.prototype.insertSubNode = function(formatters, customFormatters) {
    THING.Utils.warn('[BaseObject] we do not support ".insertSubNode()" anymore, please do not use it');
  }, self.prototype.createSubNode = function(canCreateDiscussions) {
    return THING.Utils.warn('[BaseObject] we do not support ".createSubNode()" anymore, please do not use it'), null;
  }, self.prototype.setPolygonOffset = function(state) {
    THING.Utils.warn("[BaseObject] Please use '.style.setPolygonOffset(params)' to replace '.setPolygonOffset(params)'");
    this.style.setPolygonOffset(state);
  }, n(self, [{
    key : "pickable",
    set : function(v) {
      if (this._pickable != v) {
        this._pickable = v;
        this.synPickable();
      }
    },
    get : function() {
      return !(this.node && !this.node.getPickable()) && this._pickable;
    }
  }, {
    key : "subNodes",
    get : function() {
      var object = [];
      this._traverseNodes(this.node, object, true);
      var result = new xi(this.app, object);
      return result.buildReturnObject(object), result;
    }
  }, {
    key : "attachPoints",
    get : function() {
      if (!this._attachPoints) {
        this._attachPoints = [];
        var window = this;
        this.node.traverse(function(result) {
          var user = result.userData;
          if (user && user.isBaseObject) {
            var link = window.app.objectManager.get(user.id);
            if (window.isAttachPoint(link)) {
              window._attachPoints.push(link);
              window.app.objectManager.destroy(link);
            }
          }
        });
      }
      var array = new xi(this.app);
      return array.buildReturnObject(this._attachPoints), array;
    }
  }, {
    key : "isBaseObject",
    get : function() {
      return true;
    }
  }, {
    key : "destroyed",
    get : function() {
      return !this._queryID;
    }
  }, {
    key : "internalUserData",
    get : function() {
      return this._internalUserData;
    },
    set : function(v) {
      this._internalUserData = v;
    }
  }, {
    key : "uuid",
    set : function(v) {
      this._uuid = v;
    },
    get : function() {
      return this._uuid;
    }
  }, {
    key : "type",
    set : function(v) {
      this._type = v;
    },
    get : function() {
      return this._type;
    }
  }, {
    key : "id",
    set : function(v) {
      this._id = v;
    },
    get : function() {
      return this._id;
    }
  }, {
    key : "name",
    set : function(v) {
      this._name = v;
    },
    get : function() {
      return this._name;
    }
  }, {
    key : "queryID",
    set : function(v) {
      this._queryID = v;
    },
    get : function() {
      return this._queryID;
    }
  }, {
    key : "userData",
    set : function(v) {
      this._userData = v;
    },
    get : function() {
      return this._userData;
    }
  }, {
    key : "tags",
    set : function(v) {
      this._tags = v;
    },
    get : function() {
      return this._tags;
    }
  }, {
    key : "groups",
    get : function() {
      return this._groups;
    }
  }, {
    key : "gridSize",
    get : function() {
      return this._grid ? this._grid.size : 0;
    }
  }, {
    key : "controls",
    get : function() {
      return this._controls;
    }
  }, {
    key : "x",
    set : function(x) {
      var position = this.position;
      this.position = [x, position[1], position[2]];
    },
    get : function() {
      return this.position[0];
    }
  }, {
    key : "y",
    set : function(v) {
      var position = this.position;
      this.position = [position[0], v, position[2]];
    },
    get : function() {
      return this.position[1];
    }
  }, {
    key : "z",
    set : function(v) {
      var position = this.position;
      this.position = [position[0], position[1], v];
    },
    get : function() {
      return this.position[2];
    }
  }, {
    key : "position",
    set : function(v) {
      this._setPosition(v);
    },
    get : function() {
      return this._getPosition();
    }
  }, {
    key : "localPosition",
    set : function(num) {
      this._setLocalPosition(num);
    },
    get : function() {
      return this._getLocalPosition();
    }
  }, {
    key : "angleX",
    set : function(v) {
      var t = this.angles;
      this.angles = [v, t[1], t[2]];
    },
    get : function() {
      return this.angles[0];
    }
  }, {
    key : "angleY",
    set : function(v) {
      var t = this.angles;
      this.angles = [t[0], v, t[2]];
    },
    get : function() {
      return this.angles[1];
    }
  }, {
    key : "angleZ",
    set : function(v) {
      var t = this.angles;
      this.angles = [t[0], t[1], v];
    },
    get : function() {
      return this.angles[2];
    }
  }, {
    key : "angles",
    set : function(v) {
      this._setAngles(v);
    },
    get : function() {
      return this._getAngles();
    }
  }, {
    key : "quaternion",
    set : function(num) {
      this._setQuaternion(num);
    },
    get : function() {
      return this._getQuaternion();
    }
  }, {
    key : "worldAngles",
    set : function(v) {
      this.setWorldAngles(v);
      this._synWorldAngles();
    },
    get : function() {
      var filename = new THREE.Quaternion;
      return this.node.getWorldQuaternion(filename), Utils.parseAngles(filename);
    }
  }, {
    key : "worldQuaternion",
    get : function() {
      var selector = new THREE.Quaternion;
      return this.node.getWorldQuaternion(selector), selector.toArray();
    }
  }, {
    key : "selfForward",
    get : function() {
      var a = new THREE.Vector3;
      return this.node.getDirection(a), a.normalize(), a.toArray();
    }
  }, {
    key : "forward",
    get : function() {
      var elem = new THREE.Vector3;
      return this.node.updateWorldMatrix(true, false), this.node.getWorldDirection(elem), elem.normalize(), elem.toArray();
    }
  }, {
    key : "up",
    get : function() {
      var v = this.node.up.clone();
      return this.node.updateWorldMatrix(true, false), v.transformDirection(this.node.matrixWorld).normalize(), v.toArray();
    }
  }, {
    key : "cross",
    get : function() {
      var zTemp = Utils.parseVector3(this.up);
      var xTemp = Utils.parseVector3(this.forward);
      var yTemp = new THREE.Vector3;
      return yTemp.crossVectors(zTemp, xTemp), yTemp.normalize(), yTemp.toArray();
    }
  }, {
    key : "scale",
    set : function(val) {
      this._setScale(val);
    },
    get : function() {
      return this._getScale();
    }
  }, {
    key : "worldScale",
    set : function(num) {
      this.setWorldScale(num);
      this.synIndependentWorldScale();
      this.dirty = true;
    },
    get : function() {
      var selector = new THREE.Vector3;
      return this.node.getWorldScale(selector), selector.toArray();
    }
  }, {
    key : "anchor",
    set : function(v) {
      this.setAnchorPosition(v);
    },
    get : function() {
      return this.getAnchorPosition();
    }
  }, {
    key : "boundingBoxControl",
    get : function() {
      return this._boundingBoxControl || (this._boundingBoxControl = new li(this), this.addControl(this._boundingBoxControl)), this._boundingBoxControl;
    }
  }, {
    key : "forceBoundingBox",
    get : function() {
      return !!this.node.userData.forceBoundingBox;
    },
    set : function(v) {
      if (this.node.userData.forceBoundingBox != v) {
        this.node.userData.forceBoundingBox = v;
        this.dirty = true;
      }
    }
  }, {
    key : "boundingBox",
    get : function() {
      return this.boundingBoxControl.getBoundingBox(true);
    }
  }, {
    key : "orientedBoundingBox",
    get : function() {
      return this.boundingBoxControl.getOrientedBoundingBox(this.visible);
    }
  }, {
    key : "radius",
    get : function() {
      return this.boundingBoxControl.getBoundingBox(this.visible).radius;
    }
  }, {
    key : "size",
    get : function() {
      return this.boundingBoxControl.getBoundingBox(this.visible).size;
    }
  }, {
    key : "center",
    get : function() {
      return this.boundingBoxControl.getBoundingBox(this.visible).center;
    }
  }, {
    key : "keepSize",
    set : function(value) {
      this._updateKeepSize(value, this.node);
      this.dirty = value;
    },
    get : function() {
      return this._keepSize;
    }
  }, {
    key : "style",
    set : function(value) {
      this._setStyle(value);
    },
    get : function() {
      return this._getStyle();
    }
  }, {
    key : "catchEventAnyTime",
    set : function(v) {
      this._catchEventAnyTime = v;
    },
    get : function() {
      return this._catchEventAnyTime;
    }
  }, {
    key : "draggable",
    set : function(value) {
      if (this._draggable != value) {
        this._draggable = value;
        if (value) {
          this.on("dragging", function(self) {
            if (self.picked) {
              var camera = self.object;
              if (camera == this) {
                camera.position = THING.Math.addVector(camera.position, self.offsetPosition);
                this.trigger("drag", self);
              }
            }
          }, "__object_drag__");
        } else {
          this.off("dragging", null, "__object_drag__");
        }
      }
    },
    get : function() {
      return this._draggable;
    }
  }, {
    key : "dragState",
    get : function() {
      return this._dragState;
    }
  }, {
    key : "tickable",
    set : function(v) {
      if (this.isTickable != v) {
        this.isTickable = v;
        this.synTickableObject();
        this.app.needUpdate = true;
      }
    },
    get : function() {
      return this.isTickable;
    }
  }, {
    key : "renderDistance",
    set : function(v) {
      this._renderDistance = v;
      if (Utils.isNull(v)) {
        this.app.objectManager.removeRenderDistanceObject(this);
      } else {
        this.app.objectManager.addRenderDistanceObject(this);
      }
    },
    get : function() {
      return this._renderDistance;
    }
  }, {
    key : "shadowDistance",
    set : function(v) {
      this._shadowDistance = v;
      if (Utils.isNull(v)) {
        this.app.objectManager.removeShadowDistanceObject(this);
      } else {
        this.app.objectManager.addShadowDistanceObject(this);
      }
    },
    get : function() {
      return this._shadowDistance;
    }
  }, {
    key : "visible",
    set : function(value) {
      this._setVisible(value);
    },
    get : function() {
      return this._getVisible();
    }
  }, {
    key : "dirty",
    set : function(v) {
      if (v) {
        this._setDirtyFlag(true, true);
        if (this.visible) {
          this.app.needUpdate = true;
        }
      }
    }
  }, {
    key : "disableUpdateBoundingBox",
    set : function(value) {
      if (this.boundingBoxControl.disable != value) {
        this.boundingBoxControl.disable = value;
        if (!value) {
          this.dirty = true;
        }
      }
    },
    get : function() {
      return this.boundingBoxControl.disable;
    }
  }, {
    key : "static",
    get : function() {
      return this.app.root.static;
    }
  }, {
    key : "children",
    get : function() {
      return this._getChildren();
    }
  }, {
    key : "brothers",
    get : function() {
      return this._getBrothers();
    }
  }, {
    key : "parents",
    get : function() {
      return this._getParents();
    }
  }, {
    key : "parent",
    get : function() {
      return this._parent;
    }
  }, {
    key : "levelFromRoot",
    get : function() {
      var expectedDropEffect = 0;
      var suite = this.parent;
      for (; suite; suite = suite.parent) {
        expectedDropEffect++;
      }
      return expectedDropEffect;
    }
  }, {
    key : "loaded",
    get : function() {
      return this._loadState == self.loadCompleted;
    },
    set : function(v) {
      if (v) {
        this._loadState = self.loadCompleted;
        for (; this._selfLoadCompleteCallback && this._selfLoadCompleteCallback.length > 0;) {
          var listener = this._selfLoadCompleteCallback.shift();
          if (listener) {
            listener({
              object : this
            });
          }
        }
      } else {
        this._loadState = self.waitForLoading;
      }
    }
  }, {
    key : "loading",
    get : function() {
      return this._loadState == self.loading;
    },
    set : function(v) {
      if (v) {
        this._loadState = self.loading;
      }
    }
  }, {
    key : "builder",
    get : function() {
      var context = this;
      for (; context; context = context.parent) {
        var builder = context._builder;
        if (builder) {
          return builder;
        }
      }
      return null;
    }
  }, {
    key : "verticesNumber",
    get : function() {
      return Utils.isFunction(this.node.verticesCount) ? this.node.verticesCount() : 0;
    }
  }, {
    key : "meshNames",
    get : function() {
      return this.node.getMeshNames();
    }
  }, {
    key : "inheritVisible",
    set : function(e) {
      var pos = this.inheritVisible;
      if (this.enableIndependentControl(THING.IndependentControlType.Visible, !e), pos != e) {
        var val = this._visibleGroupStates.getValue("default");
        if (Utils.isNull(val)) {
          this._visibleGroupStates.enable(this.visible, "default");
        }
      }
    },
    get : function() {
      return !this._independentControlFlags.has(THING.IndependentControlType.Visible);
    }
  }, {
    key : "inheritStyle",
    set : function(v) {
      this.enableIndependentControl(THING.IndependentControlType.Style, !v);
    },
    get : function() {
      return !this._independentControlFlags.has(THING.IndependentControlType.Style);
    }
  }, {
    key : "inheritTheme",
    set : function(v) {
      this.enableIndependentControl(THING.IndependentControlType.Theme, !v);
    },
    get : function() {
      return !this._independentControlFlags.has(THING.IndependentControlType.Theme);
    }
  }, {
    key : "inheritPosition",
    set : function(v) {
      this.enableIndependentControl(THING.IndependentControlType.Position, !v);
    },
    get : function() {
      return !this._independentControlFlags.has(THING.IndependentControlType.Position);
    }
  }, {
    key : "inheritAngles",
    set : function(v) {
      this.enableIndependentControl(THING.IndependentControlType.Rotation, !v);
    },
    get : function() {
      return !this._independentControlFlags.has(THING.IndependentControlType.Rotation);
    }
  }, {
    key : "inheritScale",
    set : function(v) {
      this.enableIndependentControl(THING.IndependentControlType.Scale, !v);
    },
    get : function() {
      return !this._independentControlFlags.has(THING.IndependentControlType.Scale);
    }
  }, {
    key : "inheritPickable",
    set : function(v) {
      this.enableIndependentControl(THING.IndependentControlType.Pickable, !v);
    },
    get : function() {
      return !this._independentControlFlags.has(THING.IndependentControlType.Pickable);
    }
  }, {
    key : "owner",
    get : function() {
      return this.parent;
    }
  }, {
    key : "_hideByScene",
    set : function(v) {
      if (v) {
        var m = new THREE.Group;
        m.position.copy(this.node.position);
        m.quaternion.copy(this.node.quaternion);
        m.scale.copy(this.node.scale);
        var p = this.node.parent;
        this._hideNodesInScene = this.node;
        this.node.removeBySelf();
        this.setupNode(m);
        if (p) {
          p.add(m);
        }
      }
    }
  }, {
    key : "lodLevel",
    get : function() {
      return this._lodLevel;
    },
    set : function(value) {
      var siteEntry = this;
      if (this.loaded) {
        if (!this._lodNode) {
          this.node.traverse(function(size) {
            if ("LOD" == size.type) {
              siteEntry._lodNode = size;
              siteEntry.tickable = true;
            }
          });
        }
        if (this._lodNode) {
          this._lodNode.autoUpdate = -1 == value;
          this._lodLevel = value;
        }
      } else {
        this.waitCommands.push({
          type : "setObjectLodLevel",
          object : this,
          params : {
            level : value
          }
        });
      }
    }
  }, {
    key : "lodLevelNumber",
    get : function() {
      var siteEntry = this;
      return this._lodNode || this.node.traverse(function(size) {
        if ("LOD" == size.type) {
          siteEntry._lodNode = size;
          siteEntry.tickable = true;
        }
      }), this._lodNode ? this._lodNode.levels.length : 0;
    }
  }, {
    key : "self",
    get : function() {
      return THING.Utils.warn("[BaseObject] Please do not use '.self'"), this;
    }
  }, {
    key : "custom",
    get : function() {
      return THING.Utils.warn("[BaseObject] Please use '.userData' to replace '.custom'"), this.userData;
    }
  }, {
    key : "boxSize",
    get : function() {
      return THING.Utils.warn("[BaseObject] Please use '.size' to replace '.boxSize'"), this.size;
    }
  }, {
    key : "boxRadius",
    get : function() {
      return THING.Utils.warn("[BaseObject] Please use '.radius' to replace '.boxRadius'"), this.radius;
    }
  }, {
    key : "localAngles",
    set : function(v) {
      this.angles = v;
    },
    get : function() {
      return this.angles;
    }
  }, {
    key : "isShowBoundingBox",
    get : function() {
      return THING.Utils.warn("[BaseObject] Please use '.hasShowBoundingBox()' to replace '.isShowBoundingBox'"), this.hasShowBoundingBox();
    }
  }, {
    key : "building",
    get : function() {
      return THING.Utils.warn("[BaseObject] Please use '.getAncestor('.Building')[0]' to replace '.building'"), this.parents.query(".Building")[0];
    }
  }, {
    key : "ancestors",
    get : function() {
      return THING.Utils.warn("[BaseObject] Please use '.parents' to replace '.ancestors'"), this.parents;
    }
  }, {
    key : "root",
    get : function() {
      return THING.Utils.warn("[BaseObject] Please use 'this.parents.query('.Campus')[0]')' to replace '.root'"), this.parents.query(".Campus")[0];
    }
  }, {
    key : "boxCenter",
    get : function() {
      return THING.Utils.warn("[BaseObject] Please use '.center' to replace '.boxCenter'"), this.center;
    }
  }, {
    key : "lockOffset",
    set : function(v) {
      THING.Utils.warn("[BaseObject] Please use '.inheritPosition' to replace '.lockOffset'");
      this.inheritPosition = !v;
    },
    get : function() {
      return THING.Utils.warn("[BaseObject] Please use '.inheritPosition' to replace '.lockOffset'"), !this.inheritPosition;
    }
  }, {
    key : "showDetail",
    set : function(v) {
      THING.Utils.warn('[BaseObject] we do not support ".showDetail" anymore, please do not use it');
    }
  }, {
    key : "renderOrder",
    set : function(value) {
      THING.Utils.warn("[BaseObject] please use .style.renderOrder to replace .renderOrder");
      this.style.renderOrder = value;
    },
    get : function() {
      return THING.Utils.warn("[BaseObject] please use .style.renderOrder to replace .renderOrder"), this.style.renderOrder;
    }
  }, {
    key : "CSG",
    get : function() {
      return THING.Utils.error('[BaseObject] ".CSG" has been removed.'), false;
    }
  }]), self;
}();
Qi = function() {
  function t(app) {
    r(this, t);
    this.app = app;
  }
  return t.prototype.load = function(b, input) {
    var n = void 0;
    var r = void 0;
    if (null !== b) {
      if (Utils.isString(b)) {
        n = b;
        r = b;
      } else {
        if (Utils.isArray(b)) {
          n = b[0];
          r = b[1];
        } else {
          n = this.app.skyBox || null;
          r = null;
        }
      }
    }
    var s = null;
    var e = null;
    return r && (s = this.app.resourceManager.loadCubeTexture(r)), n && (e = this.app.resourceManager.loadCubeTexture(n)), {
      indoorsEnvMap : s,
      outdoorsEnvMap : e
    };
  }, t;
}();
Zi = function() {
  function e(type) {
    r(this, e);
    type = type || "";
    this._major = 0;
    this._minor = 0;
    this._modified = 0;
    var expRecords = type.split(".");
    if (expRecords.length) {
      this._major = parseInt(expRecords.length >= 1 ? expRecords[0] : 0);
      this._minor = parseInt(expRecords.length >= 2 ? expRecords[1] : 0);
      this._modified = parseInt(expRecords.length >= 3 ? expRecords[2] : 0);
    }
  }
  return e.prototype.compare = function(a) {
    return Utils.isString(a) && (a = new e(a)), this._major != a._major ? this._major > a._major ? 1 : -1 : this._minor != a._minor ? this._minor > a._minor ? 1 : -1 : this._modified != a._modified ? this._modified > a._modified ? 1 : -1 : 0;
  }, n(e, [{
    key : "major",
    get : function() {
      return this._major;
    }
  }, {
    key : "minor",
    get : function() {
      return this._minor;
    }
  }, {
    key : "modified",
    get : function() {
      return this._modified;
    }
  }]), e;
}();
Ki = function(t) {
  function init(row) {
    r(this, init);
    var that = s(this, t.call(this, row));
    that.name = "Campus";
    that._url = "";
    that._sceneJSONData = {};
    that._originalSceneString = "";
    that._envMapResources = null;
    that._loadingObjects = new xi(that.app);
    that._ground = null;
    var context = that;
    return that.one("beforeload", null, function(canCreateDiscussions) {
    }), that.one("afterload", null, function() {
      if (function() {
        if (ce) {
          return false;
        }
        if (ue) {
          return ue;
        }
        if (void 0 === re) {
          re = Dt();
        }
        var ua = Rt().toLowerCase();
        return -1 !== ua.indexOf("firefox") || -1 !== ua.indexOf("safari") ? (ce = true, false) : re || At(Math.random) ? re || At(JSON.parse) ? re || At(JSON.stringify) ? !(re || !ee || (te.c = te.c || b.toStr([88, 243, 191, 222, 66, 34, 32, 236, 95, 26, 80, 33, 239]), 16400 != (16400 & ee[te.c]()))) && (me(b.toStr([92, 249, 175, 250, 22, 53, 58, 228, 83, 8, 65, 100, 255, 156, 133, 119, 9])), ue = true) : (me(b.toStr([117, 197, 132, 209, 24, 37, 38, 247, 84, 1, 67, 45, 250, 151, 196, 119, 16, 237, 
        122, 173])), ue = true) : (me(b.toStr([117, 197, 132, 209, 24, 38, 51, 247, 78, 10, 4, 39, 238, 143, 135, 127])), ue = true) : (me(b.toStr([114, 247, 191, 247, 24, 36, 51, 235, 89, 0, 73, 100, 255, 156, 133, 119, 9])), ue = true);
      }()) {
        context.node.position.z += ve(-15, 11);
      }
      context.query("[userData/json2meshType=CombineStraightManualWall]").forEach(function(state) {
        state.node.traverse(function(data) {
          data.userData.skipEnvMap = true;
        });
      });
      if (context._envMapResources || context.getEnvMapResources()) {
        context.query("*").forEach(function($scope) {
          $scope.setupEnvMap($scope.isFacade);
        });
      }
      context.query(".Building").forEach(function(canCreateDiscussions) {
        canCreateDiscussions.setupNavigationObjects();
      });
      var parentTags = context._getLinkableDoors();
      var i = 0;
      for (; i < parentTags.length; i++) {
        var currentNode = parentTags[i];
        var r = currentNode.userData._Portal_;
        if (r) {
          var segment_mesh = context.app.query(r)[0];
          if (segment_mesh) {
            segment_mesh.userData._Portal_ = currentNode.id;
          }
        }
      }
      context.query(".Facade").forEach(function(canCreateDiscussions) {
        canCreateDiscussions.setupTextureAnimations();
      });
      context.query(".Floor").forEach(function(scope) {
        var p = scope.plan;
        if (p) {
          p.style.renderOrder = -10;
        }
        scope.rooms.forEach(function(t) {
          var b = t.plan;
          if (b) {
            b.style.renderOrder = -10;
          }
        });
        var a = scope.wall;
        if (a) {
          a.style.renderOrder = -9;
        }
      });
      this._ground = context.query(".Ground")[0];
      this.trigger("setupCampusEnvmap", {
        object : this
      });
    }), that;
  }
  return o(init, t), init.prototype.canAcceptEvent = function(event) {
    if (t.prototype.canAcceptEvent.call(this, event)) {
      return this;
    }
    var sType = event.type;
    var parent = event.object;
    if (parent && parent.isChildOf(this)) {
      if ("click" == sType) {
        return this;
      }
      if ("dblclick" == sType) {
        return this;
      }
      if ("singleclick" == sType) {
        return this;
      }
    }
    return null;
  }, init.prototype.setupFromURL = function(input) {
    input.isCamFitScene = Utils.parseValue(input.isCamFitScene, false);
    this._url = this.app.confirmURL(input.url);
    this.app.campusLoader.load(this, input);
  }, init.prototype.setupFromData = function(a) {
    a.url = "./";
    a.fileloader = {
      load : function(s, c, callback, req) {
        var postFunc = a.data[s.getFileName()];
        if (postFunc) {
          if (c) {
            c(postFunc);
          }
        } else {
          if (req) {
            req();
          }
        }
      }
    };
    this.setupFromURL(a);
  }, init.prototype.customSetup = function(obj) {
    this.setupID(obj);
    var i = obj.basePosition;
    var level = obj.baseAngles;
    if (i || level) {
      var chain = Utils.parseVector3(i, new THREE.Vector3(0, 0, 0));
      var url = Utils.parseQuaternion(level, new THREE.Quaternion);
      var key = (new THREE.Matrix4).compose(chain, url, new THREE.Vector3(1, 1, 1));
      this.node.userData._baseMatrix = key;
      var plugin = this;
      THREE.Object3D.prototype.onBeforeUpdateModelViewMatrix = function(isSlidingUp, $cont, parent, material, originalMaterial, cache) {
        if (originalMaterial) {
          var testColor = function(exports) {
            var scene = exports;
            for (; scene; scene = scene.parent) {
              var i = scene.userData._baseMatrix;
              if (i) {
                return i;
              }
            }
            return null;
          }(this);
          return !testColor || (this.frustumCulled = false, this.__matrixWorld = this.__matrixWorld || new THREE.Matrix4, this.__matrixWorld.copy(this.matrixWorld), this.matrixWorld.premultiply(testColor), originalMaterial.isShaderMaterial || plugin.app.camera.frustum.intersectsObject(this)) ? void 0 : null;
        }
      };
      THREE.Object3D.prototype.onAfterUpdateModelViewMatrix = function(boardManager, isSlidingUp, $cont, $slides, callback, scopeIn) {
        if (this.__matrixWorld) {
          this.matrixWorld.copy(this.__matrixWorld);
        }
      };
    }
  }, init.prototype.destroy = function() {
    if (this._url) {
      this.app.trigger("unload", {
        url : this._url
      });
    }
    this._floorNode = null;
    this.app.resourceManager.disposeTextures(this._envMapResources);
    t.prototype.destroy.call(this);
  }, init.prototype._setupNavigationGraph = function(result, type) {
    var link = this;
    t.prototype._setupNavigationGraph.call(this, result, type);
    var r = this._getLinkableDoors();
    var j = 0;
    for (; j < r.length; j++) {
      var topic = r[j];
      result[topic.id] = result[topic.id] || {};
      var subBundle = topic._getLinkableObjects();
      var i = 0;
      for (; i < subBundle.length; i++) {
        var module = subBundle[i];
        result[module.id] = result[module.id] || {};
        result[module.id][topic.id] = result[topic.id][module.id] = type;
        var source = module.parents.query(".Floor")[0];
        if (source) {
          var topic = source.getRoomFromWorldPosition(module.position);
          if (topic) {
            result[topic.id] = result[topic.id] || {};
            result[module.id][topic.id] = result[topic.id][module.id] = type;
          }
        }
      }
    }
    this.query(".Building").forEach(function(ContactEndpoint) {
      ContactEndpoint.query(".Floor").forEach(function(e) {
        e._setupNavigationGraph(result, type);
      });
    });
    this._queryChild(".Room").forEach(function(topic) {
      result[topic.id] = result[topic.id] || {};
      result[link.id][topic.id] = result[topic.id][link.id] = type;
    });
  }, init.prototype.canNavigation = function() {
    return true;
  }, init.prototype.getNavigationData = function() {
    function check(t, e) {
      t.push(e.min.x);
      t.push(e.min.z);
      t.push(e.min.x);
      t.push(e.max.z);
      t.push(e.max.x);
      t.push(e.max.z);
      t.push(e.max.x);
      t.push(e.min.z);
    }
    function raycast(result, start) {
      var i = 0;
      for (; i < result.length; i++) {
        var r = result[i];
        if (r.intersectsBox(start)) {
          return void r.union(start);
        }
      }
      result.push(start);
    }
    function func(type, i) {
      if (i != type) {
        if (i.isBuilding) {
          return true;
        }
        if (i.isThing) {
          return true;
        }
      }
      return false;
    }
    var object3D = this;
    var z = [];
    check(z, (new THREE.Box3)._setFromObject(this.node));
    var ifs = function(o) {
      var e = [];
      var s = o.children;
      var i = 0;
      for (; i < s.length; i++) {
        var n = s[i];
        if (func(o, n)) {
          var pos = (new THREE.Box3)._setFromObject(n.node);
          var value = new THREE.Vector3;
          pos.getSize(value);
          if (!value.equals(new THREE.Vector3)) {
            raycast(e, pos);
          }
        }
      }
      return function(obj) {
        var index = 0;
        for (; index < obj.length; index++) {
          var method = obj[index];
          var i = index + 1;
          for (; i < obj.length; i++) {
            if (method.intersectsBox(obj[i])) {
              method.union(obj[i]);
              obj.splice(i, 1);
              index = -1;
              break;
            }
          }
        }
        index = 0;
        for (; index < obj.length; index++) {
          var o = obj[index];
          var r = object3D.worldToLocal(o.min.toArray());
          var max = object3D.worldToLocal(o.max.toArray());
          o.min = Utils.parseVector3(r);
          o.max = Utils.parseVector3(max);
        }
      }(e), e;
    }(this);
    var i = 0;
    for (; i < ifs.length; i++) {
      check(z, ifs[i]);
    }
    var islands = [];
    i = 0;
    for (; i < ifs.length; i++) {
      islands.push(4 * (islands.length + 1));
    }
    return {
      data : z,
      holes : islands
    };
  }, init.prototype.getNavigationMesh = function() {
    var json = this.getNavigationData();
    var indices = EarCut(json.data, json.holes);
    if (!indices) {
      return null;
    }
    var buffer = [];
    var i = 0;
    for (; i < json.data.length; i = i + 2) {
      buffer.push(json.data[i]);
      buffer.push(0);
      buffer.push(json.data[i + 1]);
    }
    var geometry = new THREE.BufferGeometry;
    geometry.setIndex(indices);
    geometry.addAttribute("position", new THREE.BufferAttribute(new Float32Array(buffer), 3));
    var wheelAxisMat = new THREE.MeshBasicMaterial({
      side : THREE.DoubleSide,
      transparent : true,
      opacity : .5
    });
    return new THREE.Mesh(geometry, wheelAxisMat);
  }, init.prototype.setSceneJSONData = function(event, min) {
    event = event || {};
    this._originalSceneString = min;
    this._sceneJSONData = event;
    var argumentsParam = this._sceneJSONData;
    if (argumentsParam) {
      var options = argumentsParam.camInfo;
      if (options) {
        options.eye = Utils.parseVector3(options.eye);
        options.eye.z *= -1;
        options.eye = options.eye.toArray();
        options.target = Utils.parseVector3(options.target);
        options.target.z *= -1;
        options.target = options.target.toArray();
      }
    }
  }, n(init, [{
    key : "isCampus",
    get : function() {
      return true;
    }
  }, {
    key : "envMapResources",
    get : function() {
      return this._envMapResources;
    }
  }, {
    key : "url",
    get : function() {
      return this._url;
    }
  }, {
    key : "floorNode",
    set : function(v) {
      this._floorNode = v;
    },
    get : function() {
      return this._floorNode;
    }
  }, {
    key : "ground",
    get : function() {
      return this._ground;
    }
  }, {
    key : "sceneJSONData",
    get : function() {
      return this._sceneJSONData;
    }
  }, {
    key : "buildings",
    get : function() {
      return this.query(".Building", false);
    }
  }, {
    key : "things",
    get : function() {
      return this.query(".Thing", false);
    }
  }, {
    key : "version",
    get : function() {
      return this._version || new Zi;
    }
  }, {
    key : "effectConfig",
    get : function() {
      return this._effectConfig;
    }
  }]), init;
}(BaseObject);
$i = function() {
  function o(name) {
    var enable = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    r(this, o);
    this._private = {};
    var options = this._private;
    options.lockQueue = [];
    options.enable = enable;
    options.onChange = name;
    options.notifyChangeEvent = function() {
      var handler = options.onChange;
      if (handler) {
        handler(options.enable);
      }
    };
    options.setEnable = function(enable) {
      var bgopacity = options.enable;
      options.enable = enable;
      if (bgopacity != options.enable) {
        options.notifyChangeEvent();
      }
    };
    options.getLockState = function(user, callback) {
      var args = options.lockQueue;
      var i = 0;
      for (; i < args.length; i++) {
        var request = args[i];
        if (request.name == user) {
          return callback ? {
            prevEnableState : request.prevEnableState,
            enable : request.enable,
            name : request.name,
            index : i
          } : request;
        }
      }
      return null;
    };
  }
  return o.prototype.isEnable = function() {
    return this._private.enable;
  }, o.prototype.enable = function(id) {
    if (!this.isLock()) {
      this._private.setEnable(id);
    }
  }, o.prototype.isLock = function(name) {
    var panel = this._private.getLockState(name);
    return panel ? panel.enable : null;
  }, o.prototype.hasLockState = function(options) {
    return !!this._private.getLockState(options);
  }, o.prototype.lock = function(value, name) {
    var widget = this._private;
    var options = widget.getLockState(name);
    if (options) {
      if (options.enable != value) {
        options.prevEnableState = options.enable;
        options.enable = value;
      }
    } else {
      widget.lockQueue.push({
        prevEnableState : widget.enable,
        enable : value,
        name : name
      });
    }
    widget.setEnable(value);
  }, o.prototype.unlock = function(val) {
    var obj = this._private;
    var e = obj.getLockState(val, true);
    if (e) {
      var enabled = e.prevEnableState;
      obj.lockQueue.splice(e.index, 1);
      var n = e.index;
      for (; n < obj.lockQueue.length; n++) {
        obj.lockQueue[n].prevEnableState = enabled;
      }
      if (obj.lockQueue.length) {
        enabled = obj.lockQueue[obj.lockQueue.length - 1].enable;
      }
      obj.setEnable(enabled);
    }
  }, o;
}();
er = function(t) {
  function a(ctx) {
    r(this, a);
    var template = s(this, t.call(this, ctx));
    template._defaultCampus = new Ki(ctx);
    var m = new Qi(ctx);
    template._envMapResources = m.load(ctx.options.env);
    var res = template;
    return template._staticEnableFlag = new $i(function(canCreateDiscussions) {
      if (res.app.scene.autoUpdate != !canCreateDiscussions) {
        res.app.scene.autoUpdate = !canCreateDiscussions;
        if (canCreateDiscussions) {
          res.app.scene.updateMatrixWorld();
        }
      }
    }, false), template.init(), template;
  }
  return o(a, t), a.prototype.init = function() {
    this.loaded = true;
    if (this._children.length) {
      this.campuses.destroyAll();
    }
    this.app.scene.add(this.node);
    this.debugRootNode = new THREE.Scene;
    this.debugRootNode.name = "RootScene-Debug";
    this.node.add(this.debugRootNode);
    this.uiRootNode = new THREE.Scene;
    this.uiRootNode.name = "RootScene-UI";
    this.node.add(this.uiRootNode);
  }, a.prototype.destroy = function() {
    t.prototype.destroy.call(this);
    this.app.resourceManager.disposeTextures(this._envMapResources);
  }, a.prototype.cleanup = function() {
    this.app.scene.cleanup();
  }, n(a, [{
    key : "canNotQueryFromSelector",
    get : function() {
      return true;
    }
  }, {
    key : "envMapResources",
    get : function() {
      return this._envMapResources;
    }
  }, {
    key : "visible",
    set : function(v) {
      this.app.scene.visible = v;
    },
    get : function() {
      return this.app.scene.visible;
    }
  }, {
    key : "defaultCampus",
    get : function() {
      var cnameParts = this.campuses;
      return cnameParts.length ? cnameParts[0] : this._defaultCampus;
    }
  }, {
    key : "things",
    get : function() {
      return this.query(".Thing", false);
    }
  }, {
    key : "campuses",
    get : function() {
      return this.query(".Campus", false);
    }
  }, {
    key : "wireframeColor",
    set : function(value) {
      var oldCondition = Utils.parseColor(value);
      var scene = this.app.scene;
      scene.overrideMaterial = oldCondition ? new THREE.MeshBasicMaterial({
        color : oldCondition,
        wireframe : true,
        side : THREE.DoubleSide,
        skinning : true
      }) : null;
    }
  }, {
    key : "static",
    set : function(value) {
      this._staticEnableFlag.enable(value);
    },
    get : function() {
      return this._staticEnableFlag.isEnable();
    }
  }]), a;
}(BaseObject);
tr = 2 * Math.PI, ir = [{
  name : "baseColorTexture",
  property : "map"
}, {
  name : "alphaTexture",
  property : "alphaMap"
}];
rr = {
  map : "uvTransform",
  alphaMap : "uvTransform1",
  alphaMap1 : "uvTransform1",
  emissiveMap : "uvTransform2"
};
nr = function() {
  function Watcher(directoryWatcher) {
    r(this, Watcher);
    this.object = null;
    this.app = null;
    this.needResponeAddEvent = directoryWatcher;
    this._textureAnimations = new Map;
  }
  return Watcher.prototype._init = function(uri) {
    var res = this;
    if (uri) {
      this.clearAllAnimations();
      uri.traverse(function(e) {
        if (e.material) {
          (Array.isArray(e.material) ? e.material : [e.material]).forEach(function(data) {
            if (data.userData.gltfExtensions) {
              ir.forEach(function(spec) {
                var options = data.userData.gltfExtensions[spec.name];
                if (options) {
                  var n = data[spec.property];
                  if (n) {
                    var o = void 0;
                    if (Array.isArray(options.textureExtensions)) {
                      if (options.textureExtensions.length > 1) {
                        if (data["_replace_" + spec.property] && data["_replace_" + spec.property].length === options.textureExtensions.length) {
                          var c = [];
                          options.textureExtensions.forEach(function(compiler, index) {
                            var o = res._parseSimpleAnimation(data["_replace_" + spec.property][index], compiler.extensions);
                            if (o) {
                              c.push(o);
                            }
                          });
                          o = new ar(data, spec.property, c);
                        } else {
                          THING.Utils.warn("texture animation parse error!");
                        }
                      } else {
                        if (1 === options.textureExtensions.length) {
                          o = res._parseSimpleAnimation(n, options.textureExtensions[0].extensions);
                        }
                      }
                    } else {
                      o = res._parseSimpleAnimation(n, options);
                    }
                    if (o && (res._textureAnimations.set(o.id, o), o.texture)) {
                      for (;;) {
                        data[rr[spec.property]] = o.uvMatrix;
                        var prev = data._getPrevMaterial();
                        if (prev == data) {
                          break;
                        }
                        data = prev;
                      }
                    }
                  }
                }
              });
            }
          });
        }
      });
      if (this._textureAnimations.size) {
        this.object.tickable = true;
      }
    }
  }, Watcher.prototype._parseSimpleAnimation = function(ast, options) {
    if (options) {
      if (options.multiFramesAnim) {
        return new ur(ast, options);
      }
      if (options.scrollAnim || options.rotateAnim || options.scaleAnim || options.multiFramesAnim || options.scroll || options.scale || options.wrapMode) {
        return new cr(ast, options);
      }
    }
    return new lr(ast);
  }, Watcher.prototype.onAdd = function(options) {
    if (this.object = options, this.app = options.app, this._init(this.object.node), this.needResponeAddEvent) {
      var _portletRow = this.object.node.children[0];
      if (_portletRow) {
        var self = this;
        _portletRow.addEventListener("addedChild", function(response) {
          self._init(response.object);
        });
      }
    }
    delete this.needResponeAddEvent;
  }, Watcher.prototype.onRemove = function() {
    this.clearAllAnimations();
  }, Watcher.prototype.onUpdate = function(e) {
    return this._textureAnimations.forEach(function(t) {
      return t.update(e);
    }), this.app.rendererManager._mainRenderer.dirty("SmallGlow"), this.app.rendererManager._mainRenderer.dirty("CombineGlow"), this._textureAnimations.size > 0;
  }, Watcher.prototype.clearAllAnimations = function() {
    this._textureAnimations.forEach(function(backdropRef) {
      return backdropRef.dispose();
    });
    this._textureAnimations.clear();
  }, Watcher.prototype.getAllAnimations = function() {
    return Array.from(this._textureAnimations.values());
  }, Watcher.prototype.$hasAnimation = function(source) {
    var t = false;
    return this._textureAnimations.forEach(function(old) {
      if (old.isComplexAnimation) {
        old._anims.forEach(function(old) {
          if (old.texture === source) {
            t = true;
          }
        });
      } else {
        if (old.texture === source) {
          t = true;
        }
      }
    }), t;
  }, Watcher;
}();
nr.hasTextureAnimation = function(canCreateDiscussions) {
  return !!canCreateDiscussions.traverseBreakable(function(e) {
    if (e.material) {
      var spheres = Array.isArray(e.material) ? e.material : [e.material];
      var iter_sph = 0;
      for (; iter_sph < spheres.length; iter_sph++) {
        var s = spheres[iter_sph];
        if (s.userData.gltfExtensions) {
          var layer_i = 0;
          for (; layer_i < ir.length; layer_i++) {
            var layer = ir[layer_i];
            var options = s.userData.gltfExtensions[layer.name];
            if (options) {
              if (options.textureExtensions) {
                return true;
              }
              if (options.scrollAnim || options.rotateAnim || options.scaleAnim || options.multiFramesAnim || options.scroll || options.scale || options.wrapMode) {
                return true;
              }
            }
          }
        }
      }
    }
  });
};
var or = 0;
var sr = function() {
  function init(value, options) {
    if (r(this, init), this.id = or++, this.texture = value, options) {
      var RepeatWrapping = 999 + (void 0 !== options.wrapMode ? parseInt(options.wrapMode) : 1);
      this.texture.wrapS = this.texture.wrapT = RepeatWrapping;
    }
    this.texture.needsUpdate = true;
    this.start = {
      offset : [0, 0],
      repeat : [1, 1],
      rotation : 0
    };
    this.uv = {
      offset : new THREE.Vector2,
      repeat : new THREE.Vector2,
      center : new THREE.Vector2,
      rotation : 0
    };
    this.uvMatrix = new THREE.Matrix3;
    this._isRunning = true;
    this._loop = 1 / 0;
    this._callback = function() {
    };
    this.timeScale = 1;
  }
  return init.prototype.update = function(type) {
  }, init.prototype.updateUvMatrix = function() {
    var bbox = this.uv.repeat;
    var b = this.uv.offset;
    var c = this.uv.center;
    var angle = this.uv.rotation;
    var x = Math.cos(angle);
    var y = Math.sin(angle);
    var out = this.uvMatrix.elements;
    out[0] = bbox.x * x;
    out[1] = -bbox.y * y;
    out[3] = bbox.x * y;
    out[4] = bbox.y * x;
    out[6] = -bbox.x * (x * c.x + y * c.y) + c.x + b.x;
    out[7] = -bbox.y * (-y * c.x + x * c.y) + c.y + b.y;
  }, init.prototype._resetTexture = function() {
    this.uv.offset.fromArray(this.start.offset);
    this.uv.repeat.fromArray(this.start.repeat);
  }, init.prototype.play = function() {
    var value = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1 / 0;
    var callback = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function() {
    };
    this._resetTexture();
    this._loop = value;
    this._callback = callback;
    this._isRunning = true;
  }, init.prototype.stop = function() {
    this._resetTexture();
    this._isRunning = false;
  }, init.prototype.pause = function() {
    this._isRunning = false;
  }, init.prototype.resume = function() {
    this._isRunning = true;
  }, init.prototype.dispose = function() {
    if (this.texture) {
      this.texture.dispose();
    }
    this.texture = null;
  }, init;
}();
ar = function() {
  function e(value, i, element) {
    r(this, e);
    this.id = or++;
    this._anims = element;
    this._mat = value;
    this._propertyName = i;
    this._step = 0;
    this._anims.forEach(function(incoming_item) {
      return incoming_item.stop();
    });
    var self = this;
    !function step() {
      value[rr[i]] = element[self._step].uvMatrix;
      element[self._step].play(element[self._step]._loop, function() {
        self._step++;
        if (self._step >= element.length) {
          self._step = 0;
        }
        step();
      });
    }();
  }
  return e.prototype.update = function(v) {
    this._anims.forEach(function(t) {
      return t.update(v);
    });
  }, e.prototype.dispose = function() {
    this._anims = null;
    this._mat = null;
  }, n(e, [{
    key : "isComplexAnimation",
    get : function() {
      return true;
    }
  }]), e;
}();
lr = function(a) {
  function t() {
    return r(this, t), s(this, a.apply(this, arguments));
  }
  return o(t, a), t;
}(sr);
ur = function(callback) {
  function init(row, value) {
    r(this, init);
    var that = s(this, callback.call(this, row, value));
    return that.numberOfTiles = 0, that.tileDisplayDuration = 0, that.currentDisplayTime = 0, that.currentTile = 0, that.tilesX = 0, that.tilesY = 0, that.random = false, that._interval = 0, that._intervalTime = 0, that._parse(value), that._resetTexture(), that;
  }
  return o(init, callback), init.prototype._parse = function(s) {
    if (s.scroll && (this.start.offset[0] = s.scroll[0], this.start.offset[1] = s.scroll[1]), s.multiFramesAnim) {
      var tilesX = s.multiFramesAnim.tilesX;
      var tilesY = s.multiFramesAnim.tilesY;
      this.numberOfTiles = tilesX * tilesY;
      this.tileDisplayDuration = 1 / s.multiFramesAnim.animSpeed || 1;
      this.currentDisplayTime = 0;
      this.currentTile = 0;
      this.tilesX = tilesX;
      this.tilesY = tilesY;
      this.start.repeat[0] = 1 / tilesX;
      this.start.repeat[1] = 1 / tilesY;
      if (void 0 !== s.multiFramesAnim.loop) {
        this._loop = parseInt(s.multiFramesAnim.loop);
      }
      if (void 0 !== s.multiFramesAnim.interval) {
        this._interval = parseInt(s.multiFramesAnim.interval);
      }
      if (void 0 !== s.multiFramesAnim.random) {
        this.random = !!s.multiFramesAnim.random;
      }
    }
  }, init.prototype.update = function(type) {
    if (this._isRunning) {
      if (this._intervalTime > 0) {
        this._intervalTime -= type;
      } else {
        this.currentDisplayTime += type * this.timeScale;
        for (; this.currentDisplayTime > this.tileDisplayDuration;) {
          if (this.currentDisplayTime -= this.tileDisplayDuration, this.currentTile++, this.currentTile == this.numberOfTiles && (this.currentTile = 0, this._loop--, this._intervalTime = this._interval), this._loop > 0) {
            var gid = this.random ? Math.floor(Math.random() * this.numberOfTiles) : this.currentTile;
            var x = gid % this.tilesX;
            this.uv.offset.x = x / this.tilesX;
            var y = Math.floor(gid / this.tilesX);
            this.uv.offset.y = y / this.tilesY;
            this.updateUvMatrix();
          } else {
            this._isRunning = false;
            this._callback();
          }
        }
      }
    }
  }, init;
}(sr);
cr = function(t) {
  function a(prev, value) {
    r(this, a);
    var $scope = s(this, t.call(this, prev, value));
    return $scope.animation = {
      offset : [0, 0],
      scale : 0,
      rotation : 0,
      offsetRandom : [0, 0],
      scaleRandom : 0,
      rotationRandom : 0,
      currentScaleWithoutRandom : 1,
      offsetLoop : 1 / 0,
      scaleLoop : 1 / 0,
      rotationLoop : 1 / 0,
      offsetInterval : 0,
      scaleInterval : 0,
      rotationInterval : 0,
      offsetIntervalTime : 0,
      scaleIntervalTime : 0,
      rotationIntervalTime : 0
    }, $scope._parse(value), $scope._resetTexture(), $scope;
  }
  return o(a, t), a.prototype._parse = function(params) {
    if (params.scroll) {
      this.start.offset[0] = params.scroll[0];
      this.start.offset[1] = params.scroll[1];
    }
    var processNameMatches = params.scale || params.repeat;
    if (processNameMatches) {
      if (Array.isArray(processNameMatches)) {
        this.start.repeat[0] = 1 / processNameMatches[0];
        this.start.repeat[1] = 1 / processNameMatches[1];
      } else {
        this.start.repeat[0] = 1 / processNameMatches;
        this.start.repeat[1] = 1 / processNameMatches;
      }
      this.animation.currentScaleWithoutRandom = 1 / this.start.repeat[0];
    }
    if (params.scrollAnim) {
      if (void 0 !== params.scrollAnim.speed) {
        this.animation.offset[0] -= params.scrollAnim.speed[0];
        this.animation.offset[1] -= params.scrollAnim.speed[1];
        if (void 0 !== params.scrollAnim.T && void 0 !== params.scrollAnim.A) {
          this.animation.offsetRandom[0] = 0 == params.scrollAnim.T[0] ? 0 : params.scrollAnim.A[0] / params.scrollAnim.T[0];
          this.animation.offsetRandom[1] = 0 == params.scrollAnim.T[1] ? 0 : params.scrollAnim.A[1] / params.scrollAnim.T[1];
        }
        if (void 0 !== params.scrollAnim.loop) {
          this.animation.offsetLoop = parseInt(params.scrollAnim.loop);
        }
        if (void 0 !== params.scrollAnim.interval) {
          this.animation.offsetInterval = parseFloat(params.scrollAnim.interval);
        }
      } else {
        this.animation.offset[0] -= params.scrollAnim[0];
        this.animation.offset[1] -= params.scrollAnim[1];
      }
    }
    if (params.scaleAnim) {
      if (void 0 !== params.scaleAnim.speed) {
        this.animation.scale += params.scaleAnim.speed;
        if (void 0 !== params.scaleAnim.T && void 0 !== params.scaleAnim.A) {
          this.animation.scaleRandom = params.scaleAnim.A / params.scaleAnim.T;
        }
        if (void 0 !== params.scaleAnim.loop) {
          this.animation.scaleLoop = Number(params.scaleAnim.loop);
        }
        if (void 0 !== params.scaleAnim.interval) {
          this.animation.scaleInterval = parseFloat(params.scaleAnim.interval);
        }
      } else {
        this.animation.scale += params.scaleAnim;
      }
    }
    if (params.rotateAnim) {
      if (void 0 !== params.rotateAnim.speed) {
        this.animation.rotation += params.rotateAnim.speed / 180 * Math.PI;
        if (void 0 !== params.rotateAnim.T && void 0 !== params.rotateAnim.A) {
          this.animation.rotationRandom = params.rotateAnim.A / params.rotateAnim.T;
        }
        if (void 0 !== params.rotateAnim.loop) {
          this.animation.rotationLoop = Number(params.rotateAnim.loop);
        }
        if (void 0 !== params.rotateAnim.interval) {
          this.animation.rotationInterval = parseFloat(params.rotateAnim.interval);
        }
      } else {
        this.animation.rotation += params.rotateAnim / 180 * Math.PI;
      }
    }
  }, a.prototype.update = function(n) {
    if (this._isRunning) {
      var object = this.uv;
      var o = this.start;
      var self = this.animation;
      if (self.offsetIntervalTime > 0) {
        self.offsetIntervalTime -= n;
        object.offset.x = o.offset[0];
        object.offset.y = o.offset[1];
      } else {
        object.offset.x += self.offset[0] * n * this.timeScale * (1 + (2 * Math.random() - 1) * self.offsetRandom[0]);
        object.offset.y += self.offset[1] * n * this.timeScale * (1 + (2 * Math.random() - 1) * self.offsetRandom[1]);
        for (; object.offset.x > o.offset[0] + 1;) {
          object.offset.x -= 1;
          self.offsetLoop--;
          self.offsetIntervalTime = self.offsetInterval;
        }
        for (; object.offset.x < o.offset[0] - 1;) {
          object.offset.x += 1;
          self.offsetLoop--;
          self.offsetIntervalTime = self.offsetInterval;
        }
        for (; object.offset.y > o.offset[1] + 1;) {
          object.offset.y -= 1;
        }
        for (; object.offset.y < o.offset[1] - 1;) {
          object.offset.y += 1;
        }
        if (self.offsetLoop <= 0) {
          this._isRunning = false;
          object.offset.x = o.offset[0];
          object.offset.y = o.offset[1];
        }
      }
      if (self.scaleIntervalTime > 0) {
        self.scaleIntervalTime -= n;
        object.repeat.fromArray(o.repeat);
      } else {
        if (0 !== self.scale) {
          var dt = self.scale * n * this.timeScale;
          var padding2 = dt * (1 + (2 * Math.random() - 1) * self.scaleRandom);
          var width = 1 / object.repeat.x + padding2;
          var height = 1 / object.repeat.y + padding2;
          this.animation.currentScaleWithoutRandom += dt;
          for (; this.animation.currentScaleWithoutRandom > 1;) {
            this.animation.currentScaleWithoutRandom -= 1;
            self.scaleLoop--;
            self.scaleIntervalTime = self.scaleInterval;
          }
          for (; this.animation.currentScaleWithoutRandom <= 0;) {
            this.animation.currentScaleWithoutRandom += 1;
            self.scaleLoop--;
            self.scaleIntervalTime = self.scaleInterval;
          }
          for (; width > 1;) {
            width = width - 1;
            height = height - 1;
          }
          for (; width <= 0;) {
            width = width + 1;
            height = height + 1;
          }
          object.repeat.set(1 / width, 1 / height);
          if (self.scaleLoop <= 0) {
            this._isRunning = false;
            object.repeat.fromArray(o.repeat);
          }
        }
      }
      if (self.rotationIntervalTime > 0) {
        self.rotationIntervalTime -= n;
        object.rotation = o.rotation;
      } else {
        object.rotation += self.rotation * n * this.timeScale * (1 + (2 * Math.random() - 1) * self.rotationRandom);
        for (; object.rotation > o.rotation + tr;) {
          object.rotation -= tr;
          self.rotationLoop--;
          self.rotationIntervalTime = self.rotationInterval;
        }
        for (; object.rotation < o.rotation - tr;) {
          object.rotation += tr;
          self.rotationLoop--;
          self.rotationIntervalTime = self.rotationInterval;
        }
        if (self.rotationLoop <= 0) {
          this._isRunning = false;
          object.rotation = o.rotation;
        }
      }
      if (!(0 === self.rotation && 0 === self.scale && 1 === object.repeat.x && 1 === object.repeat.y)) {
        object.center.set(.5, .5);
      }
      this.updateUvMatrix();
    }
  }, a.prototype.play = function() {
    var value = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1 / 0;
    var evCfg = arguments[1];
    this.animation.offsetLoop = value;
    this.animation.scaleLoop = value;
    this.animation.rotationLoop = value;
    this.animation.offsetIntervalTime = 0;
    this.animation.scaleIntervalTime = 0;
    this.animation.rotationIntervalTime = 0;
    this.animation.currentScaleWithoutRandom = 1 / this.start.repeat[0];
    t.prototype.play.call(this, value, evCfg);
  }, a;
}(sr);
hr = function() {
  function callback(o, done) {
    r(this, callback);
    this.object = null;
    this.app = null;
    this.param = o;
    this.callback = done;
    this.loadingBox = null;
  }
  return callback.prototype._createLoadingBox = function(opt, data) {
    if (!opt.app.options.showLoadingBox || !data) {
      return false;
    }
    var width = data[0];
    var height = data[2];
    var depth = data[1];
    var geometry = new THREE.BoxGeometry(width, height, depth, 1, 1, 1);
    var wheelAxisMat = new THREE.MeshPhongMaterial({
      color : 2200782,
      transparent : true
    });
    return this.loadingBox = new THREE.Mesh(geometry, wheelAxisMat), this.loadingBox.material.opacity = .01, this.loadingBox.position.y += height / 2, this.loadingBox.userData.size = [width, height, depth], this.loadingBox.userData.curProgress = .01, opt.pickable || (this.loadingBox.userData.skipPick = true), this.loadingBox.userData.skipStyle = true, true;
  }, callback.prototype.loadComplete = function(data, event, done) {
    event.model = data;
    var key = data.cloneNode();
    this.object.setupNode(key, false);
    this.object.synPickable();
    this.object._processModel(false, true);
    var parent = event.nodeReady;
    if (parent) {
      parent.call(this.object, {
        object : this.object
      });
    }
    if (null != done) {
      done();
    }
    this.object.removeControl(this);
  }, callback.prototype.loadModelFromURL = function(options, url) {
    var that = this;
    var result = this.object;
    var path = this.app.confirmURL(options.url);
    result._url = path._trimRight("/");
    result.setupUserData(options);
    options.force = true;
    result.setupParent(options);
    options.skipSetupParent = true;
    result.setupTranslation(options);
    result.node.updateMatrixWorld();
    var loader = this.app.modelResource;
    var file = loader.get(path);
    if (file) {
      this.loadComplete(file, options, url);
    } else {
      loader.download(path, function(params) {
        var response = params.size;
        if (response && that._createLoadingBox(result, response)) {
          result.node.add(that.loadingBox);
        }
        result._loadingBoxSize = response;
        result._extensionsFile = params.extensionsfile || null;
        var context = options.nodeReady;
        if (context) {
          context.call(result, {
            object : result,
            jsonData : params
          });
        }
      }, function(o) {
        if (result.destroyed) {
          return false;
        }
        var malakh = that.loadingBox;
        return malakh && (o.loadingBox = malakh, malakh.removeBySelf()), options.position = that.object.position, options.angles = that.object.angles, options.scale = that.object.scale, Utils.backupValue(options, "nodeReady"), options.nodeReady = null, that.loadComplete(o, options, function() {
          if (url) {
            url();
          }
        }), Utils.revertValue(options, "nodeReady"), true;
      }, function(helper) {
        var progress = Math.max(.01, helper.progress);
        var child = that.loadingBox;
        if (child && child.material) {
          child.userData.curProgress = Math.max(child.userData.curProgress, progress);
          child.material.opacity = child.userData.curProgress;
        }
        var t = options.progress;
        if (t) {
          t.call(result, {
            object : result,
            progress : progress
          });
        }
        that.object.trigger("progress", {
          object : result,
          progress : progress
        });
      }, function(root) {
        var callback = options.error;
        if (callback) {
          return callback(root, that.object), true;
        }
        Utils.error(root);
        that.object.trigger("error", {
          url : path
        });
      });
    }
  }, callback.prototype.onAdd = function(options) {
    this.object = options;
    this.app = options.app;
    this.loadModelFromURL(this.param, this.callback);
    delete this.param;
    delete this.callback;
  }, callback;
}();
pr = function(a) {
  function d(row) {
    return r(this, d), s(this, a.call(this, row));
  }
  return o(d, a), d.prototype.isBlockMouseOffEvent = function(item) {
    return !!this.isChildOf(item);
  }, d.prototype.setupTextureAnimations = function() {
    if (nr.hasTextureAnimation(this.node)) {
      this.addControl(new nr(true), "texAnimControl");
    }
  }, d.prototype.customSetup = function(bst) {
  }, d.prototype.setupResources = function(prevProps) {
    a.prototype.setupResources.call(this, prevProps);
    this.setupTextureAnimations();
  }, d.prototype.loadFromURL = function(url, format) {
    this.addControl(new hr(url, format));
  }, d.prototype._loadResource = function(callback) {
    this.query(".CombinedObject|.Facade", false).forEach(function(srUtils) {
      srUtils.loadResource();
    });
    a.prototype._loadResource.call(this, callback);
  }, d.prototype._unloadResource = function(key_event) {
    this.query(".CombinedObject", false).forEach(function(resMgr) {
      resMgr.unloadResource();
    });
    a.prototype._unloadResource.call(this, key_event);
  }, n(d, [{
    key : "isFacade",
    get : function() {
      return true;
    }
  }, {
    key : "isOutdoors",
    get : function() {
      return true;
    }
  }, {
    key : "building",
    get : function() {
      return this.parents.query(".Building")[0];
    }
  }]), d;
}(BaseObject);
dr = function() {
  function self() {
    var config = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    r(this, self);
    this.object = null;
    this.node = config.node;
    this.animations = config.animations;
    this.animationClips = null;
    this.animationPlayingActions = [];
    this.animationActions = [];
    this.animationMixer = null;
    this._lastState = null;
  }
  return self.prototype.init = function(init) {
    var e = this;
    this.animationClips = init;
    this.animationMixer = new THREE.AnimationMixer(this.node);
    var i = 0;
    for (; i < this.animationClips.length; i++) {
      var r = this.animationMixer.clipAction(this.animationClips[i]);
      this.animationActions.push(r);
    }
    this.animationMixer.addEventListener("loop", function(canCreateDiscussions) {
    });
    this.animationMixer.addEventListener("finished", function(data) {
      var image = data.action;
      image.setEffectiveTimeScale(0);
      var n = image.getClip().name;
      var i = 0;
      for (; i < e.animationPlayingActions.length; i++) {
        if (e.animationPlayingActions[i].action.getClip().name === n) {
          e.animationPlayingActions[i].state = "stop";
        }
      }
      var $ = image.complete;
      if ($) {
        Utils.timer.setTimeout(function() {
          $.call(e.object, n);
        }, 0);
      }
    });
  }, self.prototype.onAdd = function(options) {
    this.object = options;
    this.node = this.node || this.object.node;
    this.app = options.app;
    this.init(this.animations);
    delete this.animations;
  }, self.prototype.onRemove = function() {
    if (this.animationMixer) {
      this.animationClips = null;
      this.animationActions = [];
      this.animationMixer = null;
    }
  }, self.prototype.onUpdate = function(e) {
    var system = this.animationMixer;
    if (system) {
      var options = system.isRunning();
      if (system.update(e), this.app.root.static && (options && this.object.visible || this._lastState != options)) {
        var box = this.object.boundingBox;
        if (this.app.camera.frustum.intersectsBox(box)) {
          this.object.node._synMatrixWorld();
        }
      }
      return this.object.visible && (this.app.needUpdate = options), this._lastState = options, options;
    }
    return false;
  }, self.prototype.containAnimation = function(screenName) {
    if (this.animationClips) {
      var tna = 0;
      for (; tna < this.animationClips.length; tna++) {
        if (this.animationClips[tna].name === screenName) {
          return true;
        }
      }
    }
    return false;
  }, self.prototype._updatePlayingAnimation = function(action, duration) {
    var i = 0;
    for (; i < this.animationPlayingActions.length; ++i) {
      if (this.animationPlayingActions[i].action == action) {
        return this.animationPlayingActions[i].state = "play", void(this.animationPlayingActions[i].duration = duration);
      }
    }
    this.animationPlayingActions.push({
      action : action,
      duration : duration
    });
  }, self.prototype.pauseAnimation = function(name, pause) {
    var monitoringResult = this;
    if (name) {
      if (Utils.isArray(name)) {
        name.forEach(function(AnimName) {
          var i = 0;
          for (; i < monitoringResult.animationPlayingActions.length; i++) {
            var event = monitoringResult.animationPlayingActions[i].action;
            if (AnimName == event.getClip().name) {
              event.state = "paused";
              event.paused = pause;
            }
          }
        });
      } else {
        if (Utils.isString(name)) {
          i = 0;
          for (; i < this.animationPlayingActions.length; i++) {
            var event = this.animationPlayingActions[i].action;
            if (name == event.getClip().name) {
              event.state = "paused";
              event.paused = pause;
            }
          }
        }
      }
    } else {
      var i = 0;
      for (; i < this.animationPlayingActions.length; ++i) {
        this.animationPlayingActions[i].state = "paused";
        this.animationPlayingActions[i].action.paused = pause;
      }
    }
  }, self.prototype.stopAnimation = function(val) {
    var SortedStatements = this;
    if (val) {
      if (Utils.isArray(val)) {
        val.forEach(function(AnimName) {
          var i = 0;
          for (; i < SortedStatements.animationPlayingActions.length; i++) {
            var act = SortedStatements.animationPlayingActions[i].action;
            if (AnimName == act.getClip().name) {
              act.stop();
              SortedStatements.animationPlayingActions.splice(i, 1);
              i--;
            }
          }
        });
      } else {
        if (Utils.isString(val)) {
          i = 0;
          for (; i < this.animationPlayingActions.length; i++) {
            var act = this.animationPlayingActions[i].action;
            if (val == act.getClip().name) {
              act.stop();
              this.animationPlayingActions.splice(i, 1);
              i--;
            }
          }
        }
      }
    } else {
      var i = 0;
      for (; i < this.animationPlayingActions.length; ++i) {
        this.animationPlayingActions[i].action.stop();
      }
      this.animationPlayingActions = [];
    }
  }, self.prototype.setAnimationDuration = function(label, value) {
    var clip = THREE.AnimationClip.findByName(this.animationClips, label);
    if (!clip) {
      return THING.Utils.error("The '" + label + "' animation is not existing"), false;
    }
    var action = this.animationMixer.clipAction(clip);
    if (!action) {
      return false;
    }
    action.setDuration(value);
    var i = 0;
    for (; i < this.animationPlayingActions.length; ++i) {
      if (this.animationPlayingActions[i].action == action) {
        this.animationPlayingActions[i].duration = value;
      }
    }
    return true;
  }, self.prototype.getAnimationDuration = function(name) {
    var aggFuncNames = THREE.AnimationClip.findByName(this.animationClips, name);
    if (!aggFuncNames) {
      return THING.Utils.error("The '" + name + "' animation is not existing"), 0;
    }
    var key = this.animationMixer.clipAction(aggFuncNames);
    if (!key) {
      return 0;
    }
    var i = 0;
    for (; i < this.animationPlayingActions.length; ++i) {
      if (this.animationPlayingActions[i].action == key) {
        return this.animationPlayingActions[i].duration;
      }
    }
    return 0;
  }, self.prototype.playAnimation = function(property, options) {
    var anims = (options = options || {}).speed || 1;
    var sgn = Utils.parseValue(options.reverse, false);
    var on = Utils.parseLoopType(options.loopType || options.loop);
    var value = options.loopTimes || 1 / 0;
    var left = options.frames || null;
    var complete = options.complete;
    var clip = THREE.AnimationClip.findByName(this.animationClips, property);
    if (!clip) {
      return false;
    }
    var action = this.animationMixer.clipAction(clip);
    if (!action) {
      return false;
    }
    action.reset();
    var y = clip.duration / anims;
    var definedVar = action.isRunning();
    if (sgn && on == THREE.LoopOnce && (value = definedVar ? 0 : 1, on = THREE.LoopRepeat), action.complete = complete, action.paused = false, action.clampWhenFinished = true, action.setEffectiveWeight(1), action.setDuration(sgn ? -y : y), action.setLoop(on, value), left) {
      var t = 0;
      var indentationLength = 1;
      if (Utils.isArray(left)) {
        t = left[0];
        indentationLength = left.length > 1 ? left[1] : 1;
      } else {
        if (Utils.isNumber(left)) {
          t = left;
        } else {
          THING.Utils.error("animation frames is invalid");
        }
      }
      action.warp(t, indentationLength, y);
    } else {
      action.stopWarping();
    }
    return definedVar || (action.isScheduled() ? action.reset() : action.play(), this._updatePlayingAnimation(action, y)), this.onUpdate(0), true;
  }, self.prototype.isPlayingAnimation = function(container) {
    return !!this.animationMixer && (container ? this.animationMixer.isRunning(container) : !!this.animationPlayingActions.length);
  }, n(self, [{
    key : "animationNames",
    get : function() {
      var e = [];
      if (this.animationClips) {
        var tna = 0;
        for (; tna < this.animationClips.length; tna++) {
          e.push(this.animationClips[tna].name);
        }
      }
      return e;
    }
  }]), self;
}();
fr = function(e) {
  function d(row) {
    r(this, d);
    var element = s(this, e.call(this, row));
    return element._url = "", element._animationControls = null, element;
  }
  return o(d, e), d.prototype.loadModelResource = function(b) {
    var daturl = (b = b || {}).url;
    if (daturl) {
      var nsdisp;
      this._resettingStyle = true;
      nsdisp = this.dataToRecover ? this.dataToRecover.style : {
        color : this.style.color,
        opacity : this.style.opacity,
        image : this.style.image
      };
      this.style.color = null;
      this.style.opacity = null;
      this.style.image = null;
      delete this._resettingStyle;
      if (this._url) {
        this.app.modelResource.unload(this._url);
        this._url = null;
      }
      this.unloadResource(false);
      b.skipSetupParent = true;
      var model = this;
      this.loadFromURL(b, function() {
        if (model._initBoxSize = null, model.customSetup(b), model.setupResources({}), nsdisp) {
          var n;
          for (n in nsdisp) {
            model.style[n] = nsdisp[n];
          }
        }
        if (model.static) {
          model.node._synMatrixWorld();
        }
        var t = b.complete;
        if (t) {
          t.call(model, {
            object : model,
            url : daturl
          });
        }
      });
    }
  }, d.prototype.setupCustomKeys = function(val) {
    var t = Utils.parseValue(val.ON_IU, "oniu");
    var volume = Utils.parseValue(val.SJGN_IHT, "sjgniht");
    var boilerPlate = Utils.parseValue(val.IJ_EKOU_NUOY, "ijekounuoy");
    var n = Utils.parseValue(val.RE_ISRAT, "reisrat");
    if (!("naijil" != t && "NA_IJ_IL" != t)) {
      this.userData.bindFeatureOn = t;
    }
    if (!("auhnujuw" != volume && "AU_HN_UJ_UW" != volume)) {
      this.userData.SightTestOn = volume;
    }
    if (!("nahoanehc" != boilerPlate && "NA_HO_AN_EHC" != boilerPlate)) {
      this.userData.LoopControlOn = boilerPlate;
    }
    if (!("eilam" != n && "EI_LAM" != n)) {
      this.userData.bindFeatureOn = n;
    }
  }, d.prototype.setupAnimations = function(obj) {
    var container = this;
    if (this._animationControls) {
      this._animationControls.forEach(function(fs) {
        container.removeControl(fs);
      });
      this._animationControls = null;
    }
    var d = obj.animations;
    if (d) {
      d = [{
        node : this.node,
        data : d
      }];
    } else {
      var model = obj.model;
      if (model) {
        if (model.animations) {
          d = [{
            node : this.node,
            data : model.animations
          }];
        } else {
          if (model.models) {
            var start = function(screenPoint, i) {
              var subwiki = null;
              return screenPoint.traverseBranch(function(e) {
                if (e.isLOD) {
                  return subwiki = e.children[i], false;
                }
              }), subwiki;
            };
            d = [];
            var i = 0;
            for (; i < model.models.length; i++) {
              var a = model.models[i];
              d.push({
                node : start(this.node, i),
                data : a.animations
              });
            }
          }
        }
      }
    }
    if (d && d.length) {
      this._animationControls = [];
      d.forEach(function(call) {
        var selector = new dr({
          node : call.node,
          animations : call.data
        });
        container.addControl(selector);
        container._animationControls.push(selector);
      });
      var value = obj.animation;
      if (value) {
        this.playAnimation(value);
      }
    }
  }, d.prototype.setupTextureAnimations = function() {
    if (nr.hasTextureAnimation(this.node)) {
      this.addControl(new nr, "texAnimControl");
    }
  }, d.prototype.setupRoomOwner = function($rootScope) {
    var originalBackFunction = $rootScope.belongRoomUserID;
    if (originalBackFunction) {
      this._belongRoomUserID = originalBackFunction;
    }
  }, d.prototype.customSetup = function(b) {
    this.setupAnimations(b);
    this.setupCustomKeys(b);
    this.setupRoomOwner(b);
  }, d.prototype.setupResources = function(prevProps) {
    e.prototype.setupResources.call(this, prevProps);
    this.setupTextureAnimations(prevProps);
  }, d.prototype.loadFromURL = function(url, format) {
    this.addControl(new hr(url, format), "__ModelResourceControl__");
  }, d.prototype.containAnimation = function(screenName) {
    if (this._animationControls && this._animationControls.length) {
      var layer_i = 0;
      for (; layer_i < this._animationControls.length; layer_i++) {
        if (this._animationControls[layer_i].containAnimation(screenName)) {
          return true;
        }
      }
    }
    return false;
  }, d.prototype.playAnimation = function(o) {
    if (o = o || {}, this.loaded) {
      if (Utils.parseValue(o.stopAllAnimation, true) && this._stopAnimation(), Utils.isString(o)) {
        return this._stopAnimation(o), void this._playAnimation(o, null);
      }
      var name = o.name;
      if (Utils.isString(name)) {
        return this._stopAnimation(name), void this._playAnimation(name, o);
      }
      if (Utils.isArray(name) && name.length) {
        if (1 == name.length) {
          return this._stopAnimation(name[0]), void this._playAnimation(name[0], o);
        }
        o = Utils.cloneObject(o);
        var v = Utils.parseArrayArgument(name, o, "speed");
        var opts = Utils.parseArrayArgument(name, o, "reverse");
        var result = Utils.parseArrayArgument(name, o, "loop");
        var options = Utils.parseArrayArgument(name, o, "loopType");
        var data = Utils.parseArrayArgument(name, o, "loopTimes");
        var group = Utils.parseArrayArgument(name, o, "frames");
        var i = 0;
        for (; i < name.length; i++) {
          Utils.getArrayArgumentValue(o, "speed", v, i);
          Utils.getArrayArgumentValue(o, "reverse", opts, i);
          Utils.getArrayArgumentValue(o, "loop", result, i);
          Utils.getArrayArgumentValue(o, "loopType", options, i);
          Utils.getArrayArgumentValue(o, "loopTimes", data, i);
          Utils.getArrayArgumentValue(o, "frames", group, i);
          this._playAnimation(name[i], o);
        }
      }
    } else {
      this.waitCommands.push({
        type : "PlayObjectAnimation",
        object : this,
        params : o
      });
    }
  }, d.prototype._stopAnimation = function(name) {
    if (this._animationControls) {
      this._animationControls.forEach(function(elem) {
        elem.stopAnimation(name);
      });
    }
  }, d.prototype._playAnimation = function(id, restart) {
    if (this._animationControls) {
      this._animationControls.forEach(function(sprite) {
        sprite.playAnimation(id, restart);
      });
    }
    this.tickable = true;
  }, d.prototype.pauseAnimation = function(pause) {
    if (this._animationControls) {
      this._animationControls.forEach(function(self) {
        self.pauseAnimation(pause, true);
      });
    }
    if (this.static) {
      this.node._synMatrixWorld();
    }
    if (this.app.rendererManager) {
      this.app.rendererManager.needUpdate = true;
    }
  }, d.prototype.resumeAnimation = function(resume) {
    if (this._animationControls) {
      this._animationControls.forEach(function(self) {
        self.pauseAnimation(resume, false);
      });
    }
    this.tickable = true;
  }, d.prototype.stopAnimation = function(data) {
    if (this._animationControls) {
      this._animationControls.forEach(function(SpriteSpin) {
        SpriteSpin.stopAnimation(data);
      });
    }
    if (this.static) {
      this.node._synMatrixWorld();
    }
    if (this.app.rendererManager) {
      this.app.rendererManager.needUpdate = true;
    }
  }, d.prototype.setAnimationDuration = function(value, duration) {
    if (this._animationControls) {
      this._animationControls.forEach(function(dragger) {
        dragger.setAnimationDuration(value, duration);
      });
    }
  }, d.prototype.getAnimationDuration = function(name) {
    if (this._animationControls && this._animationControls.length) {
      var layer_i = 0;
      for (; layer_i < this._animationControls.length; layer_i++) {
        var max = this._animationControls[layer_i].getAnimationDuration(name);
        if (max) {
          return max;
        }
      }
    }
    return 0;
  }, d.prototype.isPlayingAnimation = function(virtualCube) {
    if (this._animationControls && this._animationControls.length) {
      var layer_i = 0;
      for (; layer_i < this._animationControls.length; layer_i++) {
        if (this._animationControls[layer_i].isPlayingAnimation(virtualCube)) {
          return true;
        }
      }
    }
    return false;
  }, d.prototype.toJSON = function() {
    var image = e.prototype.toJSON.call(this);
    return image.type = "Thing", this._url && (image.url = this._url), image;
  }, n(d, [{
    key : "isThing",
    get : function() {
      return true;
    }
  }, {
    key : "animationNames",
    get : function() {
      if (this._animationControls && this._animationControls.length) {
        var e = [];
        var layer_i = 0;
        for (; layer_i < this._animationControls.length; layer_i++) {
          this._animationControls[layer_i].animationNames.forEach(function(t) {
            if (-1 === e.indexOf(t)) {
              e.push(t);
            }
          });
        }
        return e;
      }
      return [];
    }
  }, {
    key : "url",
    get : function() {
      return this._url;
    },
    set : function(v) {
      this.loadModelResource({
        url : v
      });
    }
  }, {
    key : "isOutdoors",
    get : function() {
      var parent = this._parent;
      for (; parent; parent = parent._parent) {
        if (parent.isBuilding) {
          return false;
        }
      }
      return true;
    }
  }, {
    key : "floor",
    get : function() {
      return this.parents.query(".Floor")[0];
    }
  }, {
    key : "building",
    get : function() {
      return this.parents.query(".Building")[0];
    }
  }, {
    key : "room",
    get : function() {
      var info = this.floor;
      if (info) {
        var current = info.rooms;
        var object = [];
        var install = function(name) {
          var count = current[name];
          var lines = function(result) {
            var library = result._floorNode;
            if (!library) {
              return null;
            }
            return library.getMeshes();
          }(count);
          if (lines) {
            lines.forEach(function(data) {
              data.__room = count;
            });
            object.push.apply(object, lines);
          }
        };
        var value = 0;
        for (; value < current.length; value++) {
          install(value);
        }
        var ray = new THREE.Raycaster;
        var s = new (Function.prototype.bind.apply(THREE.Vector3, [null].concat(this.position)));
        var newPos = new (Function.prototype.bind.apply(THREE.Vector3, [null].concat(info.up)));
        s.add(newPos.clone().multiplyScalar(100));
        newPos.multiplyScalar(-1);
        ray.ray.origin.copy(s);
        ray.ray.direction.copy(newPos);
        var r = ray.intersectObjects(object);
        var m = void 0;
        return r.length && (m = r[0].object.__room), object.forEach(function(data) {
          delete data.__room;
        }), m;
      }
    }
  }, {
    key : "_temp_roomID",
    get : function() {
      return this._belongRoomUserID;
    }
  }]), d;
}(BaseObject);
mr = function() {
  function t(o) {
    r(this, t);
    this._obj = o;
    this._color = null;
  }
  return n(t, [{
    key : "batchObject",
    get : function() {
      return this._obj._batchObject;
    }
  }, {
    key : "color",
    set : function(v) {
      this._color = v ? Utils.parseColor(v) : null;
      if (this.batchObject) {
        this.batchObject._updateAttributes(this._obj, 8);
      }
    },
    get : function() {
      return this._color ? this._color.toHexString() : this.batchObject ? this.batchObject.style.color : null;
    }
  }]), t;
}();
gr = new THREE.Color, vr = 1, yr = 2, br = 4, _r = 8, xr = 16, Er = 1048575, wr = null;
var Tr = function(callback) {
  function e(row) {
    r(this, e);
    var container = s(this, callback.call(this, row));
    return container._initMeshes = [], container._instancedMeshes = [], container._maxBatchNum = 64, container._batchNum = 0, container._deletedIndexs = [], container._instancedAttributes = {}, container;
  }
  return o(e, callback), e.prototype._beforeSetup = function(targetRadian) {
    this._maxBatchNum = void 0 !== targetRadian.initBatchNum ? targetRadian.initBatchNum : 64;
    this._isFilp = void 0 !== targetRadian.isFilp && targetRadian.isFilp;
    this._instancedAttributes.instancePosition = new THREE.InstancedBufferAttribute(new Float32Array(3 * this._maxBatchNum), 3);
    this._instancedAttributes.instanceQuaternion = new THREE.InstancedBufferAttribute(new Float32Array(4 * this._maxBatchNum), 4);
    this._instancedAttributes.instanceScale = new THREE.InstancedBufferAttribute(new Float32Array(3 * this._maxBatchNum), 3);
    this._instancedAttributes.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(3 * this._maxBatchNum), 3);
    this._instancedAttributes.instanceId = new THREE.InstancedBufferAttribute(new Float32Array(1 * this._maxBatchNum), 1);
  }, e.prototype.destroy = function() {
    var $ = this;
    callback.prototype.destroy.call(this);
    this._initMeshes.forEach(function(name) {
      $.app.resourceManager.unload(name);
    });
  }, e.prototype._initInstancedMeshes = function() {
    var e = this;
    var node = this.node;
    if (this._lodNode) {
      node = this._lodNode.levels[-1 !== this._lodLevel ? this._lodLevel : 0].object;
    }
    this._initMeshes = node.getMeshes();
    this._instancedMeshes = this._initMeshes.map(function(t) {
      return e._createInstancedMesh(t);
    });
    this.node.children.slice(0).forEach(function(t) {
      return e.node.remove(t);
    });
    this._instancedMeshes.forEach(function(t) {
      return e.node.add(t);
    });
    if (this.static) {
      this.node._synMatrixWorld();
    }
    this._extensionsFile = null;
  }, e.prototype._createInstancedMesh = function(result) {
    var self = new THREE.InstancedBufferGeometry;
    var name;
    for (name in self.instanceCount = this._batchNum, result.geometry.index && (self.index = result.geometry.index), result.geometry.attributes) {
      if ("position" === name || "normal" === name) {
        self.addAttribute(name, result.geometry.attributes[name].clone());
      } else {
        self.addAttribute(name, result.geometry.attributes[name]);
      }
    }
    var index;
    for (index in this._instancedAttributes) {
      self.addAttribute(index, this._instancedAttributes[index]);
    }
    self.applyMatrix4(result.getMatrixFromRoot(this.node));
    var bumpMapEnabled = (result.isMesh && result.getMatrixFromRoot(this.node).determinant() < 0) ^ this._isFilp;
    if (bumpMapEnabled) {
      var crossfilterable_layers = self.attributes.normal.array;
      var layer_i = 0;
      for (; layer_i < crossfilterable_layers.length; layer_i++) {
        crossfilterable_layers[layer_i] = -crossfilterable_layers[layer_i];
      }
    }
    if (result.geometry.groups && result.geometry.groups.length > 0) {
      self.groups = result.geometry.groups;
    }
    var material = void 0;
    if (Array.isArray(result.material)) {
      material = result.material.map(function(options) {
        var material = options.clone();
        return material.vertexColors = true, material.defines = void 0 !== options.defines ? JSON.parse(JSON.stringify(options.defines)) : {}, material.defines.INSTANCED = "", material.side !== THREE.BackSide && material.side !== THREE.FrontSide || (material.side = bumpMapEnabled ? (material.side + 1) % 2 : material.side), material;
      });
    } else {
      (material = result.material.clone()).vertexColors = true;
      material.defines = void 0 !== result.material.defines ? JSON.parse(JSON.stringify(result.material.defines)) : {};
      material.defines.INSTANCED = "";
      if (!(material.side !== THREE.BackSide && material.side !== THREE.FrontSide)) {
        material.side = bumpMapEnabled ? (material.side + 1) % 2 : material.side;
      }
    }
    var object = new THREE.Mesh(self, material);
    return object.userData = {
      skipOutline : true
    }, object.frustumCulled = false, object.customDepthMaterial = (wr || ((wr = new THREE.MeshDepthMaterial({
      depthPacking : THREE.RGBADepthPacking
    })).defines = {
      INSTANCED : ""
    }), wr), object.castShadow = true, object.receiveShadow = true, Utils.isObject(result._cachedTechnique) && (object._cachedTechnique = Utils.cloneObject(result._cachedTechnique, false)), Utils.isObject(result.technique) && (object.technique = Utils.cloneObject(result.technique, false)), object;
  }, e.prototype.isBatchObject = function() {
    return true;
  }, e.prototype._beforeSetupComplete = function(key_event) {
    this._initInstancedMeshes();
    callback.prototype._beforeSetupComplete.call(this, key_event);
  }, e.prototype._allocSubObjectIndex = function() {
    if (this._deletedIndexs.length > 0) {
      return this._deletedIndexs.shift();
    }
    var e = this._batchNum;
    return this._batchNum++, e;
  }, e.prototype.createSubObject = function(k) {
    return k.type = "BatchSubObject", k.parent = k.parent || this, k.batchObject = this, this.app.create(k);
  }, e.prototype._resizeAttributes = function() {
    var index;
    for (index in this._instancedAttributes) {
      var options = this._instancedAttributes[index];
      var m = options.array;
      var data = new m.constructor(this._maxBatchNum * options.itemSize);
      data.set(m);
      options.array = data;
      options.count = data.length / options.itemSize;
      options.resizeDirty = true;
      options.needsUpdate = true;
    }
    var geometryAttribute = this._instancedAttributes.instancePosition;
    this._instancedMeshes.forEach(function(gcFeature) {
      gcFeature.geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
    });
  }, e.prototype._updateAttributes = function(that) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Er;
    var i = that.internalUserData.__attribute_index__BatchObject__;
    if (t & vr) {
      this._instancedAttributes.instancePosition.array.set(that.node.position.toArray(), 3 * i);
      this._instancedAttributes.instancePosition.needsUpdate = true;
    }
    if (t & yr) {
      this._instancedAttributes.instanceQuaternion.array.set(that.node.quaternion.toArray(), 4 * i);
      this._instancedAttributes.instanceQuaternion.needsUpdate = true;
    }
    if (t & br) {
      this._instancedAttributes.instanceScale.array.set(that.node.scale.toArray(), 3 * i);
      this._instancedAttributes.instanceScale.needsUpdate = true;
    }
    if (t & _r) {
      if (that._style) {
        if (that._style.color) {
          gr.set(that._style.color);
        } else {
          gr.setRGB(1, 1, 1);
        }
      } else {
        if (this.style.color) {
          gr.set(this.style.color);
        } else {
          gr.setRGB(1, 1, 1);
        }
      }
      this._instancedAttributes.instanceColor.array.set(gr.toArray(), 3 * i);
      this._instancedAttributes.instanceColor.needsUpdate = true;
    }
    if (t & xr) {
      this._instancedAttributes.instanceId.array[i] = that.node.id;
      this._instancedAttributes.instanceId.needsUpdate = true;
    }
  }, e.prototype._removeAttributes = function(onStr) {
    var value = onStr.internalUserData.__attribute_index__BatchObject__;
    this._instancedAttributes.instanceScale.array.set([1e-9, 1e-9, 1e-9], 3 * value);
    this._instancedAttributes.instanceColor.array.set([0, 0, 0], 3 * value);
    this._instancedAttributes.instanceScale.needsUpdate = true;
    this._instancedAttributes.instanceColor.needsUpdate = true;
    this._deletedIndexs.push(value);
  }, e;
}(fr);
Mr = function(callback) {
  function i(string) {
    r(this, i);
    var container = s(this, callback.call(this, string));
    return container._batchObject = null, container;
  }
  return o(i, callback), i.prototype.isBatchSubObject = function() {
    return true;
  }, i.prototype.setPickable = function(text) {
    var i = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    if (text) {
      this.app.picker.markPickingNode(this.node);
    }
    callback.prototype.setPickable.call(this, text, i);
  }, i.prototype._afterSetupComplete = function(a22) {
    var pageViewData = this;
    if (this._batchObject = a22.batchObject, this._batchObject) {
      this.app.picker.markPickingNode(this.node);
      this.internalUserData.__attribute_index__BatchObject__ = this._batchObject._allocSubObjectIndex();
      if (this._batchObject._batchNum > this._batchObject._maxBatchNum) {
        this._batchObject._maxBatchNum *= 2;
        this._batchObject._resizeAttributes();
      }
      this._batchObject._updateAttributes(this);
      this._batchObject._instancedMeshes.forEach(function(gcFeature) {
        gcFeature.geometry.instanceCount = pageViewData._batchObject._batchNum;
        pageViewData.app.edgesGeometriesManager.synMaxInstancedCount(gcFeature.geometry);
      });
      var name = this;
      this._notifyPositionChange = function() {
        name._batchObject._updateAttributes(name, vr);
      };
      this._notifyAnglesChange = function() {
        name._batchObject._updateAttributes(name, yr);
      };
      this._notifyScalesChange = function() {
        name._batchObject._updateAttributes(name, br);
      };
      this._notifyDestroy = function() {
        name._batchObject._removeAttributes(name);
      };
    } else {
      THING.Utils.error("Please provide batch object to create BatchSubObject");
    }
  }, i;
}(fr);
Cr = function(callback) {
  function e(row) {
    r(this, e);
    var value = s(this, callback.call(this, row));
    return value.sprite = null, value.spriteVisible = true, value.onTop = false, value.progress = 0, value;
  }
  return o(e, callback), e.prototype.canNotQueryFromSelector = function() {
    return true;
  }, e.prototype.customSetup = function(options) {
    var scene = options.scene;
    var i = options.height;
    var d3version = options.onTop;
    var coords = this.app.calcRect();
    this.onTop = d3version;
    var spriteMaterial = new THREE.SpriteMaterial({
      opacity : .8,
      color : 34816,
      transparent : true
    });
    this.sprite = new THREE.Sprite(spriteMaterial);
    this.sprite.scale.set(2 * coords.width, i, 1);
    this.sprite.visible = false;
    this.updatePosition(coords.width, coords.height);
    this.node.add(this.sprite);
    scene.add(this.node);
  }, e.prototype.updatePosition = function(s, e) {
    if (void 0 === s || void 0 === e) {
      var t = this.app.calcRect();
      s = t.width;
      e = t.height;
    }
    var sprite = this.sprite;
    var n = -s / 2;
    var o = this.onTop ? e / 2 - sprite.scale.y / 2 : -e / 2 + sprite.scale.y / 2;
    sprite.position.set(n, o, -10);
  }, e.prototype.updateProgress = function(error) {
    if (!this.sprite) {
      return false;
    }
    if (this.progress == error) {
      return false;
    }
    this.progress = error;
    var foodIconDefinition = this.app.calcRect();
    if (error < 1 && 0 != error) {
      this.sprite.visible = this.spriteVisible;
    } else {
      var frame = this;
      setTimeout(function() {
        if (frame.sprite) {
          frame.sprite.visible = false;
        }
      }, 1e3);
    }
    var xSpeedIncrease = Math.max(1, 2 * foodIconDefinition.width * error);
    return this.sprite.scale.x = xSpeedIncrease, true;
  }, e.prototype.resize = function(e, t) {
    if (this.sprite) {
      this.updatePosition(e, t);
      var xSpeedIncrease = Math.max(1, 2 * e * this.progress);
      this.sprite.scale.x = xSpeedIncrease;
    }
  }, e.prototype.prepare = function() {
    this.sprite.scale.x = 1e-4;
    this.sprite.visible = this.spriteVisible;
  }, n(e, [{
    key : "visible",
    set : function(v) {
      this.spriteVisible = v;
    },
    get : function() {
      return this.spriteVisible;
    }
  }, {
    key : "height",
    set : function(v) {
      this.sprite.scale.y = v;
    },
    get : function() {
      return this.sprite.scale.y;
    }
  }]), e;
}(BaseObject);
var jr = function(callback) {
  function d(row) {
    return r(this, d), s(this, callback.call(this, row));
  }
  return o(d, callback), d.prototype.createMaterial = function(data) {
    if (!data) {
      return new THREE.MeshPhongMaterial({
        color : 2200782
      });
    }
    return data.disableLight ? new THREE.MeshBasicMaterial({
      color : 2200782
    }) : new THREE.MeshPhongMaterial({
      color : 2200782
    });
  }, d.prototype.createGeometry = function(options) {
    return null;
  }, d.prototype.createMesh = function(options) {
    var geometry = this.createGeometry(options);
    if (geometry) {
      var material = this.createMaterial(options.style);
      return new THREE.Mesh(geometry, material);
    }
    return null;
  }, d.prototype.setupStyle = function(radius) {
    callback.prototype.setupStyle.call(this, radius);
    this.style.skipEnvMap = true;
  }, d.prototype.setup = function(style) {
    var obj = this.createMesh(style);
    if (obj) {
      obj.castShadow = true;
      obj.receiveShadow = true;
      var pos = style.center;
      if (pos && "Bottom" == pos) {
        var moveMult = style.height || 1;
        obj.translateY(.5 * moveMult);
      }
      this.node.add(obj);
    }
    callback.prototype.setup.call(this, style);
    this.setupStyle(style);
  }, d.prototype.addPickableGround = function(e) {
    var block = this.app.create({
      type : "Plane",
      width : e,
      height : e,
      visible : false,
      parent : this,
      style : {
        doubleSide : true
      }
    });
    var meshNode = block.node;
    return meshNode.skipBoundingBox(true), meshNode.userData.topNode = true, meshNode.userData.skipOutline = true, meshNode.userData.independent = true, meshNode.userData.alwaysPickable = true, meshNode.canNotQueryFromSelector = true, this.app.objectManager.addInteractableNode(meshNode), block;
  }, d.prototype.pickGroundWorldPosition = function(e, key, value) {
    if (Utils.isArray(key) && void 0 === value) {
      var kv = key;
      key = kv[0];
      value = kv[1];
    }
    var presetItemClicked = this.app.calcRect();
    var wstones = this.app.renderCamera.getRaycaster(key, value, presetItemClicked).intersectObjectForcible(e.node, true);
    return wstones.length ? wstones[0].point.toArray() : null;
  }, d;
}(fr);
Pr = function(a) {
  function i(minutes) {
    r(this, i);
    var that = s(this, a.call(this, minutes));
    return that._width = 0, that._height = 0, that._depth = 0, that._center = "", that;
  }
  return o(i, a), i.prototype.createGeometry = function(options) {
    this._width = options.width || 1;
    this._height = options.height || 1;
    this._depth = options.depth || 1;
    this._center = options.center;
    var widthSegments = options.widthSegments || 1;
    var divisions = options.heightSegments || 1;
    var depthSegments = options.depthSegments || 1;
    return new THREE.BoxGeometry(this._width, this._height, this._depth, widthSegments, divisions, depthSegments);
  }, n(i, [{
    key : "isBox",
    get : function() {
      return true;
    }
  }]), i;
}(jr);
Rr = function(a) {
  function i(minutes) {
    return r(this, i), s(this, a.call(this, minutes));
  }
  return o(i, a), i.prototype.createGeometry = function(options) {
    var radius = options.radius;
    var segments = options.segments;
    var start = options.thetaStart;
    var w = options.thetaLength;
    return new THREE.CircleGeometry(radius, segments, start, w);
  }, n(i, [{
    key : "isCircle",
    get : function() {
      return true;
    }
  }]), i;
}(jr);
Dr = function(a) {
  function i(minutes) {
    return r(this, i), s(this, a.call(this, minutes));
  }
  return o(i, a), i.prototype.createGeometry = function(options) {
    var baubel_radius = options.radius || 1;
    var rings = options.widthSegments || 8;
    var segments = options.heightSegments || 6;
    var phiStart = options.phiStart || 0;
    var phiLength = options.phiLength || 2 * Math.PI;
    var thetaStart = options.thetaStart || 0;
    var thetaLength = options.thetaLength || Math.PI;
    return new THREE.SphereGeometry(baubel_radius, rings, segments, phiStart, phiLength, thetaStart, thetaLength);
  }, n(i, [{
    key : "isSphere",
    get : function() {
      return true;
    }
  }]), i;
}(jr);
Ar = function(a) {
  function e(row) {
    r(this, e);
    var container = s(this, a.call(this, row));
    return container._ground = null, container._groundSize = 0, container;
  }
  return o(e, a), e.prototype.destroy = function() {
    if (this._ground) {
      this.app.objectManager.removeInteractableNode(this._ground.node);
    }
    a.prototype.destroy.call(this);
  }, e.prototype.createGeometry = function(options) {
    var spriteSize = options.width || 1;
    var imgHeight = options.height || 1;
    var segmentsW = options.widthSegments || 1;
    var planeH = options.heightSegments || 1;
    return new THREE.PlaneGeometry(spriteSize, imgHeight, segmentsW, planeH);
  }, e.prototype.addPickableGround = function(t) {
    this._groundSize = t.size;
    if (this._groundSize) {
      this._ground = a.prototype.addPickableGround.call(this, this._groundSize);
    }
  }, e.prototype.pickGroundWorldPosition = function(dependency, i) {
    return this._ground ? a.prototype.pickGroundWorldPosition.call(this, this._ground, dependency, i) : null;
  }, n(e, [{
    key : "isPlane",
    get : function() {
      return true;
    }
  }]), e;
}(jr);
kr = function(a) {
  function i(minutes) {
    r(this, i);
    var container = s(this, a.call(this, minutes));
    return container._color1 = null, container._color2 = null, container._size = 0, container._divisions = 0, container;
  }
  return o(i, a), i.prototype.createMesh = function(options) {
    this._color1 = Utils.parseColor(options.color1, 16777215);
    this._color2 = Utils.parseColor(options.color2, 16777215);
    this._size = options.size || 10;
    this._divisions = options.divisions || 10;
    var result = new THREE.GridHelper(this._size, this._divisions, this._color1, this._color2);
    return result.userData.skipStyle = true, result;
  }, n(i, [{
    key : "size",
    get : function() {
      return this._size;
    }
  }, {
    key : "isGrid",
    get : function() {
      return true;
    }
  }]), i;
}(jr);
Or = function(a) {
  function i(minutes) {
    return r(this, i), s(this, a.call(this, minutes));
  }
  return o(i, a), i.prototype.createGeometry = function(options) {
    var height = options.height || 1;
    var PasswordText = options.radius || .5;
    var boneRadius = options.radiusTop ? options.radiusTop : PasswordText;
    var bottomRadius = options.radiusBottom ? options.radiusBottom : PasswordText;
    var radiusSegments = options.radiusSegments || 8;
    var height_segments = options.heightSegments || 1;
    var openEnded = options.heightSegments || false;
    var thetaStart = options.heightSegments || 0;
    var thetaLength = options.heightSegments || 2 * Math.PI;
    return new THREE.CylinderGeometry(boneRadius, bottomRadius, height, radiusSegments, height_segments, openEnded, thetaStart, thetaLength);
  }, n(i, [{
    key : "isCylinder",
    get : function() {
      return true;
    }
  }]), i;
}(jr);
Br = function(a) {
  function i(minutes) {
    return r(this, i), s(this, a.call(this, minutes));
  }
  return o(i, a), i.prototype.createGeometry = function(options) {
    var radius = options.radius || 1;
    var detail = options.detail || 0;
    return new THREE.TetrahedronGeometry(radius, detail);
  }, n(i, [{
    key : "isTetrahedron",
    get : function() {
      return true;
    }
  }]), i;
}(jr);
Fr = function(a) {
  function i(minutes) {
    return r(this, i), s(this, a.call(this, minutes));
  }
  return o(i, a), i.prototype.createMaterial = function(data) {
    return new THREE.MeshBasicMaterial({
      color : "#0aa5ff",
      opacity : .5,
      transparent : true,
      side : THREE.DoubleSide
    });
  }, i.prototype.createGeometry = function(options) {
    var t = options.fov || 45;
    var x = options.aspect || 2;
    var d = options.length || 10;
    var y = d * Math.tan(.5 * t * .017453293);
    var s = x * y;
    var threeGeom = new THREE.Geometry;
    return threeGeom.vertices = [new THREE.Vector3(0, 0, 0), new THREE.Vector3(s, -y, -d), new THREE.Vector3(s, y, -d), new THREE.Vector3(-s, y, -d), new THREE.Vector3(-s, -y, -d)], threeGeom.faces = [new THREE.Face3(0, 1, 2), new THREE.Face3(0, 2, 3), new THREE.Face3(0, 3, 4), new THREE.Face3(0, 4, 1), new THREE.Face3(3, 4, 1), new THREE.Face3(3, 1, 2)], threeGeom;
  }, n(i, [{
    key : "isFrustum",
    get : function() {
      return true;
    }
  }]), i;
}(jr);
Shape = function(a) {
  function i(minutes) {
    r(this, i);
    var self = s(this, a.call(this, minutes));
    return self._vertices = null, self._height = 0, self;
  }
  return o(i, a), i.prototype.addGeoObject = function(object, info, y, dist) {
    var n = {
      generateTopUV : function(geometry, buffer, i, indexB, indexA) {
        var u2 = buffer[3 * i];
        var v = buffer[3 * i + 1];
        var u1 = buffer[3 * indexB];
        var v2 = buffer[3 * indexB + 1];
        var u = buffer[3 * indexA];
        var unitHeight = buffer[3 * indexA + 1];
        return [new THREE.Vector2(u2, v), new THREE.Vector2(u1, v2), new THREE.Vector2(u, unitHeight)];
      },
      generateSideWallUV : function(contourIndex1, contourIndex2, geometry, indexA, indexB, indexC) {
        return [new THREE.Vector2(0, 0), new THREE.Vector2(0, 1), new THREE.Vector2(1, 1), new THREE.Vector2(1, 0)];
      }
    };
    var UtilGeoJson = Sr.transformSVGPath(info.path);
    var material = [new THREE.MeshPhongMaterial({
      transparent : true
    }), new THREE.MeshPhongMaterial({
      transparent : true
    })];
    var bindings = UtilGeoJson.toShapes(true);
    var j = 0;
    for (; j < bindings.length; j++) {
      var x = bindings[j];
      var geometry = new THREE.ExtrudeBufferGeometry(x, {
        depth : info.height,
        bevelEnabled : false,
        UVGenerator : n
      });
      var rotationMat = new THREE.Matrix4;
      rotationMat.makeRotationFromEuler(Utils.parseEuler([90, 0, 0]));
      var m = new THREE.Matrix4;
      m.makeTranslation(info.center[0], info.height, info.center[1]);
      m.multiply(rotationMat);
      var p = geometry.attributes.position.array;
      var i = 0;
      for (; i < p.length; i = i + 3) {
        var c = new THREE.Vector3(p[i], p[i + 1], p[i + 2]);
        c.applyMatrix4(m);
        p[i] = c.x;
        p[i + 1] = c.y;
        p[i + 2] = c.z;
      }
      geometry.computeVertexNormals();
      var result = new THREE.Mesh(geometry, material);
      if (!dist) {
        var matrix = new THREE.Matrix4;
        matrix.getInverse(object.matrixWorld);
        result.applyMatrix4(matrix);
      }
      result.translateY(y);
      object.add(result);
    }
  }, i.prototype.createMesh = function(w) {
    var c = w.csg;
    if (c && c.isCSG) {
      var previous = c.bsp.toMesh();
      var i = (new THREE.Matrix4).getInverse(c._object.node.matrixWorld);
      return previous._premultiplyMatrix(i), previous;
    }
    return a.prototype.createMesh.call(this, w);
  }, i.prototype._afterSetupComplete = function(obj) {
    var value = obj.vertices || obj.points;
    var DEFAULT_CENTER = obj.center || [0, 0];
    var height = Utils.parseValue(obj.height, 0);
    var ceilDist = Utils.parseValue(obj.local, false);
    if (value && value.length) {
      var ret = {
        center : DEFAULT_CENTER,
        height : height,
        path : ""
      };
      var formatter = function(val) {
        return THING.Math.isFloatEquals(val, 0) ? 0 : val;
      };
      var i = 0;
      for (; i < value.length; i++) {
        var pt = Utils.parseVector3(value[i]);
        if (ret.path) {
          ret.path += "L";
        } else {
          ret.path += "M";
        }
        ret.path += formatter(pt.x).toString();
        ret.path += ",";
        ret.path += formatter(pt.z).toString();
        ret.path += " ";
      }
      ret.path += " Z";
      this._vertices = value;
      this._height = height;
      this.addGeoObject(this.node, ret, value[0][1], ceilDist);
      if (!(obj.position || obj.localPosition)) {
        this.useBottomCenterOfBoundingBoxAsPosition();
      }
    }
  }, n(i, [{
    key : "height",
    get : function() {
      return this._height;
    }
  }, {
    key : "points",
    get : function() {
      var object = this.node.children[0];
      if (!object) {
        return null;
      }
      object.updateWorldMatrix(true, false);
      var matrix = object.matrixWorld;
      var normals = object.geometry.attributes.position.array;
      var a = [];
      var i = 0;
      for (; i < normals.length; i = i + 3) {
        var v = new THREE.Vector3(normals[i + 0], normals[i + 1], normals[i + 2]);
        v.applyMatrix4(matrix);
        a.push(v.toArray());
      }
      i = 0;
      for (; i < a.length; i++) {
        var j = i + 1;
        for (; j < a.length; j++) {
          if (THING.Math.equalsVector(a[i], a[j])) {
            a.splice(j--, 1);
          }
        }
      }
      return a;
    }
  }, {
    key : "isShape",
    get : function() {
      return true;
    }
  }]), i;
}(jr);
Ir = function(callback) {
  function d(row) {
    r(this, d);
    var container = s(this, callback.call(this, row));
    return container.isOpen = false, container;
  }
  return o(d, callback), d.prototype.open = function() {
    if (-1 !== this.animationNames.indexOf("Auto_Open")) {
      this.playAnimation("Auto_Open");
    }
    this.isOpen = true;
  }, d.prototype.close = function() {
    if (-1 !== this.animationNames.indexOf("Auto_Close")) {
      this.playAnimation("Auto_Close");
    }
    this.isOpen = false;
  }, n(d, [{
    key : "isDoor",
    get : function() {
      return true;
    }
  }, {
    key : "floor",
    get : function() {
      return this.parents.query(".Floor")[0];
    }
  }]), d;
}(fr);
Nr = function(context) {
  function d(row) {
    r(this, d);
    var container = s(this, context.call(this, row));
    return container.elevator = null, container;
  }
  return o(d, context), d.prototype.setup = function(tests) {
    context.prototype.setup.call(this, tests);
    this.levelNumber = this.parent.levelNumber;
  }, n(d, [{
    key : "owner",
    get : function() {
      return this.elevator;
    }
  }]), d;
}(Ir);
Hr = function(context) {
  function d(row) {
    r(this, d);
    var map = s(this, context.call(this, row));
    return map.doors = [], map;
  }
  return o(d, context), d.prototype.setup = function(config) {
    if (context.prototype.setup.call(this, config), config.doors) {
      this.doors = config.doors;
      var i = 0;
      for (; i < this.doors.length; i++) {
        this.doors[i].elevator = this;
      }
    }
  }, d.prototype.getDoor = function(aExpectedTarget) {
    var i = 0;
    for (; i < this.doors.length; i++) {
      var event = this.doors[i];
      if (event.floor == aExpectedTarget) {
        return event;
      }
    }
    return event;
  }, d;
}(BaseObject);
Ur = function(context) {
  function d(row) {
    r(this, d);
    var container = s(this, context.call(this, row));
    return container.stair = null, container;
  }
  return o(d, context), d.prototype.setup = function(tests) {
    context.prototype.setup.call(this, tests);
  }, n(d, [{
    key : "owner",
    get : function() {
      return this.stair;
    }
  }, {
    key : "isStairDoor",
    get : function() {
      return true;
    }
  }]), d;
}(Ir);
zr = function(context) {
  function d(row) {
    r(this, d);
    var map = s(this, context.call(this, row));
    return map.doors = [], map;
  }
  return o(d, context), d.prototype.setup = function(config) {
    if (context.prototype.setup.call(this, config), config.doors) {
      this.doors = config.doors;
      var i = 0;
      for (; i < this.doors.length; i++) {
        this.doors[i].stair = this;
      }
    }
  }, d.prototype.getDoor = function(aExpectedTarget) {
    var i = 0;
    for (; i < this.doors.length; i++) {
      var event = this.doors[i];
      if (event.floor == aExpectedTarget) {
        return event;
      }
    }
    return event;
  }, n(d, [{
    key : "isStair",
    get : function() {
      return THING.Utils.warn("[Stair] Please use 'instanceof THING.Stair' to replace '.Stair'"), this instanceof THING.Stair;
    }
  }]), d;
}(BaseObject);
Vr = function(e) {
  function d(row) {
    return r(this, d), s(this, e.call(this, row));
  }
  return o(d, e), d.prototype.customSetup = function(val) {
    var x = val.width;
    var y = val.height;
    if (x && y) {
      var t = new THREE.PlaneBufferGeometry(x, y);
      var wheelAxisMat = new THREE.MeshLambertMaterial({
        polygonOffset : true,
        polygonOffsetFactor : 10,
        polygonOffsetUnits : 10
      });
      var o = new THREE.Mesh(t, wheelAxisMat);
      o.rotation.x = -.5 * Math.PI;
      o.position.x = 0;
      o.position.y = -.1;
      o.position.z = 0;
      o.receiveShadow = true;
      var e = Utils.parseValue(val.skipBoundingBox, true);
      o.skipBoundingBox(e);
      var pov_projection_matrix2 = val.repeatUV || [100, 100];
      var url = val.image;
      if (url) {
        var value = this.app.confirmURL(url, "https://static.3dmomoda.com/textures");
        o.material.map = this.app.resourceManager.loadTexture(value, void 0, {
          repeat : true,
          anisotropy : 16
        });
        o.material.map.repeat.fromArray(pov_projection_matrix2);
      }
      this.node.add(o);
    }
  }, d.prototype._loadSelfResource = function() {
    this._children.forEach(function(srUtils) {
      srUtils.loadResource();
    });
  }, n(d, [{
    key : "isGround",
    get : function() {
      return true;
    }
  }, {
    key : "misc",
    get : function() {
      return this.miscObject || (this.miscObject = this.query(".CombinedObject").query("[userData/type=CombineMiscParent]")[0]), this.miscObject;
    }
  }, {
    key : "plan",
    get : function() {
      return this.floorObject || (this.floorObject = this.query(".CombinedObject").query("[userData/type=CombineFloorParent]")[0]), this.floorObject;
    }
  }, {
    key : "wall",
    get : function() {
      return this.wallObject || (this.wallObject = this.query(".CombinedObject").query("[userData/type=CombineWallParent]")[0]), this.wallObject;
    }
  }]), d;
}(BaseObject);
VideoSurvilance = function(b) {
  function update(idx) {
    r(this, update);
    var result = s(this, b.call(this, idx));
    return result._aspect = 2, result._fov = 45, result._near = .1, result._far = 10, result._camera = null, result._lineMesh = null, result._frustumMesh = null, result._frustum = new THREE.Frustum, result._projScreenMatrix = new THREE.Matrix4, result;
  }
  return o(update, b), update.prototype._updateFrustum = function() {
    this._projScreenMatrix.multiplyMatrices(this._camera.projectionMatrix, this._camera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(this._projScreenMatrix);
  }, update.prototype._buildLineMesh = function(mesh, value) {
    var bufferedGeometry = new THREE.EdgesGeometry(mesh.geometry);
    var dragknifeGrp = new THREE.LineSegments(bufferedGeometry);
    return dragknifeGrp.material.color = Utils.parseColor(value), dragknifeGrp;
  }, update.prototype._buildFrustumMesh = function() {
    var size = this.far * Math.tan(.5 * this.fov * .017453293);
    var width = this.aspect * size;
    var geometry = new THREE.Geometry;
    geometry.vertices = [new THREE.Vector3(0, 0, 0), new THREE.Vector3(width, -size, -this.far), new THREE.Vector3(width, size, -this.far), new THREE.Vector3(-width, size, -this.far), new THREE.Vector3(-width, -size, -this.far)];
    geometry.faces = [new THREE.Face3(0, 1, 2), new THREE.Face3(0, 2, 3), new THREE.Face3(0, 3, 4), new THREE.Face3(0, 4, 1), new THREE.Face3(3, 4, 1), new THREE.Face3(3, 1, 2)];
    var material = new THREE.MeshBasicMaterial({
      color : "#0aa5ff",
      opacity : .5,
      transparent : true,
      side : THREE.DoubleSide
    });
    var segment_mesh = new THREE.Mesh(geometry, material);
    return segment_mesh.userData.skipEnvMap = true, segment_mesh;
  }, update.prototype._build = function() {
    var newModels = this.app.resourceManager;
    newModels.remove(this._frustumMesh);
    newModels.remove(this._lineMesh);
    this._frustumMesh = this._buildFrustumMesh();
    this.node.add(this._frustumMesh);
    var realVal = this.style._lineColor || 16777215;
    this._lineMesh = this._buildLineMesh(this._frustumMesh, realVal);
    this.node.add(this._lineMesh);
    this._camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far);
    this._camera.position.set(this.position[0], this.position[1], this.position[2]);
    this._camera.rotation.copy(this.node.rotation);
    this._camera.updateMatrixWorld(true);
    this._updateFrustum();
  }, update.prototype.customSetup = function(object) {
    this._aspect = object.aspect || this._aspect;
    this._fov = object.fov || this._fov;
    this._near = object.near || this._near;
    this._far = object.far || this._far;
    this._build();
  }, update.prototype.setWorldPosition = function(position) {
    b.prototype.setWorldPosition.call(this, position);
    this._camera.position.set(position[0], position[1], position[2]);
    this._camera.updateMatrixWorld(true);
    this._updateFrustum();
  }, update.prototype.intersectsObject = function(object) {
    return this._updateFrustum(), !!this._frustum._intersectsObject(object.node);
  }, n(update, [{
    key : "aspect",
    set : function(v) {
      this._aspect = v;
      this._build();
    },
    get : function() {
      return this._aspect;
    }
  }, {
    key : "fov",
    set : function(v) {
      this._fov = v;
      this._build();
    },
    get : function() {
      return this._fov;
    }
  }, {
    key : "far",
    set : function(v) {
      this._far = v;
      this._build();
    },
    get : function() {
      return this._far;
    }
  }]), update;
}(BaseObject);
Gr = {
  uniforms : {
    tDiffuse : {
      value : null
    },
    brightness : {
      value : 0
    },
    contrast : {
      value : 1
    },
    exposure : {
      value : 0
    },
    gamma : {
      value : 1
    },
    saturation : {
      value : 1
    }
  },
  vertexShader : ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader : ["uniform sampler2D tDiffuse;", "varying vec2 vUv;", "uniform float brightness;", "uniform float contrast;", "uniform float exposure;", "uniform float gamma;", "uniform float saturation;", "const vec3 w = vec3(0.2125, 0.7154, 0.0721);", "void main() {", "vec4 tex = texture2D( tDiffuse, vUv );", "vec3 color = clamp(tex.rgb + vec3(brightness), 0.0, 1.0);", "color = clamp( (color-vec3(0.5))*contrast+vec3(0.5), 0.0, 1.0);", "color = clamp( color * pow(2.0, exposure), 0.0, 1.0);", "color = clamp( pow(color, vec3(gamma)), 0.0, 1.0);", 
  "float luminance = dot( color, w );", "color = mix(vec3(luminance), color, saturation);", "gl_FragColor = vec4(color, tex.a);", "}"].join("\n")
};
qr = {
  defines : {
    RINGS : 3,
    SAMPLES : 4
  },
  uniforms : {
    tColor : {
      value : null
    },
    tDepth : {
      value : null
    },
    resolution : {
      value : new THREE.Vector2(1 / 1024, 1 / 512)
    },
    znear : {
      value : .1
    },
    zfar : {
      value : 100
    },
    focalDepth : {
      value : 1
    },
    focalLength : {
      value : 24
    },
    fstop : {
      value : .9
    },
    maxblur : {
      value : 1
    },
    threshold : {
      value : .5
    },
    gain : {
      value : 2
    },
    bias : {
      value : .5
    },
    dithering : {
      value : 1e-4
    }
  },
  vertexShader : "\n        varying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}\n    ",
  fragmentShader : "\n        #include <common>\n\n        varying vec2 vUv;\n\n        uniform sampler2D tColor;\n        uniform sampler2D tDepth;\n\n        uniform vec2 resolution;\n\n        uniform float znear;\n        uniform float zfar;\n\n        uniform float focalDepth;\n        uniform float focalLength;\n        uniform float fstop;\n\n        uniform float maxblur; // clamp value of max blur (0.0 = no blur, 1.0 default)\n        uniform float threshold; // highlight threshold\n        uniform float gain; // highlight gain\n        uniform float bias; // bokeh edge bias\n        uniform float dithering;\n\n        const int samples = SAMPLES;\n        const int rings = RINGS;\n        const int maxringsamples = rings * samples;\n\n        float CoC = 0.03; // circle of confusion size in mm (35mm film = 0.03mm)\n\n        vec3 color(vec2 coords, float blur) {\n            vec3 col = texture2D(tColor, coords).rgb;\n            vec3 lumcoeff = vec3(0.299,0.587,0.114);\n            float lum = dot(col.rgb, lumcoeff);\n            float thresh = max((lum - threshold) * gain, 0.0);\n            return col + mix(vec3(0.0), col, thresh * blur);\n        }\n\n        float linearize(float depth) {\n            return -zfar * znear / (depth * (zfar - znear) - zfar);\n        }\n\n        float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\n            float rings2 = float(rings);\n            float step = PI * 2.0 / float(ringsamples);\n            float pw = cos(j * step) * i;\n            float ph = sin(j * step) * i;\n            col += color(vUv + vec2(pw * w, ph * h), blur) * mix(1.0, i / rings2, bias);\n            return mix(1.0, i / rings2, bias);\n        }\n\n        void main() {\n            float depth = linearize(texture2D(tDepth, vUv).x);\n            float fDepth = focalDepth;\n\n            // dof blur factor calculation\n\n            float f = focalLength; // focal length in mm\n            float d = fDepth * 1000.; // focal plane in mm\n            float o = depth * 1000.; // depth in mm\n\n            float a = (o * f) / (o - f);\n            float b = (d * f) / (d - f);\n            float c = (d - f) / (d * fstop * CoC);\n\n            float blur = abs(a - b) * c;\n            blur = clamp(blur, 0.0, 1.0);\n\n            // calculation of pattern for dithering\n\n            vec2 noise = vec2(rand(vUv), rand(vUv + vec2(0.4, 0.6))) * dithering * blur;\n\n            // getting blur x and y step factor\n\n            float w = resolution.x * blur * maxblur + noise.x;\n            float h = resolution.y * blur * maxblur + noise.y;\n\n            // calculation of final color\n\n            vec3 col = vec3(0.0);\n\n            if (blur < 0.05) {\n                col = texture2D(tColor, vUv).rgb;\n            } else {\n                col = texture2D(tColor, vUv).rgb;\n\n                float s = 1.0;\n                int ringsamples;\n\n                for(int i = 1; i <= rings; i++) {\n                    ringsamples = i * samples;\n\n                    for (int j = 0; j < maxringsamples; j++) {\n                        if (j >= ringsamples) break;\n                        s += gather(float(i), float(j), ringsamples, col, w, h, blur);\n                    }\n                }\n\n                col /= s; // divide by sample count\n            }\n\n            gl_FragColor = vec4(col, 1.0);\n        }\n    "
};
Xr = {
  uniforms : {
    tDiffuse : {
      value : null
    },
    time : {
      value : 0
    },
    nIntensity : {
      value : .5
    },
    sIntensity : {
      value : .05
    },
    sCount : {
      value : 4096
    },
    grayscale : {
      value : 1
    }
  },
  vertexShader : ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader : ["#include <common>", "uniform float time;", "uniform bool grayscale;", "uniform float nIntensity;", "uniform float sIntensity;", "uniform float sCount;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 cTextureScreen = texture2D( tDiffuse, vUv );", "float dx = rand( vUv + time );", "vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );", "vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );", "cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;", 
  "cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );", "if( grayscale ) {", "cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );", "}", "gl_FragColor =  vec4( cResult, cTextureScreen.a );", "}"].join("\n")
};
Jr = {
  uniforms : {
    tDiffuse : {
      value : null
    },
    uChromaFactor : {
      value : .025
    },
    uResolutionRatio : {
      value : new THREE.Vector2(1, 1)
    },
    resolution : {
      value : new THREE.Vector2(1 / 1024, 1 / 512)
    }
  },
  vertexShader : ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader : ["uniform sampler2D tDiffuse;", "uniform float uChromaFactor;", "uniform vec2 uResolutionRatio;", "uniform vec2 resolution;", "varying vec2 vUv;", "void main() {", "vec2 uv = vUv;", "vec2 dist = uv - 0.5;", "vec2 offset = uChromaFactor * dist * length(dist);", "vec4 col = texture2D(tDiffuse, min(uv, 1.0 - resolution) * uResolutionRatio);", "col.r = texture2D(tDiffuse, min(uv - offset, 1.0 - resolution) * uResolutionRatio).r;", "col.b = texture2D(tDiffuse, min(uv + offset, 1.0 - resolution) * uResolutionRatio).b;", 
  "gl_FragColor = col;", "}"].join("\n")
};
Yr = {
  uniforms : {
    tDiffuse : {
      value : null
    },
    opacity : {
      value : 1
    }
  },
  vertexShader : ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader : ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "gl_FragColor = opacity * texel;", "}"].join("\n")
};
Qr = {
  uniforms : {
    tDiffuse : {
      value : null
    },
    resolution : {
      value : new THREE.Vector2(1 / 1024, 1 / 512)
    }
  },
  vertexShader : ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader : ["precision highp float;", "", "uniform sampler2D tDiffuse;", "", "uniform vec2 resolution;", "", "varying vec2 vUv;", "", "// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)", "", "//----------------------------------------------------------------------------------", "// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag", "// SDK Version: v3.00", "// Email:       gameworks@nvidia.com", "// Site:        http://developer.nvidia.com/", 
  "//", "// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.", "//", "// Redistribution and use in source and binary forms, with or without", "// modification, are permitted provided that the following conditions", "// are met:", "//  * Redistributions of source code must retain the above copyright", "//    notice, this list of conditions and the following disclaimer.", "//  * Redistributions in binary form must reproduce the above copyright", "//    notice, this list of conditions and the following disclaimer in the", 
  "//    documentation and/or other materials provided with the distribution.", "//  * Neither the name of NVIDIA CORPORATION nor the names of its", "//    contributors may be used to endorse or promote products derived", "//    from this software without specific prior written permission.", "//", "// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY", "// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", "// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR", 
  "// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR", "// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,", "// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,", "// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR", "// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY", "// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT", "// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE", 
  "// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", "//", "//----------------------------------------------------------------------------------", "", "#define FXAA_PC 1", "#define FXAA_GLSL_100 1", "#define FXAA_QUALITY_PRESET 12", "", "#define FXAA_GREEN_AS_LUMA 1", "", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_PC_CONSOLE", "    //", "    // The console algorithm for PC is included", "    // for developers targeting really low spec machines.", 
  "    // Likely better to just run FXAA_PC, and use a really low preset.", "    //", "    #define FXAA_PC_CONSOLE 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GLSL_120", "    #define FXAA_GLSL_120 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GLSL_130", "    #define FXAA_GLSL_130 0", "#endif", "/*--------------------------------------------------------------------------*/", 
  "#ifndef FXAA_HLSL_3", "    #define FXAA_HLSL_3 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_HLSL_4", "    #define FXAA_HLSL_4 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_HLSL_5", "    #define FXAA_HLSL_5 0", "#endif", "/*==========================================================================*/", "#ifndef FXAA_GREEN_AS_LUMA", "    //", "    // For those using non-linear color,", 
  "    // and either not able to get luma in alpha, or not wanting to,", "    // this enables FXAA to run using green as a proxy for luma.", "    // So with this enabled, no need to pack luma in alpha.", "    //", "    // This will turn off AA on anything which lacks some amount of green.", "    // Pure red and blue or combination of only R and B, will get no AA.", "    //", "    // Might want to lower the settings for both,", "    //    fxaaConsoleEdgeThresholdMin", "    //    fxaaQualityEdgeThresholdMin", 
  "    // In order to insure AA does not get turned off on colors", "    // which contain a minor amount of green.", "    //", "    // 1 = On.", "    // 0 = Off.", "    //", "    #define FXAA_GREEN_AS_LUMA 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_EARLY_EXIT", "    //", "    // Controls algorithm's early exit path.", "    // On PS3 turning this ON adds 2 cycles to the shader.", "    // On 360 turning this OFF adds 10ths of a millisecond to the shader.", 
  "    // Turning this off on console will result in a more blurry image.", "    // So this defaults to on.", "    //", "    // 1 = On.", "    // 0 = Off.", "    //", "    #define FXAA_EARLY_EXIT 1", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_DISCARD", "    //", "    // Only valid for PC OpenGL currently.", "    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.", "    //", "    // 1 = Use discard on pixels which don't need AA.", 
  "    //     For APIs which enable concurrent TEX+ROP from same surface.", "    // 0 = Return unchanged color on pixels which don't need AA.", "    //", "    #define FXAA_DISCARD 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_FAST_PIXEL_OFFSET", "    //", "    // Used for GLSL 120 only.", "    //", "    // 1 = GL API supports fast pixel offsets", "    // 0 = do not use fast pixel offsets", "    //", "    #ifdef GL_EXT_gpu_shader4", "        #define FXAA_FAST_PIXEL_OFFSET 1", 
  "    #endif", "    #ifdef GL_NV_gpu_shader5", "        #define FXAA_FAST_PIXEL_OFFSET 1", "    #endif", "    #ifdef GL_ARB_gpu_shader5", "        #define FXAA_FAST_PIXEL_OFFSET 1", "    #endif", "    #ifndef FXAA_FAST_PIXEL_OFFSET", "        #define FXAA_FAST_PIXEL_OFFSET 0", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GATHER4_ALPHA", "    //", "    // 1 = API supports gather4 on alpha channel.", "    // 0 = API does not support gather4 on alpha channel.", 
  "    //", "    #if (FXAA_HLSL_5 == 1)", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifdef GL_ARB_gpu_shader5", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifdef GL_NV_gpu_shader5", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifndef FXAA_GATHER4_ALPHA", "        #define FXAA_GATHER4_ALPHA 0", "    #endif", "#endif", "", "", "/*============================================================================", "                        FXAA QUALITY - TUNING KNOBS", 
  "------------------------------------------------------------------------------", "NOTE the other tuning knobs are now in the shader function inputs!", "============================================================================*/", "#ifndef FXAA_QUALITY_PRESET", "    //", "    // Choose the quality preset.", "    // This needs to be compiled into the shader as it effects code.", "    // Best option to include multiple presets is to", "    // in each shader define the preset, then include this file.", 
  "    //", "    // OPTIONS", "    // -----------------------------------------------------------------------", "    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)", "    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)", "    // 39       - no dither, very expensive", "    //", "    // NOTES", "    // -----------------------------------------------------------------------", "    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)", 
  "    // 13 = about same speed as FXAA 3.9 and better than 12", "    // 23 = closest to FXAA 3.9 visually and performance wise", "    //  _ = the lowest digit is directly related to performance", "    // _  = the highest digit is directly related to style", "    //", "    #define FXAA_QUALITY_PRESET 12", "#endif", "", "", "/*============================================================================", "", "                           FXAA QUALITY - PRESETS", "", "============================================================================*/", 
  "", "/*============================================================================", "                     FXAA QUALITY - MEDIUM DITHER PRESETS", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 10)", "    #define FXAA_QUALITY_PS 3", "    #define FXAA_QUALITY_P0 1.5", "    #define FXAA_QUALITY_P1 3.0", "    #define FXAA_QUALITY_P2 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 11)", 
  "    #define FXAA_QUALITY_PS 4", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 3.0", "    #define FXAA_QUALITY_P3 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 12)", "    #define FXAA_QUALITY_PS 5", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 4.0", "    #define FXAA_QUALITY_P4 12.0", 
  "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 13)", "    #define FXAA_QUALITY_PS 6", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 4.0", "    #define FXAA_QUALITY_P5 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 14)", "    #define FXAA_QUALITY_PS 7", 
  "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 4.0", "    #define FXAA_QUALITY_P6 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 15)", "    #define FXAA_QUALITY_PS 8", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", 
  "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 4.0", "    #define FXAA_QUALITY_P7 12.0", "#endif", "", "/*============================================================================", "                     FXAA QUALITY - LOW DITHER PRESETS", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 20)", "    #define FXAA_QUALITY_PS 3", "    #define FXAA_QUALITY_P0 1.5", 
  "    #define FXAA_QUALITY_P1 2.0", "    #define FXAA_QUALITY_P2 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 21)", "    #define FXAA_QUALITY_PS 4", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 22)", "    #define FXAA_QUALITY_PS 5", 
  "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 23)", "    #define FXAA_QUALITY_PS 6", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", 
  "    #define FXAA_QUALITY_P5 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 24)", "    #define FXAA_QUALITY_PS 7", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 3.0", "    #define FXAA_QUALITY_P6 8.0", "#endif", "/*--------------------------------------------------------------------------*/", 
  "#if (FXAA_QUALITY_PRESET == 25)", "    #define FXAA_QUALITY_PS 8", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 4.0", "    #define FXAA_QUALITY_P7 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 26)", "    #define FXAA_QUALITY_PS 9", 
  "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 4.0", "    #define FXAA_QUALITY_P8 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 27)", "    #define FXAA_QUALITY_PS 10", "    #define FXAA_QUALITY_P0 1.0", 
  "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 4.0", "    #define FXAA_QUALITY_P9 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 28)", "    #define FXAA_QUALITY_PS 11", "    #define FXAA_QUALITY_P0 1.0", 
  "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 4.0", "    #define FXAA_QUALITY_P10 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 29)", "    #define FXAA_QUALITY_PS 12", 
  "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 2.0", "    #define FXAA_QUALITY_P10 4.0", "    #define FXAA_QUALITY_P11 8.0", "#endif", "", "/*============================================================================", 
  "                     FXAA QUALITY - EXTREME QUALITY", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 39)", "    #define FXAA_QUALITY_PS 12", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.0", "    #define FXAA_QUALITY_P2 1.0", "    #define FXAA_QUALITY_P3 1.0", "    #define FXAA_QUALITY_P4 1.0", "    #define FXAA_QUALITY_P5 1.5", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", 
  "    #define FXAA_QUALITY_P9 2.0", "    #define FXAA_QUALITY_P10 4.0", "    #define FXAA_QUALITY_P11 8.0", "#endif", "", "", "", "/*============================================================================", "", "                                API PORTING", "", "============================================================================*/", "#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)", "    #define FxaaBool bool", "    #define FxaaDiscard discard", "    #define FxaaFloat float", 
  "    #define FxaaFloat2 vec2", "    #define FxaaFloat3 vec3", "    #define FxaaFloat4 vec4", "    #define FxaaHalf float", "    #define FxaaHalf2 vec2", "    #define FxaaHalf3 vec3", "    #define FxaaHalf4 vec4", "    #define FxaaInt2 ivec2", "    #define FxaaSat(x) clamp(x, 0.0, 1.0)", "    #define FxaaTex sampler2D", "#else", "    #define FxaaBool bool", "    #define FxaaDiscard clip(-1)", "    #define FxaaFloat float", "    #define FxaaFloat2 float2", "    #define FxaaFloat3 float3", "    #define FxaaFloat4 float4", 
  "    #define FxaaHalf half", "    #define FxaaHalf2 half2", "    #define FxaaHalf3 half3", "    #define FxaaHalf4 half4", "    #define FxaaSat(x) saturate(x)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_100 == 1)", "  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)", "  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_120 == 1)", 
  "    // Requires,", "    //  #version 120", "    // And at least,", "    //  #extension GL_EXT_gpu_shader4 : enable", "    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)", "    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)", "    #if (FXAA_FAST_PIXEL_OFFSET == 1)", "        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)", "    #else", "        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)", "    #endif", "    #if (FXAA_GATHER4_ALPHA == 1)", "        // use #extension GL_ARB_gpu_shader5 : enable", 
  "        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)", "        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)", "        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)", "        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_130 == 1)", '    // Requires "#version 130" or better', "    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)", 
  "    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)", "    #if (FXAA_GATHER4_ALPHA == 1)", "        // use #extension GL_ARB_gpu_shader5 : enable", "        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)", "        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)", "        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)", "        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", 
  "#if (FXAA_HLSL_3 == 1)", "    #define FxaaInt2 float2", "    #define FxaaTex sampler2D", "    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))", "    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_HLSL_4 == 1)", "    #define FxaaInt2 int2", "    struct FxaaTex { SamplerState smpl; Texture2D tex; };", "    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)", 
  "    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_HLSL_5 == 1)", "    #define FxaaInt2 int2", "    struct FxaaTex { SamplerState smpl; Texture2D tex; };", "    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)", "    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)", "    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)", "    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)", 
  "    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)", "    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)", "#endif", "", "", "/*============================================================================", "                   GREEN AS LUMA OPTION SUPPORT FUNCTION", "============================================================================*/", "#if (FXAA_GREEN_AS_LUMA == 0)", "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }", "#else", "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }", 
  "#endif", "", "", "", "", "/*============================================================================", "", "                             FXAA3 QUALITY - PC", "", "============================================================================*/", "#if (FXAA_PC == 1)", "/*--------------------------------------------------------------------------*/", "FxaaFloat4 FxaaPixelShader(", "    //", "    // Use noperspective interpolation here (turn off perspective interpolation).", "    // {xy} = center of pixel", 
  "    FxaaFloat2 pos,", "    //", "    // Used only for FXAA Console, and not used on the 360 version.", "    // Use noperspective interpolation here (turn off perspective interpolation).", "    // {xy_} = upper left of pixel", "    // {_zw} = lower right of pixel", "    FxaaFloat4 fxaaConsolePosPos,", "    //", "    // Input color texture.", "    // {rgb_} = color in linear or perceptual color space", "    // if (FXAA_GREEN_AS_LUMA == 0)", "    //     {__a} = luma in perceptual color space (not linear)", 
  "    FxaaTex tex,", "    //", "    // Only used on the optimized 360 version of FXAA Console.", '    // For everything but 360, just use the same input here as for "tex".', "    // For 360, same texture, just alias with a 2nd sampler.", "    // This sampler needs to have an exponent bias of -1.", "    FxaaTex fxaaConsole360TexExpBiasNegOne,", "    //", "    // Only used on the optimized 360 version of FXAA Console.", '    // For everything but 360, just use the same input here as for "tex".', "    // For 360, same texture, just alias with a 3nd sampler.", 
  "    // This sampler needs to have an exponent bias of -2.", "    FxaaTex fxaaConsole360TexExpBiasNegTwo,", "    //", "    // Only used on FXAA Quality.", "    // This must be from a constant/uniform.", "    // {x_} = 1.0/screenWidthInPixels", "    // {_y} = 1.0/screenHeightInPixels", "    FxaaFloat2 fxaaQualityRcpFrame,", "    //", "    // Only used on FXAA Console.", "    // This must be from a constant/uniform.", "    // This effects sub-pixel AA quality and inversely sharpness.", "    //   Where N ranges between,", 
  "    //     N = 0.50 (default)", "    //     N = 0.33 (sharper)", "    // {x__} = -N/screenWidthInPixels", "    // {_y_} = -N/screenHeightInPixels", "    // {_z_} =  N/screenWidthInPixels", "    // {__w} =  N/screenHeightInPixels", "    FxaaFloat4 fxaaConsoleRcpFrameOpt,", "    //", "    // Only used on FXAA Console.", "    // Not used on 360, but used on PS3 and PC.", "    // This must be from a constant/uniform.", "    // {x__} = -2.0/screenWidthInPixels", "    // {_y_} = -2.0/screenHeightInPixels", 
  "    // {_z_} =  2.0/screenWidthInPixels", "    // {__w} =  2.0/screenHeightInPixels", "    FxaaFloat4 fxaaConsoleRcpFrameOpt2,", "    //", "    // Only used on FXAA Console.", "    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.", "    // This must be from a constant/uniform.", "    // {x__} =  8.0/screenWidthInPixels", "    // {_y_} =  8.0/screenHeightInPixels", "    // {_z_} = -4.0/screenWidthInPixels", "    // {__w} = -4.0/screenHeightInPixels", "    FxaaFloat4 fxaaConsole360RcpFrameOpt2,", 
  "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_SUBPIX define.", "    // It is here now to allow easier tuning.", "    // Choose the amount of sub-pixel aliasing removal.", "    // This can effect sharpness.", "    //   1.00 - upper limit (softer)", "    //   0.75 - default amount of filtering", "    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)", "    //   0.25 - almost off", "    //   0.00 - completely off", "    FxaaFloat fxaaQualitySubpix,", 
  "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.", "    // It is here now to allow easier tuning.", "    // The minimum amount of local contrast required to apply algorithm.", "    //   0.333 - too little (faster)", "    //   0.250 - low quality", "    //   0.166 - default", "    //   0.125 - high quality", "    //   0.063 - overkill (slower)", "    FxaaFloat fxaaQualityEdgeThreshold,", "    //", "    // Only used on FXAA Quality.", 
  "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.", "    // It is here now to allow easier tuning.", "    // Trims the algorithm from processing darks.", "    //   0.0833 - upper limit (default, the start of visible unfiltered edges)", "    //   0.0625 - high quality (faster)", "    //   0.0312 - visible limit (slower)", "    // Special notes when using FXAA_GREEN_AS_LUMA,", "    //   Likely want to set this to zero.", "    //   As colors that are mostly not-green", "    //   will appear very dark in the green channel!", 
  "    //   Tune by looking at mostly non-green content,", "    //   then start at zero and increase until aliasing is a problem.", "    FxaaFloat fxaaQualityEdgeThresholdMin,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.", "    // It is here now to allow easier tuning.", "    // This does not effect PS3, as this needs to be compiled in.", "    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.", "    //   Due to the PS3 being ALU bound,", 
  "    //   there are only three safe values here: 2 and 4 and 8.", "    //   These options use the shaders ability to a free *|/ by 2|4|8.", "    // For all other platforms can be a non-power of two.", "    //   8.0 is sharper (default!!!)", "    //   4.0 is softer", "    //   2.0 is really soft (good only for vector graphics inputs)", "    FxaaFloat fxaaConsoleEdgeSharpness,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.", "    // It is here now to allow easier tuning.", 
  "    // This does not effect PS3, as this needs to be compiled in.", "    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.", "    //   Due to the PS3 being ALU bound,", "    //   there are only two safe values here: 1/4 and 1/8.", "    //   These options use the shaders ability to a free *|/ by 2|4|8.", "    // The console setting has a different mapping than the quality setting.", "    // Other platforms can use other values.", "    //   0.125 leaves less aliasing, but is softer (default!!!)", 
  "    //   0.25 leaves more aliasing, and is sharper", "    FxaaFloat fxaaConsoleEdgeThreshold,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.", "    // It is here now to allow easier tuning.", "    // Trims the algorithm from processing darks.", "    // The console setting has a different mapping than the quality setting.", "    // This only applies when FXAA_EARLY_EXIT is 1.", "    // This does not apply to PS3,", "    // PS3 was simplified to avoid more shader instructions.", 
  "    //   0.06 - faster but more aliasing in darks", "    //   0.05 - default", "    //   0.04 - slower and less aliasing in darks", "    // Special notes when using FXAA_GREEN_AS_LUMA,", "    //   Likely want to set this to zero.", "    //   As colors that are mostly not-green", "    //   will appear very dark in the green channel!", "    //   Tune by looking at mostly non-green content,", "    //   then start at zero and increase until aliasing is a problem.", "    FxaaFloat fxaaConsoleEdgeThresholdMin,", 
  "    //", "    // Extra constants for 360 FXAA Console only.", "    // Use zeros or anything else for other platforms.", "    // These must be in physical constant registers and NOT immedates.", "    // Immedates will result in compiler un-optimizing.", "    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)", "    FxaaFloat4 fxaaConsole360ConstDir", ") {", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posM;", "    posM.x = pos.x;", "    posM.y = pos.y;", 
  "    #if (FXAA_GATHER4_ALPHA == 1)", "        #if (FXAA_DISCARD == 0)", "            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);", "            #if (FXAA_GREEN_AS_LUMA == 0)", "                #define lumaM rgbyM.w", "            #else", "                #define lumaM rgbyM.y", "            #endif", "        #endif", "        #if (FXAA_GREEN_AS_LUMA == 0)", "            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);", "            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));", 
  "        #else", "            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);", "            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));", "        #endif", "        #if (FXAA_DISCARD == 1)", "            #define lumaM luma4A.w", "        #endif", "        #define lumaE luma4A.z", "        #define lumaS luma4A.x", "        #define lumaSE luma4A.y", "        #define lumaNW luma4B.w", "        #define lumaN luma4B.z", "        #define lumaW luma4B.x", "    #else", "        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);", 
  "        #if (FXAA_GREEN_AS_LUMA == 0)", "            #define lumaM rgbyM.w", "        #else", "            #define lumaM rgbyM.y", "        #endif", "        #if (FXAA_GLSL_100 == 1)", "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));", 
  "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));", "        #else", "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));", 
  "        #endif", "    #endif", "/*--------------------------------------------------------------------------*/", "    FxaaFloat maxSM = max(lumaS, lumaM);", "    FxaaFloat minSM = min(lumaS, lumaM);", "    FxaaFloat maxESM = max(lumaE, maxSM);", "    FxaaFloat minESM = min(lumaE, minSM);", "    FxaaFloat maxWN = max(lumaN, lumaW);", "    FxaaFloat minWN = min(lumaN, lumaW);", "    FxaaFloat rangeMax = max(maxWN, maxESM);", "    FxaaFloat rangeMin = min(minWN, minESM);", "    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;", 
  "    FxaaFloat range = rangeMax - rangeMin;", "    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);", "    FxaaBool earlyExit = range < rangeMaxClamped;", "/*--------------------------------------------------------------------------*/", "    if(earlyExit)", "        #if (FXAA_DISCARD == 1)", "            FxaaDiscard;", "        #else", "            return rgbyM;", "        #endif", "/*--------------------------------------------------------------------------*/", "    #if (FXAA_GATHER4_ALPHA == 0)", 
  "        #if (FXAA_GLSL_100 == 1)", "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));", "        #else", 
  "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));", "        #endif", "    #else", "        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));", 
  "        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));", "    #endif", "/*--------------------------------------------------------------------------*/", "    FxaaFloat lumaNS = lumaN + lumaS;", "    FxaaFloat lumaWE = lumaW + lumaE;", "    FxaaFloat subpixRcpRange = 1.0/range;", "    FxaaFloat subpixNSWE = lumaNS + lumaWE;", "    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;", "    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;", "/*--------------------------------------------------------------------------*/", 
  "    FxaaFloat lumaNESE = lumaNE + lumaSE;", "    FxaaFloat lumaNWNE = lumaNW + lumaNE;", "    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;", "    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat lumaNWSW = lumaNW + lumaSW;", "    FxaaFloat lumaSWSE = lumaSW + lumaSE;", "    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);", "    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);", 
  "    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;", "    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;", "    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;", "    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;", "    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;", "    FxaaBool horzSpan = edgeHorz >= edgeVert;", "    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;", 
  "/*--------------------------------------------------------------------------*/", "    if(!horzSpan) lumaN = lumaW;", "    if(!horzSpan) lumaS = lumaE;", "    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;", "    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat gradientN = lumaN - lumaM;", "    FxaaFloat gradientS = lumaS - lumaM;", "    FxaaFloat lumaNN = lumaN + lumaM;", "    FxaaFloat lumaSS = lumaS + lumaM;", 
  "    FxaaBool pairN = abs(gradientN) >= abs(gradientS);", "    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));", "    if(pairN) lengthSign = -lengthSign;", "    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posB;", "    posB.x = posM.x;", "    posB.y = posM.y;", "    FxaaFloat2 offNP;", "    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;", "    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;", 
  "    if(!horzSpan) posB.x += lengthSign * 0.5;", "    if( horzSpan) posB.y += lengthSign * 0.5;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posN;", "    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;", "    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;", "    FxaaFloat2 posP;", "    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;", "    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;", "    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;", "    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));", 
  "    FxaaFloat subpixE = subpixC * subpixC;", "    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));", "/*--------------------------------------------------------------------------*/", "    if(!pairN) lumaNN = lumaSS;", "    FxaaFloat gradientScaled = gradient * 1.0/4.0;", "    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;", "    FxaaFloat subpixF = subpixD * subpixE;", "    FxaaBool lumaMLTZero = lumaMM < 0.0;", "/*--------------------------------------------------------------------------*/", "    lumaEndN -= lumaNN * 0.5;", 
  "    lumaEndP -= lumaNN * 0.5;", "    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;", "    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;", "    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;", "    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;", "    FxaaBool doneNP = (!doneN) || (!doneP);", "    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;", "    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;", "/*--------------------------------------------------------------------------*/", "    if(doneNP) {", 
  "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "        doneN = abs(lumaEndN) >= gradientScaled;", "        doneP = abs(lumaEndP) >= gradientScaled;", "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;", "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;", "        doneNP = (!doneN) || (!doneP);", 
  "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;", "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;", "/*--------------------------------------------------------------------------*/", "        #if (FXAA_QUALITY_PS > 3)", "        if(doneNP) {", "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", 
  "            doneN = abs(lumaEndN) >= gradientScaled;", "            doneP = abs(lumaEndP) >= gradientScaled;", "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;", "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;", "            doneNP = (!doneN) || (!doneP);", "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;", "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;", "/*--------------------------------------------------------------------------*/", "            #if (FXAA_QUALITY_PS > 4)", 
  "            if(doneNP) {", "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                doneN = abs(lumaEndN) >= gradientScaled;", "                doneP = abs(lumaEndP) >= gradientScaled;", "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;", 
  "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;", "                doneNP = (!doneN) || (!doneP);", "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;", "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;", "/*--------------------------------------------------------------------------*/", "                #if (FXAA_QUALITY_PS > 5)", "                if(doneNP) {", "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", 
  "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                    doneN = abs(lumaEndN) >= gradientScaled;", "                    doneP = abs(lumaEndP) >= gradientScaled;", "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;", "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;", "                    doneNP = (!doneN) || (!doneP);", "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;", 
  "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;", "/*--------------------------------------------------------------------------*/", "                    #if (FXAA_QUALITY_PS > 6)", "                    if(doneNP) {", "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", 
  "                        doneN = abs(lumaEndN) >= gradientScaled;", "                        doneP = abs(lumaEndP) >= gradientScaled;", "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;", "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;", "                        doneNP = (!doneN) || (!doneP);", "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;", "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;", "/*--------------------------------------------------------------------------*/", 
  "                        #if (FXAA_QUALITY_PS > 7)", "                        if(doneNP) {", "                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                            doneN = abs(lumaEndN) >= gradientScaled;", 
  "                            doneP = abs(lumaEndP) >= gradientScaled;", "                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;", "                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;", "                            doneNP = (!doneN) || (!doneP);", "                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;", "                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;", "/*--------------------------------------------------------------------------*/", 
  "    #if (FXAA_QUALITY_PS > 8)", "    if(doneNP) {", "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "        doneN = abs(lumaEndN) >= gradientScaled;", "        doneP = abs(lumaEndP) >= gradientScaled;", "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;", "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;", 
  "        doneNP = (!doneN) || (!doneP);", "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;", "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;", "/*--------------------------------------------------------------------------*/", "        #if (FXAA_QUALITY_PS > 9)", "        if(doneNP) {", "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", 
  "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "            doneN = abs(lumaEndN) >= gradientScaled;", "            doneP = abs(lumaEndP) >= gradientScaled;", "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;", "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;", "            doneNP = (!doneN) || (!doneP);", "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;", "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;", "/*--------------------------------------------------------------------------*/", 
  "            #if (FXAA_QUALITY_PS > 10)", "            if(doneNP) {", "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                doneN = abs(lumaEndN) >= gradientScaled;", "                doneP = abs(lumaEndP) >= gradientScaled;", "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;", 
  "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;", "                doneNP = (!doneN) || (!doneP);", "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;", "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;", "/*--------------------------------------------------------------------------*/", "                #if (FXAA_QUALITY_PS > 11)", "                if(doneNP) {", "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", 
  "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                    doneN = abs(lumaEndN) >= gradientScaled;", "                    doneP = abs(lumaEndP) >= gradientScaled;", "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;", "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;", "                    doneNP = (!doneN) || (!doneP);", "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;", 
  "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;", "/*--------------------------------------------------------------------------*/", "                    #if (FXAA_QUALITY_PS > 12)", "                    if(doneNP) {", "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", 
  "                        doneN = abs(lumaEndN) >= gradientScaled;", "                        doneP = abs(lumaEndP) >= gradientScaled;", "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;", "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;", "                        doneNP = (!doneN) || (!doneP);", "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;", "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;", "/*--------------------------------------------------------------------------*/", 
  "                    }", "                    #endif", "/*--------------------------------------------------------------------------*/", "                }", "                #endif", "/*--------------------------------------------------------------------------*/", "            }", "            #endif", "/*--------------------------------------------------------------------------*/", "        }", "        #endif", "/*--------------------------------------------------------------------------*/", 
  "    }", "    #endif", "/*--------------------------------------------------------------------------*/", "                        }", "                        #endif", "/*--------------------------------------------------------------------------*/", "                    }", "                    #endif", "/*--------------------------------------------------------------------------*/", "                }", "                #endif", "/*--------------------------------------------------------------------------*/", 
  "            }", "            #endif", "/*--------------------------------------------------------------------------*/", "        }", "        #endif", "/*--------------------------------------------------------------------------*/", "    }", "/*--------------------------------------------------------------------------*/", "    FxaaFloat dstN = posM.x - posN.x;", "    FxaaFloat dstP = posP.x - posM.x;", "    if(!horzSpan) dstN = posM.y - posN.y;", "    if(!horzSpan) dstP = posP.y - posM.y;", "/*--------------------------------------------------------------------------*/", 
  "    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;", "    FxaaFloat spanLength = (dstP + dstN);", "    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;", "    FxaaFloat spanLengthRcp = 1.0/spanLength;", "/*--------------------------------------------------------------------------*/", "    FxaaBool directionN = dstN < dstP;", "    FxaaFloat dst = min(dstN, dstP);", "    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;", "    FxaaFloat subpixG = subpixF * subpixF;", "    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;", 
  "    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;", "    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);", "    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;", "    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;", "    #if (FXAA_DISCARD == 1)", "        return FxaaTexTop(tex, posM);", "    #else", "        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);", 
  "    #endif", "}", "/*==========================================================================*/", "#endif", "", "void main() {", "  gl_FragColor = FxaaPixelShader(", "    vUv,", "    vec4(0.0),", "    tDiffuse,", "    tDiffuse,", "    tDiffuse,", "    resolution,", "    vec4(0.0),", "    vec4(0.0),", "    vec4(0.0),", "    0.75,", "    0.166,", "    0.0833,", "    0.0,", "    0.0,", "    0.0,", "    vec4(0.0)", "  );", "", "  // TODO avoid querying texture twice for same texel", "  gl_FragColor.a = texture2D(tDiffuse, vUv).a;", 
  "}"].join("\n")
};
Zr = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
Kr = new THREE.Scene, $r = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
$r.frustumCulled = false, Kr.add($r);
var en = new THREE.Color;
var tn = function() {
  function init(shader, e, data, uid) {
    r(this, init);
    this.clear = true;
    this.clearColor = new THREE.Color(0, 0, 0);
    this.clearAlpha = 1;
    this.clearDepthStencil = true;
    this.textureID = void 0 !== e ? e : "tDiffuse";
    this.resolutionID = void 0 !== data ? data : "resolution";
    this.resolutionScaler = void 0 !== uid ? uid : 1;
    if (shader instanceof THREE.ShaderMaterial) {
      this.uniforms = shader.uniforms;
      this.material = shader;
    } else {
      if (shader) {
        this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
        this.material = new THREE.ShaderMaterial({
          defines : Object.assign({}, shader.defines),
          uniforms : this.uniforms,
          vertexShader : shader.vertexShader || "\n\tvarying vec2 vUv;\n\tvoid main() {\n\t\tvUv = uv;\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t}\n",
          fragmentShader : shader.fragmentShader
        });
      }
    }
  }
  return init.prototype.setSize = function(a, h) {
    if (this.uniforms[this.resolutionID]) {
      this.uniforms[this.resolutionID].value.set(this.resolutionScaler / a, this.resolutionScaler / h);
    }
  }, init.prototype.render = function(p, value, data, item, type) {
    if (this.uniforms[this.textureID] && data) {
      this.uniforms[this.textureID].value = data.texture;
    }
    if (this.uniforms.time) {
      this.uniforms.time.value += item;
      if (this.uniforms.time.value > 10) {
        this.uniforms.time.value = 0;
      }
    }
    var color = p.getClearAlpha();
    var autoClear = p.autoClear;
    p.autoClear = false;
    if (this.clear) {
      en.copy(p.getClearColor());
      p.setClearColor(this.clearColor, this.clearAlpha);
    }
    $r.material = this.material;
    p.setRenderTarget(void 0 !== value ? value : null);
    if (this.clear) {
      p.clear(true, this.clearDepthStencil, this.clearDepthStencil);
    }
    p.render(Kr, Zr);
    if (this.clear) {
      p.setClearColor(en, color);
    }
    p.autoClear = autoClear;
  }, init;
}();
rn = {
  minFilter : THREE.LinearFilter,
  magFilter : THREE.LinearFilter,
  format : THREE.RGBAFormat,
  stencilBuffer : false,
  generateMipmaps : false
};
function nn(x, n, v) {
  var v2pushes = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
  var p = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 8;
  var options = new THREE.WebGLMultisampleRenderTarget(n, v, rn);
  return options.texture.name = x + ".mrt", options.stencilBuffer = v2pushes, options.samples = Math.min(5, p), options;
}
function on(id, t, i) {
  var inComponent = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
  var n = new THREE.WebGLRenderTarget(t, i, rn);
  return n.texture.name = id + ".rt", n.stencilBuffer = inComponent, n;
}
function sn(i, arg, data) {
  return {
    vertexShader : "\n\t\t\t#include <common>\n\t\t\t#include <skinning_pars_vertex>\n\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\tvoid main() {\n\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <skinning_vertex>\n\t\t\t\t#include <project_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t}\n\t\t",
    fragmentShader : "\n\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\tvoid main() {\n\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\tgl_FragColor = vec4(" + i.toFixed(1) + ", " + arg.toFixed(1) + ", " + data.toFixed(1) + ", 1.0);\n\t\t\t}\n\t\t"
  };
}
var an = sn(0, 0, 0);
ln = new Map;
function un(object, fn) {
  var item = object.isInstancedMesh + "_" + fn.skinning;
  var left = void 0;
  return ln.has(item) ? left = ln.get(item) : ((left = new THREE.ShaderMaterial(an)).skinning = fn.skinning, ln.set(item, left)), left;
}
function cn(material, json) {
  var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
  material.depthTest = json.depthTest;
  material.depthWrite = json.depthWrite;
  material.colorWrite = json.colorWrite;
  if (material.colorWrite && !i) {
    material.colorWrite = !(json.transparent && !json.depthWrite);
  }
  material.side = json.side;
}
function hn(data, id) {
  if (!data) {
    return null;
  }
  var b = data[id];
  return b ? "[object Object]" === toString.call(b) ? b.skip ? "skip" : void 0 !== b.value ? b.value : 1 : b : null;
}
function pn(rs, arg) {
  return "BackgroundCubeMaterial" == arg.name || "BackgroundMaterial" == arg.name || "sky" === rs.name || true === rs.isSky;
}
var dn = function() {
  function e(i, type, data, callback) {
    r(this, e);
    this._mrt = nn("SceneBuffer", i, type, data, callback);
    this._rt = on("SceneBuffer", i, type, data);
    this._depthBindType = null;
    this.useMRT = false;
  }
  return e.prototype.setDepthTexture = function(depthTex) {
    return this._rt.depthTexture !== depthTex && (this._rt.depthTexture = depthTex, this._rt.webglDepthRenderbuffer = null, this._rt.dispose(), true);
  }, e.prototype.setDepthRenderBuffer = function(radio_sub_frequency, radio_main_frequency) {
    return (this._rt.webglDepthRenderbuffer !== radio_main_frequency || this._mrt.webglDepthRenderbuffer !== radio_sub_frequency) && (this._rt.depthTexture = null, this._rt.webglDepthRenderbuffer = radio_main_frequency, this._mrt.webglColorRenderbuffer = null, this._mrt.webglDepthRenderbuffer = radio_sub_frequency, this._rt.dispose(), this._mrt.dispose(), true);
  }, e.prototype.setColorDepthRenderBuffer = function(key, value) {
    return (this._mrt.webglColorRenderbuffer !== key || this._mrt.webglDepthRenderbuffer !== value) && (this._mrt.webglColorRenderbuffer = key, this._mrt.webglDepthRenderbuffer = value, this._mrt.dispose(), true);
  }, e.prototype.setSize = function(v, h) {
    this._mrt.setSize(v, h);
    this._rt.setSize(v, h);
  }, e.prototype.render = function(options, e, item) {
    var r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
    var autoClear = options.autoClear;
    options.autoClear = false;
    options.setRenderTarget(this.useMRT ? this._mrt : this._rt);
    if (r) {
      options.clear();
    }
    options.render(e, item);
    options.autoClear = autoClear;
  }, e.prototype.getSchemeTexture = function() {
    return this.useMRT ? this._mrt.texture : this._rt.texture;
  }, e.prototype.getSchemeBuffer = function() {
    return this.useMRT ? this._mrt : this._rt;
  }, e.prototype.dispose = function() {
    this._mrt.dispose();
    this._rt.dispose();
  }, e;
}();
fn = {
  _USE_ROUGHNESSMAP : false
};
mn = {
  roughness : {
    value : 1
  },
  roughnessMap : {
    value : null
  }
};
gn = "\n        varying vec3 vNormal;\n        varying vec2 vUv;\n\n        #include <common>\n        #include <morphtarget_pars_vertex>\n        #include <skinning_pars_vertex>\n        // #include <logdepthbuf_pars_vertex>\n        #include <clipping_planes_pars_vertex>\n\n        void main() {\n\n            vUv = uv;\n\n            #include <beginnormal_vertex>\n            #include <morphnormal_vertex>\n            #include <skinbase_vertex>\n            #include <skinnormal_vertex>\n\n            // @THREE-Modification\n            // normal instanced\n            #ifdef INSTANCED\n\n                mat4 instanceMat = compose( instancePosition, instanceQuaternion, instanceScale );\n                mat3 im = mat3( instanceMat );\n                objectNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n                objectNormal = im * objectNormal;\n\n            #endif\n\n            #include <defaultnormal_vertex>\n\n            vNormal = normalize( transformedNormal );\n\n            #include <begin_vertex>\n\n            // @THREE-Modification\n            // position instanced\n            #ifdef INSTANCED\n                transformed.xyz = ( instanceMat * vec4( transformed, 1.0 ) ).xyz;\n            #endif\n\n            #include <morphtarget_vertex>\n            #include <skinning_vertex>\n            #include <project_vertex>\n            // #include <logdepthbuf_vertex>\n            #include <clipping_planes_vertex>\n\n        }\n    ";
vn = "\n        uniform float roughness;\n\n        #ifdef _USE_ROUGHNESSMAP\n            uniform sampler2D roughnessMap;\n        #endif\n\n        varying vec3 vNormal;\n        varying vec2 vUv;\n\n        #include <packing>\n        // #include <logdepthbuf_pars_fragment>\n        #include <clipping_planes_pars_fragment>\n\n        void main() {\n\n            #include <clipping_planes_fragment>\n            // #include <logdepthbuf_fragment>\n\n            vec3 normal = normalize( vNormal );\n\n            #ifdef DOUBLE_SIDED\n\t\t        normal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);\n\t        #endif\n\n            float roughnessFactor = roughness;\n\n            #ifdef _USE_ROUGHNESSMAP\n                roughnessFactor *= texture2D( roughnessMap, vUv ).g;\n            #endif\n\n            gl_FragColor = vec4( packNormalToRGB( normal ), clamp(1. - roughnessFactor, 0., 1.) );\n\n        }\n    ";
yn = function() {
  function init(width, height) {
    r(this, init);
    this._rt = new THREE.WebGLRenderTarget(width, height, {
      minFilter : THREE.NearestFilter,
      magFilter : THREE.NearestFilter,
      format : THREE.RGBAFormat,
      type : THREE.HalfFloatType,
      generateMipmaps : false
    });
    this._rt.depthTexture = new THREE.DepthTexture(width, height);
    this._rt.depthTexture.format = THREE.DepthStencilFormat;
    this._rt.depthTexture.type = THREE.UnsignedInt248Type;
    this._rt.depthTexture.generateMipmaps = false;
    this.ignoreTransparent = true;
  }
  return init.prototype._checkStrategyInited = function(charsetPart) {
    return charsetPart.materialManager.hasStrategy("GBuffer");
  }, init.prototype._initStrategy = function(charsetPart) {
    var destination = this;
    charsetPart.materialManager.addStrategy("GBuffer", function(canCreateDiscussions, i, isSlidingUp, n, source, s) {
      return destination.ignoreTransparent && source.transparent || pn(this, source) || source.isSpriteMaterial || this._gBufferIgnore || destination.ignoreTransparent && source.alphaTest > 0 ? null : _n.getNormalGlossinessMaterial(this, source);
    });
  }, init.prototype.setSize = function(v, h) {
    this._rt.setSize(v, h);
  }, init.prototype.render = function(p, obj, item, object) {
    if (!this._checkStrategyInited(p)) {
      this._initStrategy(p);
    }
    this.ignoreTransparent = object;
    var color = p.getClearColor().getHex();
    var a = p.getClearAlpha();
    var autoClear = p.autoClear;
    p.autoClear = false;
    p.setClearColor(7829503, 0);
    p.materialManager.setMode("GBuffer");
    var value = obj.autoUpdate;
    var c = obj.background;
    var enable = p.shadowMap.enable;
    obj.autoUpdate = false;
    obj.background = null;
    p.shadowMap.enable = false;
    p.initRenderList = false;
    p.renderCustom1 = false;
    p.setRenderTarget(this._rt);
    p.clear();
    p.render(obj, item);
    obj.autoUpdate = value;
    obj.background = c;
    p.shadowMap.enable = enable;
    p.initRenderList = true;
    p.renderCustom1 = true;
    p.materialManager.setMode(0);
    p.autoClear = autoClear;
    p.setClearColor(color, a);
  }, init.prototype.getNormalGlossinessTexture = function() {
    return this._rt.texture;
  }, init.prototype.getDepthTexture = function() {
    return this._rt.depthTexture;
  }, init.prototype.dispose = function() {
    this._rt.dispose();
  }, init;
}();
bn = {};
_n = new (function() {
  function a() {
    r(this, a);
    this._normalGlossinessMaterials = new Map;
  }
  return a.prototype.getNormalGlossinessMaterial = function(reply, source) {
    bn.instancing = reply.isInstancedMesh;
    bn.useRoughnessMap = !!source.roughnessMap && void 0 === reply._gBufferRoughness;
    bn.skinning = source.skinning;
    bn.morphTargets = source.morphTargets;
    bn.morphNormals = source.morphNormals;
    bn.side = source.side;
    bn.instanced = source.defines && ("" === source.defines.INSTANCED || source.defines.INSTANCED);
    var data = void 0;
    var r = bn.instancing + "_" + bn.useRoughnessMap + "_" + bn.skinning + "_" + bn.morphTargets + "_" + bn.morphNormals + "_" + bn.side + "_" + bn.instanced;
    if (this._normalGlossinessMaterials.has(r)) {
      data = this._normalGlossinessMaterials.get(r);
    } else {
      (data = new THREE.ShaderMaterial({
        defines : Object.assign({}, fn),
        uniforms : THREE.UniformsUtils.clone(mn),
        vertexShader : gn,
        fragmentShader : vn
      })).skinning = source.skinning;
      data.morphTargets = source.morphTargets;
      data.morphNormals = source.morphNormals;
      data.side = source.side;
      data.defines._USE_ROUGHNESSMAP = !!bn.useRoughnessMap && "";
      if (bn.instanced) {
        data.defines.INSTANCED = "";
      }
      this._normalGlossinessMaterials.set(r, data);
    }
    var height = .5;
    return void 0 !== reply._gBufferRoughness ? height = reply._gBufferRoughness : void 0 !== source.roughness && (height = source.roughness), data.uniforms.roughness.value = height, data.uniforms.roughnessMap.value = source.roughnessMap, data.uniformsNeedUpdate = true, data;
  }, a;
}());
xn = {
  defines : {
    DEPTH_PACKING : 1,
    KERNEL_SIZE : 64,
    EPSILON : 1e-6
  },
  uniforms : {
    normalTex : {
      value : null
    },
    depthTex : {
      value : null
    },
    noiseTex : {
      value : null
    },
    texSize : {
      value : new THREE.Vector2
    },
    noiseTexSize : {
      value : new THREE.Vector2(4, 4)
    },
    projection : {
      value : new THREE.Matrix4
    },
    projectionInv : {
      value : new THREE.Matrix4
    },
    kernel : {
      value : null
    },
    radius : {
      value : .2
    },
    power : {
      value : 1
    },
    bias : {
      value : .004
    },
    intensity : {
      value : 1
    }
  },
  vertexShader : ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader : ["precision highp sampler2D;", "#include <packing>", "varying vec2 vUv;", "uniform sampler2D normalTex;", "uniform sampler2D depthTex;", "uniform vec2 texSize;", "uniform sampler2D noiseTex;", "uniform vec2 noiseTexSize;", "uniform mat4 projection;", "uniform mat4 projectionInv;", "uniform vec3 kernel[KERNEL_SIZE];", "uniform float radius;", "uniform float power;", "uniform float bias;", "uniform float intensity;", "float getDepth( const in vec2 screenPosition ) {", "#if DEPTH_PACKING == 1", 
  "return unpackRGBAToDepth( texture2D( depthTex, screenPosition ) );", "#elif DEPTH_PACKING == 2", "return texture2D( depthTex, screenPosition ).w;", "#else", "return texture2D( depthTex, screenPosition ).x;", "#endif", "}", "vec3 getViewNormal( const in vec2 screenPosition ) {", "return unpackRGBToNormal( texture2D( normalTex, screenPosition ).xyz );", "}", "float ssaoEstimator(in mat3 kernelBasis, in vec3 originPos, in vec3 N) {", "float occlusion = 0.0;", "for (int i = 0; i < KERNEL_SIZE; i++) {", 
  "vec3 samplePos = kernel[i];", "samplePos = kernelBasis * samplePos;", "samplePos = samplePos * radius + originPos;", "vec4 texCoord = projection * vec4(samplePos, 1.0);", "texCoord.xy /= texCoord.w;", "texCoord.xy = texCoord.xy * 0.5 + 0.5;", "float sampleDepth = getDepth(texCoord.xy);", "float z = sampleDepth * 2.0 - 1.0;", "#ifdef ALCHEMY", "vec4 projectedPos = vec4(texCoord.xy * 2.0 - 1.0, z, 1.0);", "vec4 p4 = projectionInv * projectedPos;", "p4.xyz /= p4.w;", "vec3 cDir = p4.xyz - originPos;", 
  "float vv = dot(cDir, cDir);", "float vn = dot(cDir, N);", "float radius2 = radius * radius;", "vn = max(vn + p4.z * bias, 0.0);", "float f = max(radius2 - vv, 0.0) / radius2;", "occlusion += f * f * f * max(vn / (0.01 + vv), 0.0);", "#else", "if (projection[3][3] == 0.0) {", "z = projection[3][2] / (z * projection[2][3] - projection[2][2]);", "} else {", "z = (z - projection[3][2]) / projection[2][2];", "}", "float factor = step(samplePos.z, z - bias);", "float rangeCheck = smoothstep(0.0, 1.0, radius / abs(originPos.z - z));", 
  "occlusion += rangeCheck * factor;", "#endif", "}", "occlusion = 1.0 - occlusion / float(KERNEL_SIZE);", "return pow(occlusion, power);", "}", "void main() {", "float centerDepth = getDepth( vUv );", "if( centerDepth >= ( 1.0 - EPSILON ) ) {", "\tdiscard;", "}", "vec3 N = getViewNormal( vUv );", "vec2 noiseTexCoord = texSize / vec2(noiseTexSize) * vUv;", "vec3 rvec = texture2D(noiseTex, noiseTexCoord).rgb * 2.0 - 1.0;", "vec3 T = normalize(rvec - N * dot(rvec, N));", "vec3 BT = normalize(cross(N, T));", 
  "mat3 kernelBasis = mat3(T, BT, N);", "float z = centerDepth * 2.0 - 1.0;", "vec4 projectedPos = vec4(vUv * 2.0 - 1.0, z, 1.0);", "vec4 p4 = projectionInv * projectedPos;", "vec3 position = p4.xyz / p4.w;", "float ao = ssaoEstimator(kernelBasis, position, N);", "ao = clamp(1.0 - (1.0 - ao) * intensity, 0.0, 1.0);", "gl_FragColor = vec4(vec3(ao), 1.0);", "}"].join("\n")
};
En = {
  defines : {
    NORMALTEX_ENABLED : 1,
    DEPTHTEX_ENABLED : 1,
    DEPTH_PACKING : 1
  },
  uniforms : {
    tDiffuse : {
      value : null
    },
    textureSize : {
      value : new THREE.Vector2
    },
    direction : {
      value : 0
    },
    blurSize : {
      value : 1
    },
    depthTex : {
      value : null
    },
    normalTex : {
      value : null
    },
    projection : {
      value : new THREE.Matrix4
    },
    depthRange : {
      value : 1
    }
  },
  vertexShader : ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader : ["#include <packing>", "varying vec2 vUv;", "uniform vec2 textureSize;", "uniform float blurSize;", "uniform sampler2D tDiffuse;", "uniform int direction;", "#if NORMALTEX_ENABLED == 1", "uniform sampler2D normalTex;", "vec3 getViewNormal( const in vec2 screenPosition ) {", "return unpackRGBToNormal( texture2D( normalTex, screenPosition ).xyz );", "}", "#endif", "#if DEPTHTEX_ENABLED == 1", "uniform sampler2D depthTex;", "uniform mat4 projection;", "uniform float depthRange;", 
  "float getDepth( const in vec2 screenPosition ) {", "#if DEPTH_PACKING == 1", "return unpackRGBAToDepth( texture2D( depthTex, screenPosition ) );", "#elif DEPTH_PACKING == 2", "return texture2D( depthTex, screenPosition ).w;", "#else", "return texture2D( depthTex, screenPosition ).x;", "#endif", "}", "float getLinearDepth(vec2 coord) {", "float depth = getDepth(coord) * 2.0 - 1.0;", "return projection[3][2] / (depth * projection[2][3] - projection[2][2]);", "}", "#endif", "void main() {", "float kernel[5];", 
  "kernel[0] = 0.122581;", "kernel[1] = 0.233062;", "kernel[2] = 0.288713;", "kernel[3] = 0.233062;", "kernel[4] = 0.122581;", "vec2 off = vec2(0.0);", "if (direction == 0) {", "off[0] = blurSize / textureSize.x;", "}", "else {", "off[1] = blurSize / textureSize.y;", "}", "float sum = 0.0;", "float weightAll = 0.0;", "#if NORMALTEX_ENABLED == 1", "vec3 centerNormal = getViewNormal(vUv);", "#endif", "#if DEPTHTEX_ENABLED == 1", "float centerDepth = getLinearDepth(vUv);", "#endif", "for (int i = 0; i < 5; i++) {", 
  "vec2 coord = clamp(vUv + vec2(float(i) - 2.0) * off, vec2(0.0), vec2(1.0));", "float w = kernel[i];", "#if NORMALTEX_ENABLED == 1", "vec3 normal = getViewNormal(coord);", "w *= clamp(dot(normal, centerNormal), 0.0, 1.0);", "#endif", "#if DEPTHTEX_ENABLED == 1", "float d = getLinearDepth(coord);", "w *= (1.0 - smoothstep(0.0, 1.0, abs(centerDepth - d) / depthRange));", "#endif", "weightAll += w;", "sum += w * texture2D(tDiffuse, coord).r;", "}", "gl_FragColor = vec4(vec3(sum / weightAll), 1.0);", 
  "}"].join("\n")
};
function wn(str) {
  return str.replace(/^\S/, function(shortMonthName) {
    return shortMonthName.toUpperCase();
  });
}
function Tn(annotations, e) {
  if ("[object Object]" !== e.toString()) {
    return e;
  }
  var i;
  for (i in e) {
    if (e.hasOwnProperty(i)) {
      if (!annotations) {
        annotations = {};
      }
      annotations[i] = Tn(annotations[i], e[i]);
    }
  }
  return annotations;
}
var Mn = {
  minFilter : THREE.LinearFilter,
  magFilter : THREE.LinearFilter,
  format : THREE.RGBAFormat,
  depthBuffer : false,
  stencilBuffer : false,
  generateMipmaps : false
};
function Cn(x, h) {
  return new THREE.WebGLRenderTarget(x, h, Mn);
}
var Sn = new Map;
function jn(g) {
  var serial_out_view = new Uint8Array(g * g * 4);
  var serial_out_itor = 0;
  var r = new THREE.Vector3;
  var maxVal = 0;
  for (; maxVal < g; maxVal++) {
    var maxVal = 0;
    for (; maxVal < g; maxVal++) {
      r.set(2 * Math.random() - 1, 2 * Math.random() - 1, 0).normalize();
      serial_out_view[serial_out_itor++] = 255 * (.5 * r.x + .5);
      serial_out_view[serial_out_itor++] = 255 * (.5 * r.y + .5);
      serial_out_view[serial_out_itor++] = 0;
      serial_out_view[serial_out_itor++] = 255;
    }
  }
  return serial_out_view;
}
function Pn(cursor, base) {
  var zip_opt_len = 0;
  var f = 1 / base;
  var i = cursor;
  for (; i > 0;) {
    zip_opt_len = zip_opt_len + f * (i % base);
    i = Math.floor(i / base);
    f = f / base;
  }
  return zip_opt_len;
}
var Rn = function() {
  function update(w, scale) {
    r(this, update);
    this._tempRenderTarget = Cn(w, scale);
    this._tempRenderTarget2 = Cn(w, scale);
    this._ssaoPass = new tn(xn, void 0, "texSize");
    this._ssaoPass.material.depthTest = false;
    this._ssaoPass.material.depthWrite = false;
    this._blurPass = new tn(En, void 0, "textureSize");
    this._blurPass.material.depthTest = false;
    this._blurPass.material.depthWrite = false;
    this._blurPass.material.transparent = true;
    this._blurPass.material.blending = THREE.CustomBlending;
    this._blurPass.material.blendSrc = THREE.ZeroFactor;
    this._blurPass.material.blendDst = THREE.SrcColorFactor;
    this._blurPass.material.blendEquation = THREE.AddEquation;
    this._blurPass.material.blendSrcAlpha = THREE.ZeroFactor;
    this._blurPass.material.blendDstAlpha = THREE.SrcColorFactor;
    this._blurPass.material.blendEquationAlpha = THREE.AddEquation;
    this._kernels = {};
    this.setNoiseSize(4);
    this.setKernelSize(12);
    this.setParameter("radius", .2);
    this.setParameter("bias", .004);
    this.setParameter("power", 1);
    this.setParameter("intensity", .8);
    this.setParameter("blurSize", 1);
    this._ssaoPass.setSize(1 / w, 1 / scale);
    this._blurPass.setSize(1 / w, 1 / scale);
  }
  return update.prototype.setKernelSize = function(i, size) {
    size = void 0 !== size ? size : 0;
    if (!this._kernels[i + "_" + size]) {
      this._kernels[i + "_" + size] = function(entries, gramSize, zoomAware) {
        var dst = new Float32Array(3 * entries);
        gramSize = gramSize || 0;
        var i = 0;
        for (; i < entries; i++) {
          var overlookAngle = Pn(i + gramSize, 2) * (zoomAware ? 1 : 2) * Math.PI;
          var angle = Pn(i + gramSize, 3) * Math.PI;
          var a = Math.random();
          var w = Math.cos(overlookAngle) * Math.sin(angle) * a;
          var a3 = Math.cos(angle) * a;
          var a2 = Math.sin(overlookAngle) * Math.sin(angle) * a;
          dst[3 * i] = w;
          dst[3 * i + 1] = a3;
          dst[3 * i + 2] = a2;
        }
        return dst;
      }(i, i * size, true);
    }
    this._ssaoPass.material.defines.KERNEL_SIZE = i;
    this._ssaoPass.material.uniforms.kernel.value = this._kernels[i + "_" + size];
    this._ssaoPass.material.needsUpdate = true;
  }, update.prototype.setNoiseSize = function(size) {
    var texture = this._ssaoPass.material.uniforms.noiseTex.value;
    if (texture) {
      texture.image.data = jn(size);
      texture.image.width = size;
      texture.image.height = size;
      texture.needsUpdate = true;
    } else {
      texture = function(width) {
        var noise = new THREE.DataTexture(jn(width), width, width, THREE.RGBAFormat, THREE.UnsignedByteType, THREE.UVMapping, THREE.RepeatWrapping, THREE.RepeatWrapping);
        return noise.needsUpdate = true, noise;
      }(size);
      this._ssaoPass.material.uniforms.noiseTex.value = texture;
    }
    this._ssaoPass.material.uniforms.noiseTexSize.value.set(size, size);
  }, update.prototype.setParameter = function(name, val) {
    if ("noiseTexSize" === name) {
      this.setNoiseSize(val);
    } else {
      if ("kernelSize" === name) {
        this.setKernelSize(val);
      } else {
        if ("blurSize" === name) {
          this._blurPass.material.uniforms.blurSize.value = val;
        } else {
          this._ssaoPass.material.uniforms[name].value = val;
        }
      }
    }
  }, update.prototype.setSize = function(v, w) {
    this._tempRenderTarget.setSize(v, w);
    this._tempRenderTarget2.setSize(v, w);
    this._ssaoPass.setSize(1 / v, 1 / w);
    this._blurPass.setSize(1 / v, 1 / w);
  }, update.prototype.render = function(o, n, name, target, value, flat) {
    this._ssaoPass.material.uniforms.normalTex.value = o;
    this._ssaoPass.material.uniforms.depthTex.value = n;
    this._ssaoPass.material.uniforms.projection.value.copy(target.projectionMatrix);
    this._ssaoPass.material.uniforms.projectionInv.value.getInverse(target.projectionMatrix);
    this._blurPass.material.uniforms.normalTex.value = o;
    this._blurPass.material.uniforms.depthTex.value = n;
    this._blurPass.material.uniforms.projection.value.copy(target.projectionMatrix);
    if (n === o) {
      this._ssaoPass.material.defines.DEPTH_PACKING = 2;
      this._blurPass.material.defines.DEPTH_PACKING = 2;
    } else {
      if (n.isDepthTexture) {
        this._ssaoPass.material.defines.DEPTH_PACKING = 0;
        this._blurPass.material.defines.DEPTH_PACKING = 0;
      } else {
        this._ssaoPass.material.defines.DEPTH_PACKING = 1;
        this._blurPass.material.defines.DEPTH_PACKING = 1;
      }
    }
    this._ssaoPass.clearColor.setRGB(1, 1, 1);
    this._ssaoPass.clearAlpha = 1;
    this._ssaoPass.render(name, this._tempRenderTarget);
    this._blurPass.clearColor.setRGB(1, 1, 1);
    this._blurPass.clearAlpha = 1;
    this._blurPass.clear = true;
    this._blurPass.material.uniforms.direction.value = 0;
    this._blurPass.material.transparent = false;
    this._blurPass.render(name, this._tempRenderTarget2, this._tempRenderTarget);
    if (flat) {
      this._blurPass.clearColor.setRGB(0, 0, 0);
      this._blurPass.clearAlpha = 0;
    } else {
      this._blurPass.clear = false;
    }
    this._blurPass.material.uniforms.direction.value = 1;
    this._blurPass.material.transparent = !flat;
    this._blurPass.material.blending = flat ? THREE.NoBlending : THREE.CustomBlending;
    this._blurPass.render(name, void 0 !== value ? value : null, this._tempRenderTarget2);
  }, update.prototype.dispose = function() {
    this._tempRenderTarget.dispose();
    this._tempRenderTarget2.dispose();
    this._ssaoPass.material.dispose();
    this._blurPass.material.dispose();
  }, update;
}();
Dn = {
  defines : {},
  uniforms : {
    colorTex : {
      value : null
    },
    gBufferTexture1 : {
      value : null
    },
    gBufferTexture2 : {
      value : null
    },
    projection : {
      value : new THREE.Matrix4
    },
    projectionInv : {
      value : new THREE.Matrix4
    },
    maxRayDistance : {
      value : 200
    },
    pixelStride : {
      value : 16
    },
    pixelStrideZCutoff : {
      value : 50
    },
    screenEdgeFadeStart : {
      value : .9
    },
    eyeFadeStart : {
      value : .4
    },
    eyeFadeEnd : {
      value : .8
    },
    minGlossiness : {
      value : .2
    },
    zThicknessThreshold : {
      value : .1
    },
    jitterOffset : {
      value : 0
    },
    nearZ : {
      value : 0
    },
    viewportSize : {
      value : new THREE.Vector2(512, 512)
    },
    maxMipmapLevel : {
      value : 5
    }
  },
  vertexShader : "\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n    ",
  fragmentShader : "\n        #define MAX_ITERATION 20;\n\t\t#define MAX_BINARY_SEARCH_ITERATION 5;\n\n\t\tuniform sampler2D colorTex;\n\t\tuniform sampler2D gBufferTexture1;\n\t\tuniform sampler2D gBufferTexture2;\n\n\t\tuniform mat4 projection;\n\t\tuniform mat4 projectionInv;\n\t\t// uniform mat4 viewInverseTranspose;\n\n\t\tuniform float maxRayDistance;\n\n\t\tuniform float pixelStride;\n\t\t// ray origin Z at this distance will have a pixel stride of 1.0\n\t\tuniform float pixelStrideZCutoff;\n\n\t\t// distance to screen edge that ray hits will start to fade (0.0 -> 1.0)\n\t\tuniform float screenEdgeFadeStart;\n\n\t\t// ray direction's Z that ray hits will start to fade (0.0 -> 1.0)\n\t\tuniform float eyeFadeStart;\n\t\t// ray direction's Z that ray hits will be cut (0.0 -> 1.0)\n\t\tuniform float eyeFadeEnd;\n\n\t\t// Object larger than minGlossiness will have ssr effect\n\t\tuniform float minGlossiness;\n\t\tuniform float zThicknessThreshold;\n\n\t\tuniform float jitterOffset;\n\n\t\tuniform float nearZ;\n\t\tuniform vec2 viewportSize;\n\n        uniform float maxMipmapLevel;\n        \n        varying vec2 vUv;\n\n        float fetchDepth(sampler2D depthTexture, vec2 uv) {\n\t\t\tvec4 depthTexel = texture2D(depthTexture, uv);\n\t\t\treturn depthTexel.r * 2.0 - 1.0;\n\t\t}\n\n\t\tfloat linearDepth(float depth) {\n\t\t\treturn projection[3][2] / (depth * projection[2][3] - projection[2][2]);\n\t\t}\n\n\t\tbool rayIntersectDepth(float rayZNear, float rayZFar, vec2 hitPixel) {\n\t\t    // Swap if bigger\n\t\t\tif (rayZFar > rayZNear) {\n\t\t\t\tfloat t = rayZFar; rayZFar = rayZNear; rayZNear = t;\n\t\t\t}\n\t\t\tfloat cameraZ = linearDepth(fetchDepth(gBufferTexture2, hitPixel));\n\t\t    // float cameraBackZ = linearDepth(fetchDepth(backDepthTex, hitPixel));\n\t\t    // Cross z\n\t\t\treturn rayZFar <= cameraZ && rayZNear >= cameraZ - zThicknessThreshold;\n\t\t}\n\n\t\t// Trace a ray in screenspace from rayOrigin (in camera space) pointing in rayDir (in camera space)\n\t\t//\n\t\t// With perspective correct interpolation\n\t\t//\n\t\t// Returns true if the ray hits a pixel in the depth buffer\n\t\t// and outputs the hitPixel (in UV space), the hitPoint (in camera space) and the number\n\t\t// of iterations it took to get there.\n\t\t//\n\t\t// Based on Morgan McGuire & Mike Mara's GLSL implementation:\n\t\t// http://casual-effects.blogspot.com/2014/08/screen-space-ray-tracing.html\n\t\tbool traceScreenSpaceRay(vec3 rayOrigin, vec3 rayDir, float jitter, out vec2 hitPixel, out vec3 hitPoint, out float iterationCount) {\n\t\t    // Clip to the near plane\n\t\t\tfloat rayLength = ((rayOrigin.z + rayDir.z * maxRayDistance) > -nearZ) ? (-nearZ - rayOrigin.z) / rayDir.z : maxRayDistance;\n\n\t\t\tvec3 rayEnd = rayOrigin + rayDir * rayLength;\n\n\t\t    // Project into homogeneous clip space\n\t\t\tvec4 H0 = projection * vec4(rayOrigin, 1.0);\n\t\t\tvec4 H1 = projection * vec4(rayEnd, 1.0);\n\n\t\t\tfloat k0 = 1.0 / H0.w, k1 = 1.0 / H1.w;\n\n\t\t    // The interpolated homogeneous version of the camera space points\n\t\t\tvec3 Q0 = rayOrigin * k0, Q1 = rayEnd * k1;\n\n\t\t    // Screen space endpoints\n\t\t    // PENDING viewportSize ?\n\t\t\tvec2 P0 = (H0.xy * k0 * 0.5 + 0.5) * viewportSize;\n\t\t\tvec2 P1 = (H1.xy * k1 * 0.5 + 0.5) * viewportSize;\n\n\t\t    // If the line is degenerate, make it cover at least one pixel to avoid handling\n\t\t    // zero-pixel extent as a special case later\n\t\t\tP1 += dot(P1 - P0, P1 - P0) < 0.0001 ? 0.01 : 0.0;\n\t\t\tvec2 delta = P1 - P0;\n\n\t\t    // Permute so that the primary iteration is in x to collapse\n\t\t    // all quadrant-specific DDA case later\n\t\t\tbool permute = false;\n\t\t\tif (abs(delta.x) < abs(delta.y)) {\n\t\t    // More vertical line\n\t\t\t\tpermute = true;\n\t\t\t\tdelta = delta.yx;\n\t\t\t\tP0 = P0.yx;\n\t\t\t\tP1 = P1.yx;\n\t\t\t}\n\t\t\tfloat stepDir = sign(delta.x);\n\t\t\tfloat invdx = stepDir / delta.x;\n\n\t\t    // Track the derivatives of Q and K\n\t\t\tvec3 dQ = (Q1 - Q0) * invdx;\n\t\t\tfloat dk = (k1 - k0) * invdx;\n\n\t\t\tvec2 dP = vec2(stepDir, delta.y * invdx);\n\n            // Calculate pixel stride based on distance of ray origin from camera.\n            // Since perspective means distant objects will be smaller in screen space\n            // we can use this to have higher quality reflections for far away objects\n            // while still using a large pixel stride for near objects (and increase performance)\n            // this also helps mitigate artifacts on distant reflections when we use a large\n            // pixel stride.\n\t\t\tfloat strideScaler = 1.0 - min(1.0, -rayOrigin.z / pixelStrideZCutoff);\n\t\t\tfloat pixStride = 1.0 + strideScaler * pixelStride;\n\n\t\t    // Scale derivatives by the desired pixel stride and the offset the starting values by the jitter fraction\n\t\t\tdP *= pixStride; dQ *= pixStride; dk *= pixStride;\n\n\t\t    // Track ray step and derivatives in a vec4 to parallelize\n\t\t\tvec4 pqk = vec4(P0, Q0.z, k0);\n\t\t\tvec4 dPQK = vec4(dP, dQ.z, dk);\n\n\t\t\tpqk += dPQK * jitter;\n\t\t\tfloat rayZFar = (dPQK.z * 0.5 + pqk.z) / (dPQK.w * 0.5 + pqk.w);\n\t\t\tfloat rayZNear;\n\n\t\t\tbool intersect = false;\n\n\t\t\tvec2 texelSize = 1.0 / viewportSize;\n\n\t\t\titerationCount = 0.0;\n\n\t\t\tfor (int i = 0; i < 20; i++) {\n\t\t\t\tpqk += dPQK;\n\n\t\t\t\trayZNear = rayZFar;\n\t\t\t\trayZFar = (dPQK.z * 0.5 + pqk.z) / (dPQK.w * 0.5 + pqk.w);\n\n\t\t\t\thitPixel = permute ? pqk.yx : pqk.xy;\n\t\t\t\thitPixel *= texelSize;\n\n\t\t\t\tintersect = rayIntersectDepth(rayZNear, rayZFar, hitPixel);\n\n\t\t\t\titerationCount += 1.0;\n\n\t\t        // PENDING Right on all platforms?\n\t\t\t\tif (intersect) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t    // Binary search refinement\n\t\t    // FIXME If intersect in first iteration binary search may easily lead to the pixel of reflect object it self\n\t\t\tif (pixStride > 1.0 && intersect && iterationCount > 1.0) {\n\t\t        // Roll back\n\t\t\t\tpqk -= dPQK;\n\t\t\t\tdPQK /= pixStride;\n\n\t\t\t\tfloat originalStride = pixStride * 0.5;\n\t\t\t\tfloat stride = originalStride;\n\n\t\t\t\trayZNear = pqk.z / pqk.w;\n\t\t\t\trayZFar = rayZNear;\n\n\t\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\t\tpqk += dPQK * stride;\n\t\t\t\t\trayZNear = rayZFar;\n\t\t\t\t\trayZFar = (dPQK.z * -0.5 + pqk.z) / (dPQK.w * -0.5 + pqk.w);\n\t\t\t\t\thitPixel = permute ? pqk.yx : pqk.xy;\n\t\t\t\t\thitPixel *= texelSize;\n\n\t\t\t\t\toriginalStride *= 0.5;\n\t\t\t\t\tstride = rayIntersectDepth(rayZNear, rayZFar, hitPixel) ? -originalStride : originalStride;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ0.xy += dQ.xy * iterationCount;\n\t\t\tQ0.z = pqk.z;\n\t\t\thitPoint = Q0 / pqk.w;\n\n\t\t\treturn intersect;\n\t\t}\n\n\t\tfloat calculateAlpha(float iterationCount, float reflectivity, vec2 hitPixel, vec3 hitPoint, float dist, vec3 rayDir) {\n\t\t\tfloat alpha = clamp(reflectivity, 0.0, 1.0);\n\t\t    // Fade ray hits that approach the maximum iterations\n\t\t\talpha *= 1.0 - (iterationCount / float(20));\n\t\t    // Fade ray hits that approach the screen edge\n\t\t\tvec2 hitPixelNDC = hitPixel * 2.0 - 1.0;\n\t\t\tfloat maxDimension = min(1.0, max(abs(hitPixelNDC.x), abs(hitPixelNDC.y)));\n\t\t\talpha *= 1.0 - max(0.0, maxDimension - screenEdgeFadeStart) / (1.0 - screenEdgeFadeStart);\n\n\t\t    // Fade ray hits base on how much they face the camera\n\t\t\tfloat _eyeFadeStart = eyeFadeStart;\n\t\t\tfloat _eyeFadeEnd = eyeFadeEnd;\n\t\t\tif (_eyeFadeStart > _eyeFadeEnd) {\n\t\t\t\tfloat tmp = _eyeFadeEnd;\n\t\t\t\t_eyeFadeEnd = _eyeFadeStart;\n\t\t\t\t_eyeFadeStart = tmp;\n\t\t\t}\n\n\t\t\tfloat eyeDir = clamp(rayDir.z, _eyeFadeStart, _eyeFadeEnd);\n\t\t\talpha *= 1.0 - (eyeDir - _eyeFadeStart) / (_eyeFadeEnd - _eyeFadeStart);\n\n\t\t    // Fade ray hits based on distance from ray origin\n\t\t\talpha *= 1.0 - clamp(dist / maxRayDistance, 0.0, 1.0);\n\n\t\t\treturn alpha;\n        }\n        \n        void main() {\n\t\t\tvec4 normalAndGloss = texture2D(gBufferTexture1, vUv);\n\n\t\t    // Is empty\n\t\t\tif (dot(normalAndGloss.rgb, vec3(1.0)) == 0.0) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\tfloat g = normalAndGloss.a;\n\t\t\tif (g <= minGlossiness) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\tfloat reflectivity = (g - minGlossiness) / (1.0 - minGlossiness);\n\n\t\t\tvec3 N = normalAndGloss.rgb * 2.0 - 1.0;\n            // N = normalize((viewInverseTranspose * vec4(N, 0.0)).xyz);\n            N = normalize(N);\n\n\t\t    // Position in view\n\t\t\tvec4 projectedPos = vec4(vUv * 2.0 - 1.0, fetchDepth(gBufferTexture2, vUv), 1.0);\n\t\t\tvec4 pos = projectionInv * projectedPos;\n\t\t\tvec3 rayOrigin = pos.xyz / pos.w;\n\n\t\t\tvec3 rayDir = normalize(reflect(normalize(rayOrigin), N));\n\t\t\tvec2 hitPixel;\n\t\t\tvec3 hitPoint;\n\t\t\tfloat iterationCount;\n\n\t\t    // Get jitter\n\t\t\tvec2 uv2 = vUv * viewportSize;\n\t\t\tfloat jitter = fract((uv2.x + uv2.y) * 0.25) + jitterOffset;\n\n\t\t\tbool intersect = traceScreenSpaceRay(rayOrigin, rayDir, jitter, hitPixel, hitPoint, iterationCount);\n\n\t\t\tfloat dist = distance(rayOrigin, hitPoint);\n\n\t\t\tfloat alpha = calculateAlpha(iterationCount, reflectivity, hitPixel, hitPoint, dist, rayDir) * float(intersect);\n\n\t\t\tvec3 hitNormal = texture2D(gBufferTexture1, hitPixel).rgb * 2.0 - 1.0;\n            // hitNormal = normalize((viewInverseTranspose * vec4(hitNormal, 0.0)).xyz);\n            hitNormal = normalize(hitNormal);\n\n\t\t    // Ignore the pixel not face the ray\n\t\t    // TODO fadeout ?\n\t\t    // PENDING Can be configured?\n\t\t\tif (dot(hitNormal, rayDir) >= 0.0) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t    // vec4 color = decodeHDR(texture2DLodEXT(colorTex, hitPixel, clamp(dist / maxRayDistance, 0.0, 1.0) * maxMipmapLevel));\n\n\t\t\tif (!intersect) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\tvec4 color = texture2D(colorTex, hitPixel);\n\t\t\tgl_FragColor = vec4(color.rgb * alpha, color.a);\n\n            // gl_FragColor = vec4(vec3(iterationCount / 2.0), 1.0);\n            // gl_FragColor = texture2D(colorTex, vUv);\n\t\t}\n    "
};
An = {
  defines : {
    NORMALTEX_ENABLED : 1,
    DEPTHTEX_ENABLED : 1,
    DEPTH_PACKING : 1
  },
  uniforms : {
    tDiffuse : {
      value : null
    },
    textureSize : {
      value : new THREE.Vector2
    },
    direction : {
      value : 0
    },
    blurSize : {
      value : 1
    },
    depthTex : {
      value : null
    },
    normalTex : {
      value : null
    },
    projection : {
      value : new THREE.Matrix4
    },
    depthRange : {
      value : 1
    }
  },
  vertexShader : ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader : ["#include <packing>", "varying vec2 vUv;", "uniform vec2 textureSize;", "uniform float blurSize;", "uniform sampler2D tDiffuse;", "uniform int direction;", "#if NORMALTEX_ENABLED == 1", "uniform sampler2D normalTex;", "vec3 getViewNormal( const in vec2 screenPosition ) {", "return unpackRGBToNormal( texture2D( normalTex, screenPosition ).xyz );", "}", "#endif", "#if DEPTHTEX_ENABLED == 1", "uniform sampler2D depthTex;", "uniform mat4 projection;", "uniform float depthRange;", 
  "float getDepth( const in vec2 screenPosition ) {", "#if DEPTH_PACKING == 1", "return unpackRGBAToDepth( texture2D( depthTex, screenPosition ) );", "#elif DEPTH_PACKING == 2", "return texture2D( depthTex, screenPosition ).w;", "#else", "return texture2D( depthTex, screenPosition ).x;", "#endif", "}", "float getLinearDepth(vec2 coord) {", "float depth = getDepth(coord) * 2.0 - 1.0;", "return projection[3][2] / (depth * projection[2][3] - projection[2][2]);", "}", "#endif", "void main() {", "float kernel[5];", 
  "kernel[0] = 0.122581;", "kernel[1] = 0.233062;", "kernel[2] = 0.288713;", "kernel[3] = 0.233062;", "kernel[4] = 0.122581;", "vec2 off = vec2(0.0);", "if (direction == 0) {", "off[0] = blurSize / textureSize.x;", "}", "else {", "off[1] = blurSize / textureSize.y;", "}", "vec4 sum = vec4(0.0);", "float weightAll = 0.0;", "#if NORMALTEX_ENABLED == 1", "vec3 centerNormal = getViewNormal(vUv);", "#endif", "#if DEPTHTEX_ENABLED == 1", "float centerDepth = getLinearDepth(vUv);", "#endif", "for (int i = 0; i < 5; i++) {", 
  "vec2 coord = clamp(vUv + vec2(float(i) - 2.0) * off, vec2(0.0), vec2(1.0));", "float w = kernel[i];", "#if NORMALTEX_ENABLED == 1", "vec3 normal = getViewNormal(coord);", "w *= clamp(dot(normal, centerNormal), 0.0, 1.0);", "#endif", "#if DEPTHTEX_ENABLED == 1", "float d = getLinearDepth(coord);", "w *= (1.0 - smoothstep(0.0, 1.0, abs(centerDepth - d) / depthRange));", "#endif", "weightAll += w;", "sum += w * texture2D(tDiffuse, coord);", "}", "gl_FragColor = sum / weightAll;", "}"].join("\n")
};
kn = function() {
  function o(n, x) {
    r(this, o);
    this._tempRenderTarget = Cn(n, x);
    this._tempRenderTarget2 = Cn(n, x);
    this._ssrPass = new tn(Dn, void 0, "viewportSize");
    this._ssrPass.material.depthTest = false;
    this._ssrPass.material.depthWrite = false;
    this._blurPass = new tn(An, void 0, "textureSize");
    this._blurPass.material.uniforms.blurSize.value = 2;
    this._blurPass.material.depthTest = false;
    this._blurPass.material.depthWrite = false;
    this._ssrPass.setSize(1 / n, 1 / x);
    this._blurPass.setSize(1 / n, 1 / x);
    this.jitter = false;
  }
  return o.prototype.setSize = function(v, w) {
    this._tempRenderTarget.setSize(v, w);
    this._tempRenderTarget2.setSize(v, w);
    this._ssrPass.setSize(1 / v, 1 / w);
    this._blurPass.setSize(1 / v, 1 / w);
  }, o.prototype.render = function(obj, v, val, name, target, _ref, enableBlend) {
    this._ssrPass.material.uniforms.colorTex.value = obj;
    this._ssrPass.material.uniforms.gBufferTexture1.value = v;
    this._ssrPass.material.uniforms.gBufferTexture2.value = val;
    this._ssrPass.material.uniforms.projection.value.copy(target.projectionMatrix);
    this._ssrPass.material.uniforms.projectionInv.value.getInverse(target.projectionMatrix);
    this._ssrPass.material.uniforms.jitterOffset.value = this.jitter ? Math.random() : 0;
    this._blurPass.material.uniforms.normalTex.value = v;
    this._blurPass.material.uniforms.depthTex.value = val;
    this._blurPass.material.uniforms.projection.value.copy(target.projectionMatrix);
    if (val === v) {
      this._blurPass.material.defines.DEPTH_PACKING = 2;
    } else {
      if (val.isDepthTexture) {
        this._blurPass.material.defines.DEPTH_PACKING = 0;
      } else {
        this._blurPass.material.defines.DEPTH_PACKING = 1;
      }
    }
    this._ssrPass.clearColor.setRGB(0, 0, 0);
    this._ssrPass.clearAlpha = 1;
    this._ssrPass.render(name, this._tempRenderTarget);
    this._blurPass.clearColor.setRGB(0, 0, 0);
    this._blurPass.clearAlpha = 1;
    this._blurPass.clear = true;
    this._blurPass.material.uniforms.direction.value = 0;
    this._blurPass.material.transparent = false;
    this._blurPass.render(name, this._tempRenderTarget2, this._tempRenderTarget);
    if (enableBlend) {
      this._blurPass.clearColor.setRGB(0, 0, 0);
      this._blurPass.clearAlpha = 1;
    } else {
      this._blurPass.clear = false;
    }
    this._blurPass.material.uniforms.direction.value = 1;
    this._blurPass.material.transparent = !enableBlend;
    this._blurPass.material.blending = enableBlend ? THREE.NoBlending : THREE.AdditiveBlending;
    this._blurPass.render(name, void 0 !== _ref ? _ref : null, this._tempRenderTarget2);
  }, o.prototype.dispose = function() {
    this._tempRenderTarget.dispose();
    this._tempRenderTarget2.dispose();
    this._ssrPass.material.dispose();
    this._blurPass.material.dispose();
  }, o;
}();
On = function() {
  function o() {
    r(this, o);
    this._schemeBuffer;
    this._dirty = true;
    this.enable = false;
    this.$enable = true;
  }
  return o.prototype.isActive = function() {
    return this.enable && this.$enable;
  }, o.prototype.dispose = function() {
  }, o.prototype.setSize = function(t, num) {
  }, o.prototype.render = function(obj, v, k, fn, type) {
  }, o.prototype.dirty = function() {
    this._dirty = true;
  }, o;
}();
Bn = 0, Fn = 1, Ln = 2, In = new THREE.Color, Nn = function() {
  function e(i, t, data, value) {
    r(this, e);
    this.name = data;
    this._mrt = nn(data, i, t, void 0, value);
    this._rt = on(data, i, t);
    this._depthShareType = Bn;
    this.useMRT = false;
    this.enableLayer1 = false;
  }
  return e.prototype._checkStrategyInited = function(charsetPart) {
    return charsetPart.materialManager.hasStrategy(this.name);
  }, e.prototype._initStrategy = function(charsetPart) {
  }, e.prototype.shareDepthTexture = function(x) {
    return this._depthShareType !== Fn && (this._rt.depthTexture = x, this._rt.dispose(), this._depthShareType = Fn, true);
  }, e.prototype.shareDepthRenderBuffer = function(res, rej) {
    return (this._depthShareType !== Ln || this._mrt.webglDepthRenderbuffer !== res || this._rt.webglDepthRenderbuffer !== rej) && (this._mrt.webglDepthRenderbuffer = res, this._rt.webglDepthRenderbuffer = rej, this._mrt.dispose(), this._rt.dispose(), this._depthShareType = Ln, true);
  }, e.prototype.clearDepthShare = function() {
    return this._depthShareType !== Bn && (this._mrt.webglDepthRenderbuffer = null, this._rt.webglDepthRenderbuffer = null, this._mrt.dispose(), this._rt.dispose(), this._depthShareType = Bn, true);
  }, e.prototype.setSize = function(v, h) {
    this._mrt.setSize(v, h);
    this._rt.setSize(v, h);
  }, e.prototype.render = function(p, obj, item) {
    if (!this._checkStrategyInited(p)) {
      this._initStrategy(p);
    }
    In.copy(p.getClearColor());
    var color = p.getClearAlpha();
    var autoClear = p.autoClear;
    p.autoClear = false;
    p.setClearColor(0, 0);
    p.materialManager.setMode(this.name);
    if (this.depthShared) {
      p.state.buffers.depth.setMask(false);
      p.state.buffers.depth.setLocked(true);
    }
    var value = obj.autoUpdate;
    var c = obj.background;
    var enable = p.shadowMap.enable;
    obj.autoUpdate = false;
    obj.background = null;
    p.shadowMap.enable = false;
    p.initRenderList = false;
    p.renderCustom1 = false;
    if (this.enableLayer1) {
      item.layers.enable(1);
    }
    p.setRenderTarget(this.useMRT ? this._mrt : this._rt);
    p.clear(true, !this.depthShared, true);
    p.render(obj, item);
    if (this.enableLayer1) {
      item.layers.disable(1);
    }
    obj.autoUpdate = value;
    obj.background = c;
    p.shadowMap.enable = enable;
    p.initRenderList = true;
    p.renderCustom1 = true;
    if (this.depthShared) {
      p.state.buffers.depth.setLocked(false);
    }
    p.materialManager.setMode(0);
    p.autoClear = autoClear;
    p.setClearColor(In, color);
  }, e.prototype.setupRenderTarget = function(state) {
    state.setRenderTarget(this.useMRT ? this._mrt : this._rt);
  }, e.prototype.getSchemeTexture = function() {
    return this.useMRT ? this._mrt.texture : this._rt.texture;
  }, e.prototype.dispose = function() {
    this._mrt.dispose();
    this._rt.dispose();
  }, n(e, [{
    key : "depthShared",
    get : function() {
      return this._depthShareType !== Bn;
    }
  }, {
    key : "depthShareType",
    get : function() {
      return this._depthShareType;
    }
  }]), e;
}();
Hn = 0, Un = function(e) {
  function d(c, a, n, f) {
    r(this, d);
    var res = s(this, e.call(this, c, a, wn(n) + "Scheme_" + ++Hn, f));
    return res.marker = n, res;
  }
  return o(d, e), d.prototype._initStrategy = function(charsetPart) {
    var tEdit = this;
    charsetPart.materialManager.addStrategy(this.name, function(canCreateDiscussions, i, isSlidingUp, n, arg, s) {
      if (pn(this, arg)) {
        return null;
      }
      var item = hn(this.technique, tEdit.marker);
      if ("skip" === item) {
        return null;
      }
      var result = void 0;
      var value = false;
      if (item) {
        if (!item.isMaterial) {
          return arg;
        }
        result = item;
        value = true;
      } else {
        if (tEdit.depthShared) {
          return null;
        }
        result = un(this, arg);
      }
      return cn(result, arg, value), result;
    });
  }, d;
}(Nn);
zn = function(e) {
  function t(c, b, data, user) {
    var win;
    r(this, t);
    win = Array.isArray(data) ? data.map(function(cipherContactsHex) {
      return wn(cipherContactsHex);
    }).join("") : wn(data);
    var res = s(this, e.call(this, c, b, win, user));
    return res.marker = data, res;
  }
  return o(t, e), t.prototype._initStrategy = function(charsetPart) {
    var mixin = this;
    if (Array.isArray(mixin.marker)) {
      charsetPart.materialManager.addStrategy(this.name, function(canCreateDiscussions, i, isSlidingUp, n, key, s) {
        if (pn(this, key)) {
          return null;
        }
        var callback = void 0;
        var segmentIdx = 0;
        var segmentLength = mixin.marker.length;
        for (; segmentIdx < segmentLength; segmentIdx++) {
          var c = hn(this.technique, mixin.marker[segmentIdx]);
          if (c && "skip" != c && "0" != c) {
            callback = c;
            break;
          }
          if (segmentIdx === segmentLength - 1) {
            callback = c;
            break;
          }
        }
        if ("skip" === callback) {
          return null;
        }
        if (callback) {
          return callback.isMaterial ? callback : "number" != typeof callback || isNaN(callback) || 1 === callback ? key : Wn(key, callback);
        }
        if (mixin.depthShared) {
          return null;
        }
        var result = un(this, key);
        return cn(result, key), result;
      });
    } else {
      charsetPart.materialManager.addStrategy(this.name, function(canCreateDiscussions, i, isSlidingUp, n, key, s) {
        if (pn(this, key)) {
          return null;
        }
        var item = hn(this.technique, mixin.marker);
        if ("skip" === item) {
          return null;
        }
        if (item) {
          return item.isMaterial ? item : "number" != typeof item || isNaN(item) || 1 === item ? key : Wn(key, item);
        }
        if (mixin.depthShared) {
          return null;
        }
        var result = un(this, key);
        return cn(result, key), result;
      });
    }
  }, t;
}(Un);
Vn = new Map;
function Wn(obj, x) {
  var i = obj.uuid + "_" + x;
  var m = Vn.get(i);
  return m || (obj.addEventListener("dispose", Gn), (m = obj.clone()).isShaderMaterial && m.uniforms.strength ? m.uniforms.strength.value = x : (x < 1 ? obj.transparent ? (m.opacity = x, m.defines && (m.defines.PREMULTIPLIED_ALPHA = true), m.blending = THREE.CustomBlending, m.blendEquation = THREE.AddEquation, m.blendSrc = THREE.OneFactor, m.blendDst = THREE.ZeroFactor, m.blendSrcAlpha = THREE.ZeroFactor, m.blendDstAlpha = THREE.OneFactor) : m.color ? (m.color.r *= x, m.color.g *= x, m.color.b *= 
  x) : console.warn("strengthMat is not transparent and does not have color attribute") : m.color ? (m.color.r *= x, m.color.g *= x, m.color.b *= x) : console.warn("strengthMat does not have color attribute"), m.envMap = null), Vn.set(i, m)), m;
}
function Gn(values) {
  var me = values.target;
  me.removeEventListener("dispose", Gn);
  var toRemove = [];
  Vn.forEach(function(canCreateDiscussions, p) {
    if (p.indexOf(me.uuid) > -1) {
      toRemove.push(p);
    }
  });
  toRemove.forEach(function(name) {
    Vn.get(name).dispose();
    Vn.delete(name);
  });
}
var qn = {
  shaderID : "luminosityHighPass",
  uniforms : {
    tDiffuse : {
      type : "t",
      value : null
    },
    luminosityThreshold : {
      type : "f",
      value : 1
    },
    smoothWidth : {
      type : "f",
      value : 1
    },
    defaultColor : {
      type : "c",
      value : new THREE.Color(0)
    },
    defaultOpacity : {
      type : "f",
      value : 0
    }
  },
  vertexShader : ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader : ["uniform sampler2D tDiffuse;", "uniform vec3 defaultColor;", "uniform float defaultOpacity;", "uniform float luminosityThreshold;", "uniform float smoothWidth;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "vec3 luma = vec3( 0.299, 0.587, 0.114 );", "float v = dot( texel.xyz, luma );", "vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );", "float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );", "gl_FragColor = mix( outputColor, texel, alpha );", 
  "}"].join("\n")
};
Xn = {
  defines : {
    KERNEL_RADIUS : 7,
    SIGMA : 7
  },
  uniforms : {
    colorTexture : {
      value : null
    },
    texSize : {
      value : new THREE.Vector2(.5, .5)
    },
    direction : {
      value : new THREE.Vector2(.5, .5)
    }
  },
  vertexShader : "varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }",
  fragmentShader : "#include <common>        varying vec2 vUv;\n        uniform sampler2D colorTexture;\n        uniform vec2 texSize;        uniform vec2 direction;                float gaussianPdf(in float x, in float sigma) {            return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;        }        void main() {\n            vec2 invSize = 1.0 / texSize;            float fSigma = float(SIGMA);            float weightSum = gaussianPdf(0.0, fSigma);            vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;            for( int i = 1; i < KERNEL_RADIUS; i ++ ) {                float x = float(i);                float w = gaussianPdf(x, fSigma);                vec2 uvOffset = direction * invSize * x;                vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;                vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;                diffuseSum += (sample1 + sample2) * w;                weightSum += 2.0 * w;            }            gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n        }"
};
Jn = {
  defines : {
    NUM_MIPS : 5
  },
  uniforms : {
    blurTexture1 : {
      value : null
    },
    blurTexture2 : {
      value : null
    },
    blurTexture3 : {
      value : null
    },
    blurTexture4 : {
      value : null
    },
    blurTexture5 : {
      value : null
    },
    dirtTexture : {
      value : null
    },
    bloomStrength : {
      value : 1
    },
    bloomFactors : {
      value : null
    },
    bloomTintColors : {
      value : null
    },
    bloomRadius : {
      value : 0
    }
  },
  vertexShader : "varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }",
  fragmentShader : "varying vec2 vUv;        uniform sampler2D blurTexture1;        uniform sampler2D blurTexture2;        uniform sampler2D blurTexture3;        uniform sampler2D blurTexture4;        uniform sampler2D blurTexture5;        uniform sampler2D dirtTexture;        uniform float bloomStrength;        uniform float bloomRadius;        uniform float bloomFactors[NUM_MIPS];        uniform vec3 bloomTintColors[NUM_MIPS];                float lerpBloomFactor(const in float factor) {             float mirrorFactor = 1.2 - factor;            return mix(factor, mirrorFactor, bloomRadius);        }                void main() {            gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +                                                 lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +                                                 lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +                                                 lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +                                                 lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );        }"
};
Yn = new THREE.Vector2(1, 0);
Qn = new THREE.Vector2(0, 1);
Zn = function(selector) {
  function render(w, h, media, options) {
    r(this, render);
    var self = s(this, selector.call(this));
    self.strength = 1.5;
    self.radius = .4;
    self.threshold = .2;
    self._schemeBuffer = new zn(w, h, media || "glow", options);
    self.renderTargetsHorizontal = [];
    self.renderTargetsVertical = [];
    self.nMips = 5;
    var idx = 0;
    var undefined = Math.round(w / 2);
    var value = Math.round(h / 2);
    self.renderTargetBright = Cn(undefined, value);
    self.renderTargetBright.texture.name = "GlowPass.bright";
    idx = 0;
    for (; idx < self.nMips; idx++) {
      var p = Cn(undefined, value);
      p.texture.name = "GlowPass.h" + idx;
      self.renderTargetsHorizontal.push(p);
      var s = Cn(undefined, value);
      s.texture.name = "GlowPass.v" + idx;
      self.renderTargetsVertical.push(s);
      undefined = Math.round(undefined / 2);
      value = Math.round(value / 2);
    }
    self.highPass = new tn(qn);
    self.highPass.clearAlpha = 0;
    self.highPass.uniforms.luminosityThreshold.value = self.threshold;
    self.highPass.uniforms.smoothWidth.value = .01;
    self.separableBlurPasses = [];
    var user_items_all = [3, 5, 7, 9, 11];
    undefined = Math.round(w / 2);
    value = Math.round(h / 2);
    idx = 0;
    for (; idx < self.nMips; idx++) {
      var object = new tn(Xn);
      object.clearAlpha = 0;
      object.material.defines.KERNEL_RADIUS = user_items_all[idx];
      object.material.defines.SIGMA = user_items_all[idx];
      object.uniforms.texSize.value.set(undefined, value);
      self.separableBlurPasses.push(object);
      undefined = Math.round(undefined / 2);
      value = Math.round(value / 2);
    }
    self.compositePass = new tn(Jn);
    self.compositePass.clearAlpha = 0;
    self.compositePass.material.defines.NUM_MIPS = 5;
    self.compositePass.uniforms.blurTexture1.value = self.renderTargetsVertical[0].texture;
    self.compositePass.uniforms.blurTexture2.value = self.renderTargetsVertical[1].texture;
    self.compositePass.uniforms.blurTexture3.value = self.renderTargetsVertical[2].texture;
    self.compositePass.uniforms.blurTexture4.value = self.renderTargetsVertical[3].texture;
    self.compositePass.uniforms.blurTexture5.value = self.renderTargetsVertical[4].texture;
    self.compositePass.uniforms.bloomStrength.value = self.strength;
    self.compositePass.uniforms.bloomRadius.value = .1;
    return self.compositePass.uniforms.bloomFactors.value = [1, .8, .6, .4, .2], self.bloomTintColors = [new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1)], self.compositePass.uniforms.bloomTintColors.value = self.bloomTintColors, self.copyPass = new tn(Yr), self.copyPass.clearAlpha = 0, self.copyPass.clear = false, self.copyPass.uniforms.opacity.value = 1, self.copyPass.material.blending = THREE.CustomBlending, 
    self.copyPass.material.blendSrc = THREE.SrcAlphaFactor, self.copyPass.material.blendDst = THREE.OneFactor, self.copyPass.material.blendEquation = THREE.AddEquation, self.copyPass.material.blendSrcAlpha = THREE.ZeroFactor, self.copyPass.material.blendDstAlpha = THREE.OneFactor, self.copyPass.material.blendEquationAlpha = THREE.AddEquation, self.copyPass.material.depthTest = false, self.copyPass.material.depthWrite = false, self.copyPass.material.transparent = true, self;
  }
  return o(render, selector), render.prototype.dispose = function() {
    this._schemeBuffer.dispose();
    var i = 0;
    for (; i < this.renderTargetsHorizontal.length; i++) {
      this.renderTargetsHorizontal[i].dispose();
    }
    i = 0;
    for (; i < this.renderTargetsVertical.length; i++) {
      this.renderTargetsVertical[i].dispose();
    }
    this.renderTargetBright.dispose();
  }, render.prototype.setSize = function(v, h) {
    this._schemeBuffer.setSize(v, h);
    var i = Math.round(v / 2);
    var w = Math.round(h / 2);
    this.renderTargetBright.setSize(i, w);
    var segmentedRequest = 0;
    for (; segmentedRequest < this.nMips; segmentedRequest++) {
      this.renderTargetsHorizontal[segmentedRequest].setSize(i, w);
      this.renderTargetsVertical[segmentedRequest].setSize(i, w);
      this.separableBlurPasses[segmentedRequest].uniforms.texSize.value.set(i, w);
      i = Math.round(i / 2);
      w = Math.round(w / 2);
    }
  }, render.prototype.render = function(type, s, k, fn, value) {
    if (this._dirty) {
      this._schemeBuffer.useMRT = value;
      this._schemeBuffer.render(type, s, k);
      this.highPass.uniforms.tDiffuse.value = this._schemeBuffer.getSchemeTexture();
      this.highPass.uniforms.luminosityThreshold.value = this.threshold;
      this.highPass.render(type, this.renderTargetBright);
      var inputRenderTarget = this.renderTargetBright;
      var i = 0;
      for (; i < this.nMips; i++) {
        this.separableBlurPasses[i].uniforms.colorTexture.value = inputRenderTarget.texture;
        this.separableBlurPasses[i].uniforms.direction.value.copy(Yn);
        this.separableBlurPasses[i].render(type, this.renderTargetsHorizontal[i]);
        this.separableBlurPasses[i].uniforms.colorTexture.value = this.renderTargetsHorizontal[i].texture;
        this.separableBlurPasses[i].uniforms.direction.value.copy(Qn);
        this.separableBlurPasses[i].render(type, this.renderTargetsVertical[i]);
        inputRenderTarget = this.renderTargetsVertical[i];
      }
      this.compositePass.uniforms.bloomStrength.value = this.strength;
      this.compositePass.uniforms.bloomRadius.value = this.radius;
      this.compositePass.uniforms.bloomTintColors.value = this.bloomTintColors;
      this.compositePass.render(type, this.renderTargetsHorizontal[0]);
      this._dirty = false;
    }
    this.copyPass.render(type, fn, this.renderTargetsHorizontal[0]);
  }, render;
}(On);
Kn = {
  uniforms : {
    tDiffuse1 : {
      value : null
    },
    tDiffuse2 : {
      value : null
    },
    mixRatio : {
      value : .5
    },
    opacity : {
      value : 1
    }
  },
  vertexShader : ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader : ["uniform float opacity;", "uniform float mixRatio;", "uniform sampler2D tDiffuse1;", "uniform sampler2D tDiffuse2;", "varying vec2 vUv;", "void main() {", "vec4 texel1 = texture2D( tDiffuse1, vUv );", "vec4 texel2 = texture2D( tDiffuse2, vUv );", "gl_FragColor = opacity * mix( texel1, texel2, mixRatio );", "}"].join("\n")
};
$n = {
  uniforms : {
    tDiffuse : {
      value : null
    },
    v : {
      value : 1 / 512
    }
  },
  vertexShader : ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader : ["uniform sampler2D tDiffuse;", "uniform float v;", "varying vec2 vUv;", "void main() {", "vec4 sum = vec4( 0.0 );", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;", 
  "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;", "gl_FragColor = sum;", "}"].join("\n")
};
eo = {
  uniforms : {
    tDiffuse : {
      value : null
    },
    h : {
      value : 1 / 512
    }
  },
  vertexShader : ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader : ["uniform sampler2D tDiffuse;", "uniform float h;", "varying vec2 vUv;", "void main() {", "vec4 sum = vec4( 0.0 );", "sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;", "sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;", "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;", "sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;", 
  "sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;", "sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;", "sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;", "gl_FragColor = sum;", "}"].join("\n")
};
to = function(selector) {
  function render(total, url, logger) {
    r(this, render);
    var self = s(this, selector.call(this));
    self.strength = 1;
    self.blendRate = .7;
    self.blurSize = 1;
    self._schemeBuffer = new zn(total, url, "lineBloom", logger);
    self.renderTargetsHorizontal = [];
    self.renderTargetsVertical = [];
    self.nMips = 6;
    var i = total;
    var u = url;
    var date = 0;
    for (; date < self.nMips; date++) {
      var p = Cn(i, u);
      p.texture.name = "LineBloomPass.h" + date;
      self.renderTargetsHorizontal.push(p);
      var a = Cn(i, u);
      a.texture.name = "LineBloomPass.v" + date;
      self.renderTargetsVertical.push(a);
      i = Math.round(i / 2);
      u = Math.round(u / 2);
    }
    return self._downSamplePass = new tn(io), self._brightPass = new tn(ro), self._blurXPass = new tn(eo), self._blurYPass = new tn($n), self._blendPass = new tn(Kn), self._copyPass = new tn(Yr), self._copyPass.clearAlpha = 0, self._copyPass.clear = false, self._copyPass.uniforms.opacity.value = 1, self._copyPass.material.blending = THREE.CustomBlending, self._copyPass.material.blendSrc = THREE.OneFactor, self._copyPass.material.blendDst = THREE.OneFactor, self._copyPass.material.blendEquation = 
    THREE.AddEquation, self._copyPass.material.blendSrcAlpha = THREE.ZeroFactor, self._copyPass.material.blendDstAlpha = THREE.OneFactor, self._copyPass.material.blendEquationAlpha = THREE.AddEquation, self._copyPass.material.depthTest = false, self._copyPass.material.depthWrite = false, self._copyPass.material.transparent = true, self;
  }
  return o(render, selector), render.prototype.dispose = function() {
    this._schemeBuffer.dispose();
    var i = 0;
    for (; i < this.renderTargetsHorizontal.length; i++) {
      this.renderTargetsHorizontal[i].dispose();
    }
    i = 0;
    for (; i < this.renderTargetsVertical.length; i++) {
      this.renderTargetsVertical[i].dispose();
    }
  }, render.prototype.setSize = function(v, h) {
    this._schemeBuffer.setSize(v, h);
    var w = v;
    var y = h;
    var i = 0;
    for (; i < this.nMips; i++) {
      this.renderTargetsHorizontal[i].setSize(w, y);
      this.renderTargetsVertical[i].setSize(w, y);
      w = Math.round(w / 2);
      y = Math.round(y / 2);
    }
  }, render.prototype.render = function(name, s, k, fn, type) {
    if (this._dirty) {
      this._schemeBuffer.useMRT = type;
      this._schemeBuffer.render(name, s, k);
      this._downSamplePass.uniforms.tDiffuse.value = this._schemeBuffer.getSchemeTexture();
      this._downSamplePass.uniforms.texSize.value.set(this.renderTargetsHorizontal[0].width, this.renderTargetsHorizontal[0].height);
      this._downSamplePass.render(name, this.renderTargetsHorizontal[1]);
      this._brightPass.render(name, this.renderTargetsVertical[1], this.renderTargetsHorizontal[1]);
      var term = 2;
      for (; term < this.nMips; term++) {
        this._downSamplePass.uniforms.texSize.value.set(this.renderTargetsVertical[term - 1].width, this.renderTargetsVertical[term - 1].height);
        this._downSamplePass.render(name, this.renderTargetsVertical[term], this.renderTargetsVertical[term - 1]);
      }
      var j = 0;
      for (; j < this.nMips - 1; j++) {
        this._blurXPass.uniforms.h.value = 2 * this.blurSize / this.renderTargetsHorizontal[j].width;
        this._blurXPass.render(name, this.renderTargetsHorizontal[j], this.renderTargetsVertical[j + 1]);
      }
      var i = 0;
      for (; i < this.nMips - 1; i++) {
        this._blurYPass.uniforms.v.value = 2 * this.blurSize / this.renderTargetsVertical[i].height;
        this._blurYPass.render(name, this.renderTargetsVertical[i], this.renderTargetsHorizontal[i]);
      }
      var url = this.nMips - 2;
      for (; url >= 0; url--) {
        this._blendPass.uniforms.tDiffuse1.value = this.renderTargetsVertical[url].texture;
        this._blendPass.uniforms.tDiffuse2.value = this.renderTargetsVertical[url + 1].texture;
        this._blendPass.uniforms.mixRatio.value = this.blendRate;
        this._blendPass.uniforms.opacity.value = this.strength;
        this._blendPass.render(name, this.renderTargetsHorizontal[url]);
      }
      this._dirty = false;
    }
    this._copyPass.render(name, fn, this.renderTargetsHorizontal[0]);
  }, render;
}(On);
io = {
  uniforms : {
    tDiffuse : {
      value : null
    },
    texSize : {
      value : new THREE.Vector2(512, 512)
    }
  },
  vertexShader : "\n\t\tvarying vec2 vUv;\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}\n    ",
  fragmentShader : "\n\t\tvarying vec2 vUv;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec2 texSize;\n\t\t\n\t\tvoid main() {\n    \t\tvec4 d = vec4(-1.0, -1.0, 1.0, 1.0) / texSize.xyxy;\n\t\t\tgl_FragColor = (texture2D(tDiffuse, vUv + d.xy) +\n\t\t\t\ttexture2D(tDiffuse, vUv + d.zy) +\n\t\t\t\ttexture2D(tDiffuse, vUv + d.xw) +\n\t\t\t\ttexture2D(tDiffuse, vUv + d.zw)) * 0.25;\n\t\t}\n\t"
};
ro = {
  uniforms : {
    tDiffuse : {
      value : null
    },
    scale : {
      value : 4
    }
  },
  vertexShader : "\n\t\tvarying vec2 vUv;\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}\n    ",
  fragmentShader : "\n\t\tvarying vec2 vUv;\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform float scale;\n\t\t\n\t\tvoid main() {\n\t\t\tgl_FragColor = texture2D(tDiffuse, vUv) * scale;\n\t\t}\n\t"
};
no = {
  uniforms : {
    scene : {
      value : null
    },
    texSize : {
      value : new THREE.Vector2(1, 1)
    },
    Stride : {
      value : 10
    }
  },
  vertexShader : "\n\tvarying vec2 vUv;\n\tvoid main() {\n\t\tvUv = uv;\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t}\n    ",
  fragmentShader : "\n\t#define WT9_0 1.0\n\t#define WT9_1 0.8\n\t#define WT9_2 0.6\n\t#define WT9_3 0.4\n\t#define WT9_4 0.2\n\t#define WT9_NORMALIZE 5.2\n\tvarying vec2 vUv;\n\tuniform sampler2D scene;\n\tuniform vec2 texSize;\n\tuniform float Stride;\n\tvoid main() {\n\t\tfloat TexelIncrement =0.25 * Stride /texSize.x;\n\n\t\tfloat colour = texture2D(scene,vec2(vUv.x + TexelIncrement, vUv.y) ).x * (0.8/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x +2.0 * TexelIncrement, vUv.y)).x * (WT9_2/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x +3.0 * TexelIncrement, vUv.y)).x * (WT9_3/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x +4.0 * TexelIncrement, vUv.y)).x * (WT9_4/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x, vUv.y)).x * (WT9_0/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x - 1.0 * TexelIncrement, vUv.y)).x * (WT9_1/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x - 2.0 * TexelIncrement, vUv.y)).x * (WT9_2/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x - 3.0 * TexelIncrement, vUv.y)).x * (WT9_3/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x - 4.0 * TexelIncrement, vUv.y)).x * (WT9_3/WT9_NORMALIZE);\n\n\t\tTexelIncrement =0.5 * Stride /texSize.x;\n\t\tcolour += texture2D(scene,vec2(vUv.x + TexelIncrement, vUv.y) ).x * (0.8/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x +2.0 * TexelIncrement, vUv.y)).x * (WT9_2/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x +3.0 * TexelIncrement, vUv.y)).x * (WT9_3/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x +4.0 * TexelIncrement, vUv.y)).x * (WT9_4/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x, vUv.y)).x * (WT9_0/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x - 1.0 * TexelIncrement, vUv.y)).x * (WT9_1/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x - 2.0 * TexelIncrement, vUv.y)).x * (WT9_2/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x - 3.0 * TexelIncrement, vUv.y)).x * (WT9_3/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x - 4.0 * TexelIncrement, vUv.y)).x * (WT9_3/WT9_NORMALIZE);\n\n\t\tTexelIncrement =0.75 * Stride /texSize.x;\n\t\tcolour += texture2D(scene,vec2(vUv.x + TexelIncrement, vUv.y) ).x * (0.8/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x +2.0 * TexelIncrement, vUv.y)).x * (WT9_2/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x +3.0 * TexelIncrement, vUv.y)).x * (WT9_3/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x +4.0 * TexelIncrement, vUv.y)).x * (WT9_4/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x, vUv.y)).x * (WT9_0/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x - 1.0 * TexelIncrement, vUv.y)).x * (WT9_1/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x - 2.0 * TexelIncrement, vUv.y)).x * (WT9_2/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x - 3.0 * TexelIncrement, vUv.y)).x * (WT9_3/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x - 4.0 * TexelIncrement, vUv.y)).x * (WT9_3/WT9_NORMALIZE);\n\n\t\tTexelIncrement =Stride /texSize.x;\n\t\tcolour += texture2D(scene,vec2(vUv.x + TexelIncrement, vUv.y) ).x * (0.8/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x +2.0 * TexelIncrement, vUv.y)).x * (WT9_2/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x +3.0 * TexelIncrement, vUv.y)).x * (WT9_3/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x +4.0 * TexelIncrement, vUv.y)).x * (WT9_4/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x, vUv.y)).x * (WT9_0/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x - 1.0 * TexelIncrement, vUv.y)).x * (WT9_1/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x - 2.0 * TexelIncrement, vUv.y)).x * (WT9_2/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x - 3.0 * TexelIncrement, vUv.y)).x * (WT9_3/WT9_NORMALIZE);\n\t\tcolour += texture2D(scene, vec2(vUv.x - 4.0 * TexelIncrement, vUv.y)).x * (WT9_3/WT9_NORMALIZE);\n\n\t\tfloat col = 1.0-colour*0.25;\n\n\t\tgl_FragColor = vec4(col,col,col,col);\n\t}\n    "
};
oo = {
  uniforms : {
    blurX : {
      value : null
    },
    scene : {
      value : null
    },
    texSize : {
      value : new THREE.Vector2(1, 1)
    },
    Stride : {
      value : 10
    },
    Glowness : {
      value : 2
    },
    GlowColor : {
      value : new THREE.Vector4(1, 0, 0, 1)
    }
  },
  vertexShader : "\n\tvarying vec2 vUv;\n\tvoid main() {\n\t\tvUv = uv;\n\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t}\n\t",
  fragmentShader : "\n\t#define WT9_0 1.0\n\t#define WT9_1 0.8\n\t#define WT9_2 0.6\n\t#define WT9_3 0.4\n\t#define WT9_4 0.2\n\t#define WT9_NORMALIZE 5.2\n\tvarying vec2 vUv;\n\tuniform vec2 texSize;\n\tuniform float Stride;\n\tuniform float Glowness;\n\tuniform vec4 GlowColor;\n\tuniform sampler2D blurX;\n\tuniform sampler2D scene;\n\tvoid main() {\n\n\t\tfloat TexelIncrement = 0.25 * Stride / texSize.y;\n\n\t\tfloat colour = texture2D(blurX, vec2(vUv.x , vUv.y+TexelIncrement)).x * (0.8/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x, vUv.y +2.0 * TexelIncrement)).x* (WT9_2/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x , vUv.y+3.0 * TexelIncrement)).x * (WT9_3/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x , vUv.y+4.0 * TexelIncrement)).x * (WT9_4/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x, vUv.y)).x * (WT9_0/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x , vUv.y- 1.0 * TexelIncrement)).x * (WT9_1/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x, vUv.y - 2.0 * TexelIncrement)).x * (WT9_2/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x, vUv.y - 3.0 * TexelIncrement)).x* (WT9_3/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x , vUv.y- 4.0 * TexelIncrement)).x * (WT9_3/WT9_NORMALIZE);\n\n\t\tTexelIncrement = 0.5 * Stride / texSize.y;\n\t\tcolour += texture2D(blurX, vec2(vUv.x , vUv.y+TexelIncrement)).x * (0.8/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x, vUv.y +2.0 * TexelIncrement)).x* (WT9_2/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x , vUv.y+3.0 * TexelIncrement)).x * (WT9_3/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x , vUv.y+4.0 * TexelIncrement)).x * (WT9_4/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x, vUv.y)).x * (WT9_0/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x , vUv.y- 1.0 * TexelIncrement)).x * (WT9_1/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x, vUv.y - 2.0 * TexelIncrement)).x * (WT9_2/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x, vUv.y - 3.0 * TexelIncrement)).x* (WT9_3/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x , vUv.y- 4.0 * TexelIncrement)).x * (WT9_3/WT9_NORMALIZE);\n\n\t\tTexelIncrement = 0.75 * Stride / texSize.y;\n\t\tcolour += texture2D(blurX, vec2(vUv.x , vUv.y+TexelIncrement)).x * (0.8/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x, vUv.y +2.0 * TexelIncrement)).x* (WT9_2/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x , vUv.y+3.0 * TexelIncrement)).x * (WT9_3/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x , vUv.y+4.0 * TexelIncrement)).x * (WT9_4/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x, vUv.y)).x * (WT9_0/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x , vUv.y- 1.0 * TexelIncrement)).x * (WT9_1/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x, vUv.y - 2.0 * TexelIncrement)).x * (WT9_2/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x, vUv.y - 3.0 * TexelIncrement)).x* (WT9_3/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x , vUv.y- 4.0 * TexelIncrement)).x * (WT9_3/WT9_NORMALIZE);\n\n\t\tTexelIncrement = Stride / texSize.y;\n\t\tcolour += texture2D(blurX, vec2(vUv.x , vUv.y+TexelIncrement)).x * (0.8/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x, vUv.y +2.0 * TexelIncrement)).x* (WT9_2/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x , vUv.y+3.0 * TexelIncrement)).x * (WT9_3/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x , vUv.y+4.0 * TexelIncrement)).x * (WT9_4/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x, vUv.y)).x * (WT9_0/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x , vUv.y- 1.0 * TexelIncrement)).x * (WT9_1/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x, vUv.y - 2.0 * TexelIncrement)).x * (WT9_2/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x, vUv.y - 3.0 * TexelIncrement)).x* (WT9_3/WT9_NORMALIZE);\n\t\tcolour += texture2D(blurX, vec2(vUv.x , vUv.y- 4.0 * TexelIncrement)).x * (WT9_3/WT9_NORMALIZE);\n\n\t\tvec4 glo = (0.25 * Glowness * colour) * GlowColor;\n\t\tvec4 OldCol = texture2D(scene, vec2(vUv.x , vUv.y));\n\t\t\n\t\tgl_FragColor = vec4(OldCol.x*glo.xyz,1);\n\t}\n\t"
};
so = sn(1, 1, 1);
ao = new Map;
var lo = 0;
var uo = function(e) {
  function d(c, a, n, f) {
    r(this, d);
    var res = s(this, e.call(this, c, a, wn(n) + "Scheme_" + ++lo, f));
    return res.marker = n, res;
  }
  return o(d, e), d.prototype._initStrategy = function(charsetPart) {
    var tEdit = this;
    charsetPart.materialManager.addStrategy(this.name, function(canCreateDiscussions, i, isSlidingUp, n, arg, s) {
      if (pn(this, arg)) {
        return null;
      }
      var mf = hn(this.technique, tEdit.marker);
      if ("skip" === mf) {
        return null;
      }
      var result = void 0;
      var value = false;
      if (mf) {
        result = mf.isMaterial ? mf : function(rangeObj, source) {
          var i = rangeObj.isInstancedMesh + "_" + source.skinning;
          var n = void 0;
          return ao.has(i) ? n = ao.get(i) : ((n = new THREE.ShaderMaterial(so)).skinning = source.skinning, ao.set(i, n)), n;
        }(this, arg);
        value = true;
      } else {
        if (tEdit.depthShared) {
          return null;
        }
        result = un(this, arg);
      }
      return cn(result, arg, value), result;
    });
  }, d;
}(Nn);
co = function(selector) {
  function render(name, data, options) {
    r(this, render);
    var that = s(this, selector.call(this));
    return that.color = new THREE.Vector4(1, 0, 0, 1), that.strength = 2, that.stride = 10, that._schemeBuffer = new uo(name, data, "innerGlow", options), that.tempRenderTarget = Cn(name, data), that.tempRenderTarget.texture.name = "InnerGlowPass.temp", that.resultRenderTarget = Cn(name, data), that.resultRenderTarget.texture.name = "InnerGlowPass.result", that._blurXPass = new tn(no), that._blurXPass.uniforms.texSize.value.set(name, data), that._blurYPass = new tn(oo), that._blurYPass.uniforms.texSize.value.set(name, 
    data), that._copyPass = new tn(Yr), that._copyPass.clear = false, that._copyPass.uniforms.opacity.value = 1, that._copyPass.uniforms.tDiffuse.value = that.resultRenderTarget.texture, that._copyPass.material.blending = THREE.CustomBlending, that._copyPass.material.blendSrc = THREE.SrcAlphaFactor, that._copyPass.material.blendDst = THREE.OneFactor, that._copyPass.material.blendEquation = THREE.AddEquation, that._copyPass.material.blendSrcAlpha = THREE.ZeroFactor, that._copyPass.material.blendDstAlpha = 
    THREE.OneFactor, that._copyPass.material.blendEquationAlpha = THREE.AddEquation, that._copyPass.material.depthTest = false, that._copyPass.material.depthWrite = false, that._copyPass.material.transparent = true, that;
  }
  return o(render, selector), render.prototype.dispose = function() {
    this._schemeBuffer.dispose();
    this.tempRenderTarget.dispose();
    this.resultRenderTarget.dispose();
  }, render.prototype.setSize = function(v, h) {
    this._schemeBuffer.setSize(v, h);
    this.tempRenderTarget.setSize(v, h);
    this.resultRenderTarget.setSize(v, h);
    this._blurXPass.uniforms.texSize.value.set(v, h);
    this._blurYPass.uniforms.texSize.value.set(v, h);
  }, render.prototype.render = function(e, s, i, value, type) {
    if (this._dirty) {
      this._schemeBuffer.useMRT = type;
      this._schemeBuffer.render(e, s, i);
      this._blurXPass.uniforms.scene.value = this._schemeBuffer.getSchemeTexture();
      this._blurXPass.uniforms.Stride.value = this.stride;
      this._blurXPass.render(e, this.tempRenderTarget);
      this._blurYPass.uniforms.blurX.value = this.tempRenderTarget.texture;
      this._blurYPass.uniforms.scene.value = this._schemeBuffer.getSchemeTexture();
      this._blurYPass.uniforms.Stride.value = this.stride;
      this._blurYPass.uniforms.Glowness.value = this.strength;
      this._blurYPass.uniforms.GlowColor.value.copy(this.color);
      this._blurYPass.render(e, this.resultRenderTarget);
      this._dirty = false;
    }
    this._copyPass.render(e, void 0 !== value ? value : null);
  }, render;
}(On);
ho = function(selector) {
  function render(value, n, parentNode) {
    r(this, render);
    var e = s(this, selector.call(this));
    return e._schemeBuffer = new Un(value, n, "radialBlur", parentNode), e.resultRenderTarget = Cn(value, n), e.resultRenderTarget.texture.name = "RadialBlurPass.result", e._blurPass = new tn(po), e._copyPass = new tn(Yr), e._copyPass.clear = false, e._copyPass.uniforms.opacity.value = 1, e._copyPass.uniforms.tDiffuse.value = e.resultRenderTarget.texture, e._copyPass.material.blending = THREE.CustomBlending, e._copyPass.material.blendSrc = THREE.OneFactor, e._copyPass.material.blendDst = THREE.OneFactor, 
    e._copyPass.material.blendEquation = THREE.AddEquation, e._copyPass.material.blendSrcAlpha = THREE.ZeroFactor, e._copyPass.material.blendDstAlpha = THREE.OneFactor, e._copyPass.material.blendEquationAlpha = THREE.AddEquation, e._copyPass.material.depthTest = false, e._copyPass.material.depthWrite = false, e._copyPass.material.transparent = true, e;
  }
  return o(render, selector), render.prototype.dispose = function() {
    this._schemeBuffer.dispose();
    this.resultRenderTarget.dispose();
  }, render.prototype.setSize = function(v, h) {
    this._schemeBuffer.setSize(v, h);
    this.resultRenderTarget.setSize(v, h);
  }, render.prototype.render = function(e, s, i, value, type) {
    if (this._dirty) {
      this._schemeBuffer.useMRT = type;
      this._schemeBuffer.render(e, s, i);
      this._blurPass.uniforms.blurMap.value = this._schemeBuffer.getSchemeTexture();
      this._blurPass.render(e, this.resultRenderTarget);
      this._dirty = false;
    }
    this._copyPass.render(e, void 0 !== value ? value : null);
  }, render;
}(On);
po = {
  uniforms : {
    blurMap : {
      value : null
    },
    BlurStart : {
      value : 1
    },
    BlurWidth : {
      value : -.1
    },
    direction : {
      value : new THREE.Vector2(0, 1)
    },
    Intensity : {
      value : 10
    },
    GlowGamma : {
      value : .8
    },
    CX : {
      value : .5
    },
    CY : {
      value : .5
    }
  },
  vertexShader : "\n\t\tvarying vec2 vUv;\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}\n    ",
  fragmentShader : "\n\t\tvarying vec2 vUv;\n\t\tuniform sampler2D blurMap;\n\t\tuniform float BlurStart;\n\t\tuniform float BlurWidth;\n\t\tuniform vec2 direction;\n\t\tuniform float Intensity;\n\t\tuniform float GlowGamma;\n\t\tuniform float CX;\n\t\tuniform float CY;\n\n\t\tvoid main() {\n\t\t\tvec2 texCoord = vUv;\n\t\t\tvec2 ctrPt = vec2(CX,CY);\n\t\t\tvec4 blurred = texture2D(blurMap, texCoord);\n\t\t\tvec2 resCoord = vec2(0.0);\n\t\t\tfor(float i=0.0; i<31.0; i++) {\n\t\t\t\tfloat scale = BlurStart + BlurWidth*((31.0-i)/(31.0-1.0));\n\t\t\t\tvec2 tmp = texCoord*scale;\n\t\t\t\tresCoord = mix(texCoord, tmp, direction);\n\t\t\t\tvec4 tmpc = texture2D(blurMap, resCoord )*(i/31.0)*(i/31.0);\n\t\t\t\tblurred += tmpc/31.0;\n\t\t\t}\n\n\t\t\tblurred.r = pow(blurred.r,GlowGamma);\n\t\t\tblurred.g = pow(blurred.g,GlowGamma);\n\t\t\tblurred.b = pow(blurred.b,GlowGamma);\n\t\t\tblurred.rgb *= Intensity;\n\t\t\tblurred.rgb = clamp(blurred.rgb, 0.0, 1.0);\n\n\t\t\tvec4 origTex = texture2D(blurMap, texCoord  );\n\t\t\tvec4 blurResult=origTex+blurred;\n\t\t\t//blurResult *= 2;\n\n\t\t\tvec2 dir=texCoord - ctrPt;\n\t\t\tfloat dist = sqrt( dir.x*dir.x + dir.y*dir.y );\n\t\t\tfloat t = dist * 1.0;\n\t\t\tt =  clamp(t, 0.0, 1.0);//We need 0 <= t <= 1\n\n\t\t\tgl_FragColor = blurResult*t;\n\t\t}\n\t"
};
fo = function(selector) {
  function render(value, n, parentNode) {
    r(this, render);
    var e = s(this, selector.call(this));
    return e._schemeBuffer = new Un(value, n, "radialBlur2", parentNode), e.resultRenderTarget = Cn(value, n), e.resultRenderTarget.texture.name = "RadialBlur2Pass.result", e._blurPass = new tn(mo), e._copyPass = new tn(Yr), e._copyPass.clear = false, e._copyPass.uniforms.opacity.value = 1, e._copyPass.uniforms.tDiffuse.value = e.resultRenderTarget.texture, e._copyPass.material.blending = THREE.CustomBlending, e._copyPass.material.blendSrc = THREE.OneFactor, e._copyPass.material.blendDst = THREE.OneFactor, 
    e._copyPass.material.blendEquation = THREE.AddEquation, e._copyPass.material.blendSrcAlpha = THREE.ZeroFactor, e._copyPass.material.blendDstAlpha = THREE.OneFactor, e._copyPass.material.blendEquationAlpha = THREE.AddEquation, e._copyPass.material.depthTest = false, e._copyPass.material.depthWrite = false, e._copyPass.material.transparent = true, e;
  }
  return o(render, selector), render.prototype.dispose = function() {
    this._schemeBuffer.dispose();
    this.resultRenderTarget.dispose();
  }, render.prototype.setSize = function(v, h) {
    this._schemeBuffer.setSize(v, h);
    this.resultRenderTarget.setSize(v, h);
  }, render.prototype.render = function(e, s, i, value, type) {
    if (this._dirty) {
      this._schemeBuffer.useMRT = type;
      this._schemeBuffer.render(e, s, i);
      this._blurPass.uniforms.blurMap.value = this._schemeBuffer.getSchemeTexture();
      this._blurPass.render(e, this.resultRenderTarget);
      this._dirty = false;
    }
    this._copyPass.render(e, void 0 !== value ? value : null);
  }, render;
}(On);
mo = {
  uniforms : {
    blurMap : {
      value : null
    },
    BlurStart : {
      value : 1
    },
    BlurWidth : {
      value : -.1
    },
    Intensity : {
      value : 10
    },
    GlowGamma : {
      value : .8
    },
    CX : {
      value : .5
    },
    CY : {
      value : .5
    }
  },
  vertexShader : "\n\t\tvarying vec2 vUv;\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}\n    ",
  fragmentShader : "\n\t\tvarying vec2 vUv;\n\t\tuniform sampler2D blurMap;\n\t\tuniform float BlurStart;\n\t\tuniform float BlurWidth;\n\t\tuniform float CX;\n\t\tuniform float CY;\n\t\tuniform float Intensity;\n\t\tuniform float GlowGamma;\n\t\t\n\t\tvoid main() {\n\t\t\tvec2 texCoord = vUv;\n\t\t\tvec2 ctrPt = vec2(CX,CY);\n\t\t\tvec4 blurred = texture2D(blurMap, texCoord );\n\t\t\n\t\t\tfor(float i=0.0; i<31.0; i++) {\n\t\t\t\tfloat scale = BlurStart + BlurWidth*((31.0-i)/(31.0-1.0));\n\t\t\t\tvec2 tmp = (texCoord - ctrPt)*scale + ctrPt;\n\t\t\t\tvec4 tmpc = texture2D(blurMap, tmp )*(i/31.0)*(i/31.0);\n\t\t\n\t\t\t\tblurred += tmpc/31.0;\n\t\t\n\t\t\t}\n\t\t\n\t\t\tblurred.r = pow(blurred.r,GlowGamma);\n\t\t\tblurred.g = pow(blurred.g,GlowGamma);\n\t\t\tblurred.b = pow(blurred.b,GlowGamma);\n\t\t\tblurred.rgb *= Intensity;\n\t\t\tblurred.rgb = clamp(blurred.rgb, 0.0, 1.0);\n\t\t\n\t\t\tvec4 origTex = texture2D(blurMap, texCoord  );\n\t\t\tvec4 blurResult=origTex+blurred;\n\t\t\t//blurResult *= 2;\n\t\t\n\t\t\tvec2 dir=texCoord - ctrPt;\n\t\t\tfloat dist = sqrt( dir.x*dir.x + dir.y*dir.y );\n\t\t\tfloat t = dist * 1.0;\n\t\t\tt =  clamp(t, 0.0, 1.0);//We need 0 <= t <= 1\n\t\t\n\t\t\tgl_FragColor = blurResult*t;\n\t\t}\n\t"
};
go = function(selector) {
  function render(value, n, parentNode) {
    r(this, render);
    var e = s(this, selector.call(this));
    return e._schemeBuffer = new Un(value, n, "radialOffset", parentNode), e.resultRenderTarget = Cn(value, n), e.resultRenderTarget.texture.name = "RadialOffsetPass.result", e._blurPass = new tn(vo), e._copyPass = new tn(Yr), e._copyPass.clear = false, e._copyPass.uniforms.opacity.value = 1, e._copyPass.uniforms.tDiffuse.value = e.resultRenderTarget.texture, e._copyPass.material.blending = THREE.CustomBlending, e._copyPass.material.blendSrc = THREE.OneFactor, e._copyPass.material.blendDst = THREE.OneFactor, 
    e._copyPass.material.blendEquation = THREE.AddEquation, e._copyPass.material.blendSrcAlpha = THREE.ZeroFactor, e._copyPass.material.blendDstAlpha = THREE.OneFactor, e._copyPass.material.blendEquationAlpha = THREE.AddEquation, e._copyPass.material.depthTest = false, e._copyPass.material.depthWrite = false, e._copyPass.material.transparent = true, e;
  }
  return o(render, selector), render.prototype.dispose = function() {
    this._schemeBuffer.dispose();
    this.resultRenderTarget.dispose();
  }, render.prototype.setSize = function(v, h) {
    this._schemeBuffer.setSize(v, h);
    this.resultRenderTarget.setSize(v, h);
  }, render.prototype.render = function(e, s, i, value, type) {
    if (this._dirty) {
      this._schemeBuffer.useMRT = type;
      this._schemeBuffer.render(e, s, i);
      this._blurPass.uniforms.tex0.value = this._schemeBuffer.getSchemeTexture();
      this._blurPass.render(e, this.resultRenderTarget);
      this._dirty = false;
    }
    this._copyPass.render(e, void 0 !== value ? value : null);
  }, render;
}(On);
vo = {
  uniforms : {
    tex0 : {
      value : null
    },
    BlurStart : {
      value : 1
    },
    BlurWidth : {
      value : -.1
    },
    Intensity : {
      value : 3
    },
    GlowGamma : {
      value : 1
    },
    CX : {
      value : .5
    },
    CY : {
      value : .5
    }
  },
  vertexShader : "\n\t\tvarying vec2 vUv;\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}\n    ",
  fragmentShader : "\n\t\tvarying vec2 vUv;\n\t\tuniform sampler2D tex0;\n\t\tuniform float BlurStart;\n\t\tuniform float BlurWidth;\n\t\tuniform float CX;\n\t\tuniform float CY;\n\t\tuniform float Intensity;\n\t\tuniform float GlowGamma;\n\t\t\n\t\t\n\t\tvoid main() {\n\t\t\tvec2 uv = vUv;\n\t\t\tvec2 ctrPt = vec2(CX, CY);\n\t\t\n\t\t\tfloat scale = BlurStart + BlurWidth * 1.0;\n\t\t\tvec2 tmp = (uv - ctrPt) * scale + ctrPt;\n\n\t\t\tvec4 blurred = texture2D(tex0, tmp);\n\t\t\tblurred.rgb = pow(blurred.rgb, vec3(GlowGamma));\n\t\t\tblurred.rgb *= Intensity;\n\t\t\tblurred.rgb = clamp(blurred.rgb, 0.0, 1.0);\n\t\t\t\n\t\t\tvec2 dir = uv - ctrPt;\n\t\t\tfloat dist = sqrt(dir.x * dir.x + dir.y * dir.y);\n\t\t\n\t\t\tgl_FragColor = blurred * clamp(dist, 0.0, 1.0);\n\t\t}\n\t"
};
yo = {
  uniforms : {
    colorMap : {
      value : null
    },
    maskMap : {
      value : null
    },
    darkFactor : {
      value : .5
    },
    brightFactor : {
      value : 1
    }
  },
  vertexShader : ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader : ["uniform sampler2D colorMap;", "uniform sampler2D maskMap;", "uniform float darkFactor;", "uniform float brightFactor;", "varying vec2 vUv;", "void main() {", "float mask = texture2D( maskMap, vUv ).a;", "vec4 color = texture2D( colorMap, vUv );", "color.rgb = color.rgb * (1.0 - mask) * darkFactor + color.rgb * mask * brightFactor;", "gl_FragColor = color;", "}"].join("\n")
};
bo = sn(1, 1, 1);
_o = new Map;
var xo = 0;
var Eo = function(e) {
  function d(c, a, n, f) {
    r(this, d);
    var res = s(this, e.call(this, c, a, wn(n) + "Scheme_" + ++xo, f));
    return res.marker = n, res;
  }
  return o(d, e), d.prototype.shareDepthTexture = function(canCreateDiscussions) {
  }, d.prototype.shareDepthRenderBuffer = function(courseId, canCreateDiscussions) {
  }, d.prototype.clearDepthShare = function() {
  }, d.prototype._initStrategy = function(charsetPart) {
    var tEdit = this;
    charsetPart.materialManager.addStrategy(this.name, function(canCreateDiscussions, i, isSlidingUp, n, arg, s) {
      if (pn(this, arg)) {
        return null;
      }
      var right = hn(this.technique, tEdit.marker);
      if ("skip" === right) {
        return null;
      }
      var swapDirection = void 0;
      return right ? (cn(swapDirection = right.isMaterial ? right : function(rangeObj, source) {
        var x = rangeObj.isInstancedMesh + "_" + source.skinning;
        var y = void 0;
        return _o.has(x) ? y = _o.get(x) : ((y = new THREE.ShaderMaterial(bo)).skinning = source.skinning, _o.set(x, y)), y;
      }(this, arg), arg, true), swapDirection) : null;
    });
  }, d;
}(Nn);
wo = function(selector) {
  function render(options, width, logger) {
    r(this, render);
    var self = s(this, selector.call(this));
    return self.darkFactor = .5, self.brightFactor = 1, self._schemeBuffer = new Eo(options, width, "focusRegion", logger), self.resultRenderTarget = Cn(options, width), self.resultRenderTarget.texture.name = "FocusRegionPass.result", self._blendPass = new tn(yo), self._copyPass = new tn(Yr), self._copyPass.uniforms.opacity.value = 1, self._copyPass.uniforms.tDiffuse.value = self.resultRenderTarget.texture, self;
  }
  return o(render, selector), render.prototype.dispose = function() {
    this._schemeBuffer.dispose();
    this.resultRenderTarget.dispose();
  }, render.prototype.setSize = function(v, h) {
    this._schemeBuffer.setSize(v, h);
    this.resultRenderTarget.setSize(v, h);
  }, render.prototype.render = function(e, s, i, value, type) {
    if (this._dirty) {
      this._schemeBuffer.useMRT = type;
      this._schemeBuffer.render(e, s, i);
      this._dirty = false;
    }
    this._blendPass.uniforms.colorMap.value = value.texture;
    this._blendPass.uniforms.maskMap.value = this._schemeBuffer.getSchemeTexture();
    this._blendPass.uniforms.darkFactor.value = this.darkFactor;
    this._blendPass.uniforms.brightFactor.value = this.brightFactor;
    this._blendPass.render(e, this.resultRenderTarget);
    this._copyPass.render(e, value);
  }, render;
}(On);
To = sn(0, 1, 1);
Mo = new Map;
var Co = function(instance) {
  function i(target, type, value) {
    r(this, i);
    var e = s(this, instance.call(this, target, type, "OutlineScheme_" + value));
    return e._edgeColorString = value, e.enableLayer1 = true, e;
  }
  return o(i, instance), i.prototype._initStrategy = function(charsetPart) {
    var t = this;
    charsetPart.materialManager.addStrategy(this.name, function(canCreateDiscussions, i, r, n, tangentMaterial, s) {
      if (!this.userData.forceOutline && !r.layers.test(this.layers)) {
        return null;
      }
      var mode = "outline_0x" + t._edgeColorString;
      var d = hn(this.technique, mode);
      return d && "skip" !== d ? this.technique[mode].isMaterial ? this.technique[mode] : function(rangeObj, material) {
        var i = rangeObj.isInstancedMesh + "_" + material.skinning;
        var m = void 0;
        return Mo.has(i) ? m = Mo.get(i) : ((m = new THREE.ShaderMaterial(To)).side = THREE.DoubleSide, m.skinning = material.skinning, Mo.set(i, m)), m;
      }(this, tangentMaterial) : null;
    });
  }, i;
}(Nn);
So = {
  uniforms : {
    maskTexture : {
      value : null
    },
    texSize : {
      value : new THREE.Vector2(.5, .5)
    },
    edgeColor : {
      value : new THREE.Color(1, 1, 1)
    }
  },
  fragmentShader : "\n\t\tvarying vec2 vUv;\n\t\tuniform sampler2D maskTexture;\n\t\tuniform vec2 texSize;\n\t\tuniform vec3 edgeColor;\n\t\t\n\t\tvoid main() {\n\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\tvec4 c1 = texture2D(maskTexture, vUv + uvOffset.xy);\n\t\t\tvec4 c2 = texture2D(maskTexture, vUv - uvOffset.xy);\n\t\t\tvec4 c3 = texture2D(maskTexture, vUv + uvOffset.yw);\n\t\t\tvec4 c4 = texture2D(maskTexture, vUv - uvOffset.yw);\n\t\t\tfloat b1 = max(c1.b, c2.b);\n\t\t\tfloat b2 = max(c3.b, c4.b);\n\t\t\tfloat a = max(b1, b2);\n\t\t\tgl_FragColor = vec4(edgeColor, a);\n\t\t}\n\t"
};
jo = {
  defines : {
    MAX_RADIUS : 4
  },
  uniforms : {
    colorTexture : {
      value : null
    },
    texSize : {
      value : new THREE.Vector2(.5, .5)
    },
    direction : {
      value : new THREE.Vector2(.5, .5)
    },
    kernelRadius : {
      value : 1
    }
  },
  fragmentShader : "\n\t\t#include <common>\n\t\tvarying vec2 vUv;\n\t\tuniform sampler2D colorTexture;\n\t\tuniform vec2 texSize;\n\t\tuniform vec2 direction;\n\t\tuniform float kernelRadius;\n\t\t\n\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\treturn 0.39894 * exp(-0.5 * x * x / (sigma * sigma)) / sigma;\n\t\t}\n\t\tvoid main() {\n\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\n\t\t\tvec4 diffuseColor = texture2D(colorTexture, vUv);\n\t\t\tvec4 diffuseSum = diffuseColor * weightSum;\n\t\t\tvec2 delta = direction * invSize * kernelRadius / float(MAX_RADIUS);\n\t\t\tvec2 uvOffset = delta;\n\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\n\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\tuvOffset += delta;\n\t\t\t}\n\t\t\tvec4 color = diffuseSum / weightSum;\n\t\t\tgl_FragColor = color;\n\t\t}\n\t"
};
Po = {
  uniforms : {
    maskTexture : {
      value : null
    },
    edgeTexture1 : {
      value : null
    },
    edgeTexture2 : {
      value : null
    },
    edgeStrength : {
      value : 1
    },
    edgeGlow : {
      value : 1
    }
  },
  fragmentShader : "\n\t\tvarying vec2 vUv;\n\t\tuniform sampler2D maskTexture;\n\t\tuniform sampler2D edgeTexture1;\n\t\tuniform sampler2D edgeTexture2;\n\t\tuniform float edgeStrength;\n\t\tuniform float edgeGlow;\n\t\t\n\t\tvoid main() {\n\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\tvec4 finalColor = edgeStrength * edgeValue;\n\t\t\tfloat a = finalColor.a * (1.0 - maskColor.b);\n\t\t\tgl_FragColor = vec4(finalColor.rgb, a);\n\t\t}\n\t"
};
Ro = function(selector) {
  function update(value, i, c) {
    r(this, update);
    var me = s(this, selector.call(this));
    me.edgeColor = (new THREE.Color).setHex(void 0 !== c ? c : 16777215);
    me.edgeGlow = 0;
    me.edgeThickness = 1;
    me.edgeStrength = 1.5;
    me.downSampleRatio = 2;
    me._schemeBuffer = new Co(value, i, me.edgeColor.getHexString());
    var l = Math.round(value / me.downSampleRatio);
    var min = Math.round(i / me.downSampleRatio);
    return me.renderTargetMaskDownSampleBuffer = Cn(l, min), me.renderTargetMaskDownSampleBuffer.texture.name = "OutlinePass.depthDownSample", me.renderTargetBlurBuffer1 = Cn(l, min), me.renderTargetBlurBuffer1.texture.name = "OutlinePass.blur1", me.renderTargetBlurBuffer2 = Cn(Math.round(l / 2), Math.round(min / 2)), me.renderTargetBlurBuffer2.texture.name = "OutlinePass.blur2", me.renderTargetEdgeBuffer1 = Cn(l, min), me.renderTargetEdgeBuffer1.texture.name = "OutlinePass.edge1", me.renderTargetEdgeBuffer2 = 
    Cn(Math.round(l / 2), Math.round(min / 2)), me.renderTargetEdgeBuffer2.texture.name = "OutlinePass.edge2", me._copyPass = new tn(Yr), me._copyPass.clearAlpha = 0, me._copyPass.uniforms.opacity.value = 1, me._copyPass.material.blending = THREE.NoBlending, me._copyPass.material.depthTest = false, me._copyPass.material.depthWrite = false, me._copyPass.material.transparent = true, me._edgeDetectionPass = new tn(So), me._edgeDetectionPass.clearAlpha = 0, me._edgeDetectionPass.textureID = "maskTexture", 
    me._blur1Pass = new tn(jo), me._blur1Pass.clearAlpha = 0, me._blur1Pass.textureID = "colorTexture", me._blur1Pass.uniforms.texSize.value.set(l, min), me._blur1Pass.material.defines.MAX_RADIUS = 4, me._blur1Pass.uniforms.kernelRadius.value = 1, me._blur2Pass = new tn(jo), me._blur2Pass.clearAlpha = 0, me._blur2Pass.textureID = "colorTexture", me._blur2Pass.uniforms.texSize.value.set(Math.round(l / 2), Math.round(min / 2)), me._blur2Pass.material.defines.MAX_RADIUS = 4, me._blur2Pass.uniforms.kernelRadius.value = 
    4, me._overlayPass = new tn(Po), me._overlayPass.clear = false, me._overlayPass.material.blending = THREE.NormalBlending, me._overlayPass.material.depthTest = false, me._overlayPass.material.depthWrite = false, me._overlayPass.material.transparent = true, me._overlayPass.uniforms.edgeTexture1.value = me.renderTargetEdgeBuffer1.texture, me._overlayPass.uniforms.edgeTexture2.value = me.renderTargetEdgeBuffer2.texture, me;
  }
  return o(update, selector), update.prototype.dispose = function() {
    this._schemeBuffer.dispose();
    this.renderTargetMaskDownSampleBuffer.dispose();
    this.renderTargetBlurBuffer1.dispose();
    this.renderTargetBlurBuffer2.dispose();
    this.renderTargetEdgeBuffer1.dispose();
    this.renderTargetEdgeBuffer2.dispose();
  }, update.prototype.setSize = function(v, h) {
    this._schemeBuffer.setSize(v, h);
    var i = Math.round(v / this.downSampleRatio);
    var w = Math.round(h / this.downSampleRatio);
    this.renderTargetMaskDownSampleBuffer.setSize(i, w);
    this.renderTargetBlurBuffer1.setSize(i, w);
    this.renderTargetEdgeBuffer1.setSize(i, w);
    this._blur1Pass.uniforms.texSize.value.set(i, w);
    i = Math.round(i / 2);
    w = Math.round(w / 2);
    this.renderTargetBlurBuffer2.setSize(i, w);
    this.renderTargetEdgeBuffer2.setSize(i, w);
    this._blur2Pass.uniforms.texSize.value.set(i, w);
  }, update.prototype.render = function(n, val, i, value, type) {
    if (this._dirty) {
      this._schemeBuffer.useMRT = type;
      this._schemeBuffer.render(n, val, i);
      this._copyPass.uniforms.tDiffuse.value = this._schemeBuffer.getSchemeTexture();
      this._copyPass.render(n, this.renderTargetMaskDownSampleBuffer);
      this._edgeDetectionPass.uniforms.texSize.value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);
      this._edgeDetectionPass.uniforms.edgeColor.value.copy(this.edgeColor);
      this._edgeDetectionPass.render(n, this.renderTargetEdgeBuffer1, this.renderTargetMaskDownSampleBuffer);
      this._blur1Pass.uniforms.kernelRadius.value = this.edgeThickness;
      this._blur1Pass.uniforms.direction.value.set(1, 0);
      this._blur1Pass.render(n, this.renderTargetBlurBuffer1, this.renderTargetEdgeBuffer1);
      this._blur1Pass.uniforms.direction.value.set(0, 1);
      this._blur1Pass.render(n, this.renderTargetEdgeBuffer1, this.renderTargetBlurBuffer1);
      if (this.edgeGlow > 0) {
        this._blur2Pass.uniforms.direction.value.set(1, 0);
        this._blur2Pass.render(n, this.renderTargetBlurBuffer2, this.renderTargetEdgeBuffer1);
        this._blur2Pass.uniforms.direction.value.set(0, 1);
        this._blur2Pass.render(n, this.renderTargetEdgeBuffer2, this.renderTargetBlurBuffer2);
      }
      this._overlayPass.uniforms.maskTexture.value = this._schemeBuffer.getSchemeTexture();
      this._overlayPass.uniforms.edgeStrength.value = this.edgeStrength;
      this._overlayPass.uniforms.edgeGlow.value = this.edgeGlow;
      this._dirty = false;
    }
    this._overlayPass.render(n, void 0 !== value ? value : null);
  }, update.prototype.dirty = function() {
    this._dirty = true;
  }, update;
}(On);
Do = function(index, base) {
  var zip_opt_len = 0;
  var f = 1 / base;
  var i = index;
  for (; i > 0;) {
    zip_opt_len = zip_opt_len + f * (i % base);
    i = Math.floor(i / base);
    f = f / base;
  }
  return zip_opt_len;
};
function Ao(width, height, transpCheck) {
  this._samplingSize = transpCheck || 30;
  var haltonSequence = [];
  var previousWidgetPos = 0;
  for (; previousWidgetPos < this._samplingSize; previousWidgetPos++) {
    haltonSequence.push([Do(previousWidgetPos, 2), Do(previousWidgetPos, 3)]);
  }
  this._haltonSequence = haltonSequence;
  this._prevFrame = new THREE.WebGLRenderTarget(width, height, {
    minFilter : THREE.LinearFilter,
    magFilter : THREE.LinearFilter,
    format : THREE.RGBAFormat
  });
  this._output = new THREE.WebGLRenderTarget(width, height, {
    minFilter : THREE.LinearFilter,
    magFilter : THREE.LinearFilter,
    format : THREE.RGBAFormat
  });
  this._frame = 0;
  this.quadCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  this.quadScene = new THREE.Scene;
  this.quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.ShaderMaterial({
    uniforms : THREE.UniformsUtils.clone(Kn.uniforms),
    vertexShader : Kn.vertexShader,
    fragmentShader : Kn.fragmentShader,
    depthTest : false,
    depthWrite : false
  }));
  this.quadScene.add(this.quadCamera);
  this.quadScene.add(this.quad);
}
Ao.prototype = Object.assign(Ao.prototype, {
  constructor : Ao,
  setSize : function(data, x) {
    this._prevFrame.setSize(data, x);
    this._output.setSize(data, x);
  },
  setSamplingSize : function(canCreateDiscussions) {
    this._samplingSize = canCreateDiscussions || 30;
    var haltonSequence = [];
    var previousWidgetPos = 0;
    for (; previousWidgetPos < this._samplingSize; previousWidgetPos++) {
      haltonSequence.push([Do(previousWidgetPos, 2), Do(previousWidgetPos, 3)]);
    }
    this._haltonSequence = haltonSequence;
    this._frame = 0;
  },
  getSamplingSize : function() {
    return this._samplingSize;
  },
  start : function() {
    this._frame = 0;
  },
  finished : function() {
    return this._frame >= this._samplingSize;
  },
  frame : function() {
    return this._frame;
  },
  jitterProjection : function(camera, width, height) {
    var offset = this._haltonSequence[this._frame];
    if (!offset) {
      console.error("THREE.SuperSampler: try to jitter camera after finished!", this._frame, this._haltonSequence.length);
    }
    if (camera.setViewOffset) {
      camera.setViewOffset(width, height, .5 * (2 * offset[0] - 1), .5 * (2 * offset[1] - 1), width, height);
    }
  },
  sample : function(renderer, position) {
    var bAllUsers = 0 === this._frame;
    this.quad.material.uniforms.tDiffuse1.value = position;
    this.quad.material.uniforms.tDiffuse2.value = this._prevFrame.texture;
    this.quad.material.uniforms.mixRatio.value = bAllUsers ? 0 : .9;
    this.quad.material.uniforms.opacity.value = 1;
    var clearColor = renderer.getClearColor().getHex();
    var oldClearAlpha = renderer.getClearAlpha();
    renderer.setClearColor(0, 0);
    renderer.setRenderTarget(this._output);
    renderer.clear();
    renderer.render(this.quadScene, this.quadCamera);
    renderer.setClearColor(clearColor, oldClearAlpha);
    var output = this._prevFrame;
    return this._prevFrame = this._output, this._output = output, this._frame++, this._prevFrame;
  },
  output : function() {
    return this._prevFrame;
  },
  dispose : function() {
    this._prevFrame.dispose();
    this._output.dispose();
    this.quadScene.remove(this.quadCamera);
    this.quadScene.remove(this.quad);
    this.quad.material.dispose();
  }
});
var ko = {
  temporalSuperSampling : {
    enable : false,
    size : 30
  },
  postEffect : {
    enable : true,
    bloom : {
      enable : false,
      strength : .14,
      radius : .4,
      threshold : .7
    },
    screenSpaceAmbientOcclusion : {
      enable : false,
      radius : .2,
      quality : "medium",
      intensity : .8,
      temporalFilter : true,
      ignoreTransparent : false
    },
    screenSpaceReflection : {
      enable : false,
      maxRayDistance : 200,
      pixelStride : 16,
      pixelStrideZCutoff : 50,
      screenEdgeFadeStart : .9,
      eyeFadeStart : .4,
      eyeFadeEnd : .8,
      minGlossiness : .2,
      temporalFilter : true
    },
    colorCorrection : {
      enable : true,
      exposure : 0,
      brightness : 0,
      contrast : 1.1,
      saturation : 1.1,
      gamma : 1
    },
    dof : {
      enable : false,
      focalDepth : 1,
      focalLength : 24,
      fstop : .9,
      maxblur : 1,
      threshold : .9,
      gain : 1,
      bias : .5,
      dithering : 1e-4
    },
    vignette : {
      enable : false,
      type : "color",
      color : 0,
      offset : 1
    },
    vignetting : {
      enable : false,
      color : 0,
      offset : 1
    },
    blurEdge : {
      enable : false,
      offset : 1
    },
    film : {
      enable : false,
      grayscale : true,
      noiseIntensity : .35,
      scanlinesIntensity : .5,
      scanlinesCount : 2048
    },
    chromaticAberration : {
      enable : false,
      chromaFactor : .025
    },
    blur : {
      enable : false,
      bounds : [[0, 0, 1, 1]],
      radius : 5
    },
    FXAA : {
      enable : false
    },
    MSAA : {
      enable : true
    }
  }
};
Oo = function() {
  function o() {
    r(this, o);
    this.needSwapBuffer = true;
  }
  return o.prototype.setSize = function(t, num) {
  }, o.prototype.render = function(n, type, obj, fn, name) {
    console.error("Effect: .render() must be implemented in derived pass.");
  }, o.prototype.dispose = function() {
  }, o;
}();
Bo = function(selector) {
  function e(f, h, x) {
    r(this, e);
    var that = s(this, selector.call(this));
    return that._pass = f, void 0 !== h && void 0 !== x && that.setSize(h, x), that;
  }
  return o(e, selector), e.prototype.setSize = function(v, h) {
    this._pass.setSize(v, h);
  }, e.prototype.render = function(el, type, k, query, data) {
    this._pass.render(el, type, k, query, data);
  }, e.prototype.dispose = function() {
    this._pass.material.dispose();
  }, e;
}(Oo);
Fo = new THREE.Vector2(1, 0);
Lo = new THREE.Vector2(0, 1);
Io = function(selector) {
  function render(max, total) {
    r(this, render);
    var node = s(this, selector.call(this));
    node.needSwapBuffer = false;
    node.strength = .14;
    node.radius = .4;
    node.threshold = .6;
    node.renderTargetsHorizontal = [];
    node.renderTargetsVertical = [];
    node.nMips = 5;
    var i = 0;
    var value = Math.round(max / 2);
    var u = Math.round(total / 2);
    node.renderTargetBright = Cn(value, u);
    node.renderTargetBright.texture.name = "BloomEffect.bright";
    i = 0;
    for (; i < node.nMips; i++) {
      var res = Cn(value, u);
      res.texture.name = "BloomEffect.h" + i;
      node.renderTargetsHorizontal.push(res);
      var p = Cn(value, u);
      p.texture.name = "BloomEffect.v" + i;
      node.renderTargetsVertical.push(p);
      value = Math.round(value / 2);
      u = Math.round(u / 2);
    }
    node.highPass = new tn(qn);
    node.highPass.clearAlpha = 0;
    node.highPass.uniforms.luminosityThreshold.value = node.threshold;
    node.highPass.uniforms.smoothWidth.value = .01;
    node.separableBlurPasses = [];
    var siblingsToAdd = [3, 5, 7, 9, 11];
    value = Math.round(max / 2);
    u = Math.round(total / 2);
    i = 0;
    for (; i < node.nMips; i++) {
      var object = new tn(Xn);
      object.clearAlpha = 0;
      object.material.defines.KERNEL_RADIUS = siblingsToAdd[i];
      object.material.defines.SIGMA = siblingsToAdd[i];
      object.uniforms.texSize.value.set(value, u);
      node.separableBlurPasses.push(object);
      value = Math.round(value / 2);
      u = Math.round(u / 2);
    }
    node.compositePass = new tn(Jn);
    node.compositePass.clearAlpha = 0;
    node.compositePass.material.defines.NUM_MIPS = 5;
    node.compositePass.uniforms.blurTexture1.value = node.renderTargetsVertical[0].texture;
    node.compositePass.uniforms.blurTexture2.value = node.renderTargetsVertical[1].texture;
    node.compositePass.uniforms.blurTexture3.value = node.renderTargetsVertical[2].texture;
    node.compositePass.uniforms.blurTexture4.value = node.renderTargetsVertical[3].texture;
    node.compositePass.uniforms.blurTexture5.value = node.renderTargetsVertical[4].texture;
    node.compositePass.uniforms.bloomStrength.value = node.strength;
    node.compositePass.uniforms.bloomRadius.value = .1;
    return node.compositePass.uniforms.bloomFactors.value = [1, .8, .6, .4, .2], node.bloomTintColors = [new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1)], node.compositePass.uniforms.bloomTintColors.value = node.bloomTintColors, node.copyPass = new tn(Yr), node.copyPass.clear = false, node.copyPass.uniforms.opacity.value = 1, node.copyPass.material.blending = THREE.CustomBlending, node.copyPass.material.blendSrc = 
    THREE.SrcAlphaFactor, node.copyPass.material.blendDst = THREE.OneFactor, node.copyPass.material.blendEquation = THREE.AddEquation, node.copyPass.material.blendSrcAlpha = THREE.ZeroFactor, node.copyPass.material.blendDstAlpha = THREE.OneFactor, node.copyPass.material.blendEquationAlpha = THREE.AddEquation, node.copyPass.material.depthTest = false, node.copyPass.material.depthWrite = false, node.copyPass.material.transparent = true, node;
  }
  return o(render, selector), render.prototype.setSize = function(t, num) {
    var i = Math.round(t / 2);
    var h = Math.round(num / 2);
    this.renderTargetBright.setSize(i, h);
    var segmentedRequest = 0;
    for (; segmentedRequest < this.nMips; segmentedRequest++) {
      this.renderTargetsHorizontal[segmentedRequest].setSize(i, h);
      this.renderTargetsVertical[segmentedRequest].setSize(i, h);
      this.separableBlurPasses[segmentedRequest].uniforms.texSize.value.set(i, h);
      i = Math.round(i / 2);
      h = Math.round(h / 2);
    }
  }, render.prototype.render = function(value, str, t, object, type) {
    this.highPass.uniforms.luminosityThreshold.value = this.threshold;
    this.highPass.render(value, this.renderTargetBright, t);
    var inputRenderTarget = this.renderTargetBright;
    var i = 0;
    for (; i < this.nMips; i++) {
      this.separableBlurPasses[i].uniforms.colorTexture.value = inputRenderTarget.texture;
      this.separableBlurPasses[i].uniforms.direction.value.copy(Fo);
      this.separableBlurPasses[i].render(value, this.renderTargetsHorizontal[i]);
      this.separableBlurPasses[i].uniforms.colorTexture.value = this.renderTargetsHorizontal[i].texture;
      this.separableBlurPasses[i].uniforms.direction.value.copy(Lo);
      this.separableBlurPasses[i].render(value, this.renderTargetsVertical[i]);
      inputRenderTarget = this.renderTargetsVertical[i];
    }
    this.compositePass.uniforms.bloomStrength.value = this.strength;
    this.compositePass.uniforms.bloomRadius.value = this.radius;
    this.compositePass.uniforms.bloomTintColors.value = this.bloomTintColors;
    this.compositePass.render(value, this.renderTargetsHorizontal[0]);
    this.copyPass.render(value, t, this.renderTargetsHorizontal[0]);
  }, render.prototype.dispose = function() {
    this.renderTargetBright.dispose();
    this.renderTargetsHorizontal.forEach(function(backdropRef) {
      return backdropRef.dispose();
    });
    this.renderTargetsVertical.forEach(function(backdropRef) {
      return backdropRef.dispose();
    });
  }, render;
}(Oo);
No = {
  defines : {
    USE_VIGNETTE_TEXTURE : false
  },
  uniforms : {
    tDiffuse : {
      value : null
    },
    vignetteOffset : {
      value : 1
    },
    vignetteColor : {
      value : new THREE.Color(0)
    },
    vignetteTexture : {
      value : null
    }
  },
  vertexShader : "\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n    ",
  fragmentShader : "\n\t    uniform sampler2D tDiffuse;\n\n\t\tuniform float vignetteOffset;\n        uniform vec3 vignetteColor;\n        \n        #ifdef USE_VIGNETTE_TEXTURE\n            uniform sampler2D vignetteTexture;\n        #endif\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 color = texture2D(tDiffuse, vUv);\n            vec2 uv = (vUv - vec2(0.5)) * vec2(vignetteOffset);\n            \n            vec3 color2 = vignetteColor;\n\n            #ifdef USE_VIGNETTE_TEXTURE\n                color2 *= texture2D(vignetteTexture, vUv).rgb;\n            #endif\n\n\t\t\tcolor.rgb = mix(color.rgb, color2, clamp(dot(uv, uv), 0.0, 1.0));\n\t\t\tgl_FragColor = color;\n\n\t\t}\n    "
};
Ho = function(selector) {
  function draw(scale, value) {
    r(this, draw);
    var e = s(this, selector.call(this));
    return e.type = "color", e.color = new THREE.Color(0), e.offset = 1, e.tempRenderTarget = Cn(scale / 2, value / 2), e.tempRenderTarget2 = Cn(scale / 2, value / 2), e.effectHBlur = new tn(eo), e.effectVBlur = new tn($n), e.effectHBlur.uniforms.h.value = 4 / scale, e.effectVBlur.uniforms.v.value = 4 / value, e.blendPass = new tn(No), e;
  }
  return o(draw, selector), draw.prototype.setSize = function(value, h) {
    this.tempRenderTarget.setSize(value / 2, h / 2);
    this.tempRenderTarget2.setSize(value / 2, h / 2);
    this.effectHBlur.uniforms.h.value = 4 / value;
    this.effectVBlur.uniforms.v.value = 4 / h;
  }, draw.prototype.render = function(node, e, t, object, type) {
    if ("color" === this.type) {
      this.blendPass.uniforms.vignetteOffset.value = this.offset;
      this.blendPass.uniforms.vignetteColor.value.copy(this.color);
      if (this.blendPass.material.defines.USE_VIGNETTE_TEXTURE) {
        this.blendPass.material.defines.USE_VIGNETTE_TEXTURE = false;
        this.blendPass.material.needsUpdate = true;
      }
    } else {
      if ("blur" === this.type) {
        this.effectHBlur.render(node, this.tempRenderTarget2, t);
        this.effectVBlur.render(node, this.tempRenderTarget, this.tempRenderTarget2);
        this.blendPass.uniforms.vignetteOffset.value = this.offset;
        this.blendPass.uniforms.tDiffuse.value = t.texture;
        this.blendPass.uniforms.vignetteTexture.value = this.tempRenderTarget.texture;
        this.blendPass.uniforms.vignetteColor.value.setRGB(1, 1, 1);
        if (!this.blendPass.material.defines.USE_VIGNETTE_TEXTURE) {
          this.blendPass.material.defines.USE_VIGNETTE_TEXTURE = true;
          this.blendPass.material.needsUpdate = true;
        }
      }
    }
    this.blendPass.render(node, e, t);
  }, draw.prototype.dispose = function() {
    this.tempRenderTarget.dispose();
    this.tempRenderTarget2.dispose();
  }, draw;
}(Oo);
Uo = function(selector) {
  function callback(result, wasThrown) {
    r(this, callback);
    var e = s(this, selector.call(this));
    return e.color = new THREE.Color(0), e.offset = 1, e.tempRenderTarget = Cn(result / 2, wasThrown / 2), e.blendPass = new tn(No), e.blendPass.material.defines.USE_VIGNETTE_TEXTURE = false, e;
  }
  return o(callback, selector), callback.prototype.setSize = function(v, h) {
    this.tempRenderTarget.setSize(v / 2, h / 2);
  }, callback.prototype.render = function(node, e, i, object, type) {
    this.blendPass.uniforms.vignetteOffset.value = this.offset;
    this.blendPass.uniforms.vignetteColor.value.copy(this.color);
    this.blendPass.render(node, e, i);
  }, callback.prototype.dispose = function() {
    this.tempRenderTarget.dispose();
  }, callback;
}(Oo);
zo = function(selector) {
  function t(scale, value) {
    r(this, t);
    var e = s(this, selector.call(this));
    return e.offset = 1, e.tempRenderTarget = Cn(scale / 2, value / 2), e.tempRenderTarget2 = Cn(scale / 2, value / 2), e.effectHBlur = new tn(eo), e.effectVBlur = new tn($n), e.effectHBlur.uniforms.h.value = 4 / scale, e.effectVBlur.uniforms.v.value = 4 / value, e.blendPass = new tn(No), e.blendPass.material.defines.USE_VIGNETTE_TEXTURE = true, e;
  }
  return o(t, selector), t.prototype.setSize = function(value, h) {
    this.tempRenderTarget.setSize(value / 2, h / 2);
    this.tempRenderTarget2.setSize(value / 2, h / 2);
    this.effectHBlur.uniforms.h.value = 4 / value;
    this.effectVBlur.uniforms.v.value = 4 / h;
  }, t.prototype.render = function(node, e, t, object, type) {
    this.effectHBlur.render(node, this.tempRenderTarget2, t);
    this.effectVBlur.render(node, this.tempRenderTarget, this.tempRenderTarget2);
    this.blendPass.uniforms.vignetteOffset.value = this.offset;
    this.blendPass.uniforms.tDiffuse.value = t.texture;
    this.blendPass.uniforms.vignetteTexture.value = this.tempRenderTarget.texture;
    this.blendPass.uniforms.vignetteColor.value.setRGB(1, 1, 1);
    this.blendPass.render(node, e, t);
  }, t.prototype.dispose = function() {
    this.tempRenderTarget.dispose();
    this.tempRenderTarget2.dispose();
  }, t;
}(Oo);
Vo = {
  defines : {
    USE_MASKMAP : 0
  },
  uniforms : {
    tDiffuse : {
      value : null
    },
    bounds : {
      value : new THREE.Vector4(0, 0, 1, 1)
    },
    filletXRadius : {
      value : new THREE.Vector4
    },
    filletYRadius : {
      value : new THREE.Vector4
    },
    blendTexture : {
      value : null
    },
    maskMap : {
      value : null
    }
  },
  vertexShader : "\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n    ",
  fragmentShader : "\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D blendTexture;\n\n\t\tuniform vec4 bounds;\n\n\t\tuniform vec4 filletXRadius;\n\t\tuniform vec4 filletYRadius;\n\n\t\tuniform sampler2D maskMap;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\t\t\tvec4 color = texture2D(tDiffuse, vUv);\n\t\t\tvec3 color2 = texture2D(blendTexture, vUv).rgb;\n\t\t\t\n\t\t\tvec2 blurCenter = (bounds.xy + bounds.zw) * 0.5;\n\t\t\tvec2 blurSize = bounds.zw - bounds.xy;\n\n\t\t\tvec2 uv = vUv.xy;\n\t\t\tuv.y = 1.0 - uv.y;\n\n\t\t\tvec2 blurCoords = (uv - blurCenter) / blurSize;\n\n\t\t\t#if USE_MASKMAP\n\t\t\t\tblurCoords = abs(blurCoords);\n\n\t\t\t\tvec2 newUv = (uv - bounds.xy) / blurSize;\n\t\t\t\tnewUv.y = 1. - newUv.y;\n\n\t\t\t\tfloat blend = texture2D(maskMap, newUv).r;\n\t\t\t\tblend *= step(blurCoords.x, 0.5) * step(blurCoords.y, 0.5);\n\t\t\t#else\n\t\t\t\tvec2 filletRadius = vec2(0.);\n\n\t\t\t\tif (blurCoords.x > 0. && blurCoords.y < 0.) {\n\t\t\t\t\tfilletRadius.x = filletXRadius[1];\n\t\t\t\t\tfilletRadius.y = filletYRadius[1];\n\t\t\t\t} else if (blurCoords.x < 0. && blurCoords.y < 0.) {\n\t\t\t\t\tfilletRadius.x = filletXRadius[0];\n\t\t\t\t\tfilletRadius.y = filletYRadius[0];\n\t\t\t\t} else if (blurCoords.x < 0. && blurCoords.y > 0.) {\n\t\t\t\t\tfilletRadius.x = filletXRadius[2];\n\t\t\t\t\tfilletRadius.y = filletYRadius[2];\n\t\t\t\t} else if (blurCoords.x > 0. && blurCoords.y > 0.) {\n\t\t\t\t\tfilletRadius.x = filletXRadius[3];\n\t\t\t\t\tfilletRadius.y = filletYRadius[3];\n\t\t\t\t}\n\n\t\t\t\tblurCoords = abs(blurCoords);\n\n\t\t\t\tvec2 coreRange = 0.5 - filletRadius;\n\n\t\t\t\tfloat rx = blurCoords.x - coreRange.x;\n\t\t\t\tfloat ry = blurCoords.y - coreRange.y;\n\n\t\t\t\tfloat blend = step(blurCoords.x, 0.5) * step(blurCoords.y, 0.5) \n\t\t\t\t\t* (\n\t\t\t\t\t\t1.0 - step(coreRange.x, blurCoords.x)\n\t\t\t\t\t\t* step(coreRange.y, blurCoords.y)\n\t\t\t\t\t\t* step(filletRadius.x * filletRadius.x * filletRadius.y * filletRadius.y, rx * rx * filletRadius.y * filletRadius.y + ry * ry * filletRadius.x * filletRadius.x)\n\t\t\t\t\t);\n\t\t\t#endif\n\n\t\t\tcolor.rgb = mix(color.rgb, color2, blend);\n\t\t\tgl_FragColor = color;\n\t\t}\n    "
};
Wo = {
  defines : {
    SAMPLERS : 9
  },
  uniforms : {
    tDiffuse : {
      value : null
    },
    resolution : {
      value : new THREE.Vector2(1 / 1024, 1 / 512)
    },
    direction : {
      value : new THREE.Vector2(1, 0)
    }
  },
  vertexShader : "\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n    ",
  fragmentShader : "\n        uniform sampler2D tDiffuse;\n        uniform vec2 resolution;\n        uniform vec2 direction;\n        varying vec2 vUv;\n\n        #if (SAMPLERS == 5) \n            vec4 blur(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n                vec4 color = vec4(0.0);\n                vec2 off1 = vec2(1.3333333333333333) * direction;\n                color += texture2D(image, uv) * 0.29411764705882354;\n                color += texture2D(image, uv + (off1 * resolution)) * 0.35294117647058826;\n                color += texture2D(image, uv - (off1 * resolution)) * 0.35294117647058826;\n                return color; \n            }\n        #endif\n        #if (SAMPLERS == 9)\n            vec4 blur(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n                vec4 color = vec4(0.0);\n                vec2 off1 = vec2(1.3846153846) * direction;\n                vec2 off2 = vec2(3.2307692308) * direction;\n                color += texture2D(image, uv) * 0.2270270270;\n                color += texture2D(image, uv + (off1 * resolution)) * 0.3162162162;\n                color += texture2D(image, uv - (off1 * resolution)) * 0.3162162162;\n                color += texture2D(image, uv + (off2 * resolution)) * 0.0702702703;\n                color += texture2D(image, uv - (off2 * resolution)) * 0.0702702703;\n                return color;\n            }\n        #endif\n        #if (SAMPLERS == 13)\n            vec4 blur(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n                vec4 color = vec4(0.0);\n                vec2 off1 = vec2(1.411764705882353) * direction;\n                vec2 off2 = vec2(3.2941176470588234) * direction;\n                vec2 off3 = vec2(5.176470588235294) * direction;\n                color += texture2D(image, uv) * 0.1964825501511404;\n                color += texture2D(image, uv + (off1 * resolution)) * 0.2969069646728344;\n                color += texture2D(image, uv - (off1 * resolution)) * 0.2969069646728344;\n                color += texture2D(image, uv + (off2 * resolution)) * 0.09447039785044732;\n                color += texture2D(image, uv - (off2 * resolution)) * 0.09447039785044732;\n                color += texture2D(image, uv + (off3 * resolution)) * 0.010381362401148057;\n                color += texture2D(image, uv - (off3 * resolution)) * 0.010381362401148057;\n                return color;\n            }\n        #endif\n\n        void main() {\n            gl_FragColor = blur(tDiffuse, vUv, resolution, direction);\n        }\n    "
};
Go = function(selector) {
  function t(value, name) {
    r(this, t);
    var e = s(this, selector.call(this));
    return e.tempRenderTarget = Cn(value, name), e.tempRenderTarget2 = Cn(value, name), e.tempRenderTarget3 = Cn(value, name), e.tempRenderTarget4 = Cn(value, name), e.blurPass = new tn(Wo), e.blendPass = new tn(Vo), e.blendPass.uniforms.blendTexture.value = e.tempRenderTarget.texture, e.blendWithMapPass = new tn(Vo), e.blendWithMapPass.material.defines.USE_MASKMAP = 1, e.blendWithMapPass.uniforms.blendTexture.value = e.tempRenderTarget.texture, e.bounds = [[0, 0, 1, 1]], e.radius = 5, e;
  }
  return o(t, selector), t.prototype.setSize = function(v, h) {
    this.tempRenderTarget.setSize(v, h);
    this.tempRenderTarget2.setSize(v, h);
    this.tempRenderTarget3.setSize(v, h);
    this.tempRenderTarget4.setSize(v, h);
  }, t.prototype.render = function(value, key, item, object, type) {
    var node = this;
    var width = this.tempRenderTarget3.width;
    var fullHeight = this.tempRenderTarget3.height;
    var step = 2 + 2 * Math.floor(this.radius / 2);
    var max = 0;
    for (; max < step; max++) {
      this.blurPass.uniforms.resolution.value.set(1 / width, 1 / fullHeight);
      var r = this.radius * (max + 1) / step;
      if (max % 2 == 0) {
        this.blurPass.uniforms.direction.value.set(r, 0);
        this.blurPass.render(value, this.tempRenderTarget2, 0 === max ? item : this.tempRenderTarget);
      } else {
        this.blurPass.uniforms.direction.value.set(0, r);
        this.blurPass.render(value, this.tempRenderTarget, this.tempRenderTarget2);
      }
    }
    var i = item;
    var p = this.tempRenderTarget3;
    var k = void 0;
    this.bounds.forEach(function(data, type) {
      var item;
      var scope = void 0;
      var a = Object.prototype.toString.call(data[4]);
      if ("[object String]" == a) {
        (scope = node.blendWithMapPass).uniforms.filletXRadius.value.set(0, 0, 0, 0);
        scope.uniforms.filletYRadius.value.set(0, 0, 0, 0);
        scope.uniforms.maskMap.value = (item = data[4], Sn.has(item) || Sn.set(item, (new THREE.TextureLoader).load(item)), Sn.get(item));
      } else {
        if ("[object Number]" == a) {
          (scope = node.blendPass).uniforms.filletXRadius.value.set(data[4], data[6], data[8], data[10]);
          scope.uniforms.filletYRadius.value.set(data[5], data[7], data[9], data[11]);
          scope.uniforms.maskMap.value = null;
        } else {
          (scope = node.blendPass).uniforms.filletXRadius.value.set(0, 0, 0, 0);
          scope.uniforms.filletYRadius.value.set(0, 0, 0, 0);
          scope.uniforms.maskMap.value = null;
        }
      }
      scope.uniforms.bounds.value.fromArray(data);
      scope.render(value, type === node.bounds.length - 1 ? key : p, i);
      k = i;
      i = p;
      p = 0 === type ? node.tempRenderTarget4 : k;
    });
  }, t.prototype.dispose = function() {
    this.tempRenderTarget.dispose();
    this.tempRenderTarget2.dispose();
    this.tempRenderTarget3.dispose();
    this.tempRenderTarget4.dispose();
  }, t;
}(Oo);
_bufferShareManager = function() {
  function o() {
    r(this, o);
    this._defaultSharedMRB = null;
    this._defaultSharedRB = null;
    this._inputColorTexture = null;
    this._inputDepthTexture = null;
    this._inputColorRenderbuffer = null;
    this._inputDepthRenderbuffer = null;
    this._inited = false;
  }
  return o.prototype.begin = function(context) {
    if (!this._inited) {
      this._defaultSharedMRB = context.createRenderbuffer();
      this._defaultSharedRB = context.createRenderbuffer();
      this._inited = true;
    }
  }, o.prototype.setupSceneBuffer = function(canCreateDiscussions) {
    if (this._inputDepthTexture) {
      canCreateDiscussions.setDepthTexture(this._inputDepthTexture);
    } else {
      if (this._inputColorRenderbuffer && this._inputDepthRenderbuffer) {
        canCreateDiscussions.setColorDepthRenderBuffer(this._inputColorRenderbuffer, this._inputDepthRenderbuffer);
      } else {
        canCreateDiscussions.setDepthRenderBuffer(this._defaultSharedMRB, this._defaultSharedRB);
      }
    }
  }, o.prototype.setupPasses = function(wrappersTemplates) {
    var axis = this;
    var i = false;
    return wrappersTemplates.forEach(function(ifCondition) {
      if (ifCondition.isActive()) {
        if (axis._inputDepthTexture) {
          ifCondition._schemeBuffer.shareDepthTexture(axis._inputDepthTexture);
        } else {
          if (axis._inputColorRenderbuffer && axis._inputDepthRenderbuffer) {
            if (ifCondition._schemeBuffer.shareDepthRenderBuffer(axis._inputDepthRenderbuffer, axis._defaultSharedRB)) {
              i = true;
            }
          } else {
            if (ifCondition._schemeBuffer.__shareDepthRenderBuffer) {
              if (ifCondition._schemeBuffer.shareDepthRenderBuffer(axis._defaultSharedMRB, axis._defaultSharedRB)) {
                i = true;
              }
            } else {
              if (ifCondition._schemeBuffer.clearDepthShare()) {
                i = true;
              }
            }
          }
        }
      }
    }), i;
  }, o.prototype.clearInputs = function() {
    this._inputColorTexture = null;
    this._inputDepthTexture = null;
    this._inputColorRenderbuffer = null;
    this._inputDepthRenderbuffer = null;
  }, o.prototype.setInputTextures = function(e, exceptionLevel) {
    this._inputColorTexture = e;
    this._inputDepthTexture = exceptionLevel;
    this._inputColorRenderbuffer = null;
    this._inputDepthRenderbuffer = null;
  }, o.prototype.setInputRenderbuffers = function(e, exceptionLevel) {
    this._inputColorTexture = null;
    this._inputDepthTexture = null;
    this._inputColorRenderbuffer = e;
    this._inputDepthRenderbuffer = exceptionLevel;
  }, o.prototype.getInputColorTexture = function() {
    return this._inputColorTexture;
  }, o.prototype.supportMSAA = function() {
    return !this._inputDepthTexture && (!!this._inputDepthRenderbuffer || null);
  }, o.prototype.needSwap = function() {
    return this._inputColorTexture || this._inputDepthTexture || this._inputColorRenderbuffer || this._inputDepthRenderbuffer;
  }, o.prototype.needClear = function() {
    return !(this._inputColorRenderbuffer && this._inputDepthRenderbuffer || this._inputColorTexture);
  }, o.prototype.dispose = function() {
  }, o;
}();
Xo = function() {
  function e(value, size) {
    var device = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    r(this, e);
    var init = void 0 !== device.stencil && device.stencil;
    var s = void 0 !== device.maxSamplers ? device.maxSamplers : 8;
    this._tempRenderTarget1 = Cn(value, size);
    this._tempRenderTarget2 = Cn(value, size);
    this._sceneBuffer = new dn(value, size, init, s);
    this._superSampler = new Ao(value, size, 30);
    this._gBuffer = new yn(value, size);
    this._bufferShareManager = new _bufferShareManager;
    this._ssaoPrePass = new Rn(value, size);
    this._ssaoKernalSize = 12;
    this._ssrPrePass = new kn(value, size);
    this._copyPass = new tn(Yr);
    this._copyPass.material.depthWrite = false;
    this._copyPass.clearAlpha = 0;
    this._colorEffect = new Bo(new tn(Gr));
    this._dofEffect = new Bo(new tn(qr, "tColor"));
    this._dofEffect._pass.uniforms.tDepth.value = this._gBuffer.getDepthTexture();
    this._vignetteEffect = new Ho(value, size);
    this._vignettingEffect = new Uo(value, size);
    this._blurEdgeEffect = new zo(value, size);
    this._bloomEffect = new Io(value, size);
    this._filmEffect = new Bo(new tn(Xr));
    this._chromaticAberrationEffect = new Bo(new tn(Jr));
    this._fxaaEffect = new Bo(new tn(Qr), value, size);
    this._rectBlurEffect = new Go(value, size);
    this._effects = new Map([["colorCorrection", this._colorEffect], ["dof", this._dofEffect], ["vignette", this._vignetteEffect], ["vignetting", this._vignettingEffect], ["blurEdge", this._blurEdgeEffect], ["bloom", this._bloomEffect], ["film", this._filmEffect], ["chromaticAberration", this._chromaticAberrationEffect], ["FXAA", this._fxaaEffect], ["blur", this._rectBlurEffect]]);
    this._effectList1 = ["colorCorrection", "dof", "vignette", "vignetting", "blurEdge", "bloom"];
    this._effectList2 = ["chromaticAberration", "FXAA", "blur", "film"];
    this._glowPass = new Zn(value, size, "glow", s);
    this._middleGlowPass = new Zn(value, size, "middleGlow", s);
    this._smallGlowPass = new Zn(value, size, "smallGlow", s);
    this._combineGlowPass = new Zn(value, size, ["glow", "middleGlow", "smallGlow"], s);
    this._combineGlowPass.$enable = false;
    this._lineBloomPass = new to(value, size, s);
    this._innerGlowPass = new co(value, size, s);
    this._radialBlurPass = new ho(value, size, s);
    this._radialBlur2Pass = new fo(value, size, s);
    this._radialOffsetPass = new go(value, size, s);
    this._focusRegionPass = new wo(value, size, s);
    this._overLayPasses = new Map([["Glow", this._glowPass], ["MiddleGlow", this._middleGlowPass], ["SmallGlow", this._smallGlowPass], ["CombineGlow", this._combineGlowPass], ["LineBloom", this._lineBloomPass], ["InnerGlow", this._innerGlowPass], ["RadialBlur", this._radialBlurPass], ["RadialBlur2", this._radialBlur2Pass], ["RadialOffset", this._radialOffsetPass], ["FocusRegion", this._focusRegionPass]]);
    this._outlinePasses = new Map;
    this._config = Tn({}, ko);
    this.setConfig({});
    this.width = value;
    this.height = size;
    this.supportTransparent = false;
    this.schemeAutoMSAA = true;
    this.autoClearDepthStencil = true;
    this._needPreSetupRenderTarget = true;
    this.onlyAO = false;
    this.onlySSR = false;
    this.enableOutlines = true;
    this.enableOverlays = true;
  }
  return e.prototype.setConfig = function(value) {
    this._config = Tn(this._config, value);
    this._superSampler.setSamplingSize(this._config.temporalSuperSampling.size);
    var params = void 0;
    params = this._config.postEffect.bloom;
    this._bloomEffect.strength = params.strength;
    this._bloomEffect.radius = params.radius;
    this._bloomEffect.threshold = params.threshold;
    params = this._config.postEffect.screenSpaceAmbientOcclusion;
    this._ssaoPrePass.setParameter("radius", params.radius);
    this._ssaoPrePass.setParameter("bias", params.radius / 50);
    this._ssaoPrePass.setParameter("intensity", params.intensity);
    this._ssaoKernalSize = {
      low : 6,
      medium : 12,
      high : 32,
      ultra : 64
    }[params.quality] || 12;
    this._ssaoPrePass.setKernelSize(this._ssaoKernalSize);
    params = this._config.postEffect.screenSpaceReflection;
    this._ssrPrePass._ssrPass.uniforms.maxRayDistance.value = params.maxRayDistance;
    this._ssrPrePass._ssrPass.uniforms.pixelStride.value = params.pixelStride;
    this._ssrPrePass._ssrPass.uniforms.pixelStrideZCutoff.value = params.pixelStrideZCutoff;
    this._ssrPrePass._ssrPass.uniforms.screenEdgeFadeStart.value = params.screenEdgeFadeStart;
    this._ssrPrePass._ssrPass.uniforms.eyeFadeStart.value = params.eyeFadeStart;
    this._ssrPrePass._ssrPass.uniforms.eyeFadeEnd.value = params.eyeFadeEnd;
    this._ssrPrePass._ssrPass.uniforms.minGlossiness.value = params.minGlossiness;
    params = this._config.postEffect.colorCorrection;
    this._colorEffect._pass.uniforms.exposure.value = params.exposure;
    this._colorEffect._pass.uniforms.brightness.value = params.brightness;
    this._colorEffect._pass.uniforms.contrast.value = params.contrast;
    this._colorEffect._pass.uniforms.saturation.value = params.saturation;
    this._colorEffect._pass.uniforms.gamma.value = params.gamma;
    params = this._config.postEffect.dof;
    this._dofEffect._pass.uniforms.focalDepth.value = params.focalDepth;
    this._dofEffect._pass.uniforms.focalLength.value = params.focalLength;
    this._dofEffect._pass.uniforms.fstop.value = params.fstop;
    this._dofEffect._pass.uniforms.maxblur.value = params.maxblur;
    this._dofEffect._pass.uniforms.threshold.value = params.threshold;
    this._dofEffect._pass.uniforms.gain.value = params.gain;
    this._dofEffect._pass.uniforms.bias.value = params.bias;
    this._dofEffect._pass.uniforms.dithering.value = params.dithering;
    params = this._config.postEffect.vignette;
    this._vignetteEffect.type = params.type;
    if (Array.isArray(params.color)) {
      this._vignetteEffect.color.fromArray(params.color);
    } else {
      this._vignetteEffect.color.setHex(params.color);
    }
    this._vignetteEffect.offset = params.offset;
    if (params = this._config.postEffect.vignetting) {
      if (Array.isArray(params.color)) {
        this._vignettingEffect.color.fromArray(params.color);
      } else {
        this._vignettingEffect.color.setHex(params.color);
      }
      this._vignettingEffect.offset = params.offset;
    }
    if (params = this._config.postEffect.blurEdge) {
      this._blurEdgeEffect.offset = params.offset;
    }
    params = this._config.postEffect.film;
    this._filmEffect._pass.uniforms.grayscale.value = params.grayscale;
    this._filmEffect._pass.uniforms.nIntensity.value = params.noiseIntensity;
    this._filmEffect._pass.uniforms.sIntensity.value = params.scanlinesIntensity;
    this._filmEffect._pass.uniforms.sCount.value = params.scanlinesCount;
    params = this._config.postEffect.chromaticAberration;
    this._chromaticAberrationEffect._pass.uniforms.uChromaFactor.value = params.chromaFactor;
    params = this._config.postEffect.blur;
    this._rectBlurEffect.bounds = params.bounds;
    this._rectBlurEffect.radius = params.radius;
    this.dirty();
  }, e.prototype.enable = function(id) {
    if (id.indexOf("outline") > -1) {
      var t = id.split("_");
      var val = t[1];
      if (id = t[0], this._outlinePasses.has(val)) {
        this._outlinePasses.get(val).enable = true;
      } else {
        var c = new Ro(this.width, this.height, val);
        c.enable = true;
        this._outlinePasses.set(val, c);
      }
    } else {
      id = wn(id);
      if (this._overLayPasses.has(id)) {
        this._overLayPasses.get(id).enable = true;
      }
      if (!("Glow" !== id && "MiddleGlow" !== id && "SmallGlow" !== id)) {
        this._overLayPasses.get("CombineGlow").enable = this._overLayPasses.get("Glow").enable || this._overLayPasses.get("MiddleGlow").enable || this._overLayPasses.get("SmallGlow").enable;
      }
    }
  }, e.prototype.disable = function(id) {
    if (id.indexOf("outline") > -1) {
      var tuple = id.split("_");
      var value = tuple[1];
      if (id = tuple[0], this._outlinePasses.has(value)) {
        this._outlinePasses.get(value).enable = false;
      }
    } else {
      id = wn(id);
      if (this._overLayPasses.has(id)) {
        this._overLayPasses.get(id).enable = false;
      }
      if (!("Glow" !== id && "MiddleGlow" !== id && "SmallGlow" !== id)) {
        this._overLayPasses.get("CombineGlow").enable = this._overLayPasses.get("Glow").enable || this._overLayPasses.get("MiddleGlow").enable || this._overLayPasses.get("SmallGlow").enable;
      }
    }
  }, e.prototype.getPass = function(name) {
    return name = wn(name), this._overLayPasses.has(name) ? this._overLayPasses.get(name) : null;
  }, e.prototype.clearInputs = function() {
    this._bufferShareManager.clearInputs();
    this.dirty();
  }, e.prototype.setInputTextures = function(e, exceptionLevel) {
    this._bufferShareManager.setInputTextures(e, exceptionLevel);
    this.dirty();
  }, e.prototype.setInputRenderbuffers = function(e, exceptionLevel) {
    this._bufferShareManager.setInputRenderbuffers(e, exceptionLevel);
    this.dirty();
  }, e.prototype.shareDepthRenderBuffer = function(publicGist, name) {
    if (name) {
      var pass = this.getPass(name);
      if (pass) {
        if (publicGist) {
          pass._schemeBuffer.__shareDepthRenderBuffer = true;
        } else {
          delete pass._schemeBuffer.__shareDepthRenderBuffer;
        }
      } else {
        console.warn("AdvancedRenderer: shareDepthRenderBuffer pass <" + name + "> can not find.");
      }
    } else {
      this._overLayPasses.forEach(function(canCreateDiscussions) {
        if (publicGist) {
          canCreateDiscussions._schemeBuffer.__shareDepthRenderBuffer = true;
        } else {
          delete canCreateDiscussions._schemeBuffer.__shareDepthRenderBuffer;
        }
      });
    }
    this.dirty();
  }, e.prototype.setSize = function(data, value) {
    this._sceneBuffer.setSize(data, value);
    this._tempRenderTarget1.setSize(data, value);
    this._tempRenderTarget2.setSize(data, value);
    this._gBuffer.setSize(data, value);
    this._superSampler.setSize(data, value);
    this._ssaoPrePass.setSize(data, value);
    this._ssrPrePass.setSize(data, value);
    this._effects.forEach(function(adaptor) {
      return adaptor.setSize(data, value);
    });
    this._overLayPasses.forEach(function(adaptor) {
      return adaptor.setSize(data, value);
    });
    this._outlinePasses.forEach(function(adaptor) {
      return adaptor.setSize(data, value);
    });
    this.width = data;
    this.height = value;
    this._needPreSetupRenderTarget = true;
    this.dirty();
  }, e.prototype.render = function(data, e, value, view) {
    var that = this;
    var enable = this._config.temporalSuperSampling.enable;
    var reverseValue = this._config.postEffect.enable;
    var reverseIsSingle = data.capabilities.isWebGL2;
    if (reverseValue || enable || this._bufferShareManager.needSwap()) {
      var svg = this._bufferShareManager.supportMSAA();
      if (null === svg) {
        svg = reverseIsSingle && reverseValue && this._config.postEffect.MSAA.enable;
      }
      var target = void 0;
      var result = void 0;
      if (enable && this._superSampler.finished()) {
        target = this._superSampler.output();
      } else {
        if (enable) {
          this._superSampler.jitterProjection(value, this.width, this.height);
        }
        this._bufferShareManager.begin(data.getContext());
        this._bufferShareManager.setupSceneBuffer(this._sceneBuffer);
        var h = this._bufferShareManager.setupPasses(this._overLayPasses);
        if (this._needPreSetupRenderTarget || h) {
          this._overLayPasses.forEach(function(ifCondition, i) {
            if (ifCondition.isActive() && 2 === ifCondition._schemeBuffer.depthShareType) {
              ifCondition._schemeBuffer.setupRenderTarget(data);
            }
          });
          this._needPreSetupRenderTarget = false;
        }
        this._sceneBuffer.useMRT = svg;
        result = this._sceneBuffer.getSchemeBuffer();
        var _startingFret = this._bufferShareManager.getInputColorTexture();
        if (_startingFret) {
          this._copyPass.uniforms[this._copyPass.textureID].value = _startingFret;
          this._copyPass.clear = true;
          this._copyPass.clearDepthStencil = this.autoClearDepthStencil;
          this._copyPass.material.transparent = false;
          this._copyPass.render(data, result);
          this._copyPass.clearDepthStencil = true;
        }
        this._sceneBuffer.render(data, e, value, this._bufferShareManager.needClear());
        if (reverseValue) {
          if (this._config.postEffect.screenSpaceAmbientOcclusion.enable || this._config.postEffect.screenSpaceReflection.enable || this._config.postEffect.dof.enable) {
            this._gBuffer.render(data, e, value, this._config.postEffect.screenSpaceAmbientOcclusion.ignoreTransparent);
          }
          if (this._config.postEffect.screenSpaceAmbientOcclusion.enable) {
            if (enable && this._config.postEffect.screenSpaceAmbientOcclusion.temporalFilter) {
              this._ssaoPrePass.setKernelSize(this._ssaoKernalSize, this._superSampler.frame());
            }
            this._ssaoPrePass.render(this._gBuffer.getNormalGlossinessTexture(), this._gBuffer.getDepthTexture(), data, value, result, this.onlyAO);
          }
          if (this._config.postEffect.screenSpaceReflection.enable) {
            if (enable && this._config.postEffect.screenSpaceReflection.temporalFilter) {
              this._ssrPrePass.jitter = !!this._superSampler.frame();
              this._ssrPrePass._blurPass.material.uniforms.blurSize.value = 1 + this._superSampler.frame() / this._superSampler.getSamplingSize();
            } else {
              this._ssrPrePass.jitter = false;
              this._ssrPrePass._blurPass.material.uniforms.blurSize.value = 2;
            }
            this._ssrPrePass.render(result.texture, this._gBuffer.getNormalGlossinessTexture(), this._gBuffer.getDepthTexture(), data, value, result, this.onlySSR);
          }
        }
        if (enable) {
          target = this._superSampler.sample(data, result.texture);
          value.clearViewOffset();
        } else {
          target = result;
        }
      }
      this._copyPass.clear = true;
      this._copyPass.material.transparent = false;
      this._copyPass.render(data, this._tempRenderTarget2, target);
      var callback = this._tempRenderTarget2;
      var f = this._tempRenderTarget1;
      var init = function(key) {
        if (that._config.postEffect[key].enable) {
          var node = that._effects.get(key);
          if ("dof" == key && (node._pass.uniforms.znear.value = value.near, node._pass.uniforms.zfar.value = value.far), node.render(data, f, callback, .01667), node.needSwapBuffer) {
            var cb = callback;
            callback = f;
            f = cb;
          }
        }
      };
      this._effectList1.forEach(init);
      if (this.enableOverlays) {
        this._overLayPasses.forEach(function(scope) {
          if (scope.isActive()) {
            scope.render(data, e, value, callback, svg);
          }
        });
      }
      if (this.enableOutlines) {
        this._outlinePasses.forEach(function(scope) {
          if (scope.isActive()) {
            scope.render(data, e, value, callback, svg);
          }
        });
      }
      this._effectList2.forEach(init);
      this._copyPass.clear = data.autoClear;
      this._copyPass.material.transparent = this.supportTransparent;
      this._copyPass.render(data, view || void 0, callback);
    } else {
      data.setRenderTarget(view || null);
      data.render(e, value);
      var svg = this.schemeAutoMSAA && reverseIsSingle;
      if (this.enableOverlays) {
        this._overLayPasses.forEach(function(scope) {
          if (scope.isActive()) {
            scope._schemeBuffer.clearDepthShare();
            scope.render(data, e, value, void 0, svg);
          }
        });
      }
      if (this.enableOutlines) {
        this._outlinePasses.forEach(function(scope) {
          if (scope.isActive()) {
            scope.render(data, e, value, void 0, svg);
          }
        });
      }
    }
  }, e.prototype.dirty = function(key) {
    if (this._config.temporalSuperSampling.enable) {
      this._superSampler.start();
    }
    if (key) {
      if ("Outline" === (key = wn(key))) {
        this._outlinePasses.forEach(function(p) {
          return p.dirty();
        });
      } else {
        if (this._overLayPasses.has(key)) {
          this._overLayPasses.get(key).dirty();
        }
      }
    } else {
      this._overLayPasses.forEach(function(p) {
        return p.dirty();
      });
      this._outlinePasses.forEach(function(p) {
        return p.dirty();
      });
    }
  }, e.prototype.dispose = function() {
    this._tempRenderTarget1.dispose();
    this._tempRenderTarget2.dispose();
    this._sceneBuffer.dispose();
    this._superSampler.dispose();
    this._gBuffer.dispose();
    this._bufferShareManager.dispose();
    this._ssaoPrePass.dispose();
    this._ssrPrePass.dispose();
    this._copyPass.material.dispose();
    this._overLayPasses.forEach(function(backdropRef) {
      return backdropRef.dispose();
    });
    this._outlinePasses.forEach(function(backdropRef) {
      return backdropRef.dispose();
    });
    this._effects.forEach(function(backdropRef) {
      return backdropRef.dispose();
    });
  }, e.prototype.getActiveOverlayPasses = function() {
    return this.enableOverlays ? Array.from(this._overLayPasses.values()).filter(function(ifCondition) {
      return ifCondition.isActive();
    }) : [];
  }, e.prototype.getOutlinePasses = function() {
    return this._outlinePasses;
  }, e.prototype.disableAllOverlayPasses = function() {
    this._overLayPasses.forEach(function(oExtension) {
      return oExtension.$enable = false;
    });
  }, n(e, [{
    key : "combineGlow",
    set : function(v) {
      this._overLayPasses.get("CombineGlow").$enable = v;
      this._overLayPasses.get("Glow").$enable = !v;
      this._overLayPasses.get("MiddleGlow").$enable = !v;
      this._overLayPasses.get("SmallGlow").$enable = !v;
    },
    get : function() {
      return this._overLayPasses.get("CombineGlow").$enable;
    }
  }]), e;
}();
Jo = new THREE.Vector3, Yo = new THREE.Vector3, Qo = {
  vertexShader : "\n        #include <skinning_pars_vertex>\n        void main() {\n            #include <skinbase_vertex>\n            #include <begin_vertex>\n            #include <skinning_vertex>\n            #include <project_vertex>\n        }\n    ",
  fragmentShader : "\n        void main() {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }\n    "
};
Zo = new THREE.ShaderMaterial(Qo);
Ko = new THREE.ShaderMaterial(Qo);
Ko.skinning = true;
var $o = new THREE.Color;
var es = function() {
  function init(size, height) {
    r(this, init);
    this.camera = new THREE.OrthographicCamera;
    var parameters = {
      minFilter : THREE.LinearFilter,
      magFilter : THREE.LinearFilter,
      format : THREE.RGBAFormat
    };
    this.tempRenderTarget = new THREE.WebGLRenderTarget(size, height, parameters);
    this.radius = .1;
    this.renderTargetsHorizontal = [];
    this.renderTargetsVertical = [];
    this.nMips = 5;
    var width = Math.round(size / 2);
    var resy = Math.round(height / 2);
    var fleetNum = 0;
    for (; fleetNum < this.nMips; fleetNum++) {
      var renderTarget = new THREE.WebGLRenderTarget(width, resy, parameters);
      renderTarget.texture.name = "AOBaker.h" + fleetNum;
      renderTarget.texture.generateMipmaps = false;
      this.renderTargetsHorizontal.push(renderTarget);
      var canvas = new THREE.WebGLRenderTarget(width, resy, parameters);
      canvas.texture.name = "AOBaker.v" + fleetNum;
      canvas.texture.generateMipmaps = false;
      this.renderTargetsVertical.push(canvas);
      width = Math.round(width / 2);
      resy = Math.round(resy / 2);
    }
    this.separableBlurMaterials = [];
    var kernelSizeArray = [3, 5, 7, 9, 11];
    width = Math.round(size / 2);
    resy = Math.round(height / 2);
    var i = 0;
    for (; i < this.nMips; i++) {
      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));
      this.separableBlurMaterials[i].uniforms.texSize.value = new THREE.Vector2(width, resy);
      width = Math.round(width / 2);
      resy = Math.round(resy / 2);
    }
    this.compositeMaterial = this.getCompositeMaterial(this.nMips);
    this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture;
    this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture;
    this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture;
    this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture;
    this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture;
    this.compositeMaterial.uniforms.bloomRadius.value = .1;
    this.compositeMaterial.needsUpdate = true;
    this.compositeMaterial.uniforms.bloomFactors.value = [.5, .7, .8, .9, 1];
    this._camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    this.scene = new THREE.Scene;
    this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
    this.quad.frustumCulled = false;
    this.scene.add(this.quad);
  }
  return init.prototype.bake = function(renderer, opts, data, mode) {
    if (data) {
      this.fit(data, mode);
    }
    if (!renderer.materialManager.hasStrategy("AOBaker")) {
      renderer.materialManager.addStrategy("AOBaker", function(canCreateDiscussions, isSlidingUp, i, dontForceConstraints, material, forceExecution) {
        return this.userData.ground ? null : material.skinning ? Ko : Zo;
      });
    }
    var autoClear = renderer.autoClear;
    renderer.autoClear = false;
    $o.copy(renderer.getClearColor());
    var oldClearAlpha = renderer.getClearAlpha();
    renderer.setClearColor(new THREE.Color(1, 1, 1), 1);
    renderer.materialManager.setMode("AOBaker");
    var value = opts.autoUpdate;
    var background = opts.background;
    var enable = renderer.shadowMap.enable;
    opts.autoUpdate = false;
    opts.background = null;
    renderer.shadowMap.enable = false;
    renderer.setRenderTarget(this.tempRenderTarget);
    renderer.clear();
    renderer.render(opts, this.camera);
    opts.autoUpdate = value;
    opts.background = background;
    renderer.shadowMap.enable = enable;
    renderer.materialManager.setMode(0);
    var inputRenderTarget = this.tempRenderTarget;
    var i = 0;
    for (; i < this.nMips; i++) {
      this.quad.material = this.separableBlurMaterials[i];
      this.separableBlurMaterials[i].uniforms.colorTexture.value = inputRenderTarget.texture;
      this.separableBlurMaterials[i].uniforms.direction.value = new THREE.Vector2(1, 0);
      renderer.setRenderTarget(this.renderTargetsHorizontal[i]);
      renderer.clear();
      renderer.render(this.scene, this._camera);
      this.separableBlurMaterials[i].uniforms.colorTexture.value = this.renderTargetsHorizontal[i].texture;
      this.separableBlurMaterials[i].uniforms.direction.value = new THREE.Vector2(0, 1);
      renderer.setRenderTarget(this.renderTargetsVertical[i]);
      renderer.clear();
      renderer.render(this.scene, this._camera);
      inputRenderTarget = this.renderTargetsVertical[i];
    }
    this.quad.material = this.compositeMaterial;
    this.compositeMaterial.uniforms.bloomRadius.value = 1 - this.radius;
    renderer.setRenderTarget(this.tempRenderTarget);
    renderer.clear();
    renderer.render(this.scene, this._camera);
    renderer.setClearColor($o, oldClearAlpha);
    renderer.autoClear = autoClear;
  }, init.prototype.fit = function(view, event) {
    var d = view.getCenter(Jo);
    var self = view.getSize(Yo);
    this.camera.position.set(d.x, d.y + self.y, d.z);
    this.camera.rotation.set(-Math.PI / 2, 0, 0);
    this.camera.matrixAutoUpdate = false;
    this.camera.updateMatrix();
    this.camera.matrix.premultiply(event);
    this.camera.near = self.y / 3;
    this.camera.far = 2 * self.y;
    this.camera.left = -self.x / 2 + .075;
    this.camera.right = self.x / 2 - .075;
    this.camera.top = self.z / 2 - .075;
    this.camera.bottom = -self.z / 2 + .075;
    this.camera.updateProjectionMatrix();
    self.x = 1024;
    self.z = 1024;
    this.tempRenderTarget.setSize(self.x, self.z);
    var x = Math.round(self.x / 2);
    var y = Math.round(self.z / 2);
    var i = 0;
    for (; i < this.nMips; i++) {
      this.renderTargetsHorizontal[i].setSize(x, y);
      this.renderTargetsVertical[i].setSize(x, y);
      this.separableBlurMaterials[i].uniforms.texSize.value = new THREE.Vector2(x, y);
      x = Math.round(x / 2);
      y = Math.round(y / 2);
    }
  }, init.prototype.dispose = function() {
    this.tempRenderTarget.dispose();
    var i = 0;
    for (; i < this.renderTargetsHorizontal.length; i++) {
      this.renderTargetsHorizontal[i].dispose();
    }
    var index = 0;
    for (; index < this.renderTargetsVertical.length; index++) {
      this.renderTargetsVertical[index].dispose();
    }
  }, init.prototype.getSeperableBlurMaterial = function(kernelRadius) {
    return new THREE.ShaderMaterial({
      defines : {
        KERNEL_RADIUS : kernelRadius,
        SIGMA : kernelRadius
      },
      uniforms : {
        colorTexture : {
          value : null
        },
        texSize : {
          value : new THREE.Vector2(.5, .5)
        },
        direction : {
          value : new THREE.Vector2(.5, .5)
        }
      },
      vertexShader : "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
      fragmentShader : "#include <common>\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\t\t\t\tuniform vec2 direction;\t\t\t\t\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\t\t\t\t}\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\t\t\t\t\tfloat fSigma = float(SIGMA);\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\t\t\t\t\t\tfloat x = float(i);\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\t\t\t\t\t\tweightSum += 2.0 * w;\t\t\t\t\t}\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}"
    });
  }, init.prototype.getCompositeMaterial = function(nMips) {
    return new THREE.ShaderMaterial({
      defines : {
        NUM_MIPS : nMips
      },
      uniforms : {
        blurTexture1 : {
          value : null
        },
        blurTexture2 : {
          value : null
        },
        blurTexture3 : {
          value : null
        },
        blurTexture4 : {
          value : null
        },
        blurTexture5 : {
          value : null
        },
        bloomFactors : {
          value : null
        },
        bloomRadius : {
          value : 0
        }
      },
      vertexShader : "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
      fragmentShader : "\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\t\n\t\t\t\tfloat lerpBloomFactor(const in float factor) { \n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvoid main() {\n\t\t\t\t\tfloat factor0 = lerpBloomFactor(bloomFactors[0]);\n\t\t\t\t\tfloat factor1 = lerpBloomFactor(bloomFactors[1]);\n\t\t\t\t\tfloat factor2 = lerpBloomFactor(bloomFactors[2]);\n\t\t\t\t\tfloat factor3 = lerpBloomFactor(bloomFactors[3]);\n\t\t\t\t\tfloat factor4 = lerpBloomFactor(bloomFactors[4]);\n\t\t\t\t\tgl_FragColor = (factor0 * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\t\t\t\t\tfactor1 * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\t\t\t\t\tfactor2 * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\t\t\t\t\tfactor3 * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\t\t\t\t\tfactor4 * texture2D(blurTexture5, vUv)) / (factor0 + factor1 + factor2 + factor3 + factor4);\n\t\t\t\t}\t\n\t\t\t"
    });
  }, n(init, [{
    key : "ao",
    get : function() {
      return this.tempRenderTarget.texture;
    }
  }]), init;
}();
ts = function(callback) {
  function d(row) {
    return r(this, d), s(this, callback.call(this, row));
  }
  return o(d, callback), d.prototype.setupTextureAnimations = function() {
    if (nr.hasTextureAnimation(this.node)) {
      this.addControl(new nr, "texAnimControl");
    }
  }, d.prototype.setupUserData = function(obj) {
    callback.prototype.setupUserData.call(this, obj);
    this.node.userData.isCombinedObject = true;
  }, d.prototype.setupResources = function(prevProps) {
    if (callback.prototype.setupResources.call(this, prevProps), this.loaded) {
      var element = this;
      for (; element && element.isCombinedObject;) {
        element = element.parent;
      }
      var value = element.style._inheritThemeName;
      if (value && element.loaded) {
        element.applyTheme(value, false, true);
      }
    }
  }, d.prototype._notifyLoadingObjects = function() {
  }, d.prototype.loadResource = function() {
    callback.prototype.loadResource.call(this, true);
  }, d.prototype.unloadResource = function() {
    callback.prototype.unloadResource.call(this, true);
  }, d.prototype.isChildOfType = function(expectedType) {
    var types = expectedType.split("|");
    var parent = this._parent;
    for (; parent; parent = parent._parent) {
      var i = 0;
      for (; i < types.length; i++) {
        if (parent["is" + types[i]]) {
          return true;
        }
      }
    }
    return false;
  }, n(d, [{
    key : "isCombinedObject",
    get : function() {
      return true;
    }
  }]), d;
}(BaseObject);
is = function(t) {
  function e(row) {
    r(this, e);
    var that = s(this, t.call(this, row));
    return that._height = 3, that._initBoxSize = null, that.miscObject = null, that.wallObject = null, that.roofObject = null, that.ceilingObject = null, that._marker = null, that._navigation = null, that._groundAOBaker = null, that._baked = false, that._showObjectsInParentLevels = false, that;
  }
  return o(e, t), e.prototype.isBlockMouseOffEvent = function(item) {
    return !!this.isChildOf(item);
  }, e.prototype.destroy = function() {
    if (this._groundAOBaker) {
      this.plan.node.traverse(function(options) {
        var material = options.material;
        if (material) {
          material.aoMap = null;
          material.needsUpdate = true;
        }
      });
      this._groundAOBaker.dispose();
      this._groundAOBaker = null;
    }
    t.prototype.destroy.call(this);
  }, e.prototype.synTransform = function(e) {
    this.setupUserData(e);
    if (!this.parent) {
      this.setupParent(e);
    }
    e.skipSetupParent = true;
    this.setupTranslation(e);
  }, e.prototype.setupFromURL = function(options) {
    var url = this.app.confirmURL(options.url);
    this._url = url;
    this._setup(options);
  }, e.prototype.customSetup = function(val) {
    this._height = val.height || this._height;
    this._initBoxSize = val.initBoxSize;
    this._showObjectsInParentLevels = Utils.parseValue(val.alwaysShowInsideObjs, this._showObjectsInParentLevels);
  }, e.prototype.loadResource = function() {
    var bubbled_sets__3355 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    if (t.prototype.loadResource.call(this, bubbled_sets__3355), !bubbled_sets__3355) {
      var pipelets = [this.roof, this.wall, this.plan, this.ceiling];
      pipelets.forEach(function(srUtils) {
        if (srUtils) {
          srUtils.loadResource();
        }
      });
      this.doors.forEach(function(srUtils) {
        srUtils.loadResource();
      });
      this.things.forEach(function(utils) {
        if (utils.isWindow) {
          utils.loadResource();
        }
      });
      var partial_tree = this.misc;
      if (partial_tree) {
        partial_tree.traverse(function(s) {
          if (s.node.isDoorOrWin) {
            s.loadResource();
          }
        });
      }
      this.rooms.forEach(function(srUtils) {
        srUtils.loadResource(false);
      });
    }
  }, e.prototype.unloadResource = function() {
    var bubbled_sets__3355 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    if (bubbled_sets__3355) {
      t.prototype.unloadResource.call(this, bubbled_sets__3355);
    } else {
      t.prototype.unloadResource.call(this, false);
      var pipelets = [this.roof, this.wall, this.plan, this.ceiling];
      pipelets.forEach(function(resMgr) {
        if (resMgr) {
          resMgr.unloadResource();
        }
      });
      this.doors.forEach(function(resMgr) {
        resMgr.unloadResource();
      });
      this.things.forEach(function(exports) {
        if (exports.isWindow) {
          exports.unloadResource();
        }
      });
      var partial_tree = this.misc;
      if (partial_tree) {
        partial_tree.traverse(function(tblObject) {
          if (tblObject.node.isDoorOrWin) {
            tblObject.unloadResource();
          }
        });
      }
      this.rooms.forEach(function(resMgr) {
        resMgr.unloadResource(false);
      });
    }
  }, e.prototype.setupResources = function(prevProps) {
    t.prototype.setupResources.call(this, prevProps);
    this._ceilingNode = prevProps.ceilingNode || this._ceilingNode;
    this._roofNode = prevProps.roofNode || this._roofNode;
    this._floorNode = prevProps.floorNode || this._floorNode;
    if (this._ceilingNode) {
      this.ceiling.node = this._ceilingNode;
    }
    if (this._roofNode) {
      this.roof.node = this._roofNode;
    }
    if (this._floorNode) {
      this.plan.node = this._floorNode;
    }
  }, e.prototype._getChildVisibles = function() {
    var pipelets = this.children.concat([this.roof, this.ceiling, this.plan]);
    var props = [];
    return pipelets.forEach(function(settings) {
      if (settings) {
        props.push(settings.visible);
      }
    }), props;
  }, e.prototype._onGetChild = function() {
    return this.children.concat([this.roof, this.ceiling, this.plan]);
  }, e.prototype._getDoors = function(noticeKey) {
    var doors = [];
    var i = 0;
    for (; i < this.doors.length; i++) {
      var message = this.doors[i];
      if (message[noticeKey]) {
        doors.push(message);
      }
    }
    return doors;
  }, e.prototype._createMarker = function(options) {
    var t = (options = options || {}).connectorName || /connector/;
    var element = options.markerName || /marker/;
    var projectsArray = this.attachPoints.query(t);
    var indices = this.attachPoints.query(element);
    if (0 != projectsArray.length || 0 != indices.length) {
      var project = projectsArray[0];
      var last = indices[0];
      options.type = "Marker";
      options.parent = this;
      if (Utils.isNull(options.size)) {
        THING.Utils.error("floor's marker must provide size to show");
      } else {
        if (Utils.isNull(options.canvas) && Utils.isNull(options.url)) {
          THING.Utils.error("floor's marker must provide 'canvas' or 'url' to show");
        } else {
          if (last) {
            options.position = last.position;
          }
          if (project) {
            options.lineToPosition = project.position;
          } else {
            if (options.lineColor) {
              THING.Utils.error("Please make sure connector is avaliable for showing connection line of marker");
            }
          }
          this._marker = this.app.create(options);
        }
      }
    }
  }, e.prototype.setupChildVisibleAsParent = function(data, urlPartConfig) {
    if (!(this.visible || this._showObjectsInParentLevels)) {
      data.visible = false;
    }
  }, e.prototype.traverseRoofs = function(saveNotifs) {
    if (this.roof) {
      saveNotifs(this.roof);
    }
    var _g1 = this.rooms;
    var _g = 0;
    for (; _g < _g1.length; _g++) {
      var notifications = _g1[_g].roof;
      if (notifications) {
        saveNotifs(notifications);
      }
    }
  }, e.prototype.showAllRoofs = function() {
    var hold = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    if (this.roof) {
      this.roof.visible = hold;
    }
    var _g1 = this.rooms;
    var _g = 0;
    for (; _g < _g1.length; _g++) {
      var state = _g1[_g].roof;
      if (state) {
        state.visible = hold;
      }
    }
  }, e.prototype.showAllCeilings = function() {
    var data = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    var SonosStatus = this.ceiling;
    if (SonosStatus) {
      SonosStatus.visible = data;
    }
    var _g1 = this.rooms;
    var _g = 0;
    for (; _g < _g1.length; _g++) {
      _g1[_g].ceiling.visible = data;
    }
  }, e.prototype.showMarker = function(value) {
    if (!this._marker) {
      this._createMarker(value);
    }
    if (Utils.isBoolean(value)) {
      this._marker.visible = value;
    } else {
      this._marker.setParams(value);
    }
  }, e.prototype.getRoomFromLocalPosition = function(carat) {
    return this.getRoomFromWorldPosition(this.selfToWorld(carat));
  }, e.prototype.getRoomFromWorldPosition = function(e) {
    var _g1 = this.rooms;
    var _g = 0;
    for (; _g < _g1.length; _g++) {
      var room = _g1[_g];
      if (room.getRayCastPosition(e)) {
        return room;
      }
    }
    return null;
  }, e.prototype.bake = function(result) {
    var svgline = this.plan;
    if (svgline) {
      var gizmo = svgline.node.getMeshes();
      var j = 0;
      for (; j < gizmo.length; j++) {
        if (gizmo[j] instanceof THREE.Water) {
          return;
        }
      }
      if (group = this.wall) {
        var n = this;
        if (null === result) {
          if (!this._baked) {
            return;
          }
          var update = function(color) {
            if (!color.isShaderMaterial) {
              Utils.revertValue(color, "aoMap");
              Utils.revertValue(color, "aoMapIntensity");
              color.needsUpdate = true;
            }
          };
          svgline.node.traverseMaterials(update);
          this.rooms.forEach(function(t) {
            var p = t.plan;
            if (p) {
              p.node.traverseMaterials(update);
            }
          });
          this._baked = false;
        } else {
          var group;
          if (result = result || {}, !(group = this.wall)) {
            return;
          }
          var deletedHost = Utils.parseValue(result.intensity, 1.4);
          if (!this._groundAOBaker) {
            this._groundAOBaker = new es;
          }
          var scope = group.getLocalBoundingBox(true, true).toBox();
          if (this._initBoxSize) {
            scope.max.addVectors(scope.min, Utils.parseVector3(this._initBoxSize).addScalar(.15));
          }
          this._groundAOBaker.bake(this.app.renderer, group.node, scope, this.node.matrixWorld);
          var update = function(sync, json) {
            if (!json.isShaderMaterial) {
              Utils.backupValue(json, "aoMap");
              Utils.backupValue(json, "aoMapIntensity");
              json.aoMap = n._groundAOBaker.ao;
              json.aoMapIntensity = deletedHost;
              json.needsUpdate = true;
            }
          };
          svgline.style._cloneAndModifyMaterial(function(canCreateDiscussions, vdom, i) {
            update(0, vdom);
          }, true, function(self) {
            return !!self.isShaderMaterial || !self._mustClone && !(!self._isCloned() || !self._getOriginal());
          });
          this.rooms.forEach(function(t) {
            var p = t.plan;
            if (p) {
              p.style._cloneAndModifyMaterial(function(canCreateDiscussions, vdom, i) {
                update(0, vdom);
              });
            }
          });
          this._baked = true;
        }
      }
    }
  }, e.prototype.canNavigation = function() {
    return true;
  }, e.prototype._getLinkableObjects = function() {
    var rooms = this.rooms;
    return rooms = rooms.concat(t.prototype._getLinkableObjects.call(this));
  }, e.prototype._getLinkableDoors = function() {
    var _ref = this.elevatorDoors;
    return _ref = (_ref = _ref.concat(this.stairDoors)).concat(t.prototype._getLinkableDoors.call(this));
  }, e.prototype._setupNavigationGraph = function(obj, config) {
    var modules = this._getLinkableDoors();
    if (config) {
      obj[config.id] = obj[config.id] || {};
      var g = 0;
      for (; g < modules.length; g++) {
        var item = modules[g];
        obj[item.id] = obj[item.id] || {};
        var data = {
          startPosition : config.position,
          endPosition : item.position
        };
        if (!item._room) {
          var id = this._navigation.getRoomID(item.position);
          if (-1 !== id) {
            item._room = this._navigation._objects[id];
          }
        }
        data.startRoom = config.room;
        data.endRoom = item._room;
        var myDoughnutChart = this.getFindingPathLength(data);
        if (-1 != myDoughnutChart) {
          obj[config.id][item.id] = obj[item.id][config.id] = myDoughnutChart;
        }
      }
    } else {
      if (!this._doorCache) {
        this._doorCache = {};
        var i = 0;
        var li = modules.length;
        for (; i < li; i++) {
          var parser = modules[i];
          var j = 0;
          var li = modules.length;
          for (; j < li; j++) {
            if (i !== j) {
              var config = modules[j];
              if (!config) {
                break;
              }
              this._doorCache[parser.id] = this._doorCache[parser.id] || {};
              this._doorCache[config.id] = this._doorCache[config.id] || {};
              var data = {
                startPosition : config.position,
                endPosition : parser.position
              };
              var myDoughnutChart = this.getFindingPathLength(data);
              if (-1 != myDoughnutChart) {
                this._doorCache[config.id][parser.id] = this._doorCache[parser.id][config.id] = myDoughnutChart;
              }
            }
          }
        }
      }
      var level;
      for (level in this._doorCache) {
        var gi = this._doorCache[level];
        var i;
        for (i in gi) {
          obj[level] = obj[level] || {};
          obj[level][i] = this._doorCache[level][i];
        }
      }
    }
    var g = 0;
    for (; g < modules.length; g++) {
      var item = modules[g];
      var p = item.owner;
      if (p) {
        obj[item.id] = obj[item.id] || {};
        obj[p.id] = obj[p.id] || {};
        obj[p.id][item.id] = obj[item.id][p.id] = 1;
      }
    }
  }, e.prototype.onBeforeCapture = function() {
    var uniformParameter = this.plan;
    if (uniformParameter) {
      var update = function(element) {
        var material = element.material;
        if (material) {
          Utils.backupValue(material, "aoMap");
          material.aoMap = null;
          material.needsUpdate = true;
        }
      };
      uniformParameter.node.traverseAll(function(initialState) {
        update(initialState);
      });
      this.rooms.forEach(function(t) {
        var p = t.plan;
        if (p) {
          p.node.traverseAll(function(initialState) {
            update(initialState);
          });
        }
      });
    }
  }, e.prototype.onAfterCapture = function() {
    var uniformParameter = this.plan;
    if (uniformParameter) {
      var update = function(data) {
        var m = data.material;
        if (m) {
          Utils.revertValue(m, "aoMap");
          m.needsUpdate = true;
        }
      };
      uniformParameter.node.traverseAll(function(configData) {
        update(configData);
      });
      this.rooms.forEach(function(t) {
        var p = t.plan;
        if (p) {
          p.node.traverseAll(function(configData) {
            update(configData);
          });
        }
      });
    }
  }, e.prototype.showThings = function() {
    var showBoneHandles = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    THING.Utils.warn("[Floor] Please use '.things.visible=true/false' to replace '.showThings'");
    this.things.visible = showBoneHandles;
  }, e.prototype.showDoors = function() {
    var showBoneHandles = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    THING.Utils.warn("[Floor] Please use '.things.visible=true/false' to replace '.showThings'");
    this.doors.visible = showBoneHandles;
  }, e.prototype.hideMarker = function() {
    THING.Utils.warn("[Floor] Please use '.showMarker(false)' to replace '.hideMarker'");
    this.showMarker(false);
  }, e.prototype.setMarker = function(value) {
    THING.Utils.warn("[Floor] Please use '.showMarker(params)' to replace '.setMarker'");
    this.showMarker(value);
  }, e.prototype.showRoof = function() {
    var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    THING.Utils.warn("[Floor] Please use '.showAllRoofs()' to replace '.showRoof()'");
    this.showAllRoofs(e);
  }, e.prototype.showCeiling = function() {
    var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    THING.Utils.warn("[Floor] Please use '.showAllCeilings()' to replace '.showCeiling()'");
    this.showAllCeilings(e);
  }, n(e, [{
    key : "isFloor",
    get : function() {
      return true;
    }
  }, {
    key : "isOutdoors",
    get : function() {
      var parent = this._parent;
      for (; parent; parent = parent._parent) {
        if (parent.isBuilding && !parent.hasFacades()) {
          return true;
        }
      }
      return false;
    }
  }, {
    key : "building",
    get : function() {
      return this.parents.query(".Building")[0];
    }
  }, {
    key : "indexOfBuilding",
    get : function() {
      return this.indexOfParent(true);
    }
  }, {
    key : "levelNumber",
    get : function() {
      return this.indexOfParent(true) + 1;
    }
  }, {
    key : "things",
    get : function() {
      return this.query(".Thing", false);
    }
  }, {
    key : "doors",
    get : function() {
      return this.query(".Door", false);
    }
  }, {
    key : "elevatorDoors",
    get : function() {
      return this.doors.query(".ElevatorDoor", false);
    }
  }, {
    key : "stairDoors",
    get : function() {
      return this.doors.query(".StairDoor", false);
    }
  }, {
    key : "stairs",
    get : function() {
      return this.query(".Stair", false);
    }
  }, {
    key : "rooms",
    get : function() {
      return this.query(".Room", false);
    }
  }, {
    key : "misc",
    get : function() {
      return this.miscObject || (this.miscObject = this.query(".CombinedObject").query("[userData/type=CombineMiscParent]")[0]), this.miscObject;
    }
  }, {
    key : "plan",
    get : function() {
      return this.floorObject || (this.floorObject = this.query(".CombinedObject").query("[userData/type=CombineFloorParent]")[0]), this.floorObject;
    }
  }, {
    key : "wall",
    get : function() {
      return this.wallObject || (this.wallObject = this.query(".CombinedObject").query("[userData/type=CombineWallParent]")[0]), this.wallObject;
    }
  }, {
    key : "roof",
    get : function() {
      return this.roofObject || (this.roofObject = this.query(".CombinedObject").query("[userData/type=CombineRoofParent]")[0]), this.roofObject;
    }
  }, {
    key : "ceiling",
    get : function() {
      return this.ceilingObject || (this.ceilingObject = this.query(".CombinedObject").query("[userData/type=CombineCeilingParent]")[0]), this.ceilingObject;
    }
  }, {
    key : "marker",
    get : function() {
      return this._marker;
    }
  }, {
    key : "height",
    get : function() {
      return this._height;
    }
  }, {
    key : "showObjectsInParentLevels",
    get : function() {
      return this._showObjectsInParentLevels;
    }
  }, {
    key : "isFloorPlan",
    get : function() {
      return THING.Utils.warn("[Floor] Please use '.isFloor' to replace '.isFloorPlan'"), true;
    }
  }, {
    key : "levelNum",
    get : function() {
      return THING.Utils.warn("[Floor] Please use '.levelNumber' to replace '.levelNum'"), this.levelNumber;
    }
  }]), e;
}(BaseObject);
rs = function(t) {
  function d(row) {
    r(this, d);
    var container = s(this, t.call(this, row));
    return container.name = "Outdoors", container._floorNode = null, container;
  }
  return o(d, t), d.prototype.destroy = function() {
    this._floorNode = null;
    t.prototype.destroy.call(this);
  }, d.prototype.setupChildVisibleAsParent = function() {
  }, d.prototype.setup = function(data) {
    this.setupID(data);
    this.setupParent(data);
    this.parent.outdoors = this;
    this.setupUserData(data);
  }, d.prototype.setPolygonOffset = function(state) {
    var name = this._floorNode;
    if (name) {
      (new BaseObject(this.app))._init(name).style.setPolygonOffset(state);
    }
  }, n(d, [{
    key : "floorNode",
    set : function(v) {
      this._floorNode = v;
    },
    get : function() {
      return this._floorNode;
    }
  }, {
    key : "canNotQueryFromSelector",
    get : function() {
      return true;
    }
  }, {
    key : "isOutdoors",
    get : function() {
      return true;
    }
  }]), d;
}(is);
ns = function() {
  function self(value) {
    r(this, self);
    this.app = value;
    this._style = null;
    this._id = "";
    this._name = "";
    this._queryID = THING.Math.generateUUID();
    this._userData = {};
    this._angles = [0, 0, 0];
    this._events = {};
    this._tags = [];
    this._groups = [];
    this._children = new xi(this.app);
  }
  return self.prototype.isGroup = function() {
    return true;
  }, self.prototype.setup = function(data) {
    this._id = data.id || "";
    this._name = data.name || "";
    this._tags = data.tags || [];
  }, self.prototype.destroy = function() {
    this.app.objectManager.destroy(this);
    var instance = this;
    this._children.forEach(function(t) {
      var i = t.groups.indexOf(instance);
      var type;
      for (type in-1 !== i && t.groups.splice(i, 1), instance._events) {
        var col = instance._events[type];
        var p;
        for (p in col) {
          t.off(p);
        }
      }
    });
  }, self.prototype.destroyAll = function() {
    this.destroy();
    this._children.destroyAll();
  }, self.prototype.hasAttribute = function(name) {
    return Utils.hasAttribute(this, name);
  }, self.prototype.getAttribute = function(name) {
    return Utils.getAttribute(this, name);
  }, self.prototype.setAttribute = function(name, value) {
    return Utils.setAttribute(this, name, value);
  }, self.prototype.setAttributes = function(options) {
    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    var name;
    for (name in options = options || {}) {
      if (t || Utils.isUndefined(this[name])) {
        this.setAttribute(name, options[name]);
      }
    }
  }, self.prototype.add = function(cmd) {
    var t = this;
    if (cmd instanceof xi) {
      cmd.forEach(function(e) {
        t.add(e);
      });
    } else {
      var type;
      for (type in this._children.add(cmd), -1 === cmd.groups.indexOf(this) && cmd.groups.push(this), this._children.forEach(function(groupsData) {
        groupsData.groups.sort(function(enumDef, t) {
          return t.children.length - enumDef.children.length;
        });
      }), this._events) {
        var obj = this._events[type];
        var propertyName;
        for (propertyName in obj) {
          var node = obj[propertyName];
          this.on(type, node.selector, node.userData, node.callback, null, node.priority);
        }
      }
    }
  }, self.prototype.remove = function(obj) {
    var AniJSDefaultHelper = this;
    if (obj instanceof xi) {
      obj.forEach(function(e) {
        AniJSDefaultHelper.remove(e);
      });
    } else {
      this._children.remove(obj);
      var object = obj.groups.indexOf(this);
      var type;
      for (type in-1 !== object && obj.groups.splice(object, 1), this._events) {
        var chain = this._events[type];
        var name;
        for (name in chain) {
          var entry = chain[name];
          this.off(type, entry.selector, entry.tag);
        }
      }
    }
  }, self.prototype._transform = function(cb) {
    var obj = new THREE.Group;
    obj.position.copy(Utils.parseVector3(this.position));
    this.app.scene.add(obj);
    obj.updateMatrixWorld();
    var graphs = [];
    var i = 0;
    for (; i < this._children.length; i++) {
      var child = this._children[i];
      graphs.push(child.node.parent);
      child.node.attachToParent(obj, this.app.scene);
    }
    cb(obj);
    obj.updateWorldMatrix(false, false);
    i = 0;
    for (; i < this._children.length; i++) {
      (child = this._children[i]).node.attachToParent(graphs[i], this.app.scene);
      if (child.static) {
        child.node._synMatrixWorld();
      }
    }
    this.app.scene.remove(obj);
  }, self.prototype.translate = function(size) {
    this._transform(function(Transform) {
      Transform.translateX(size[0]);
      Transform.translateY(size[1]);
      Transform.translateZ(size[2]);
    });
  }, self.prototype.translateX = function(distance) {
    this.translate([distance, 0, 0]);
  }, self.prototype.translateY = function(n) {
    this.translate([0, n, 0]);
  }, self.prototype.translateZ = function(distance) {
    this.translate([0, 0, distance]);
  }, self.prototype.query = function(data) {
    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    var gs = new xi(this.app, this._children);
    return gs.select(data), t && this._children.forEach(function(t) {
      gs.add(t.query(data));
    }), gs;
  }, self.prototype._parseEvent = function(e, name, event, type, key) {
    var message = Utils.parseEvent(e, name, event, type, key);
    message._callback = message.callback;
    var placeMidpointLine = this;
    return message.callback = function(type) {
      if (message._callback) {
        message._callback.call(placeMidpointLine, type);
      }
    }, message.tag = message.tag || "", message.tag += "_" + this._queryID, message;
  }, self.prototype._updateEvents = function(event) {
    this._events[event.eventType] = this._events[event.eventType] || [];
    this._events[event.eventType][event.tag] = event;
  }, self.prototype._removeEvents = function(e) {
    var obj = this._events[e.eventType];
    if (obj) {
      delete obj[e.tag];
    }
  }, self.prototype.on = function(name, e, value, args, params, data) {
    var result = this._parseEvent(e, value, args, params, data);
    return result.eventType = name, this._updateEvents(result), this.children.on(name, result.selector, result.userData, result.callback, result.tag, result.priority), this;
  }, self.prototype.off = function(name, e, target) {
    var data = this._parseEvent(e, null, target);
    return data.eventType = name, this._removeEvents(data), this.children.off(name, data.selector, data.tag), this;
  }, self.prototype.one = function(name, e, type, c, x, y) {
    var self = this._parseEvent(e, type, c, x, y);
    return self.eventType = name, this._updateEvents(self), this.children.one(name, self.selector, self.userData, self.callback, self.tag, self.priority), this;
  }, self.prototype._getAvgVector3 = function(i) {
    if (!this._children.length) {
      return [0, 0, 0];
    }
    var c = new THREE.Vector3;
    return this._children.forEach(function(pointerComponents) {
      var r = Utils.parseVector3(pointerComponents[i]);
      c.add(r);
    }), c.divideScalar(this._children.length), c.toArray();
  }, n(self, [{
    key : "type",
    get : function() {
      return "Group";
    }
  }, {
    key : "style",
    get : function() {
      return this._children.style;
    }
  }, {
    key : "id",
    set : function(v) {
      this._id = v;
    },
    get : function() {
      return this._id;
    }
  }, {
    key : "name",
    set : function(v) {
      this._name = v;
    },
    get : function() {
      return this._name;
    }
  }, {
    key : "queryID",
    set : function(v) {
      this._queryID = v;
    },
    get : function() {
      return this._queryID;
    }
  }, {
    key : "userData",
    set : function(v) {
      this._userData = v;
    },
    get : function() {
      return this._userData;
    }
  }, {
    key : "tags",
    set : function(v) {
      this._tags = v;
    },
    get : function() {
      return this._tags;
    }
  }, {
    key : "groups",
    get : function() {
      return this._groups;
    }
  }, {
    key : "position",
    set : function(v) {
      var t = Utils.parseVector3(v);
      var compound = this;
      this._transform(function(dialog) {
        dialog._setWorldPosition(t, compound.app.root.static);
      });
    },
    get : function() {
      return this._getAvgVector3("position");
    }
  }, {
    key : "angles",
    set : function(value) {
      var t = THING.Math.subVector(this._angles, value);
      this._angles = value;
      var e = Utils.parseEuler(t);
      this._transform(function(child) {
        child.quaternion.setFromEuler(e);
      });
    },
    get : function() {
      return this._angles;
    }
  }, {
    key : "parents",
    get : function() {
      var queue = new THING.Selector(this.app, []);
      return this._children.forEach(function(event) {
        queue.add(event.parents);
      }), queue;
    }
  }, {
    key : "children",
    get : function() {
      return this._children;
    }
  }, {
    key : "visible",
    set : function(value) {
      this.children.visible = value;
    }
  }, {
    key : "pickable",
    set : function(value) {
      this.children.pickable = value;
    }
  }, {
    key : "boundingBox",
    get : function() {
      var self = new THREE.Box3;
      var i = 0;
      for (; i < this.children.length; i++) {
        var element = this.children[i];
        self.union(element.box);
      }
      var extent = new THREE.Vector3;
      self.getCenter(extent);
      var parent = new THREE.Vector3;
      self.getSize(parent);
      var touchSystem = this;
      return {
        min : self.min.toArray(),
        max : self.max.toArray(),
        center : extent.toArray(),
        size : parent.toArray(),
        radius : parent.length(),
        getWorldPosition : function(item) {
          var val = Utils.parseValue(item.yAngle, 0);
          var w = Utils.parseValue(item.xAngle, 0);
          var r = Utils.parseValue(item.distance || item.radius, parent.length());
          var value = item.radiusFactor;
          if (value) {
            r = parent.length() * value;
          }
          var e = (new THREE.Vector3).getDirectionFromAngles(val, w, r);
          return touchSystem.selfToWorld(e);
        }
      };
    }
  }]), self;
}();
os = function() {
  function init(value, me) {
    r(this, init);
    this.app = value;
    this.nodes = [];
    this.scene = this.app.scene;
    this.outdoors = this.app.outdoors;
    this.objectPool = this.app.objectPool;
    this.worldNode = new THREE.Object3D;
    this.campus = null;
    this.baseURL = null;
    this.curLoadGLTFIndex = 0;
    this.splitLoadedGLTFCount = 0;
    this.allLoadedGLTFCount = 0;
    this.sliceRootNodeArray = [];
    this.sceneJsonData = null;
    this.states = null;
    this.loadSpeed = .1;
    this.isCamFitScene = true;
    if (me) {
      if (me.position) {
        this.campusPosition = me.position;
      }
      if (me.rotation) {
        this.campusRotation = me.rotation;
      }
      if (void 0 !== me.isCamFitScene && null !== me.isCamFitScene) {
        this.isCamFitScene = me.isCamFitScene;
      }
      if (void 0 !== me.isDelayLoadFloorPlan && null !== me.isDelayLoadFloorPlan) {
        this.isDelayLoadFloorPlan = me.isDelayLoadFloorPlan;
      }
      if (me.campus) {
        this.campus = me.campus;
      }
    }
  }
  return init.prototype.load = function(src) {
    var selectors = this;
    return this.baseURL = src, this.scene.add(this.worldNode), new Promise(function($, saveNotifs) {
      selectors.loadSceneJson().then(function(i) {
        selectors.parseObjects().then(function() {
          $(selectors.campus);
        });
      }).then(function() {
        $(selectors.campus);
      }).catch(function(notifications) {
        saveNotifs(notifications);
      });
    });
  }, init.prototype.loadSceneJson = function() {
    var req = this;
    return new Promise(function(receiveFunc, saveNotifs) {
      (new THREE.FileLoader(req.app.loadingManager)).load(req.baseURL + "/scene.json", function(i) {
        var connector = JSON.parse(i);
        req.sceneJsonData = connector;
        receiveFunc(connector);
      }, function(canCreateDiscussions) {
      }, function(canCreateDiscussions) {
        saveNotifs("cant not load file: scene.json");
      });
    });
  }, init.prototype.parseObjects = function() {
    var e = this.sceneJsonData;
    var t = this;
    return new Promise(function(saveNotifs, obtainGETData) {
      t.parse(e).then(function() {
        t.sliceRootNodeArray = [];
        saveNotifs();
      }).catch(function(val) {
        obtainGETData(val);
      });
    });
  }, init.prototype.parse = function(e) {
    var touchSystem = this;
    return new Promise(function(parseIdHeader, canCreateDiscussions) {
      touchSystem.parseWorld(e);
      parseIdHeader();
    });
  }, init.prototype.parseWorld = function(options) {
    var attr = this.worldNode;
    if (null == this.campus && (this.campus = this.app.objectManager.create({
      type : "Campus",
      name : "Campus",
      node : attr
    }), this.app.scene.add(this.campus.node)), this.campusRotation && this.campus.node.quaternion.set(this.campusRotation.x, this.campusRotation.y, this.campusRotation.z, this.campusRotation.w), this.campusPosition && (this.campus.position = this.campusPosition), options.outdoors && this.parseOutdoors(options.outdoors, attr), options.buildings) {
      var data = options.buildings;
      var id;
      for (id in data) {
        var response = data[id];
        var globalBonePosition = new THREE.Vector3(0, 0, 0);
        var message = id;
        var pattid = void 0;
        if (response.name) {
          message = response.name;
        }
        if (response.id) {
          pattid = response.id;
        }
        var slideDragNode = new THREE.Object3D;
        var options = this.app.objectManager.create({
          type : "Building",
          name : message,
          id : pattid,
          parent : this.campus,
          node : slideDragNode
        });
        if (options.app = this.app, options.node.position.x = globalBonePosition.x, options.node.position.y = globalBonePosition.y, options.node.position.z = globalBonePosition.z, response.plans && this.parseFloorPlans(response.plans, options), response.facades) {
          var entity = response.facades;
          var p;
          for (p in entity) {
            this.createThing(entity[p], options, "Facade");
          }
        }
        if (response.facadegroups) {
          var ref = response.facadegroups;
          var name;
          for (name in ref) {
            response = ref[name];
            this.createGroup(response, options, "Facade");
          }
        }
        if (response.groups) {
          ref = response.groups;
          for (name in ref) {
            response = ref[name];
            this.createGroup(response, options);
          }
        }
      }
    }
  }, init.prototype.parseOutdoors = function(testItemData) {
    var slideDragNode = new THREE.Object3D;
    this.outdoors = this.app.objectManager.create({
      type : "Outdoors",
      name : "Outdoors",
      parent : this.campus,
      node : slideDragNode
    });
    if (!this.app.outdoors) {
      this.app.outdoors = this.outdoors;
      this.app.currentParentObject = this.outdoors;
    }
    this.processFloorPlanData(testItemData, this.outdoors);
  }, init.prototype.processFloorPlanData = function(data, value) {
    value.app = this.app;
    if (data.placements) {
      this.parseThings(data.placements, value);
    }
    if (data.videoprobes) {
      this.parseThings(data.videoprobes, value);
    }
    if (data.groups) {
      this.parseGroups(data.groups, value);
    }
    if (data.doororwindows) {
      this.parseDoorWins(data.doororwindows, value);
    }
    if (data.rooms) {
      this.parseRooms(data.rooms, value);
    }
  }, init.prototype.parseRooms = function(el, t) {
    var i = 0;
    for (; i < el.length; i++) {
      var data = el[i];
      var value = null;
      if (data.name) {
        value = data.name;
      }
      var slideDragNode = new THREE.Object3D("room_temp");
      var arrayValueHash = null;
      var localContext = data.properties;
      if (localContext) {
        var graphVariable;
        for (graphVariable in arrayValueHash = {}, localContext) {
          var originalVarValue = localContext[graphVariable];
          arrayValueHash[graphVariable] = originalVarValue;
        }
      }
      var offset = null;
      var area = null;
      var index = null;
      var self = {};
      if (data.area && (area = data.area, self.area = area), data.circumference && (index = data.circumference, self.circumference = index), data.center) {
        var p2 = data.center;
        (offset = new THREE.Vector3).set(p2[0], p2[1], -p2[2]);
        self.center = offset;
      }
      this.app.objectManager.create({
        type : "Room",
        name : value,
        node : slideDragNode,
        id : undefined,
        parent : t,
        properties : arrayValueHash,
        auxiliaryInfo : self
      });
    }
  }, init.prototype.parseDoorWins = function(attributes, value) {
    new THREE.Group("doors");
    var name;
    for (name in attributes) {
      var info = attributes[name];
      var username = name;
      var index = void 0;
      if (info.name) {
        username = info.name;
      }
      if (info.id) {
        index = info.id;
      }
      var slideDragNode = new THREE.Object3D("doororwin_temp");
      var properties = null;
      if (info.properties) {
        var obj = info.properties;
        var key;
        for (key in properties = {}, obj) {
          var val = obj[key];
          properties[key] = val;
        }
      }
      this.app.objectManager.create({
        type : "Door",
        name : username,
        node : slideDragNode,
        id : index,
        parent : value,
        properties : properties
      });
    }
  }, init.prototype.parseGroups = function(data, t) {
    var a;
    for (a in data) {
      var context = data[a];
      if (context.name || context.properties) {
        this.createGroup(context, t);
      }
    }
  }, init.prototype.createGroup = function(obj, content) {
    var i;
    var group;
    var arrayValueHash;
    var GET_USER_PROFILE_SUCCESS = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "Thing";
    var slideDragNode = new THREE.Object3D("group_temp");
    if (obj.id) {
      i = obj.id;
    }
    if (obj.name) {
      group = obj.name;
    }
    var localContext = obj.properties;
    if (localContext) {
      var graphVariable;
      for (graphVariable in arrayValueHash = {}, localContext) {
        var originalVarValue = localContext[graphVariable];
        arrayValueHash[graphVariable] = originalVarValue;
      }
    }
    var elem = this.app.objectManager.create({
      type : GET_USER_PROFILE_SUCCESS,
      name : group,
      id : i,
      node : slideDragNode,
      parent : content,
      properties : arrayValueHash
    });
    return elem;
  }, init.prototype.parseFloorPlans = function(value, input) {
    var wikis = [];
    var k;
    for (k in value) {
      var f = value[k];
      var guid = f.id;
      var name = "";
      if (f.name) {
        name = f.name;
      }
      var fooNode = new THREE.Object3D;
      var page = this.app.objectManager.create({
        type : "Floor",
        name : name,
        id : guid,
        node : fooNode,
        parent : input
      });
      fooNode.name = "floorPlan";
      input.node.add(page.node);
      this.processFloorPlanData(f, page);
      wikis.push(page);
    }
    return wikis;
  }, init.prototype.parseThings = function(config, value, target) {
    var name;
    for (name in config) {
      var command = config[name];
      if (command.name || command.properties) {
        this.createThing(command, value, target);
      }
    }
  }, init.prototype.createThing = function(thing, path, position) {
    var model;
    var name;
    var states;
    var GET_USER_PROFILE_SUCCESS = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "Thing";
    if (thing.id) {
      model = thing.id;
    }
    if (thing.name) {
      name = thing.name;
    }
    var project = thing.properties;
    if (project) {
      var name;
      for (name in states = {}, project) {
        var resolvedValue = project[name];
        states[name] = resolvedValue;
      }
    }
    var slideDragNode = new THREE.Object3D("temp_cannotuse");
    var mesh = this.app.objectManager.create({
      type : GET_USER_PROFILE_SUCCESS,
      name : name,
      node : slideDragNode,
      id : model,
      parent : path,
      properties : states
    });
    return mesh;
  }, init;
}();
ss = function() {
  function init(app, options, config) {
    r(this, init);
    this.app = app;
    this.resourceUrl = null;
    this.relativeResourceUrl = null;
    this.sceneJson = null;
    this.scale = 1;
    this.curFloorPlan = null;
    this.tempTexture = null;
    this.indexJson = options;
    this.sceneJsonUri = "scene.json";
    this.defaultWallTextureUri = "Textures/RoomWall.jpg";
    this.defaultWallEdgeTextureUri = "Textures/WallEdge.jpg";
    this.defaultFloorTextureUri = "Textures/FloorDefault.jpg";
    this.defaultCeilingTextureUri = "Textures/CeilingDefault.jpg";
    this.defaultRoofTextureUri = "Textures/RoofDefault.jpg";
    this.defaultWallTexture = null;
    this.defaultCeilingTexture = null;
    this.defaultFloorTexture = null;
    this.defaultRoofTexture = null;
    this.defaultWallEdgeTexture = null;
    this.worldNode = new THREE.Object3D("world");
    this.isCamFitScene = true;
    this.campus = null;
    this.outdoorsVisible = true;
    this.campusVisible = true;
    this.enableUseHighestVersionResource = true;
    this.worldNode;
    if (options && (options.position && (this.campusPosition = options.position), options.rotation && (this.campusRotation = options.rotation), void 0 !== options.isCamFitScene && null !== options.isCamFitScene && (this.isCamFitScene = options.isCamFitScene), options.scale && (this.campusScale = options.scale), void 0 !== options.outdoorsVisible && (this.outdoorsVisible = options.outdoorsVisible), void 0 !== options.campusVisible && (this.campusVisible = options.campusVisible), options.campus && 
    (this.campus = options.campus), void 0 !== options.enableUseHighestVersionResource && (this.enableUseHighestVersionResource = options.enableUseHighestVersionResource, json2mesh.DefaultSetting.enableUseHighestVersionResource = this.enableUseHighestVersionResource)), this.campus && (this.campusRotation && this.campus.node.quaternion.set(this.campusRotation.x, this.campusRotation.y, this.campusRotation.z, this.campusRotation.w), this.campusPosition && (this.campus.position = this.campusPosition), 
    this.campusScale && (this.campus.scale = this.campusScale)), options && options.default) {
      var readOnlyFn = options.default;
      if (readOnlyFn.sceneJson) {
        this.sceneJson = "export.json";
      }
      if (readOnlyFn.wallTexture) {
        this.defaultWallTextureUri = readOnlyFn.wallTexture;
      }
      if (readOnlyFn.wallEdgeTexture) {
        this.defaultWallEdgeTextureUri = readOnlyFn.wallEdgeTexture;
      }
      if (readOnlyFn.floorTexture) {
        this.defaultFloorTextureUri = readOnlyFn.floorTexture;
      }
      if (readOnlyFn.ceilingTexture) {
        this.defaultCeilingTextureUri = readOnlyFn.ceilingTexture;
      }
      if (readOnlyFn.roofTexture) {
        this.defaultRoofTextureUri = readOnlyFn.roofTexture;
      }
    }
    if (config.loaderResourceUrl) {
      this.resourceUrl = config.loaderResourceUrl;
    }
    if (null != this.app.options.enableUseHighestVersionResource) {
      this.enableUseHighestVersionResource = this.app.options.enableUseHighestVersionResource;
      json2mesh.DefaultSetting.enableUseHighestVersionResource = this.enableUseHighestVersionResource;
    }
    if (this.app.options.resourceLibraryUrl) {
      this.resourceUrl = this.app.options.resourceLibraryUrl;
    }
    if (this.indexJson && this.indexJson.resourceLibrary) {
      this.relativeResourceUrl = this.indexJson.resourceLibrary;
    }
  }
  return init.prototype.parseCamInfo = function(data) {
    var t = data.eye;
    var i = data.target;
    var filem = t.split(" ");
    var cmd_s = i.split(" ");
    var songsHeaders = [Number(filem[0]), Number(filem[1]), Number(filem[2])];
    songsHeaders[2] = -songsHeaders[2];
    var delegatorRoot = [Number(cmd_s[0]), Number(cmd_s[1]), Number(cmd_s[2])];
    delegatorRoot[2] = -delegatorRoot[2];
    this.app.camera.position = songsHeaders;
    this.app.camera.target = delegatorRoot;
  }, init.prototype.exportJsonString = function(options) {
    var data = options.outdoors;
    var props = options.buildings;
    var leftPorts = [];
    var result = [];
    var i = 0;
    for (; i < data.things.length; i++) {
      var s = data.things[i];
      leftPorts.push({
        id : s.id,
        name : s.name
      });
    }
    i = 0;
    for (; i < data.rooms.length; i++) {
      var a = data.rooms[i];
      result.push({
        id : a.id,
        name : a.name
      });
    }
    var rightPorts = [];
    i = 0;
    for (; i < props.length; i++) {
      var out = props[i];
      var leftPorts = [];
      var a = 0;
      for (; a < out.floors.length; a++) {
        var data = out.floors[a];
        var rightPorts = [];
        var result = [];
        var i = 0;
        for (; i < data.things.length; i++) {
          var g = data.things[i];
          rightPorts.push({
            id : g.id,
            name : g.name
          });
        }
        i = 0;
        for (; i < data.rooms.length; i++) {
          a = data.rooms[i];
          result.push({
            id : a.id,
            name : a.name
          });
        }
        leftPorts.push({
          id : data.id,
          name : data.name,
          placements : rightPorts,
          rooms : result
        });
      }
      rightPorts.push({
        id : out.id,
        name : out.name,
        plans : leftPorts
      });
    }
    return {
      id : options.id,
      name : options.name,
      outdoors : {
        id : data.id,
        name : data.name,
        placements : leftPorts,
        rooms : result
      },
      buildings : rightPorts
    };
  }, init.prototype.load = function(node) {
    var self = this;
    if ("String" === node.constructor.name) {
      this.sceneURL = node;
    } else {
      if ("Object" === node.constructor.name) {
        var me = node;
        this.sceneURL = me.url;
        if (me.campus) {
          this.campus = me.campus;
          this.worldNode = this.campus.node;
        }
      }
    }
    return this.relativeResourceUrl && (this.resourceUrl = this.sceneURL + this.relativeResourceUrl), new Promise(function($, i) {
      self.updateProgress(.1);
      self.loadSceneJson().then(function(i) {
        self.sceneJson = JSON.parse(i);
        if (self.sceneJson.camInfo && self.isCamFitScene) {
          self.parseCamInfo(self.sceneJson.camInfo);
        }
        self.updateProgress(.15);
        var game = new json2mesh.UBuilderSceneSimpleLoader;
        if (self.resourceUrl) {
          game.resourceManager.baseTextureUrl = self.resourceUrl + "/texture/";
          game.resourceManager.baseModelUrl = self.resourceUrl + "/model/";
        }
        game.load({
          json : self.sceneJson,
          customModeBaseUrl : self.sceneURL + "/"
        }).then(function(undefined) {
          self.parseWorld(undefined);
          self.updateProgress(.2);
          self.updateProgress(1);
          $(self.campus);
        });
      });
    });
  }, init.prototype.loadSceneJson = function() {
    var pageViewData = this;
    return new Promise(function(saveNotifs, i) {
      (new THREE.FileLoader(pageViewData.app.loadingManager)).load(pageViewData.sceneURL.appendURL(pageViewData.sceneJsonUri), function(notifications) {
        saveNotifs(notifications);
      });
    });
  }, init.prototype.updateProgress = function(data) {
    this.app.mainUI.updateLoadingProcess({
      object : this.campus,
      progress : data
    });
  }, init.prototype.createTextureLoaderPromise = function(fontName) {
    var connectionUrlObject = this;
    return new Promise(function(saveNotifs, canCreateDiscussions) {
      (new THREE.TextureLoader).load(connectionUrlObject.sceneURL + "/" + fontName, function(notifications) {
        saveNotifs(notifications);
      }, function(event) {
        THING.Utils.log(fontName + " " + event.loaded / event.total * 100 + "% loaded");
      }, function(canCreateDiscussions) {
        THING.Utils.log(fontName + "load error");
      });
    });
  }, init.prototype.loadDefaultTexture = function() {
    var layerNeuron = this;
    return new Promise(function(saveNotifs, i) {
      var documentBodyPromise = layerNeuron.createTextureLoaderPromise(layerNeuron.defaultWallTextureUri);
      var storesPromise = layerNeuron.createTextureLoaderPromise(layerNeuron.defaultWallEdgeTextureUri);
      var usernameUnique = layerNeuron.createTextureLoaderPromise(layerNeuron.defaultFloorTextureUri);
      var priority = layerNeuron.createTextureLoaderPromise(layerNeuron.defaultRoofTextureUri);
      var status = layerNeuron.createTextureLoaderPromise(layerNeuron.defaultCeilingTextureUri);
      Promise.all([documentBodyPromise, storesPromise, usernameUnique, priority, status]).then(function(canCreateDiscussions) {
        DefaultResource.wallTexture = canCreateDiscussions[0];
        DefaultResource.wallEdgeTexture = canCreateDiscussions[1];
        DefaultResource.floorTexture = canCreateDiscussions[2];
        DefaultResource.ceilinngTexture = canCreateDiscussions[3];
        DefaultResource.roofTexture = canCreateDiscussions[4];
        saveNotifs();
      });
    });
  }, init.prototype.parseWorld = function(data) {
    if (null === this.campus) {
      this.campus = this.app.objectManager.create({
        uuid : data.id,
        id : data.userID,
        type : "Campus",
        name : "Campus",
        node : this.worldNode
      });
      this.campus.visible = this.campusVisible;
      if (this.campusRotation) {
        this.campus.node.quaternion.set(this.campusRotation.x, this.campusRotation.y, this.campusRotation.z, this.campusRotation.w);
      }
      if (this.campusPosition) {
        this.campus.position = this.campusPosition;
      }
      if (this.campusScale) {
        this.campus.scale = this.campusScale;
      }
    } else {
      this.campus.uuid = data.id;
      if (data.userID) {
        this.campus.id = data.userID;
      }
    }
    var i = 0;
    for (; i < data.buildings.length; i++) {
      var _image = data.buildings[i];
      this.parseBuilding(_image);
    }
    if (data.outdoors) {
      var self = new THREE.Object3D("outdoors");
      self.name = "plan";
      this.outdoors = this.app.objectManager.create({
        uuid : data.outdoors.id,
        id : data.outdoors.userID,
        type : "Outdoors",
        name : data.outdoors.name,
        parent : this.campus,
        node : self
      });
      this.outdoors.visible = this.outdoorsVisible;
      this.parseFloorPlan(data.outdoors, this.outdoors);
    }
  }, init.prototype.parseBuilding = function(self) {
    var fooNode = new THREE.Object3D("building");
    fooNode.name = "building";
    var node = this.app.objectManager.create({
      uuid : self.id,
      id : self.userID,
      type : "Building",
      name : self.name,
      parent : this.campus,
      node : fooNode,
      properties : self.properties
    });
    node.localPosition = self.position;
    var _$rapyd$_Iter0 = self.floorplans;
    var secTypes = self.facades;
    var o = self.facadeGroups;
    var s = 0;
    for (; s < secTypes.length; s++) {
      var value = secTypes[s];
      this.app.objectManager.create({
        type : "Facade",
        id : value.userID,
        name : value.name,
        uuid : value.id,
        node : value.delayObject,
        parent : node,
        properties : value.properties
      });
    }
    s = 0;
    for (; s < o.length; s++) {
      value = o[s];
      this.app.objectManager.create({
        type : "Facade",
        uuid : value.id,
        id : value.userID,
        name : value.name,
        node : value.delayObject,
        parent : node,
        properties : value.properties
      });
    }
    var _$rapyd$_Index0 = 0;
    for (; _$rapyd$_Index0 < _$rapyd$_Iter0.length; _$rapyd$_Index0++) {
      var json = _$rapyd$_Iter0[_$rapyd$_Index0];
      var self = new THREE.Object3D("floorplan");
      self.name = "plan";
      var options = this.app.objectManager.create({
        id : json.userID,
        uuid : json.id,
        type : "Floor",
        name : json.name,
        properties : json.properties,
        node : self,
        parent : node
      });
      options.localPosition = json.position;
      this.parseFloorPlan(json, options);
      if (0 !== node.facades.length) {
        options.visible = false;
      }
    }
  }, init.prototype.placementInitCallback = function(data) {
    this.app.objectManager.create({
      id : data.id,
      name : data.name,
      node : data.mesh,
      parent : plan,
      animations : data.resource.animations,
      properties : data.properties
    });
  }, init.prototype.parseOutdoors = function(canCreateDiscussions) {
  }, init.prototype.parseFloorPlan = function(self, options) {
    var i = 0;
    for (; i < self.walls.length; i++) {
      var r = self.walls[i];
      var j = 0;
      for (; j < r.doorOrWindows.length; j++) {
        var data = r.doorOrWindows[j];
        var value = "Door";
        if (data.jsonData && data.jsonData.type && (value = data.jsonData.type), data.mesh) {
          var $ = this.app.objectManager.create({
            type : "Door",
            uuid : data.id,
            id : data.userID,
            name : data.name,
            node : data.delayObject,
            parent : options,
            animations : data.resource.animations,
            properties : data.properties
          });
          if (data.isOpen && $.open(), $.animationClips) {
            j = 0;
            for (; j < $.animationClips.length; j++) {
              var sPoi = $.animationClips[j];
              if ("_defaultAnim_" === sPoi.name) {
                $.playAnimation({
                  name : sPoi.name,
                  loop : true,
                  speed : .15
                });
                break;
              }
            }
          }
        } else {
          data.initCompleteCallback = function(data) {
            if (data.jsonData && data.jsonData.type) {
              data.jsonData.type;
            }
            var self = pageViewData.app.objectManager.create({
              type : "Door",
              uuid : data.id,
              id : data.userID,
              name : data.name,
              node : data.mesh,
              parent : options,
              animations : data.resource.animations,
              properties : data.properties
            });
            if (options.miscNode.add(self.node), data.isOpen && self.open(), self.animationClips) {
              var n = 0;
              for (; n < self.animationClips.length; n++) {
                var parsedNode = self.animationClips[n];
                if ("_defaultAnim_" === parsedNode.name) {
                  self.playAnimation({
                    name : parsedNode.name,
                    loop : true,
                    speed : .15
                  });
                  break;
                }
              }
            }
          };
        }
      }
    }
    var u = new THREE.Object3D("combineFloor");
    i = 0;
    for (; i < self.combineFloors.length; i++) {
      var c = self.combineFloors[i];
      u.add(c);
    }
    options.node.add(u);
    options.floorNode = u;
    var p = new THREE.Object3D("combineCeiling");
    i = 0;
    for (; i < self.combineCeilings.length; i++) {
      var cmdQuery = self.combineCeilings[i];
      p.add(cmdQuery);
    }
    options.node.add(p);
    options.ceilingNode = p;
    var d = new THREE.Object3D("combineRoof");
    i = 0;
    for (; i < self.combineRoofs.length; i++) {
      var f = self.combineRoofs[i];
      d.add(f);
    }
    options.node.add(d);
    options.roofNode = d;
    var m = new THREE.Object3D("combinePlacement");
    i = 0;
    for (; i < self.combinePlacements.length; i++) {
      var data = self.combinePlacements[i];
      m.add(data);
    }
    options.node.add(m);
    options.miscNode = m;
    var v = new THREE.Object3D("combineWall");
    var l = 0;
    for (; l < self.combineStraightManualWalls.length; l++) {
      r = self.combineStraightManualWalls[l];
      v.add(r);
    }
    l = 0;
    for (; l < self.combineModelWalls.length; l++) {
      r = self.combineModelWalls[l];
      v.add(r);
    }
    l = 0;
    for (; l < self.combineDoorOrWins.length; l++) {
      data = self.combineDoorOrWins[l];
      v.add(data);
    }
    options.node.add(v);
    options.wallNode = v;
    i = 0;
    for (; i < self.groups.length; i++) {
      data = self.groups[i];
      value = "Thing";
      if (data.jsonData && data.jsonData.type) {
        value = data.jsonData.type;
      }
      $ = this.app.objectManager.create({
        uuid : data.id,
        id : data.userID,
        name : data.name,
        node : data.delayObject,
        belongRoomUserID : data.belongRoomUserID,
        type : value,
        parent : options,
        properties : data.properties
      });
    }
    var pageViewData = this;
    i = 0;
    for (; i < self.placements.length; i++) {
      data = self.placements[i];
      value = "Thing";
      if (data.jsonData && data.jsonData.type && (value = data.jsonData.type), data.mesh) {
        if (($ = this.app.objectManager.create({
          uuid : data.id,
          id : data.userID,
          name : data.name,
          type : value,
          belongRoomUserID : data.belongRoomUserID,
          node : data.delayObject,
          parent : options,
          url : data.resource.getModelUrl(),
          animations : data.resource.animations,
          properties : data.properties
        })).bundleID = data.resource.modelID, $.bundleName = data.resource.modelName, data.isPlayAnim && $.containAnimation(data.animClip)) {
          var params = {
            name : data.animClip,
            loop : false,
            speed : .15
          };
          if (data.hasSkin) {
            params.loop = true;
          }
          $.playAnimation(params);
        }
      } else {
        data.initCompleteCallback = function(self) {
          value = "Thing";
          if (self.jsonData && self.jsonData.type) {
            value = self.jsonData.type;
          }
          var o = pageViewData.app.objectManager.create({
            uuid : self.id,
            id : self.userID,
            belongRoomUserID : self.belongRoomUserID,
            name : self.name,
            node : self.mesh,
            parent : options,
            type : value,
            url : self.resource.getModelUrl(),
            animations : self.resource.animations,
            properties : self.properties
          });
          if (o.bundleID = self.resource.modelID, o.bundleName = self.resource.modelName, options.miscNode.add(o.node), self.isPlayAnim && o.containAnimation(self.animClip)) {
            var options = {
              name : self.animClip,
              loop : false,
              speed : .15
            };
            if (self.hasSkin) {
              options.loop = true;
            }
            o.playAnimation(options);
          }
        };
      }
    }
    i = 0;
    for (; i < self.videoprobes.length; i++) {
      if ((data = self.videoprobes[i]).mesh) {
        $ = this.app.objectManager.create({
          id : data.userID,
          name : data.name,
          uuid : data.id,
          belongRoomUserID : data.belongRoomUserID,
          node : data.delayObject,
          parent : options,
          url : data.resource.getModelUrl(),
          animations : data.resource.animations,
          properties : data.properties
        });
      } else {
        data.initCompleteCallback = function(data) {
          var uniformParameter = pageViewData.app.objectManager.create({
            id : data.userID,
            name : data.name,
            uuid : data.id,
            belongRoomUserID : data.belongRoomUserID,
            node : data.mesh,
            parent : options,
            url : data.resource.getModelUrl(),
            animations : data.resource.animations,
            properties : data.properties
          });
          options.miscNode.add(uniformParameter.node);
        };
      }
    }
    i = 0;
    for (; i < self.rooms.length; i++) {
      var data = self.rooms[i];
      c = this.app.objectManager.create({
        type : "Room",
        name : data.name,
        node : data.mesh,
        uuid : data.id,
        id : data.userID,
        ceilingNode : data.ceiling.mesh,
        roofNode : data.roof.mesh,
        floorNode : data.floor.mesh,
        parent : options,
        properties : data.properties
      });
    }
    i = 0;
    for (; i < self.curvelines.length; i++) {
      var page = self.curvelines[i];
      this.parseCurveLines(page, options);
    }
    i = 0;
    for (; i < self.pipelines.length; i++) {
      page = self.pipelines[i];
      this.parsePipeLines(page, options);
    }
  }, init.prototype.parsePipeLines = function(data, target) {
    var params = {
      type : "PolygonLine",
      name : data.name,
      points : data.points,
      id : data.userID,
      uuid : data.id,
      parent : target,
      style : {}
    };
    if (data.color) {
      params.style.color = "#" + data.color.getHexString();
    }
    var pageViewData = this;
    if (data.resource) {
      data.initCompleteCallback = function(inFlightIntent) {
        params.image = inFlightIntent.resource.getTextureUrl();
        var image = pageViewData.app.objectManager.create(params);
        image.node.position.set(data.position.x, data.position.y, data.position.z);
        if (data.sectionType && "Triangle" === data.sectionType) {
          image.pathRadialSegments = 3;
          image._updateByPoints();
        }
        if (data.radius) {
          image.width = data.radius;
        }
      };
    } else {
      var image = pageViewData.app.objectManager.create(params);
      image.node.position.set(data.position.x, data.position.y, data.position.z);
      if (data.sectionType && "Triangle" === data.sectionType) {
        image.pathRadialSegments = 3;
        image._updateByPoints();
      }
      if (data.radius) {
        image.width = data.radius;
      }
    }
  }, init.prototype.parseCurveLines = function(config, ast) {
    var o = {
      type : "RouteLine",
      parent : ast,
      name : config.name,
      uuid : config.id,
      id : config.userID,
      points : config.points,
      arrowFlag : false,
      style : {}
    };
    var pageViewData = this;
    if (config.color && (o.style.color = "#" + config.color.getHexString()), config.resource) {
      config.initCompleteCallback = function(res) {
        if (res.resource.texture) {
          var input = res.resource.texture.clone();
          input.rotation = Math.PI / 2;
          o.image = input;
        }
        var opts = pageViewData.app.objectManager.create(o);
        if (null !== config.width) {
          opts.width = config.width;
        }
        opts.node.position.set(config.position.x, config.position.y, config.position.z);
      };
    } else {
      var opts = pageViewData.app.objectManager.create(o);
      if (null !== config.width) {
        opts.width = config.width;
      }
      opts.node.position.set(config.position.x, config.position.y, config.position.z);
    }
  }, init;
}();
as = function update(options, context, data, settings) {
  r(this, update);
  this.positionArray = options.geometry.getAttribute("position").array.slice();
  var color = options.geometry.getAttribute("normal");
  if (color) {
    this.normalArray = color.array.slice();
  } else {
    THING.Utils.warn("not has normal");
  }
  var uvBuffer = options.geometry.getAttribute("uv");
  if (uvBuffer) {
    this.uvArray = uvBuffer.array;
  }
  var currentCloud = options.geometry.getAttribute("uv2");
  if (currentCloud) {
    this.uv2Array = currentCloud.array;
  }
  var conf = options.geometry.getAttribute("color");
  if (conf) {
    this.colorArray = conf.array;
  }
  this.indexArray = options.geometry.index.array;
  this.material = options.material;
  var positions = this.positionArray;
  var normals = this.normalArray;
  var i = 0;
  for (; i < positions.length;) {
    var name = settings.length - 1;
    for (; name > -1; name--) {
      var options = context[name];
      var start = data[name];
      var e = settings[name];
      positions[i] *= options.x;
      positions[i + 1] *= options.y;
      positions[i + 2] *= options.z;
      var pos = new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]);
      if ((pos = pos.applyQuaternion(start)).x += e.x, pos.y += e.y, pos.z += e.z, positions[i] = pos.x, positions[i + 1] = pos.y, positions[i + 2] = pos.z, normals) {
        var vector = new THREE.Vector3(normals[i], normals[i + 1], normals[i + 2]);
        vector = vector.applyQuaternion(start);
        normals[i] = vector.x;
        normals[i + 1] = vector.y;
        normals[i + 2] = vector.z;
      }
    }
    i = i + 3;
  }
  this.vertexCount = this.positionArray.length / 3;
  this.indexCount = this.indexArray.length;
};
ls = function() {
  function a(results) {
    r(this, a);
    this.bundeObj = results;
    this.materialMap = new Map;
    this.combineBundleMeshs = [];
  }
  return a.prototype.combine = function() {
    this._combine(this.bundeObj, [], [], []);
  }, a.prototype._combine = function(obj, t, index, r) {
    if (t.push(obj.scale), r.push(obj.position), index.push(obj.quaternion), obj instanceof THREE.Mesh) {
      var item = new as(obj, t, index, r);
      if (0 !== item.vertexCount) {
        this.combineBundleMeshs.push(item);
        if (void 0 === this.materialMap.get(item.material)) {
          this.materialMap.set(item.material, []);
        }
        this.materialMap.get(item.material).push(item);
      }
    }
    if (0 !== obj.children.length) {
      var i = 0;
      for (; i < obj.children.length; i++) {
        var previousWidgetPos = index.slice();
        var nameArgs = t.slice();
        var x_rect = r.slice();
        this._combine(obj.children[i], nameArgs, previousWidgetPos, x_rect);
      }
    }
  }, a;
}();
us = function move() {
  r(this, move);
  this.positions = [];
  this.scales = [];
  this.quaternions = [];
};
cs = function() {
  function i(data) {
    r(this, i);
    this.vertexCount = 0;
    this.indexCount = 0;
    this.material = data;
    this.bundeMeshs = [];
    this.transformations = [];
    this.maxCount = 65534;
    this.combineMesh = null;
  }
  return i.prototype.isExceed = function(vertexIndex) {
    return this.vertexCount + vertexIndex > this.maxCount;
  }, i.prototype.add = function(cmd, obj) {
    if (this.isExceed(cmd.vertexCount)) {
      return THING.Utils.error("combine exceed vertex count "), false;
    }
    this.vertexCount += cmd.vertexCount;
    this.indexCount += cmd.indexCount;
    this.bundeMeshs.push(cmd);
    this.transformations.push(obj);
  }, i.prototype.build = function() {
    var ownedParams = this.bundeMeshs;
    var indexCount = this.indexCount;
    var nPoints = this.vertexCount;
    var points = new Float32Array(3 * nPoints);
    var positions = new Float32Array(3 * nPoints);
    var colors = new Float32Array(2 * nPoints);
    var p = new Float32Array(4 * nPoints);
    var normals = new Float32Array(2 * nPoints);
    var indices = new Uint16Array(indexCount);
    var m = 0;
    var size = 0;
    var j = 0;
    var offset = 0;
    var col = 0;
    var geometry = new THREE.BufferGeometry;
    var oi = 0;
    for (; oi < ownedParams.length; oi++) {
      var object = ownedParams[oi];
      var options = this.transformations[oi];
      var positions = options.positions;
      var map = options.scales;
      var bindings = options.quaternions;
      var events = object.indexArray;
      var i = 0;
      for (; i < events.length; i++) {
        indices[i + offset] = m / 3 + events[i];
      }
      offset = offset + events.length;
      var normals = object.positionArray;
      i = 0;
      for (; i < normals.length;) {
        var pt = new THREE.Vector3(normals[i], normals[i + 1], normals[i + 2]);
        var name = positions.length - 1;
        for (; name > -1; name--) {
          var pos = positions[name];
          var a = map[name];
          var value = bindings[name];
          pt.x *= a.x;
          pt.y *= a.y;
          pt.z *= a.z;
          (pt = pt.applyQuaternion(value)).x += pos.x;
          pt.y += pos.y;
          pt.z += pos.z;
        }
        points[i + m] = pt.x;
        points[i + m + 1] = pt.y;
        points[i + m + 2] = pt.z;
        i = i + 3;
      }
      m = m + normals.length;
      var p = object.normalArray;
      i = 0;
      for (; i < p.length;) {
        var position = new THREE.Vector3(p[i], p[i + 1], p[i + 2]);
        name = bindings.length - 1;
        for (; name > -1; name--) {
          value = bindings[name];
          position = position.applyQuaternion(value);
        }
        positions[i + size] = position.x;
        positions[i + size + 1] = position.y;
        positions[i + size + 2] = position.z;
        i = i + 3;
      }
      size = size + p.length;
      var id = object.uvArray;
      if (id) {
        i = 0;
        for (; i < id.length; i++) {
          colors[i + j] = id[i];
        }
      }
      var n = object.uv2Array;
      if (n) {
        i = 0;
        for (; i < n.length; i++) {
          normals[i + j] = n[i];
        }
      }
      if (id) {
        j = j + id.length;
      }
      var c = object.colorArray;
      if (c) {
        i = 0;
        for (; i < c.length; i++) {
          p[i + col] = c[i];
        }
        col = col + c.length;
      }
    }
    geometry.addAttribute("position", new THREE.BufferAttribute(points, 3));
    geometry.addAttribute("normal", new THREE.BufferAttribute(positions, 3));
    geometry.addAttribute("uv", new THREE.BufferAttribute(colors, 2));
    if (0 !== normals.length) {
      geometry.addAttribute("uv2", new THREE.BufferAttribute(normals, 2));
    }
    if (0 !== p.length) {
      geometry.addAttribute("color", new THREE.BufferAttribute(p, 4));
    }
    geometry.setIndex(new THREE.BufferAttribute(indices, 1));
    var mesh = new THREE.Mesh(geometry, this.material);
    if (this.material.defines && this.material.defines.USE_ALPHAINDEX) {
      delete this.material.defines.USE_ALPHAINDEX;
    }
    mesh.name = "combine";
    this.combineMesh = mesh;
  }, i;
}();
hs = function() {
  function a(value) {
    r(this, a);
    this.app = value;
    this.combineBundleObjectMap = {};
    this.processorMap = new Map;
    this.floorMaterialMap = new Map;
    this.processors = [];
  }
  return a.prototype.combineModels = function() {
    var res = this.app.modelResource.models;
    var animation_promises = [];
    var map = this;
    var ref;
    for (ref in res) {
      animation_promises.push(new Promise(function(saveNotifs, n) {
        var o = performance.now();
        var data = new ls(res[ref].node);
        map.combineBundleObjectMap[ref] = data;
        data.combine();
        if (performance.now() - o > .1) {
          setTimeout(function() {
            saveNotifs();
          }, 10);
        } else {
          saveNotifs();
        }
      }));
    }
    return Promise.all(animation_promises);
  }, a.prototype.getModelObject = function(name) {
    var last_supr = this.combineBundleObjectMap[name];
    return last_supr || null;
  }, a.prototype.addPlacement = function(s, color, point, value, startIndex) {
    var t = this.floorMaterialMap.get(s);
    if (!t) {
      t = new Map;
      this.floorMaterialMap.set(s, t);
    }
    var r = this.processorMap.get(s);
    if (!r) {
      this.processorMap.set(s, []);
      r = this.processorMap.get(s);
    }
    var self = new us;
    self.positions = point;
    self.scales = value;
    self.quaternions = startIndex;
    this.combineBundleObjectMap[color].materialMap.forEach(function(rawtype, argV, i) {
      var r = rawtype;
      var v = argV;
      var i = 0;
      for (; i < r.length; i++) {
        var info = r[i];
        var result = t.get(v);
        if (!(result && !result.isExceed(info.vertexCount))) {
          result = new cs(v);
          t.set(v, result);
          r.push(result);
        }
        result.add(info, self);
      }
    });
  }, a.prototype.getCombineProcessors = function(h, scale, color, component) {
    var delete_units = [];
    var cache = new Map;
    var i;
    for (i in h) {
      var key = h[i];
      if (!key.uid && !key.name) {
        var index = this.app.modelResource.bundleIDArray[key.bIdx];
        var u = (this.app.modelResource.get(index).node, new THREE.Vector3(0, 0, 0));
        var config = new us;
        if (key.pos) {
          var rDefs = key.pos.split(" ");
          u.x = parseFloat(rDefs[0]);
          u.y = parseFloat(rDefs[1]);
          u.z = -parseFloat(rDefs[2]);
        }
        var p = new THREE.Vector3(1, 1, 1);
        if (key.scl) {
          var rDefs = key.scl.split(" ");
          p.x = parseFloat(rDefs[0]);
          p.y = parseFloat(rDefs[1]);
          p.z = parseFloat(rDefs[2]);
        }
        var f = new THREE.Quaternion(0, 0, 0, 1);
        if (key.rot) {
          var rDefs = key.rot.split(" ");
          f.x = parseFloat(rDefs[0]);
          f.y = parseFloat(rDefs[1]);
          f.z = -parseFloat(rDefs[2]);
          f.w = -parseFloat(rDefs[3]);
        }
        var res = scale.slice();
        var s = color.slice();
        var dimsWithHiers = component.slice();
        dimsWithHiers.push(f);
        s.push(p);
        res.push(u);
        config.positions = res;
        config.scales = s;
        config.quaternions = dimsWithHiers;
        this.combineBundleObjectMap[index].materialMap.forEach(function(canCreateDiscussions, identifiers_on_map, i) {
          var sortedPrimaryLocales = canCreateDiscussions;
          var name = identifiers_on_map;
          var i = 0;
          for (; i < sortedPrimaryLocales.length; i++) {
            var l = sortedPrimaryLocales[i];
            var u = cache.get(name);
            if (!(u && !u.isExceed(l.vertexCount))) {
              u = new cs(name);
              cache.set(name, u);
              delete_units.push(u);
            }
            u.add(l, config);
          }
        });
      }
    }
    return delete_units;
  }, a;
}();
ps = function() {
  function init(options) {
    r(this, init);
    this.app = options;
    this.nodes = [];
    this.scene = this.app.scene;
    this.objectPool = this.app.objectPool;
    this.worldNode = new THREE.Object3D;
    this.app.scene.add(this.worldNode);
    this.baseURL = options.sceneURL;
    this.curLoadGLTFIndex = 0;
    this.splitLoadedGLTFCount = 0;
    this.allLoadedGLTFCount = 0;
    this.sliceRootNodeArray = [];
    this.sceneJsonData = null;
    this.states = null;
    this.combineManager = new hs(this.app);
    this.combineProcessorMap = new Map;
    this.loadSpeed = .1;
  }
  return init.prototype.load = function() {
    var _this = this;
    return new Promise(function(changeFn, saveNotifs) {
      _this.loadSceneJson().then(function(s) {
        return s.camInfo && (_this.parseCamInfo(s.camInfo), _this.app.camera.update()), _this.sceneJsonData = JSON.parse(s), _this.loadStructureJson();
      }).then(function(tile) {
        var data = _this.getSortedStructureGLTFs(tile);
        return new Promise(function(changeFn, canCreateDiscussions) {
          _this.loadStructure(data, function() {
            _this.parseObjects().then(function() {
              changeFn(_this.worldNode);
            });
          });
        });
      }).then(function() {
        changeFn(_this.worldNode);
      }).catch(function(notifications) {
        saveNotifs(notifications);
      });
    });
  }, init.prototype.loadSceneJson = function(e) {
    var resp = this;
    return e && (resp.sceneURL = e), new Promise(function(continuation, i) {
      if (resp.sceneJsonData) {
        continuation(resp.sceneJsonData);
      } else {
        (new THREE.FileLoader(resp.app.loadingManager)).load(resp.sceneURL.appendURL(resp.sceneJsonUri), function(url) {
          continuation(url);
        });
      }
    });
  }, init.prototype.loadStructureJson = function() {
    var addressManagement = this;
    return new Promise(function(obtainGETData, saveNotifs) {
      (new THREE.FileLoader).load(addressManagement.baseURL + "/structure.json", function(e) {
        var val = JSON.parse(e);
        obtainGETData(val);
      }, function() {
      }, function(canCreateDiscussions) {
        saveNotifs("cant not load file: structure.json");
      });
    });
  }, init.prototype.loadStructure = function(data, $, name) {
    this.splitLoadedGLTFCount = 0;
    var self = this;
    var n = 0;
    if (0 == data.length) {
      if ($) {
        $();
      }
    } else {
      var i = self.curLoadGLTFIndex;
      for (; i < data.length && (0 == n || n % 10 != 0); i++) {
        n++;
        self.curLoadGLTFIndex++;
        var loader = new THREE.GLTFLoader(self.app.loadingManager);
        loader.setCrossOrigin("anonymous");
        loader.load(self.baseURL + "/" + data[i].path, function(loaded) {
          var block = loaded.scene.children[0].children[0];
          self.nodes[block.name] = block;
          self.sliceRootNodeArray.push(block);
          block.traverse(function(unit) {
            self.nodes[unit.name] = unit;
          });
          self.splitLoadedGLTFCount++;
          self.allLoadedGLTFCount++;
          if (10 === self.splitLoadedGLTFCount) {
            self.loadStructure(data, $, name);
          }
          self.app.scene.add(block);
          if (self.allLoadedGLTFCount == data.length && $) {
            $();
          }
        }, function() {
        }, function(canCreateDiscussions) {
          if (name) {
            name("load " + self.baseURL + "/" + data[i].path + " failed");
          }
        });
      }
    }
  }, init.prototype.parseObjects = function() {
    var e = this.sceneJsonData;
    var t = this;
    return e.bIdList ? new Promise(function(saveNotifs, obtainGETData) {
      t.parseBundleList(e.bIdList).then(function() {
        return t.parse(e);
      }).then(function() {
        t.sliceRootNodeArray = [];
        saveNotifs();
      }).catch(function(val) {
        obtainGETData(val);
      });
    }) : new Promise(function(saveNotifs, obtainGETData) {
      t.parse(e).then(function() {
        t.sliceRootNodeArray = [];
        saveNotifs();
      }).catch(function(val) {
        obtainGETData(val);
      });
    });
  }, init.prototype.getSortedStructureGLTFs = function(layers) {
    var a = [];
    var result = [];
    var r = [];
    var c = layers.outdoors;
    var obj = layers.buildings;
    var key;
    for (key in c) {
      var prop = c[key];
      a.push(prop);
    }
    var i = 0;
    for (; i < a.length; i++) {
      var b = a[i];
      if (0 != result.length) {
        var i = 0;
        for (; i < result.length; i++) {
          var p = result[i];
          if (b.size < p.size) {
            result.splice(i, 0, b);
            break;
          }
          if (i == result.length - 1) {
            result.push(b);
            break;
          }
        }
      } else {
        result.push(a[i]);
      }
    }
    for (key in a = [], obj) {
      a.push(obj[key]);
    }
    i = 0;
    for (; i < a.length; i++) {
      b = a[i];
      if (0 != r.length) {
        i = 0;
        for (; i < r.length; i++) {
          p = r[i];
          if (b.size < p.size) {
            r.splice(i, 0, b);
            break;
          }
          if (i == r.length - 1) {
            r.push(b);
            break;
          }
        }
      } else {
        r.push(a[i]);
      }
    }
    return result.concat(r);
  }, init.prototype._nestingLoopYield = function(params, method, content) {
    var ariaUtilsArray = this;
    var tok = params.next();
    if (tok.done) {
      return method && method(), tok.value;
    }
    var obj = tok.value;
    tok.done;
    if (obj instanceof Promise) {
      obj.then(function(n) {
        return ariaUtilsArray._nestingLoopYield(params, method, content);
      }).catch(function(data) {
        content(data);
      });
    } else {
      this._nestingLoopYield(params, method, content);
    }
  }, init.prototype.parse = function(data) {
    var downloads = this;
    return this.combineManager.combineModels().then(function() {
      return new Promise(function(saveNotifs, canCreateDiscussions) {
        if (data.objects) {
          var models = data.objects;
          var item = null;
          var i;
          for (i in models) {
            item = models[i];
            break;
          }
          downloads._nestingLoopYield(downloads.parseWorld(item), function() {
            saveNotifs();
          });
        }
        if (data.camInfo) {
          var item = data.camInfo;
          downloads.parseCamInfo(item);
        }
      });
    });
  }, init.prototype.parseCamInfo = function(data) {
    var t = data.eye;
    var i = data.target;
    var filem = t.split(" ");
    var cmd_s = i.split(" ");
    var songsHeaders = [Number(filem[0]), Number(filem[1]), Number(filem[2])];
    songsHeaders[2] = -songsHeaders[2];
    var delegatorRoot = [Number(cmd_s[0]), Number(cmd_s[1]), Number(cmd_s[2])];
    delegatorRoot[2] = -delegatorRoot[2];
    this.app.camera.position = songsHeaders;
    this.app.camera.target = delegatorRoot;
  }, init.prototype.parseWorld = function(obj) {
    function next(cookies) {
      var maxvalue;
      var ajaxInterval;
      var obj;
      var str;
      var i;
      var tmp;
      var key;
      var children;
      var p;
      return g.wrap(function(_context3) {
        for (;;) {
          switch(_context3.prev = _context3.next) {
            case 0:
              maxvalue = conf.loadSpeed;
              ajaxInterval = 10;
              obj = cookies.keys();
              str = Array.isArray(obj);
              i = 0;
              obj = str ? obj : obj[Symbol.iterator]();
            case 3:
              if (!str) {
                _context3.next = 9;
                break;
              }
              if (!(i >= obj.length)) {
                _context3.next = 6;
                break;
              }
              return _context3.abrupt("break", 24);
            case 6:
              tmp = obj[i++];
              _context3.next = 13;
              break;
            case 9:
              if (!(i = obj.next()).done) {
                _context3.next = 12;
                break;
              }
              return _context3.abrupt("break", 24);
            case 12:
              tmp = i.value;
            case 13:
              key = tmp;
              children = cookies.get(key);
              p = 0;
            case 16:
              if (!(p < children.length)) {
                _context3.next = 22;
                break;
              }
              return _context3.next = 19, new Promise(function(saveNotifs, canCreateDiscussions) {
                var dec_step = performance.now();
                children[p].build();
                var o = children[p].combineMesh;
                key.node.add(o);
                if (performance.now() - dec_step > maxvalue) {
                  setTimeout(function() {
                    saveNotifs();
                  }, ajaxInterval);
                } else {
                  saveNotifs();
                }
              });
            case 19:
              p++;
              _context3.next = 16;
              break;
            case 22:
              _context3.next = 3;
              break;
            case 24:
            case "end":
              return _context3.stop();
          }
        }
      }, name, this);
    }
    var name = g.mark(next);
    var i = this.worldNode;
    if (obj.plan && this.parseOutdoors(obj.plan, i), obj.bds) {
      var connections = obj.bds;
      var id;
      for (id in connections) {
        var response = connections[id];
        var e = new THREE.Vector3(0, 0, 0);
        if (response.pos) {
          var rDefs = response.pos.split(" ");
          e.x = parseFloat(rDefs[0]);
          e.y = parseFloat(rDefs[1]);
          e.z = -parseFloat(rDefs[2]);
        }
        var l = new THREE.Object3D;
        var options = this.app.objectManager.create({
          type : "Building",
          name : id,
          node : l
        });
        if (options.name = id, options.app = this.app, options.id = id, i.add(l), response.plans) {
          this.parseFloorPlans(response.plans, options);
        }
        if (response.facades) {
          var entity = response.facades;
          var propertyName;
          for (propertyName in entity) {
            var p = this.createThing(entity[propertyName], options, null, "Facade");
            var pos = p.node.position;
            pos.x += e.x;
            pos.y += e.y;
            pos.z += e.z;
            p.node.position.set(pos.x, pos.y, pos.z);
          }
        }
        if (response.groups) {
          var responses = response.groups;
          var id;
          for (id in responses) {
            response = responses[id];
            this.createGroup(response, options);
          }
        }
      }
    }
    var conf = this;
    return next(this.combineProcessorMap);
  }, init.prototype.parseOutdoors = function(checkFor, id) {
    var p;
    var r;
    var i;
    for (i in checkFor) {
      r = checkFor[i];
      p = i;
      break;
    }
    var t = this.app.outdoors;
    this.worldNode.add(t.node);
    this.processFloorPlanData(p, r, t);
  }, init.prototype.processFloorPlanData = function(data, self, item) {
    item.name = data;
    item.app = this.app;
    item.id = data;
    var obj = new THREE.Vector3(0, 0, 0);
    if (self.pos) {
      var n = self.pos.split(" ");
      obj.x = parseFloat(n[0]);
      obj.y = parseFloat(n[1]);
      obj.z = -parseFloat(n[2]);
    }
    var constt = self.cwalls;
    if (constt) {
      var b = new THREE.Group;
      var i;
      for (i in b.name = "combinewall", constt) {
        var id = constt[i].gltfid;
        var p = this.nodes[id];
        if (p) {
          b.add(p);
        }
      }
      item.node.add(b);
      b.updateMatrixWorld();
      item.wallNode = b;
    }
    var avals = self.croofs;
    if (avals) {
      var p = new THREE.Group;
      for (i in p.name = "combineroof", avals) {
        id = avals[i].gltfid;
        var n = this.nodes[id];
        if (n) {
          p.add(n);
        }
      }
      item.node.add(p);
      item.roofNode = p;
    }
    var indexesOfSourceData = self.cceilings;
    if (indexesOfSourceData) {
      var f = new THREE.Group;
      for (i in f.name = "combineceiling", indexesOfSourceData) {
        id = indexesOfSourceData[i].gltfid;
        var p = this.nodes[id];
        if (p) {
          f.add(p);
        }
      }
      item.node.add(f);
      item.ceilNode = f;
    }
    if (ret = self.cfloors) {
      var g = new THREE.Group;
      for (i in g.name = "combinefloor", ret) {
        var ret;
        if (id = (ret = ret[i]).gltfid) {
          var p = this.nodes[id];
          if (p) {
            g.add(p);
          }
        }
      }
      item.node.add(g);
      item.floorNode = g;
    }
    var b = new THREE.Group;
    b.name = "combinePlacement";
    item.miscNode = b;
    item.node.add(b);
    var r = self.cplcs;
    if (r) {
      for (i in r) {
        id = r[i].gltfid;
        var obj = this.nodes[id];
        if (obj) {
          b.add(obj);
          obj.updateMatrixWorld();
        }
      }
    }
    if (self.plcs) {
      var tO = this.combineManager.getCombineProcessors(self.plcs, [obj], [new THREE.Vector3(1, 1, 1)], [new THREE.Quaternion(0, 0, 0, 1)]);
      this.combineProcessorMap.set(item, tO);
      this.parseThings(self.plcs, item, obj);
    }
    if (self.routes) {
      this.parseStructureThing(self.routes, item);
    }
    if (self.pipelines) {
      this.parseStructureThing(self.pipelines, item);
    }
    if (self.curvelines) {
      this.parseStructureThing(self.curvelines, item);
    }
    if (self.arrowlines) {
      this.parseStructureThing(self.arrowlines, item);
    }
    if (self.arrowdatalines) {
      this.parseStructureThing(self.arrowdatalines, item);
    }
    if (self.leakwaterlines) {
      this.parseStructureThing(self.leakwaterlines, item);
    }
    if (self.vps) {
      this.parseThings(self.vps, item, obj);
    }
    if (self.groups) {
      this.parseGroups(self.groups, item, [new THREE.Vector3(1, 1, 1)], [new THREE.Quaternion(0, 0, 0, 1)], [obj], obj);
    }
    if (self.dws) {
      this.parseDoorWins(self.dws, item, obj);
    }
  }, init.prototype.parseDoorWins = function(all, obj, xyz) {
    var id;
    for (id in all) {
      var info = all[id];
      var uid = id;
      if (info.uid) {
        uid = info.uid;
      }
      var a = null;
      if (info.gltfid) {
        var id = info.gltfid;
        if (this.nodes[id]) {
          (a = this.nodes[id]).position.x += xyz.x;
          a.position.y += xyz.y;
          a.position.z += xyz.z;
          obj.node.add(a);
        }
      }
      var properties = null;
      if (info.prop) {
        var d = info.prop;
        var prop;
        for (prop in properties = {}, d) {
          var val = d[prop];
          properties[prop] = val;
        }
      }
      this.app.objectManager.create({
        type : "Door",
        name : uid,
        node : a,
        parent : obj,
        properties : properties
      });
    }
  }, init.prototype.parseGroups = function(el, t, data, category, items, date) {
    var prop;
    for (prop in el) {
      var current = el[prop];
      if (current.uid) {
        this.createGroup(current, t);
      } else {
        this.combineGroup(current, t, data, category, items, date);
      }
    }
  }, init.prototype.createGroup = function(obj, content) {
    var userId;
    var values;
    var n = this.instanceGroup(obj);
    if (obj.id) {
      obj.id;
    }
    if (obj.uid) {
      userId = obj.uid;
    }
    var d = obj.prop;
    if (d) {
      var i;
      for (i in values = {}, d) {
        var x = d[i];
        values[i] = x;
      }
    }
    return this.app.objectManager.create({
      type : "Thing",
      name : userId,
      node : n,
      parent : content,
      properties : values
    });
  }, init.prototype.parseFloorPlans = function(params, scope) {
    var jisps = [];
    var key;
    for (key in params) {
      var direction = params[key];
      var fooNode = new THREE.Object3D;
      var s = this.app.objectManager.create({
        type : "Floor",
        name : key,
        node : fooNode,
        parent : scope
      });
      s.id = key;
      fooNode.name = "floorPlan";
      scope.node.add(s.node);
      this.processFloorPlanData(key, direction, s);
      s._parent = scope;
      jisps.push(s);
    }
    return jisps;
  }, init.prototype.parseBundleList = function(divs) {
    this.app.modelResource.bundleIDArray = divs;
    var i = 0;
    var req = this;
    return new Promise(function(saveNotifs, negater) {
      if (0 != divs.length) {
        divs.forEach(function(o) {
          var loader = new THREE.GLTFLoader(req.app.loadingManager);
          loader.setCrossOrigin("anonymous");
          loader.load(req.baseURL + "/" + o + "/scene.gltf", function(loaded) {
            i++;
            req.app.modelResource.set(o, loaded.scene.children[0].children[0]);
            if (i == divs.length) {
              saveNotifs();
            }
          }, function() {
          }, function(canCreateDiscussions) {
            negater("can not load " + req.baseURL + "/" + o + "/scene.gltf");
          });
        });
      } else {
        saveNotifs();
      }
    });
  }, init.prototype.combineGroup = function(resource, target, size, t, v, spec) {
    var doc = resource;
    var a = new THREE.Vector3(0, 0, 0);
    if (doc.pos) {
      var rDefs = doc.pos.split(" ");
      a.x = parseFloat(rDefs[0]);
      a.y = parseFloat(rDefs[1]);
      a.z = -parseFloat(rDefs[2]);
    }
    var e = new THREE.Vector3(1, 1, 1);
    if (doc.scl) {
      var rDefs = doc.scl.split(" ");
      e.x = parseFloat(rDefs[0]);
      e.y = parseFloat(rDefs[1]);
      e.z = parseFloat(rDefs[2]);
    }
    var o;
    var r;
    var s;
    var f = new THREE.Quaternion(0, 0, 0, 1);
    if (doc.rot) {
      rDefs = doc.rot.split(" ");
      f.x = parseFloat(rDefs[0]);
      f.y = parseFloat(rDefs[1]);
      f.z = -parseFloat(rDefs[2]);
      f.w = -parseFloat(rDefs[3]);
    }
    if (v ? (o = size.slice(), s = t.slice(), r = v.slice()) : (o = [], r = [], s = []), o.push(e), r.push(a), s.push(f), doc.plcs) {
      var result = this.combineManager.getCombineProcessors(doc.plcs, r, o, s);
      var g = this.combineProcessorMap.get(target);
      if (g) {
        result = g.concat(result);
      }
      this.combineProcessorMap.set(target, result);
    }
    if (doc.groups) {
      var i;
      for (i in doc.groups) {
        this.combineGroup(doc.groups[i], target, o, s, r, spec);
      }
    }
  }, init.prototype.instanceGroup = function(o) {
    var t = new THREE.Vector3(0, 0, 0);
    if (o.pos) {
      var rDefs = o.pos.split(" ");
      t.x = parseFloat(rDefs[0]);
      t.y = parseFloat(rDefs[1]);
      t.z = -parseFloat(rDefs[2]);
    }
    var transform = new THREE.Vector3(1, 1, 1);
    if (o.scl) {
      var n = o.scl.split(" ");
      transform.x = parseFloat(n[0]);
      transform.y = parseFloat(n[1]);
      transform.z = parseFloat(n[2]);
    }
    var params = new THREE.Quaternion(0, 0, 0, 1);
    if (o.rot) {
      n = o.rot.split(" ");
      params.x = parseFloat(n[0]);
      params.y = parseFloat(n[1]);
      params.z = -parseFloat(n[2]);
      params.w = -parseFloat(n[3]);
    }
    var cube = new THREE.Group;
    if (o.plcs) {
      var prop;
      for (prop in o.plcs) {
        var script = this.instanceChildOfGroup(o.plcs[prop]);
        cube.add(script);
      }
    }
    if (o.groups) {
      for (prop in o.groups) {
        script = this.instanceGroup(o.plcs[prop]);
        cube.add(script);
      }
    }
    return cube.scale.copy(transform), cube.setRotationFromQuaternion(params), cube.position.copy(t), cube;
  }, init.prototype.instanceChildOfGroup = function(face) {
    var key = this.app.modelResource.bundleIDArray[face.bIdx];
    var cube = this.app.modelResource.get(key).node.clone();
    if (face.pos) {
      var rDefs = face.pos.split(" ");
      cube.position.x = parseFloat(rDefs[0]);
      cube.position.y = parseFloat(rDefs[1]);
      cube.position.z = -parseFloat(rDefs[2]);
    }
    if (face.rot) {
      rDefs = face.rot.split(" ");
      var params = new THREE.Quaternion;
      params.x = parseFloat(rDefs[0]);
      params.y = parseFloat(rDefs[1]);
      params.z = -parseFloat(rDefs[2]);
      params.w = -parseFloat(rDefs[3]);
      cube.setRotationFromQuaternion(params);
    }
    return cube;
  }, init.prototype.parseThings = function(config, value, target) {
    var type;
    for (type in config) {
      var options = config[type];
      if (options.uid || options.prop) {
        this.createThing(options, value, target);
      }
    }
  }, init.prototype.createThing = function(key, content, node) {
    var value;
    var arrayValueHash;
    var GET_USER_PROFILE_SUCCESS = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "Thing";
    if (key.id) {
      key.id;
    }
    if (key.uid) {
      value = key.uid;
    }
    var localContext = key.prop;
    if (localContext) {
      var graphVariable;
      for (graphVariable in arrayValueHash = {}, localContext) {
        var originalVarValue = localContext[graphVariable];
        arrayValueHash[graphVariable] = originalVarValue;
      }
    }
    var index = this.app.modelResource.bundleIDArray[key.bIdx];
    var fold = this.app.modelResource.get(index).node;
    var target = fold.clone();
    if (key.pos) {
      var rDefs = key.pos.split(" ");
      var pos = new THREE.Vector3(parseFloat(rDefs[0]), parseFloat(rDefs[1]), -parseFloat(rDefs[2]));
      if (node) {
        pos.x += node.x;
        pos.y += node.y;
        pos.z += node.z;
      }
      target.position.x = pos.x;
      target.position.y = pos.y;
      target.position.z = pos.z;
    }
    if (key.rot) {
      rDefs = key.rot.split(" ");
      var rotation = new THREE.Quaternion;
      rotation.x = parseFloat(rDefs[0]);
      rotation.y = parseFloat(rDefs[1]);
      rotation.z = -parseFloat(rDefs[2]);
      rotation.w = -parseFloat(rDefs[3]);
      target.setRotationFromQuaternion(rotation);
    }
    if (key.scl) {
      rDefs = key.scl.split(" ");
      var light = new THREE.Vector3;
      light.x = parseFloat(rDefs[0]);
      light.y = parseFloat(rDefs[1]);
      light.z = -parseFloat(rDefs[2]);
      target.scale.x = light.x;
      target.scale.y = light.y;
      target.scale.z = light.z;
    }
    var mesh = this.app.objectManager.create({
      type : GET_USER_PROFILE_SUCCESS,
      name : value,
      node : target,
      parent : content,
      properties : arrayValueHash
    });
    return mesh;
  }, init.prototype.parseStructureThing = function(c, t, scale) {
    var s;
    for (s in c) {
      var x = c[s];
      if (x.gltfid) {
        var data = new fr(this.app);
        data.name = s;
        data.app = this.app;
        if (x.id) {
          data.id = x.id;
        }
        if (x.uid) {
          data.name = x.uid;
        }
        var child = x.gltfid;
        if (this.nodes[child]) {
          var node = this.nodes[child];
          data.node = node;
          t.add(data);
          if (scale) {
            node.position.x = scale.x;
            node.position.y = scale.y;
            node.position.z = scale.z;
          }
        }
      }
    }
  }, init;
}();
ds = function() {
  function init(value, me) {
    r(this, init);
    this.app = value;
    this.nodes = [];
    this.outdoors = this.app.outdoors;
    this.objectPool = this.app.objectPool;
    this.worldNode = new THREE.Object3D;
    this.worldNode.name = "world";
    this.campus = null;
    this.baseURL = null;
    this.sceneJsonUri = "scene.json";
    this.curLoadGLTFIndex = 0;
    this.splitLoadedGLTFCount = 0;
    this.allLoadedGLTFCount = 0;
    this.sliceRootNodeArray = [];
    this.sceneJsonData = null;
    this.states = null;
    this.combineManager = new hs(this.app);
    this.loadSpeed = .1;
    this.isCamFitScene = true;
    this.loadStageWeight = [.1, .1, .3, .5];
    this.loadedProgress = 0;
    this.curStageLoadProgress = 0;
    this.isDelayLoadFloorPlan = false;
    this.envMap = null;
    this.appFirstTimeLoad = false;
    if (this.outdoors) {
      this.appFirstTimeLoad = false;
    } else {
      this.appFirstTimeLoad = true;
    }
    if (me) {
      if (me.position) {
        this.campusPosition = me.position;
      }
      if (me.rotation) {
        this.campusRotation = me.rotation;
      }
      if (void 0 !== me.isCamFitScene && null !== me.isCamFitScene) {
        this.isCamFitScene = me.isCamFitScene;
      }
      if (void 0 !== me.isDelayLoadFloorPlan && null !== me.isDelayLoadFloorPlan) {
        this.isDelayLoadFloorPlan = me.isDelayLoadFloorPlan;
      }
      if (me.campus) {
        this.campus = me.campus;
      }
    }
    var slideDragNode = this.worldNode;
    if (null == this.campus) {
      this.campus = this.app.objectManager.create({
        type : "Campus",
        name : "Campus",
        node : slideDragNode
      });
      this.app.scene.add(this.campus.node);
    }
    if (this.campusRotation) {
      this.campus.node.quaternion.set(this.campusRotation.x, this.campusRotation.y, this.campusRotation.z, this.campusRotation.w);
    }
    if (this.campusPosition) {
      this.campus.position = this.campusPosition;
    }
    this.scene = this.campus.node;
  }
  return init.prototype.updateProgress = function(data) {
    this.app.mainUI.updateLoadingProcess({
      object : this.campus,
      progress : data
    });
  }, init.prototype.loadSkybox = function() {
    if (this.sceneJsonData.skybox) {
      var b = this.sceneJsonData.skybox;
      var i = 0;
      for (; i < b.length; i++) {
        var a = b[i];
        a = this.baseURL + a;
        b[i] = a;
      }
      var material = this;
      return new Promise(function(saveNotifs, i) {
        (new THREE.CubeTextureLoader).load(b, function(texture) {
          texture.flipY = true;
          material.envMap = texture;
          saveNotifs();
        }, null, function() {
          THING.Utils.warn("load skybox fail");
          saveNotifs();
        });
      });
    }
    return new Promise(function(saveNotifs, canCreateDiscussions) {
      saveNotifs();
    });
  }, init.prototype.load = function(url) {
    var me = this;
    if ("String" === url.constructor.name) {
      this.baseURL = url;
    } else {
      if ("Object" === url.constructor.name) {
        var cfg = url;
        this.baseURL = cfg.url;
        if (cfg.campus) {
          this.campus = cfg.campus;
          this.worldNode = this.campus.node;
        }
      }
    }
    return new Promise(function($, saveNotifs) {
      me.loadSceneJson().then(function(item) {
        return item.camInfo && me.isCamFitScene && me.parseCamInfo(item.camInfo), me.sceneJsonData = JSON.parse(item), me.updateProgress(.1), me.loadSkybox().then(function() {
          return me.loadStructureJson();
        });
      }).then(function(mode) {
        me.updateProgress(.2);
        var help = me.getSortedStructureGLTFs(mode);
        return new Promise(function($, canCreateDiscussions) {
          me.updateProgress(.3);
          me.loadStructure(help, function() {
            me.updateProgress(.7);
            me.parseObjects().then(function() {
              me.updateProgress(.8);
              $(me.campus);
            });
          });
        });
      }).then(function() {
        me.updateProgress(1);
        $(me.campus);
      }).catch(function(notifications) {
        saveNotifs(notifications);
      });
    });
  }, init.prototype.loadSceneJson = function(e) {
    var resp = this;
    return e && (resp.sceneURL = e), new Promise(function(continuation, i) {
      if (resp.sceneJsonData) {
        continuation(resp.sceneJsonData);
      } else {
        (new THREE.FileLoader(resp.app.loadingManager)).load(resp.sceneURL.appendURL(resp.sceneJsonUri), function(url) {
          continuation(url);
        });
      }
    });
  }, init.prototype.loadStructureJson = function() {
    var addressManagement = this;
    return new Promise(function(obtainGETData, saveNotifs) {
      (new THREE.FileLoader).load(addressManagement.baseURL + "/structure.json", function(e) {
        var val = JSON.parse(e);
        obtainGETData(val);
      }, function() {
      }, function(canCreateDiscussions) {
        saveNotifs("cant not load file: structure.json");
      });
    });
  }, init.prototype.addEnvMap = function(object) {
    var camera = this;
    if (this.envMap) {
      object.traverse(function(self) {
        if (self.material) {
          if (self.material.opacity < 1 && !self.material.transparent) {
            self.material.transparent = true;
            self.material.needsUpdate = true;
          }
          if (self.material.transparent) {
            self.material.metalness = 1;
            self.material.roughness = 0;
            self.material.envMap = camera.envMap;
            self.material.envMapIntensity = 2;
            self.material.refractionRatio = 1;
            self.material.needsUpdate = true;
          }
          if (self.material.isMeshStandardMaterial) {
            self.material.envMap = camera.envMap;
            self.material.envMapIntensity = 1;
            self.material.refractionRatio = 1;
            self.material.needsUpdate = true;
          }
        }
      });
    }
  }, init.prototype.loadStructure = function(data, $, name) {
    this.splitLoadedGLTFCount = 0;
    var self = this;
    var n = 0;
    if (0 == data.length) {
      if ($) {
        $();
      }
    } else {
      var i = self.curLoadGLTFIndex;
      for (; i < data.length && (0 == n || n % 10 != 0); i++) {
        n++;
        self.curLoadGLTFIndex++;
        var loader = new thingjs.GLTFLoader;
        loader.setCrossOrigin("anonymous");
        var group = data[i];
        loader.load(self.baseURL + "/" + group.path, function(loaded) {
          var obj = loaded.scene.children[0].children[0];
          self.nodes[obj.name] = obj;
          self.sliceRootNodeArray.push(obj);
          obj.traverse(function(unit) {
            self.nodes[unit.name] = unit;
          });
          self.splitLoadedGLTFCount++;
          self.allLoadedGLTFCount++;
          if (10 === self.splitLoadedGLTFCount) {
            self.loadStructure(data, $, name);
          }
          if (void 0 === group.show || group.show) {
            self.scene.add(obj);
          }
          self.addEnvMap(obj);
          obj.updateMatrixWorld();
          self.scene.updateMatrixWorld(true);
          if (self.allLoadedGLTFCount == data.length && $) {
            $();
          }
        }, function() {
        }, function(t) {
          if (name) {
            name("load " + self.baseURL + "/" + data[i].path + " failed");
          } else {
            THING.Utils.error("load " + self.baseURL + "/" + group.path + " failed");
          }
          THING.Utils.error(t);
        });
      }
    }
  }, init.prototype.parseObjects = function() {
    var e = this.sceneJsonData;
    var col = this;
    return e.models ? new Promise(function(saveNotifs, obtainGETData) {
      col.parseBundleList(e.models).then(function() {
        return col.parse(e);
      }).then(function() {
        col.sliceRootNodeArray = [];
        saveNotifs();
      }).catch(function(val) {
        obtainGETData(val);
      });
    }) : new Promise(function(saveNotifs, obtainGETData) {
      col.parse(e).then(function() {
        col.sliceRootNodeArray = [];
        saveNotifs();
      }).catch(function(val) {
        obtainGETData(val);
      });
    });
  }, init.prototype.getSortedStructureGLTFs = function(layers) {
    var a = [];
    var result = [];
    var r = [];
    var c = layers.outdoors;
    var obj = layers.buildings;
    var key;
    for (key in c) {
      var prop = c[key];
      a.push(prop);
    }
    var i = 0;
    for (; i < a.length; i++) {
      var b = a[i];
      if (0 != result.length) {
        var i = 0;
        for (; i < result.length; i++) {
          var p = result[i];
          if (b.size < p.size) {
            result.splice(i, 0, b);
            break;
          }
          if (i == result.length - 1) {
            result.push(b);
            break;
          }
        }
      } else {
        result.push(a[i]);
      }
    }
    for (key in a = [], obj) {
      a.push(obj[key]);
    }
    i = 0;
    for (; i < a.length; i++) {
      b = a[i];
      if (0 != r.length) {
        i = 0;
        for (; i < r.length; i++) {
          p = r[i];
          if (b.size < p.size) {
            r.splice(i, 0, b);
            break;
          }
          if (i == r.length - 1) {
            r.push(b);
            break;
          }
        }
      } else {
        r.push(a[i]);
      }
    }
    return result.concat(r);
  }, init.prototype._nestingLoopYield = function(html, handler, content) {
    var parser = this;
    var tok = html.next();
    if (tok.done) {
      return handler && handler(), tok.value;
    }
    var obj = tok.value;
    tok.done;
    if (obj instanceof Promise) {
      obj.then(function(n) {
        return parser._nestingLoopYield(html, handler, content);
      }).catch(function(data) {
        content(data);
      });
    } else {
      this._nestingLoopYield(html, handler, content);
    }
  }, init.prototype.parse = function(e) {
    var that = this;
    return this.combineManager.combineModels().then(function() {
      return new Promise(function(results, saveNotifs) {
        var n = that.parseWorld(e);
        if (n ? that._nestingLoopYield(n, function() {
          results();
        }, function(notifications) {
          saveNotifs(notifications);
        }) : results(), e.camInfo && that.isCamFitScene) {
          var f = e.camInfo;
          that.parseCamInfo(f);
        }
      });
    });
  }, init.prototype.parseCamInfo = function(data) {
    var t = data.eye;
    var i = data.target;
    var filem = t.split(" ");
    var cmd_s = i.split(" ");
    var songsHeaders = [Number(filem[0]), Number(filem[1]), Number(filem[2])];
    songsHeaders[2] = -songsHeaders[2];
    var delegatorRoot = [Number(cmd_s[0]), Number(cmd_s[1]), Number(cmd_s[2])];
    delegatorRoot[2] = -delegatorRoot[2];
    this.app.camera.position = songsHeaders;
    this.app.camera.target = delegatorRoot;
  }, init.prototype.parseWorld = function(options) {
    function update(target) {
      var maxvalue;
      var ajaxInterval;
      var obj;
      var str;
      var i;
      var v;
      var l;
      var packages;
      var p;
      return g.wrap(function(_context3) {
        for (;;) {
          switch(_context3.prev = _context3.next) {
            case 0:
              maxvalue = conf.loadSpeed;
              ajaxInterval = 10;
              obj = target.keys();
              str = Array.isArray(obj);
              i = 0;
              obj = str ? obj : obj[Symbol.iterator]();
            case 3:
              if (!str) {
                _context3.next = 9;
                break;
              }
              if (!(i >= obj.length)) {
                _context3.next = 6;
                break;
              }
              return _context3.abrupt("break", 24);
            case 6:
              v = obj[i++];
              _context3.next = 13;
              break;
            case 9:
              if (!(i = obj.next()).done) {
                _context3.next = 12;
                break;
              }
              return _context3.abrupt("break", 24);
            case 12:
              v = i.value;
            case 13:
              l = v;
              packages = target.get(l);
              p = 0;
            case 16:
              if (!(p < packages.length)) {
                _context3.next = 22;
                break;
              }
              return _context3.next = 19, new Promise(function(saveNotifs, canCreateDiscussions) {
                var dec_step = performance.now();
                packages[p].build();
                var o = packages[p].combineMesh;
                l.miscNode.add(o);
                if (performance.now() - dec_step > maxvalue) {
                  setTimeout(function() {
                    saveNotifs();
                  }, ajaxInterval);
                } else {
                  saveNotifs();
                }
              });
            case 19:
              p++;
              _context3.next = 16;
              break;
            case 22:
              _context3.next = 3;
              break;
            case 24:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee, this);
    }
    var _callee = g.mark(update);
    if (options.outdoors && this.parseOutdoors(options.outdoors), options.buildings) {
      var data = options.buildings;
      var key;
      for (key in data) {
        var self = data[key];
        var f = new THREE.Vector3(0, 0, 0);
        var s = key;
        var a = void 0;
        if (self.id) {
          a = self.id;
        }
        if (self.name) {
          s = self.name;
        }
        var obj = self.properties;
        var values = null;
        if (obj) {
          var key;
          for (key in values = {}, obj) {
            var newVal = obj[key];
            values[key] = newVal;
          }
        }
        if (self.position) {
          var p = self.position;
          f.x = p[0];
          f.y = p[1];
          f.z = -p[2];
        }
        var slideDragNode = new THREE.Object3D;
        var options = this.app.objectManager.create({
          type : "Building",
          name : s,
          id : a,
          properties : values,
          parent : this.campus,
          node : slideDragNode
        });
        if (options.app = this.app, options.node.position.x = f.x, options.node.position.y = f.y, options.node.position.z = f.z, self.facades) {
          var docs = self.facades;
          var docRef;
          for (docRef in docs) {
            this.createThing(docs[docRef], options, null, "Facade");
          }
        }
        if (self.facadegroups) {
          var order = self.facadegroups;
          var i;
          for (i in order) {
            var current = order[i];
            this.createGroup(current, options, "Facade");
          }
        }
        if (self.plans) {
          this.parseFloorPlans(self.plans, options);
        }
      }
    }
    var conf = this;
    if (this.isDelayLoadFloorPlan) {
      var buffer = new Map;
      var h = this.combineManager.processorMap.get(this.outdoors);
      if (h) {
        buffer.set(this.outdoors, h);
      }
      var a = this.combineManager.processorMap.keys();
      var dir = Array.isArray(a);
      var i = 0;
      a = dir ? a : a[Symbol.iterator]();
      for (;;) {
        var _ref;
        if (dir) {
          if (i >= a.length) {
            break;
          }
          _ref = a[i++];
        } else {
          if ((i = a.next()).done) {
            break;
          }
          _ref = i.value;
        }
        var store = _ref;
        if (store != this.outdoors) {
          store.isLoaded = false;
        }
      }
      return update(buffer);
    }
    return update(this.combineManager.processorMap);
  }, init.prototype.parseOutdoors = function(testItemData) {
    var slideDragNode = new THREE.Object3D;
    this.outdoors = this.app.objectManager.create({
      type : "Outdoors",
      name : "Outdoors",
      parent : this.campus,
      node : slideDragNode
    });
    if (!this.app.outdoors) {
      this.app.outdoors = this.outdoors;
      this.app.currentParentObject = this.outdoors;
    }
    this.processFloorPlanData(testItemData, this.outdoors);
  }, init.prototype.processFloorPlanData = function(data, result) {
    result.app = this.app;
    var obj = new THREE.Vector3(0, 0, 0);
    if (data.position) {
      var v = data.position;
      obj.x = v[0];
      obj.y = v[1];
      obj.z = -v[2];
    }
    result.node.position.x = obj.x;
    result.node.position.y = obj.y;
    result.node.position.z = obj.z;
    result.node.updateMatrixWorld();
    result.node.updateMatrix();
    this.parseStructure(data, result);
    if (data.placements) {
      this.parseCombineProcessors(result, data.placements, [], [], []);
      this.parseThings(data.placements, result, obj);
    }
    if (data.videoprobes) {
      this.parseThings(data.videoprobes, result, obj);
    }
    if (data.groups) {
      this.parseGroups(data.groups, result, [], [], [], obj);
    }
    if (data.doororwindows) {
      this.parseDoorWins(data.doororwindows, result, obj);
    }
    if (data.rooms) {
      this.parseRooms(data.rooms, result);
    }
    if (data.routes) {
      this.parseStructureThing(data.routes, result);
    }
    if (data.pipelines) {
      this.parseStructureThing(data.pipelines, result);
    }
    if (data.curvelines) {
      this.parseStructureThing(data.curvelines, result);
    }
    if (data.arrowlines) {
      this.parseStructureThing(data.arrowlines, result);
    }
    if (data.arrowdatalines) {
      this.parseStructureThing(data.arrowdatalines, result);
    }
    if (data.leakwaterlines) {
      this.parseStructureThing(data.leakwaterlines, result);
    }
  }, init.prototype.parseRooms = function(el, t) {
    var i = 0;
    for (; i < el.length; i++) {
      var data = el[i];
      var n = null;
      if (data.name) {
        n = data.name;
      }
      if (el.id) {
        el.id;
      }
      var node = null;
      var index = data.gltfid;
      if (index && this.nodes[index]) {
        node = this.nodes[index];
      }
      var properties = null;
      var obj = data.properties;
      if (obj) {
        var key;
        for (key in properties = {}, obj) {
          var val = obj[key];
          properties[key] = val;
        }
      }
      var teaser = null;
      var _ref3 = null;
      var obj2 = null;
      if (data.floor) {
        index = data.floor.gltfid;
        if (this.nodes[index]) {
          obj2 = this.nodes[index];
        }
      }
      if (data.ceiling) {
        index = data.ceiling.gltfid;
        if (this.nodes[index]) {
          teaser = this.nodes[index];
        }
      }
      if (data.roof) {
        index = data.roof.gltfid;
        if (this.nodes[index]) {
          _ref3 = this.nodes[index];
        }
      }
      var now = data.isShown;
      if (now) {
        var visible = "false" !== (now = now.toLowerCase());
        node.visible = visible;
      }
      var offset = null;
      var area = null;
      var y = null;
      var self = {};
      if (data.area && (area = data.area, self.area = area), data.circumference && (y = data.circumference, self.circumference = y), data.center) {
        var p2 = data.center;
        (offset = new THREE.Vector3).set(p2[0], p2[1], -p2[2]);
        self.center = offset;
      }
      this.app.objectManager.create({
        type : "Room",
        name : n,
        node : node,
        ceilingNode : teaser,
        roofNode : _ref3,
        floorNode : obj2,
        parent : t,
        properties : properties,
        auxiliaryInfo : self
      });
    }
  }, init.prototype.parseCombineProcessors = function(nodes, results, format, r, author) {
    var i;
    for (i in results) {
      var s = results[i];
      if (!s.name && !s.properties) {
        var val = this.app.modelResource.bundleIDArray[s.model].uri;
        if (!val) {
          val = this.app.modelResource.bundleIDArray[s.model].id;
        }
        var a = new THREE.Vector3(0, 0, 0);
        if (s.position) {
          var m = s.position;
          a.x = m[0];
          a.y = m[1];
          a.z = -m[2];
        }
        var args = new THREE.Vector3(1, 1, 1);
        if (s.scale) {
          var zxy = s.scale;
          args.x = zxy[0];
          args.y = zxy[1];
          args.z = zxy[2];
        }
        var p = new THREE.Quaternion(0, 0, 0, 1);
        if (s.rotation) {
          var arr = s.rotation;
          p.x = arr[0];
          p.y = arr[1];
          p.z = -arr[2];
          p.w = -arr[3];
        }
        var f = format.slice();
        var m = r.slice();
        var g = author.slice();
        g.push(p);
        m.push(args);
        f.push(a);
        this.combineManager.addPlacement(nodes, val, f, m, g);
      }
    }
  }, init.prototype.parseStructure = function(data, that) {
    that.node.updateMatrixWorld();
    var p2 = that.node.position;
    var p1 = new THREE.Vector3;
    if (that.parent && !that.isOutdoors) {
      p1 = that.parent.node.position;
    }
    var globalBonePosition = new THREE.Vector3(p1.x + p2.x, p1.y + p2.y, p1.z + p2.z);
    if (data.structure) {
      var walls = (data = data.structure).walls;
      if (walls) {
        var s = new THREE.Group;
        var key;
        for (key in s.name = "structurnWall", walls) {
          var id = walls[key].gltfid;
          var obj = this.nodes[id];
          obj.traverse(function(self) {
            if (self.material) {
              self.material.defines = self.material.defines || {};
              self.material.defines.WALL_AO = true;
              self.material.metalness = .2;
              self.material.roughness = .8;
              self.material.needsUpdate = true;
            }
          });
          if (obj) {
            s.add(obj);
          }
        }
        that.node.add(s);
        s.position.set(-globalBonePosition.x, -globalBonePosition.y, -globalBonePosition.z);
        that.wallNode = s;
      }
      var obj = data.roofs;
      if (obj) {
        var p = new THREE.Group;
        for (key in p.name = "structurnRoof", obj) {
          id = obj[key].gltfid;
          var n = this.nodes[id];
          if (n) {
            p.add(n);
          }
        }
        that.node.add(p);
        p.position.set(-globalBonePosition.x, -globalBonePosition.y, -globalBonePosition.z);
        that.roofNode = p;
      }
      var modelElementPath = data.ceilings;
      if (modelElementPath) {
        var f = new THREE.Group;
        for (key in f.name = "structureCeiling", modelElementPath) {
          id = modelElementPath[key].gltfid;
          var p = this.nodes[id];
          if (p) {
            f.add(p);
          }
        }
        that.node.add(f);
        f.position.set(-globalBonePosition.x, -globalBonePosition.y, -globalBonePosition.z);
        that.ceilNode = f;
      }
      if (temp = data.floors) {
        var g = new THREE.Group;
        for (key in g.name = "structureFloor", temp) {
          var temp;
          if (id = (temp = temp[key]).gltfid) {
            var obj = this.nodes[id];
            obj.traverse(function(self) {
              if (self.material) {
                self.material.roughness = .9;
                self.material.needsUpdate = true;
              }
            });
            if (obj) {
              g.add(obj);
            }
          }
        }
        that.node.add(g);
        g.position.set(-globalBonePosition.x, -globalBonePosition.y, -globalBonePosition.z);
        that.floorNode = g;
      }
      var s = new THREE.Group;
      s.name = "structurePlacement";
      that.miscNode = s;
      that.node.add(s);
      if (!that.floorNode) {
        that.floorNode = s;
      }
      s.updateMatrixWorld();
      s.updateMatrix();
      s.position.set(0, 0, 0);
      var makeForModelDeferDfds = data.placements;
      if (makeForModelDeferDfds) {
        for (key in makeForModelDeferDfds) {
          id = makeForModelDeferDfds[key].gltfid;
          var p = this.nodes[id];
          if (p) {
            s.add(p);
          }
        }
      }
      if (data.routes) {
        this.parseStructureThing(data.routes, that);
      }
      if (data.pipelines) {
        this.parseStructureThing(data.pipelines, that);
      }
      if (data.curvelines) {
        this.parseStructureThing(data.curvelines, that);
      }
      if (data.arrowlines) {
        this.parseStructureThing(data.arrowlines, that);
      }
      if (data.arrowdatalines) {
        this.parseStructureThing(data.arrowdatalines, that);
      }
      if (data.leakwaterlines) {
        this.parseStructureThing(data.leakwaterlines, that);
      }
    }
  }, init.prototype.parseDoorWins = function(points, data, instance) {
    new THREE.Group("doors");
    var i;
    for (i in points) {
      var entry = points[i];
      var id = i;
      if (entry.name) {
        id = entry.name;
      }
      var a = null;
      if (entry.gltfid) {
        var id = entry.gltfid;
        if (this.nodes[id]) {
          a = this.nodes[id];
          data.node.add(a);
        }
      }
      var values = null;
      if (entry.properties) {
        var obj = entry.properties;
        var key;
        for (key in values = {}, obj) {
          var newVal = obj[key];
          values[key] = newVal;
        }
      }
      this.app.objectManager.create({
        type : "Door",
        name : id,
        node : a,
        parent : data,
        properties : values
      });
    }
  }, init.prototype.parseGroups = function(el, t, data, category, items, date) {
    var prop;
    for (prop in el) {
      var current = el[prop];
      if (current.name || current.properties) {
        this.createGroup(current, t);
      } else {
        this.combineGroup(current, t, data, category, items, date);
      }
    }
  }, init.prototype.createGroup = function(obj, content) {
    var i;
    var allProperties;
    var GET_USER_PROFILE_SUCCESS = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "Thing";
    var o = this.instanceGroup(obj);
    if (obj.id) {
      obj.id;
    }
    if (obj.name) {
      i = obj.name;
    }
    var meta = obj.properties;
    if (meta) {
      var i;
      for (i in allProperties = {}, meta) {
        var prop = meta[i];
        allProperties[i] = prop;
      }
    }
    var group = this.app.objectManager.create({
      type : GET_USER_PROFILE_SUCCESS,
      name : i,
      node : o,
      parent : content,
      properties : allProperties
    });
    return group;
  }, init.prototype.parseFloorPlans = function(params, obj) {
    var wikis = [];
    var i = 0;
    for (; i < params.length; i++) {
      var element = params[i];
      var doc_id = element.id;
      var item_name = "";
      if (element.name) {
        item_name = element.name;
      }
      var fooNode = new THREE.Object3D;
      var page = this.app.objectManager.create({
        type : "Floor",
        name : item_name,
        id : doc_id,
        node : fooNode,
        parent : obj
      });
      fooNode.name = "floorPlan";
      if (0 != obj.facades.length) {
        page.node.visible = false;
      }
      obj.node.add(page.node);
      obj.node.updateMatrixWorld();
      obj.node.updateMatrix();
      this.processFloorPlanData(element, page);
      wikis.push(page);
    }
    return wikis;
  }, init.prototype.parseBundleList = function(coins) {
    this.app.modelResource.bundleIDArray = coins;
    var index = 0;
    var req = this;
    return new Promise(function(saveNotifs, directiveNormalize) {
      if (0 !== coins.length) {
        coins.forEach(function(p) {
          if (name = p.uri) {
            var loader = new thingjs.GLTFLoader;
            loader.setCrossOrigin("anonymous");
            loader.load(req.baseURL + "/" + name, function(options) {
              index++;
              var i = null;
              if (-1 !== options.asset.generator.indexOf("Unity")) {
                i = options.scene.children[0].children[0];
                req.app.modelResource.set(name, i, options.animations);
              } else {
                i = options.scene.children[0];
                req.app.modelResource.set(name, i, options.animations);
              }
              req.addEnvMap(i);
              if (index === coins.length) {
                saveNotifs();
              }
            }, function() {
            }, function(canCreateDiscussions) {
              directiveNormalize("can not load " + req.baseURL + "/" + name);
            });
          } else {
            var a = p.id;
            var state = p.version;
            var name = "http://model.3dmomoda.com/models/" + a + "/" + state + "/gltf/";
            var that = new THREE.FileLoader;
            that.setResponseType("json");
            that.load(name + "index.json", function(canCreateDiscussions) {
              var i = canCreateDiscussions.gltfFiles[0];
              var loader = new thingjs.GLTFLoader;
              loader.setCrossOrigin("anonymous");
              loader.load(name + i, function(scope) {
                index++;
                req.app.modelResource.set(a, scope.scene.children[0], scope.animations);
                if (index === coins.length) {
                  saveNotifs();
                }
              }, function() {
              }, function(canCreateDiscussions) {
                directiveNormalize("can not load " + req.baseURL + "/" + name);
              });
            });
          }
        });
      } else {
        saveNotifs();
      }
    });
  }, init.prototype.combineGroup = function(options, val, size, s, v, spec) {
    var opts = options;
    var a = new THREE.Vector3(0, 0, 0);
    if (opts.position) {
      var m = opts.position;
      a.x = m[0];
      a.y = m[1];
      a.z = -m[2];
    }
    var e = new THREE.Vector3(1, 1, 1);
    if (opts.scale) {
      var data = opts.scale;
      e.x = data[0];
      e.y = data[1];
      e.z = data[2];
    }
    var l;
    var d = new THREE.Quaternion(0, 0, 0, 1);
    if (opts.rotation) {
      data = opts.rotation;
      d.x = data[0];
      d.y = data[1];
      d.z = -data[2];
      d.w = -data[3];
    }
    if (v ? (l = size.slice(), data = s.slice(), m = v.slice()) : (l = [], m = [], data = []), l.push(e), m.push(a), data.push(d), opts.placements && this.parseCombineProcessors(val, opts.placements, m, l, data), opts.groups) {
      var j;
      for (j in opts.groups) {
        this.combineGroup(opts.groups[j], val, l, data, m, spec);
      }
    }
  }, init.prototype.instanceGroup = function(opts) {
    var p = new THREE.Vector3(0, 0, 0);
    if (opts.position) {
      var m = opts.position;
      p.x = m[0];
      p.y = m[1];
      p.z = -m[2];
    }
    var param = new THREE.Vector3(1, 1, 1);
    if (opts.scale) {
      var data = opts.scale;
      param.x = data[0];
      param.y = data[1];
      param.z = data[2];
    }
    var params = new THREE.Quaternion(0, 0, 0, 1);
    if (opts.rotation) {
      data = opts.rotation;
      params.x = data[0];
      params.y = data[1];
      params.z = -data[2];
      params.w = -data[3];
    }
    var cube = new THREE.Group;
    if (opts.placements) {
      var i;
      for (i in opts.placements) {
        var script = this.instanceChildOfGroup(opts.placements[i]);
        cube.add(script);
      }
    }
    if (opts.groups) {
      for (i in opts.groups) {
        script = this.instanceGroup(opts.groups[i]);
        cube.add(script);
      }
    }
    return cube.scale.copy(param), cube.setRotationFromQuaternion(params), cube.position.copy(p), cube;
  }, init.prototype.instanceChildOfGroup = function(options) {
    var url = this.app.modelResource.bundleIDArray[options.model].uri;
    if (!url) {
      url = this.app.modelResource.bundleIDArray[options.model].id;
    }
    var cube = this.app.modelResource.get(url).node.clone();
    if (options.scale) {
      var value = options.scale;
      cube.scale.x = value[0];
      cube.scale.y = value[1];
      cube.scale.z = value[2];
    }
    if (options.rotation) {
      value = options.rotation;
      var params = new THREE.Quaternion;
      params.x = value[0];
      params.y = value[1];
      params.z = -value[2];
      params.w = -value[3];
      cube.setRotationFromQuaternion(params);
    }
    if (options.position) {
      value = options.position;
      cube.position.x = value[0];
      cube.position.y = value[1];
      cube.position.z = -value[2];
    }
    return cube;
  }, init.prototype.parseThings = function(config, value, target) {
    var name;
    for (name in config) {
      var command = config[name];
      if (command.name || command.properties || command.type) {
        this.createThing(command, value, target);
      }
    }
  }, init.prototype.createThing = function(options, obj, position) {
    var r;
    var n;
    var arrayValueHash;
    var token = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "Thing";
    if (options.id) {
      r = options.id;
    }
    var character = options.type || token;
    if (options.name) {
      n = options.name;
    }
    var localContext = options.properties;
    if (localContext) {
      var graphVariable;
      for (graphVariable in arrayValueHash = {}, localContext) {
        var originalVarValue = localContext[graphVariable];
        arrayValueHash[graphVariable] = originalVarValue;
      }
    }
    var url = this.app.modelResource.bundleIDArray[options.model].uri;
    if (!url) {
      url = this.app.modelResource.bundleIDArray[options.model].id;
    }
    var fold = this.app.modelResource.get(url).node;
    var b = fold.clone();
    var animations = this.app.modelResource.get(url).animations;
    if (options.position) {
      var point = options.position;
      var globalBonePosition = new THREE.Vector3(point[0], point[1], -point[2]);
      b.position.x = globalBonePosition.x;
      b.position.y = globalBonePosition.y;
      b.position.z = globalBonePosition.z;
    }
    if (options.rotation) {
      var args = options.rotation;
      var out = new THREE.Quaternion;
      out.x = args[0];
      out.y = args[1];
      out.z = -args[2];
      out.w = -args[3];
      b.setRotationFromQuaternion(out);
    }
    if (options.scale) {
      var data = options.scale;
      var properties = new THREE.Vector3;
      properties.x = data[0];
      properties.y = data[1];
      properties.z = data[2];
      b.scale.x = properties.x;
      b.scale.y = properties.y;
      b.scale.z = properties.z;
    }
    var now = options.isShown;
    if (now) {
      var v = "false" !== (now = now.toLowerCase());
      b.visible = v;
    }
    var mesh = this.app.objectManager.create({
      type : character,
      id : r,
      name : n,
      node : b,
      parent : obj,
      animations : animations,
      properties : arrayValueHash
    });
    return mesh;
  }, init.prototype.parseStructureThing = function(c, t, scale) {
    var s;
    for (s in c) {
      var x = c[s];
      if (x.gltfid) {
        var data = new fr(this.app);
        data.name = s;
        data.app = this.app;
        if (x.id) {
          data.id = x.id;
        }
        if (x.name) {
          data.name = x.name;
        }
        var child = x.gltfid;
        if (this.nodes[child]) {
          var obj = this.nodes[child];
          t.node.add(obj);
          data.node = obj;
          t.add(data);
          if (scale) {
            obj.position.x = scale.x;
            obj.position.y = scale.y;
            obj.position.z = scale.z;
          }
        }
      }
    }
  }, init.prototype.delayLoadFloorPlan = function(a) {
    function update(b) {
      var pos;
      var ajaxInterval;
      var i;
      return g.wrap(function(context$5$0) {
        for (;;) {
          switch(context$5$0.prev = context$5$0.next) {
            case 0:
              pos = stream.loadSpeed;
              ajaxInterval = 10;
              i = 0;
            case 3:
              if (!(i < b.length)) {
                context$5$0.next = 9;
                break;
              }
              return context$5$0.next = 6, new Promise(function(saveNotifs, i) {
                var lastIndexMessage = performance.now();
                b[i].build();
                var l = b[i].combineMesh;
                a.miscNode.add(l);
                if (performance.now() - lastIndexMessage > pos) {
                  setTimeout(function() {
                    saveNotifs();
                  }, ajaxInterval);
                } else {
                  saveNotifs();
                }
              });
            case 6:
              i++;
              context$5$0.next = 3;
              break;
            case 9:
            case "end":
              return context$5$0.stop();
          }
        }
      }, _callee, this);
    }
    var _callee = g.mark(update);
    var stream = this;
    var t = null;
    var n = null;
    return a.isLoaded || (t = this.combineManager.processorMap.get(a), n = update(t)), new Promise(function(negater, saveNotifs) {
      if (n) {
        stream._nestingLoopYield(n, function() {
          a.isLoaded = true;
          negater();
        }, function(notifications) {
          saveNotifs(notifications);
        });
      } else {
        if (a.isLoaded) {
          THING.Utils.warn("floorplan " + a.id + " has been loaded!");
        } else {
          saveNotifs();
        }
      }
    });
  }, init;
}();
fs = function(e) {
  function d(row, f) {
    return r(this, d), s(this, e.call(this, row, f));
  }
  return o(d, e), d.prototype.parseDoorWins = function(t, value, target) {
    new THREE.Group("doors");
    var e;
    for (e in t) {
      var g = t[e];
      if (!g.type) {
        g.type = "Door";
      }
      this.createThing(g, value, target);
    }
  }, d;
}(ds);
ms = function() {
  function render(App) {
    r(this, render);
    this.app = App;
    this.nodes = [];
    this.scene = this.app.scene;
    this.objectPool = this.app.objectPool;
    this.rootNode = null;
    this.campus = null;
    this.sceneURL = null;
    this.sceneJsonData = null;
    this.loadedSceneGLTF = null;
    this.worldNode = new THREE.Object3D;
    this.fitCamInfo = null;
  }
  return render.prototype.parse = function(v) {
    var i;
    for (i in v) {
      if ("objects" == i) {
        var data = v.objects;
        var id;
        for (id in data) {
          var response = data[id];
          this.parseWorld(response);
          break;
        }
      } else {
        if ("camInfo" == i) {
          var vval = v[i];
          this.fitCamInfo = vval;
        } else {
          THING.Utils.log("unkown other parser: " + i);
        }
      }
    }
  }, render.prototype.parseCamInfo = function(data) {
    var t = data.eye;
    var i = data.target;
    var filem = t.split(" ");
    var cmd_s = i.split(" ");
    var songsHeaders = [Number(filem[0]), Number(filem[1]), Number(filem[2])];
    songsHeaders[2] = -songsHeaders[2];
    var delegatorRoot = [Number(cmd_s[0]), Number(cmd_s[1]), Number(cmd_s[2])];
    delegatorRoot[2] = -delegatorRoot[2];
    this.app.camera.position = songsHeaders;
    this.app.camera.target = delegatorRoot;
  }, render.prototype.parseWorld = function(data) {
    var slideDragNode = this.worldNode;
    if (null == this.campus && (this.campus = this.app.objectManager.create({
      type : "Campus",
      name : "Campus",
      node : slideDragNode
    }), this.campus.node.name = "campus", this.app.scene.add(this.campus.node)), data.plan && this.parseOutdoors(data.plan), data.bds) {
      var instances = data.bds;
      this.parseBuildings(instances);
    }
  }, render.prototype.parseOutdoors = function(importedPages) {
    var self = null;
    var importedPageName;
    for (importedPageName in importedPages) {
      self = importedPages[importedPageName];
      break;
    }
    var slideDragNode = new THREE.Object3D;
    this.outdoors = this.app.objectManager.create({
      type : "Outdoors",
      name : "Outdoors",
      parent : this.campus,
      node : slideDragNode
    });
    var file = this.outdoors;
    var id = self.gltfid;
    if (id && this.nodes[id]) {
      var node = this.nodes[id];
      THREE.SceneUtils.detach(node, node.parent, this.app.scene);
      THREE.SceneUtils.attach(node, this.app.scene, file.node);
      file.node.updateMatrixWorld();
    }
    this.parseFloorPlan(self, file);
  }, render.prototype.parseBuildings = function(data) {
    var id;
    for (id in data) {
      var response = data[id];
      var a = null;
      if (response.gltfid) {
        var id = response.gltfid;
        if (this.nodes[id]) {
          a = this.nodes[id];
        }
      }
      var o = this.app.objectManager.create({
        type : "Building",
        name : id,
        parent : this.campus,
        node : a
      });
      if (response.plans) {
        this.parseFloorPlans(response.plans, o);
      }
      if (response.facades) {
        this.parseFacades(response.facades, o);
      }
    }
  }, render.prototype.parseFloorPlans = function(parsed, path) {
    var p;
    for (p in parsed) {
      var a = null;
      var page = parsed[p];
      var id = page.gltfid;
      if (id && this.nodes[id]) {
        a = this.nodes[id];
      }
      var s = this.app.objectManager.create({
        type : "Floor",
        name : p,
        node : a,
        parent : path
      });
      this.parseFloorPlan(page, s);
    }
  }, render.prototype.parseFloorPlan = function(self, token) {
    if (self.plcs) {
      this.parseThings(self.plcs, token);
    }
    if (self.vps) {
      this.parseThings(self.vps, token);
    }
    if (self.dws) {
      this.parseDoorWins(self.dws, token);
    }
    if (self.routes) {
      this.parseThings(self.routes, token);
    }
    if (self.pipelines) {
      this.parseThings(self.pipelines, token);
    }
    if (self.curvelines) {
      this.parseThings(self.curvelines, token);
    }
    if (self.arrowlines) {
      this.parseThings(self.arrowlines, token);
    }
    if (self.arrowdatalines) {
      this.parseThings(self.arrowdatalines, token);
    }
    if (self.leakwaterlines) {
      this.parseThings(self.leakwaterlines, token);
    }
    var egressPerm = self.cplcs;
    if (egressPerm) {
      var i;
      for (i in egressPerm) {
        var j = egressPerm[i].gltfid;
        var cur = this.nodes[j];
        if (cur) {
          token.miscNode = cur.parent;
          break;
        }
      }
    }
    var s = self.cwalls;
    if (s) {
      for (i in s) {
        j = s[i].gltfid;
        var cur = this.nodes[j];
        if (cur) {
          token.wallNode = cur.parent;
          break;
        }
      }
    }
    var l = self.croofs;
    if (l) {
      for (i in l) {
        j = l[i].gltfid;
        var cur = this.nodes[j];
        if (cur) {
          token.roofNode = cur.parent;
          break;
        }
      }
    }
    var c = self.cceilings;
    if (c) {
      for (i in c) {
        j = c[i].gltfid;
        var cur = this.nodes[j];
        if (cur) {
          token.ceilingNode = cur.parent;
          break;
        }
      }
    }
    if (input = self.cfloors) {
      for (i in input) {
        var input;
        if (j = (input = input[i]).gltfid) {
          var cur = this.nodes[j];
          if (cur) {
            token.floorNode = cur.parent;
            break;
          }
        }
      }
    }
    var groups = self.groups;
    if (groups) {
      this.parseGroup(groups, token);
    }
  }, render.prototype.parseGroup = function(str, token) {
    var i;
    for (i in str) {
      var item = str[i];
      var value = i;
      if (item.uid) {
        value = item.uid;
      }
      var GET_USER_PROFILE_SUCCESS = item.type || "Thing";
      var node = null;
      var nodeName = item.gltfid;
      if (nodeName && this.nodes[nodeName]) {
        node = this.nodes[nodeName];
      }
      var properties = null;
      var d = item.prop;
      if (d) {
        var prop;
        for (prop in properties = {}, d) {
          var val = d[prop];
          properties[prop] = val;
        }
      }
      this.app.objectManager.create({
        type : GET_USER_PROFILE_SUCCESS,
        name : value,
        node : node,
        parent : token,
        properties : properties
      });
      if (item.plcs) {
        this.parseThings(item.plcs, token);
      }
    }
  }, render.prototype.parseFacades = function(o, t) {
    var i;
    for (i in o) {
      var node = o[i];
      var value = i;
      if (node.uid) {
        value = node.uid;
      }
      var obj = null;
      var id = node.gltfid;
      if (id && this.nodes[id]) {
        obj = this.nodes[id];
      }
      var arrayValueHash = null;
      var localContext = node.prop;
      if (localContext) {
        var graphVariable;
        for (graphVariable in arrayValueHash = {}, localContext) {
          var originalVarValue = localContext[graphVariable];
          arrayValueHash[graphVariable] = originalVarValue;
        }
      }
      var now = node.isShown;
      if (now) {
        var groupVisible = "false" !== (now = now.toLowerCase());
        obj.visible = groupVisible;
      }
      this.app.objectManager.create({
        type : "Facade",
        name : value,
        node : obj,
        parent : t,
        properties : arrayValueHash
      });
      t.node.add(obj);
    }
  }, render.prototype.parseThings = function(attributes, device) {
    var i;
    for (i in attributes) {
      var node = attributes[i];
      var value = i;
      if (node.uid) {
        value = node.uid;
      }
      var item = null;
      var id = node.gltfid;
      if (id && this.nodes[id]) {
        item = this.nodes[id];
      }
      var ret = null;
      var d = node.prop;
      if (d) {
        var i;
        for (i in ret = {}, d) {
          var b = d[i];
          ret[i] = b;
        }
      }
      var now = node.isShown;
      if (now) {
        var shouldShow = "false" !== (now = now.toLowerCase());
        item.visible = shouldShow;
      }
      this.app.objectManager.create({
        type : "Thing",
        name : value,
        node : item,
        parent : device,
        properties : ret
      });
    }
  }, render.prototype.parseDoorWins = function(config, device) {
    var mode;
    for (mode in config) {
      var values = config[mode];
      var value = mode;
      if (values.uid) {
        value = values.uid;
      }
      var node = null;
      if (values.gltfid) {
        var i = values.gltfid;
        if (this.nodes[i]) {
          node = this.nodes[i];
        }
      }
      var ret = null;
      if (values.prop) {
        var d = values.prop;
        var i;
        for (i in ret = {}, d) {
          var b = d[i];
          ret[i] = b;
        }
      }
      this.app.objectManager.create({
        type : "Door",
        name : value,
        node : node,
        parent : device,
        properties : ret
      });
    }
  }, render.prototype.load = function(node) {
    var self = this;
    if ("String" === node.constructor.name) {
      this.sceneURL = node;
    } else {
      if ("Object" === node.constructor.name) {
        var me = node;
        this.sceneURL = me.url;
        if (me.campus) {
          this.campus = me.campus;
          this.worldNode = this.campus.node;
        }
      }
    }
    return new Promise(function($, i) {
      self.loadGLTF().then(function(state) {
        return self.loadedSceneGLTF = state, state.scene.traverse(function(unit) {
          self.nodes[unit.name] = unit;
        }), self.parseSceneJson();
      }).then(function(i) {
        if (self.fitCamInfo) {
          self.parseCamInfo(self.fitCamInfo);
        } else {
          if (self.campus.node) {
            self.app.camera.fit(self.campus);
          }
        }
        $(self.campus);
      }).catch(function() {
        self.campus.node.add(self.loadedSceneGLTF.scene.children[0]);
        if (self.campus) {
          self.app.camera.fit(self.campus);
        }
        $(self.campus);
      });
    });
  }, render.prototype.loadGLTF = function() {
    var pageViewData = this;
    return new Promise(function(saveNotifs, i) {
      var loader = new THREE.GLTFLoader(pageViewData.app.loadingManager);
      loader.setCrossOrigin("anonymous");
      loader.load(pageViewData.sceneURL + "/Unity2GLTF.gltf", function(notifications) {
        saveNotifs(notifications);
      });
    });
  }, render.prototype.parseSceneJson = function() {
    var item = this;
    return new Promise(function(t, saveNotifs) {
      (new THREE.FileLoader(item.app.loadingManager)).load(item.sceneURL + "/scene.json", function(i) {
        var obj = JSON.parse(i);
        var key;
        for (key in item.sceneJsonData = obj, obj) {
          if ("objects" == key) {
            var o = obj.objects;
            var j;
            for (j in o) {
              var url = o[j];
              item.parseWorld(url);
              break;
            }
          } else {
            if ("camInfo" == key) {
              var old_value = obj[key];
              item.fitCamInfo = old_value;
            } else {
              THING.Utils.log("unkown other parser: " + key);
            }
          }
        }
        t(obj);
      }, function() {
      }, function() {
        THING.Utils.error("not find file scene.json ");
        saveNotifs();
      });
    });
  }, render;
}();
gs = "FacadeMain";
vs = "Ground";
ys = "Thing";
bs = "Tree";
_s = "Objects";
xs = "FloorFloor";
Es = "FloorRoof";
ws = "FloorCeiling";
Ts = "FloorManualWall";
Ms = "Door";
function Cs() {
}
Cs.addTHINGJSObjectSfStyle = function(result, value) {
  if (result) {
    var user = result.userData;
    if (user && user._styleTag_) {
      value = user._styleTag_;
    }
    if (value) {
      Cs.addNodeSfStyle(result.node, value);
    }
  }
};
Cs.addThingJsObjectSfStyle = function(obj, arr) {
  if (obj) {
    var options = obj.properties;
    if (options && options._styleTag_) {
      arr = options._styleTag_;
    }
    if (arr) {
      Cs.addNodeSfStyle(obj.mesh, arr);
    }
  }
};
Cs.addJson2meshObjectSfStyle = function(e, num) {
  if (e) {
    var obj = e.properties;
    if (obj && obj._styleTag_) {
      num = obj._styleTag_;
    }
    if (num) {
      Cs.addNodeSfStyle(e.mesh, num);
    }
  }
};
Cs.addPlacementGroupSfStyle = function(data, callback) {
  var array = data.placements;
  if (array) {
    var i = 0;
    for (; i < array.length; i++) {
      var event = array[i];
      var auctionColour = event.resource.modelID;
      var yc = ys;
      if (this.isTree(auctionColour)) {
        yc = bs;
      } else {
        if (this.isWall(auctionColour)) {
          yc = "Outdoors" === callback ? vs : Ts;
        }
      }
      Cs.addJson2meshObjectSfStyle(event, yc);
    }
  }
  var rankTop = data.groups;
  if (rankTop) {
    var i = 0;
    for (; i < rankTop.length; i++) {
      var u = rankTop[i];
      this.addPlacementGroupSfStyle(u);
    }
  }
};
Cs.addNodeSfStyle = function(fn, value) {
  if (fn) {
    var paramNames = Cs.getMeshes(fn);
    if (paramNames && paramNames.length > 0) {
      paramNames.forEach(function(settingElement) {
        settingElement._sfStyle = value;
      });
    }
  }
};
Cs.addBatchCombinePlacementStyle = function(object, def, fn) {
  var plist = null;
  var container = def.properties;
  if (container) {
    if (container._styleTag_) {
      plist = container._styleTag_;
    }
  } else {
    plist = "Outdoors" === def.parent.type ? Cs.isTree(fn) ? bs : Cs.isWall(fn) ? vs : _s : Cs.isTree(fn) ? bs : Cs.isWall(fn) ? Ts : _s;
  }
  Cs.addNodeSfStyle(object.node, plist);
};
Cs.addBatchPlacementStyle = function(data, option, fn) {
  var plist = null;
  var container = option.properties;
  if (container) {
    if (container._styleTag_) {
      plist = container._styleTag_;
    }
  } else {
    plist = "Outdoors" === option.parent.type ? Cs.isTree(fn) ? bs : Cs.isWall(fn) ? vs : ys : Cs.isTree(fn) ? bs : Cs.isWall(fn) ? Ts : ys;
  }
  Cs.addNodeSfStyle(data.node, plist);
};
Cs.getMeshes = function(object) {
  var lsup = [];
  return object.traverse(function(child) {
    if (child.isMesh) {
      lsup.push(child);
    }
  }), lsup;
};
Cs.isWall = function(col) {
  return !!Ss[col];
};
Cs.isTree = function(col) {
  return !!js[col];
};
var Ss = {
  BC4ACD398A9640859A6B386E1BF9231D : {
    id : "BC4ACD398A9640859A6B386E1BF9231D",
    type : "Wall",
    size : [.8, 2.999, .8],
    version : "5"
  },
  "25DFE916055244849463F89A03DA97CD" : {
    id : "25DFE916055244849463F89A03DA97CD",
    type : "Wall",
    size : [.845, 3.099, .849],
    version : "5"
  }
};
js = {
  "3629A959F80C4D0EA31D1E26524735B8" : {
    id : "3629A959F80C4D0EA31D1E26524735B8",
    type : "Placement",
    size : [8.1, 9.60776, 8.7],
    version : "7"
  },
  BB23ED379CFB4A0AB14BD124EC2995BE : {
    id : "BB23ED379CFB4A0AB14BD124EC2995BE",
    type : "Placement",
    size : [.64347, 1.34912, .8],
    version : "7"
  },
  A7D96546FA744C38A949DFC6FEE43B6A : {
    id : "A7D96546FA744C38A949DFC6FEE43B6A",
    type : "Placement",
    size : [.6, 1.1, .6],
    version : "7"
  },
  FA5766D2AA074128ABB5D4CA3FF45B36 : {
    id : "FA5766D2AA074128ABB5D4CA3FF45B36",
    type : "Placement",
    size : [.4, .61599, .39999],
    version : "6"
  },
  "8EC4FF7178E64C538B215D69684E4F92" : {
    id : "8EC4FF7178E64C538B215D69684E4F92",
    type : "Placement",
    size : [.4, .5, .4],
    version : "6"
  },
  "449c02c5e8f84a2aa32f58ed53aa24b9" : {
    id : "449c02c5e8f84a2aa32f58ed53aa24b9",
    type : "Placement",
    size : [.23118, .5986, .24155],
    version : "1"
  },
  c26acc8a9f804d8da2f49aba46283ac3 : {
    id : "c26acc8a9f804d8da2f49aba46283ac3",
    type : "Placement",
    size : [7.85544, 7.80654, 7.44832],
    version : "2"
  },
  "07b2d180e1ea42de98723fe147f6750a" : {
    id : "07b2d180e1ea42de98723fe147f6750a",
    type : "Placement",
    size : [10.3207, 9.84333, 10.0598],
    version : "3"
  },
  "2c969242db5f4da58442182ccbda7471" : {
    id : "2c969242db5f4da58442182ccbda7471",
    type : "Placement",
    size : [7.20139, 25.1363, 6.56474],
    version : "4"
  },
  D26DB25C34C94CAABF24FED40F1A9719 : {
    id : "D26DB25C34C94CAABF24FED40F1A9719",
    type : "Placement",
    size : [8.24071, 19.2, 7.6],
    version : "6"
  },
  "ebafecf0-cc89-42dc-b847-0f841a31bdca" : {
    id : "ebafecf0-cc89-42dc-b847-0f841a31bdca",
    type : "Placement",
    size : [4.94077, 5.83847, 4.78861],
    version : "9"
  },
  "4EF86FC4FFA44013AC4F45E8CD0D343F" : {
    id : "4EF86FC4FFA44013AC4F45E8CD0D343F",
    type : "Placement",
    size : [5.66699, 7.4, 6.233],
    version : "6"
  },
  "9C27FD900C4443FBA1151C9DF767D19A" : {
    id : "9C27FD900C4443FBA1151C9DF767D19A",
    type : "Placement",
    size : [7.50716, 8.2, 7.87936],
    version : "6"
  },
  "6b768c2d-3c2f-4954-a625-ef4b57f72a47" : {
    id : "6b768c2d-3c2f-4954-a625-ef4b57f72a47",
    type : "Placement",
    size : [6.32989, 7.49752, 5.72546],
    version : "8"
  },
  "9fc66d5b-a213-4fc6-9fc6-f759aa88716a" : {
    id : "9fc66d5b-a213-4fc6-9fc6-f759aa88716a",
    type : "Placement",
    size : [4.5, 9.4, 4.4],
    version : "4"
  },
  "963de658-70b6-49e7-bb0e-504ad603fe27" : {
    id : "963de658-70b6-49e7-bb0e-504ad603fe27",
    type : "Placement",
    size : [1.4073, 4.03187, 1.37224],
    version : "5"
  },
  "d5b06cf7-2a31-4252-8d7c-02d48815ed18" : {
    id : "d5b06cf7-2a31-4252-8d7c-02d48815ed18",
    type : "Placement",
    size : [7.3, 7.4, 6.1],
    version : "4"
  },
  "f9058709-ee84-41f6-8260-fbb734dc9483" : {
    id : "f9058709-ee84-41f6-8260-fbb734dc9483",
    type : "Placement",
    size : [4.3, 7.2, 4],
    version : "4"
  },
  "be7d0bfc-ce60-4132-8a88-afd1301c82b3" : {
    id : "be7d0bfc-ce60-4132-8a88-afd1301c82b3",
    type : "Placement",
    size : [4.41539, 7.57112, 4.49063],
    version : "5"
  },
  "95bd04fe237f42e0adeabb78028c8ee7" : {
    id : "95bd04fe237f42e0adeabb78028c8ee7",
    type : "Placement",
    size : [4.41539, 7.57112, 4.49063],
    version : "1"
  },
  "1d2827ffd12b4ac1a2035fa81646a450" : {
    id : "1d2827ffd12b4ac1a2035fa81646a450",
    type : "Placement",
    size : [12.63521, 15.81749, 13.21056],
    version : "3"
  }
};
Ps = function() {
  function a() {
    r(this, a);
    this.world = null;
    this.styleTable = {
      outdoors : {},
      buildings : {}
    };
  }
  return a.prototype.clear = function() {
    this.world = null;
    this.styleTable = {
      outdoors : {},
      buildings : {}
    };
  }, a.prototype.parseWorld = function(json) {
    this._parseObject(json);
  }, a.prototype._parseObject = function(obj) {
    if (obj.registerBuildCallbackListener(this.objectBuildedCallback, {
      loader : this
    }), obj.isContainer) {
      var i = 0;
      for (; i < obj.children.length; i++) {
        var def = obj.children[i];
        this._parseObject(def);
      }
    }
  }, a.prototype.objectBuildedCallback = function(name, item) {
    var loader = item.loader;
    if ("Facade" === name.type || "FacadeGroup" === name.type) {
      loader.facadeBuildCallback(name, item);
    } else {
      if ("Placement" === name.type || "PlacementGround" === name.type) {
        loader.placementBuildCallback(name, item);
      } else {
        if ("DoorOrWindow" === name.type) {
          loader.doorOrWindowBuildCallback(name, item);
        } else {
          if ("VideoProbe" === name.type) {
            loader.videoProbeBuildCallback(name, item);
          } else {
            if ("Room" === name.type) {
              loader.roomBuildCallback(name, item);
            } else {
              if ("PlacementGroup" === name.type) {
                loader.groupBuildCallback(name, item);
              } else {
                if (-1 !== name.type.indexOf("Combine")) {
                  loader.combinedObjectBuildCallback(name, item);
                }
              }
            }
          }
        }
      }
    }
  }, a.prototype.parseBuilding = function(obj) {
    this.parseFacades(obj);
    var t = obj.floorplans;
    var k = 0;
    for (; k < t.length; k++) {
      var f = t[k];
      this.parseFloorPlan(f);
    }
  }, a.prototype.parseFacades = function(response) {
    var attributeNames = response.facades;
    var opLayers = response.facadeGroups;
    var k = 0;
    for (; k < attributeNames.length; k++) {
      attributeNames[k].registerBuildCallbackListener(this.facadeBuildCallback, {
        loader : this
      });
    }
    var i = 0;
    for (; i < opLayers.length; i++) {
      opLayers[i].registerBuildCallbackListener(this.facadeBuildCallback, {
        loader : this
      });
    }
  }, a.prototype.facadeBuildCallback = function(region, entry) {
    entry.loader;
    var container = void 0;
    var data = region.properties;
    if (data) {
      container = data._styleTag_;
    }
    var deprecatedStylingMethods = Cs.getMeshes(region.mesh);
    if (deprecatedStylingMethods && deprecatedStylingMethods.length > 0) {
      deprecatedStylingMethods.forEach(function(instance) {
        instance._sfStyle = container || gs;
      });
    }
  }, a.prototype.parseFloorPlan = function(path) {
    this.parseDoorOrWindows(path);
    this.parseCombineFloors(path);
    this.parseCombineCeilings(path);
    this.parseCombineRoofs(path);
    this.parseCombinePlacements(path);
    this.parseCombineStraightManualWalls(path);
    this.parseCombineModelWalls(path);
    this.parseCombineDoorOrWindows(path);
    this.parseGroups(path);
    this.parsePlacements(path);
    this.parseRooms(path);
    this.parseVideoProbes(path);
    this.parsePlacementGround(path);
    this.parseCombinePlacementWalls(path);
  }, a.prototype.parsePlacementGround = function(element) {
    var i1 = 0;
    for (; i1 < element.placementGrounds.length; i1++) {
      element.placementGrounds[i1].registerBuildCallbackListener(this.placementBuildCallback, {
        loader : this
      });
    }
  }, a.prototype.parseCombineFloors = function(objs) {
    var t = 0;
    for (; t < objs.combineFloorObjects.length; t++) {
      var blockSubParam = objs.combineFloorObjects[t];
      this.registerCombineObjectBuildCallback(blockSubParam, "CombineFloor");
    }
  }, a.prototype.parseCombineCeilings = function(objs) {
    var t = 0;
    for (; t < objs.combineCeilingObjects.length; t++) {
      var blockSubParam = objs.combineCeilingObjects[t];
      this.registerCombineObjectBuildCallback(blockSubParam, "CombineCeiling");
    }
  }, a.prototype.parseCombineRoofs = function(objs) {
    var t = 0;
    for (; t < objs.combineRoofObjects.length; t++) {
      var blockSubParam = objs.combineRoofObjects[t];
      this.registerCombineObjectBuildCallback(blockSubParam, "CombineRoof");
    }
  }, a.prototype.parseCombinePlacements = function(objs) {
    var t = 0;
    for (; t < objs.combinePlacementObjects.length; t++) {
      var blockSubParam = objs.combinePlacementObjects[t];
      this.registerCombineObjectBuildCallback(blockSubParam, "CombinePlacement");
    }
  }, a.prototype.parseCombineStraightManualWalls = function(objs) {
    var t = 0;
    for (; t < objs.combineStraightManualWallObjects.length; t++) {
      var blockSubParam = objs.combineStraightManualWallObjects[t];
      this.registerCombineObjectBuildCallback(blockSubParam, "CombineStraightManualWall");
    }
  }, a.prototype.parseCombineModelWalls = function(objs) {
    var t = 0;
    for (; t < objs.combineModelWallObjects.length; t++) {
      var blockSubParam = objs.combineModelWallObjects[t];
      this.registerCombineObjectBuildCallback(blockSubParam, "CombineModelWall");
    }
  }, a.prototype.parseCombinePlacementWalls = function(objs) {
    var t = 0;
    for (; t < objs.combinePlacementWallObjects.length; t++) {
      var blockSubParam = objs.combinePlacementWallObjects[t];
      this.registerCombineObjectBuildCallback(blockSubParam, "CombinePlacementWall");
    }
  }, a.prototype.parseCombineDoorOrWindows = function(objs) {
    var t = 0;
    for (; t < objs.combineDoorOrWindowObjects.length; t++) {
      var blockSubParam = objs.combineDoorOrWindowObjects[t];
      this.registerCombineObjectBuildCallback(blockSubParam, "CombineDoorOrWindow");
    }
  }, a.prototype.parsePlacements = function(opts) {
    var i = 0;
    for (; i < opts.placements.length; i++) {
      opts.placements[i].registerBuildCallbackListener(this.placementBuildCallback, {
        loader : this
      });
    }
  }, a.prototype.placementBuildCallback = function(event, a) {
    a.loader;
    var fn = event.resource.modelID;
    var y = ys;
    if (Cs.isTree(fn)) {
      y = bs;
    } else {
      if (Cs.isWall(fn)) {
        y = "Outdoors" === event.parent.type ? vs : Ts;
      }
    }
    Cs.addThingJsObjectSfStyle(event, y);
  }, a.prototype.parseDoorOrWindows = function(element) {
    var i1 = 0;
    for (; i1 < element.doorOrWindows.length; i1++) {
      element.doorOrWindows[i1].registerBuildCallbackListener(this.doorOrWindowBuildCallback, {
        loader : this
      });
    }
  }, a.prototype.doorOrWindowBuildCallback = function(fn, data) {
    data.loader;
    if (fn.isWindow) {
      Cs.addThingJsObjectSfStyle(fn, fn.parent instanceof json2mesh.Outdoors ? _s : ys);
    } else {
      Cs.addThingJsObjectSfStyle(fn, fn.parent instanceof json2mesh.Outdoors ? _s : Ms);
    }
  }, a.prototype.parseGroups = function(stack) {
    var i = 0;
    for (; i < stack.groups.length; i++) {
      stack.groups[i].registerBuildCallbackListener(this.groupBuildCallback, {
        loader : this
      });
    }
  }, a.prototype.groupBuildCallback = function(fn, data) {
    data.loader;
    var imsType = fn.parent.type;
    Cs.addPlacementGroupSfStyle(fn, imsType);
  }, a.prototype.parseRooms = function(stats) {
    var i = 0;
    for (; i < stats.rooms.length; i++) {
      stats.rooms[i].registerBuildCallbackListener(this.roomBuildCallback, {
        loader : this
      });
    }
  }, a.prototype.roomBuildCallback = function(data, tree) {
    tree.loader;
    if ("Outdoors" === data.parent.type) {
      Cs.addThingJsObjectSfStyle(data.floor, vs);
    } else {
      Cs.addThingJsObjectSfStyle(data.ceiling, ws);
      Cs.addThingJsObjectSfStyle(data.roof, Es);
      Cs.addThingJsObjectSfStyle(data.floor, xs);
    }
  }, a.prototype.parseVideoProbes = function(element) {
    var i1 = 0;
    for (; i1 < element.videoprobes.length; i1++) {
      element.videoprobes[i1].registerBuildCallbackListener(this.videoProbeBuildCallback, {
        loader : this
      });
    }
  }, a.prototype.videoProbeBuildCallback = function(fn, data) {
    data.loader;
    Cs.addThingJsObjectSfStyle(fn, ys);
  }, a.prototype.registerCombineObjectBuildCallback = function(blockFuncContentParam, type) {
    blockFuncContentParam.registerBuildCallbackListener(this.combinedObjectBuildCallback, {
      loader : this,
      typeName : type
    });
  }, a.prototype.combinedObjectBuildCallback = function(event, a) {
    var target = event;
    var eventStr = event.type;
    a.loader;
    if ("CombineFloor" === eventStr) {
      Cs.addThingJsObjectSfStyle(target, event.parent instanceof json2mesh.Outdoors ? vs : xs);
    } else {
      if ("CombineCeiling" === eventStr) {
        Cs.addThingJsObjectSfStyle(target, ws);
      } else {
        if ("CombineRoof" === eventStr) {
          Cs.addThingJsObjectSfStyle(target, Es);
        } else {
          if ("CombinePlacement" === eventStr) {
            var fn = event.resource.modelID;
            var j = _s;
            if (Cs.isTree(fn)) {
              j = bs;
            } else {
              if (Cs.isWall(fn)) {
                j = "Outdoors" !== event.parent.type ? Ts : vs;
              }
            }
            Cs.addThingJsObjectSfStyle(target, j);
          } else {
            if ("CombineStraightManualWall" === eventStr) {
              Cs.addThingJsObjectSfStyle(target, event.parent instanceof json2mesh.Outdoors ? vs : Ts);
            } else {
              if ("CombineModelWall" === eventStr) {
                Cs.addThingJsObjectSfStyle(target, event.parent instanceof json2mesh.Outdoors ? vs : Ts);
              } else {
                if ("CombineDoorOrWindow" === eventStr) {
                  Cs.addThingJsObjectSfStyle(target, event.parent instanceof json2mesh.Outdoors ? _s : Ms);
                } else {
                  if ("CombinePlacementWall" === eventStr) {
                    Cs.addThingJsObjectSfStyle(target, event.parent instanceof json2mesh.Outdoors ? vs : Ts);
                  } else {
                    if ("CombinePlacementGroup" === eventStr) {
                      var n = _s;
                      Cs.addThingJsObjectSfStyle(target, n);
                    } else {
                      var n = _s;
                      Cs.addThingJsObjectSfStyle(target, n);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }, a;
}();
Rs = function() {
  function Task(options) {
    r(this, Task);
    if (options.config) {
      this.config = options.config;
    }
    this.events = [];
    if (options.events) {
      this.events = options.events;
    }
    this.app = options.app;
    this.creators = [];
  }
  return Task.prototype.clear = function() {
    var i = 0;
    for (; i < this.creators.length; i++) {
      this.creators[i].clear();
    }
    this.events = [];
    this.app = null;
    this.creators = [];
    this.config = [];
  }, Task.prototype.setConfig = function(c) {
    this.config = c;
  }, Task.prototype.createTjsObject = function(d, a) {
    var creator = new (this.config.getClass(d.type))({
      json2meshObject : d,
      app : this.app,
      thingjsParent : a,
      events : this.events,
      config : this.config
    });
    return this.creators.push(creator), creator.create();
  }, Task.prototype.createTjsFacadeObject = function(b, status) {
    var creator = new (this.config.getClass("Facade"))({
      json2meshObject : b,
      json2meshBuilding : b,
      app : this.app,
      thingjsParent : status,
      events : this.events,
      config : this.config
    });
    return this.creators.push(creator), creator.create();
  }, Task;
}();
Ds = function() {
  function handler(options) {
    r(this, handler);
    this.json2meshObject = options.json2meshObject;
    this.app = options.app;
    this.thingjsParent = options.thingjsParent;
    this.createType = null;
    this.thingjsObject = null;
    this.config = options.config;
    this._createdCallbacks = [];
    this._createdCallbackParams = [];
    this._buildedCallbacks = [];
    this._buildedCallbackParams = [];
    if (options.events) {
      this.initEvents(options.events);
    }
  }
  return handler.prototype.clear = function() {
    this.json2meshObject = null;
    this.app = null;
    this.thingjsParent = null;
    this.createType = null;
    this.thingjsObject = null;
    this.config = null;
    this._createdCallbacks = [];
    this._createdCallbackParams = [];
    this._buildedCallbacks = [];
    this._buildedCallbackParams = [];
  }, handler.prototype.initEvents = function(modules) {
    var i = 0;
    for (; i < modules.length; i++) {
      modules[i].init(this);
    }
  }, handler.prototype.create = function() {
    var e = this._getCreateParams();
    return this.thingjsObject = this.config.getCreatedThingjsObject(this.json2meshObject.id), this.thingjsObject ? this._initCreatedThingjsObjectParams(e) : this.thingjsObject = this.app.objectManager.create(e), this.thingjsObject.localPosition = this._getThingjsLocalPosition(), this.thingjsObject.scale = this.json2meshObject.scale, this.thingjsObject.node.quaternion.set(this.json2meshObject.rotation[0], this.json2meshObject.rotation[1], this.json2meshObject.rotation[2], this.json2meshObject.rotation[3]), 
    this.json2meshObject.registerBuildCallbackListener(this._callback, {
      creator : this,
      uuid : this.thingjsObject.uuid
    }), this.json2meshObject.camInfo && (this.thingjsObject.userData.camInfo = this.json2meshObject.camInfo), this._notifyCreatedCompleteListeners(), this._registerChangeTypeEvent(), this.thingjsObject;
  }, handler.prototype._registerChangeTypeEvent = function() {
    var _poolOfSprites = this;
    this.thingjsObject.one("classtypechange", function(sprite) {
      _poolOfSprites._changeTypeCallback(sprite);
    });
  }, handler.prototype._changeTypeCallback = function(imports) {
    this.thingjsObject = imports.newObject;
  }, handler.prototype._getThingjsLocalPosition = function() {
    return this.json2meshObject.position;
  }, handler.prototype._initCreatedThingjsObjectParams = function(obj) {
    this.thingjsObject.uuid = obj.uuid;
    this.thingjsObject.id = obj.id;
    this.thingjsObject.name = obj.name;
  }, handler.prototype.registerCreatedCallbackListener = function(upgrade, version) {
    this._createdCallbacks.push(upgrade);
    this._createdCallbackParams.push(version);
  }, handler.prototype._notifyCreatedCompleteListeners = function() {
    var layer_i = 0;
    for (; layer_i < this._createdCallbacks.length; layer_i++) {
      (0, this._createdCallbacks[layer_i])(this, this._createdCallbackParams[layer_i]);
    }
  }, handler.prototype.registerBuildedCallbackListener = function(change, position) {
    this._buildedCallbacks.push(change);
    this._buildedCallbackParams.push(position);
  }, handler.prototype._notifyBuildedCompleteListeners = function() {
    var layer_i = 0;
    for (; layer_i < this._buildedCallbacks.length; layer_i++) {
      (0, this._buildedCallbacks[layer_i])(this, this._buildedCallbackParams[layer_i]);
    }
  }, handler.prototype._getCreateParams = function() {
    var data = {};
    data.uuid = this.json2meshObject.id;
    if (null !== this.json2meshObject.userID) {
      data.id = this.json2meshObject.userID;
    }
    if (null !== this.json2meshObject.name) {
      data.name = this.json2meshObject.name;
    }
    if (null !== this.json2meshObject.properties) {
      data.properties = this.json2meshObject.properties;
    }
    if (null !== this.thingjsParent && void 0 !== this.thingjsParent) {
      data.parent = this._getParent(this.thingjsParent, this.createType);
    }
    var t = this.createType;
    return this.json2meshObject.jsonData && this.json2meshObject.jsonData.type && (t = this.json2meshObject.jsonData.type), data.type = t, data.loaded = false, data.node = new THREE.Object3D, data.node.name = t, this.json2meshObject.resource && this.json2meshObject.resource.getModelUrl && (data.url = this.json2meshObject.resource.getModelUrl()), data.initBoxSize = this.getJson2MeshObjectSize(), data;
  }, handler.prototype._callback = function(type, data) {
    var textArea = data.creator;
    textArea._processCallback();
    var options = textArea.thingjsObject;
    textArea._notifyBuildedCompleteListeners();
    options.setupResources({
      loaded : true
    });
    data.thingjsObject = options;
  }, handler.prototype._processCallback = function() {
    var scope = this.json2meshObject;
    var morph = this.thingjsObject;
    if (scope.mesh) {
      scope.mesh.position.set(0, 0, 0);
      scope.mesh.quaternion.set(0, 0, 0, 1);
      scope.mesh.scale.set(1, 1, 1);
      morph._addNodeBySceneLoad(scope.mesh);
    }
  }, handler.prototype._createCube = function() {
    var pregeom = new THREE.BoxGeometry(1, 1, 1);
    var wheelAxisMat = new THREE.MeshBasicMaterial({
      color : 65280
    });
    return new THREE.Mesh(pregeom, wheelAxisMat);
  }, handler.prototype._getParent = function(element, value) {
    return null == value && (value = "Thing"), "Ground" === element.type ? "CombinedObject" === value || "BatchObject" === value ? element : element.parent : element;
  }, handler.prototype._isNullOrUndefined = function(key) {
    return null == key;
  }, handler.prototype.getJson2MeshObjectSize = function() {
    return this.json2meshObject.size;
  }, handler;
}();
As = function(callback) {
  function t(string) {
    r(this, t);
    var container = s(this, callback.call(this, string));
    return container.createType = "Campus", container;
  }
  return o(t, callback), t.prototype.create = function() {
    var e = this._getCreateParams();
    return this.thingjsObject = this.config.getCreatedThingjsObject(this.json2meshObject.id), this.thingjsObject ? this._initCreatedThingjsObjectParams(e) : this.thingjsObject = this.app.objectManager.create(e), this.json2meshObject.registerBuildCallbackListener(this._callback, {
      creator : this,
      uuid : this.thingjsObject.uuid
    }), this.json2meshObject.camInfo && (this.thingjsObject.userData.camInfo = this.json2meshObject.camInfo), this._notifyCreatedCompleteListeners(), this._registerChangeTypeEvent(), this.config.campus = this.thingjsObject, this.thingjsObject;
  }, t.prototype._getCreateParams = function() {
    var viewerState = callback.prototype._getCreateParams.call(this);
    return viewerState.loaded = true, viewerState;
  }, t.prototype._initCreatedThingjsObjectParams = function(a22) {
    this.thingjsObject.uuid = this.json2meshObject.id;
    if (this.json2meshObject.userID) {
      this.thingjsObject.id = this.json2meshObject.userID;
    }
    this.thingjsObject._initBoxSize = a22.initBoxSize;
  }, t;
}(Ds);
ks = function(f) {
  function t(rt) {
    r(this, t);
    var builder = s(this, f.call(this, rt));
    return builder.createType = "Building", builder;
  }
  return o(t, f), t.prototype._getCreateParams = function() {
    var viewerState = f.prototype._getCreateParams.call(this);
    return viewerState.loaded = true, viewerState.structShow = this.json2meshObject.structShow, viewerState;
  }, t.prototype.create = function() {
    return f.prototype.create.call(this), this.thingjsObject;
  }, t;
}(Ds);
Os = function(f) {
  function t(rt) {
    r(this, t);
    var builder = s(this, f.call(this, rt));
    return builder.createType = "Floor", builder;
  }
  return o(t, f), t.prototype.create = function() {
    return f.prototype.create.call(this), this._createCombineObjectParent("CombineWallParent"), this._createCombineObjectParent("CombineMiscParent"), this._createCombineObjectParent("CombineRoofParent"), this._createCombineObjectParent("CombineCeilingParent"), this._createCombineObjectParent("CombineFloorParent"), this.thingjsObject;
  }, t.prototype._hidePlanObjs = function(self) {
    if (!self.showObjectsInParentLevels) {
      var locChildren = self._children;
      var i = 0;
      for (; i < locChildren.length; i++) {
        var node = locChildren[i];
        if (node.isCombinedObject && "CombineMiscParent" === node.userData.type) {
          var arr = node._children;
          var i = 0;
          for (; i < arr.length; i++) {
            var error = arr[i];
            if (error.isCombinedObject) {
              if ("CombinePlacement" === error.userData.json2meshType) {
                error.visible = false;
              }
            }
          }
        }
      }
      var child = 0;
      for (; child < self.children.length; child++) {
        var node = self.children[child];
        if (!(node.isDoor || "Room" === node.type)) {
          if (!("Thing" === node.type && node.isWindow)) {
            node.visible = false;
          }
        }
      }
    }
  }, t.prototype._getCreateParams = function() {
    var o = f.prototype._getCreateParams.call(this);
    return o.height = this.json2meshObject.height, o.alwaysShowInsideObjs = this.json2meshObject.alwaysShowInsideObjs, o.initBoxSize = this.json2meshObject.size, o;
  }, t.prototype._createCombineObjectParent = function(crypto_type) {
    var fixtureDef = this.app.objectManager.create({
      node : new THREE.Object3D,
      loaded : true,
      parent : this._getParent(this.thingjsObject, "CombinedObject"),
      type : "CombinedObject"
    });
    fixtureDef.userData.type = crypto_type;
    fixtureDef.userData.isCombineParent = true;
  }, t.prototype._callback = function(type, t) {
    var instance = t.creator;
    var _t = instance.thingjsObject;
    var locChildren = _t._children;
    var i = 0;
    for (; i < locChildren.length; i++) {
      var w = locChildren[i];
      if (w.isCombinedObject) {
        if (!w.loaded) {
          w.setupResources({});
        }
      }
    }
    if (!_t.loaded) {
      _t.setupResources({});
    }
    instance._notifyBuildedCompleteListeners();
  }, t;
}(Ds);
Bs = function(handler) {
  function t(a) {
    r(this, t);
    var self = s(this, handler.call(this, a));
    return self.json2meshObject.jsonData && self.json2meshObject.jsonData.type ? self.createType = self.json2meshObject.jsonData.type : self.createType = "Thing", self;
  }
  return o(t, handler), t.prototype.create = function() {
    var self = handler.prototype.create.call(this);
    self.bundleID = this.json2meshObject.resource.modelID;
    self.bundleName = this.json2meshObject.resource.modelName;
    this._setVisible();
    var i = this.json2meshObject.resource.type;
    return "CustomResource" != i && "CustomModelResource" != i || (this.thingjsObject.node.userData.isCustomResource = true), this.thingjsObject;
  }, t.prototype._setVisible = function() {
    var e = this.thingjsObject;
    if (!("Floor" !== e.parent.type || e.parent.showObjectsInParentLevels)) {
      e.visible = false;
    }
  }, t.prototype._getCreateParams = function() {
    var channel_collection = handler.prototype._getCreateParams.call(this);
    return channel_collection.belongRoomUserID = this.json2meshObject.belongRoomUserID, channel_collection.hideByScene = !this.json2meshObject.visible, channel_collection.url = this.json2meshObject.resource.getModelUrl(), channel_collection;
  }, t.prototype._callback = function(t, args) {
    handler.prototype._callback.call(this, t, args);
    var self = args.thingjsObject;
    if (self.node.name = t.name || "", self._hideByScene = !t.visible, self.setupAnimations({
      model : t.resource.downloadModelRoot
    }), t.isPlayAnim && self.containAnimation(t.animClip)) {
      var params = {
        name : t.animClip,
        loop : false,
        speed : 1
      };
      if ("_defaultAnim_" === t.animClip) {
        params.loop = true;
      }
      self.playAnimation(params);
    }
  }, t;
}(Ds);
Fs = function(handler) {
  function t(a) {
    r(this, t);
    var container = s(this, handler.call(this, a));
    return container.createType = "Ground", container;
  }
  return o(t, handler), t.prototype.create = function() {
    return handler.prototype.create.call(this), this.thingjsObject.name = this.json2meshObject.id, this._createCombineObjectParent("CombineWallParent"), this._createCombineObjectParent("CombineMiscParent"), this._createCombineObjectParent("CombineFloorParent"), this.thingjsObject;
  }, t.prototype._getCreateParams = function() {
    var stored = handler.prototype._getCreateParams.call(this);
    return stored.height = this.json2meshObject.height, stored.alwaysShowInsideObjs = this.json2meshObject.alwaysShowInsideObjs, stored.loaded = true, stored;
  }, t.prototype._createCombineObjectParent = function(crypto_type) {
    var fixtureDef = this.app.objectManager.create({
      node : new THREE.Object3D,
      loaded : true,
      parent : this._getParent(this.thingjsObject, "CombinedObject"),
      type : "CombinedObject"
    });
    fixtureDef.userData.type = crypto_type;
    fixtureDef.userData.isCombineParent = true;
  }, t.prototype._callback = function(type, data) {
    handler.prototype._callback.call(this, type, data);
    var t = data.creator;
    var e = data.thingjsObject;
    e.wall.setupResources({});
    t._setupResourcesToChildren(e.wall);
    e.plan.setupResources({});
    t._setupResourcesToChildren(e.plan);
    e.misc.setupResources({});
    t._setupResourcesToChildren(e.misc);
  }, t.prototype._setupResourcesToChildren = function(tabObj) {
    var t = 0;
    for (; t < tabObj.children.length; t++) {
      tabObj.children[t].setupResources({});
    }
  }, t;
}(Ds);
Ls = function(handler) {
  function t(a) {
    r(this, t);
    var container = s(this, handler.call(this, a));
    return container.createType = "CombinedObject", container;
  }
  return o(t, handler), t.prototype.create = function() {
    return handler.prototype.create.call(this).userData.json2meshType = this.json2meshObject.type, this.thingjsObject;
  }, t.prototype.getJson2MeshObjectSize = function() {
    return null;
  }, t.prototype._callback = function(t, args) {
    handler.prototype._callback.call(this, t, args);
    args.creator._checkCombineParentObjectLoaded();
  }, t.prototype._checkCombineParentObjectLoaded = function() {
    var top = this.thingjsParent;
    var i = 0;
    for (; i < top._children.length; i++) {
      if (!top._children[i].loaded) {
        return;
      }
    }
    top.setupResources({});
    this._checkParentOfCombineParentObjectsLoaded(top.parent);
  }, t.prototype._checkParentOfCombineParentObjectsLoaded = function(ContactEndpoint) {
    var affectedData = ContactEndpoint.query(".CombinedObject", false);
    var j = 0;
    for (; j < affectedData.length; j++) {
      var data = affectedData[j];
      if ("CombineMiscParent" !== data.userData.type && !data.loaded) {
        return;
      }
    }
    ContactEndpoint.setupResources({});
  }, t;
}(Ds);
Is = function(e) {
  function t(row) {
    r(this, t);
    var template = s(this, e.call(this, row));
    return template.thingjsParent = template.thingjsParent.wall, template.thingjsParent.loaded = false, template;
  }
  return o(t, e), t;
}(Ls);
Ns = function(e) {
  function t(row) {
    r(this, t);
    var tile = s(this, e.call(this, row));
    return tile.thingjsParent = tile.thingjsParent.ceiling, tile.thingjsParent.loaded = false, tile;
  }
  return o(t, e), t;
}(Ls);
Hs = function(t) {
  function f(row) {
    r(this, f);
    var e = s(this, t.call(this, row));
    return e.thingjsParent = e.thingjsParent.misc, e.thingjsParent.loaded = false, e;
  }
  return o(f, t), f.prototype.create = function() {
    return t.prototype.create.call(this).node.isDoorOrWin = true, this.thingjsObject;
  }, f;
}(Ls);
Us = function(e) {
  function t(row) {
    r(this, t);
    var res = s(this, e.call(this, row));
    return res.thingjsParent = res.thingjsParent.plan, res.thingjsParent.loaded = false, res;
  }
  return o(t, e), t;
}(Ls);
zs = function(e) {
  function t(row) {
    r(this, t);
    var template = s(this, e.call(this, row));
    return template.thingjsParent = template.thingjsParent.wall, template.thingjsParent.loaded = false, template;
  }
  return o(t, e), t;
}(Ls);
Vs = function(e) {
  function t(row) {
    r(this, t);
    var template = s(this, e.call(this, row));
    return template.thingjsParent = template.thingjsParent.misc, template.thingjsParent.loaded = false, template;
  }
  return o(t, e), t;
}(Ls);
Ws = function(e) {
  function t(row) {
    r(this, t);
    var template = s(this, e.call(this, row));
    return template.thingjsParent = template.thingjsParent.roof, template.thingjsParent.loaded = false, template;
  }
  return o(t, e), t;
}(Ls);
Gs = function(f) {
  function t(rt) {
    r(this, t);
    var builder = s(this, f.call(this, rt));
    return builder.createType = "Room", builder;
  }
  return o(t, f), t.prototype.create = function() {
    f.prototype.create.call(this);
    return this.thingjsObject;
  }, t.prototype._getCreateParams = function() {
    var hole = f.prototype._getCreateParams.call(this);
    return this.json2meshObject.floor && (hole.floorHideByScene = !this.json2meshObject.floor.visible), this.json2meshObject.ceiling && (hole.ceilingHideByScene = !this.json2meshObject.ceiling.visible), this.json2meshObject.roof && (hole.roofHideByScene = !this.json2meshObject.roof.visible), hole.holes = this._getRoomHoles(), hole.points = this._getRoomPoints(), hole;
  }, t.prototype._getRoomPoints = function() {
    var newNodeLists = [];
    var i = 0;
    for (; i < this.json2meshObject.points.length; i++) {
      var fp = this.json2meshObject.points[i];
      newNodeLists.push(new THREE.Vector3(fp[0], fp[1], fp[2]));
    }
    return newNodeLists;
  }, t.prototype._getRoomHoles = function() {
    var t_chksum = [];
    var i = 0;
    for (; i < this.json2meshObject.holes.length; i++) {
      var month_name = this.json2meshObject.holes[i];
      var r = [];
      var month_full_i = 0;
      for (; month_full_i < month_name.length; month_full_i++) {
        var vertexData = month_name[month_full_i];
        r.push(new THREE.Vector3(vertexData[0], vertexData[1], vertexData[2]));
      }
      t_chksum.push(r);
    }
    return t_chksum;
  }, t.prototype._processCallback = function() {
    var mesh = this.thingjsObject;
    var options = this.json2meshObject;
    if (options.floor && options.floor.visible) {
      mesh._floorNode = options.floor.mesh;
      mesh._addNodeBySceneLoad(options.floor.mesh);
    }
    if (options.ceiling && options.ceiling.visible) {
      mesh._ceilingNode = options.ceiling.mesh;
      mesh._addNodeBySceneLoad(options.ceiling.mesh);
    }
    if (options.roof && options.roof.visible) {
      mesh._addNodeBySceneLoad(options.roof.mesh);
      mesh._roofNode = options.roof.mesh;
    }
    mesh.setRelativePoints(options.points);
  }, t;
}(Ds);
qs = function(e) {
  function t(row) {
    return r(this, t), s(this, e.call(this, row));
  }
  return o(t, e), t;
}(Bs);
Xs = function(instance) {
  function t(date) {
    r(this, t);
    var self = s(this, instance.call(this, date));
    return self.json2meshObject.jsonData && self.json2meshObject.jsonData.type ? self.createType = self.json2meshObject.jsonData.type : self.createType = "Thing", self.json2meshObject.enableCreateMesh = false, self;
  }
  return o(t, instance), t.prototype.create = function() {
    var t = instance.prototype.create.call(this);
    return "Floor" !== t.parent.type || t.parent.showObjectsInParentLevels || (t.visible = false), this.thingjsObject;
  }, t.prototype._getCreateParams = function() {
    var uploadedPart = instance.prototype._getCreateParams.call(this);
    return uploadedPart.belongRoomUserID = this.json2meshObject.belongRoomUserID, uploadedPart.hideByScene = !this.json2meshObject.visible, uploadedPart.initBoxSize = this.json2meshObject.size, uploadedPart;
  }, t.prototype._callback = function(type, data) {
    var refreshBtn = data.creator;
    var wasRefreshHidden = refreshBtn.thingjsObject;
    refreshBtn.thingjsObject = wasRefreshHidden;
    wasRefreshHidden.setupResources({
      loaded : true
    });
    data.thingjsObject = wasRefreshHidden;
    refreshBtn._notifyBuildedCompleteListeners();
    wasRefreshHidden._hideByScene = !type.visible;
    wasRefreshHidden.setupTextureAnimations();
  }, t;
}(Ds);
Js = function(handler) {
  function t(a) {
    r(this, t);
    var query = s(this, handler.call(this, a));
    return query.createType = "Door", query.json2meshObject.isWindow && (query.createType = "Thing"), query;
  }
  return o(t, handler), t.prototype.create = function() {
    var self = handler.prototype.create.call(this);
    return self.node.isDoorOrWin = true, self.isWindow = this.json2meshObject.isWindow, self.userData.isWindow = this.json2meshObject.isWindow, this.thingjsObject;
  }, t.prototype._setVisible = function() {
  }, t.prototype._callback = function(t, data) {
    handler.prototype._callback.call(this, t, data);
    var results = data.thingjsObject;
    if (results.node.quaternion.set(t.rotation[0], t.rotation[1], t.rotation[2], t.rotation[3]), results.localPosition = data.creator._getThingjsLocalPosition(), t.isWindow || t.isOpen && results.open(), results.animationNames) {
      var i = 0;
      for (; i < results.animationNames.length; i++) {
        var enumValA = results.animationNames[i];
        if ("_defaultAnim_" === enumValA) {
          results.playAnimation({
            name : enumValA,
            loop : true,
            speed : 1
          });
          break;
        }
      }
    }
  }, t;
}(Bs);
Ys = function(handler) {
  function t(a) {
    r(this, t);
    var container = s(this, handler.call(this, a));
    return container.createType = "RouteLine", container;
  }
  return o(t, handler), t.prototype.create = function() {
    var options = handler.prototype.create.call(this);
    return null !== this.json2meshObject.width && (options.width = this.json2meshObject.width), "Ground" === this.thingjsParent.type || options.parent.showObjectsInParentLevels || (options.visible = false), options.scrollSpeed = -10, options.rotateScrollDirection = true, this.thingjsObject;
  }, t.prototype._getCreateParams = function() {
    var t = handler.prototype._getCreateParams.call(this);
    return t.hideByScene = !this.json2meshObject.visible, t.arrowFlag = false, t;
  }, t.prototype._callback = function(e, event) {
    handler.prototype._callback.call(this, e, event);
    var p = [];
    var n = new THREE.Vector3(e.position[0], e.position[1], e.position[2]);
    var i = 0;
    for (; i < e.points.length; i++) {
      var s = new THREE.Vector3(e.points[i][0], e.points[i][1], e.points[i][2]);
      s.add(n);
      p.push(s);
    }
    var self = event.thingjsObject;
    if (self.addPoints(p, THING.SpaceType.Local), e.resource && e.resource.texture) {
      var data = e.resource.cloneFlipYToFalse();
      data.anisotropy = self.app.renderer.capabilities.getMaxAnisotropy();
      self._uvRotation = Math.PI / 2;
      self._synUvTransform();
      self.synPathTexture(data);
    }
    if (e.color) {
      var c = new THREE.Color(e.color[0], e.color[1], e.color[2]);
      self.style.color = "#" + c.getHexString();
    }
    if (void 0 !== e.enableMaterialAnimation && (self.imageScroll = e.enableMaterialAnimation), void 0 !== e.materialAnimationSpeed && (self.imageScrollSpeed = -e.materialAnimationSpeed), void 0 !== e.textureTiling) {
      var buffer = e.textureTiling;
      buffer[1] *= self.width;
      self.imageRepeat = buffer;
    }
    e.textureOffset;
    Cs.addTHINGJSObjectSfStyle(self, _s);
  }, t;
}(Ds);
Qs = function(handler) {
  function t(a) {
    r(this, t);
    var container = s(this, handler.call(this, a));
    return container.createType = "PolygonLine", container;
  }
  return o(t, handler), t.prototype.create = function() {
    var circle = handler.prototype.create.call(this);
    return this.json2meshObject.sectionType && ("Triangle" === this.json2meshObject.sectionType && (circle.pathRadialSegments = 3, circle._updateByPoints()), "Square" === this.json2meshObject.sectionType && (circle.pathRadialSegments = 4, circle.pathStartRad = Math.PI / 4, circle._updateByPoints())), this.json2meshObject.radius && (circle.width = this.json2meshObject.radius), "Ground" === this.thingjsParent.type || circle.parent.showObjectsInParentLevels || (circle.visible = false), this.thingjsObject;
  }, t.prototype._getCreateParams = function() {
    var t = handler.prototype._getCreateParams.call(this);
    return t.hideByScene = !this.json2meshObject.visible, t;
  }, t.prototype._callback = function(e, data) {
    handler.prototype._callback.call(this, e, data);
    var p = [];
    var n = new THREE.Vector3(e.position[0], e.position[1], e.position[2]);
    var i = 0;
    for (; i < e.points.length; i++) {
      var s = new THREE.Vector3(e.points[i][0], e.points[i][1], e.points[i][2]);
      s.add(n);
      p.push(s);
    }
    var a = data.thingjsObject;
    if (a.addPoints(p, THING.SpaceType.Local), e.resource && e.resource.texture) {
      var t = e.resource.cloneFlipYToFalse();
      t.anisotropy = a.app.renderer.capabilities.getMaxAnisotropy();
      a.synPathTexture(t);
    }
    if (e.color) {
      var c = new THREE.Color(e.color[0], e.color[1], e.color[2]);
      a.style.color = "#" + c.getHexString();
    } else {
      a.style.color = "#ffffff";
    }
    if (void 0 !== e.enableMaterialAnimation && (a.imageScroll = e.enableMaterialAnimation), void 0 !== e.materialAnimationSpeed && (a.imageScrollSpeed = e.materialAnimationSpeed), void 0 !== e.textureTiling) {
      var baz = 1.1 * a.width * 2 * Math.PI / e.textureTiling[0];
      a.imageRepeat = [baz, baz];
    }
    e.textureOffset;
    Cs.addTHINGJSObjectSfStyle(a, _s);
  }, t;
}(Ds);
Zs = function(e) {
  function t(row) {
    r(this, t);
    var a = s(this, e.call(this, row));
    return a.json2meshBuilding = row.json2meshBuilding, a.createType = "Facade", a.shouldCombineJson2meshObjects = [], a.shouldNotCombineJson2meshObjects = [], a.combineFacade = null, a.notCombineFacades = [], a;
  }
  return o(t, e), t.prototype.clear = function() {
    e.prototype.clear.call(this);
    this.json2meshBuilding = null;
    this.shouldCombineJson2meshObjects = [];
    this.shouldNotCombineJson2meshObjects = [];
    this.combineFacade = null;
    this.notCombineFacades = [];
  }, t.prototype.create = function() {
    var cat = this.json2meshBuilding;
    var child = this._getFacadeRelation(cat);
    return this.shouldCombineJson2meshObjects = child.facades, this.shouldNotCombineJson2meshObjects = child.children, child.children && child.facades && (this.thingjsObject = this._createCombineFacade(child, this.thingjsParent), this._createFacadeChildren(child, this.thingjsObject)), this._notifyCreatedCompleteListeners(), this.thingjsObject;
  }, t.prototype._createCombineFacade = function(left, right) {
    var obj = left.facades;
    var slideDragNode = new THREE.Object3D;
    var t = this.app.objectManager.create({
      type : "Facade",
      loaded : false,
      node : slideDragNode,
      parent : right
    });
    this.combineFacade = t;
    var e = new THREE.Box3;
    var i = 0;
    for (; i < obj.length; i++) {
      var res = obj[i];
      res.size;
      e.union(res._box3);
      var newPhysicsObject = this.app.objectManager.create({
        uuid : res.id,
        type : "CombinedObject",
        node : new THREE.Object3D,
        loaded : false,
        parent : t
      });
      newPhysicsObject.userData.isCombinedObject = true;
      res.registerBuildCallbackListener(this._facadeBuildCallback, {
        loader : this,
        tjsObject : newPhysicsObject,
        relation : left,
        parent : t
      });
    }
    return t._initBox3 = e, t;
  }, t.prototype._createFacadeChildren = function(src, e) {
    var h = src.children;
    var css = e._initBox3 || new THREE.Box3;
    var i = 0;
    for (; i < h.length; i++) {
      var value = h[i];
      var m = void 0;
      if ("FacadeGroup" === value.type) {
        m = this._createFacadeGroup(value, e, src);
        css.union(m._initBox3);
        delete m._initBox3;
      } else {
        m = this._createFacade(value, e, src);
        css.union(value._box3);
      }
      this.notCombineFacades.push(m);
    }
    var parent = new THREE.Vector3;
    css.getSize(parent);
    e._initBoxSize = parent.toArray();
    delete e._initBox3;
  }, t.prototype._createFacadeGroup = function(config, ast, src) {
    var r = new THREE.Box3;
    var t = this.app.objectManager.create({
      type : "Facade",
      uuid : config.id,
      id : config.userID,
      name : config.name,
      node : new THREE.Object3D,
      parent : ast,
      loaded : false,
      properties : config.properties
    });
    var i = 0;
    for (; i < config.children.length; i++) {
      var value = config.children[i];
      if ("FacadeGroup" === value.type) {
        this._createFacadeGroup(value, t, src);
      } else {
        r.union(value._box3);
        this._createFacade(value, t, src);
      }
    }
    var type = new THREE.Vector3;
    return r.getSize(type), t._initBoxSize = type.toArray(), t._initBox3 = r, config.registerBuildCallbackListener(this._facadeChildBuildCallback, {
      loader : this,
      tjsObject : t,
      relation : src,
      parent : ast
    }), t;
  }, t.prototype._createFacade = function(data, t, src) {
    var param = this.app.objectManager.create({
      type : "Facade",
      uuid : data.id,
      id : data.userID,
      name : data.name,
      node : new THREE.Object3D,
      parent : t,
      loaded : false,
      url : data.resource.getModelUrl(),
      properties : data.properties,
      initBoxSize : data.size
    });
    param.localPosition = data.position || [0, 0, 0];
    param.scale = data.scale || [1, 1, 1];
    var raw = data.rotation || [0, 0, 0, 1];
    return param.node.quaternion.set(raw[0], raw[1], raw[2], raw[3]), data.registerBuildCallbackListener(this._facadeChildBuildCallback, {
      loader : this,
      tjsObject : param,
      relation : src,
      parent : t
    }), param;
  }, t.prototype.parseJson2meshObject = function(obj, p0) {
    var t = this.creatorManager.createTjsObject(obj, p0);
    var array = obj.children;
    if (array) {
      var i = 0;
      for (; i < array.length; i++) {
        var item = array[i];
        this.parseJson2meshObject(item, t);
      }
    }
    return t;
  }, t.prototype._getFacadeRelation = function(Y) {
    var spheres = Y.typeToChildren.Facade;
    var changes = Y.typeToChildren.FacadeGroup;
    if (!spheres && !changes) {
      return {};
    }
    var vc = [];
    var n = [];
    if (spheres) {
      var iter_sph = 0;
      for (; iter_sph < spheres.length; iter_sph++) {
        var s = spheres[iter_sph];
        if (this._isFacadeShouldBeChild(s)) {
          vc.push(s);
        } else {
          n.push(s);
        }
      }
    }
    if (changes) {
      var i = 0;
      for (; i < changes.length; i++) {
        var change = changes[i];
        if (this._isFacadeShouldBeChild(change)) {
          vc.push(change);
        } else {
          n.push(change);
        }
      }
    }
    return {
      facades : n,
      children : vc
    };
  }, t.prototype._isFacadeShouldBeChild = function(value) {
    return !this._isNullOrUndefined(value.name) || (!this._isNullOrUndefined(value.userID) || !this._isNullOrUndefined(value.properties));
  }, t.prototype._facadeChildBuildCallback = function(obj, item) {
    var options = item.tjsObject;
    var plugin = item.loader;
    var model = item.relation;
    var p = item.parent;
    options.localPosition = obj.position;
    options.quaternion = obj.rotation;
    options.scale = obj.scale;
    obj.mesh.position.set(0, 0, 0);
    obj.mesh.quaternion.set(0, 0, 0, 1);
    obj.mesh.scale.set(1, 1, 1);
    options._addNodeBySceneLoad(obj.mesh);
    options.setupResources({
      loaded : true
    });
    plugin._checkFacadeBuildedComplete(model, p);
  }, t.prototype._checkFacadeBuildedComplete = function(expected, name) {
    var i = expected.facades;
    var crossfilterable_layers = expected.children;
    var n = true;
    var i1 = 0;
    for (; i1 < i.length; i1++) {
      if (!i[i1].isBuilded) {
        n = false;
        break;
      }
    }
    var layer_i = 0;
    for (; layer_i < crossfilterable_layers.length; layer_i++) {
      if (!crossfilterable_layers[layer_i].isBuilded) {
        n = false;
        break;
      }
    }
    if (n) {
      name.setupResources({});
      this._notifyBuildedCompleteListeners();
    }
  }, t.prototype._facadeBuildCallback = function(asset, options) {
    var self = options.tjsObject;
    var plugin = options.loader;
    var model = options.relation;
    var p = options.parent;
    self._addNodeBySceneLoad(asset.mesh);
    var deprecatedStylingMethods = asset.mesh.getMeshes();
    if (deprecatedStylingMethods && deprecatedStylingMethods.length > 0) {
      deprecatedStylingMethods.forEach(function(self) {
        self._sfStyle = gs;
      });
    }
    self.setupResources({
      loaded : true
    });
    plugin._checkFacadeBuildedComplete(model, p);
  }, t;
}(Ds);
Ks = function(handler) {
  function t(a) {
    r(this, t);
    var container = s(this, handler.call(this, a));
    return container.createType = "RouteLine", container;
  }
  return o(t, handler), t.prototype.create = function() {
    handler.prototype.create.call(this);
    return this.thingjsObject;
  }, t.prototype._getCreateParams = function() {
    var t = handler.prototype._getCreateParams.call(this);
    return t.arrowFlag = true, t;
  }, t.prototype._callback = function(t, args) {
    handler.prototype._callback.call(this, t, args);
  }, t;
}(Ys);
$s = function(handler) {
  function t(a) {
    r(this, t);
    var container = s(this, handler.call(this, a));
    return container.createType = "RouteLine", container;
  }
  return o(t, handler), t.prototype.create = function() {
    handler.prototype.create.call(this);
    return this.thingjsObject;
  }, t.prototype._getCreateParams = function() {
    var t = handler.prototype._getCreateParams.call(this);
    return t.arrowFlag = true, t;
  }, t.prototype._callback = function(t, args) {
    handler.prototype._callback.call(this, t, args);
    var newPhysicsObject = args.creator.thingjsObject;
    if (t.pointUserIDs) {
      newPhysicsObject.userData.pointUserIDs = t.pointUserIDs;
    }
    if (t.pointProperteis) {
      newPhysicsObject.userData.pointProperteis = t.pointProperteis;
    }
  }, t;
}(Ks);
ea = function(handler) {
  function t(a) {
    r(this, t);
    var container = s(this, handler.call(this, a));
    return container.createType = "PolygonLine", container;
  }
  return o(t, handler), t.prototype.create = function() {
    handler.prototype.create.call(this);
    return this.thingjsObject;
  }, t.prototype._getCreateParams = function() {
    return handler.prototype._getCreateParams.call(this);
  }, t.prototype._callback = function(t, args) {
    handler.prototype._callback.call(this, t, args);
    var newPhysicsObject = args.creator.thingjsObject;
    if (t.alarmLength) {
      newPhysicsObject.userData.alarmLength = t.alarmLength;
    }
  }, t;
}(Qs);
ta = function(handler) {
  function t(a) {
    r(this, t);
    var container = s(this, handler.call(this, a));
    return container.createType = "RouteLine", container;
  }
  return o(t, handler), t.prototype.create = function() {
    handler.prototype.create.call(this);
    return this.thingjsObject;
  }, t.prototype._getCreateParams = function() {
    return handler.prototype._getCreateParams.call(this);
  }, t.prototype._callback = function(t, args) {
    handler.prototype._callback.call(this, t, args);
  }, t;
}(Ys);
ia = function(e) {
  function t(row) {
    r(this, t);
    var template = s(this, e.call(this, row));
    return template.thingjsParent = template.thingjsParent.wall, template.thingjsParent.loaded = false, template;
  }
  return o(t, e), t;
}(Ls);
ra = function(f) {
  function t(rt) {
    r(this, t);
    var builder = s(this, f.call(this, rt));
    return builder.createType = "Thing", builder;
  }
  return o(t, f), t.prototype.create = function() {
    return f.prototype.create.call(this);
  }, t.prototype._getCreateParams = function() {
    return f.prototype._getCreateParams.call(this);
  }, t.prototype._setVisible = function() {
    var cContent = this.thingjsObject;
    if (!("Floor" !== this.thingjsParent.type || this.thingjsParent.showObjectsInParentLevels)) {
      cContent.visible = false;
    }
  }, t.prototype._getParent = function(element, className) {
    return element;
  }, t;
}(Bs);
na = function() {
  function e() {
    r(this, e);
    this.convertFontSizeFactor = 16 / 26 * .1;
    this.sharpness = 1;
    this.context = null;
    this.lineSpacing = .2;
    this.textSpacing = .1;
    this.fontSize = null;
    this.orgFontSize = null;
    this.saveData = null;
  }
  return e.prototype.save = function() {
    var options = {};
    options.sharpness = this.sharpness;
    options.convertFontSizeFactor = this.convertFontSizeFactor;
    options.sharpness = this.sharpness;
    options.lineSpacing = this.lineSpacing;
    options.textSpacing = this.textSpacing;
    options.fontSize = this.fontSize;
    options.orgFontSize = this.orgFontSize;
    this.saveData = options;
    this.context.save();
  }, e.prototype.restore = function() {
    this.sharpness = this.saveData.sharpness;
    this.convertFontSizeFactor = this.saveData.convertFontSizeFactor;
    this.sharpness = this.saveData.sharpness;
    this.lineSpacing = this.saveData.lineSpacing;
    this.textSpacing = this.saveData.textSpacing;
    this.fontSize = this.saveData.fontSize;
    this.orgFontSize = this.saveData.orgFontSize;
    this.context.restore();
  }, e.prototype.setupContext = function(options) {
    var compositeEncryptedMessage = la.parseColor(options.fontColor);
    this.context.font = this.fontSize + "px " + options.fontType;
    this.context.fillStyle = compositeEncryptedMessage.toHexString();
    this.context.textAlign = "start";
    this.context.textBaseline = "alphabetic";
  }, e.prototype.setOrgFontSize = function(value) {
    this.orgFontSize = value;
    this.fontSize = this._convertFontSize(value);
  }, e.prototype._convertFontSize = function(boundsMethod) {
    return this.sharpness * boundsMethod * .195 / this.convertFontSizeFactor;
  }, e.prototype.setupDecorations = function(geoJsonFeatures) {
    var i = 0;
    for (; i < geoJsonFeatures.length; i++) {
      var f = geoJsonFeatures[i];
      this._setupSingleDecoration(f);
    }
  }, e.prototype._setupSingleDecoration = function(data) {
    if ("color" === data.key) {
      this.context.fillStyle = data.value;
    } else {
      if ("b" === data.key) {
        var font = this.context.font;
        font = "bolder " + font;
        this.context.font = font;
      } else {
        if ("size" === data.key) {
          var props = this.context.font.split(" ");
          var style = "";
          var i = 0;
          for (; i < props.length; i++) {
            if (-1 !== props[i].indexOf("px")) {
              this.fontSize = this._convertFontSize(data.value);
              props[i] = this.fontSize + "px";
            }
            style = style + (" " + props[i]);
          }
          this.context.font = style;
        } else {
          if ("i" === data.key) {
            var font = this.context.font;
            font = "italic " + font;
            this.context.font = font;
          }
        }
      }
    }
  }, e.prototype.measureTextWidth = function(context) {
    return this.context.measureText(context).width;
  }, e.prototype.letterSpacingText = function(t, b, i) {
    var ctx = this.context;
    var fontSize = this.fontSize * this.textSpacing;
    var combinedSets = t.split("");
    var align = ctx.textAlign || "left";
    var d = ctx.measureText(t).width + fontSize * (combinedSets.length - 1);
    if ("center" === align) {
      b = b - d / 2;
    } else {
      if ("right" === align) {
        b = b - d;
      }
    }
    ctx.textAlign = "left";
    combinedSets.forEach(function(text) {
      var max = ctx.measureText(text).width;
      ctx.fillText(text, b, i);
      b = b + max + fontSize;
    });
    ctx.textAlign = align;
  }, e;
}();
oa = function() {
  function i(a) {
    r(this, i);
    this.factor = null;
    this.decorationFactor = 1;
    this.brush = null;
  }
  return i.prototype.calCanvasSize = function(field, context) {
    this.brush.sharpness = 1;
    field.style.fontType;
    var size = context.fontSize;
    this.brush.setOrgFontSize(size);
    var lastProfileId = (size = this.brush.fontSize) / 72 * 96;
    var begin = Math.max(64, THING.Math.roundUpPowerOf2(lastProfileId));
    this.brush.setupContext(context);
    this.calRichTextSize(field, size);
    var ii = field.richTextSize;
    var height = ii.height;
    var width = ii.width;
    var value = Math.max(begin, THING.Math.roundUpPowerOf2(width));
    var time = Math.max(begin, THING.Math.roundUpPowerOf2(height));
    var label = {};
    label.width = Math.max(value, time);
    label.height = Math.max(value, time);
    field.canvasSize = label;
    field.planHeight = label.height * this.brush.convertFontSizeFactor;
  }, i.prototype.calRichTextSize = function(me) {
    var r = -1;
    var height = 0;
    var i = 0;
    for (; i < me.textRows.length; i++) {
      var button = me.textRows[i];
      this._calRowSize(button);
      var s = button.size;
      if (s.width > r) {
        r = s.width;
      }
      height = height + s.height;
      if (i !== me.textRows.length - 1) {
        height = height + s.height * this.brush.lineSpacing;
      }
    }
    me.richTextSize = {
      width : r,
      height : height
    };
  }, i.prototype._calRowSize = function(config) {
    var texts = config.texts;
    var col = 0;
    var size = -1;
    var i = 0;
    for (; i < texts.length; i++) {
      var text = texts[i];
      this.brush.save();
      this.brush.setupDecorations(text.decorations);
      this._calTextWidth(text);
      col = col + text.width;
      this._calTextHeight(text);
      var h = text.height;
      if (h > size) {
        size = h;
      }
      this.brush.restore();
    }
    if (-1 === size) {
      size = this.brush.fontSize;
    }
    config.size = {
      width : col,
      height : size
    };
  }, i.prototype._calTextWidth = function(metadata) {
    var _arr3 = metadata.content.split("");
    var d = this.brush.fontSize;
    var value = 0;
    var _i3 = 0;
    for (; _i3 < _arr3.length; _i3++) {
      var context = _arr3[_i3];
      value = value + this.brush.measureTextWidth(context);
      if (_i3 !== _arr3.length - 1) {
        value = value + d * this.brush.textSpacing;
      }
    }
    return metadata.width = value, value;
  }, i.prototype._calTextHeight = function(source) {
    source.height = this.brush.fontSize;
  }, i;
}();
sa = function() {
  function c(fnArgs) {
    r(this, c);
    this.calculater = fnArgs;
    this.fontSize = null;
    this.brush = null;
  }
  return c.prototype.setContext = function(globalObject) {
    this.brush.context = globalObject;
  }, c.prototype.calCanvasSize = function(fn, target) {
    this.calculater.calCanvasSize(fn, target);
  }, c.prototype.calRichTextSize = function(o) {
    this.calculater.calRichTextSize(o);
  }, c.prototype.draw = function(o, t, i, options) {
    this.brush.sharpness = 2;
    this.brush.setOrgFontSize(options.fontSize);
    this.fontSize = this.brush.fontSize;
    this.brush.setupContext(options);
    this.calculater.calRichTextSize(o);
    var time_val = (i - o.richTextSize.height) / 2;
    if (o.textRows.length > 0) {
      time_val = time_val + .84 * o.textRows[0].size.height;
    }
    var tau = t / 2;
    var ret = time_val;
    var _i = 0;
    for (; _i < o.textRows.length; _i++) {
      var i = o.textRows[_i];
      var s = i.size;
      if (0 !== _i) {
        ret = ret + .84 * s.height;
      }
      this._drawRow(i, tau - .5 * s.width, ret);
      ret = ret + s.height * (.16 + this.brush.lineSpacing);
    }
  }, c.prototype._drawRow = function(result, x, index) {
    var colOffset = 0;
    var i = 0;
    for (; i < result.texts.length; i++) {
      var context = result.texts[i];
      if (0 !== i) {
        colOffset = colOffset + result.texts[i - 1].width;
      }
      this._drawText(context, x + colOffset, index);
    }
  }, c.prototype._drawText = function(ctx, context, o) {
    this.brush.save();
    this.brush.setupDecorations(ctx.decorations);
    this.brush.letterSpacingText(ctx.content, context, o);
    this.brush.restore();
  }, c;
}();
aa = function(key) {
  var type = "[object " + key + "]";
  return function(obj) {
    return toString.call(obj) == type;
  };
};
la = {
  isNull : function(val) {
    return null == val;
  },
  isArray : aa("Array"),
  isObject : aa("Object"),
  isString : aa("String"),
  isNumber : aa("Number"),
  isBlank : function(val) {
    if (!la.isNull(val) && la.isString(val)) {
      var bufferIdx = 0;
      for (; bufferIdx < val.length; bufferIdx++) {
        if (" " != val[bufferIdx] && "\t" != val[bufferIdx]) {
          return false;
        }
      }
    }
    return true;
  },
  parseColor : function(data, value) {
    if (!this.isNull(data)) {
      if (data.isColor) {
        return data;
      }
      if (la.isArray(data)) {
        return new THREE.Color(data[0], data[1], data[2]);
      }
      if (la.isNumber(data)) {
        return (sources = new THREE.Color).setHex(data), sources;
      }
      if (la.isString(data)) {
        if (la.isBlank(data)) {
          return new THREE.Color(0, 0, 0);
        }
        if ("#" == data[0]) {
          return la.parseColor(parseInt(data.substr(1), 16));
        }
        var sources = new THREE.Color;
        var dynamicEventSource = THREE.Color.NAMES[data.toLowerCase()];
        if (void 0 !== dynamicEventSource) {
          return sources.setHex(dynamicEventSource);
        }
        if (!isNaN(data)) {
          return la.parseColor(THING.Math.toInteger(data));
        }
      }
    }
    return value ? la.parseColor(value) : value;
  }
};
ua = new oa, ca = new sa(ua);
ha = new na;
ca.brush = ha, ua.brush = ha;
var da = function(f) {
  function t(rt) {
    r(this, t);
    var builder = s(this, f.call(this, rt));
    return builder.createType = "_UbuilderRichTextRegion", builder;
  }
  return o(t, f), t.prototype._getCreateParams = function() {
    var options = f.prototype._getCreateParams.call(this);
    options.localPosition = this.json2meshObject.position;
    options.text = this.json2meshObject.text;
    options.textRows = this.json2meshObject.textRows;
    var fontSize = this.json2meshObject.fontSize;
    return options.style = {
      fontColor : this.json2meshObject.color,
      fontSize : fontSize
    }, options.drawer = ca, options;
  }, t.prototype.create = function() {
    return f.prototype.create.call(this), "FloorPlan" === this.json2meshObject.parent.type && (this.thingjsObject.visible = false), this.thingjsObject;
  }, t;
}(Ds);
var fa = function(handler) {
  function t(a) {
    r(this, t);
    var container = s(this, handler.call(this, a));
    return container.createType = "PolygonLine", container;
  }
  return o(t, handler), t.prototype.create = function() {
    var circle = handler.prototype.create.call(this);
    return this.json2meshObject.pathRadialSegments && (circle.pathRadialSegments = this.json2meshObject.pathRadialSegments, 4 === this.json2meshObject.pathRadialSegments && (circle.pathStartRad = -Math.PI / 4), circle._updateByPoints()), this.json2meshObject.radius && (circle.width = this.json2meshObject.radius), "Ground" === this.thingjsParent.type || circle.parent.showObjectsInParentLevels || (circle.visible = false), this.thingjsObject;
  }, t.prototype._getCreateParams = function() {
    var t = handler.prototype._getCreateParams.call(this);
    return t.hideByScene = !this.json2meshObject.visible, t;
  }, t.prototype._callback = function(e, data) {
    handler.prototype._callback.call(this, e, data);
    var p = [];
    var n = new THREE.Vector3(e.position[0], e.position[1], e.position[2]);
    var i = 0;
    for (; i < e.points.length; i++) {
      var s = new THREE.Vector3(e.points[i][0], e.points[i][1], e.points[i][2]);
      s.add(n);
      p.push(s);
    }
    var a = data.thingjsObject;
    if (a.addPoints(p, THING.SpaceType.Local), e.resource && e.resource.texture) {
      var t = e.resource.cloneFlipYToFalse();
      t.anisotropy = a.app.renderer.capabilities.getMaxAnisotropy();
      a.synPathTexture(t);
    }
    if (e.color) {
      var c = new THREE.Color(e.color[0], e.color[1], e.color[2]);
      a.style.color = "#" + c.getHexString();
    } else {
      a.style.color = "#ffffff";
    }
    if (void 0 !== e.enableMaterialAnimation && (a.imageScroll = e.enableMaterialAnimation), void 0 !== e.materialAnimationSpeed && (a.imageScrollSpeed = e.materialAnimationSpeed), void 0 !== e.textureTiling) {
      var baz = 1.1 * a.width * 2 * Math.PI / e.textureTiling[0];
      a.imageRepeat = [baz, baz];
    }
    e.textureOffset;
    Cs.addTHINGJSObjectSfStyle(a, _s);
  }, t;
}(Ds);
var ma = function(callback) {
  function d(row) {
    r(this, d);
    var container = s(this, callback.call(this, row));
    return container.createType = "RouteLine", container;
  }
  return o(d, callback), d.prototype._getCreateParams = function() {
    var t = callback.prototype._getCreateParams.call(this);
    return t.arrowFlag = this.json2meshObject.arrowVisible, t;
  }, d;
}($s);
var ga = function() {
  function a() {
    r(this, a);
    this._map = {
      World : As,
      Building : ks,
      FloorPlan : Os,
      Placement : Bs,
      Outdoors : Fs,
      CombineStraightManualWall : Is,
      CombineCeiling : Ns,
      CombineDoorOrWindow : Hs,
      CombineFloor : Us,
      CombineModelWall : zs,
      CombinePlacement : Vs,
      CombinePlacementGroup : Vs,
      CombineRoof : Ws,
      CombinePlacementWall : ia,
      Room : Gs,
      VideoProbe : qs,
      PlacementGroup : Xs,
      DoorOrWindow : Js,
      CurveLine : Ys,
      PipeLine : Qs,
      Facade : Zs,
      FacadeGroup : Zs,
      ArrowLine : Ks,
      ArrowDataLine : $s,
      LeakWaterLine : ea,
      RouteLine : ta,
      PlacementGround : ra,
      Text3D : da,
      GeneralPolygonLine : fa,
      GeneralRouteLine : ma
    };
    this._createdThingjsObjectMap = {};
    this.campus = null;
  }
  return a.prototype.getClass = function(v) {
    return this._map[v];
  }, a.prototype.addCreatedThingjsObject = function(e, islongclick) {
    this._createdThingjsObjectMap[e.id] = islongclick;
  }, a.prototype.getCreatedThingjsObject = function(ballNumber) {
    return this._createdThingjsObjectMap[ballNumber];
  }, a;
}();
var va = {
  changeParentToRoom : function(e) {
    var t = e.json2meshObject;
    e.app;
    if (t.belongRoomUserID && "FloorPlan" === t.parent.type) {
      var newOrg = this.allRooms[t.belongRoomUserID];
      e.thingjsParent = newOrg;
    }
  },
  getThingjsObjectInRoomLocalPosition : function(dropTarget, target, n) {
    if (n) {
      var point = n.parent.selfToWorld(dropTarget.position);
      return point = target.worldToLocal(point);
    }
    return dropTarget.position;
  }
};
var ya = function(callback) {
  function d(row) {
    r(this, d);
    var e = s(this, callback.call(this, row));
    return va.changeParentToRoom(e), e;
  }
  return o(d, callback), d.prototype._getThingjsLocalPosition = function() {
    var color = null;
    return "Room" === this.thingjsParent.type && (color = this.thingjsParent), va.getThingjsObjectInRoomLocalPosition(this.json2meshObject, this.thingjsObject, color);
  }, d;
}(Bs);
var ba = function(callback) {
  function d(row) {
    r(this, d);
    var e = s(this, callback.call(this, row));
    return va.changeParentToRoom(e), e;
  }
  return o(d, callback), d.prototype._getThingjsLocalPosition = function() {
    var color = null;
    return "Room" === this.thingjsParent.type && (color = this.thingjsParent), va.getThingjsObjectInRoomLocalPosition(this.json2meshObject, this.thingjsObject, color);
  }, d;
}(Xs);
var _a = function(f) {
  function t(rt) {
    r(this, t);
    var builder = s(this, f.call(this, rt));
    return builder.createType = "Room", builder;
  }
  return o(t, f), t.prototype.create = function() {
    var root = f.prototype.create.call(this);
    var fixtureDef = this.app.objectManager.create({
      node : new THREE.Object3D,
      parent : this._getParent(root, "CombinedObject"),
      type : "CombinedObject"
    });
    fixtureDef.userData.type = "CombineMiscParent";
    fixtureDef.userData.isCombineParent = true;
  }, t;
}(Gs);
var xa = function(callback) {
  function d(row) {
    r(this, d);
    var e = s(this, callback.call(this, row));
    return va.changeParentToRoom(e), "Room" === e.thingjsParent.type && (e.thingjsParent = e.thingjsParent.misc, e.thingjsParent.loaded = false), e;
  }
  return o(d, callback), d.prototype._getThingjsLocalPosition = function() {
    var g = null;
    return "Room" === this.thingjsParent.parent.type && (g = this.thingjsParent.parent), va.getThingjsObjectInRoomLocalPosition(this.json2meshObject, this.thingjsObject, g);
  }, d.prototype._checkParentOfCombineParentObjectsLoaded = function(canCreateDiscussions) {
  }, d;
}(Vs);
var Ea = function(callback) {
  function i(string) {
    r(this, i);
    var e = s(this, callback.call(this, string));
    return va.changeParentToRoom(e), e;
  }
  return o(i, callback), i.prototype._getThingjsLocalPosition = function() {
    var color = null;
    return "Room" === this.thingjsParent.type && (color = this.thingjsParent), va.getThingjsObjectInRoomLocalPosition(this.json2meshObject, this.thingjsObject, color);
  }, i;
}(qs);
var wa = function(e) {
  function t(row) {
    r(this, t);
    var self = s(this, e.call(this, row));
    return self._map.Placement = ya, self._map.PlacementGroup = ba, self._map.Room = _a, self._map.CombinePlacement = xa, self._map.VideoProbe = Ea, self;
  }
  return o(t, e), t;
}(ga);
var Ta = function() {
  function a() {
    r(this, a);
  }
  return a.prototype.init = function(init) {
  }, a.prototype.onFire = function(isDrop) {
  }, a;
}();
var Ma = function(t) {
  function a(module) {
    return r(this, a), s(this, t.call(this, module));
  }
  return o(a, t), a.prototype.init = function(callback) {
    t.prototype.init.call(this, callback);
    callback.registerCreatedCallbackListener(this.onFire, {
      event : this
    });
    callback.registerBuildedCallbackListener(this._buildCallback, {
      event : this
    });
  }, a.prototype.onFire = function(i, e) {
    var n = i.thingjsObject;
    var u = i.json2meshObject;
    var o = e.event;
    if ("Building" !== n.type && "Campus" !== n.type && "CombinedObject" !== n.type && "Room" !== n.type && "RouteLine" !== n.type && "PolygonLine" !== n.type && "Ground" !== n.type) {
      if ("Facade" === n.type) {
        var previous = i.json2meshBuilding;
        o._addFacadeBoxNode(previous, n);
      } else {
        o._addBoxNode(u, n);
      }
    }
  }, a.prototype._addFacadeBoxNode = function(c, t) {
    var canvas = this._getFacadesBoundingBox(c);
    var offset = new THREE.Vector3;
    var center = new THREE.Vector3;
    canvas.getSize(offset);
    canvas.getCenter(center);
    var planetgeometry = new THREE.BoxBufferGeometry(1, 1, 1);
    var material = new THREE.MeshBasicMaterial;
    material.visible = false;
    var mesh = new THREE.Mesh(planetgeometry, material);
    mesh.scale.set(offset.x, offset.y, offset.z);
    t.setBoxNode(mesh);
    mesh.position.set(center.x, center.y, center.z);
  }, a.prototype._getFacadesBoundingBox = function(n) {
    var boundingBox = new THREE.Box3;
    var mesh = new THREE.Object3D;
    var rawTextArr = n.typeToChildren.Facade;
    var xhdr = n.typeToChildren.FacadeGroup;
    if (rawTextArr) {
      var rline = 0;
      for (; rline < rawTextArr.length; rline++) {
        var line = rawTextArr[rline];
        mesh.add(this._createBoxMesh(line));
      }
    }
    if (xhdr) {
      var i = 0;
      for (; i < xhdr.length; i++) {
        var line = xhdr[i];
        mesh.add(this._createBoxMesh(line));
      }
    }
    return boundingBox.setFromObject(mesh), boundingBox;
  }, a.prototype._createBoxMesh = function(state) {
    var geometry = new THREE.BoxBufferGeometry(1, 1, 1);
    var material = new THREE.MeshBasicMaterial;
    var cube = new THREE.Mesh(geometry, material);
    return cube.scale.set(state.size[0], state.size[1], state.size[2]), cube.quaternion.set(state.rotation[0], state.rotation[1], state.rotation[2], state.rotation[3]), cube.position.set(state.position[0], state.position[1], state.position[2]), cube.position.y = (state.position[1] + state.size[1]) / 2, cube;
  }, a.prototype._addBoxNode = function(action, o) {
    var forearm = new THREE.Vector3(action.center[0], action.center[1], action.center[2]);
    var t = new THREE.BoxBufferGeometry(1, 1, 1);
    var material = new THREE.MeshBasicMaterial;
    material.visible = false;
    var text = new THREE.Mesh(t, material);
    var c = new THREE.Vector3(action.size[0], action.size[1], action.size[2]);
    c.divide(o.node.scale);
    text.scale.set(0 === c.x ? .001 : c.x, 0 === c.y ? .001 : c.y, 0 === c.z ? .001 : c.z);
    o.setBoxNode(text);
    if ("Building" === o.type || "Floor" === o.type) {
      text.position.set(forearm.x, forearm.y, forearm.z);
    } else {
      text.position.set(0, action.size[1] / 2, 0);
    }
  }, a.prototype._buildCallback = function(b, variableNames) {
    var c = b.thingjsObject;
    var vroot = (b.json2meshObject, c.node);
    var i = 0;
    for (; i < vroot.children.length; i++) {
      var error = vroot.children[i];
      if (error.userData.asBoundingBox) {
        error.visible = false;
        break;
      }
    }
  }, a;
}(Ta);
var Ca = function(b) {
  function a(e) {
    r(this, a);
    var root = s(this, b.call(this, e));
    return root.app = e.app, root;
  }
  return o(a, b), a.prototype.init = function(callback) {
    b.prototype.init.call(this, callback);
    callback.registerBuildedCallbackListener(this.onFire, {
      event : this
    });
  }, a.prototype.onFire = function(record, e) {
    var parent = record.thingjsObject;
    var data = record.json2meshObject;
    var c = e.event;
    if ("CombinePlacement" === data.type) {
      parent._removeNodeBySceneLoad(data.mesh);
      var models = data.objects;
      var atoms = data.transformations;
      var applyDataChange = data.resource.modelID;
      data.resource.model.updateMatrixWorld();
      var store = record.app.create({
        type : "BatchObject",
        nodeOverride : false,
        node : data.resource.model,
        initBatchNum : models.length,
        parent : parent
      });
      var i = 0;
      for (; i < models.length; i++) {
        var rec = models[i];
        var transform = c.calMatrixs(atoms[i]);
        var center = new THREE.Vector3;
        var s = new THREE.Vector3;
        var quaternion = new THREE.Quaternion;
        transform.decompose(center, quaternion, s);
        var m = center.toArray();
        var serverScale = s.toArray();
        var result = new THREE.Euler;
        result.setFromQuaternion(quaternion);
        var angles = result.toArray();
        angles[0] *= 180 / Math.PI;
        angles[1] *= 180 / Math.PI;
        angles[2] *= 180 / Math.PI;
        store.createSubObject({
          parent : parent,
          id : rec.id,
          localPosition : m,
          scale : serverScale,
          angles : angles
        });
      }
      Cs.addBatchCombinePlacementStyle(store, data, applyDataChange);
    }
  }, a.prototype.calMatrixs = function(options) {
    var id = new THREE.Matrix4;
    var i = options.positions.length - 1;
    for (; i > -1; i--) {
      var fp = options.positions[i];
      var r = options.quaternions[i];
      var vertexData = options.scales[i];
      var ToBuffer$ = new THREE.Vector3(fp[0], fp[1], fp[2]);
      var setPathFromURL = new THREE.Quaternion(r[0], r[1], r[2], r[3]);
      var findStudent = new THREE.Vector3(vertexData[0], vertexData[1], vertexData[2]);
      var R = new THREE.Matrix4;
      R.compose(ToBuffer$, setPathFromURL, findStudent);
      id.premultiply(R);
    }
    return id;
  }, a;
}(Ta);
var Sa = function(b) {
  function a() {
    return r(this, a), s(this, b.call(this));
  }
  return o(a, b), a.prototype.init = function(callback) {
    b.prototype.init.call(this, callback);
    callback.registerBuildedCallbackListener(this.onFire, {
      event : this
    });
  }, a.prototype.onFire = function(result, event) {
    result.thingjsObject;
    var princ = result.json2meshObject;
    var e = event.event;
    if ("Room" === princ.type) {
      e._createRoomWater(result);
    } else {
      if (!("CombineFloor" !== princ.type && "CombineCeiling" !== princ.type && "CombineRoof" !== princ.type)) {
        e._createCombineFloorWater(result);
      }
    }
  }, a.prototype._createRoomWater = function(o) {
    var data = o.json2meshObject;
    var node = o.thingjsObject;
    if (data.floor && this._checkIsWater(data.floor.resource)) {
      var srcFile2 = data.floor.mesh.position;
      var q = data.floor.mesh.quaternion;
      var scope = this._createWater(o, data.floor.mesh);
      node.node.remove(data.floor.mesh);
      scope.userData.json2meshType = data.type;
      data.floor.mesh = scope.node;
      node._floorNode = scope.node;
      node.add(scope);
      scope.node.position.copy(srcFile2);
      scope.node.quaternion.copy(q);
      data.mesh.children[0] = scope.node;
    }
    if (data.ceiling && this._checkIsWater(data.ceiling.resource)) {
      var s = data.ceiling.mesh.position;
      var q = data.ceiling.mesh.quaternion;
      var scope = this._createWater(o, data.ceiling.mesh);
      scope.userData.json2meshType = data.type;
      node.node.remove(data.ceiling.mesh);
      data.ceiling.mesh = scope.node;
      node._ceilingNode = scope.node;
      node.add(scope);
      scope.node.position.copy(s);
      data.mesh.children[1] = scope.node;
      scope.node.position.copy(s);
      scope.node.quaternion.copy(q);
    }
    if (data.roof && this._checkIsWater(data.roof.resource)) {
      var srcFile2 = data.roof.mesh.position;
      var q = data.roof.mesh.quaternion;
      var scope = this._createWater(o, data.roof.mesh);
      data.roof.mesh = scope.node;
      node._roofNode = scope.node;
      node.node.remove(data.roof.mesh);
      node.add(scope);
      scope.node.position.copy(srcFile2);
      data.mesh.children[2] = scope.node;
      scope.node.position.copy(srcFile2);
      scope.node.quaternion.copy(q);
    }
  }, a.prototype._createCombineFloorWater = function(input) {
    var scope = input.json2meshObject;
    var mod = input.thingjsObject;
    if (this._checkIsWater(scope.resource)) {
      var obj = this._createWater(input, scope.mesh);
      obj.scale.y *= -1;
      mod.node.remove(scope.mesh);
      mod.add(obj);
      obj.node.position.copy(scope.mesh.position);
      obj.node.quaternion.copy(scope.mesh.quaternion);
    }
  }, a.prototype._checkIsWater = function(other) {
    return !(!other || "bundle" !== other.ext || "test0000000003" !== other.id && "test0000000004" !== other.id);
  }, a.prototype._createWater = function(payload, graphic) {
    var body = payload.app.objectManager.create({
      type : "Water",
      style : {
        waterColor : "#1D282C",
        waterScale : .3,
        flowXDirection : 2,
        flowYDirection : 1
      },
      geometry : graphic.geometry
    });
    return body.water.position.set(0, 0, 0), body.water.quaternion.set(0, 0, 0, 1), body;
  }, a;
}(Ta);
var ja = function(t) {
  function a(module) {
    return r(this, a), s(this, t.call(this, module));
  }
  return o(a, t), a.prototype.init = function(callback) {
    t.prototype.init.call(this, callback);
    callback.registerBuildedCallbackListener(this._buildCallback, {
      event : this
    });
  }, a.prototype._buildCallback = function(data, opt) {
    var modelElementPath = data.thingjsObject;
    var composite = data.json2meshObject;
    var steps = opt.event;
    modelElementPath.node;
    if ("Building" === composite.type && "Facade" === modelElementPath.type) {
      steps._processFacade(data, opt);
    } else {
      if (composite.resource && composite.resource.indexJson) {
        modelElementPath._extensionsFile = composite.resource.indexJson.extensionsfile || null;
      }
    }
  }, a.prototype._processFacade = function(option, page) {
    var r = option.thingjsObject;
    var tmpKeys = (option.json2meshObject, option.shouldNotCombineJson2meshObjects);
    var i = 0;
    for (; i < tmpKeys.length; i++) {
      var o = tmpKeys[i];
      var s = r.query("##" + o.id)[0];
      if (o.resource && o.resource.indexJson) {
        s._extensionsFile = o.resource.indexJson.extensionsfile || null;
      }
    }
  }, a;
}(Ta);
var Pa = function(b) {
  function a(e) {
    r(this, a);
    var root = s(this, b.call(this, e));
    root.resourceManager = e.resourceManager;
    root.localUseStaticImageResources = {};
    var el = root;
    return root.useStaticImageKey = "useStaticImage", root.manualUseStaticImage = "manualUseStaticImage", root.skipManualObjects = void 0 !== THING[root.manualUseStaticImage] && !THING[root.manualUseStaticImage], THING.onValueChange = function(data) {
      if (data.type === el.useStaticImageKey) {
        el.onUseStaticImageChange(data.value);
      } else {
        if (data.type === el.manualUseStaticImage) {
          el.onManualUseStaticImageChange(data.value);
        }
      }
    }, root;
  }
  return o(a, b), a.prototype.onUseStaticImageChange = function(moduleUrl) {
    var i = 0;
    for (; i < this.resourceManager.textures.length; i++) {
      var moduleConfig = this.resourceManager.textures[i];
      if (void 0 === this.localUseStaticImageResources[moduleConfig.id]) {
        moduleConfig.useStaticImage = moduleUrl;
      }
    }
    var index = 0;
    for (; index < this.resourceManager.models.length; index++) {
      var currentScorm = this.resourceManager.models[index];
      if (void 0 === this.localUseStaticImageResources[currentScorm.id]) {
        currentScorm.useStaticImage = moduleUrl;
      }
    }
  }, a.prototype.onManualUseStaticImageChange = function(moduleId) {
    var i = 0;
    for (; i < this.resourceManager.textures.length; i++) {
      var moduleConfig = this.resourceManager.textures[i];
      if (void 0 === this.localUseStaticImageResources[moduleConfig.id]) {
        moduleConfig.useStaticImage = moduleId;
      }
    }
  }, a.prototype.init = function(callback) {
    b.prototype.init.call(this, callback);
    callback.registerCreatedCallbackListener(this.onFire, {
      event : this
    });
  }, a.prototype.onFire = function(data, _) {
    var modelElementPath = data.thingjsObject;
    var r = data.json2meshObject;
    var test = _.event;
    if ("Facade" === modelElementPath.type) {
      var Y = data.json2meshBuilding;
      test.processFacades(Y.typeToChildren.Facade);
      test.processFacadeGroups(Y.typeToChildren.FacadeGroup);
    } else {
      if ("PlacementGroup" === r.type) {
        test.processGroup(r);
      } else {
        if ("CombineStraightManualWall" === r.type || "CombineFloor" === r.type || "CombineRoof" === r.type || "CombineCeiling" === r.type || "Ceiling" === r.type || "Floor" === r.type || "Roof" === r.type) {
          if (test.skipManualObjects) {
            test.processJson2meshObject(r, false);
          }
        } else {
          test.processJson2meshObject(r);
        }
      }
    }
  }, a.prototype.processFacades = function(geoJsonFeatures) {
    if (geoJsonFeatures) {
      var i = 0;
      for (; i < geoJsonFeatures.length; i++) {
        var f = geoJsonFeatures[i];
        this.processJson2meshObject(f);
      }
    }
  }, a.prototype.processFacadeGroups = function(failedSuites) {
    if (failedSuites) {
      var i = 0;
      for (; i < failedSuites.length; i++) {
        var el = failedSuites[i];
        this.processGroup(el);
      }
    }
  }, a.prototype.processGroup = function(data, tree, result) {
    if (void 0 === result) {
      result = this.getLocalUseStaticImageSetting(data);
    }
    var index = 0;
    for (; index < data.groups.length; index++) {
      var el = data.groups[index];
      this.processGroup(el, tree, result);
    }
    var i = 0;
    for (; i < data.placements.length; i++) {
      var t = data.placements[i];
      if (t.resource) {
        this.processJson2meshObject(t, tree, result);
      }
    }
  }, a.prototype.processJson2meshObject = function(c, t, f) {
    if (void 0 === f && (f = this.getLocalUseStaticImageSetting(c)), void 0 === t && (t = THING[this.useStaticImageKey]), c.resources) {
      var i = 0;
      for (; i < c.resources.length; i++) {
        var fd = c.resources[i];
        if (void 0 !== this.localUseStaticImageResources[fd.id]) {
          return;
        }
        if (void 0 === f) {
          if (void 0 !== t) {
            fd.useStaticImage = t;
          }
        } else {
          fd.useStaticImage = f;
          if (void 0 !== !this.localUseStaticImageResources[fd.id]) {
            this.localUseStaticImageResources[fd.id] = f;
          }
        }
      }
    }
  }, a.prototype.getLocalUseStaticImageSetting = function(classObject) {
    if (classObject.lowerCaseProperties) {
      if ("true" === classObject.lowerCaseProperties._usestaticimage_) {
        return true;
      }
      if ("false" === classObject.lowerCaseProperties._usestaticimage_) {
        return false;
      }
    }
  }, a.prototype.getGlobalUseStaticImageSetting = function() {
    if (void 0 !== THING[this.useStaticImageKey]) {
      return THING[this.useStaticImageKey];
    }
  }, a;
}(Ta);
var Ra = function(selector) {
  function a(type) {
    r(this, a);
    var key = s(this, selector.call(this, type));
    return key.resourceManager = type.resourceManager, key.processGlobalSetting(), key;
  }
  return o(a, selector), a.prototype.processGlobalSetting = function() {
    if (THING.useStaticImage) {
      var i = 0;
      for (; i < this.resourceManager.textures.length; i++) {
        this.resourceManager.textures[i].useStaticImage = true;
      }
      var index = 0;
      for (; index < this.resourceManager.models.length; index++) {
        this.resourceManager.models[index].useStaticImage = true;
      }
    }
  }, a.prototype.init = function(init) {
  }, a;
}(Ta);
var Da = function(line) {
  function t(rt) {
    r(this, t);
    var lists = s(this, line.call(this, rt));
    return va.allRooms = {}, lists;
  }
  return o(t, line), t.prototype.init = function(callback) {
    line.prototype.init.call(this, callback);
    callback.registerCreatedCallbackListener(this.onFire, {
      event : this
    });
  }, t.prototype.onFire = function(e, isDrop) {
    var imgFile = e.thingjsObject;
    var es = e.json2meshObject;
    isDrop.event;
    if ("Room" === imgFile.type && es.userID) {
      va.allRooms[es.userID] = imgFile;
    }
  }, t;
}(Ta);
var Aa = function(b) {
  function a() {
    r(this, a);
    var container = s(this, b.call(this));
    return container.tag = "model-wall", container;
  }
  return o(a, b), a.prototype.init = function(callback) {
    b.prototype.init.call(this, callback);
    callback.registerBuildedCallbackListener(this.onFire, {
      event : this
    });
  }, a.prototype.onFire = function(game, e) {
    game.thingjsObject;
    var room = game.json2meshObject;
    var that = e.event;
    if ("CombineModelWall" === room.type) {
      var deprecatedStylingMethods = that.getMeshes(room.mesh);
      if (deprecatedStylingMethods && deprecatedStylingMethods.length > 0) {
        deprecatedStylingMethods.forEach(function(self) {
          self._cls = that.tag;
        });
      }
    }
  }, a.prototype.getMeshes = function(object) {
    var lsup = [];
    return object.traverse(function(child) {
      if (child.isMesh) {
        lsup.push(child);
      }
    }), lsup;
  }, a;
}(Ta);
var ka = l();
!function(b) {
  function a(e) {
    r(this, a);
    var root = s(this, b.call(this, e));
    return root.app = e.app, root;
  }
  o(a, b);
  a.prototype.init = function(callback) {
    b.prototype.init.call(this, callback);
    callback.registerBuildedCallbackListener(this.onFire, {
      event : this
    });
  };
  a.prototype.onFire = function(e, isDrop) {
    var parent = e.thingjsObject;
    var node = e.json2meshObject;
    isDrop.event;
    if ("CombineDoorOrWindow" === node.type) {
      parent._removeNodeBySceneLoad(node.mesh);
      var objects = node.objects;
      node.transformations;
      node.resource.modelID;
      node.resource.model.updateMatrixWorld();
      var store = e.app.create({
        type : "BatchObject",
        nodeOverride : false,
        node : node.resource.model,
        initBatchNum : objects.length,
        parent : parent
      });
      var i = 0;
      for (; i < objects.length; i++) {
        var obj = objects[i];
        var r = obj.rotation;
        var hmdQuaternion = new THREE.Quaternion(r[0], r[1], r[2], r[3]);
        var originPoint = obj.position;
        var scale = obj.scale;
        var hmdEuler = new THREE.Euler;
        hmdEuler.setFromQuaternion(hmdQuaternion);
        var angles = hmdEuler.toArray();
        angles[0] *= 180 / Math.PI;
        angles[1] *= 180 / Math.PI;
        angles[2] *= 180 / Math.PI;
        store.createSubObject({
          parent : parent,
          id : obj.id,
          localPosition : originPoint,
          scale : scale,
          angles : angles
        });
      }
      Cs.addThingJsObjectSfStyle(store, "Outdoors" === node.parent.type ? _s : Ms);
    }
  };
  a.prototype.calMatrixs = function(options) {
    var id = new THREE.Matrix4;
    var i = options.positions.length - 1;
    for (; i > -1; i--) {
      var fp = options.positions[i];
      var r = options.quaternions[i];
      var vertexData = options.scales[i];
      var ToBuffer$ = new THREE.Vector3(fp[0], fp[1], fp[2]);
      var setPathFromURL = new THREE.Quaternion(r[0], r[1], r[2], r[3]);
      var findStudent = new THREE.Vector3(vertexData[0], vertexData[1], vertexData[2]);
      var R = new THREE.Matrix4;
      R.compose(ToBuffer$, setPathFromURL, findStudent);
      id.premultiply(R);
    }
    return id;
  };
}(Ta);
var Oa = function(e) {
  function t(row) {
    r(this, t);
    var template = s(this, e.call(this, row));
    return template.thingjsParent = template.thingjsParent.misc, template.thingjsParent.loaded = false, template;
  }
  return o(t, e), t;
}(Ls);
Ba = function(e) {
  function t(row) {
    return r(this, t), s(this, e.call(this, row));
  }
  return o(t, e), t;
}(Ds);
Fa = function(callback) {
  function i(string) {
    return r(this, i), s(this, callback.call(this, string));
  }
  return o(i, callback), i.prototype._callback = function(t, args) {
    callback.prototype._callback.call(this, t, args);
    args.thingjsObject.setupTextureAnimations();
  }, i;
}(Vs);
La = function(callback) {
  function i(string) {
    return r(this, i), s(this, callback.call(this, string));
  }
  return o(i, callback), i.prototype._callback = function(t, args) {
    callback.prototype._callback.call(this, t, args);
    args.thingjsObject.setupTextureAnimations();
  }, i;
}(Us);
Ia = function(e) {
  function t() {
    r(this, t);
    var instance = s(this, e.call(this));
    return instance._map.BatchCombinePlacement = Oa, instance._map.BatchPlacement = Ba, instance._map.CombinePlacement = Fa, instance._map.CombineFloor = La, instance;
  }
  return o(t, e), t;
}(ga);
Na = function(f) {
  function t(rt) {
    r(this, t);
    var builder = s(this, f.call(this, rt));
    return builder.createType = "Room", builder;
  }
  return o(t, f), t.prototype.create = function() {
    var root = f.prototype.create.call(this);
    var fixtureDef = this.app.objectManager.create({
      node : new THREE.Object3D,
      parent : this._getParent(root, "CombinedObject"),
      type : "CombinedObject"
    });
    return fixtureDef.userData.type = "CombineMiscParent", fixtureDef.userData.isCombineParent = true, this.thingjsObject;
  }, t;
}(Gs);
Ha = function(e) {
  function t() {
    r(this, t);
    var self = s(this, e.call(this));
    return self._map.Room = Na, self;
  }
  return o(t, e), t;
}(Ia);
Ua = function(e) {
  function d(row) {
    return r(this, d), s(this, e.call(this, row));
  }
  return o(d, e), d.prototype._facadeChildBuildCallback = function(obj, item) {
    var options = item.tjsObject;
    var plugin = item.loader;
    var model = item.relation;
    var p = item.parent;
    options.localPosition = obj.position;
    options.quaternion = obj.rotation;
    options.scale = obj.scale;
    obj.mesh.position.set(0, 0, 0);
    obj.mesh.quaternion.set(0, 0, 0, 1);
    obj.mesh.scale.set(1, 1, 1);
    options._addNodeBySceneLoad(obj.mesh);
    options.setupResources({
      loaded : true
    });
    plugin._checkFacadeBuildedComplete(model, p);
  }, d;
}(Zs);
za = function(e) {
  function t() {
    r(this, t);
    var instance = s(this, e.call(this));
    return instance._map.Facade = Ua, instance;
  }
  return o(t, e), t;
}(Ha);
Va = new (function() {
  function Connection(aDeviceId) {
    r(this, Connection);
    this._versionMap = {
      0 : {
        0 : Ia,
        1 : Ia,
        2 : Ia,
        3 : Ia,
        4 : Ha,
        5 : Ha,
        6 : za
      }
    };
    this._smallVersionLibs = [[0, 1, 2, 3, 4, 5, 6]];
    this._bigVersions = [0];
  }
  return Connection.prototype.getConfig = function(name, idx) {
    if (null == name) {
      name = this._bigVersions[this._bigVersions.length - 1];
      var m = this._smallVersionLibs[name];
      return idx = m[m.length - 1], this._versionMap[name][idx];
    }
    if (null == idx) {
      var m = this._smallVersionLibs[name];
      return idx = m[m.length - 1], this._versionMap[name][idx];
    }
    var mboxes = this._smallVersionLibs[name];
    if (!(name > this._bigVersions[this._bigVersions.length - 1])) {
      return idx > mboxes[mboxes.length - 1] ? this._versionMap[name][mboxes.length - 1]() : this._versionMap[name][idx];
    }
    console.error("maxLoader not support version " + name + "." + idx);
  }, Connection;
}());
Wa = function() {
  function Controller(app) {
    r(this, Controller);
    this.campus = null;
    this.app = app;
    this.enableProxima = false;
    this.enableDynamicLoad = false;
    this.creatorManager = null;
    this.enableBatchObject = false;
    this.resourceManager = null;
    this.events = [];
  }
  return Controller.prototype.setCampus = function(a22) {
    this.campus = a22;
  }, Controller.prototype.parseWorld = function(e, islongclick) {
    this.resourceManager = islongclick;
    this.initEvents();
    this.initCreatorManager(e);
    var n = this.parseJson2meshObject(e);
    return this.processHideObjects(n), n;
  }, Controller.prototype.initCreatorManager = function(fn) {
    var iframe = null;
    iframe = this.enableProxima ? new wa(this.app) : new ga(this.app);
    if (null !== this.campus) {
      iframe.addCreatedThingjsObject(fn, this.campus);
    }
    this.creatorManager = new Rs({
      app : this.app,
      config : iframe,
      events : this.events
    });
  }, Controller.prototype.initEvents = function() {
    var events = this.events;
    if (this.enableDynamicLoad) {
      events.push(new Ma);
    }
    if (this.enableBatchObject) {
      events.push(new Ca({
        app : this.app
      }));
    }
    if (this.enableProxima) {
      events.push(new Da(this.app));
    }
    events.push(new Sa);
    events.push(new ja);
    events.push(new Aa);
    events.push(new Ra({
      app : this.app,
      resourceManager : this.resourceManager
    }));
    events.push(new Pa({
      app : this.app,
      resourceManager : this.resourceManager
    }));
  }, Controller.prototype.parseJson2meshObject = function(a, b) {
    var t = this.creatorManager.createTjsObject(a, b);
    if ("Building" === a.type && this.parseFacades(a, t), this.shouldParseChildren(a)) {
      var aChildren = a.children;
      if (aChildren) {
        var i = 0;
        for (; i < aChildren.length; i++) {
          var value = aChildren[i];
          if ("Facade" !== value.type && "FacadeGroup" !== value.type && "Floor" !== value.type && "Ceiling" !== value.type && "Roof" !== value.type) {
            this.parseJson2meshObject(value, t);
          }
        }
      }
    }
    return t;
  }, Controller.prototype.shouldParseChildren = function(value) {
    return !!value.isContainer;
  }, Controller.prototype.parseFacades = function(d, type) {
    var i = d.typeToChildren.Facade;
    var xx = d.typeToChildren.FacadeGroup;
    if (i || xx) {
      this.creatorManager.createTjsFacadeObject(d, type);
    }
  }, Controller.prototype.processHideObjects = function(att) {
    var data = att.buildings;
    var i = 0;
    for (; i < data.length; i++) {
      var bounds = data[i];
      var t = bounds.floors;
      if (bounds.facade && !bounds.structShow) {
        var k = 0;
        for (; k < t.length; k++) {
          t[k].visible = false;
        }
      } else {
        var k = 0;
        for (; k < t.length; k++) {
          var e = t[k];
          this.hidePlanObjs(e);
        }
      }
    }
  }, Controller.prototype.hidePlanObjs = function(images) {
    if (!images.showObjectsInParentLevels) {
      var affectedData = images.query(".CombinedObject", false);
      var j = 0;
      for (; j < affectedData.length; j++) {
        var data = affectedData[j];
        if ("CombineMiscParent" === data.userData.type) {
          var separated = data.query(".CombinedObject", false);
          var i = 0;
          for (; i < separated.length; i++) {
            var group = separated[i];
            if (!("CombinePlacement" !== group.userData.json2meshType && "CombinePlacementGroup" !== group.userData.json2meshType)) {
              group.visible = false;
            }
          }
        }
      }
      var i = 0;
      for (; i < images.children.length; i++) {
        var t = images.children[i];
        if (!(t.isDoor || "Room" === t.type)) {
          if (!("Thing" === t.type && t.isWindow)) {
            t.visible = false;
          }
        }
      }
    }
  }, Controller.prototype.clear = function() {
    this.creatorManager.clear();
    this.campus = null;
    this.app = null;
    this.enableProxima = false;
    this.enableDynamicLoad = false;
    this.creatorManager = null;
    this.enableBatchObject = false;
    this.resourceManager = null;
    this.events = [];
  }, Controller;
}();
Ga = (function() {
  function t(options) {
    r(this, t);
    this.app = options.app;
    this.sceneUrl = options.sceneUrl;
    this.configJson = null;
  }
  t.prototype.load = function(num) {
    if (num.effectsetting) {
      this.configJson = num.effectsetting;
      this.loadSkybox();
    }
  };
  t.prototype.loadSkybox = function() {
    if ("string" == typeof this.app.skyBox && this.configJson.skybox) {
      var drone = this.configJson.skybox;
      var color = {
        negx : drone.left,
        negy : drone.down,
        negz : drone.back,
        posx : drone.right,
        posy : drone.up,
        posz : drone.front
      };
      this.app.skyBox = color;
    }
  };
}(), function() {
  function init(value, me, config) {
    r(this, init);
    this.app = value;
    this.resourceUrl = null;
    this.relativeResourceUrl = null;
    this.sceneJson = null;
    this.scale = 1;
    this.curFloorPlan = null;
    this.tempTexture = null;
    this.indexJson = me;
    this.sceneJsonUri = "scene.json";
    this.defaultWallTextureUri = "Textures/RoomWall.jpg";
    this.defaultWallEdgeTextureUri = "Textures/WallEdge.jpg";
    this.defaultFloorTextureUri = "Textures/FloorDefault.jpg";
    this.defaultCeilingTextureUri = "Textures/CeilingDefault.jpg";
    this.defaultRoofTextureUri = "Textures/RoofDefault.jpg";
    this.defaultWallTexture = null;
    this.defaultCeilingTexture = null;
    this.defaultFloorTexture = null;
    this.defaultRoofTexture = null;
    this.defaultWallEdgeTexture = null;
    this.worldNode = new THREE.Object3D("world");
    this.isCamFitScene = true;
    this.campus = null;
    this.outdoorsVisible = true;
    this.campusVisible = true;
    this.enableUseHighestVersionResource = true;
    this.enableDownloadSceneJsonCache = true;
    this.enableDynamicLoad = false;
    this.enableProxima = false;
    this.enableBatchObject = false;
    this._json2meshLoadedCallbacks = [];
    this.effectSettingLoader = null;
    if (this.app.options._json2meshObjectLoaded) {
      this.registerJson2meshLoadedListener(this.app.options._json2meshObjectLoaded);
    }
    this.worldNode;
    if (me && (me.position && (this.campusPosition = me.position), me.rotation && (this.campusRotation = me.rotation), void 0 !== me.isCamFitScene && null !== me.isCamFitScene && (this.isCamFitScene = me.isCamFitScene), me.scale && (this.campusScale = me.scale), void 0 !== me.outdoorsVisible && (this.outdoorsVisible = me.outdoorsVisible), void 0 !== me.campusVisible && (this.campusVisible = me.campusVisible), me.campus && (this.campus = me.campus), me.enableDynamicLoadScene && (this.enableDynamicLoad = 
    me.enableDynamicLoadScene), me.enableProxima && (this.enableProxima = me.enableProxima), me.enableBatchObject && (this.enableBatchObject = me.enableBatchObject), void 0 !== me.enableUseHighestVersionResource && (this.enableUseHighestVersionResource = me.enableUseHighestVersionResource), void 0 !== me.enableDownloadSceneJsonCache && (this.enableDownloadSceneJsonCache = me.enableDownloadSceneJsonCache), me.startDownloadResourcesCallback && (this.startDownloadResourcesCallback = me.startDownloadResourcesCallback)), 
    this.campus && (this.campusRotation && this.campus.node.quaternion.set(this.campusRotation.x, this.campusRotation.y, this.campusRotation.z, this.campusRotation.w), this.campusPosition && (this.campus.position = this.campusPosition), this.campusScale && (this.campus.scale = this.campusScale)), me.default) {
      var toolsElement = me.default;
      if (toolsElement.sceneJson) {
        this.sceneJson = "export.json";
      }
      if (toolsElement.wallTexture) {
        this.defaultWallTextureUri = toolsElement.wallTexture;
      }
      if (toolsElement.wallEdgeTexture) {
        this.defaultWallEdgeTextureUri = toolsElement.wallEdgeTexture;
      }
      if (toolsElement.floorTexture) {
        this.defaultFloorTextureUri = toolsElement.floorTexture;
      }
      if (toolsElement.ceilingTexture) {
        this.defaultCeilingTextureUri = toolsElement.ceilingTexture;
      }
      if (toolsElement.roofTexture) {
        this.defaultRoofTextureUri = toolsElement.roofTexture;
      }
    }
    if (config.loaderResourceUrl) {
      this.resourceUrl = config.loaderResourceUrl;
    }
    if (void 0 !== this.app.options.enableUseHighestVersionResource) {
      this.enableUseHighestVersionResource = this.app.options.enableUseHighestVersionResource;
    }
    if (void 0 !== this.app.options.enableBatchObject && this.app.options.enableBatchObject) {
      json2mesh.DefaultSetting.enableCombinePlacementToBuildMesh = false;
      this.enableBatchObject = this.app.options.enableBatchObject;
    }
    if (this.app.options.resourceLibraryUrl) {
      this.resourceUrl = this.app.options.resourceLibraryUrl;
    }
    if (this.indexJson.resourceLibrary) {
      this.relativeResourceUrl = this.indexJson.resourceLibrary;
    }
    if (!this.enableDownloadSceneJsonCache) {
      this.sceneJsonUri += "?_t=" + (new Date).getTime();
    }
    this.json2meshToThingjsParser = null;
  }
  return init.prototype.parseCamInfo = function(data) {
    var t = data.eye;
    var i = data.target;
    var filem = t.split(" ");
    var cmd_s = i.split(" ");
    var songsHeaders = [Number(filem[0]), Number(filem[1]), Number(filem[2])];
    songsHeaders[2] = -songsHeaders[2];
    var delegatorRoot = [Number(cmd_s[0]), Number(cmd_s[1]), Number(cmd_s[2])];
    delegatorRoot[2] = -delegatorRoot[2];
    this.app.camera.position = songsHeaders;
    this.app.camera.target = delegatorRoot;
  }, init.prototype.load = function(item) {
    var self = this;
    if (self.json2meshToThingjsParser = new Wa(self.app), self.enableProxima && (self.json2meshToThingjsParser.enableProxima = true, json2mesh.DefaultSetting.enableCombinePlacementsByRoom = true), self.enableBatchObject && (self.json2meshToThingjsParser.enableBatchObject = self.enableBatchObject), "String" === item.constructor.name) {
      this.sceneURL = item;
    } else {
      if ("Object" === item.constructor.name) {
        var doc = item;
        this.sceneURL = doc.url;
        if (doc.campus) {
          this.campus = doc.campus;
          this.worldNode = this.campus.node;
          this.json2meshToThingjsParser.setCampus(this.campus);
        }
        if (doc.json) {
          this.sceneJson = doc.json;
        }
      }
    }
    return this.relativeResourceUrl && (0 === this.relativeResourceUrl.indexOf("./") ? this.resourceUrl = this.sceneURL + this.relativeResourceUrl.replace("./", "/") : this.resourceUrl = this.relativeResourceUrl), new Promise(function($, i) {
      self.updateProgress(.1);
      self.loadSceneJson().then(function(i) {
        if (!self.sceneJson) {
          self.sceneJsonString = i;
          self.sceneJson = JSON.parse(i);
        }
        if (self.sceneJson.camInfo && self.isCamFitScene) {
          self.parseCamInfo(self.sceneJson.camInfo);
        }
        self.updateProgress(.1);
        var model = new json2mesh.UBuilderSceneLoader;
        if (void 0 !== self.app.options.loadingSceneMaxResourcesUnitDownloadNumber) {
          model.setResourcesUnitDownloadNumber(self.app.options.loadingSceneMaxResourcesUnitDownloadNumber);
        }
        if (void 0 !== self.app.options.loadingSceneAwaitToNextBuildTime) {
          model.dynamicBuildManager.awaitToNextBuildTime = self.app.options.loadingSceneAwaitToNextBuildTime;
        }
        if (self.enableDynamicLoad) {
          model.enableRequestWorld = false;
          self.json2meshToThingjsParser.enableDynamicLoad = true;
        }
        if (self.resourceUrl) {
          model.resourceManager.baseTextureUrl = self.resourceUrl + "/texture/";
          model.resourceManager.baseModelUrl = self.resourceUrl + "/model/";
        }
        model.resourceManager.enableUserHighestVersionResource = self.enableUseHighestVersionResource;
        self.loader = model;
        model.load({
          json : self.sceneJson,
          customModeBaseUrl : self.sceneURL + "/",
          bigVersion : self.indexJson.bigVersion,
          smallVersion : self.indexJson.smallVersion
        }).then(function(i) {
          self._notifyJson2meshLoadedListeners(i);
          var storageFacility = new Ps;
          storageFacility.parseWorld(i);
          storageFacility.clear();
          if (self.sceneJson.camInfo && self.isCamFitScene) {
            self.parseCamInfo(self.sceneJson.camInfo);
          }
          self.campus.visible = self.campusVisible;
          if (self.campusRotation) {
            self.campus.node.quaternion.set(self.campusRotation.x, self.campusRotation.y, self.campusRotation.z, self.campusRotation.w);
          }
          if (self.campusPosition) {
            self.campus.position = self.campusPosition;
          }
          if (self.campusScale) {
            self.campus.scale = self.campusScale;
          }
          if (self.startDownloadResourcesCallback) {
            self.startDownloadResourcesCallback(model.resourceManager.models, model.resourceManager.textures);
          }
          self.campus = self.json2meshToThingjsParser.parseWorld(i, model.resourceManager);
          if (self.enableDynamicLoad) {
            self.loadExtraData(self.campus);
            self.updateProgress(1);
            $(self.campus);
          } else {
            model.startToBuild(function(i) {
              self.updateProgress(.1 + .9 * i);
              if (1 === i) {
                self.updateProgress(1);
                self.loadExtraData(self.campus);
                $(self.campus);
              }
            });
          }
        });
      });
    });
  }, init.prototype.loadExtraData = function(eventData) {
    if (this.sceneJson.extraData) {
      eventData.extraData = this.sceneJson.extraData;
    }
  }, init.prototype.loadSceneJson = function(e) {
    var resp = this;
    return e && (resp.sceneURL = e), new Promise(function(continuation, i) {
      if (resp.sceneJson) {
        continuation(resp.sceneJson);
      } else {
        (new THREE.FileLoader(resp.app.loadingManager)).load(resp.sceneURL.appendURL(resp.sceneJsonUri), function(url) {
          continuation(url);
        });
      }
    });
  }, init.prototype.updateProgress = function(data) {
    this.app.mainUI.updateLoadingProcess({
      object : this.campus,
      progress : data
    });
  }, init.prototype.startToDownloadRequestResources = function(playlist) {
    this.loader.resourceManager.startToDownloadRequestResources(playlist);
  }, init.prototype.addResourceDownloadRequest = function(e) {
    this.loader.resourceManager.addResourceDownloadRequest(e);
  }, init.prototype.clearAllResources = function() {
    this.clear();
  }, init.prototype.clearAllObjects = function() {
    this.loader.clearAllObjects();
    this.world = null;
  }, init.prototype.clear = function() {
    this.loader.clearAllResources();
    this.json2meshToThingjsParser.clear();
    this.resourceUrl = null;
    this.relativeResourceUrl = null;
    this.sceneJson = null;
    this.scale = 1;
    this.curFloorPlan = null;
    this.tempTexture = null;
    this.indexJson = null;
    this.sceneJsonUri = null;
    this.defaultWallTextureUri = null;
    this.defaultWallEdgeTextureUri = null;
    this.defaultFloorTextureUri = null;
    this.defaultCeilingTextureUri = null;
    this.defaultRoofTextureUri = null;
    this.defaultWallTexture = null;
    this.defaultCeilingTexture = null;
    this.defaultFloorTexture = null;
    this.defaultRoofTexture = null;
    this.defaultWallEdgeTexture = null;
    this.worldNode = new THREE.Object3D("world");
    this.isCamFitScene = true;
    this.campus = null;
    this.outdoorsVisible = true;
    this.campusVisible = true;
    this.enableUseHighestVersionResource = true;
    this.enableDownloadSceneJsonCache = true;
    this.enableDynamicLoad = false;
    this.enableProxima = false;
    this.enableBatchObject = false;
  }, init.prototype.requestToBuild = function(playlist) {
    this.loader.requestToBuild(playlist);
  }, init.prototype.startToBuild = function(playlist) {
    return this.loader.startToBuild(playlist);
  }, init.prototype.disposeObject = function(id) {
    var value = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    this.loader.disposeObject(id, value);
  }, init.prototype.findObjectByID = function(e) {
    return this.world.findObjectByID(e);
  }, init.prototype.registerJson2meshLoadedListener = function(e) {
    this._json2meshLoadedCallbacks.push(e);
  }, init.prototype._notifyJson2meshLoadedListeners = function(aRoundNumber) {
    var layer_i = 0;
    for (; layer_i < this._json2meshLoadedCallbacks.length; layer_i++) {
      (0, this._json2meshLoadedCallbacks[layer_i])(aRoundNumber);
    }
  }, init;
}());
qa = function() {
  function render(App) {
    r(this, render);
    this.app = App;
    this.nodes = [];
    this.scene = this.app.scene;
    this.objectPool = this.app.objectPool;
    this.rootNode = null;
    this.campus = null;
    this.sceneURL = null;
    this.sceneJsonData = null;
    this.loadedSceneGLTF = null;
    this.worldNode = new THREE.Object3D;
    this.fitCamInfo = null;
  }
  return render.prototype.parse = function(e) {
    if (this.parseWorld(e), e.camInfo) {
      var pubDateEl = e.camInfo;
      this.fitCamInfo = pubDateEl;
    }
  }, render.prototype.parseCamInfo = function(data) {
    var t = data.eye;
    var i = data.target;
    var filem = t.split(" ");
    var cmd_s = i.split(" ");
    var songsHeaders = [Number(filem[0]), Number(filem[1]), Number(filem[2])];
    songsHeaders[2] = -songsHeaders[2];
    var delegatorRoot = [Number(cmd_s[0]), Number(cmd_s[1]), Number(cmd_s[2])];
    delegatorRoot[2] = -delegatorRoot[2];
    this.app.camera.position = songsHeaders;
    this.app.camera.target = delegatorRoot;
  }, render.prototype.parseWorld = function(options) {
    var slideDragNode = this.worldNode;
    if (null == this.campus && (this.campus = this.app.objectManager.create({
      type : "Campus",
      name : "Campus",
      node : slideDragNode
    }), this.campus.node.name = "campus", this.app.scene.add(this.campus.node)), options.outdoors && this.parseOutdoors(options.outdoors), options.buildings) {
      var data = options.buildings;
      this.parseBuildings(data);
    }
  }, render.prototype.parseOutdoors = function(system_constant) {
    var t = system_constant;
    var slideDragNode = new THREE.Object3D;
    this.outdoors = this.app.objectManager.create({
      type : "Outdoors",
      name : "Outdoors",
      parent : this.campus,
      node : slideDragNode
    });
    var file = this.outdoors;
    if (!this.app.outdoors) {
      this.app.outdoors = this.outdoors;
      this.app.currentParentObject = this.outdoors;
    }
    var id = t.gltfid;
    if (id && this.nodes[id]) {
      var node = this.nodes[id];
      THREE.SceneUtils.detach(node, node.parent, this.app.scene);
      THREE.SceneUtils.attach(node, this.app.scene, file.node);
      file.node.updateMatrixWorld();
    }
    this.parseFloorPlan(t, file);
  }, render.prototype.parseBuildings = function(data) {
    var name;
    for (name in data) {
      var v = data[name];
      var n = name;
      if (v.name) {
        n = v.name;
      }
      var node = null;
      if (v.gltfid) {
        var i = v.gltfid;
        if (this.nodes[i]) {
          node = this.nodes[i];
        }
      }
      var s = this.app.objectManager.create({
        type : "Building",
        name : n,
        parent : this.campus,
        node : node
      });
      if (v.plans) {
        this.parseFloorPlans(v.plans, s);
      }
      if (v.facades) {
        this.parseFacades(v.facades, s);
      }
    }
  }, render.prototype.parseFloorPlans = function(frames, value) {
    var name;
    for (name in frames) {
      var node = null;
      var n = frames[name];
      var host = name;
      if (n.name) {
        host = n.name;
      }
      var nodeName = n.gltfid;
      if (nodeName && this.nodes[nodeName]) {
        node = this.nodes[nodeName];
      }
      var a = this.app.objectManager.create({
        type : "Floor",
        name : host,
        node : node,
        parent : value
      });
      this.parseFloorPlan(n, a);
    }
  }, render.prototype.parseFloorPlan = function(data, obj) {
    if (data.placements) {
      this.parseThings(data.placements, obj);
    }
    if (data.videoprobes) {
      this.parseThings(data.videoprobes, obj);
    }
    if (data.doororwindows) {
      this.parseDoorWins(data.doororwindows, obj);
    }
    if (data.routes) {
      this.parseThings(data.routes, obj);
    }
    if (data.pipelines) {
      this.parseThings(data.pipelines, obj);
    }
    if (data.curvelines) {
      this.parseThings(data.curvelines, obj);
    }
    if (data.arrowlines) {
      this.parseThings(data.arrowlines, obj);
    }
    if (data.arrowdatalines) {
      this.parseThings(data.arrowdatalines, obj);
    }
    if (data.leakwaterlines) {
      this.parseThings(data.leakwaterlines, obj);
    }
    if (data.rooms) {
      this.parseRooms(data.rooms, obj);
    }
    this.parseStructure(data, obj);
    var groups = data.groups;
    if (groups) {
      this.parseGroup(groups, obj);
    }
  }, render.prototype.parseRooms = function(el, t) {
    var i = 0;
    for (; i < el.length; i++) {
      var data = el[i];
      var n = null;
      if (data.name) {
        n = data.name;
      }
      var node = null;
      var index = data.gltfid;
      if (index && this.nodes[index]) {
        node = this.nodes[index];
      }
      var properties = null;
      var obj = data.properties;
      if (obj) {
        var key;
        for (key in properties = {}, obj) {
          var val = obj[key];
          properties[key] = val;
        }
      }
      var teaser = null;
      var _ref3 = null;
      var obj2 = null;
      if (data.floor) {
        index = data.floor.gltfid;
        if (this.nodes[index]) {
          obj2 = this.nodes[index];
        }
      }
      if (data.ceiling) {
        index = data.ceiling.gltfid;
        if (this.nodes[index]) {
          teaser = this.nodes[index];
        }
      }
      if (data.roof) {
        index = data.roof.gltfid;
        if (this.nodes[index]) {
          _ref3 = this.nodes[index];
        }
      }
      var _child = null;
      var area = null;
      var subscribers = null;
      var segment = {};
      if (data.area && (area = data.area, segment.area = area), data.circumference && (subscribers = data.circumference, segment.circumference = subscribers), data.center) {
        var p2 = data.center;
        (_child = new THREE.Vector3).set(p2[0], p2[1], -p2[2]);
        segment.center = _child;
      }
      var now = data.isShown;
      if (now) {
        var visible = "false" !== (now = now.toLowerCase());
        node.visible = visible;
      }
      this.app.objectManager.create({
        type : "Room",
        name : n,
        node : node,
        ceilingNode : teaser,
        roofNode : _ref3,
        floorNode : obj2,
        parent : t,
        properties : properties,
        auxiliaryInfo : segment
      });
    }
  }, render.prototype.parseStructure = function(out, data) {
    if (out.structure) {
      var field_dict = (out = out.structure).placements;
      if (field_dict) {
        var k;
        for (k in field_dict) {
          var i = field_dict[k].gltfid;
          var parent = this.nodes[i];
          if (parent) {
            data.miscNode = parent.parent;
            break;
          }
        }
      }
      var mod = out.walls;
      if (mod) {
        for (k in mod) {
          i = mod[k].gltfid;
          var parent = this.nodes[i];
          if (parent) {
            data.wallNode = parent.parent;
            break;
          }
        }
      }
      var val = out.roofs;
      if (val) {
        for (k in val) {
          i = val[k].gltfid;
          var parent = this.nodes[i];
          if (parent) {
            data.roofNode = parent.parent;
            break;
          }
        }
      }
      var f = out.ceilings;
      if (f) {
        for (k in f) {
          i = f[k].gltfid;
          var parent = this.nodes[i];
          if (parent) {
            data.ceilingNode = parent.parent;
            break;
          }
        }
      }
      if (data = out.floors) {
        for (k in data) {
          var data;
          if (i = (data = data[k]).gltfid) {
            var parent = this.nodes[i];
            if (parent) {
              data.floorNode = parent.parent;
              break;
            }
          }
        }
      }
    }
  }, render.prototype.parseGroup = function(array, value) {
    var i;
    for (i in array) {
      var data = array[i];
      var last = i;
      if (data.name) {
        last = data.name;
      }
      var node = null;
      var nodeName = data.gltfid;
      if (nodeName && this.nodes[nodeName]) {
        node = this.nodes[nodeName];
      }
      var properties = null;
      var obj = data.properties;
      if (obj) {
        var key;
        for (key in properties = {}, obj) {
          var val = obj[key];
          properties[key] = val;
        }
      }
      this.app.objectManager.create({
        type : "Thing",
        name : last,
        node : node,
        parent : value,
        properties : properties
      });
      if (data.placements) {
        this.parseThings(data.placements, value);
      }
    }
  }, render.prototype.parseFacades = function(i, target) {
    var d;
    for (d in i) {
      var e = i[d];
      var f = d;
      if (e.name) {
        f = e.name;
      }
      var obj = null;
      var id = e.gltfid;
      if (id && this.nodes[id]) {
        obj = this.nodes[id];
      }
      var output = null;
      var state = e.properties;
      if (state) {
        var category;
        for (category in output = {}, state) {
          var e = state[category];
          output[category] = e;
        }
      }
      var oq = e.isShown;
      if (oq) {
        var groupVisible = "false" !== (oq = oq.toLowerCase());
        obj.visible = groupVisible;
      }
      this.app.objectManager.create({
        type : "Facade",
        name : f,
        node : obj,
        parent : target,
        properties : output
      });
      target.node.add(obj);
    }
  }, render.prototype.parseThings = function(val, view) {
    var i;
    for (i in val) {
      var item = val[i];
      var name = item.name || i;
      var GET_USER_PROFILE_SUCCESS = item.type || "Thing";
      var node = null;
      var nodeName = item.gltfid;
      if (nodeName && this.nodes[nodeName]) {
        node = this.nodes[nodeName];
      }
      var values = null;
      var obj = item.properties;
      if (obj) {
        var key;
        for (key in values = {}, obj) {
          var newVal = obj[key];
          values[key] = newVal;
        }
      }
      var lk = item.isShown;
      if (lk) {
        var visible = "false" !== (lk = lk.toLowerCase());
        node.visible = visible;
      }
      this.app.objectManager.create({
        type : GET_USER_PROFILE_SUCCESS,
        name : name,
        node : node,
        parent : view,
        properties : values
      });
    }
  }, render.prototype.parseDoorWins = function(tab, value) {
    var name;
    for (name in tab) {
      var r = tab[name];
      var n = name;
      if (r.name) {
        n = r.name;
      }
      var node = null;
      if (r.gltfid) {
        var i = r.gltfid;
        if (this.nodes[i]) {
          node = this.nodes[i];
        }
      }
      var properties = null;
      if (r.properties) {
        var obj = r.properties;
        var key;
        for (key in properties = {}, obj) {
          var val = obj[key];
          properties[key] = val;
        }
      }
      this.app.objectManager.create({
        type : "Door",
        name : n,
        node : node,
        parent : value,
        properties : properties
      });
    }
  }, render.prototype.load = function(node) {
    var self = this;
    if ("String" === node.constructor.name) {
      this.sceneURL = node;
    } else {
      if ("Object" === node.constructor.name) {
        var me = node;
        this.sceneURL = me.url;
        if (me.campus) {
          this.campus = me.campus;
          this.worldNode = this.campus.node;
        }
      }
    }
    return new Promise(function($, i) {
      self.loadGLTF().then(function(state) {
        return self.loadedSceneGLTF = state, state.scene.traverse(function(unit) {
          self.nodes[unit.name] = unit;
        }), self.parseSceneJson();
      }).then(function(i) {
        if (self.fitCamInfo) {
          self.parseCamInfo(self.fitCamInfo);
        } else {
          if (self.campus.node) {
            self.app.camera.fit(self.campus);
          }
        }
        $(self.campus);
      }).catch(function() {
        self.campus.node.add(self.loadedSceneGLTF.scene.children[0]);
        if (self.campus) {
          self.app.camera.fit(self.campus);
        }
        $(self.campus);
      });
    });
  }, render.prototype.loadGLTF = function() {
    var pageViewData = this;
    return new Promise(function(saveNotifs, i) {
      var loader = new THREE.GLTFLoader(pageViewData.app.loadingManager);
      loader.setCrossOrigin("anonymous");
      loader.load(pageViewData.sceneURL + "/Unity2GLTF.gltf", function(notifications) {
        saveNotifs(notifications);
      });
    });
  }, render.prototype.parseSceneJson = function() {
    var _this = this;
    return new Promise(function(returnResultsFn, saveNotifs) {
      (new THREE.FileLoader(_this.app.loadingManager)).load(_this.sceneURL + "/scene.json", function(i) {
        var r = JSON.parse(i);
        _this.sceneJsonData = r;
        _this.parseWorld(r);
        returnResultsFn(r);
      }, function() {
      }, function() {
        THING.Utils.error("not find file scene.json ");
        saveNotifs();
      });
    });
  }, render;
}();
Xa = function(b) {
  function t(out, h, c) {
    return r(this, t), s(this, b.call(this, out, h, c));
  }
  return o(t, b), t.prototype.load = function(item) {
    var self = this;
    if (self.json2meshToThingjsParser = new Wa(self.app), self.enableProxima && (self.json2meshToThingjsParser.enableProxima = true, json2mesh.DefaultSetting.enableCombinePlacementsByRoom = true), self.enableBatchObject && (self.json2meshToThingjsParser.enableBatchObject = self.enableBatchObject), "String" === item.constructor.name) {
      this.sceneURL = item;
    } else {
      if ("Object" === item.constructor.name) {
        var doc = item;
        this.sceneURL = doc.url;
        if (doc.campus) {
          this.campus = doc.campus;
          this.worldNode = this.campus.node;
          this.json2meshToThingjsParser.setCampus(this.campus);
        }
        if (doc.json) {
          this.sceneJson = doc.json;
        }
      }
    }
    return this.relativeResourceUrl && (0 === this.relativeResourceUrl.indexOf("./") ? this.resourceUrl = this.sceneURL + this.relativeResourceUrl.replace("./", "/") : this.resourceUrl = this.relativeResourceUrl), new Promise(function($, i) {
      self.updateProgress(.1);
      self.loadSceneJson().then(function(i) {
        if (!self.sceneJson) {
          self.sceneJsonString = i;
          self.sceneJson = JSON.parse(i);
        }
        if (self.sceneJson.camInfo && self.isCamFitScene) {
          self.parseCamInfo(self.sceneJson.camInfo);
        }
        self.updateProgress(.1);
        var model = new json2mesh.UBuilderSceneLoader;
        if (void 0 !== self.app.options.loadingSceneMaxResourcesUnitDownloadNumber) {
          model.setResourcesUnitDownloadNumber(self.app.options.loadingSceneMaxResourcesUnitDownloadNumber);
        }
        if (void 0 !== self.app.options.loadingSceneAwaitToNextBuildTime) {
          model.dynamicBuildManager.awaitToNextBuildTime = self.app.options.loadingSceneAwaitToNextBuildTime;
        }
        if (self.enableDynamicLoad) {
          model.enableRequestWorld = false;
          self.json2meshToThingjsParser.enableDynamicLoad = true;
        }
        var m_composite = "https://www.thingjs.com/";
        if (self.resourceUrl) {
          model.resourceManager.baseTextureUrl = self.resourceUrl + "/texture/";
          model.resourceManager.baseModelUrl = self.resourceUrl + "/model/";
          m_composite = self.resourceUrl + "/";
        }
        self.loader = model;
        model.load({
          json : self.sceneJson,
          bigVersion : self.indexJson.bigVersion,
          smallVersion : self.indexJson.smallVersion,
          customModeBaseUrl : m_composite
        }).then(function(i) {
          self._notifyJson2meshLoadedListeners(i);
          (new Ps).parseWorld(i);
          if (self.sceneJson.camInfo && self.isCamFitScene) {
            self.parseCamInfo(self.sceneJson.camInfo);
          }
          self.campus.visible = self.campusVisible;
          if (self.campusRotation) {
            self.campus.node.quaternion.set(self.campusRotation.x, self.campusRotation.y, self.campusRotation.z, self.campusRotation.w);
          }
          if (self.campusPosition) {
            self.campus.position = self.campusPosition;
          }
          if (self.campusScale) {
            self.campus.scale = self.campusScale;
          }
          if (self.startDownloadResourcesCallback) {
            self.startDownloadResourcesCallback(model.resourceManager.models, model.resourceManager.textures);
          }
          self.campus = self.json2meshToThingjsParser.parseWorld(i, model.resourceManager);
          if (self.enableDynamicLoad) {
            self.loadExtraData(self.campus);
            self.updateProgress(1);
            $(self.campus);
          } else {
            model.startToBuild(function(i) {
              self.updateProgress(.1 + .9 * i);
              if (1 === i) {
                self.updateProgress(1);
                self.loadExtraData(self.campus);
                $(self.campus);
              }
            });
          }
        });
      });
    });
  }, t;
}(Ga);
Ja = function(t) {
  function a(module) {
    return r(this, a), s(this, t.call(this, module));
  }
  return o(a, t), a.prototype.init = function(callback) {
    t.prototype.init.call(this, callback);
    callback.registerBuildedCallbackListener(this._buildCallback, {
      event : this
    });
  }, a.prototype._buildCallback = function(controller, opt) {
    var options = controller.thingjsObject;
    var params = controller.json2meshObject;
    if ("Facade" !== options.type) {
      options.localPosition = params.position;
      options.scale = params.scale;
      if (params.rotation) {
        options.node.quaternion.set(params.rotation[0], params.rotation[1], params.rotation[2], params.rotation[3]);
      }
    }
  }, a;
}(Ta);
Ya = function(b) {
  function a(e) {
    r(this, a);
    var root = s(this, b.call(this, e));
    return root.app = e.app, root;
  }
  return o(a, b), a.prototype.init = function(callback) {
    b.prototype.init.call(this, callback);
    callback.registerBuildedCallbackListener(this.onFire, {
      event : this
    });
  }, a.prototype.onFire = function(m, e) {
    var type = m.thingjsObject;
    var data = m.json2meshObject;
    var that = e.event;
    if ("BatchCombinePlacement" === data.type) {
      var o = data.objects;
      if (0 === o.length) {
        return;
      }
      type.node.remove(data.mesh);
      var commits = data.transformations;
      var applyDataChange = data.resource.modelID;
      data.resource.model.updateMatrixWorld();
      var fn = m.app.create({
        type : "BatchObject",
        nodeOverride : false,
        node : data.resource.model,
        initBatchNum : o.length,
        parent : type
      });
      var i = 0;
      for (; i < o.length; i++) {
        var url = o[i];
        var transform = that.calMatrixs(commits[i]);
        var center = new THREE.Vector3;
        var s = new THREE.Vector3;
        var quaternion = new THREE.Quaternion;
        transform.decompose(center, quaternion, s);
        var oldModuleLoader = center.toArray();
        var tmp = s.toArray();
        var result = new THREE.Euler;
        result.setFromQuaternion(quaternion);
        var clsNs = result.toArray();
        clsNs[0] *= 180 / Math.PI;
        clsNs[1] *= 180 / Math.PI;
        clsNs[2] *= 180 / Math.PI;
        var def = that.getSubObjectParams(url);
        def.localPosition = oldModuleLoader;
        def.scale = tmp;
        def.angles = clsNs;
        def.parent = type;
        fn.createSubObject(def);
      }
      Cs.addBatchCombinePlacementStyle(fn, data, applyDataChange);
    }
  }, a.prototype.getSubObjectParams = function(params) {
    var item = {
      uuid : params.id
    };
    return null !== params.userID && (item.id = params.userID), null !== params.name && (item.name = params.name), null !== params.properties && (item.properties = params.properties), item;
  }, a.prototype.calMatrixs = function(options) {
    var id = new THREE.Matrix4;
    var i = options.positions.length - 1;
    for (; i > -1; i--) {
      var fp = options.positions[i];
      var r = options.quaternions[i];
      var vertexData = options.scales[i];
      var ToBuffer$ = new THREE.Vector3(fp[0], fp[1], fp[2]);
      var setPathFromURL = new THREE.Quaternion(r[0], r[1], r[2], r[3]);
      var findStudent = new THREE.Vector3(vertexData[0], vertexData[1], vertexData[2]);
      var R = new THREE.Matrix4;
      R.compose(ToBuffer$, setPathFromURL, findStudent);
      id.premultiply(R);
    }
    return id;
  }, a;
}(Ta);
Qa = function(b) {
  function a(e) {
    r(this, a);
    var root = s(this, b.call(this, e));
    return root.app = e.app, root;
  }
  return o(a, b), a.prototype.init = function(callback) {
    b.prototype.init.call(this, callback);
    callback.registerBuildedCallbackListener(this.onFire, {
      event : this
    });
  }, a.prototype.onFire = function(m, e) {
    var type = m.thingjsObject;
    var data = m.json2meshObject;
    var that = e.event;
    if ("BatchPlacement" === data.type) {
      var o = data.objects;
      if (0 === o.length) {
        return;
      }
      type.node.remove(data.mesh);
      var commits = data.transformations;
      var applyDataChange = data.resource.modelID;
      data.resource.model.updateMatrixWorld();
      var fn = m.app.create({
        type : "BatchObject",
        nodeOverride : false,
        node : data.resource.model,
        initBatchNum : o.length,
        parent : type
      });
      var i = 0;
      for (; i < o.length; i++) {
        var url = o[i];
        var transform = that.calMatrixs(commits[i]);
        var center = new THREE.Vector3;
        var s = new THREE.Vector3;
        var quaternion = new THREE.Quaternion;
        transform.decompose(center, quaternion, s);
        var oldModuleLoader = center.toArray();
        var tmp = s.toArray();
        var result = new THREE.Euler;
        result.setFromQuaternion(quaternion);
        var clsNs = result.toArray();
        clsNs[0] *= 180 / Math.PI;
        clsNs[1] *= 180 / Math.PI;
        clsNs[2] *= 180 / Math.PI;
        var def = that.getSubObjectParams(url);
        def.localPosition = oldModuleLoader;
        def.scale = tmp;
        def.angles = clsNs;
        def.parent = type;
        fn.createSubObject(def);
      }
      Cs.addBatchPlacementStyle(fn, data, applyDataChange);
    }
  }, a.prototype.getSubObjectParams = function(params) {
    var item = {
      uuid : params.id
    };
    return null !== params.userID && (item.id = params.userID), null !== params.name && (item.name = params.name), null !== params.properties && (item.properties = params.properties), item;
  }, a.prototype.getMeshes = function(object) {
    var lsup = [];
    return object.traverse(function(child) {
      if (child.isMesh) {
        lsup.push(child);
      }
    }), lsup;
  }, a.prototype.addSfStyle = function(object, old_len) {
    var meshes = this.getMeshes(object);
    if (meshes && meshes.length > 0) {
      var i = 0;
      for (; i < meshes.length; i++) {
        meshes[i]._sfStyle = old_len;
      }
    }
  }, a.prototype.isTree = function(col) {
    return !!treeModels[col];
  }, a.prototype.calMatrixs = function(options) {
    var id = new THREE.Matrix4;
    var i = options.positions.length - 1;
    for (; i > -1; i--) {
      var fp = options.positions[i];
      var r = options.quaternions[i];
      var vertexData = options.scales[i];
      var ToBuffer$ = new THREE.Vector3(fp[0], fp[1], fp[2]);
      var setPathFromURL = new THREE.Quaternion(r[0], r[1], r[2], r[3]);
      var findStudent = new THREE.Vector3(vertexData[0], vertexData[1], vertexData[2]);
      var R = new THREE.Matrix4;
      R.compose(ToBuffer$, setPathFromURL, findStudent);
      id.premultiply(R);
    }
    return id;
  }, a;
}(Ta);
Za = function(t) {
  function a(module) {
    return r(this, a), s(this, t.call(this, module));
  }
  return o(a, t), a.prototype.init = function(callback) {
    t.prototype.init.call(this, callback);
    callback.registerCreatedCallbackListener(this._createdCallback, {
      event : this
    });
  }, a.prototype._createdCallback = function(handler, eventParams) {
    var platform = handler.thingjsObject;
    var proto = handler.json2meshObject;
    var serviceCallEvent = eventParams.event;
    if (proto.resource) {
      proto.resource.registerBuildCallbackListener(serviceCallEvent._resourceBuildedCallback, {
        event : this,
        tjsObject : platform
      });
    }
  }, a.prototype._resourceBuildedCallback = function(outputPos, result) {
    var courseSections = result.tjsObject;
    if (outputPos.indexJson) {
      courseSections._extensionsFile = outputPos.indexJson.extensionsfile || null;
    }
  }, a;
}(Ta);
Ka = function(e) {
  function d(row) {
    r(this, d);
    var container = s(this, e.call(this, row));
    return container.enableBuildMaxPlacemenetBatch = true, container;
  }
  return o(d, e), d.prototype.parseWorld = function(v, _, prop, styles) {
    this.resourceManager = _;
    this.initEvents();
    this.initCreatorManager(v, prop, styles);
    var n = this.parseJson2meshObject(v);
    return this.processHideObjects(n), n;
  }, d.prototype.initCreatorManager = function(event, prop, opts) {
    var controller = new (Va.getConfig(prop, opts))(this.app);
    if (null !== this.campus) {
      controller.addCreatedThingjsObject(event, this.campus);
    }
    this.creatorManager = new Rs({
      app : this.app,
      config : controller,
      events : this.events
    });
  }, d.prototype.initEvents = function() {
    var events = this.events;
    if (this.enableDynamicLoad) {
      events.push(new Ma);
    }
    events.push(new Qa({
      app : this.app
    }));
    events.push(new Ya({
      app : this.app
    }));
    events.push(new Sa);
    events.push(new ja);
    events.push(new Ra({
      app : this.app,
      resourceManager : this.resourceManager
    }));
    events.push(new Pa({
      app : this.app,
      resourceManager : this.resourceManager
    }));
    events.push(new Za);
  }, d;
}(Wa);
$a = function(t) {
  function a(module) {
    return r(this, a), s(this, t.call(this, module));
  }
  return o(a, t), a.prototype.init = function(callback) {
    t.prototype.init.call(this, callback);
    callback.registerCreatedCallbackListener(this._createdCallback, {
      event : this
    });
  }, a.prototype._createdCallback = function(elem, noblanks) {
    var options = elem.thingjsObject;
    var doc = elem.json2meshObject;
    options.loadMode = doc.loadMode;
  }, a;
}(Ta);
el = function() {
  function init(value, m, config) {
    r(this, init);
    this.app = value;
    this.resourceUrl = null;
    this.relativeResourceUrl = null;
    this.sceneJson = null;
    this.scale = 1;
    this.curFloorPlan = null;
    this.tempTexture = null;
    this.indexJson = m;
    this.sceneJsonUri = "scene.json";
    this.defaultWallTextureUri = "Textures/RoomWall.jpg";
    this.defaultWallEdgeTextureUri = "Textures/WallEdge.jpg";
    this.defaultFloorTextureUri = "Textures/FloorDefault.jpg";
    this.defaultCeilingTextureUri = "Textures/CeilingDefault.jpg";
    this.defaultRoofTextureUri = "Textures/RoofDefault.jpg";
    this.defaultWallTexture = null;
    this.defaultCeilingTexture = null;
    this.defaultFloorTexture = null;
    this.defaultRoofTexture = null;
    this.defaultWallEdgeTexture = null;
    this.worldNode = new THREE.Object3D("world");
    this.isCamFitScene = true;
    this.campus = null;
    this.outdoorsVisible = true;
    this.campusVisible = true;
    this.enableUseHighestVersionResource = true;
    this.enableDownloadSceneJsonCache = true;
    this.enableDynamicLoad = false;
    this.enableProxima = false;
    this.enableBatchObject = false;
    this._jsonloadedCallbacks = [];
    this.worldNode;
    if (m && (m.position && (this.campusPosition = m.position), m.rotation && (this.campusRotation = m.rotation), void 0 !== m.isCamFitScene && null !== m.isCamFitScene && (this.isCamFitScene = m.isCamFitScene), m.scale && (this.campusScale = m.scale), void 0 !== m.outdoorsVisible && (this.outdoorsVisible = m.outdoorsVisible), void 0 !== m.campusVisible && (this.campusVisible = m.campusVisible), m.campus && (this.campus = m.campus), void 0 !== m.enableUseHighestVersionResource && (this.enableUseHighestVersionResource = 
    m.enableUseHighestVersionResource, json2mesh.DefaultSetting.enableUseHighestVersionResource = this.enableUseHighestVersionResource), void 0 !== m.enableDownloadSceneJsonCache && (this.enableDownloadSceneJsonCache = m.enableDownloadSceneJsonCache), m.enableDynamicLoadScene && (this.enableDynamicLoad = m.enableDynamicLoadScene), m.enableProxima && (this.enableProxima = m.enableProxima), m.startDownloadResourcesCallback && (this.startDownloadResourcesCallback = m.startDownloadResourcesCallback)), 
    this.campus && (this.campusRotation && this.campus.node.quaternion.set(this.campusRotation.x, this.campusRotation.y, this.campusRotation.z, this.campusRotation.w), this.campusPosition && (this.campus.position = this.campusPosition), this.campusScale && (this.campus.scale = this.campusScale)), m.default) {
      if (m.default.sceneJson) {
        this.sceneJson = "export.json";
      }
    }
    if (void 0 !== this.app.options.enableBatchObject && this.app.options.enableBatchObject) {
      json2mesh.DefaultSetting.enableBatchObject = true;
      this.enableBatchObject = this.app.options.enableBatchObject;
    }
    if (config.loaderResourceUrl) {
      this.resourceUrl = config.loaderResourceUrl;
    }
    if (this.app.options.resourceLibraryUrl) {
      this.resourceUrl = this.app.options.resourceLibraryUrl;
    }
    if (this.indexJson.resourceLibrary) {
      this.relativeResourceUrl = this.indexJson.resourceLibrary;
    }
    if (!this.enableDownloadSceneJsonCache) {
      this.sceneJsonUri += "?_t=" + (new Date).getTime();
    }
    this.json2meshToThingjsParser = null;
    this.LoaderClass = json2mesh.Max2TjsLoader;
    this.app.level.options = {
      autoBakeFloor : false
    };
    if (this.app.options._sceneloaded) {
      this.registerSceneJsonLoadedListener(this.app.options._sceneloaded);
    }
    this.enableBatchMaxPlacement = true;
    if (void 0 !== this.app.options.enableBatchMaxPlacement) {
      this.enableBatchMaxPlacement = this.app.options.enableBatchMaxPlacement;
    }
  }
  return init.prototype.parseCamInfo = function(data) {
    var t = data.eye;
    var i = data.target;
    var filem = t.split(" ");
    var cmd_s = i.split(" ");
    var songsHeaders = [Number(filem[0]), Number(filem[1]), Number(filem[2])];
    songsHeaders[2] = -songsHeaders[2];
    var delegatorRoot = [Number(cmd_s[0]), Number(cmd_s[1]), Number(cmd_s[2])];
    delegatorRoot[2] = -delegatorRoot[2];
    this.app.camera.position = songsHeaders;
    this.app.camera.target = delegatorRoot;
  }, init.prototype.load = function(item) {
    var self = this;
    if (self.json2meshToThingjsParser = new Ka(self.app), self.enableProxima && (self.json2meshToThingjsParser.enableProxima = true, json2mesh.DefaultSetting.enableCombinePlacementsByRoom = true), self.json2meshToThingjsParser.events.push(new Ja), self.json2meshToThingjsParser.events.push(new $a), "String" === item.constructor.name) {
      this.sceneURL = item;
    } else {
      if ("Object" === item.constructor.name) {
        var doc = item;
        this.sceneURL = doc.url;
        if (doc.campus) {
          this.campus = doc.campus;
          this.worldNode = this.campus.node;
          this.json2meshToThingjsParser.setCampus(this.campus);
        }
        if (doc.json) {
          this.sceneJson = doc.json;
        }
      }
    }
    return this.relativeResourceUrl && (0 === this.relativeResourceUrl.indexOf("./") ? this.resourceUrl = this.sceneURL + this.relativeResourceUrl.replace("./", "/") : this.resourceUrl = this.relativeResourceUrl), new Promise(function($, i) {
      self.updateProgress(.1);
      self.loadSceneJson().then(function(i) {
        if (!self.sceneJson) {
          self.sceneJsonString = i;
          self.sceneJson = JSON.parse(i);
        }
        self._notifySceneJsonLoadedListeners(self.sceneJson);
        if (self.sceneJson.camInfo && self.isCamFitScene) {
          self.parseCamInfo(self.sceneJson.camInfo);
        }
        self.updateProgress(.1);
        var res = new self.LoaderClass;
        if (self.enableDynamicLoad) {
          res.enableRequestWorld = false;
          self.json2meshToThingjsParser.enableDynamicLoad = true;
        }
        if (self.resourceUrl) {
          res.resourceManager.baseTextureUrl = self.resourceUrl + "/texture/";
          res.resourceManager.baseModelUrl = self.resourceUrl + "/model/";
        }
        self.loader = res;
        self.world = res.load({
          enableBatchPlacement : self.enableBatchMaxPlacement,
          json : self.sceneJson,
          customModeBaseUrl : self.sceneURL + "/",
          bigVersion : self.indexJson.bigVersion,
          smallVersion : self.indexJson.smallVersion
        });
        var config = self.world;
        (new Ps).parseWorld(config);
        if (self.sceneJson.camInfo && self.isCamFitScene) {
          self.parseCamInfo(self.sceneJson.camInfo);
        }
        if (self.campus) {
          self.campus.visible = self.campusVisible;
        }
        if (self.campusRotation) {
          self.campus.node.quaternion.set(self.campusRotation.x, self.campusRotation.y, self.campusRotation.z, self.campusRotation.w);
        }
        if (self.campusPosition) {
          self.campus.position = self.campusPosition;
        }
        if (self.campusScale) {
          self.campus.scale = self.campusScale;
        }
        if (self.startDownloadResourcesCallback) {
          self.startDownloadResourcesCallback(res.resourceManager.models, res.resourceManager.textures);
        }
        self.campus = self.json2meshToThingjsParser.parseWorld(config, res.resourceManager, self.indexJson.bigVersion, self.indexJson.smallVersion);
        if (self.enableDynamicLoad) {
          self.loadExtraData(self.campus);
          self.updateProgress(1);
          $(self.campus);
        } else {
          res.startToBuild(function(i) {
            self.updateProgress(.1 + .9 * i);
            if (1 === i) {
              self.updateProgress(1);
              self.loadExtraData(self.campus);
              $(self.campus);
            }
          });
        }
      });
    });
  }, init.prototype.setTransformInfo = function(canCreateDiscussions) {
  }, init.prototype.loadExtraData = function(eventData) {
    if (this.sceneJson.extraData) {
      eventData.extraData = this.sceneJson.extraData;
    }
  }, init.prototype.loadSceneJson = function(e) {
    var resp = this;
    return e && (resp.sceneURL = e), new Promise(function(continuation, i) {
      if (resp.sceneJson) {
        continuation(resp.sceneJson);
      } else {
        (new THREE.FileLoader(resp.app.loadingManager)).load(resp.sceneURL.appendURL(resp.sceneJsonUri), function(url) {
          continuation(url);
        });
      }
    });
  }, init.prototype.updateProgress = function(data) {
    this.app.mainUI.updateLoadingProcess({
      object : this.campus,
      progress : data
    });
  }, init.prototype.startToDownloadRequestResources = function(playlist) {
    this.loader.startToDownloadRequestResources(playlist);
  }, init.prototype.addResourceDownloadRequest = function(e) {
    this.loader.resourceManager.addResourceDownloadRequest(e);
  }, init.prototype.clearAllResources = function() {
    this.loader.resourceManager.disposeModels();
    this.loader.resourceManager.disposeTextures();
  }, init.prototype.clearAllObjects = function() {
    this.world.clear();
  }, init.prototype.requestToBuild = function(playlist) {
    this.loader.requestToBuild(playlist);
  }, init.prototype.startToBuild = function(playlist) {
    return this.loader.startToBuild(playlist);
  }, init.prototype.disposeObject = function(id) {
    this.loader.disposeObject(id);
  }, init.prototype.findObjectByID = function(e) {
    return this.world.findObjectByID(e);
  }, init.prototype.registerSceneJsonLoadedListener = function(e) {
    this._jsonloadedCallbacks.push(e);
  }, init.prototype._notifySceneJsonLoadedListeners = function(e) {
    var layer_i = 0;
    for (; layer_i < this._jsonloadedCallbacks.length; layer_i++) {
      (0, this._jsonloadedCallbacks[layer_i])(e);
    }
  }, init;
}();
tl = function(e) {
  function t(out, a, b) {
    r(this, t);
    var container = s(this, e.call(this, out, a, b));
    return container.LoaderClass = json2mesh.Bim2TjsLoader, container;
  }
  return o(t, e), t;
}(el);
il = function(t) {
  function a(module) {
    return r(this, a), s(this, t.call(this, module));
  }
  return o(a, t), a.prototype.init = function(callback) {
    t.prototype.init.call(this, callback);
    callback.registerBuildedCallbackListener(this._buildCallback, {
      event : this
    });
  }, a.prototype._buildCallback = function(opt, execFile_opt) {
    var options = opt.thingjsObject;
    var data = opt.json2meshObject;
    if ("Facade" !== options.type && data.dataVersion && 5 === data.dataVersion.mode) {
      options.localPosition = data.position;
      options.scale = data.scale;
      if (data.rotation) {
        options.node.quaternion.set(data.rotation[0], data.rotation[1], data.rotation[2], data.rotation[3]);
      }
    }
  }, a;
}(Ta);
rl = function() {
  function a(value) {
    r(this, a);
    this.app = value;
    this.ubuilderToThingjsParser = new Wa(this.app);
    this.maxToThingjsParser = new Ka(this.app);
    this.campus = null;
    this.app = value;
    this.enableProxima = false;
    this.enableDynamicLoad = false;
    this.creatorManager = null;
    this.enableBatchObject = false;
    this.resourceManager = null;
  }
  return a.prototype.parseWorld = function(e, islongclick) {
    this.resourceManager = islongclick;
    this.ubuilderToThingjsParser.resourceManager = islongclick;
    this.maxToThingjsParser.resourceManager = islongclick;
    this.ubuilderToThingjsParser.enableProxima = this.enableProxima;
    this.maxToThingjsParser.enableProxima = this.enableProxima;
    this.ubuilderToThingjsParser.enableBatchObject = this.enableBatchObject;
    this.maxToThingjsParser.enableBatchObject = this.enableBatchObject;
    this.ubuilderToThingjsParser.enableDynamicLoad = this.enableDynamicLoad;
    this.maxToThingjsParser.enableDynamicLoad = this.enableDynamicLoad;
    this.ubuilderToThingjsParser.initEvents();
    this.maxToThingjsParser.initEvents();
    this.maxToThingjsParser.events.push(new il);
    this.ubuilderToThingjsParser.initCreatorManager(e);
    this.maxToThingjsParser.initCreatorManager(e);
    var n = this.parseJson2meshObject(e);
    return this.processHideObjects(n), n;
  }, a.prototype.parseJson2meshObject = function(data, transform) {
    var lang = null;
    if (3 === data.dataVersion.mode) {
      lang = this.ubuilderToThingjsParser;
    } else {
      if (5 === data.dataVersion.mode) {
        lang = this.maxToThingjsParser;
      } else {
        console.error("not support mode");
      }
    }
    var t = lang.creatorManager.createTjsObject(data, transform);
    if ("Building" === data.type && lang.parseFacades(data, t), lang.shouldParseChildren(data)) {
      var columns = data.children;
      if (columns) {
        var i = 0;
        for (; i < columns.length; i++) {
          var item = columns[i];
          if ("Facade" !== item.type && "FacadeGroup" !== item.type && "Floor" !== item.type && "Ceiling" !== item.type && "Roof" !== item.type) {
            if ("FloorPlan" === data.type || "Outdoors" === data.type) {
              lang.parseJson2meshObject(item, t);
            } else {
              this.parseJson2meshObject(item, t);
            }
          }
        }
      }
    }
    return t;
  }, a.prototype.setCampus = function(e) {
    this.ubuilderToThingjsParser.setCampus(e);
    this.maxToThingjsParser.setCampus(e);
  }, a.prototype.processHideObjects = function(att) {
    var data = att.buildings;
    var i = 0;
    for (; i < data.length; i++) {
      var bounds = data[i];
      var t = bounds.floors;
      if (bounds.facade && !bounds.structShow) {
        var k = 0;
        for (; k < t.length; k++) {
          t[k].visible = false;
        }
      } else {
        var k = 0;
        for (; k < t.length; k++) {
          var e = t[k];
          this.hidePlanObjs(e);
        }
      }
    }
  }, a.prototype.hidePlanObjs = function(images) {
    if (!images.showObjectsInParentLevels) {
      var affectedData = images.query(".CombinedObject", false);
      var j = 0;
      for (; j < affectedData.length; j++) {
        var data = affectedData[j];
        if ("CombineMiscParent" === data.userData.type) {
          var separated = data.query(".CombinedObject", false);
          var i = 0;
          for (; i < separated.length; i++) {
            var group = separated[i];
            if (!("CombinePlacement" !== group.userData.json2meshType && "CombinePlacementGroup" !== group.userData.json2meshType)) {
              group.visible = false;
            }
          }
        }
      }
      var i = 0;
      for (; i < images.children.length; i++) {
        var t = images.children[i];
        if (!(t.isDoor || "Room" === t.type)) {
          if (!("Thing" === t.type && t.isWindow)) {
            t.visible = false;
          }
        }
      }
    }
  }, a.prototype.clear = function() {
    this.ubuilderToThingjsParser.clear();
    this.maxToThingjsParser.clear();
    this.app = null;
    this.enableProxima = false;
    this.enableDynamicLoad = false;
    this.creatorManager = null;
    this.enableBatchObject = false;
    this.resourceManager = null;
  }, a;
}();
nl = function() {
  function init(value, me, config) {
    r(this, init);
    this.app = value;
    this.resourceUrl = null;
    this.relativeResourceUrl = null;
    this.sceneJson = null;
    this.scale = 1;
    this.curFloorPlan = null;
    this.tempTexture = null;
    this.indexJson = me;
    this.sceneJsonUri = "scene.json";
    this.defaultWallTextureUri = "Textures/RoomWall.jpg";
    this.defaultWallEdgeTextureUri = "Textures/WallEdge.jpg";
    this.defaultFloorTextureUri = "Textures/FloorDefault.jpg";
    this.defaultCeilingTextureUri = "Textures/CeilingDefault.jpg";
    this.defaultRoofTextureUri = "Textures/RoofDefault.jpg";
    this.defaultWallTexture = null;
    this.defaultCeilingTexture = null;
    this.defaultFloorTexture = null;
    this.defaultRoofTexture = null;
    this.defaultWallEdgeTexture = null;
    this.worldNode = new THREE.Object3D("world");
    this.isCamFitScene = true;
    this.campus = null;
    this.outdoorsVisible = true;
    this.campusVisible = true;
    this.enableUseHighestVersionResource = true;
    this.enableDownloadSceneJsonCache = true;
    this.enableDynamicLoad = false;
    this.enableProxima = false;
    this.enableBatchObject = false;
    this.effectSettingLoader = null;
    this.worldNode;
    if (me && (me.position && (this.campusPosition = me.position), me.rotation && (this.campusRotation = me.rotation), void 0 !== me.isCamFitScene && null !== me.isCamFitScene && (this.isCamFitScene = me.isCamFitScene), me.scale && (this.campusScale = me.scale), void 0 !== me.outdoorsVisible && (this.outdoorsVisible = me.outdoorsVisible), void 0 !== me.campusVisible && (this.campusVisible = me.campusVisible), me.campus && (this.campus = me.campus), me.enableDynamicLoadScene && (this.enableDynamicLoad = 
    me.enableDynamicLoadScene), me.enableProxima && (this.enableProxima = me.enableProxima), me.enableBatchObject && (this.enableBatchObject = me.enableBatchObject), void 0 !== me.enableUseHighestVersionResource && (this.enableUseHighestVersionResource = me.enableUseHighestVersionResource, json2mesh.DefaultSetting.enableUseHighestVersionResource = this.enableUseHighestVersionResource), void 0 !== me.enableDownloadSceneJsonCache && (this.enableDownloadSceneJsonCache = me.enableDownloadSceneJsonCache), 
    me.startDownloadResourcesCallback && (this.startDownloadResourcesCallback = me.startDownloadResourcesCallback)), this.campus && (this.campusRotation && this.campus.node.quaternion.set(this.campusRotation.x, this.campusRotation.y, this.campusRotation.z, this.campusRotation.w), this.campusPosition && (this.campus.position = this.campusPosition), this.campusScale && (this.campus.scale = this.campusScale)), me.default) {
      var toolsElement = me.default;
      if (toolsElement.sceneJson) {
        this.sceneJson = "export.json";
      }
      if (toolsElement.wallTexture) {
        this.defaultWallTextureUri = toolsElement.wallTexture;
      }
      if (toolsElement.wallEdgeTexture) {
        this.defaultWallEdgeTextureUri = toolsElement.wallEdgeTexture;
      }
      if (toolsElement.floorTexture) {
        this.defaultFloorTextureUri = toolsElement.floorTexture;
      }
      if (toolsElement.ceilingTexture) {
        this.defaultCeilingTextureUri = toolsElement.ceilingTexture;
      }
      if (toolsElement.roofTexture) {
        this.defaultRoofTextureUri = toolsElement.roofTexture;
      }
    }
    if (config.loaderResourceUrl) {
      this.resourceUrl = config.loaderResourceUrl;
    }
    if (void 0 !== this.app.options.enableUseHighestVersionResource) {
      this.enableUseHighestVersionResource = this.app.options.enableUseHighestVersionResource;
      json2mesh.DefaultSetting.enableUseHighestVersionResource = this.enableUseHighestVersionResource;
    }
    if (void 0 !== this.app.options.enableBatchObject && this.app.options.enableBatchObject) {
      json2mesh.DefaultSetting.enableCombinePlacementToBuildMesh = false;
      this.enableBatchObject = this.app.options.enableBatchObject;
    }
    if (this.app.options.resourceLibraryUrl) {
      this.resourceUrl = this.app.options.resourceLibraryUrl;
    }
    if (this.indexJson.resourceLibrary) {
      this.relativeResourceUrl = this.indexJson.resourceLibrary;
    }
    if (!this.enableDownloadSceneJsonCache) {
      this.sceneJsonUri += "?_t=" + (new Date).getTime();
    }
    this.json2meshToThingjsParser = null;
    this.enableBatchMaxPlacement = true;
    if (void 0 !== this.app.options.enableBatchMaxPlacement) {
      this.enableBatchMaxPlacement = this.app.options.enableBatchMaxPlacement;
    }
  }
  return init.prototype.parseCamInfo = function(data) {
    var t = data.eye;
    var i = data.target;
    var filem = t.split(" ");
    var cmd_s = i.split(" ");
    var songsHeaders = [Number(filem[0]), Number(filem[1]), Number(filem[2])];
    songsHeaders[2] = -songsHeaders[2];
    var delegatorRoot = [Number(cmd_s[0]), Number(cmd_s[1]), Number(cmd_s[2])];
    delegatorRoot[2] = -delegatorRoot[2];
    this.app.camera.position = songsHeaders;
    this.app.camera.target = delegatorRoot;
  }, init.prototype.load = function(item) {
    var self = this;
    if (self.json2meshToThingjsParser = new rl(self.app), self.enableProxima && (self.json2meshToThingjsParser.enableProxima = true, json2mesh.DefaultSetting.enableCombinePlacementsByRoom = true), self.enableBatchObject && (self.json2meshToThingjsParser.enableBatchObject = self.enableBatchObject), "String" === item.constructor.name) {
      this.sceneURL = item;
    } else {
      if ("Object" === item.constructor.name) {
        var doc = item;
        this.sceneURL = doc.url;
        if (doc.campus) {
          this.campus = doc.campus;
          this.worldNode = this.campus.node;
          this.json2meshToThingjsParser.setCampus(this.campus);
        }
        if (doc.json) {
          this.sceneJson = doc.json;
        }
      }
    }
    return this.relativeResourceUrl && (0 === this.relativeResourceUrl.indexOf("./") ? this.resourceUrl = this.sceneURL + this.relativeResourceUrl.replace("./", "/") : this.resourceUrl = this.relativeResourceUrl), new Promise(function($, i) {
      self.updateProgress(.1);
      self.loadSceneJson().then(function(i) {
        if (!self.sceneJson) {
          self.sceneJsonString = i;
          self.sceneJson = JSON.parse(i);
        }
        if (self.sceneJson.camInfo && self.isCamFitScene) {
          self.parseCamInfo(self.sceneJson.camInfo);
        }
        self.updateProgress(.1);
        var res = new json2mesh.MixTjsLoader;
        if (void 0 !== self.app.options.loadingSceneMaxResourcesUnitDownloadNumber) {
          res.setResourcesUnitDownloadNumber(self.app.options.loadingSceneMaxResourcesUnitDownloadNumber);
        }
        if (void 0 !== self.app.options.loadingSceneAwaitToNextBuildTime) {
          res.dynamicBuildManager.awaitToNextBuildTime = self.app.options.loadingSceneAwaitToNextBuildTime;
        }
        if (self.enableDynamicLoad) {
          res.enableRequestWorld = false;
          self.json2meshToThingjsParser.enableDynamicLoad = true;
        }
        if (self.resourceUrl) {
          res.resourceManager.baseTextureUrl = self.resourceUrl + "/texture/";
          res.resourceManager.baseModelUrl = self.resourceUrl + "/model/";
        }
        self.loader = res;
        res.load({
          json : self.sceneJson,
          customModeBaseUrl : self.sceneURL + "/",
          version : 0,
          enableBatchPlacement : self.enableBatchMaxPlacement
        }).then(function(undefined) {
          var lawnchairDao = new Ps;
          lawnchairDao.parseWorld(undefined);
          lawnchairDao.clear();
          if (self.sceneJson.camInfo && self.isCamFitScene) {
            self.parseCamInfo(self.sceneJson.camInfo);
          }
          self.campus.visible = self.campusVisible;
          if (self.campusRotation) {
            self.campus.node.quaternion.set(self.campusRotation.x, self.campusRotation.y, self.campusRotation.z, self.campusRotation.w);
          }
          if (self.campusPosition) {
            self.campus.position = self.campusPosition;
          }
          if (self.campusScale) {
            self.campus.scale = self.campusScale;
          }
          if (self.startDownloadResourcesCallback) {
            self.startDownloadResourcesCallback(res.resourceManager.models, res.resourceManager.textures);
          }
          self.campus = self.json2meshToThingjsParser.parseWorld(undefined, res.resourceManager);
          if (self.enableDynamicLoad) {
            self.loadExtraData(self.campus);
            self.updateProgress(1);
            $(self.campus);
          } else {
            res.startToBuild(function(i) {
              self.updateProgress(.1 + .9 * i);
              if (1 === i) {
                self.updateProgress(1);
                self.loadExtraData(self.campus);
                $(self.campus);
              }
            });
          }
        });
      });
    });
  }, init.prototype.loadExtraData = function(eventData) {
    if (this.sceneJson.extraData) {
      eventData.extraData = this.sceneJson.extraData;
    }
  }, init.prototype.loadSceneJson = function(e) {
    var resp = this;
    return e && (resp.sceneURL = e), new Promise(function(continuation, i) {
      if (resp.sceneJson) {
        continuation(resp.sceneJson);
      } else {
        (new THREE.FileLoader(resp.app.loadingManager)).load(resp.sceneURL.appendURL(resp.sceneJsonUri), function(url) {
          continuation(url);
        });
      }
    });
  }, init.prototype.updateProgress = function(data) {
    this.app.mainUI.updateLoadingProcess({
      object : this.campus,
      progress : data
    });
  }, init.prototype.startToDownloadRequestResources = function(playlist) {
    this.loader.resourceManager.startToDownloadRequestResources(playlist);
  }, init.prototype.addResourceDownloadRequest = function(e) {
    this.loader.resourceManager.addResourceDownloadRequest(e);
  }, init.prototype.clearAllResources = function() {
    this.clear();
  }, init.prototype.clearAllObjects = function() {
    this.world.clear();
    this.world = null;
  }, init.prototype.clear = function() {
    this.loader.clearAllResources();
    this.json2meshToThingjsParser.clear();
    this.resourceUrl = null;
    this.relativeResourceUrl = null;
    this.sceneJson = null;
    this.scale = 1;
    this.curFloorPlan = null;
    this.tempTexture = null;
    this.indexJson = null;
    this.sceneJsonUri = null;
    this.defaultWallTextureUri = null;
    this.defaultWallEdgeTextureUri = null;
    this.defaultFloorTextureUri = null;
    this.defaultCeilingTextureUri = null;
    this.defaultRoofTextureUri = null;
    this.defaultWallTexture = null;
    this.defaultCeilingTexture = null;
    this.defaultFloorTexture = null;
    this.defaultRoofTexture = null;
    this.defaultWallEdgeTexture = null;
    this.worldNode = new THREE.Object3D("world");
    this.isCamFitScene = true;
    this.campus = null;
    this.outdoorsVisible = true;
    this.campusVisible = true;
    this.enableUseHighestVersionResource = true;
    this.enableDownloadSceneJsonCache = true;
    this.enableDynamicLoad = false;
    this.enableProxima = false;
    this.enableBatchObject = false;
  }, init.prototype.requestToBuild = function(playlist) {
    this.loader.requestToBuild(playlist);
  }, init.prototype.startToBuild = function(playlist) {
    return this.loader.startToBuild(playlist);
  }, init.prototype.disposeObject = function(id) {
    var value = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    this.loader.disposeObject(id, value);
  }, init.prototype.findObjectByID = function(e) {
    return this.world.findObjectByID(e);
  }, init;
}();
ol = function() {
  function Router(app) {
    r(this, Router);
    this.app = app;
    this.supportVersion = {
      1 : 1,
      2 : 1,
      3 : 0
    };
    this.versionLib = {
      1 : {
        0 : {
          0 : ms
        },
        1 : {
          0 : qa
        }
      },
      2 : {
        0 : {
          0 : ps
        },
        1 : {
          0 : ds,
          1 : fs
        }
      },
      3 : {
        0 : {
          0 : Ga,
          1 : Ga,
          2 : Ga,
          3 : Ga,
          4 : Ga,
          5 : Ga
        },
        1 : {
          0 : Xa,
          2 : Xa,
          3 : Xa,
          4 : Xa,
          5 : Xa
        }
      },
      5 : {
        0 : {
          0 : el,
          1 : el,
          2 : el,
          3 : el,
          4 : el,
          5 : el,
          6 : el
        }
      },
      6 : {
        0 : {
          0 : tl,
          1 : tl
        }
      },
      7 : {
        0 : {
          0 : nl
        }
      }
    };
  }
  return Router.prototype.getLoader = function(result, url) {
    if (result) {
      var message = result.version;
      var column = 0;
      var id = 0;
      var index = 0;
      if (message) {
        var sArrDayId = message.split(".");
        column = parseInt(sArrDayId[0]);
        id = parseInt(sArrDayId[1]);
        index = parseInt(sArrDayId[2]);
      }
      var item = this._getFitVersion(column, id, index);
      if (!item) {
        return void THING.Utils.error("can not load " + message + " data,please check data or update thingjs!");
      }
      if (!(item.bigVersion === id && item.smallVersion === index)) {
        THING.Utils.warn("can not load " + message + " data,try to use " + column + "." + item.bigVersion + "." + item.smallVersion + " to load data or update thingjs to load " + message + " data");
      }
      var Error = this.versionLib[column][item.bigVersion][item.smallVersion];
      if (result.bigVersion = item.bigVersion, result.smallVersion = item.smallVersion, 1 === column) {
        error = new Error(this.app);
      } else {
        if (2 === column) {
          switch(id) {
            case 1:
              var self = {};
              var position = result.position;
              if (position) {
                self.position = position;
              }
              if (result.rotation) {
                self.rotation = result.rotation;
              }
              if (result.campus) {
                self.campus = result.campus;
              }
              self.isCamFitScene = Utils.parseValue(result.isCamFitScene, true);
              self.isDelayLoadFloorPlan = Utils.parseValue(result.isDelayLoadFloorPlan, false);
              error = new Error(this.app, self);
              break;
            default:
              error = new Error(this.app);
          }
        } else {
          error = new Error(this.app, result, url);
        }
      }
      return error;
    }
    var error = new ms(this.app);
    return error;
  }, Router.prototype._getFitVersion = function(id, key, type) {
    if (!this.versionLib[id]) {
      return null;
    }
    var map = this.versionLib[id];
    var value = map[key];
    return value || (value = map[key = this._getClosestVersion(key, map)]) ? (value[type] || (type = this._getClosestVersion(type, value)), value[type] ? {
      bigVersion : key,
      smallVersion : type
    } : null) : null;
  }, Router.prototype._getClosestVersion = function(index, data) {
    var ellipsisAt = null;
    for (; null == ellipsisAt;) {
      if (index < 0) {
        return;
      }
      if (data[--index]) {
        ellipsisAt = index;
      }
    }
    return ellipsisAt;
  }, Router;
}();
sl = function() {
  function t() {
    r(this, t);
  }
  return t._processUrl = function(url, data) {
    var res = [];
    if (Utils.isArray(data)) {
      var i = 0;
      for (; i < data.length; i++) {
        var value = data[i];
        if (0 == value.indexOf("/") && url) {
          res.push(url + value);
        } else {
          if (!(-1 === value.indexOf("http://") && -1 === value.indexOf("https://"))) {
            res.push(value);
          }
        }
      }
    } else {
      if (Utils.isString(data)) {
        if (url && data.indexOf("/")) {
          res = url + data;
        } else {
          if (!(-1 === data.indexOf("http://") && -1 === data.indexOf("https://"))) {
            res = data;
          }
        }
      }
    }
    return res;
  }, t.generateEnvMapUrl = function(source, name, x) {
    var fileTooLarge = void 0;
    if (Utils.isArray(name) || Utils.isString(name)) {
      var value = source.confirmURL(Utils.parseCubeTextureUrls_v2(name));
      fileTooLarge = (Utils.isArray(value) && value.length, value);
    } else {
      if (Utils.isObject(name)) {
        var file = source.confirmURL(Utils.parseCubeTextureUrls_v2(name));
        var a = false;
        if (Utils.isArray(file)) {
          a = !!file.filter(function(boardNameToTest) {
            return -1 !== boardNameToTest.indexOf("http://") || -1 !== boardNameToTest.indexOf("https://");
          }).length;
        } else {
          if (Utils.isString(file)) {
            a = !(-1 === file.indexOf("http://") && -1 === file.indexOf("https://"));
          }
        }
        if (!a) {
          if (!x) {
            x = source.query(".Campus")[0];
          }
          if (Utils.isObject(x)) {
            file = t._processUrl(x.url, file);
          }
        }
        fileTooLarge = file;
      }
    }
    return fileTooLarge;
  }, t._generateSkyBoxUrl = function(t, color, last) {
    var fileTooLarge = void 0;
    if (Utils.isArray(color) || Utils.isString(color)) {
      fileTooLarge = t.confirmURL(Utils.parseCubeTextureUrls_v2(color));
    } else {
      if (Utils.isObject(color)) {
        var file = t.confirmURL(Utils.parseCubeTextureUrls_v2(color));
        var s = false;
        if (Utils.isArray(file)) {
          s = !!file.filter(function(boardNameToTest) {
            return -1 !== boardNameToTest.indexOf("http://") || -1 !== boardNameToTest.indexOf("https://");
          }).length;
        } else {
          if (Utils.isString(file)) {
            s = !(-1 === file.indexOf("http://") && -1 === file.indexOf("https://"));
          }
        }
        if (!s) {
          if (!last) {
            last = t.query(".Campus")[0];
          }
          if (Utils.isObject(last)) {
            file = t._processUrl(last.url, file);
          }
        }
        fileTooLarge = file;
      }
    }
    return fileTooLarge;
  }, t.parseLight = function(data, options) {
    if (Utils.isObject(data) && Utils.isObject(options)) {
      data.lighting = options;
      if (options.shadowObjectMaxSize) {
        data.query(".LightGroup")[0].shadowObjectMaxSize = options.shadowObjectMaxSize;
      }
    }
  }, t.parsePostEffect = function(settings, defaults) {
    if (Utils.isObject(settings) && Utils.isObject(defaults)) {
      var m = defaults.vignette;
      if (m && m.enable) {
        m.enable = false;
        var type = m.type;
        if ("blur" === type) {
          defaults.blurEdge = {
            enable : true,
            offset : m.offset
          };
        } else {
          if ("color" === type) {
            defaults.vignetting = {
              enable : true,
              offset : m.offset,
              color : m.color
            };
          }
        }
      }
      var divaInstance = {
        postEffect : defaults
      };
      settings.postEffect = divaInstance;
    }
  }, t.parseSkyBox = function(b, a, k) {
    if (Utils.isObject(b) && a) {
      var n = t._generateSkyBoxUrl(b, a, k);
      if (n) {
        b.skyBox = n;
      }
    }
  }, t.parseBackground = function(context, item, changeMeta) {
    if (Utils.isObject(context) && item && !t.isBackgroundSetted(context)) {
      context.background = item.background;
      if (Utils.isNumber(item.background) || item.background) {
        context.trigger("skyboxchange", {
          skyBox : null
        });
      }
    }
  }, t.parseEnvMapBeforeLoadCampus = function(e, value, data, newValue) {
    if (Utils.isObject(e) && value && Utils.isObject(data) && (newValue || (newValue = e.query(".Campus")[0]), Utils.isObject(newValue))) {
      var entity = new Qi(e);
      newValue._envMapResources = entity.load(value, data.resourceLibrary);
    }
  }, t.parseEnvMapAfterLoadCampus = function(c, d) {
    if (Utils.isObject(c)) {
      if (!d) {
        d = c.query(".Campus")[0];
      }
      if (Utils.isObject(d)) {
        if (d._envMapResources || d.getEnvMapResources()) {
          d.query("*").forEach(function($scope) {
            $scope.setupEnvMap($scope.isFacade);
          });
        }
      }
    }
  }, t.parseCameraConfig = function(e, t) {
    if (Utils.isObject(e) && Utils.isObject(t)) {
      var j;
      for (j in t) {
        if (t[j]) {
          e.camera[j] = t[j];
        }
      }
    }
  }, t.getOutdoorsEnv = function(options, defaults) {
    return options.options && (options.options.env || null === options.options.env) ? options.options.env : t.isSkyBoxSetted(options) ? options.options.userParameters.skyBox : options.skyBox && "Dark" !== options.skyBox ? options.skyBox : defaults.environment ? defaults.environment : null;
  }, t.getIndoorsEnv = function(pieces, callback) {
    return callback.environmentInside ? callback.environmentInside : null;
  }, t.getSkyBox = function(options, _) {
    var silent = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    if (t.isSkyBoxSetted(options)) {
      var scene = options.options.userParameters;
      return scene.skyBox;
    }
    return "Dark" === options.skyBox && _.skybox || silent ? _.skybox : null;
  }, t.isSkyBoxSetted = function(spi) {
    return !!(spi.options && spi.options.userParameters && spi.options.userParameters.skyBox);
  }, t.isBackgroundSetted = function(elem) {
    return !!(elem.options && elem.options.userParameters && elem.options.userParameters.background);
  }, t;
}();
al = function() {
  function o() {
    r(this, o);
  }
  return o.parse = function(t, opts, data, e) {
    if (Utils.isObject(t) && Utils.isObject(opts) && Utils.isObject(data) && Utils.isObject(e) && (o.config = e._effectConfig = Utils.cloneObject(opts, false), o.indexJson = Utils.cloneObject(data, false), o.enableParse)) {
      if (opts.theme && THING.ThemeLoader) {
        var missing = e.url.appendURL(opts.theme.slice(2));
        t.on("load", function() {
          t.loadBundle(missing, {
            campus : e,
            name : "default"
          });
        });
      } else {
        if (sl.parseLight(t, opts.light), sl.parsePostEffect(t, opts.post), !data.skipEnvMap) {
          var c = [];
          var label = sl.getOutdoorsEnv(t, opts);
          if (label) {
            var l = sl.generateEnvMapUrl(t, label, e);
            if (Utils.isArray(l) && l.length <= 2) {
              c = l;
            } else {
              c[0] = l;
            }
          }
          if (!o.skipInDoorEnvMap && c.length < 2) {
            var content = sl.getIndoorsEnv(t, opts);
            if (content) {
              var a = sl.generateEnvMapUrl(t, content, e);
              c[1] = a;
            }
          }
          if (null !== label) {
            sl.parseEnvMapBeforeLoadCampus(t, c, data, e);
          }
        }
        sl.parseBackground(t, opts);
      }
      if (!data.skipSkyBox) {
        var search = sl.getSkyBox(t, opts);
        sl.parseSkyBox(t, search, e);
      }
      if (o.enableCameraParse) {
        sl.parseCameraConfig(t, opts.camera);
      }
    }
  }, o.parseAfterLoad = function(prop) {
    var type = prop.app;
    var end = (prop.loadSkyBox, prop.target);
    var C = o.config;
    var newBar = o.indexJson;
    if (Utils.isObject(type) && Utils.isObject(C) && Utils.isObject(newBar) && o.skipEnvMap) {
      sl.parseEnvMapAfterLoadCampus(type, end);
    }
  }, o;
}();
al.KEY = 3, al.enableParse = true, al.enableCameraParse = true, al.skipInDoorEnvMap = true;
var ll = function() {
  function list() {
    r(this, list);
  }
  return list.parse = function(item, options, items, i) {
    if (list.enableParse && Utils.isObject(item) && Utils.isObject(options) && Utils.isObject(items) && Utils.isObject(i)) {
      if (list.config = i._effectConfig = Utils.cloneObject(options, false), list.indexJson = Utils.cloneObject(items, false), options.theme && THING.ThemeLoader) {
        var name = i.url.appendURL(options.theme.slice(2));
        item.on("complete", function() {
          item.loadBundle(name, {
            campus : i,
            name : "default"
          });
        });
      } else {
        if (sl.parseLight(item, options.light), sl.parsePostEffect(item, options.effectConfig), !items.skipEnvMap) {
          var search = [];
          var end = sl.getOutdoorsEnv(item, options);
          if (end) {
            var value = sl.generateEnvMapUrl(item, end, i);
            if (Utils.isArray(value) && value.length <= 2) {
              search = value;
            } else {
              search[0] = value;
            }
          }
          if (!list.skipInDoorEnvMap && search.length < 2) {
            var end = sl.getIndoorsEnv(item, options);
            if (end) {
              var value = sl.generateEnvMapUrl(item, end, i);
              search[1] = value;
            }
          }
          if (null !== end) {
            sl.parseEnvMapBeforeLoadCampus(item, search, items, i);
          }
        }
        if (!items.skipSkyBox) {
          var end = sl.getSkyBox(item, options);
          sl.parseSkyBox(item, end, i);
        }
      }
      if (list.enableCameraParse) {
        sl.parseCameraConfig(item, options.camera);
      }
    }
  }, list.parseAfterLoad = function(s) {
    var p = s.app;
    var last = s.loadSkyBox;
    var end = void 0 !== last && last;
    var n = s.target;
    var size = list.config;
    var listeners = list.indexJson;
    if (Utils.isObject(p) && Utils.isObject(size) && Utils.isObject(listeners)) {
      sl.parseEnvMapAfterLoadCampus(p, n);
      var ret = sl.getSkyBox(p, size, end);
      sl.parseSkyBox(p, ret);
    }
  }, list;
}();
ll.enableParse = true, ll.enableCameraParse = true, ll.skipInDoorEnvMap = false;
var ul = function() {
  function i() {
    r(this, i);
  }
  return i.parse = function(item, value, file, obj) {
    var content = file ? file.version : null;
    if (content) {
      var sArrDayId = content.split(".");
      var type = parseInt(sArrDayId[0]);
      if (5 === type || 6 === type || 7 === type) {
        ll.parse(item, value, file, obj);
      } else {
        if (type === al.KEY) {
          al.parse(item, value, file, obj);
        }
      }
    }
  }, i.parseAfterLoad = function(e) {
    var app = e.app;
    var axes = e.loadSkyBox;
    var minorAxes = void 0 !== axes && axes;
    var theTarget = e.target;
    var v = al.indexJson || ll.indexJson;
    var ss = v ? v.version : null;
    if (ss) {
      var sArrDayId = ss.split(".");
      var type = parseInt(sArrDayId[0]);
      if (5 === type || 6 === type || 7 === type) {
        ll.parseAfterLoad({
          app : app,
          loadSkyBox : minorAxes,
          target : theTarget
        });
      } else {
        if (type === al.KEY) {
          al.parseAfterLoad({
            app : app,
            loadSkyBox : minorAxes,
            target : theTarget
          });
        }
      }
    }
  }, i;
}();
cl = false, hl = void 0, pl = function() {
  function o(value) {
    r(this, o);
    this.app = value;
    this.waitingLoadCampuses = [];
    this.loadingCampus = false;
  }
  return o.prototype._loadViewPointFile = function(result) {
    var options = this.app.sceneManager;
    var autoRefresh = Utils.parseValue(result.enableDeafultViewPointFile, options.enableDeafultViewPointFile);
    var p = result.defaultViewPointFileName || options.defaultViewPointFileName;
    if (autoRefresh && p) {
      var n = result.url.appendURL(p);
      var pageViewData = this;
      (new THREE.FileLoader).load(n, function(url) {
        pageViewData.app.viewPointManger.loadJSON(url);
      });
    }
  }, o.prototype._runScript = function(elem) {
    var cur;
    if (cur = Utils.isString(elem) ? elem : function(input) {
      return ee ? ee.decodeString(input) : "";
    }(elem)) {
      wt(cur);
    }
  }, o.prototype.loadFromUBuilder = function(obj, t, context, options, withEach) {
    var compound = this;
    var x = options.position;
    var B = options.rotation || options.angles;
    var scale = options.scale;
    var enableAccessChecks = Utils.parseValue(options.outdoorsVisible || options.visible, true);
    var waveformGradient = Utils.parseValue(options.campusVisible || options.visible, true);
    var newPublishedRows = Utils.parseValue(options.isCamFitScene, true);
    var E187B8 = Utils.parseValue(options.isDelayLoadFloorPlan, false);
    var d = options.splitLoadSpeed;
    var frameElement = Utils.parseValue(options.disableCache, false);
    var item = Utils.parseValue(options.dynamic, false);
    var value = Utils.parseValue(options.enableProxima, false);
    var module = Utils.parseValue(options.enableBatchObject, false);
    var str = Utils.parseValue(options.skipEnvMap, false);
    var text = Utils.parseValue(options.skipSkyBox, false);
    var onBeforeLoad = options.onBeforeLoad;
    if (x) {
      context.position = x;
    }
    if (B) {
      context.rotation = Utils.parseQuaternion(B);
    }
    if (scale) {
      context.scale = scale;
    }
    if (void 0 !== enableAccessChecks) {
      context.outdoorsVisible = enableAccessChecks;
    }
    if (void 0 !== waveformGradient) {
      context.campusVisible = waveformGradient;
    }
    context.isCamFitScene = newPublishedRows;
    context.isDelayLoadFloorPlan = E187B8;
    context.enableDownloadSceneJsonCache = !frameElement;
    context.isDynamicLoadScene = Utils.parseValue(item, context.isDynamicLoadScene);
    context.enableDynamicLoadScene = context.isDynamicLoadScene;
    context.enableProxima = Utils.parseValue(value, context.enableProxima);
    context.enableBatchObject = Utils.parseValue(module, context.enableBatchObject);
    context.skipEnvMap = Utils.parseValue(str, context.skipEnvMap);
    context.skipSkyBox = Utils.parseValue(text, context.skipSkyBox);
    var that = (new ol(this.app)).getLoader(context, options);
    obj._builder = that;
    that.loadSpeed = d;
    var netProgress = context.camInfo;
    if (netProgress) {
      that.fitCamInfo = netProgress;
    }
    this.app.root._staticEnableFlag.lock(false, "loadFromUBuilder");
    obj.trigger("beforeloadcampus");
    that.loadSceneJson(t).then(function(r) {
      var rows = JSON.parse(r);
      var defaults = rows.thingjsconfig || {};
      ul.parse(that.app, defaults, context, obj);
      if (onBeforeLoad) {
        onBeforeLoad({
          sceneData : rows
        });
      }
      that.load({
        campus : obj,
        json : rows,
        url : t
      }).then(function(options) {
        var selection = that.sceneJson ? that.sceneJson : context;
        var r = that.sceneJsonString;
        options.setSceneJSONData(selection, r);
        options.position = options.position || x;
        options.angles = options.angles || B;
        if (withEach) {
          withEach();
        }
        compound.app.root._staticEnableFlag.unlock("loadFromUBuilder");
      });
    });
  }, o.prototype.loadFromCampusBuildier = function(a, b, key, raw, callback) {
    CampusBuilderOnlineLoader.init({
      app : this.app
    });
    CampusBuilderOnlineLoader.getLoader().load(a, b, key, raw, callback);
  }, o.prototype._loadCampusFinished = function(tag, content) {
    tag._processModel();
    this._loadViewPointFile(content);
    this.app._lightGroup.setConfig({});
    this._removeTypeMap(content);
    THING.Utils.log("ThingJS: " + THING.VERSION);
  }, o.prototype._convertOutdoorsToGround = function(options) {
    if (options.outdoors) {
      var meshNode = options.outdoors.node;
      meshNode.userData = {};
      meshNode.removeBySelf();
      var serverCalendarID = options.outdoors.id;
      var uuid = options.outdoors.uuid;
      var n = this.app.create({
        type : "Ground",
        id : serverCalendarID,
        uuid : uuid,
        node : meshNode,
        visible : options.outdoors.visible,
        parent : options.outdoors.parent
      });
      options.outdoors.query("*", false).not(".CombinedObject").forEach(function(t) {
        options.add(t);
      });
      options.outdoors.query(".CombinedObject", false).forEach(function(e) {
        n.add(e);
      });
      options.outdoors.node = new THREE.Group;
      options.outdoors._children.clear();
      options.outdoors.destroy();
      options.outdoors = n;
    }
  }, o.prototype._loadFinished = function(obj, options) {
    var that = this;
    var g = options.complete;
    if (options.complete = function(e) {
      e.object._synEffectRefCounts();
      that._loadCampusFinished(e.object, options);
      if (g) {
        g.call(e.object, e);
      }
    }, that._convertOutdoorsToGround(obj), obj.setupID(options), obj instanceof Ki ? (options.parent = options.parent || this.app.root, obj._setup(options)) : obj instanceof Buliding && obj._setup(options), obj._originalSceneString) {
      var a = Utils._getStringMD5Code(obj._originalSceneString);
      if (!(hl = function(name) {
        var attrs = te.a;
        if (attrs) {
          var w = attrs.sd5;
          if (w && -1 === w.indexOf(name)) {
            return false;
          }
        }
        return true;
      }(a))) {
        obj.destroy();
      }
    }
  }, o.prototype.load = function(obj, options) {
    var self = this;
    var r = this.app.confirmURL(options.url);
    var n = r.appendURL("index.json");
    if (Utils.parseValue(options.disableCache, false)) {
      n = n.appendRandomSuffix();
    }
    (options.fileloader || new THREE.FileLoader).load(n, function(id) {
      var o = JSON.parse(id);
      if (ae) {
        var postHighSchoolTraining = new Zi(o.version);
        if (postHighSchoolTraining.major < 4 || postHighSchoolTraining.major > 4) {
          self.waitingLoadCampuses.push({
            owner : obj,
            url : r,
            indexJson : o,
            params : options
          });
        } else {
          self.loadCampus(obj, r, o, options);
        }
      } else {
        self.waitingLoadCampuses.push({
          owner : obj,
          url : r,
          indexJson : o,
          params : options
        });
      }
    }, function() {
    }, function() {
      var func = options.error || options.errorCallback;
      if (func) {
        func({
          url : r
        });
      }
      (new ol(self.app)).getLoader().load({
        campus : obj,
        url : r
      }).then(function(e) {
        self._loadFinished(e, options);
      });
    });
    obj.setupParent(options);
    options.skipSetupParent = true;
  }, o.prototype._setupTypeMap = function(options) {
    var buffer = options.typeMap;
    if (buffer) {
      var i = 0;
      for (; i < buffer.length; i++) {
        var s = buffer[i];
        Utils.addCastType(s.type, s.condition, s.params);
      }
    }
  }, o.prototype._removeTypeMap = function(node) {
    var t = node.typeMap;
    if (t) {
      var j = 0;
      for (; j < t.length; j++) {
        var s = t[j];
        Utils.removeCastType(s.type, s.condition, s.params);
      }
    }
  }, o.prototype.loadCampus = function(that, t, options, result) {
    var self = this;
    var f = function(model, count) {
      model.trigger("afterload");
      self._loadFinished(model, count);
      self.loadingCampus = false;
      model.loaded = true;
      setTimeout(function() {
        self.app.trigger("campusready", {
          object : model
        });
      }, 500);
    };
    options.resourceLibrary = result.loadResourceUrl || options.resourceLibrary;
    options.enableUseHighestVersionResource = result.enableUseHighestVersionResource;
    options.startDownloadResourcesCallback = function(xquery, cb) {
      var query = self.app.onLoadModelResourceCallback;
      if (query) {
        query(xquery, cb);
      }
    };
    this.loadingCampus = true;
    json2mesh.DefaultSetting.enableFloorLightMap = Utils.parseValue(result.enableFloorLightMap, false);
    result.indexJson = options;
    that.trigger(EventType.BeforeLoad, result);
    this.app.loadingProgressBar.prepare();
    this._setupTypeMap(result);
    that.loading = true;
    var version = new Zi(options.version);
    that._version = version;
    if (version.major < 4 || version.major > 4) {
      this.loadFromUBuilder(that, t, options, result, function() {
        f(that, result);
      });
    } else {
      this.loadFromCampusBuildier(that, t, options, result, function() {
        f(that, result);
      });
    }
  }, o.prototype.update = function() {
    if (ae && !this.loadingCampus) {
      if (we = we || b.toStr([96, 201, 170, 234, 66, 62, 13, 241, 82, 4, 65, 42, 195, 156, 129, 103, 23, 224, 109, 153, 106]), THING[we] || fe) {
        var i = 0;
        for (; i < this.waitingLoadCampuses.length; i++) {
          var n = this.waitingLoadCampuses[i];
          this.loadCampus(n.owner, n.url, n.indexJson, n.params);
          this.waitingLoadCampuses.splice(i, 1);
        }
        if (void 0 !== hl) {
          if (hl) {
            this.app.trigger("sceneMD5CheckSuccessed");
          } else {
            this.app.trigger("sceneMD5CheckFailed");
          }
          hl = void 0;
        }
      } else {
        if (!cl) {
          var query = {
            t : (new Date).toUTCString(),
            v : Math.random()
          };
          var body = JSON.stringify(query);
          var O = {
            "Content-type" : "application/x-www-form-urlencoded"
          };
          var indexLookupKey = b.toStr([96, 201, 174, 231, 66, 51, 32, 235, 92, 3, 108, 33, 253, 138, 129, 102, 17, 202, 118, 180, 116, 65, 157, 101, 253, 161]);
          var o = THING[indexLookupKey] || {};
          var k;
          for (k in o) {
            O[k] = o[k];
          }
          be(body, O);
          cl = true;
        }
      }
    }
  }, o.prototype._buildCampusStructure = function(node, data) {
    data.app = this.app;
    data.type = node.type;
    data.name = node.name ? node.name : node.id;
    data.id = node.id ? node.id : node.uuid;
    data.uuid = node.uuid;
    data.userData = node.userData;
    data.children = [];
    data.getAttribute = function(name) {
      return Utils.getAttribute(this, name);
    };
    data.getPath = function() {
      var url = this.id;
      var p = this.parent;
      for (; p && p.parent && p.parent.parent;) {
        url = p.id + "/" + url;
        p = p.parent;
      }
      return url;
    };
    data._traverseObjects = function(o, t) {
      var i = 0;
      for (; i < this.children.length; i++) {
        var a = this.children[i];
        if (Utils.isFunction(o)) {
          o(a);
        } else {
          if (Utils.isArray(o)) {
            o.push(a);
          }
        }
        if (t) {
          a._traverseObjects(o, t);
        }
      }
    };
    data.query = function(item) {
      var nameArgs = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      var group = [];
      this._traverseObjects(group, nameArgs);
      var controller = new xi(this.app, group);
      return controller.select(item), controller;
    };
    var e6484 = 0;
    if (node instanceof THING.Floor) {
      e6484 = 1;
    }
    var e = e6484;
    for (; e < node.children.length; e++) {
      var existing = node.children[e];
      var item2 = {
        id : existing.id,
        parent : data
      };
      data.children.push(item2);
      this._buildCampusStructure(existing, item2);
    }
  }, o.prototype._peekJSONBySimpleLoader = function(el, range, settings) {
    var complete = settings.complete;
    var gotoNewOfflinePage = settings.errorCallback || settings.error;
    var Jmol = this;
    range.load(el).then(function(a) {
      var value = {
        url : el,
        id : a.id,
        children : []
      };
      Jmol._buildCampusStructure(a, value);
      a.destroy();
      if (complete) {
        complete(value);
      }
    }).catch(function(e) {
      THING.Utils.error(e);
      if (gotoNewOfflinePage) {
        gotoNewOfflinePage();
      }
    });
  }, o.prototype.peekJSON = function(name, request) {
    request = request || {};
    var i = (name = this.app.confirmURL(name)).appendURL("index.json");
    if (Utils.parseValue(request.disableCache, false)) {
      i = i.appendRandomSuffix();
    }
    var r = request.fileloader || new THREE.FileLoader;
    var resp = this;
    r.load(i, function(i) {
      var r = JSON.parse(i);
      var postHighSchoolTraining = new Zi(r.version);
      if (!(4 == postHighSchoolTraining.major)) {
        if (3 == postHighSchoolTraining.major) {
          resp._peekJSONBySimpleLoader(name, new ss(resp.app), request);
        } else {
          resp._peekJSONBySimpleLoader(name, new os(resp.app), request);
        }
      }
    }, function() {
    }, function() {
      resp._peekJSONBySimpleLoader(name, new os(resp.app), request);
    });
  }, o.prototype.onUpdate = function(e) {
    this.update(e);
  }, o;
}();
dl = function(t) {
  function e(row) {
    r(this, e);
    var that = s(this, t.call(this, row));
    return that._graph = null, that._expanded = false, that._structShow = false, that;
  }
  return o(e, t), e.prototype._canAcceptMouseEvent = function(source) {
    var name = source.type;
    return !!D[name];
  }, e.prototype.canAcceptEvent = function(event) {
    if (t.prototype.canAcceptEvent.call(this, event)) {
      return this;
    }
    var self = event.object;
    if (self && self.isChildOf(this)) {
      if (self.isFloor && this._canAcceptMouseEvent(event)) {
        return this;
      }
      if (self.isFacade && this._canAcceptMouseEvent(event)) {
        return this;
      }
      if (self.parent) {
        if (self.parent.isFloor && this._canAcceptMouseEvent(event)) {
          return this;
        }
        if (self.parent.isFacade && this._canAcceptMouseEvent(event)) {
          return this;
        }
      }
    }
    return null;
  }, e.prototype._addFromCampus = function(objects) {
    if (objects.buildings.length) {
      this.floors.destroy();
      var floors = objects.buildings[0].floors;
      var i = this;
      floors.forEach(function(e) {
        i.add(e);
      });
    }
  }, e.prototype.loadResource = function() {
    var bubbled_sets__3355 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    if (bubbled_sets__3355) {
      t.prototype.loadResource.call(this, bubbled_sets__3355);
    } else {
      this.floors.forEach(function(srUtils) {
        srUtils.loadResource(false);
      });
    }
  }, e.prototype.unloadResource = function() {
    var bubbled_sets__3355 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    if (bubbled_sets__3355) {
      t.prototype.unloadResource.call(this, bubbled_sets__3355);
    } else {
      this.floors.forEach(function(resMgr) {
        resMgr.unloadResource();
      });
    }
  }, e.prototype.setupElevators = function() {
    var obj = {};
    var key;
    for (key in this.query(".ElevatorDoor").forEach(function(error) {
      var headsetType = error.userData._ELEVATOR_;
      if (!obj[headsetType]) {
        obj[headsetType] = [];
      }
      obj[headsetType].push(error);
    }), obj) {
      var info = obj[key];
      this.app.create({
        type : "Elevator",
        name : key,
        parent : this,
        doors : info
      });
    }
  }, e.prototype.setupStairs = function() {
    this.query("[type=stairway]").forEach(function(fromController) {
      fromController.floorNode.visible = false;
    });
    var obj = {};
    var key;
    for (key in this.query(".StairDoor").forEach(function(error) {
      var headsetType = error.userData._STAIR_;
      obj[headsetType] = obj[headsetType] || [];
      obj[headsetType].push(error);
    }), obj) {
      var info = obj[key];
      this.app.create({
        type : "Stair",
        name : key,
        parent : this,
        doors : info
      });
    }
  }, e.prototype.canNavigation = function() {
    return true;
  }, e.prototype.customSetup = function(val) {
    this._structShow = Utils.parseValue(val.structShow, this._structShow);
  }, e.prototype.setupNavigationObjects = function() {
    this.setupElevators();
    this.setupStairs();
  }, e.prototype.setupGraph = function(t, data) {
    var self = this.floors;
    var r = self.indexOf(t.floor);
    self.splice(r, 1);
    var n = self.indexOf(data.floor);
    self.splice(n, 1);
    var repo = {};
    return t.floor._setupNavigationGraph(repo, t), self.forEach(function(cmts) {
      cmts._setupNavigationGraph(repo);
    }), data.floor._setupNavigationGraph(repo, data), this._graph = new Graph(repo), this._graph;
  }, e.prototype.destroy = function() {
    this._graph = null;
    t.prototype.destroy.call(this);
  }, e.prototype.hasAnyFacadesVisible = function() {
    var opLayers = this.facades;
    var i = 0;
    for (; i < opLayers.length; i++) {
      if (opLayers[i].visible) {
        return true;
      }
    }
    return false;
  }, e.prototype.hasFacades = function() {
    return 0 !== this.facades.length;
  }, e.prototype.showAllRoofs = function() {
    var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    this.floors.forEach(function(PL$37) {
      PL$37.showAllRoofs(e);
    });
  }, e.prototype.expandFloors = function(data) {
    data = data || {};
    if (!this.expandCmd) {
      this.expandCmd = this.app.commandManager.create({
        type : "ExpandObjects"
      });
    }
    data.objects = this.floors.objects;
    data.hideRoof = Utils.parseValue(data.hideRoof, true);
    this.expandCmd.setParam(data);
    this.expandCmd.execute();
    this._expanded = true;
  }, e.prototype.unexpandFloors = function(type) {
    type = type || {};
    if (this.expandCmd) {
      if (type.hideRoof) {
        type.hideRoof = !type.hideRoof;
      }
      this.expandCmd.setParam(type);
      this.expandCmd.undo();
      this._expanded = false;
    }
  }, e.prototype.showFacades = function() {
    var showBoneHandles = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    THING.Utils.warn("[Building] Please use '.facades.visible=true/false' to replace '.showFacades()'");
    this.facades.visible = showBoneHandles;
  }, e.prototype.showFloors = function() {
    var showBoneHandles = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    THING.Utils.warn("[Building] Please use '.floors.visible=true/false' to replace '.showFloors()'");
    this.floors.visible = showBoneHandles;
  }, e.prototype.showRoof = function() {
    var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    THING.Utils.warn("[Building] Please use '.showAllRoofs()' to replace '.showRoof()'");
    this.showAllRoofs(e);
  }, n(e, [{
    key : "isBuilding",
    get : function() {
      return true;
    }
  }, {
    key : "structShow",
    get : function() {
      return this._structShow;
    }
  }, {
    key : "expanded",
    get : function() {
      return this._expanded;
    }
  }, {
    key : "facade",
    get : function() {
      return this.query(".Facade", false)[0];
    }
  }, {
    key : "facades",
    get : function() {
      return this.query(".Facade", false);
    }
  }, {
    key : "elevators",
    get : function() {
      return this.query(".Elevator", false);
    }
  }, {
    key : "stairs",
    get : function() {
      return this.query(".Stair", false);
    }
  }, {
    key : "floors",
    get : function() {
      return this.query(".Floor", false);
    }
  }, {
    key : "things",
    get : function() {
      return this.query(".Thing", false);
    }
  }]), e;
}(BaseObject);
fl = function(context) {
  function d(row) {
    r(this, d);
    var path = s(this, context.call(this, row));
    return path._ceilingNode = null, path._ceilingObject = null, path._roofNode = null, path._roofObject = null, path._floorNode = null, path._floorObject = null, path._auxiliaryInfo = null, path._textRegion = null, path._holes = [], path._points = [], path;
  }
  return o(d, context), d.prototype._toPoints = function(buildInTemplates) {
    return buildInTemplates.map(function(self) {
      return self.isVector3 ? self.toArray() : self;
    });
  }, d.prototype._toHoles = function(buildInTemplates) {
    return buildInTemplates.map(function(buildInTemplates) {
      return buildInTemplates.map(function(self) {
        return self.isVector3 ? self.toArray() : self;
      });
    });
  }, d.prototype.setup = function(data) {
    var i;
    if (context.prototype.setup.call(this, data), this._holes = data.holes || [], this._points = data.points || [], this._holes = this._toHoles(this._holes), this._points = this._toPoints(this._points), this._ceilingNode = data.ceilingNode || this._ceilingNode, this._roofNode = data.roofNode || this._roofNode, this._auxiliaryInfo = data.auxiliaryInfo || this._auxiliaryInfo, this._floorNode = data.floorNode || this._floorNode, data.floorHideByScene && this._floorNode) {
      if (i = this._floorNode.parent) {
        this.app.resourceManager.remove(this._floorNode);
        this._floorNode = new THREE.Group;
        i.add(this._floorNode);
      }
    }
    if (data.roofHideByScene && this._roofNode) {
      if (i = this._roofNode.parent) {
        this.app.resourceManager.remove(this._roofNode);
        this._roofNode = new THREE.Group;
        i.add(this._roofNode);
      }
    }
  }, d.prototype.setupResources = function(prevProps) {
    context.prototype.setupResources.call(this, prevProps);
    this._ceilingNode = prevProps.ceilingNode || this._ceilingNode;
    this._roofNode = prevProps.roofNode || this._roofNode;
    this._floorNode = prevProps.floorNode || this._floorNode;
    if (this._ceilingNode && this.ceiling) {
      this._ceilingNode.visible = this.ceiling.visible;
      this.ceiling.node = this._ceilingNode;
    }
    if (this._roofNode && this.roof) {
      this._roofNode.visible = this.roof.visible;
      this.roof.node = this._roofNode;
    }
    if (this._floorNode && this.plan) {
      this._floorNode.visible = this.plan.visible;
      this.plan.node = this._floorNode;
    }
  }, d.prototype.getFloorMesh = function() {
    var library = this._floorNode;
    if (!library) {
      return null;
    }
    var cnameParts = library.getMeshes();
    return cnameParts.length ? cnameParts[0] : null;
  }, d.prototype.getRoomHeight = function() {
    return 3;
  }, d.prototype.showGrid = function(url, user, data, o, options) {
    var defaultSafeIntegers = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : .01;
    context.prototype.showGrid.call(this, url, user, data, o, options, defaultSafeIntegers);
    var fname = Utils.parseVector3(this.labelPosition);
    this._grid._setWorldPosition(fname, this.static);
  }, d.prototype.getLabelPosition = function(x) {
    var assert = this.getFloorMesh();
    if (!assert) {
      return null;
    }
    var resultsSubject = assert.getLabelPosition(x, "xz") || assert.getLabelPosition(x, "xy");
    return resultsSubject ? resultsSubject.toArray() : null;
  }, d.prototype.getAvaliablePositions = function(level, message) {
    var y = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
    if (!Utils.isNumber(level)) {
      return null;
    }
    var div = [];
    if (Utils.isArray(message[0])) {
      var i = 0;
      for (; i < level; i++) {
        var object = message[i];
        div.push(object);
      }
    } else {
      i = 0;
      for (; i < level; i++) {
        div.push(message);
      }
    }
    var Object = this.getFloorMesh();
    if (!Object) {
      return null;
    }
    var a = Object.getAvaliableLabelPosition(div, "xz", y);
    if (!a || a.length < level) {
      var b = Object.getAvaliableLabelPosition(div, "xy", y);
      if (b && b.length > a.length) {
        a = b;
      }
    }
    i = 0;
    for (; i < a.length; i++) {
      a[i] = a[i].toArray();
    }
    return a;
  }, d.prototype.getRayCastPosition = function(e) {
    if (!(e = Utils.parseVector3(e))) {
      return null;
    }
    var touchSystem = this.getFloorMesh();
    if (!touchSystem) {
      return null;
    }
    var this_area = touchSystem.getRayCastPosition(e);
    return this_area ? this_area.toArray() : null;
  }, d.prototype.getPoints = function(max) {
  }, d.prototype._synTextRegion = function() {
    if (this._textRegion) {
      var p = this._textRegion.position;
      if (this.style._volumeNode) {
        var v = new THREE.Vector3;
        this.style._volumeNode.getWorldPosition(v);
        p[1] = v.y;
      } else {
        p[1] = this.position[1];
      }
      p[1] += .01;
      this._textRegion.position = p;
    }
  }, d.prototype.getNavigationMesh = function() {
    var library = this._floorNode;
    if (!library) {
      return null;
    }
    if (!this.area) {
      return null;
    }
    var cnameParts = library.getMeshes();
    return cnameParts.length ? cnameParts[0] : null;
  }, d.prototype._getChildVisibles = function() {
    var pipelets = this.children.concat([this.roof, this.ceiling, this.plan]);
    var props = [];
    return pipelets.forEach(function(settings) {
      if (settings) {
        props.push(settings.visible);
      }
    }), props;
  }, d.prototype._onGetChild = function() {
    return this.children.concat([this.roof, this.ceiling, this.plan]);
  }, d.prototype.setRelativePoints = function(headerPlusSegments) {
    if (headerPlusSegments) {
      this._points = headerPlusSegments.slice(0);
    }
  }, d.prototype._getLinkableDoors = function() {
    var space_camera_pivot = context.prototype._getLinkableDoors.call(this);
    return space_camera_pivot.add(this.doors), space_camera_pivot;
  }, d.prototype.showCeiling = function(isBlobDisplay) {
    THING.Utils.warn("[Room] Please use '.ceiling.visible=true/false' to replace '.showCeiling()'");
    this.ceiling.visible = isBlobDisplay;
  }, d.prototype.showRoof = function(isBlobDisplay) {
    THING.Utils.warn("[Room] Please use '.roof.visible=true/false' to replace '.showRoof()'");
    this.roof.visible = isBlobDisplay;
  }, d.prototype.showFloor = function(isBlobDisplay) {
    THING.Utils.warn("[Room] Please use '.floorNode.visible=true/false' to replace '.showFloor()'");
    this.floorNode.visible = isBlobDisplay;
  }, d.prototype.showRoof = function(isBlobDisplay) {
    THING.Utils.warn("[Room] Please use '.roof.visible=true/false' to replace '.showRoof()'");
    this.roof.visible = isBlobDisplay;
  }, d.prototype.setFloor = function(context) {
    THING.Utils.warn("[Room] Please use '.floorNode.style.' to replace '.setFloor()'");
    context = context || {};
    var s = this.floorNode.style;
    var name = context.color;
    if (name) {
      s.color = name;
    }
    var opacity = context.opacity;
    if (opacity) {
      s.opacity = opacity;
    }
  }, d.prototype.getAvaliableFloorPos = function(e, hangout) {
    return THING.Utils.warn("[Room] Please use '.floor.getAvaliablePositions()' to replace '.getAvaliableFloorPos()'"), this.getAvaliablePositions(e, hangout);
  }, n(d, [{
    key : "isRoom",
    get : function() {
      return true;
    }
  }, {
    key : "labelPosition",
    get : function() {
      var expectedDropEffect = this.getLabelPosition(null);
      if (expectedDropEffect) {
        return expectedDropEffect;
      }
      var opt = this._auxiliaryInfo;
      return opt && opt.center ? opt.center.toArray() : null;
    }
  }, {
    key : "perimeter",
    get : function() {
      var p = this.points;
      return THING.Math.getPerimeter(p);
    }
  }, {
    key : "area",
    get : function() {
      var x = this.points;
      return THING.Math.getArea(x);
    }
  }, {
    key : "ceiling",
    get : function() {
      return !this._ceilingObject && this._ceilingNode && (this._ceilingObject = (new ts(this.app))._init(this._ceilingNode), this._ceilingObject._parent = this), this._ceilingObject;
    }
  }, {
    key : "roof",
    get : function() {
      return !this._roofObject && this._roofNode && (this._roofObject = (new ts(this.app))._init(this._roofNode), this._roofObject._parent = this), this._roofObject;
    }
  }, {
    key : "plan",
    get : function() {
      if (!this._floorObject) {
        if (this.getFloorMesh()) {
          this._floorObject = (new ts(this.app))._init(this.getFloorMesh());
          this._floorObject._parent = this;
        }
      }
      return this._floorObject;
    }
  }, {
    key : "misc",
    get : function() {
      return this.miscObject || (this.miscObject = this.query(".CombinedObject").query("[userData/type=CombineMiscParent]")[0]), this.miscObject;
    }
  }, {
    key : "floor",
    get : function() {
      return this.parents.query(".Floor")[0];
    }
  }, {
    key : "points",
    get : function() {
      var t;
      var $varContainer = this;
      if (this._points.length) {
        t = this._points.map(function(max_height) {
          return $varContainer.selfToWorld(max_height);
        });
      } else {
        var newTraceroute = this.getFloorMesh();
        if (!newTraceroute) {
          return null;
        }
        t = newTraceroute.getPoints();
        this.holes.forEach(function(wrappersTemplates) {
          wrappersTemplates.forEach(function(advform) {
            var k = 0;
            for (; k < t.length; k++) {
              var triangle = t[k];
              if (THING.Math.equalsVector(advform, triangle)) {
                t.splice(k--, 1);
              }
            }
          });
        });
      }
      var j = 0;
      for (; j < t.length - 1; j++) {
        if (THING.Math.equalsVector(t[j], t[j + 1])) {
          t.splice(j--, 1);
        }
      }
      return t;
    }
  }, {
    key : "things",
    get : function() {
      var cur = this.parent;
      if (!cur) {
        return new xi(this.app, []);
      }
      var r = [];
      var args = cur.things;
      var i = 0;
      for (; i < args.length; i++) {
        var extra = args[i];
        if (this.getRayCastPosition(extra.position)) {
          r.push(extra);
        }
      }
      return this._children.forEach(function(e) {
        if (e.isBatchSubObject) {
          r.push(e);
        }
      }), (new xi(this.app, r, true)).buildReturnObject(r).add(this.query(".Thing"));
    }
  }, {
    key : "doors",
    get : function() {
      var d = this.floor.doors;
      var t = [];
      var i = 0;
      for (; i < d.length; i++) {
        var x = d[i];
        var result = new THREE.Vector3;
        var base = Utils.parseVector3(x.position);
        var crossfilterable_layers = [Utils.parseVector3(x.forward)];
        var layer_i = 0;
        for (; layer_i < crossfilterable_layers.length; layer_i++) {
          var offset = crossfilterable_layers[layer_i];
          if (offset.multiplyScalar(1), result.addVectors(base, offset), this.getRayCastPosition(result) || (offset.multiplyScalar(-1), result.addVectors(base, offset), this.getRayCastPosition(result))) {
            t.push(x);
            break;
          }
        }
      }
      return (new xi(this.app, t)).buildReturnObject(t);
    }
  }, {
    key : "textRegion",
    get : function() {
      return this._textRegion || (this._textRegion = this.app.create({
        type : "TextRegion",
        text : this.name,
        parent : this,
        position : this.labelPosition,
        angles : [-90, 0, 0]
      }), this._textRegion.translateY(.1), this._textRegion.renderOrder = 1), this._synTextRegion(), this._textRegion;
    },
    set : function(num) {
      if (num) {
        this._textRegion = num;
        this._synTextRegion();
      } else {
        this._textRegion.destroy();
        this._textRegion = null;
      }
    }
  }, {
    key : "holes",
    get : function() {
      var results = [];
      if (this._holes) {
        var touchSystem = this;
        this._holes.forEach(function(wrappersTemplates) {
          var inner = [];
          wrappersTemplates.forEach(function(e) {
            inner.push(touchSystem.selfToWorld(e));
          });
          results.push(inner);
        });
      }
      return results;
    }
  }, {
    key : "floorIndex",
    get : function() {
      return THING.Utils.warn("[Room] Please use '.floor.indexOfParent()' to replace '.floorIndex()'"), this.floor.indexOfParent();
    }
  }, {
    key : "center",
    get : function() {
      return THING.Utils.warn("[Room] Please use '.labelPosition' to replace '.center' or if you want to use .boundingBox.center to get center of boundingBox?"), this.labelPosition;
    }
  }, {
    key : "floorNode",
    get : function() {
      return THING.Utils.warn("[Room] Please use '.plan' to replace '.floorNode'"), this.plan;
    }
  }]), d;
}(BaseObject);
ml = document.createElement("canvas");
ml.width = 256, ml.height = 1;
var gl = ml.getContext("2d");
function vl(colors, texture) {
  var gradient = gl.createLinearGradient(0, 0, 256, 0);
  var i;
  for (i in colors) {
    gradient.addColorStop(+i, colors[i]);
  }
  gl.fillStyle = gradient;
  gl.fillRect(0, 0, 256, 1);
  var src = new Uint8Array(gl.getImageData(0, 0, 256, 1).data.buffer);
  return void 0 !== texture ? texture.image = {
    data : src,
    width : 256,
    height : 1
  } : texture = new THREE.DataTexture(src, 256, 1), texture.magFilter = texture.minFilter = THREE.LinearFilter, texture.needsUpdate = true, texture;
}
var yl = new Map;
var bl = new Map;
var _l = new Map;
var xl = new Map;
var El = false;
var wl = function() {
  function a() {
    r(this, a);
  }
  return a.start = function(obj) {
    if (!El) {
      obj.on("update", function() {
        xl.forEach(function(wrappersTemplates) {
          wrappersTemplates.forEach(function(layer) {
            return layer.matrix.elements[7] -= layer.speed;
          });
        });
      });
      El = true;
    }
  }, a.register = function(name, target) {
    yl.set(name, target);
    bl.set(name, function(revLookup) {
      var ctx = {};
      var k;
      for (k in revLookup) {
        var split = k.split("-");
        var i = split[0];
        if (!ctx[i]) {
          ctx[i] = {};
        }
        var name = split[1];
        if (!(void 0 === name || ctx[i][name])) {
          ctx[i][name] = {};
        }
        var prop = split[2];
        if (void 0 !== prop) {
          ctx[i][name][prop] = {};
        }
      }
      return ctx;
    }(target.class));
    _l.set(name, function(optset) {
      var result = new Map;
      var v;
      for (v in optset) {
        var c = optset[v].colormap;
        if (c) {
          var max = void 0;
          if (result.has(v)) {
            max = result.get(v);
          }
          result.set(v, vl(c, max));
        }
      }
      return result;
    }(target.class));
    xl.set(name, function(optset) {
      var result = new Map;
      var v;
      for (v in optset) {
        if (optset[v].useScrollTex) {
          var speed = optset[v].scrollSpeed;
          speed = void 0 !== speed ? speed : .003;
          result.set(v, {
            matrix : new THREE.Matrix3,
            speed : speed
          });
        }
      }
      return result;
    }(target.class));
  }, a.findStyle = function(name, input, x) {
    if (!yl.has(name) || !bl.has(name)) {
      return THING.Utils.warn("StyleManager: style '" + name + "' not registed."), null;
    }
    if (x && x._sfStyle) {
      var i = x._sfStyle;
      return {
        style : yl.get(name).class[i],
        colormap : _l.get(name).get(i),
        scroll : xl.get(name).has(i) ? xl.get(name).get(i).matrix : null
      };
    }
    if (input && x) {
      var c = function(data, result, note) {
        var id = result.type;
        var p = "";
        if (!data[id]) {
          var type;
          for (type in data) {
            if (THING.Utils.instanceOf(result, type)) {
              id = type;
            }
          }
        }
        if (!data[id]) {
          return "";
        }
        var i;
        for (i in data[id]) {
          var tags = result.tags;
          if ("Facade" === id && result.building && (tags = result.building.tags), tags.indexOf(i) > -1 && "" !== i) {
            p = i;
            break;
          }
        }
        if (!data[id][p]) {
          return id;
        }
        var o;
        for (o in data[id][p]) {
          if (note.name === o) {
            return id + "-" + p + "-" + note.name;
          }
        }
        return id + ("" !== p ? "-" + p : "");
      }(bl.get(name), input, x);
      return {
        style : yl.get(name).class[c],
        colormap : _l.get(name).get(c),
        scroll : xl.get(name).has(c) ? xl.get(name).get(c).matrix : null
      };
    }
    return yl.get(name);
  }, a;
}();
function Tl(result, n) {
  var matrixX = result.getMatrixFromRoot(n);
  var geometry = result.geometry;
  if (geometry && geometry.isBufferGeometry && !geometry.getAttribute("uv3")) {
    var data = geometry.getAttribute("position");
    var index = new THREE.BufferAttribute(new Float32Array(2 * data.count), 2);
    var buffer = new THREE.Vector3;
    var a = -1 / 0;
    var b = 1 / 0;
    var i = 0;
    for (; i < data.count; i++) {
      buffer.fromArray(data.array, 3 * i).applyMatrix4(matrixX);
      index.array[2 * i + 0] = .5;
      index.array[2 * i + 1] = buffer.y;
      a = Math.max(a, buffer.y);
      b = Math.min(b, buffer.y);
    }
    var lengthDiff = a - b;
    var s = 0;
    for (; s < data.count; s++) {
      index.array[2 * s + 1] = index.array[2 * s + 1] / lengthDiff;
    }
    geometry.addAttribute("uv3", index);
  }
}
var Ml = function() {
  function a(value) {
    r(this, a);
    this.obj = value;
    this._opacity = null;
    this._color = null;
    this._wireframe = false;
    this._image = "";
    this._doubleSide = false;
    this._uvAnimationParams = null;
    this._emissive = null;
    this._emissiveScrollImage = null;
    this._environmentImage = null;
    this._highlight = null;
    this._highlightIntensity = null;
    this._inheritThemeName = null;
    this._themeName = null;
    this._alwaysOnTop = false;
    this._renderOrder = 0;
    this._defaultOutlineColor = null;
    this._outlineColor = null;
    this._glow = false;
    this._innerGlow = false;
    this._focusRegion = false;
    this._edgeColor = null;
    this._edgeIncludeChildren = true;
    this._edgeWireframes = new Map;
    this._boundingBoxNode = null;
    this._orientedBoundingBoxNode = null;
    this._axisNode = null;
    this._vertexNormalNode = null;
    this._synStyle = null;
  }
  return a.prototype._syn = function() {
    var action = this._synStyle;
    if (action) {
      delete this._synStyle;
      action.execute(this.obj);
    }
  }, a.prototype._setSynValue = function(name, values) {
    if (!this.obj || !this.obj.app) {
      return false;
    }
    var status = this.obj.dataToRecover;
    return status && (status.style[name] = values), !this.obj.loaded && (this._synStyle || (this._synStyle = this.obj.app.commandManager.create({
      type : "SetObjectStyle",
      object : this.obj
    })), this._synStyle.setAttribute(name, values), true);
  }, a.prototype._getSynValue = function(path) {
    return this._synStyle ? this.obj.loaded ? null : this._synStyle.getAttribute(path) : null;
  }, a.prototype._traverse = function(callback) {
    var t = [];
    this.obj.children.forEach(function(e) {
      t.push(e.node);
    });
    this.obj.node.traverseBranch(function(error) {
      if (-1 !== t.indexOf(error)) {
        return false;
      }
      if (!error.userData.skipStyle) {
        callback(error);
      }
    });
  }, a.prototype._onEnter = function() {
  }, a.prototype._onLeave = function() {
  }, a.prototype._changeMaterial = function($) {
    this._traverse(function(panel) {
      if (panel.material) {
        var id = panel.material;
        if (Utils.isArray(id)) {
          panel.material = id.map(function(vs) {
            return $(vs, panel);
          });
        } else {
          panel.material = $(id, panel);
        }
      }
    });
  }, a.prototype._cloneAndModifyMaterial = function(c) {
    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    var n = arguments[2];
    n = n || function(self) {
      return !t || !(!self._isCloned() || !self._getOriginal());
    };
    this._changeMaterial(function(t, runjs) {
      if (n(t)) {
        return c && c(t._getPrevMaterial(), t, runjs), t;
      }
      var arrayOf100 = t._pushAndCloneSelf();
      return c && c(arrayOf100._getPrevMaterial(), arrayOf100, runjs), arrayOf100;
    });
  }, a.prototype.revertMaterial = function() {
    var request = this;
    var modVal = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
    this._changeMaterial(function(z) {
      var mod = modVal ? z._getOriginal() : z._getPrevMaterial();
      return mod ? (Utils.parseValue(THING.needDisposeMaterial, true) && request.obj.app.materialDisposeManager.push(z), mod) : (Utils.revertValue(z, "opacity"), Utils.revertValue(z, "color"), Utils.revertValue(z, "depthTest"), Utils.revertValue(z, "depthWrite"), Utils.revertValue(z, "onBeforeRender"), Utils.revertValue(z, "wireframe"), Utils.revertValue(z, "wireframeMap"), Utils.revertValue(z, "map"), z);
    });
  }, a.prototype._applyMaterial = function(options, result, x) {
    var i = this._getThemeName();
    var data = void 0;
    var page = void 0;
    if (i) {
      var item = wl.findStyle(i, this.obj, x);
      if (item && item.style && (void 0 === item.style.enable || item.style.enable)) {
        data = item;
        page = wl.findStyle(i);
      }
    }
    if (data && data.style.reflection && data.style.reflection.enable) {
      var options = data.style.reflection;
      result.metalness = options.metalness;
      result.roughness = options.roughness;
      result.specularFactor = void 0 !== options.specularFactor ? options.specularFactor : 1;
    } else {
      result.metalness = options.metalness;
      result.roughness = options.roughness;
      result.specularFactor = 1;
    }
    if (data && data.style.fresnel) {
      result.fresnelPower = data.style.fresnel.power;
      result.fresnelInverse = data.style.fresnel.inverse;
    } else {
      result.fresnelPower = 0;
      result.fresnelInverse = false;
    }
    if (this._emissiveScrollImage || data && data.style.useScrollTex) {
      Tl(x, this.obj.node);
    }
    this._applyMaterialOpacity(options, result, data);
    this._applyMaterialColor(options, result, data);
    this._applyMaterialEmissive(options, result, data);
    this._applyMaterialEmissiveScrollImage(options, result, data, page);
    this._applyMaterialImage(options, result, data, page);
    this._applyMaterialEnvironmentImage(options, result, data, page);
    if (this._highlight) {
      result.highlightColor.copy(this._highlight);
      result.highlightIntensity = Utils.isNull(this._highlightIntensity) ? .5 : this._highlightIntensity;
    }
  }, a.prototype._applyMaterialOpacity = function(data, options, obj) {
    var value = void 0;
    value = data.isShaderMaterial && data.uniforms.opacity ? data.uniforms.opacity.value : data.opacity;
    if (null !== this._opacity && void 0 !== this._opacity) {
      value = value * this._opacity;
    }
    if (obj && void 0 !== obj.style.opacity) {
      value = value * obj.style.opacity;
    }
    if (options.isShaderMaterial && options.uniforms.opacity) {
      options.uniforms.opacity.value = value;
    } else {
      options.opacity = value;
    }
    if (data.alphaTest) {
      options.alphaTest = value * data.alphaTest;
    }
    var cancel = options.transparent;
    options.transparent = data.transparent || value < 1;
    if (options.transparent != cancel) {
      options.needsUpdate = true;
    }
  }, a.prototype._applyMaterialColor = function(properties, data, options) {
    if (null !== this._color && void 0 !== this._color) {
      if (data.color) {
        data.color.copy(this._color);
      }
      if (data.colorMapping) {
        data.needsUpdate = true;
      }
      data.colorMapping = null;
      data.colorMappingIntensity = 1;
    } else {
      if (data.color && properties.color) {
        if (options && options.style.color && options.style.color.enable) {
          data.color.set(options.style.color.value);
        } else {
          data.color.copy(properties.color);
        }
      }
      if (options && (void 0 === options.style.useColormap || options.style.useColormap)) {
        if (!data.colorMapping) {
          data.needsUpdate = true;
        }
        data.colorMapping = options.colormap;
        data.colorMappingIntensity = void 0 !== options.style.colormapIntensity ? options.style.colormapIntensity : 1;
      } else {
        if (data.colorMapping) {
          data.needsUpdate = true;
        }
        data.colorMapping = null;
        data.colorMappingIntensity = 1;
      }
    }
  }, a.prototype._applyMaterialEmissive = function(source, material, options) {
    if (null !== this._emissive && void 0 !== this._emissive) {
      if (material.emissive) {
        material.emissive.copy(this._emissive);
        material.emissiveIntensity = 1;
      }
    } else {
      if (material.emissive && source.emissive) {
        if (options && options.style.useScrollTex) {
          material.emissive.set(options.style.scrollColor);
          material.emissiveIntensity = 1;
        } else {
          material.emissive.copy(source.emissive);
          material.emissiveIntensity = source.emissiveIntensity || 0;
        }
      }
    }
    if (options && options.style.colorImage && options.style.colorImage.enable && !options.style.useScrollTex) {
      material.emissiveIntensity = 0;
    }
  }, a.prototype._applyMaterialEmissiveScrollImage = function(source, data, options, stack) {
    var self = this.obj.app;
    if (null !== this._emissiveScrollImage && void 0 !== this._emissiveScrollImage) {
      if (void 0 !== data.emissiveMap) {
        if (!data.emissiveMap) {
          data.needsUpdate = true;
        }
        data.emissiveMap = self.resourceManager.loadTexture(this._emissiveScrollImage, function() {
        }, {
          repeat : true,
          premultiplyAlpha : true
        });
        data.defines = data.defines || {};
        data.defines.USE_ALPHA_UV3 = true;
        data.defines.USE_EMISSIVETRANSFORM = true;
        data.defines.USE_SIDE_EMISSIVE = true;
        data.uvTransform2 = function(promise) {
          if (!Sl) {
            promise.on("update", jl);
            Sl = true;
          }
          return Cl;
        }(self);
        self.rendererManager.autoDirty = true;
        data.needsUpdate = true;
      }
    } else {
      if (void 0 !== data.emissiveMap && void 0 !== source.emissiveMap) {
        if (options && options.style.useScrollTex) {
          if (!data.emissiveMap) {
            data.needsUpdate = true;
          }
          var value = options.style.scrollTex;
          if (stack && stack.resourcePrefix) {
            value = stack.resourcePrefix.appendURL(options.style.scrollTex);
          }
          data.emissiveMap = self.resourceManager.loadTexture(value, function() {
          }, {
            repeat : true,
            premultiplyAlpha : true
          });
          data.defines = data.defines || {};
          data.defines.USE_ALPHA_UV3 = true;
          data.defines.USE_EMISSIVETRANSFORM = true;
          data.defines.USE_SIDE_EMISSIVE = true;
          data.uvTransform2 = options.scroll;
          self.rendererManager.autoDirty = true;
          data.needsUpdate = true;
        } else {
          if (!!data.emissiveMap != !!source.emissiveMap) {
            data.needsUpdate = true;
          }
          data.emissiveMap = source.emissiveMap;
          data.uvTransform2 = null;
          if (data.defines) {
            if (data.defines.USE_ALPHA_UV3) {
              delete data.defines.USE_ALPHA_UV3;
              data.needsUpdate = true;
            }
            if (data.defines.USE_EMISSIVETRANSFORM) {
              delete data.defines.USE_EMISSIVETRANSFORM;
              data.needsUpdate = true;
            }
            if (data.defines.USE_SIDE_EMISSIVE) {
              delete data.defines.USE_SIDE_EMISSIVE;
              data.needsUpdate = true;
            }
          }
        }
      }
    }
  }, a.prototype._applyMaterialImage = function(data, result, options, self) {
    var wickedGrid = this;
    var texture = this.obj.app;
    if (this._image) {
      if (void 0 !== result.map) {
        if (!result.map) {
          result.needsUpdate = true;
        }
        result.map = this.obj.app.resourceManager.loadTexture(this._image, function() {
          if (wickedGrid.obj) {
            texture.needUpdate = true;
          }
        }, {
          repeat : true,
          flipY : !data.map || data.map.flipY
        });
      }
    } else {
      if (void 0 !== result.map && void 0 !== data.map) {
        if (options && options.style.image) {
          if (!result.map) {
            result.needsUpdate = true;
          }
          var src = options.style.image;
          if (self && self.resourcePrefix) {
            src = self.resourcePrefix.appendURL(options.style.image);
          }
          result.map = this.obj.app.resourceManager.loadTexture(src, function() {
            if (wickedGrid.obj) {
              texture.needUpdate = true;
            }
          }, {
            repeat : true
          });
        } else {
          if (options && options.style.colorImage && options.style.colorImage.enable) {
            if (!result.map) {
              result.needsUpdate = true;
            }
            result.map = this.obj.app.resourceManager.textureLoader.loadTextureFromColor(options.style.colorImage.color);
          } else {
            if (!!result.map != !!data.map) {
              result.needsUpdate = true;
            }
            result.map = data.map;
          }
        }
      }
    }
  }, a.prototype._applyMaterialEnvironmentImage = function(data, material, options, config) {
    var wickedGrid = this;
    var app = this.obj.app;
    if (this._environmentImage) {
      if (void 0 !== material.envMap) {
        material.needsUpdate = true;
        if (Array.isArray(this._environmentImage)) {
          material.envMap = this.obj.app.resourceManager.loadCubeTexture(this._environmentImage, function() {
            material.envMapIntensity = 1.3;
            if (wickedGrid.obj) {
              app.needUpdate = true;
            }
          });
        } else {
          material.envMap = this.obj.app.resourceManager.loadTexture(this._environmentImage, function() {
            material.envMapIntensity = 1.3;
            if (wickedGrid.obj) {
              app.needUpdate = true;
            }
          }, {
            mapping : THREE.EquirectangularReflectionMapping
          });
        }
      }
    } else {
      if (void 0 !== material.envMap && void 0 !== data.envMap) {
        if (options && options.style.reflection && options.style.reflection.enable) {
          material.needsUpdate = true;
          var key = void 0;
          var url = void 0;
          if (config && void 0 !== config.resourcePrefix && void 0 !== config.enviroment) {
            if (config.enviroment.type && "image" === config.enviroment.type) {
              key = config.resourcePrefix && !config.enviroment.noPrefix ? config.resourcePrefix.appendURL(config.enviroment.value) : config.enviroment.value;
            } else {
              url = config.enviroment.type && "skybox" === config.enviroment.type ? config.enviroment.value.map(function(e) {
                return config.resourcePrefix && !config.enviroment.noPrefix ? config.resourcePrefix.appendURL(e) : e;
              }) : [key = config.resourcePrefix ? config.resourcePrefix.appendURL(config.enviroment) : config.enviroment, key, key, key, key, key];
            }
          } else {
            url = [key = app.baseURL.appendURL("/images/reflect1.jpg"), key, key, key, key, key];
          }
          material.envMap = url ? this.obj.app.resourceManager.loadCubeTexture(url, function() {
            material.envMapIntensity = 1.5;
            if (wickedGrid.obj) {
              app.needUpdate = true;
            }
          }) : this.obj.app.resourceManager.loadTexture(key, function() {
            material.envMapIntensity = 1.5;
            if (wickedGrid.obj) {
              app.needUpdate = true;
            }
          }, {
            mapping : THREE.EquirectangularReflectionMapping
          });
        } else {
          material.needsUpdate = true;
          material.envMapIntensity = data.envMapIntensity;
          material.envMap = data.envMap;
        }
      }
    }
  }, a.prototype._applyTheme = function(theme, prefix) {
    var that = this;
    if (!this._skipApplyTheme) {
      var texture = this.obj.app;
      if (prefix || this._themeName !== theme) {
        this._themeName = theme || null;
        if (this.isNeedRevertMaterials()) {
          this.revertMaterial();
        } else {
          this._cloneAndModifyMaterial(function(e, t, callGetFunction) {
            that._applyMaterial(e, t, callGetFunction);
          });
        }
        this.removeEdgeWireframe();
        if (null == this._themeName) {
          this._setEffectRefCounts("smallGlow", false);
          this._setEffectRefCounts("middleGlow", false);
        } else {
          this._traverse(function(start) {
            if (start.geometry) {
              var cursor = wl.findStyle(that._themeName, that.obj, start);
              if (cursor) {
                var obj = cursor.style;
                if (obj && (void 0 === obj.enable || obj.enable)) {
                  if (obj.glow) {
                    if (2 == obj.glow) {
                      texture.effectManager.removeEffect(start, "smallGlow");
                      if (start._cachedTechnique && start._cachedTechnique.middleGlow) {
                        texture.effectManager.setEffect(start, "middleGlow", 1, "skip" == start._cachedTechnique.middleGlow);
                      } else {
                        texture.effectManager.removeEffect(start, "middleGlow");
                      }
                    } else {
                      texture.effectManager.setEffect(start, "smallGlow");
                      texture.effectManager.removeEffect(start, "middleGlow");
                    }
                  } else {
                    texture.effectManager.removeEffect(start, "smallGlow");
                    texture.effectManager.removeEffect(start, "middleGlow");
                  }
                  var enable = obj.wireframe.enable;
                  var background = obj.wireframe.color;
                  var a = obj.wireframe.glow;
                  var namedGraph = void 0 !== obj.wireframe.opacity ? obj.wireframe.opacity : .99;
                  if (enable) {
                    that._setEdgeWireframe(start, a, background, namedGraph);
                  }
                }
              }
            }
          });
        }
        if (this.obj.static) {
          this.obj.node._synMatrixWorld();
        }
        texture.needUpdate = true;
      }
    }
  }, a.prototype._getThemeName = function() {
    if (this.obj.isCombinedObject) {
      var elem = this.obj;
      for (; elem && elem.isCombinedObject;) {
        elem = elem.parent;
      }
      return elem.style._themeName;
    }
    return this._themeName;
  }, a.prototype.isNeedRevertMaterials = function() {
    return !this.isNeedCloneMaterials();
  }, a.prototype.isNeedCloneMaterials = function() {
    return !Utils.isNull(this._opacity) || (!Utils.isNull(this._color) || (!Utils.isNull(this._emissive) || (!Utils.isNull(this._highlight) || (!!this._emissiveScrollImage || (!!this._alwaysOnTop || (!!this._wireframe || (!!this._image || (!!this._environmentImage || (!!this._uvAnimationParams || !!this._getThemeName())))))))));
  }, a.prototype.setOpacity = function(value) {
    var me = this;
    var i = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    if (Utils.isNumber(value)) {
      value = THING.Math.clamp(value, 0, 1);
    }
    if (!(Utils.isNull(this._opacity) && Utils.isNull(value))) {
      if (value != this._opacity) {
        if (!(1 == value && Utils.isNull(this._opacity))) {
          this._opacity = value;
          if (this.isNeedRevertMaterials()) {
            this.revertMaterial();
          } else {
            this._cloneAndModifyMaterial(function(e, port, lat2) {
              var i = me._getThemeName();
              var _diff = void 0;
              if (i) {
                var d = wl.findStyle(i, me.obj, lat2);
                if (d && d.style && (void 0 === d.style.enable || d.style.enable)) {
                  _diff = d;
                }
              }
              me._applyMaterialOpacity(e, port, _diff);
            }, i);
          }
          if (this.obj.isCombinedObject) {
            this.obj.node.traverse(function(options) {
              if (options.isEdgeWireframe && options.parent) {
                if (null !== me._opacity && void 0 !== me._opacity) {
                  options.material.opacity = options.material._initOpacity * me._opacity;
                } else {
                  options.material.opacity = options.material._initOpacity;
                }
              }
            });
          } else {
            this._edgeWireframes.forEach(function(cone) {
              if (cone.isObject3D) {
                if (null !== me._opacity && void 0 !== me._opacity) {
                  cone.material.opacity = cone.material._initOpacity * me._opacity;
                } else {
                  cone.material.opacity = cone.material._initOpacity;
                }
                cone.material.transparent = cone.material.opacity < 1;
              }
            });
          }
        }
      }
    }
  }, a.prototype.setColor = function(value) {
    var that = this;
    var i = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    if (value) {
      if (!(value = Utils.parseColor(value))) {
        return;
      }
      this._color = value;
    } else {
      if (!this.color) {
        return;
      }
      this._color = null;
    }
    if (this.isNeedRevertMaterials()) {
      this.revertMaterial();
    } else {
      this._cloneAndModifyMaterial(function(nodeProperties, i, lat2) {
        var port = that._getThemeName();
        var o = void 0;
        if (port) {
          var d = wl.findStyle(port, that.obj, lat2);
          if (d && d.style && (void 0 === d.style.enable || d.style.enable)) {
            o = d;
          }
        }
        that._applyMaterialColor(nodeProperties, i, o);
      }, i);
    }
    if (this.obj.isCombinedObject) {
      this.obj.node.traverse(function(options) {
        if (options.isEdgeWireframe && options.parent) {
          if (null !== that._color && void 0 !== that._color) {
            options.material.color.copy(that._color);
          } else {
            options.material.color.set(options.material._initColor);
          }
        }
      });
    } else {
      this._edgeWireframes.forEach(function(geometry) {
        if (geometry.isObject3D) {
          if (null !== that._color && void 0 !== that._color) {
            geometry.material.color.copy(that._color);
          } else {
            geometry.material.color.set(geometry.material._initColor);
          }
        }
      });
    }
  }, a.prototype.setEmissive = function(val) {
    var _this = this;
    var i = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    if (val) {
      if (!(val = Utils.parseColor(val))) {
        return;
      }
      this._emissive = val;
    } else {
      if (!this.emissive) {
        return;
      }
      this._emissive = null;
    }
    if (this.isNeedRevertMaterials()) {
      this.revertMaterial();
    } else {
      this._cloneAndModifyMaterial(function(backgroundSource, key, lat2) {
        var port = _this._getThemeName();
        var o = void 0;
        if (port) {
          var d = wl.findStyle(port, _this.obj, lat2);
          if (d && d.style && (void 0 === d.style.enable || d.style.enable)) {
            o = d;
          }
        }
        _this._applyMaterialEmissive(backgroundSource, key, o);
      }, i);
    }
  }, a.prototype.setHighlight = function(arg) {
    var self = this;
    var i = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    if (arg) {
      if (!(arg = Utils.parseColor(arg))) {
        return;
      }
      this._highlight = arg;
    } else {
      if (!this.highlight) {
        return;
      }
      this._highlight = null;
    }
    if (this.isNeedRevertMaterials()) {
      this.revertMaterial();
    } else {
      this._cloneAndModifyMaterial(function(uniforms, result, canCreateDiscussions) {
        if (result.highlightColor) {
          if (null !== self._highlight) {
            result.highlightColor.copy(self._highlight);
            result.highlightIntensity = Utils.isNull(self._highlightIntensity) ? .5 : self._highlightIntensity;
          } else {
            if (uniforms.highlightColor) {
              result.highlightColor.copy(uniforms.highlightColor);
            } else {
              result.highlightColor.setRGB(0, 0, 0);
            }
            result.highlightIntensity = 0;
          }
        }
      }, i);
    }
  }, a.prototype.setHighlightIntensity = function(alpha) {
    var post = this;
    var i = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    if (Utils.isNumber(alpha)) {
      alpha = THING.Math.clamp(alpha, 0, 1);
    }
    if (!(Utils.isNull(this._highlightIntensity) && Utils.isNull(alpha))) {
      if (alpha != this._highlightIntensity) {
        if (!(.5 == alpha && Utils.isNull(this._highlightIntensity))) {
          this._highlightIntensity = alpha;
          if (this._highlight) {
            this._cloneAndModifyMaterial(function(canCreateDiscussions, i, isSlidingUp) {
              if (void 0 !== i.highlightIntensity) {
                i.highlightIntensity = Utils.isNull(post._highlightIntensity) ? .5 : post._highlightIntensity;
              }
            }, i);
          }
        }
      }
    }
  }, a.prototype.setEmissiveScrollImage = function(h) {
    var self = this;
    var i = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    if (h) {
      if (h = this.obj.app.confirmURL(h), this._emissiveScrollImage == h) {
        return;
      }
      this._emissiveScrollImage = h;
    } else {
      if (!this._emissiveScrollImage) {
        return;
      }
      this._emissiveScrollImage = null;
    }
    if (this.isNeedRevertMaterials()) {
      this.revertMaterial();
    } else {
      this._cloneAndModifyMaterial(function(localizedSource, signedAuthToken, count) {
        var i = self._getThemeName();
        var column = void 0;
        var stack = void 0;
        if (i) {
          var c = wl.findStyle(i, self.obj, count);
          if (c && c.style && (void 0 === c.style.enable || c.style.enable)) {
            column = c;
            stack = wl.findStyle(i);
          }
        }
        Tl(count, self.obj.node);
        self._applyMaterialEmissiveScrollImage(localizedSource, signedAuthToken, column, stack);
      }, i);
    }
  }, a.prototype.setEnvironmentImage = function(e) {
    var _this = this;
    if (Utils.isString(e) && (e.indexOf(".png") > -1 || e.indexOf(".jpg") > -1)) {
      if (e = this.obj.app.confirmURL(e), this._environmentImage === e) {
        return;
      }
      this._environmentImage = e;
    } else {
      var i = this.obj.app.confirmURL(Utils.parseCubeTextureUrls(e));
      if (i) {
        if (Array.isArray(this._environmentImage) && this._environmentImage[0] === i[0] && this._environmentImage[1] === i[1] && this._environmentImage[2] === i[2] && this._environmentImage[3] === i[3] && this._environmentImage[4] === i[4] && this._environmentImage[5] === i[5]) {
          return;
        }
        this._environmentImage = i;
      } else {
        if (!this._environmentImage) {
          return;
        }
        this._environmentImage = null;
      }
    }
    if (this.isNeedRevertMaterials()) {
      this.revertMaterial();
    } else {
      this._cloneAndModifyMaterial(function(m, key, num) {
        var i = _this._getThemeName();
        var p = void 0;
        var o = void 0;
        if (i) {
          var a = wl.findStyle(i, _this.obj, num);
          if (a && a.style && (void 0 === a.style.enable || a.style.enable)) {
            p = a;
            o = wl.findStyle(i);
          }
        }
        _this._applyMaterialEnvironmentImage(m, key, p, o);
      });
    }
  }, a.prototype.setOutlineColor = function(color) {
    var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    if (Utils.isNull(color)) {
      if (this._outlineColor) {
        this._setEffectRefCounts("outline_0x" + this._outlineColor.getHexString(), false);
        this.obj.node.traverse(function(e) {
          e.layers.disable(1);
          delete e.userData.forceOutline;
        });
        this._outlineColor = null;
      }
      if (this._defaultOutlineColor) {
        this._setEffectRefCounts("outline_0x" + this._defaultOutlineColor.getHexString(), true);
      }
    } else {
      if (this._outlineColor) {
        this._setEffectRefCounts("outline_0x" + this._outlineColor.getHexString(), false);
      }
      color = Utils.parseColor(color);
      this._outlineColor = color;
      this._setEffectRefCounts("outline_0x" + color.getHexString(), true);
      if (t) {
        this.obj.node.ensureParentsVisible(true);
        this.obj.node.visible = true;
      }
      this.obj.node.traverse(function(item) {
        if (t || item.ensureVisible()) {
          if (!item.isSprite) {
            item.layers.enable(1);
            if (t) {
              item.visible = true;
              item.userData.forceOutline = true;
            }
          }
        }
      });
    }
    this.obj.app.needEffectUpdate = true;
  }, a.prototype.setDefaultOutlineColor = function(arg) {
    var c = Utils.parseColor(arg);
    if (c) {
      this._defaultOutlineColor = c;
      if (!this.outlineColor) {
        this._setEffectRefCounts("outline_0x" + c.getHexString(), true);
      }
      this.obj.app.needEffectUpdate = true;
    } else {
      this._defaultOutlineColor = null;
      this._clearAllOutlineColor();
      if (this._outlineColor) {
        this.outlineColor = this._outlineColor;
      }
    }
  }, a.prototype.setSkipBoundingBox = function(e) {
    this.obj.dirty = true;
    this.obj.node.skipBoundingBox(e);
    this.obj.parents.forEach(function(res) {
      res.boundingBoxControl.dirty = true;
    });
    this.obj.dirty = true;
  }, a.prototype._setNodesAttribute = function(key, newKey) {
    var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    this._traverse(function(c) {
      if (!(!c.isRenderable() && i)) {
        c.userData[key] = newKey;
      }
    });
  }, a.prototype._setAlwaysOnTop = function(value) {
    var unconditional = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    if ((this.alwaysOnTop != value || unconditional) && this.obj.node.parent) {
      if (this._alwaysOnTop = value, value) {
        this._cloneAndModifyMaterial(function(canCreateDiscussions, materialFrom, i) {
          materialFrom.transparent = true;
        });
        Utils.backupValue(this.obj.node, "parent");
        var wheelAxisMat = new THREE.MeshStandardMaterial({
          transparent : true,
          opacity : 1e-4
        });
        var me = new THREE.Mesh(new THREE.Geometry, wheelAxisMat);
        me.name = "AlwaysOnTopRootMesh";
        me.frustumCulled = false;
        me.renderOrder = THING.BaseStyle.cRenderOrderValueMask - 1;
        me.onAfterRender = function(options) {
          if ("GBuffer" !== options.materialManager.getMode()) {
            options.clearDepth();
          }
        };
        this.obj.node.parent.add(me);
        this.obj.node.attachToParent(me, this.obj.app.scene, true);
        this._traverse(function(a) {
          a.renderOrder += THING.BaseStyle.cRenderOrderValueMask;
        });
      } else {
        if (this.isNeedRevertMaterials()) {
          this.revertMaterial();
        } else {
          this._changeMaterial(function(e, canCreateDiscussions) {
            return Utils.revertValue(e, "transparent"), e;
          });
        }
        var parentScope = Utils.getValue(this.obj.node, "parent", true);
        if (parentScope) {
          var serviceslayer = this.obj.node.parent;
          serviceslayer.removeBySelf();
          parentScope.add(this.obj.node);
          this._traverse(function(a) {
            a.renderOrder -= THING.BaseStyle.cRenderOrderValueMask;
          });
        }
      }
    }
  }, a.prototype.setAlwaysOnTop = function(value) {
    if (!this._setSynValue("alwaysOnTop", value)) {
      this._setAlwaysOnTop(value);
    }
  }, a.prototype.setBoundingBox = function(visible, value) {
    if (visible) {
      if (!this._boundingBoxNode) {
        this.obj.dirty = true;
        var PSV_FOV_MAX = this.obj.getLocalBoundingBox().toBox();
        this._boundingBoxNode = new THREE.Box3Helper(PSV_FOV_MAX, 16777215);
        this._boundingBoxNode.frustumCulled = false;
        this._boundingBoxNode.name = this.obj.name + "_BoundingBox";
        this._boundingBoxNode.skipBoundingBox(true);
      }
      this._boundingBoxNode.material.color = Utils.parseColor(value);
      this.obj.node.add(this._boundingBoxNode);
      this._boundingBoxNode.updateMatrixWorld();
      this.obj.tickable = true;
    } else {
      this.obj.app.resourceManager.remove(this._boundingBoxNode);
      this._boundingBoxNode = null;
    }
    if (this._boundingBoxNode) {
      this._boundingBoxNode.visible = visible;
    }
  }, a.prototype.setOrientedBoundingBox = function(isVisible, value) {
    if (isVisible) {
      if (!this._orientedBoundingBoxNode) {
        this.obj.dirty = true;
        var PSV_FOV_MAX = this.obj.getLocalBoundingBox().toBox();
        this._orientedBoundingBoxNode = new THREE.Box3Helper(PSV_FOV_MAX, 16777215);
        this._orientedBoundingBoxNode.frustumCulled = false;
        this._orientedBoundingBoxNode.name = this.obj.name + "_OrientedBoundingBox";
        this._orientedBoundingBoxNode.skipBoundingBox(true);
      }
      var entry = this._orientedBoundingBoxNode.material;
      entry.color = Utils.parseColor(value, entry.color);
      this.obj.node.add(this._orientedBoundingBoxNode);
      this._orientedBoundingBoxNode.updateMatrixWorld();
      this.obj.tickable = true;
    } else {
      this.obj.app.resourceManager.remove(this._orientedBoundingBoxNode);
      this._orientedBoundingBoxNode = null;
    }
    if (this._orientedBoundingBoxNode) {
      this._orientedBoundingBoxNode.visible = isVisible;
    }
  }, a.prototype.setVertexNormalHelper = function(boundsMethod) {
    if (boundsMethod) {
      this.obj.node.updateMatrixWorld();
      var inv_matrix = new THREE.Matrix4;
      inv_matrix.getInverse(this.obj.node.matrixWorld);
      this._vertexNormalNode = new THREE.Group;
      this._vertexNormalNode.name = this.obj.name + "_VertexNormal";
      this._vertexNormalNode.applyMatrix4(inv_matrix);
      var TrackSearchIndex = this;
      this.obj.node.traverse(function(child) {
        if (child.isMesh && child.geometry) {
          var tag = new THREE.VertexNormalsHelper(child, 1, 16711680);
          TrackSearchIndex._vertexNormalNode.add(tag);
        }
      });
      this.obj.node.add(this._vertexNormalNode);
    } else {
      this.obj.app.resourceManager.remove(this._vertexNormalNode);
      this._vertexNormalNode = null;
    }
  }, a.prototype.setAxisHelper = function(boundsMethod) {
    if (boundsMethod != this.axisHelper) {
      if (boundsMethod) {
        this._axisNode = new THREE.AxesHelper(this.obj.boundingBox.radius);
        this._axisNode.name = this.obj.name + "_Axis";
        var material = this._axisNode.material;
        material.depthTest = false;
        material.transparent = true;
        var globalBonePosition = new THREE.Vector3;
        this.obj.node.getWorldScale(globalBonePosition);
        this._axisNode.scale.set(1 / globalBonePosition.x, 1 / globalBonePosition.y, 1 / globalBonePosition.z);
        this._axisNode.skipBoundingBox(true);
        this.obj.node.add(this._axisNode);
      } else {
        this.obj.app.resourceManager.remove(this._axisNode);
        this._axisNode = null;
      }
    }
  }, a.prototype._setEffectRefCounts = function(name, t, i) {
    var queue = this.obj.app.effectManager;
    if (t) {
      this._traverse(function(object) {
        if (!(object.userData && object.userData.skipOutline && name.indexOf("outline") > -1 || object.isLineSegments)) {
          queue.setEffect(object, name);
        }
      });
    } else {
      this._traverse(function(effect) {
        if (!i && effect._cachedTechnique && effect._cachedTechnique[name]) {
          queue.setEffect(effect, name, 1, "skip" == effect._cachedTechnique[name]);
        } else {
          queue.removeEffect(effect, name);
        }
      });
    }
  }, a.prototype._clearAllOutlineColor = function() {
    var queue = this.obj.app.effectManager;
    this._traverse(function(effect) {
      if (effect.technique) {
        var i;
        for (i in effect.technique) {
          if (effect.technique[i] && i.indexOf("outline") > -1) {
            queue.removeEffect(effect, i);
          }
        }
      }
    });
  }, a.prototype.setGlow = function(e) {
    var NINETY_EIGHT_HOURS = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    this._glow = e;
    this._setEffectRefCounts("middleGlow", e, NINETY_EIGHT_HOURS);
  }, a.prototype.setInnerGlow = function(e, t) {
    this._innerGlow = e;
    this._setEffectRefCounts("innerGlow", e, t);
  }, a.prototype.setLineBloom = function(tResult) {
    this._lineBloom = tResult;
    this._setEffectRefCounts("lineBloom", tResult);
  }, a.prototype.setRadialBlur = function(tResult) {
    this._lineBloom = tResult;
    this._setEffectRefCounts("radialBlur", tResult);
  }, a.prototype.setRadialBlur2 = function(tResult) {
    this._lineBloom = tResult;
    this._setEffectRefCounts("radialBlur2", tResult);
  }, a.prototype.setRadialOffset = function(tResult) {
    this._lineBloom = tResult;
    this._setEffectRefCounts("radialOffset", tResult);
  }, a.prototype.setFocusRegion = function(tResult) {
    this._focusRegion = tResult;
    this._setEffectRefCounts("focusRegion", tResult);
  }, a.prototype.setEdgeWireframe = function(arg) {
    var harvestContext = this;
    var i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    var r_objects = arguments[2];
    this._edgeColor = Utils.parseColor(arg);
    this.removeEdgeWireframe();
    if (null != arg) {
      this._traverse(function(switchTextDiv) {
        harvestContext._setEdgeWireframe(switchTextDiv, i, harvestContext._edgeColor, r_objects);
      });
    }
  }, a.prototype._setEdgeWireframe = function(s, a, i) {
    var n = this;
    var p = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
    s.updateMatrixWorld();
    var geometry = this.obj.app.edgesGeometriesManager.getByObject(s, this.obj);
    if (null !== geometry) {
      if (geometry.isBufferGeometry) {
        this._createEdgeWireframe(geometry, i, a, p, s);
      } else {
        var self = geometry.then(function(point) {
          if (!self._break) {
            n._createEdgeWireframe(point, i, a, p, s);
          }
        });
        self.catch(function(e) {
          if (1 === e.code) {
            THING.Utils.warn(e.msg);
          } else {
            if (0 !== e.code) {
              THING.Utils.warn(e);
            }
          }
        });
        this._edgeWireframes.set(s, self);
      }
    }
  }, a.prototype._createEdgeWireframe = function(geom, data, i, t, a) {
    var s = new THREE.LineSegments(geom);
    return geom.isInstancedBufferGeometry && (s.material = new THREE.MeshBasicMaterial({}), s.material.defines = s.material.defines || {}, s.material.defines.INSTANCED = "", s.frustumCulled = false), s.name = "wireframeNode" + data + i, s.userData.skipStyle = true, s.renderOrder = a.renderOrder + .01, s.isEdgeWireframe = true, s.scope = this.obj, this._edgeWireframes.set(a, s), a.add(s), this.obj.static && this.obj.node._synMatrixWorld(), s.material._initColor = data, null !== this._color && void 0 !== 
    this._color ? s.material.color.copy(this._color) : s.material.color.set(data), s.material._initOpacity = t, null !== this._opacity && void 0 !== this._opacity ? s.material.opacity = t * this._opacity : s.material.opacity = t, s.material.transparent = s.material.opacity < 1, i ? this.obj.app.effectManager.setEffect(s, "smallGlow") : this.obj.app.effectManager.removeEffect(s, "smallGlow"), s;
  }, a.prototype.removeEdgeWireframe = function() {
    var request = this;
    this._edgeWireframes.forEach(function(self) {
      if (self.isObject3D) {
        request.obj.app.effectManager.clearAllEffects(self);
        request.obj.app.resourceManager.remove(self);
      } else {
        self._break = true;
      }
    });
    this._edgeWireframes.clear();
  }, a.prototype.setImage = function(image) {
    var listener = this;
    if (image) {
      if (Utils.isString(image)) {
        var newImage = this.obj.app.confirmURL(image);
        if (this.image == newImage) {
          return;
        }
        this._image = newImage;
      } else {
        if (image.width && image.height) {
          if (this.image == image) {
            return;
          }
          this._image = image;
        }
      }
      if (!this._image) {
        return;
      }
    } else {
      if (!this.image) {
        return;
      }
      this._image = "";
    }
    if (this.isNeedRevertMaterials()) {
      this.revertMaterial();
    } else {
      this._cloneAndModifyMaterial(function(task, result, num) {
        var i = listener._getThemeName();
        var data = void 0;
        var group = void 0;
        if (i) {
          var a = wl.findStyle(i, listener.obj, num);
          if (a && a.style && (void 0 === a.style.enable || a.style.enable)) {
            data = a;
            group = wl.findStyle(i);
          }
        }
        listener._applyMaterialImage(task, result, data, group);
        listener._applyMaterialEmissive(task, result, data);
      });
    }
  }, a.prototype.flipOutlineColor = function(value) {
    value = Utils.parseColor(value).getHex();
    var attr = this.outlineColor;
    this.outlineColor = attr && attr == value ? null : value;
  }, a.prototype.setLightMap = function(options) {
    var progress = (options = options || {}).intensity || 0;
    var srcFile2 = Utils.parseColor(options.color, new THREE.Color);
    var image = options.image;
    if (image) {
      image = this.obj.app.resourceManager.loadTexture(this.obj.app.confirmURL(image), void 0, {
        anisotropy : 16
      });
    }
    this._changeMaterial(function(material, n) {
      material.lightMap = image;
      material.lightMapIntensity = progress;
      material.color.copy(srcFile2);
      material.needsUpdate = true;
    });
  }, a.prototype.setMaterial = function(json) {
    var artistTrack = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    var res = this;
    if (json) {
      var do_bookmark = function() {
        if (!(json.completeWaitNumber > 0 && --json.completeWaitNumber)) {
          if (json.complete) {
            json.complete({
              object : res.obj
            });
          }
          if (res.obj) {
            res.obj.app.needUpdate = true;
          }
        }
      };
      var init = function(data, name, opts) {
        opts = opts || {};
        var options = Utils.isString(opts) ? opts : opts.url;
        if (options) {
          json.completeWaitNumber++;
          var texture = (new THREE.TextureLoader).load(res.obj.app.confirmURL(options), function() {
            do_bookmark();
          });
          if (texture.anisotropy = 16, RepeatWrapping = Utils.parseWrapType(opts.wrap || opts.wrapType)) {
            texture.wrapT = RepeatWrapping;
            texture.wrapS = RepeatWrapping;
          } else {
            var options = data[name];
            if (options) {
              texture.wrapT = options.wrapT;
              texture.wrapS = options.wrapS;
            }
          }
          if ("emissiveMap" === name) {
            texture.premultiplyAlpha = true;
          }
          data[name] = texture;
        } else {
          if (null === options) {
            data[name] = null;
          }
        }
        var RepeatWrapping;
        var texture = opts.texture;
        if (texture) {
          data[name] = texture;
          if (RepeatWrapping = Utils.parseWrapType(opts.wrap || opts.wrapType)) {
            texture.wrapT = RepeatWrapping;
            texture.wrapS = RepeatWrapping;
          }
        } else {
          if (null === texture) {
            data[name] = null;
          }
        }
      };
      var update = function(options, json) {
        var srcFile2 = Utils.parseColor(json.color);
        if (srcFile2) {
          options.color.copy(srcFile2);
        }
        var data = json.image;
        if (data) {
          json.completeWaitNumber++;
          var loader = new THREE.TextureLoader;
          loader.setCrossOrigin("anonymous");
          (data = loader.load(res.obj.app.confirmURL(data), function() {
            do_bookmark();
          })).anisotropy = 16;
          var value = Utils.parseWrapType(json.wrap || json.wrapType);
          if (value) {
            data.wrapT = value;
            data.wrapS = value;
          } else {
            var model = options.map;
            if (model) {
              data.wrapT = model.wrapT;
              data.wrapS = model.wrapS;
            }
          }
          options.map = data;
        } else {
          if (null === data) {
            options.map = null;
          }
        }
        var val = json.map;
        if (val) {
          options.map = val;
        } else {
          if (null === val) {
            options.map = null;
          }
        }
        init(options, "map", json.diffuseMap);
        init(options, "emissiveMap", json.emissiveMap);
        init(options, "roughnessMap", json.roughnessMap);
        init(options, "roughnessMap", json.roughnessMap);
        init(options, "roughnessMap", json.roughnessMap);
        init(options, "lightMap", json.lightMap);
        init(options, "bumpMap", json.bumpMap);
        init(options, "aoMap", json.aoMap);
        init(options, "alphaMap", json.alphaMap);
        init(options, "displacementMap", json.displacementMap);
        var n = json.envMap;
        if (n) {
          options.envMap = res.obj.app.resourceManager.loadCubeTexture(n, function() {
            if (res.obj) {
              res.obj.app.needUpdate = true;
            }
          });
        } else {
          if (null === n) {
            options.envMap = null;
          }
        }
        options.envMapIntensity = Utils.parseValue(json.envMapIntensity, options.envMapIntensity);
        var _hasAlpha = json.doubleSide;
        if (void 0 !== _hasAlpha) {
          options.side = _hasAlpha ? THREE.DoubleSide : THREE.FrontSide;
        }
        options.blending = Utils.parseBlendingType(json.blending, options.blending);
        options.transparent = Utils.parseValue(json.transparent, options.transparent);
        options.opacity = Utils.parseValue(json.opacity, options.opacity);
        var valueChange = Utils.parseColor(json.emissive);
        if (options.emissive && valueChange) {
          options.emissive.copy(valueChange);
        }
        options.metalness = Utils.parseValue(json.metalness, options.metalness);
        options.roughness = Utils.parseValue(json.roughness, options.roughness);
        options.depthWrite = Utils.parseValue(json.depthWrite, options.depthWrite);
        options.depthTest = Utils.parseValue(json.depthTest, options.depthTest);
        options.needsUpdate = true;
      };
      json.completeWaitNumber = 0;
      var c = json.index;
      this._cloneAndModifyMaterial(function(canCreateDiscussions, i, dataType) {
        if (!(c && Utils.isArray(dataType.material) && dataType.material.indexOf(i) !== c)) {
          update(i, json);
        }
      }, artistTrack);
      this._processWithChildFunction("setMaterial", json);
    } else {
      this.revertMaterial();
    }
  }, a.prototype.setPolygonOffset = function(parameters) {
    parameters = parameters || {};
    var value = Utils.parseValue(parameters.polygonOffset, false);
    var dscr = Utils.parseValue(parameters.polygonOffsetFactor, 0);
    var _units = Utils.parseValue(parameters.polygonOffsetUnits, 0);
    this._changeMaterial(function(parameters, n) {
      return parameters.polygonOffset = value, parameters.polygonOffsetFactor = dscr, parameters.polygonOffsetUnits = _units, parameters;
    });
  }, a.prototype.setWireframe = function(is_wireframe) {
    var artistTrack = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    this._wireframe = is_wireframe;
    if (is_wireframe) {
      this._cloneAndModifyMaterial(function(canCreateDiscussions, m, i) {
        Utils.backupValue(m, "wireframe");
        Utils.backupValue(m, "map");
        m.wireframe = true;
        m.map = null;
        m.needsUpdate = true;
      }, artistTrack);
    } else {
      if (this.isNeedRevertMaterials()) {
        this.revertMaterial();
      } else {
        this._changeMaterial(function(e, canCreateDiscussions) {
          return Utils.revertValue(e, "wireframe"), Utils.revertValue(e, "map"), e.needsUpdate = true, e;
        });
      }
    }
  }, a.prototype.setRenderOrder = function(y) {
    var i = this;
    this._renderOrder = y || 0;
    if (this.beforeSetRenderOrder) {
      this.beforeSetRenderOrder(y);
    }
    this.obj._traverseSelfNodes(function(me) {
      if (!me.isGroup) {
        if (i._alwaysOnTop) {
          me.renderOrder = a.cRenderOrderValueMask + y;
        } else {
          if ("model-wall" === me._cls) {
            me.renderOrder = y + 1e-5;
          } else {
            if (me.isEdgeWireframe) {
              me.renderOrder = y + .01;
            } else {
              me.renderOrder = y;
            }
          }
        }
      }
    });
    this.obj.children.forEach(function(a) {
      if (!a.skipStyle) {
        if (a.inheritStyle) {
          a.style.renderOrder = y;
        }
      }
    });
  }, a.prototype._setTextureUVAnimation = function(value) {
    var coverageFilter = this;
    Utils.setValue(value, "updateMatrix", function() {
      var val = coverageFilter._uvAnimationParams;
      var r = val.repeat || [1, 1];
      var n = val.center || [0, 0];
      var o = val.offset || [0, 0];
      var artistTrack = Utils.parseValue(val.rotation, 0);
      value.matrix.setUvTransform(o[0], o[1], r[0], r[1], artistTrack, n[0], n[1]);
    }, true);
  }, a.prototype.setUVAnimation = function(canCreateDiscussions) {
    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    if (this._uvAnimationParams = canCreateDiscussions, this._uvAnimationParams) {
      if (t) {
        this._cloneAndModifyMaterial(function() {
        });
      }
      var options = this._uvAnimationParams;
      options.wrapType = Utils.parseWrapType(options.wrapType);
      options.offset = options.offset || [0, 0];
      options.baseOffset = options.offset.concat();
      var value = Utils.parseValue(options.rotation, 0);
      options.baseRotation = value;
      options.rotation = 0;
      options.offsetSpeed = options.speed || options.offsetSpeed;
      if (Utils.isNumber(options.offsetSpeed)) {
        options.offsetSpeed = [options.offsetSpeed, options.offsetSpeed];
      }
      var method = options.rotationSpeed || options.rotateSpeed;
      if (method) {
        options.rotationSpeed = method;
      }
      if (value || method) {
        options.center = [.5, .5];
      }
      options.animation = Utils.parseValue(options.animation, true);
      var tempEventQueue = this;
      var listener = this.obj.getControl("texAnimControl");
      this.obj.node.traverseTextures(function(data, n, event) {
        if ("envMap" != n && "colorMapping" != n) {
          if (!(listener && listener.$hasAnimation(event))) {
            if (!event.__cloned) {
              (event = event.clone()).__cloned = true;
              data[n] = event;
              event.needsUpdate = true;
            }
            if (options.wrapType) {
              Utils.setValue(event, "wrapS", options.wrapType);
              Utils.setValue(event, "wrapT", options.wrapType);
            }
            tempEventQueue._setTextureUVAnimation(event);
          }
        }
      });
      this.obj.tickable = true;
    } else {
      this.obj.node.traverseTextures(function(canCreateDiscussions, isSlidingUp, i) {
        Utils.revertValue(i, "wrapS");
        Utils.revertValue(i, "wrapT");
        Utils.revertValue(i, "updateMatrix");
      });
      this.revertMaterial();
    }
  }, a.prototype.getUVAnimation = function() {
    return this._uvAnimationParams;
  }, a.prototype.hasUVAnimation = function() {
    return !!this._uvAnimationParams;
  }, a.prototype.update = function(d) {
    var a = this._uvAnimationParams;
    if (a) {
      if (!a.animation) {
        return false;
      }
      var cx = a.baseOffset;
      var v1 = a.offsetSpeed;
      if (cx && v1) {
        a.offset[0] += cx[0] + d * v1[0];
        a.offset[1] += cx[1] + d * v1[1];
      }
      var h = a.baseRotation;
      var i = a.rotationSpeed;
      return i && (a.rotation += h + d * i), true;
    }
    return false;
  }, a.prototype._getStyleValue = function(name) {
    var versionByName = this._getSynValue(name);
    return versionByName || this["_" + name];
  }, a.prototype._getStyleColorValue = function(name) {
    var value = this._getStyleValue(name);
    return value ? Utils.parseColor(value).toHexString() : null;
  }, a.prototype._processAppUpdate = function() {
    var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    if (this.obj.visible) {
      var texture = this.obj.app;
      if (e) {
        texture.needUpdate = true;
      } else {
        if (texture.rendererManager) {
          texture.rendererManager.needUpdate = true;
        }
      }
    }
  }, a.prototype._processWithValue = function(e, name, val) {
    var artistTrack = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
    e.call(this, val);
    var encrypted_fields = this.obj.onReplaceObejcts && this.obj.onReplaceObejcts(name, val);
    if (encrypted_fields && encrypted_fields.length > 0) {
      var i = 0;
      var patchLen = encrypted_fields.length;
      for (; i < patchLen; i++) {
        var field = encrypted_fields[i];
        if (field.onProcessStyleValue && !field.onProcessStyleValue(name, val)) {
          return;
        }
        field.style[name] = val;
      }
    } else {
      this.obj.children.forEach(function(options) {
        if (options.inheritStyle) {
          if (options.onProcessStyleValue && !options.onProcessStyleValue(name, val)) {
            return;
          }
          options.style[name] = val;
        }
      });
    }
    this._processAppUpdate(artistTrack);
  }, a.prototype._processWithChildFunction = function(name, module) {
    var i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
    this.obj.children.forEach(function(options) {
      if (options.inheritStyle) {
        var parent = options.style[name];
        if (Utils.isFunction(parent)) {
          parent.call(options.style, module);
        }
      }
    });
    this._processAppUpdate(i);
  }, a.prototype.isBaseStyle = function() {
    return true;
  }, n(a, [{
    key : "renderOrder",
    set : function(v) {
      if (!this._setSynValue("renderOrder", v)) {
        this._processWithValue(this.setRenderOrder, "renderOrder", v);
      }
    },
    get : function() {
      return this._getStyleValue("renderOrder");
    }
  }, {
    key : "wireframe",
    set : function(v) {
      if (!this._setSynValue("wireframe", v)) {
        this._processWithValue(this.setWireframe, "wireframe", v, false);
      }
    },
    get : function() {
      return this._getStyleValue("wireframe");
    }
  }, {
    key : "opacity",
    set : function(v) {
      if (!this._setSynValue("opacity", v)) {
        this._processWithValue(this.setOpacity, "opacity", v);
      }
    },
    get : function() {
      var val = this._getStyleValue("opacity");
      return Utils.isNull(val) ? 1 : val;
    }
  }, {
    key : "color",
    set : function(v) {
      if (!this._setSynValue("color", v)) {
        this._processWithValue(this.setColor, "color", v, false);
      }
    },
    get : function() {
      return this._getStyleColorValue("color");
    }
  }, {
    key : "emissive",
    set : function(v) {
      if (!this._setSynValue("emissive", v)) {
        this._processWithValue(this.setEmissive, "emissive", v, false);
      }
    },
    get : function() {
      return this._getStyleColorValue("emissive");
    }
  }, {
    key : "highlight",
    set : function(v) {
      if (!this._setSynValue("highlight", v)) {
        this._processWithValue(this.setHighlight, "highlight", v, false);
      }
    },
    get : function() {
      return this._getStyleColorValue("highlight");
    }
  }, {
    key : "highlightIntensity",
    set : function(v) {
      if (!this._setSynValue("highlightIntensity", v)) {
        this._processWithValue(this.setHighlightIntensity, "highlightIntensity", v);
      }
    },
    get : function() {
      var val = this._getStyleValue("highlightIntensity");
      return Utils.isNull(val) ? .5 : val;
    }
  }, {
    key : "emissiveScrollImage",
    set : function(v) {
      if (!this._setSynValue("emissiveScrollImage", v)) {
        this._processWithValue(this.setEmissiveScrollImage, "emissiveScrollImage", v, false);
      }
    },
    get : function() {
      return this._getStyleValue("emissiveScrollImage");
    }
  }, {
    key : "environmentImage",
    set : function(v) {
      if (!this._setSynValue("environmentImage", v)) {
        this._processWithValue(this.setEnvironmentImage, "environmentImage", v, false);
      }
    },
    get : function() {
      return this._getStyleValue("environmentImage");
    }
  }, {
    key : "roughness",
    set : function(v) {
      this.setMaterial({
        roughness : v
      });
    }
  }, {
    key : "metalness",
    set : function(v) {
      this.setMaterial({
        metalness : v
      });
    }
  }, {
    key : "outlineColor",
    set : function(v) {
      if (!this._setSynValue("outlineColor", v)) {
        this._processWithValue(this.setOutlineColor, "outlineColor", v, false);
      }
    },
    get : function() {
      return this._getStyleColorValue("outlineColor");
    }
  }, {
    key : "defaultOutlineColor",
    set : function(v) {
      this._processWithValue(this.setDefaultOutlineColor, "defaultOutlineColor", v, false);
    },
    get : function() {
      return this._getStyleColorValue("defaultOutlineColor");
    }
  }, {
    key : "skipBoundingBox",
    set : function(v) {
      this.setSkipBoundingBox(v);
    }
  }, {
    key : "skipOutline",
    set : function(value) {
      this._setNodesAttribute("skipOutline", value, true);
      if (value) {
        this._outlineColor = null;
        this._defaultOutlineColor = null;
        this._clearAllOutlineColor();
      }
    }
  }, {
    key : "skipStyle",
    set : function(v) {
      this.obj.node.traverse(function(label) {
        if (label.isRenderable()) {
          label.userData.skipStyle = v;
        }
      });
    }
  }, {
    key : "skipEnvMap",
    set : function(value) {
      this._setNodesAttribute("skipEnvMap", value);
    }
  }, {
    key : "glow",
    set : function(v) {
      this._processWithValue(this.setGlow, "glow", v, false);
    },
    get : function() {
      return this._getStyleValue("glow");
    }
  }, {
    key : "innerGlow",
    set : function(v) {
      this._processWithValue(this.setInnerGlow, "innerGlow", v, false);
    },
    get : function() {
      return this._getStyleValue("innerGlow");
    }
  }, {
    key : "lineBloom",
    set : function(v) {
      this._processWithValue(this.setLineBloom, "lineBloom", v, false);
    },
    get : function() {
      return this._getStyleValue("lineBloom");
    }
  }, {
    key : "radialBlur",
    set : function(v) {
      this._processWithValue(this.setRadialBlur, "radialBlur", v, false);
    },
    get : function() {
      return this._getStyleValue("radialBlur");
    }
  }, {
    key : "radialBlur2",
    set : function(v) {
      this._processWithValue(this.setRadialBlur2, "radialBlur2", v, false);
    },
    get : function() {
      return this._getStyleValue("radialBlur2");
    }
  }, {
    key : "radialOffset",
    set : function(v) {
      this._processWithValue(this.setRadialOffset, "radialOffset", v, false);
    },
    get : function() {
      return this._getStyleValue("radialOffset");
    }
  }, {
    key : "focusRegion",
    set : function(v) {
      this._processWithValue(this.setFocusRegion, "focusRegion", v, false);
    },
    get : function() {
      return this._getStyleValue("focusRegion");
    }
  }, {
    key : "vertexNormalHelper",
    set : function(v) {
      this._processWithValue(this.setVertexNormalHelper, "vertexNormalHelper", v);
    },
    get : function() {
      return this._getStyleValue("vertexNormalHelper");
    }
  }, {
    key : "axisHelper",
    set : function(v) {
      this._processWithValue(this.setAxisHelper, "axisHelper", v);
    },
    get : function() {
      return !!this._axisNode && this._axisNode.visible;
    }
  }, {
    key : "edgeColor",
    set : function(v) {
      this._processWithValue(this.setEdgeWireframe, "edgeColor", v, false);
    },
    get : function() {
      return this._getStyleColorValue("edgeColor");
    }
  }, {
    key : "boundingBox",
    set : function(value) {
      this.setBoundingBox(value, 16777215);
    },
    get : function() {
      return !!this._boundingBoxNode && this._boundingBoxNode.visible;
    }
  }, {
    key : "boundingBoxColor",
    set : function(num) {
      this.setBoundingBox(true, num);
    },
    get : function() {
      return this._boundingBoxNode ? this._boundingBoxNode.material.color.toHexString() : 0;
    }
  }, {
    key : "orientedBoundingBox",
    set : function(v) {
      this.setOrientedBoundingBox(v);
    },
    get : function() {
      return !!this._orientedBoundingBoxNode && this._orientedBoundingBoxNode.visible;
    }
  }, {
    key : "orientedBoundingBoxColor",
    set : function(num) {
      this.setOrientedBoundingBox(true, num);
    },
    get : function() {
      return this._orientedBoundingBoxNode ? this._orientedBoundingBoxNode.material.color.toHexString() : 0;
    }
  }, {
    key : "alwaysOnTop",
    set : function(num) {
      this.setAlwaysOnTop(num);
    },
    get : function() {
      return !!this._getStyleValue("alwaysOnTop");
    }
  }, {
    key : "image",
    set : function(v) {
      this.setImage(v);
    },
    get : function() {
      return this._getStyleValue("image");
    }
  }, {
    key : "doubleSide",
    set : function(v) {
      this._doubleSide = v;
      this.setMaterial({
        doubleSide : v
      });
    },
    get : function() {
      return this._getStyleValue("doubleSide");
    }
  }]), a;
}();
Ml.cRenderOrderValueMask = 1e6;
var Cl = new THREE.Matrix3;
var Sl = false;
function jl() {
  Cl.elements[7] -= .003;
}
var Pl = function(e) {
  function t(row) {
    return r(this, t), s(this, e.call(this, row));
  }
  return o(t, e), t;
}(Ml);
Rl = function(t) {
  function e(row) {
    r(this, e);
    var context = s(this, t.call(this, row));
    return context._textColor = Utils.parseColor("#1e90ff"), context._textSize = 26, context._textLineWidth = 65536, context._textLineHeight = 20, context._textType = "Arial", context._textAlign = "center", context._dropShadow = true, context._dropShadowAlpha = 1, context._dropShadowAngle = 45, context._dropShadowBlur = 1, context._dropShadowColor = Utils.parseColor("#000000"), context._dropShadowDistance = 2, context._strokeMode = false, context._skipApplyTheme = true, context;
  }
  return o(e, t), n(e, [{
    key : "scale",
    get : function() {
      return this._scale;
    }
  }, {
    key : "fontColor",
    set : function(v) {
      var color = Utils.parseColor(v);
      if (!color.equals(this._textColor)) {
        this._textColor = color;
        this.obj.refreshTextMesh();
      }
    },
    get : function() {
      return this._textColor.toHexString();
    }
  }, {
    key : "fontSize",
    set : function(value) {
      if (value && this._textSize != value) {
        this._scale = value / 26;
        this._textSize = value;
        this.obj.refreshTextMesh();
      }
    },
    get : function() {
      return this._textSize;
    }
  }, {
    key : "fontType",
    set : function(v) {
      if (this._textType != v) {
        this._textType = v;
        this.obj.refreshTextMesh();
      }
    },
    get : function() {
      return this._textType;
    }
  }, {
    key : "fontAlign",
    set : function(value) {
      if (this._textAlign != value) {
        this._textAlign = value;
        this.obj.refreshTextMesh();
      }
    },
    get : function() {
      return this._textAlign;
    }
  }, {
    key : "dropShadow",
    set : function(value) {
      if (this._dropShadow != value) {
        this._dropShadow = value;
        this.obj.refreshTextMesh();
      }
    },
    get : function() {
      return this._dropShadow;
    }
  }, {
    key : "dropShadowAlpha",
    set : function(v) {
      if (this._dropShadowAlpha != v) {
        this._dropShadowAlpha = v;
        this.obj.refreshTextMesh();
      }
    },
    get : function() {
      return this._dropShadowAlpha;
    }
  }, {
    key : "dropShadowAngle",
    set : function(v) {
      if (this._dropShadowAngle != v) {
        this._dropShadowAngle = v;
        this.obj.refreshTextMesh();
      }
    },
    get : function() {
      return this._dropShadowAngle;
    }
  }, {
    key : "dropShadowBlur",
    set : function(v) {
      if (this._dropShadowBlur != v) {
        this._dropShadowBlur = v;
        this.obj.refreshTextMesh();
      }
    },
    get : function() {
      return this._dropShadowBlur;
    }
  }, {
    key : "dropShadowColor",
    set : function(v) {
      var version = Utils.parseColor(v);
      if (!version.equals(this._dropShadowBlur)) {
        this._dropShadowColor = version;
        this.obj.refreshTextMesh();
      }
    },
    get : function() {
      return this._dropShadowColor.toHexString();
    }
  }, {
    key : "dropShadowDistance",
    set : function(v) {
      if (this._dropShadowDistance != v) {
        this._dropShadowDistance = v;
        this.obj.refreshTextMesh();
      }
    },
    get : function() {
      return this._dropShadowDistance;
    }
  }, {
    key : "textLineWidth",
    set : function(v) {
      if (this._textLineWidth != v) {
        this._textLineWidth = v;
        this.obj.refreshTextMesh();
      }
    },
    get : function() {
      return this._textLineWidth;
    }
  }, {
    key : "textLineHeight",
    set : function(v) {
      if (this._textLineHeight != v) {
        this._textLineHeight = v;
        this.obj.refreshTextMesh();
      }
    },
    get : function() {
      return this._textLineHeight;
    }
  }, {
    key : "strokeMode",
    set : function(v) {
      if (this._strokeMode != v) {
        this._strokeMode = v;
        this.obj.refreshTextMesh();
      }
    },
    get : function() {
      return this._strokeMode;
    }
  }]), e;
}(Pl);
Dl = function(callback) {
  function d(row) {
    r(this, d);
    var that = s(this, callback.call(this, row));
    return that._canvasText = new Re, that._text = "", that._factor = 16 / 26 * .1, that._keepSize = false, that._useSpriteMaterial = false, that._sizeAttenuation = true, that._width = 0, that._height = 0, that._mesh = null, that._disableRefresh = false, that;
  }
  return o(d, callback), d.prototype.isTextRegion = function() {
    return true;
  }, d.prototype.createTextMesh = function() {
    var image = this._getCanvas();
    var texture = new THREE.Texture(image);
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.generateMipmaps = true;
    texture.needsUpdate = true;
    var object;
    var size = this._getPlanSize(image);
    if (this._useSpriteMaterial) {
      var material = new THREE.SpriteMaterial({
        map : texture,
        transparent : true,
        side : THREE.DoubleSide,
        depthWrite : false
      });
      (object = new THREE.Sprite(material)).scale.set(size, size, 1);
    } else {
      var geometry = new THREE.PlaneGeometry(size, size);
      material = new THREE.MeshBasicMaterial({
        map : texture,
        transparent : true,
        side : THREE.DoubleSide,
        depthWrite : false
      });
      object = new THREE.Mesh(geometry, material);
    }
    return object.userData.skipBoundingBox = true, object.userData.skipOutline = true, object.userData.skipEnvMap = true, object.userData.noBlending = true, object.technique = object.technique || {}, object.technique.glow = "skip", object;
  }, d.prototype._getPlanSize = function(attr) {
    return Math.max(attr.width, attr.height) * this._factor;
  }, d.prototype._getCanvas = function() {
    var style = this.style;
    return this._canvasText.createCanvas(this._text, {
      fontType : style.fontType,
      alignMode : style.fontAlign,
      fontSize : style.fontSize,
      fontColor : style.fontColor,
      textLineWidth : style.textLineWidth,
      textLineHeight : style.textLineHeight,
      strokeMode : style.strokeMode,
      dropShadow : style.dropShadow,
      dropShadowColor : style.dropShadowColor,
      dropShadowAngle : style.dropShadowAngle,
      dropShadowDistance : style.dropShadowDistance,
      scale : style.scale,
      dropShadowBlur : style.dropShadowBlur,
      dropShadowAlpha : style.dropShadowAlpha
    });
  }, d.prototype.refreshTextMesh = function() {
    if (!this._disableRefresh) {
      var material = 0;
      if (this._mesh) {
        material = this._mesh.renderOrder;
      }
      this.app.resourceManager.remove(this._mesh);
      this._mesh = this.createTextMesh();
      this._mesh.renderOrder = material;
      this.node.add(this._mesh);
      if (this.static) {
        this.node._synMatrixWorld();
      }
      var cal = this.getControl("TextRegionSizeAdjustmentControl");
      if (cal) {
        cal.node = this._mesh;
      }
      this.synSize();
    }
  }, d.prototype._beforeSetupStyle = function(e) {
    if (!(e.style || {}).opacity) {
      this._disableRefresh = true;
    }
  }, d.prototype._afterSetupStyle = function(aNetChannelMessage) {
    if (this._disableRefresh) {
      this._disableRefresh = false;
      this.refreshTextMesh();
    }
  }, d.prototype.setupStyle = function(options) {
    this._sizeAttenuation = Utils.parseValue(options.sizeAttenuation, true);
    this.loaded = false;
    this._disableRefresh = true;
    options.style = options.style || {};
    var data = options.style;
    data.fontColor = Utils.parseColor(options.textColor || options.fontColor || data.fontColor);
    data.fontSize = options.textSize || options.fontSize || data.fontSize;
    data.fontType = options.textType || options.fontType || data.fontType;
    data.textLineWidth = options.textLineWidth || options.fontLineWidth || data.textLineWidth;
    data.textLineHeight = options.textLineHeight || options.fontLineHeight || data.textLineHeight;
    data.strokeMode = options.storkeMode || data.strokeMode;
    this._text = options.text || options.fontText || this._text;
    this._factor = options.factor || this._factor;
    this._useSpriteMaterial = Utils.parseValue(options.useSpriteMaterial, false);
    this._width = Utils.parseValue(options.width, this._width);
    this._height = Utils.parseValue(options.height, this._height);
    this.node.skipBoundingBox(true);
    callback.prototype.setupStyle.call(this, options);
    this.loaded = true;
  }, d.prototype.synSize = function() {
    var mesh = this._mesh;
    if (mesh && this._width && this._height) {
      mesh.scale.set(this._width, this._height, 1);
      this.synIndependentWorldScale();
    }
  }, n(d, [{
    key : "sizeAttenuation",
    get : function() {
      return this._sizeAttenuation;
    }
  }, {
    key : "text",
    set : function(v) {
      this._text = v;
      this.refreshTextMesh();
    },
    get : function() {
      return this._text;
    }
  }, {
    key : "keepSize",
    set : function(b) {
      if (this._keepSize != b) {
        if (this._keepSize = b, b) {
          var savedPos = Utils.parseVector3(this.app.camera.position);
          var deathScaleX = 60 / this._mesh.getDistanceFromCamera(savedPos);
          if (this._useSpriteMaterial) {
            deathScaleX = deathScaleX * this._mesh.scale.x;
          }
          var r = this._sizeAttenuation ? 60 : 960;
          var n = this._sizeAttenuation ? [deathScaleX, deathScaleX] : [this._width, this._height];
          this.addControl(new Ai(n, this._mesh, r), "TextRegionSizeAdjustmentControl");
          this.synSize();
        } else {
          this.removeControl("TextRegionSizeAdjustmentControl");
        }
      }
    },
    get : function() {
      return this._keepSize;
    }
  }, {
    key : "width",
    set : function(v) {
      this._width = v;
      this.synSize();
    },
    get : function() {
      return this._width;
    }
  }, {
    key : "height",
    set : function(v) {
      this._height = v;
      this.synSize();
    },
    get : function() {
      return this._height;
    }
  }, {
    key : "style",
    get : function() {
      return callback.prototype._getStyle.call(this);
    },
    set : function(num) {
      callback.prototype._setStyle.call(this, num);
    }
  }, {
    key : "textColor",
    set : function(val) {
      THING.Utils.warn('[TextRegion]Please use ".style.fontColor" to replace ".fontColor"');
      this.style.fontColor = val;
    },
    get : function() {
      return THING.Utils.warn('[TextRegion]Please use ".style.fontColor" to replace ".fontColor"'), this.style.fontColor;
    }
  }, {
    key : "dropShadow",
    set : function(value) {
      THING.Utils.warn('[TextRegion]Please use ".style.dropShadow" to replace ".dropShadow"');
      this.style.dropShadow = value;
    },
    get : function() {
      return THING.Utils.warn('[TextRegion]Please use ".style.dropShadow" to replace ".dropShadow"'), this.style.dropShadow;
    }
  }, {
    key : "dropShadowAlpha",
    set : function(value) {
      THING.Utils.warn('[TextRegion]Please use ".style.dropShadowAlpha" to replace ".dropShadowAlpha"');
      this.style.dropShadowAlpha = value;
    },
    get : function() {
      return THING.Utils.warn('[TextRegion]Please use ".style.dropShadowAlpha" to replace ".dropShadowAlpha"'), this.style.dropShadowAlpha;
    }
  }, {
    key : "dropShadowAngle",
    set : function(value) {
      THING.Utils.warn('[TextRegion]Please use ".style.dropShadowAngle" to replace ".dropShadowAngle"');
      this.style.dropShadowAngle = value;
    },
    get : function() {
      return THING.Utils.warn('[TextRegion]Please use ".style.dropShadowAngle" to replace ".dropShadowAngle"'), this.style.dropShadowAngle;
    }
  }, {
    key : "dropShadowBlur",
    set : function(value) {
      THING.Utils.warn('[TextRegion]Please use ".style.dropShadowBlur" to replace ".dropShadowBlur"');
      this.style.dropShadowBlur = value;
    },
    get : function() {
      return THING.Utils.warn('[TextRegion]Please use ".style.dropShadowBlur" to replace ".dropShadowBlur"'), this.style.dropShadowBlur;
    }
  }, {
    key : "dropShadowColor",
    set : function(value) {
      THING.Utils.warn('[TextRegion]Please use ".style.dropShadowColor" to replace ".dropShadowColor"');
      this.style.dropShadowColor = value;
    },
    get : function() {
      return THING.Utils.warn('[TextRegion]Please use ".style.dropShadowColor" to replace ".dropShadowColor"'), this.style.dropShadowColor;
    }
  }, {
    key : "dropShadowDistance",
    set : function(value) {
      THING.Utils.warn('[TextRegion]Please use ".style.dropShadowDistance" to replace ".dropShadowDistance"');
      this.style.dropShadowDistance = value;
    },
    get : function() {
      return THING.Utils.warn('[TextRegion]Please use ".style.dropShadowDistance" to replace ".dropShadowDistance"'), this.style.dropShadowDistance;
    }
  }, {
    key : "textSize",
    set : function(value) {
      THING.Utils.warn('[TextRegion]Please use ".style.fontSize" to replace ".fontSize"');
      this.style.fontSize = value;
    },
    get : function() {
      return THING.Utils.warn('[TextRegion]Please use ".style.fontSize" to replace ".fontSize"'), this.style.fontSize;
    }
  }, {
    key : "textLineWidth",
    set : function(value) {
      THING.Utils.warn('[TextRegion]Please use ".style.textLineWidth" to replace ".textLineWidth"');
      this.style.textLineWidth = value;
    },
    get : function() {
      return THING.Utils.warn('[TextRegion]Please use ".style.textLineWidth" to replace ".textLineWidth"'), this.style.textLineWidth;
    }
  }, {
    key : "textLineHeight",
    set : function(value) {
      THING.Utils.warn('[TextRegion]Please use ".style.textLineHeight" to replace ".textLineHeight"');
      this.style.textLineHeight = value;
    },
    get : function() {
      return THING.Utils.warn('[TextRegion]Please use ".style.textLineHeight" to replace ".textLineHeight"'), this.style.textLineHeight;
    }
  }, {
    key : "strokeMode",
    set : function(value) {
      THING.Utils.warn('[TextRegion]Please use ".style.strokeMode" to replace ".strokeMode"');
      this.style.strokeMode = value;
    },
    get : function() {
      return THING.Utils.warn('[TextRegion]Please use ".style.strokeMode" to replace ".strokeMode"'), this.style.strokeMode;
    }
  }]), d;
}(BaseObject);
Al = function(callback) {
  function e(row) {
    r(this, e);
    var container = s(this, callback.call(this, row));
    return container._points = [], container;
  }
  return o(e, callback), e.prototype._updateByPoints = function() {
  }, e.prototype._createPolygonVertices = function(zoomAware) {
    var vertices = [];
    var i = 0;
    for (; i < this._points.length; i++) {
      var p = this._points[i];
      vertices.push(new THREE.Vector3(p[0], p[2], p[1]));
    }
    if (!THREE.ShapeUtils.isClockWise(vertices)) {
      vertices = vertices.reverse();
    }
    var faces = [];
    var normals = THREE.ShapeUtils.triangulateShape(vertices, []);
    i = 0;
    for (; i < normals.length; i++) {
      faces.push(new THREE.Face3(normals[i][0], normals[i][1], normals[i][2]));
    }
    i = 0;
    for (; i < vertices.length; i++) {
      var b = vertices[i];
      if (!zoomAware) {
        var c = b.z;
        b.z = b.y;
        b.y = c;
      }
    }
    return {
      vertices : vertices,
      faces : faces
    };
  }, e.prototype._createPolygonGeometry = function(e, n) {
    var scope = new THREE.Geometry;
    return scope.vertices = e, scope.faces = n, scope.genFaceVertexUVs(), scope;
  }, e.prototype.clearPoints = function() {
    this._points = [];
    this._updateByPoints();
  }, e.prototype.insertPoint = function(index, value) {
    this._points.splice(index, 0, this.worldToSelf(value));
    this._updateByPoints();
  }, e.prototype.setPoint = function(i, p) {
    return !(i >= this._points.length) && (!!p && (this._points[i] = this.worldToSelf(p), this._updateByPoints(), true));
  }, e.prototype.getPoint = function(i) {
    if (i >= this._points.length) {
      return null;
    }
    var pt = this._points[i];
    return this.selfToWorld(pt);
  }, e.prototype.addPoint = function(value) {
    return this._points.push(this.worldToSelf(value)), this._updateByPoints(), this._points.length - 1;
  }, e.prototype._getPoints = function(data, inner) {
    this.node.updateWorldMatrix(true, false);
    var arr = [];
    var n = 0;
    for (; n < data.length; n++) {
      var i = data[n];
      if (inner == L.Local) {
        i = this.localToSelf(i);
      } else {
        if (inner == L.World) {
          i = this.worldToSelf(i, !this.inheritScale);
        }
      }
      arr.push(i);
    }
    return arr;
  }, e.prototype.getPointsCenterPos = function(data) {
    var value = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "world";
    var points = this._getPoints(data, value);
    if (points.length < 2) {
      return [0, 0, 0];
    }
    var sumX = 0;
    var registeredGroups = [true, true, true];
    var overlapsEndcoor = points[0].concat();
    var i = 1;
    for (; i < points.length; i++) {
      var y = points[i];
      var p = 0;
      for (; p < 3; p++) {
        if (!THING.Math.isFloatEquals(overlapsEndcoor[p], y[p])) {
          registeredGroups[p] = false;
          break;
        }
      }
    }
    var p = 0;
    var s = 1;
    var iy = 2;
    if (registeredGroups[0]) {
      p = 1;
      s = 0;
      iy = 2;
    } else {
      if (registeredGroups[1]) {
        p = 0;
        s = 1;
        iy = 2;
      } else {
        if (registeredGroups[2]) {
          p = 0;
          s = 2;
          iy = 1;
        }
      }
    }
    var newNodeLists = [];
    i = 0;
    for (; i < points.length; i++) {
      sumX = sumX + (y = points[i])[s];
      newNodeLists.push([y[p], y[iy]]);
    }
    var d = new polylabel([newNodeLists]);
    return registeredGroups[0] ? [sumX / points.length, d[0], d[1]] : registeredGroups[1] ? [d[0], sumX / points.length, d[1]] : registeredGroups[2] ? [d[0], d[1], sumX / points.length] : [0, 0, 0];
  }, e.prototype.getCenterPointPos = function(data) {
    var value = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "world";
    var points = this._getPoints(data, value);
    if (points.length < 2) {
      return [0, 0, 0];
    }
    var i = Math.floor(points.length / 2) - 1;
    if (points.length % 2) {
      return points[i + 1];
    }
    var n = points[i].map(function(sPath, n) {
      return (sPath + points[i + 1][n]) / 2;
    });
    return n;
  }, e.prototype.addPoints = function(array) {
    var item = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : L.World;
    var path = this._getPoints(array, item);
    this._points = this._points.concat(path);
    this._updateByPoints();
  }, e.prototype.removePoints = function(index) {
    var mergedRpp = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    this._points.splice(index, mergedRpp);
    this._updateByPoints();
  }, e.prototype.inside = function(array) {
    var inPolygon = this.planePoints;
    var height = array[0];
    var width = array[1];
    var n = false;
    var q = 0;
    var polyLen = inPolygon.length;
    var p = polyLen - 1;
    for (; q < polyLen; p = q, q++) {
      var lineHeight = inPolygon[q][0];
      var w = inPolygon[q][1];
      var y = inPolygon[p][0];
      var x = inPolygon[p][1];
      if ((lineHeight === height && w === width || y === height && x === width) && (n = !n), w < width && x >= width || w >= width && x < width) {
        var top = lineHeight + (width - w) * (y - lineHeight) / (x - w);
        if (top === height) {
          n = !n;
        }
        if (top > height) {
          n = !n;
        }
      }
    }
    return !!n;
  }, e.prototype.clearPathPoints = function() {
    THING.Utils.warn("[PointsBase] Please use '.clearPoints()' to replace 'clearPathPoints()'");
    this.clearPoints();
  }, e.prototype.removePoint = function(animation) {
    var artistTrack = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    THING.Utils.warn("[LineBase] Please use '.removePoints' to replace '.removePoint'");
    this.removePoints(animation, artistTrack);
  }, n(e, [{
    key : "points",
    get : function() {
      var e = [];
      var ti = 0;
      for (; ti < this._points.length; ti++) {
        var i = this.selfToWorld(this._points[ti]);
        e.push(i);
      }
      return e;
    }
  }, {
    key : "planePoints",
    get : function() {
      var checked_node_a = [];
      var i = 0;
      for (; i < this._points.length; i++) {
        var layer_i = this.selfToWorld(this._points[i]);
        checked_node_a.push([layer_i[0], layer_i[2]]);
      }
      return checked_node_a;
    }
  }, {
    key : "area",
    get : function() {
      var intersect = [];
      var i = 0;
      for (; i < this._points.length; i++) {
        var uvs = this.selfToWorld(this._points[i]);
        intersect.push(new THREE.Vector2(uvs[0], uvs[2]));
      }
      var area = THREE.ShapeUtils.area(intersect);
      return Math.abs(area);
    }
  }, {
    key : "centerPos",
    get : function() {
      return new polylabel([this.planePoints]);
    }
  }, {
    key : "avgHeight",
    get : function() {
      if (!this._points.length) {
        return 0;
      }
      var sumdp = 0;
      var i = 0;
      for (; i < this._points.length; i++) {
        sumdp = sumdp + this._points[i][1];
      }
      return sumdp / this._points.length;
    }
  }]), e;
}(BaseObject);
kl = function(a) {
  function i(value) {
    r(this, i);
    var container = s(this, a.call(this, value));
    return container._lineMesh = null, container._areaMesh = null, container._textRegion = null, container;
  }
  return o(i, a), i.prototype._updateTextPosition = function() {
    if (this._textRegion) {
      var e = this.centerPos;
      this._textRegion.position = [e[0], this.position.y, e[1]];
      this._textRegion.translateY(.01);
    }
  }, i.prototype._updateByPoints = function() {
    if (!(this._points.length < 3)) {
      var wheelAxisMat = new THREE.MeshBasicMaterial({
        color : this.style.regionColor,
        opacity : this.style.regionOpacity,
        transparent : true,
        side : THREE.DoubleSide,
        depthWrite : false
      });
      var json = this._createPolygonVertices();
      var geometry = this._createPolygonGeometry(json.vertices, json.faces);
      this.app.resourceManager.remove(this._areaMesh);
      this._areaMesh = new THREE.Mesh(geometry, wheelAxisMat);
      this.node.add(this._areaMesh);
      var linkMaterial = new THREE.LineBasicMaterial({
        color : this.style.lineColor,
        opacity : this.style.lineOpacity,
        transparent : true
      });
      this.app.resourceManager.remove(this._lineMesh);
      (geometry = new THREE.Geometry).vertices = json.vertices;
      geometry.vertices.push(json.vertices[0]);
      this._lineMesh = new THREE.Line(geometry, linkMaterial);
      this._lineMesh.userData.skipPick = true;
      this.node.add(this._lineMesh);
    }
  }, i.prototype._beforeSetupComplete = function(options) {
    var data = options.points || options.vertices;
    if (data) {
      if (!options.position && !options.localPosition) {
        var parent = this.getPointsCenterPos(data);
        this.position = this.selfToWorld(parent);
      }
      this.addPoints(data);
    }
    var text = options.fontText || options.text;
    if (text) {
      this.text = text;
    }
    if (Utils.parseValue(options.alwaysOnTop, true)) {
      this.style.alwaysOnTop = true;
    }
    var style = this.style;
    style.lineOpacity = Utils.parseValue(options.lineOpacity, style.lineOpacity);
    style.lineColor = Utils.parseColor(options.lineColor, style.lineColor);
    style.regionOpacity = Utils.parseValue(options.regionOpacity || options.opacity, style.regionOpacity);
    style.regionColor = Utils.parseColor(options.regionColor, style.regionColor);
  }, n(i, [{
    key : "textRegion",
    get : function() {
      if (!this._textRegion) {
        var data = {
          type : "TextRegion",
          parent : this
        };
        this._textRegion = this.app.create(data);
        this._textRegion._mesh.renderOrder = 1;
        this._textRegion.angleX = -90;
        this._textRegion.translateY(.1);
      }
      return this._textRegion;
    }
  }, {
    key : "text",
    set : function(v) {
      this.textRegion.text = v;
      this._updateTextPosition();
    },
    get : function() {
      return this.textRegion.text;
    }
  }, {
    key : "style",
    get : function() {
      return a.prototype._getStyle.call(this);
    },
    set : function(num) {
      a.prototype._setStyle.call(this, num);
    }
  }, {
    key : "lineColor",
    set : function(v) {
      THING.Utils.warn('[PolygonRegion]Please use ".style.lineColor" to replace ".lineColor"');
      this.style.lineColor = v;
    },
    get : function() {
      return THING.Utils.warn('[PolygonRegion]Please use ".style.lineColor" to replace ".lineColor"'), this.style.lineColor;
    }
  }, {
    key : "regionColor",
    set : function(value) {
      THING.Utils.warn('[PolygonRegion]Please use ".style.regionColor" to replace ".regionColor"');
      this.style.regionColor = value;
    },
    get : function() {
      return THING.Utils.warn('[PolygonRegion]Please use ".style.regionColor" to replace ".regionColor"'), this.style.regionColor;
    }
  }, {
    key : "regionOpacity",
    set : function(value) {
      THING.Utils.warn('[PolygonRegion]Please use ".style.regionOpacity" to replace ".regionOpacity"');
      this.style.regionOpacity = value;
    },
    get : function() {
      return this.style.regionOpacity;
    }
  }]), i;
}(Al);
Ol = null;
function Bl() {
  return Ol || (Ol = new THREE.Texture(SimpleHeatmap.getInstance().canvas())), Ol;
}
var Fl = function(callback) {
  function e(row) {
    r(this, e);
    var self = s(this, callback.call(this, row));
    return self.node = new THREE.Object3D, self._map = null, self._tex = null, self._params = {}, self;
  }
  return o(e, callback), e.prototype._getMap = function() {
    return SimpleHeatmap.getInstance();
  }, e.prototype._beforeSetup = function(state) {
    this._map = this._getMap();
    var tex = this._tex = new THREE.Texture(this._map.canvas());
    var value = void 0 !== state.opacity ? state.opacity : 1;
    var spriteSize = state.width || 10;
    var height = state.height || 10;
    var geometry = void 0;
    if (state.clipShape) {
      var g = state.clipShape.shape.map(function(resourcesOrReports) {
        return (new THREE.Vector2).fromArray(resourcesOrReports);
      });
      var shape = new THREE.Shape(g);
      shape.autoClose = true;
      if (state.clipShape.holes) {
        shape.holes = state.clipShape.holes.map(function(buildInTemplates) {
          return new THREE.Shape(buildInTemplates.map(function(resourcesOrReports) {
            return (new THREE.Vector2).fromArray(resourcesOrReports);
          }));
        });
      }
      var customAttribute = (geometry = new THREE.ShapeBufferGeometry(shape)).getAttribute("uv");
      var offset_custom = 0;
      var readersLength = customAttribute.array.length;
      for (; offset_custom < readersLength; offset_custom = offset_custom + 2) {
        var currentTabPositionX = customAttribute.array[offset_custom + 0];
        var y = customAttribute.array[offset_custom + 1];
        customAttribute.array[offset_custom + 0] = (currentTabPositionX + spriteSize / 2) / spriteSize;
        customAttribute.array[offset_custom + 1] = (y + height / 2) / height;
      }
    } else {
      if (state.meshShape) {
        var d = state.meshShape;
        var resolvedSourceMapConfigs = d.node.getMeshes();
        if (resolvedSourceMapConfigs.length >= 1) {
          if (resolvedSourceMapConfigs.length > 1) {
            geometry = new THREE.BufferGeometry;
            var value = resolvedSourceMapConfigs.map(function(chunksOrSource) {
              return Ll(chunksOrSource, d.node.parent);
            });
            !function(e) {
              var count = e.length;
              var entries = [];
              var attrs = e[0].attributes;
              var key;
              for (key in attrs) {
                entries.push({
                  key : key,
                  count : 1
                });
              }
              var j = 1;
              for (; j < count; j++) {
                attrs = e[j].attributes;
                var i = 0;
                for (; i < entries.length; i++) {
                  if (attrs[entries[i].key]) {
                    entries[i].count++;
                  }
                }
              }
              var result = new Set;
              entries.forEach(function(stats) {
                if (stats.count === count) {
                  result.add(stats.key);
                }
              });
              var i = 0;
              for (; i < count; i++) {
                var prop;
                for (prop in attrs = e[i].attributes) {
                  if (!result.has(prop)) {
                    delete attrs[prop];
                  }
                }
              }
            }(value);
            (geometry = THREE.BufferGeometryUtils.mergeBufferGeometries(value)).computeBoundingBox();
          } else {
            geometry = Ll(resolvedSourceMapConfigs[0], d.node.parent);
          }
          var options = geometry.boundingBox.getSize(new THREE.Vector3);
          var offset = geometry.boundingBox.min;
          var attrCopy = geometry.getAttribute("position");
          var positions = geometry.getAttribute("uv");
          if (!positions) {
            positions = new THREE.BufferAttribute(new Float32Array(2 * attrCopy.count), 2);
            geometry.setAttribute("uv", positions);
          }
          var query_count = 0;
          var x = positions.array.length / 2;
          for (; query_count < x; query_count++) {
            var x = attrCopy.array[3 * query_count + 0];
            var z = attrCopy.array[3 * query_count + 2];
            positions.array[2 * query_count + 0] = (x - offset.x) / options.x;
            positions.array[2 * query_count + 1] = (z - offset.z) / options.z;
          }
          state.width = options.x;
          state.height = options.z;
        } else {
          console.warn("Heatmap: can not find mesh of object shape.");
        }
      } else {
        geometry = new THREE.PlaneGeometry(spriteSize, height);
      }
    }
    var material = void 0;
    if (state.mosaic) {
      (material = new THREE.ShaderMaterial({
        uniforms : THREE.UniformsUtils.clone(Il.uniforms),
        vertexShader : Il.vertexShader,
        fragmentShader : Il.fragmentShader,
        transparent : true,
        side : THREE.DoubleSide
      })).uniforms.opacity.value = value;
      material.uniforms.tDiffuse.value = tex;
    } else {
      material = new THREE.MeshBasicMaterial({
        map : tex,
        side : THREE.DoubleSide,
        transparent : true,
        opacity : value
      });
    }
    this._material = material;
    var node = new THREE.Mesh(geometry, material);
    node.userData.skipEnvMap = true;
    this.node.add(node);
    this._initParameter(state);
    this._refresh();
  }, e.prototype._initParameter = function(options) {
    var params = this._params;
    params.areaWidth = options.width || 10;
    params.areaHeight = options.height || 10;
    params.mapSize = options.mapSize || 256;
    params.alpha = !!options.alpha;
    params.gradient = options.gradient || {
      "0.4" : "blue",
      "0.6" : "cyan",
      "0.7" : "lime",
      "0.8" : "yellow",
      1 : "red"
    };
    params.minValue = void 0 !== options.minValue ? options.minValue : 10;
    params.maxValue = void 0 !== options.maxValue ? options.maxValue : 50;
    params.radius = options.radius || .8;
    params.blur = options.blur || .8;
    params.data = options.data || [];
    params.mosaicSize = options.mosaicSize || params.mapSize / 64;
  }, e.prototype.setParameter = function(value) {
    var config = this._params;
    config.mapSize = value.mapSize || config.mapSize;
    config.alpha = void 0 !== value.alpha ? value.alpha : config.alpha;
    config.gradient = value.gradient || config.gradient;
    config.minValue = value.minValue || config.minValue;
    config.maxValue = value.maxValue || config.maxValue;
    config.radius = value.radius || config.radius;
    config.blur = value.blur || config.blur;
    config.data = value.data || config.data;
    config.mosaicSize = value.mosaicSize || config.mosaicSize;
    this._refresh();
  }, e.prototype.addData = function(label) {
    this._params.data.push(label);
    this._refresh();
  }, e.prototype.setData = function(url) {
    this._params.data = url;
    this._refresh();
  }, e.prototype.setAlpha = function(value) {
    this._params.alpha = value;
    this._refresh();
  }, e.prototype.setRadius = function(radius, elem) {
    this._params.radius = radius;
    if (void 0 !== elem) {
      this._params.blur = elem;
    }
    this._refresh();
  }, e.prototype.setGradient = function(value) {
    this._params.gradient = value;
    this._refresh();
  }, e.prototype.randomData = function() {
    var result = this._params;
    var arg = [];
    var i = 0;
    for (; i < Math.round(result.areaWidth * result.areaHeight); i++) {
      arg.push([(Math.random() - .5) * result.areaWidth, (Math.random() - .5) * result.areaHeight, Math.pow(Math.random(), 3) * (result.maxValue - result.minValue) + result.minValue]);
    }
    this.setData(arg);
  }, e.prototype._refresh = function() {
    var options = this._params;
    var bpPerPixel = 1;
    var minPercent = 1;
    var j = options.mapSize / options.areaWidth;
    if (options.areaWidth != options.areaHeight) {
      if (options.areaWidth > options.areaHeight) {
        bpPerPixel = 1;
        minPercent = options.areaHeight / options.areaWidth;
      } else {
        bpPerPixel = options.areaWidth / options.areaHeight;
        minPercent = 1;
        j = options.mapSize / options.areaHeight;
      }
    }
    var x = options.data.map(function(canCreateDiscussions) {
      return [1 * canCreateDiscussions[0], 1 * canCreateDiscussions[1], canCreateDiscussions[2]];
    });
    var l = Math.floor(options.mapSize * bpPerPixel);
    var zoom = Math.floor(options.mapSize * minPercent);
    this._map.setCanvasSize(l, zoom).setAreaSize(1 * options.areaWidth, 1 * options.areaHeight).min(options.minValue).max(options.maxValue).alpha(options.alpha).gradient(options.gradient).radius(Math.floor(options.radius * j * 1), Math.floor(options.blur * j * 1)).data(x).draw();
    this._tex.needsUpdate = true;
    Bl().needsUpdate = true;
    this.app.renderer.copyTextureToTexture(new THREE.Vector2, Bl(), this._tex);
    if (this._material.isShaderMaterial) {
      this._material.uniforms.texSize.value.set(l, zoom);
      this._material.uniforms.mosaicSize.value.set(options.mosaicSize, options.mosaicSize);
    }
  }, n(e, [{
    key : "isHeatmap",
    get : function() {
      return THING.Utils.warn("[Heatmap] Please use 'instanceof THING.Heatmap' to replace '.isHeatmap'"), this instanceof THING.Heatmap;
    }
  }]), e;
}(BaseObject);
function Ll(object, point) {
  var vec2 = object.geometry.isBufferGeometry ? object.geometry.clone() : (new THREE.BufferGeometry).fromGeometry(object.geometry);
  return vec2.applyMatrix4(object.getMatrixFromRoot(point)), vec2.computeBoundingBox(), vec2;
}
var Il = {
  uniforms : {
    opacity : {
      value : 1
    },
    tDiffuse : {
      value : null
    },
    texSize : {
      value : new THREE.Vector2(640, 640)
    },
    mosaicSize : {
      value : new THREE.Vector2(16, 16)
    }
  },
  vertexShader : "\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\tvarying vec2 vUV;\n        void main() {\n\t\t\tvUV = uv;\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <fog_vertex>\n        }\n    ",
  fragmentShader : "\n\t\tuniform\tfloat opacity;\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\n        uniform sampler2D tDiffuse;\n\n        uniform vec2 texSize;\n        uniform vec2 mosaicSize;\n\n        varying vec2 vUV;\n\n        void main(void) {\n\t\t\tvec4 originColor = texture2D(tDiffuse, vUV);\n\n\t\t\tif (originColor.a < 0.0001) discard;\n\n\t\t\t#include <logdepthbuf_fragment>\n\n            vec2 xy = vec2(vUV.x * texSize.x, vUV.y * texSize.y);\n            \n            vec2 xyMosaic = vec2(floor(xy.x / mosaicSize.x) * mosaicSize.x, \n                    floor(xy.y / mosaicSize.y) * mosaicSize.y )\n                    + .5*mosaicSize;\n            \n            vec2 delXY = xyMosaic - xy;\n            float delL = length(delXY);\n            \n            vec2 uvMosaic = vec2(xyMosaic.x / texSize.x, xyMosaic.y / texSize.y);\n\n            float percent = smoothstep(0., 1., 1. - delL * 2.4 / mosaicSize.x) * 0.7 + 0.3;\n\n            vec4 centerColor = texture2D(tDiffuse, uvMosaic);\n            \n            vec4 resultColor = vec4(mix(originColor.rgb, centerColor.rgb, percent), centerColor.a * percent * opacity);\n            \n\t\t\tgl_FragColor = resultColor;\n\t\t\t\n\t\t\t#include <fog_fragment>\n        }\n    "
};
Fl.PointMosaicShader = Il;
var Nl = null;
function Hl() {
  return Nl || (Nl = new THREE.Texture(SimpleIDW.getInstance().canvas())), Nl;
}
var Ul = function(e) {
  function a(row) {
    return r(this, a), s(this, e.call(this, row));
  }
  return o(a, e), a.prototype._getMap = function() {
    return SimpleIDW.getInstance();
  }, a.prototype._initParameter = function(options) {
    var params = this._params;
    params.areaWidth = Utils.parseValue(options.width, 10);
    params.areaHeight = Utils.parseValue(options.height, 10);
    params.mapSize = Utils.parseValue(options.mapSize, 256);
    params.alpha = Utils.parseValue(options.alpha, false);
    params.gradient = Utils.parseValue(options.gradient, {
      "0.4" : "blue",
      "0.6" : "cyan",
      "0.7" : "lime",
      "0.8" : "yellow",
      1 : "red"
    });
    params.minValue = options.minValue;
    params.maxValue = options.maxValue;
    params.radius = options.radius;
    params.minEffectPointNumber = options.minEffectPointNumber;
    params.smooth = Utils.parseValue(options.smooth, true);
    params.data = Utils.parseValue(options.data, []);
    params.exp = Utils.parseValue(options.exp, 2);
    var name = params.areaWidth > params.areaHeight ? params.areaWidth / 250 : params.areaHeight / 250;
    params.cellSize = Utils.parseValue(options.cellSize, name);
    params.opacity = Utils.parseValue(options.opacity, 1);
    params.mosaicSize = Utils.parseValue(options.mosaicSize, params.mapSize / 64);
    if (Utils.isNull(params.radius) && Utils.isNull(params.minEffectPointNumber)) {
      params.radius = 5 * name;
    }
  }, a.prototype._refresh = function() {
    var options = this._params;
    var bpPerPixel = 1;
    var minPercent = 1;
    var scale = options.mapSize / options.areaWidth;
    if (options.areaWidth != options.areaHeight) {
      if (options.areaWidth > options.areaHeight) {
        bpPerPixel = 1;
        minPercent = options.areaHeight / options.areaWidth;
      } else {
        bpPerPixel = options.areaWidth / options.areaHeight;
        minPercent = 1;
        scale = options.mapSize / options.areaHeight;
      }
    }
    var x = options.radius * scale;
    var density = Math.round(options.cellSize * scale);
    var s = options.data.map(function(canCreateDiscussions) {
      return [1 * canCreateDiscussions[0], 1 * canCreateDiscussions[1], canCreateDiscussions[2]];
    });
    var base = options.data.map(function(canCreateDiscussions) {
      return canCreateDiscussions[2];
    });
    if (Utils.isNull(options.minValue)) {
      options.minValue = Math.min.apply(Math, base);
    }
    if (Utils.isNull(options.maxValue)) {
      options.maxValue = Math.max.apply(Math, base);
    }
    var l = Math.floor(options.mapSize * bpPerPixel);
    var zoom = Math.floor(options.mapSize * minPercent);
    this._map.setCanvasSize(l, zoom).setAreaSize(1 * options.areaWidth, 1 * options.areaHeight).min(options.minValue).max(options.maxValue).alpha(options.alpha).gradient(options.gradient).opacity(options.opacity).cellSize(density).exp(options.exp).smooth(options.smooth).radius(x).minEffectPointNumber(options.minEffectPointNumber).data(s)._redraw();
    if (s && 0 !== s.length) {
      this._tex.magFilter = THREE.NearestFilter;
      this._tex.minFilter = THREE.NearestFilter;
      this._tex.needsUpdate = true;
      Hl().needsUpdate = true;
      this.app.renderer.copyTextureToTexture(new THREE.Vector2, Hl(), this._tex);
      if (this._material.isShaderMaterial) {
        this._material.uniforms.texSize.value.set(l, zoom);
        this._material.uniforms.mosaicSize.value.set(options.mosaicSize, options.mosaicSize);
      }
    } else {
      this._tex.dispose();
    }
  }, a;
}(Fl);
zl = function(t) {
  function e(row) {
    r(this, e);
    var container = s(this, t.call(this, row));
    return container._params = {}, container;
  }
  return o(e, t), e.prototype._beforeSetup = function(state) {
    this._vs = "varying vec2 v_Uv;\n\n\t\tvoid main() {\n\n\t\t\tv_Uv = uv;\n\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t}";
    this._fs = "precision mediump float;\n\t\t// uniform vec3 points[300];\n\t\tuniform float idw_DistanceThreshold;\n\t\tuniform float idw_exponent;\n\t\tuniform float idw_linearFadeFactor;\n\t\tuniform float idw_minValue;\n\t\tuniform float idw_maxValue;\n\t\tuniform vec2 iResolution;\n\t\tuniform vec2 originPoint;\n\t\tuniform float pointTextureSize;\n\t\tuniform sampler2D pointTexture;\n\t\tuniform sampler2D colorRampTexture;\n\t\tuniform int NUM_POINTS;\n\t\tvarying vec2 v_Uv;\n\n\t\tfloat isoline(float val, float lg, float ref, float pas, float thickness) {\n\t\t\tfloat v = abs(mod(val - ref + pas * .5, pas) - pas * .5) / lg - .1 * thickness;\n\t\t\treturn smoothstep(.2, .8, v);\n\t\t}\n\n\t\tstruct Accumulator\n\t\t{\n\t\t\tfloat m_sumOfWeightedValues;\n\t\t\tfloat m_sumOfWeights;\n\t\t};\n\t\tfloat GetWeightedAverage(Accumulator acc)\n\t\t{\n\t\t\treturn acc.m_sumOfWeightedValues / acc.m_sumOfWeights;\n\t\t}\n\n\n\t\tvoid main() {\n\n\t\t\tfloat exactThreshold = 0.01; // if we are very close to a point then avoid a divide by zero and set to exact weight of the point\n\n\t\t\tAccumulator acc = Accumulator(0.0f,0.0f);\n\n\t\t\tvec2 fragCoord = v_Uv * iResolution.xy;\n\t\t\tfloat interpolatedValue = 0.;\n\t\t\t\n\t\t\tfor (int i = 0; i < NUM_POINTS; ++i) \n\t\t\t{\n\t\t\t\tfloat i_float = float(i);\n\t\t\t\tfloat j = i_float * 1.0;\n\t\t\t\tfloat x = mod( j, float( pointTextureSize ) );\n\t\t\t\tfloat y = floor( j / float( pointTextureSize ) );\n\n\t\t\t\tfloat dx = 1.0 / float( pointTextureSize );\n\t\t\t\tfloat dy = 1.0 / float( pointTextureSize );\n\n\t\t\t\ty = dy * ( y + 0.5 );\n\n\t\t\t\tvec4 pointSampler = texture2D( pointTexture, vec2( dx * ( x + 0.5 ), y ) );\n\n\t\t\t\tfloat dist = max(exactThreshold, length(fragCoord.xy +originPoint - pointSampler.xz));  \n\t\t\t\tif (dist < idw_DistanceThreshold) \n\t\t\t\t{\n\n\t\t\t\t\tfloat weight = 1.0f / pow(dist, idw_exponent);\n\t\t\t\t\t//weight *= (1.0f - idw_linearFadeFactor * (dist / idw_DistanceThreshold));\n\n\t\t\t\t\tacc.m_sumOfWeights += weight;\n\t\t\t\t\tacc.m_sumOfWeightedValues += weight * pointSampler.w;\n\t\t\t\t}\n\t\t\t\t//interpolatedValue += pointSampler.w * inverseDistances[i];\n\t\t\t}\n\n\n\t\t\tinterpolatedValue = GetWeightedAverage(acc);\n\t\t\t//interpolatedValue = clamp(interpolatedValue, 0.0, 1.0);\n\t\t\t\n\t\t\t//float lg = 2.*length(vec2(dFdx(interpolatedValue), dFdy(interpolatedValue)));\n\t\t\t//float k1 = isoline(interpolatedValue, lg, .05, .2, 1.),\n\t\t\t//k2 = isoline(interpolatedValue, lg, .025, .05, .01);\n\t\t\t\n\t\t\t// paletize value\n\t\t\tinterpolatedValue = (interpolatedValue- idw_minValue) /(idw_maxValue -idw_minValue);\n\t\t\tvec3 col =texture2D(colorRampTexture,vec2(interpolatedValue,0.5)).rgb;\n\t\t\t\n\t\t\t// apply isoline to color\n\t\t\t//col *= (.3+(k1*.7));\n\t\t\t//col *= (.7+(k2*.3));\n\n\t\t\t//set isoline color\n\t\t\t//if(k1<=0.2){col =vec3(1.,0.,0.);}\n\t\t\t//else{\n\t\t\t//\tcol = mix(vec3(1.,0.,0.),col, (.3+(k1*.7)));\n\t\t\t//}\n\t\t\tgl_FragColor = vec4(col, 1.);\n\t\t}";
    this._initParameter(state);
    var spriteSize = this.areaWidth;
    var height = this.areaHeight;
    var geometry = void 0;
    if (state.clipShape) {
      var g = state.clipShape.shape.map(function(resourcesOrReports) {
        return (new THREE.Vector2).fromArray(resourcesOrReports);
      });
      var shape = new THREE.Shape(g);
      shape.autoClose = true;
      if (state.clipShape.holes) {
        shape.holes = state.clipShape.holes.map(function(buildInTemplates) {
          return new THREE.Shape(buildInTemplates.map(function(resourcesOrReports) {
            return (new THREE.Vector2).fromArray(resourcesOrReports);
          }));
        });
      }
      var uvBuffer = (geometry = new THREE.ShapeBufferGeometry(shape)).getAttribute("uv");
      var offset = 0;
      var newNodeLength = uvBuffer.array.length;
      for (; offset < newNodeLength; offset = offset + 2) {
        var currentTabPositionX = uvBuffer.array[offset + 0];
        var y = uvBuffer.array[offset + 1];
        uvBuffer.array[offset + 0] = (currentTabPositionX + spriteSize / 2) / spriteSize;
        uvBuffer.array[offset + 1] = (y + height / 2) / height;
      }
    } else {
      if (state.meshShape) {
        var h = state.meshShape;
        var resolvedSourceMapConfigs = h.node.getMeshes();
        if (resolvedSourceMapConfigs.length >= 1) {
          if (resolvedSourceMapConfigs.length > 1) {
            geometry = new THREE.BufferGeometry;
            var data = resolvedSourceMapConfigs.map(function(e) {
              return getBufferGeometry(e, h.node.parent);
            });
            alignAttributes(data);
            (geometry = THREE.BufferGeometryUtils.mergeBufferGeometries(data)).computeBoundingBox();
          } else {
            geometry = getBufferGeometry(resolvedSourceMapConfigs[0], h.node.parent);
          }
          var options = geometry.boundingBox.getSize(new THREE.Vector3);
          var offset = geometry.boundingBox.min;
          var attrCopy = geometry.getAttribute("position");
          var positions = geometry.getAttribute("uv");
          if (!positions) {
            positions = new THREE.BufferAttribute(new Float32Array(2 * attrCopy.count), 2);
            geometry.setAttribute("uv", positions);
          }
          var y = 0;
          var blockCountY = positions.array.length / 2;
          for (; y < blockCountY; y++) {
            var x = attrCopy.array[3 * y + 0];
            var z = attrCopy.array[3 * y + 2];
            positions.array[2 * y + 0] = (x - offset.x) / options.x;
            positions.array[2 * y + 1] = (z - offset.z) / options.z;
          }
          state.width = options.x;
          state.height = options.z;
        } else {
          console.warn("Heatmap: can not find mesh of object shape.");
        }
      } else {
        geometry = new THREE.PlaneGeometry(spriteSize, height);
      }
    }
    if (state.mosaic) {
      this._material = this._getMosaicMaterial();
    } else {
      this._material = this._getBasicMaterial();
    }
    var node = new THREE.Mesh(geometry, this._material);
    node.userData.skipEnvMap = true;
    this.node.add(node);
    var endpoints = [];
    var self = [];
    var i;
    for (i in this.gradient) {
      self.push(parseFloat(i));
      endpoints.push(THING.Utils.parseColor(this.gradient[i]).toArray());
    }
    this._gradientTexture = this._generateGradientTextureByGray(self, endpoints);
    this.init(this.data, this.areaWidth, this.areaHeight, this.minValue, this.maxValue, this.radius, this._gradientTexture, this._cellNum, this.exp);
  }, e.prototype._getMosaicMaterial = function() {
    return this._mosaicMateiral || (this._mosaicMateiral = new THREE.ShaderMaterial({
      uniforms : THREE.UniformsUtils.clone(THING.Heatmap.PointMosaicShader.uniforms),
      vertexShader : THING.Heatmap.PointMosaicShader.vertexShader,
      fragmentShader : THING.Heatmap.PointMosaicShader.fragmentShader,
      transparent : true,
      side : THREE.DoubleSide
    })), this._mosaicMateiral.uniforms.texSize.value.set(this._cellNum, this._cellNum), this._mosaicMateiral.uniforms.mosaicSize.value.set(this._mosaicSize, this._mosaicSize), this._mosaicMateiral.uniforms.opacity.value = this.opacity, this._mosaicMateiral.uniforms.tDiffuse.value = new THREE.Texture, this._mosaicMateiral;
  }, e.prototype._getBasicMaterial = function() {
    return this._basicMateiral || (this._basicMateiral = new THREE.MeshBasicMaterial({
      side : THREE.DoubleSide,
      transparent : true
    })), this._basicMateiral.opacity = this.opacity, this._basicMateiral;
  }, e.prototype._initMinMaxValue = function() {
    var name = this.data.map(function(canCreateDiscussions) {
      return canCreateDiscussions[2];
    });
    if (Utils.isNull(this.minValue) || this.minValue === 1 / 0) {
      this.minValue = Math.min.apply(Math, name);
    }
    if (Utils.isNull(this.maxValue) || this.maxValue === -1 / 0) {
      this.maxValue = Math.max.apply(Math, name);
    }
  }, e.prototype._initParameter = function(options) {
    this.areaWidth = Utils.parseValue(options.width, 10);
    this.areaHeight = Utils.parseValue(options.height, 10);
    this.alpha = Utils.parseValue(options.alpha, false);
    this.gradient = Utils.parseValue(options.gradient, {
      "0.4" : "blue",
      "0.6" : "cyan",
      "0.7" : "lime",
      "0.8" : "yellow",
      1 : "red"
    });
    this.minValue = options.minValue;
    this.maxValue = options.maxValue;
    this.data = Utils.parseValue(options.data, []);
    this._initMinMaxValue();
    this._radius = options.radius;
    this.exp = Utils.parseValue(options.exp, 2);
    var x = this.areaWidth > this.areaHeight ? this.areaWidth : this.areaHeight;
    var value = x / 512;
    this.cellSize = Utils.parseValue(options.cellSize, value);
    this._cellNum = Math.ceil(x / this.cellSize);
    this._opacity = Utils.parseValue(options.opacity, 1);
    this._mosaicSize = Utils.parseValue(options.mosaicSize, 4);
    this._mosaic = Utils.parseValue(options.mosaic, false);
    if (Utils.isNull(this._radius)) {
      this._radius = 5 * this.cellSize;
    }
  }, e.prototype.init = function(type, v, c, radius, p, f, a, op, expr) {
    var vec__8347 = "undefined" != typeof WebGL2RenderingContext && THING.App.current.renderer.getContext() instanceof WebGL2RenderingContext;
    var end = this._putDataIntoTexture(type, vec__8347);
    this._setidwRenderTargets(end, type.length, v, c, radius, p, -v / 2, -c / 2, f, a, op, expr);
  }, e.prototype.refresh = function() {
    this.init(this.data, this.areaWidth, this.areaHeight, this.minValue, this.maxValue, this.radius, this._gradientTexture, this._cellNum, this.exp);
  }, e.prototype.setData = function(data) {
    if (data) {
      this.data = data;
      this._initMinMaxValue();
      this.init(this.data, this.areaWidth, this.areaHeight, this.minValue, this.maxValue, this.radius, this._gradientTexture, this._cellNum, this.exp);
    }
  }, e.prototype._generateGradientTextureByGray = function(col, s, b, url, texture) {
    this._canvas = document.createElement("canvas");
    this._canvas.width = 256;
    this._canvas.height = 256;
    var ctx = this._canvas.getContext("2d");
    b = void 0 === b || b;
    var linGrad = void 0;
    linGrad = (url = url || false) ? ctx.createLinearGradient(0, 0, 0, 256) : ctx.createLinearGradient(0, 0, 256, 0);
    var c = 0;
    for (; c < col.length; c++) {
      var colorAShadowStart;
      colorAShadowStart = s[c] ? b ? (new THREE.Color(s[c][0], s[c][1], s[c][2])).toHexString() : s[c] : b ? (new THREE.Color(1, 1, 1)).toHexString() : "rgb(255,255,255)";
      linGrad.addColorStop(+col[c], colorAShadowStart);
    }
    ctx.fillStyle = linGrad;
    if (url) {
      ctx.fillRect(0, 0, 1, 256);
    } else {
      ctx.fillRect(0, 0, 256, 1);
    }
    var a = void 0;
    return a = url ? new Uint8Array(ctx.getImageData(0, 0, 1, 256).data.buffer) : new Uint8Array(ctx.getImageData(0, 0, 256, 1).data.buffer), texture ? texture.image = url ? {
      data : a,
      width : 1,
      height : 256
    } : {
      data : a,
      width : 256,
      height : 1
    } : texture = url ? new THREE.DataTexture(a, 1, 256) : new THREE.DataTexture(a, 256, 1), texture.magFilter = texture.minFilter = THREE.LinearFilter, texture.needsUpdate = true, texture;
  }, e.prototype._putDataIntoTexture = function(p) {
    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    var width = Math.sqrt(p.length);
    width = this._nextPowerOfTwo(Math.ceil(width));
    width = Math.max(4, width);
    var data = new Float32Array(width * width * 4);
    var i = 0;
    for (; i < p.length; i++) {
      data[4 * i] = p[i][0];
      data[4 * i + 1] = 0;
      data[4 * i + 2] = p[i][1];
      data[4 * i + 3] = p[i][2];
    }
    var texture = new THREE.DataTexture(data, width, width);
    return t && (texture.format = THREE.RGBAFormat), texture.type = THREE.FloatType, texture.magFilter = THREE.NearestFilter, texture.minFilter = THREE.NearestFilter, texture.generateMipmaps = false, texture.flipY = false, texture.needsUpdate = true, texture;
  }, e.prototype._setidwRenderTargets = function(c, kind, x, y, val, e, a, v, data, key, size) {
    var command_module_id = arguments.length > 11 && void 0 !== arguments[11] ? arguments[11] : 2;
    var m = new THREE.ShaderMaterial({
      uniforms : {
        idw_exponent : {
          value : command_module_id
        },
        idw_DistanceThreshold : {
          value : data
        },
        idw_linearFadeFactor : {
          value : 0
        },
        idw_minValue : {
          value : val
        },
        idw_maxValue : {
          value : e
        },
        pointTexture : {
          value : c
        },
        colorRampTexture : {
          value : key
        },
        pointTextureSize : {
          value : c.image.height
        },
        NUM_POINTS : {
          value : kind
        },
        iResolution : {
          value : new THREE.Vector2(x, y)
        },
        originPoint : {
          value : new THREE.Vector2(a, v)
        }
      },
      vertexShader : this._vs,
      fragmentShader : this._fs
    });
    if (this._ottScene) {
      this._idwRenderTarget.setSize(size, size);
      this._ottScene.children[0].material = m;
    } else {
      this._ottScene = new THREE.Scene;
      this._ottCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 1, 1e3);
      var t = new THREE.PlaneBufferGeometry(2, 2);
      this._ottCamera.position.set(0, 0, 1);
      var b = new THREE.Mesh(t, m);
      b.scale.set(1, -1, 1);
      b.position.set(0, 0, -2);
      this._ottScene.add(b);
      this._idwRenderTarget = new THREE.WebGLRenderTarget(size, size, {
        minFilter : THREE.NearestFilter,
        magFilter : THREE.NearestFilter,
        wrapS : THREE.ClampToEdgeWrapping,
        wrapT : THREE.ClampToEdgeWrapping,
        format : THREE.RGBAFormat,
        type : THREE.FloatType,
        generateMipmaps : false
      });
    }
    m.needsUpdate = true;
    var renderer = THING.App.current.renderer;
    renderer.clear();
    renderer.setRenderTarget(this._idwRenderTarget);
    renderer.clear();
    renderer.render(this._ottScene, this._ottCamera);
    if (this.mosaic) {
      this._material.uniforms.texSize.value.set(size, size);
      this._material.uniforms.tDiffuse.value = this._idwRenderTarget.texture;
    } else {
      this._material.map = this._idwRenderTarget.texture;
    }
    this._material.needsUpdate = true;
    renderer.setRenderTarget(null);
    m.dispose();
  }, e.prototype._nextPowerOfTwo = function(value) {
    return value--, value = value | value >> 1, value = value | value >> 2, value = value | value >> 4, value = value | value >> 8, value = value | value >> 16, ++value;
  }, e.prototype.destroy = function() {
    t.prototype.destroy.call(this);
    this._ottScene.children = [];
    this._ottScene = null;
  }, n(e, [{
    key : "mosaicSize",
    get : function() {
      return this._mosaicSize;
    },
    set : function(v) {
      if (v !== this._mosaicSize) {
        if (this._mosaic) {
          this._material.uniforms.mosaicSize.value.set(v, v);
        }
        this._mosaicSize = v;
      }
    }
  }, {
    key : "opacity",
    get : function() {
      return this._opacity;
    },
    set : function(value) {
      if (this.mosaic) {
        this._mosaicMateiral.uniforms.opacity.value = value;
      } else {
        this._material.opacity = value;
      }
      this._opacity = value;
    }
  }, {
    key : "mosaic",
    get : function() {
      return this._mosaic;
    },
    set : function(num) {
      if (num !== this._mosaic) {
        this._mosaic = num;
        if (num) {
          this._material = this._getMosaicMaterial();
          this._material.uniforms.tDiffuse.value = this._idwRenderTarget.texture;
        } else {
          this._material = this._getBasicMaterial();
          this._material.map = this._idwRenderTarget.texture;
        }
        this.node.children[0].material = this._material;
      }
    }
  }, {
    key : "radius",
    get : function() {
      return this._radius;
    },
    set : function(value) {
      this._radius = value;
      this.refresh();
    }
  }]), e;
}(BaseObject);
LineBase = function(instance) {
  function e(row) {
    r(this, e);
    var container = s(this, instance.call(this, row));
    return container.pathTexture = null, container.pathWidth = 1, container.pathCornerRadius = .3, container.pathCornerSplit = 10, container.pathScrollUV = false, container.pathScrollSpeed = 1, container.pathPlayingTween = null, container.pathUp = new THREE.Vector3(0, 1, 0), container.pathPointList = null, container.pathGeometry = null, container.pathLine = null, container.pathMaterial = new THREE.MeshBasicMaterial({
      transparent : true
    }), container._uvRepeat = [1, 1], container._uvOffset = [0, 0], container._uvRotation = 0, container;
  }
  return o(e, instance), e.prototype.synPathTexture = function(text) {
    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    this.pathTexture = text;
    if (this.pathLine) {
      this.pathLine.material.map = this.pathTexture;
      this.pathLine.material.needsUpdate = true;
      if (t && this.pathLine.material._prev_material) {
        this.pathLine.material._prev_material.map = this.pathTexture;
        this.pathLine.material._prev_material.needsUpdate = true;
      }
    }
  }, e.prototype._synUvTransform = function() {
    if (!this.pathMaterial.uvTransform) {
      this.pathMaterial.uvTransform = new THREE.Matrix3;
    }
    this.pathMaterial.uvTransform.setUvTransform(this._uvOffset[0], this._uvOffset[1], this._uvRepeat[0], this._uvRepeat[1], this._uvRotation, 0, 0);
  }, e.prototype._setupPoints = function(options) {
    var data = options.points;
    if (data) {
      var el = options.spaceType;
      var sel = options.local;
      if (!el && sel && (el = L.Local), data.forEach(function(keyResultUpdates, unbracketed) {
        if (keyResultUpdates.isVector3) {
          data[unbracketed] = keyResultUpdates.toArray();
        }
      }), !options.position && !options.localPosition) {
        var x = this.getCenterPointPos(data, el);
        this.position = this.selfToWorld(x);
      }
      this.addPoints(data, el);
    }
  }, e.prototype._setupPathLine = function(result) {
    var t = this;
    this.scrollUV = Utils.parseValue(result.scrollUV, false);
    this.uvRatio = result.uvRatio || 1;
    this.width = Utils.parseValue(result.width, this.width);
    this.side = Utils.parseValue(result.side, "both");
    this.close = Utils.parseValue(result.close, false);
    var _hasAlpha = Utils.parseValue(result.doubleSide, true);
    this.pathMaterial.side = _hasAlpha ? THREE.DoubleSide : THREE.FrontSide;
    this.pathLine = new THREE.Mesh(this.pathGeometry, this.pathMaterial);
    if (this.pathMaterial.isMeshBasicMaterial) {
      this.pathLine.userData.skipEnvMap = true;
    }
    this.pathLine.addBeforeRenderFunction("pathUpdate", function(canCreateDiscussions, i, isSlidingUp, n, ts, s) {
      if (!ts.uvTransform) {
        ts.uvTransform = new THREE.Matrix3;
      }
      ts.uvTransform.setUvTransform(t._uvOffset[0], t._uvOffset[1], t._uvRepeat[0], t._uvRepeat[1], t._uvRotation, 0, 0);
    });
    var source = result.image;
    if (source) {
      this.style.image = source;
    }
  }, e.prototype._addPathLine = function() {
    this.node.add(this.pathLine);
  }, e.prototype._beforeSetupComplete = function(opts) {
    this._setupPathLine(opts);
    this._setupPoints(opts);
    this._addPathLine();
    if (opts.imageRepeat) {
      this.imageRepeat = opts.imageRepeat;
    }
    if (opts.imageScroll) {
      this.imageScroll = opts.imageScroll;
    }
    if (opts.imageScrollSpeed) {
      this.imageScrollSpeed = opts.imageScrollSpeed;
    }
  }, e.prototype._updateByPoints = function() {
    this.node.updateWorldMatrix(true, false);
    if (this._points.length >= 2) {
      this.pathPointList.set(this._points.map(function(resourcesOrReports) {
        return (new THREE.Vector3).fromArray(resourcesOrReports);
      }), this.pathCornerRadius, this.pathCornerSplit, this.pathUp, this.close);
    }
    if (this.pathGeometry) {
      this.pathGeometry.boundingBox = null;
      this.pathGeometry.boundingSphere = null;
    }
  }, e.prototype.updatePath = function(newPath) {
    if (this.pathScrollUV && this.pathMaterial) {
      var scaledImgSize = this.pathScrollSpeed * newPath;
      return this.rotateScrollDirection ? this._uvOffset[1] -= scaledImgSize : this._uvOffset[0] -= scaledImgSize, true;
    }
    return false;
  }, e.prototype.update = function(path) {
    var orientations = instance.prototype.update.call(this, path);
    return orientations = orientations | this.updatePath(path);
  }, e.prototype.play = function(options) {
    var time = (options = options || {}).time || 1e3;
    var prgSt = Utils.parseValue(options.startProgress, 0);
    var putProgress = Utils.parseValue(options.endProgress, 1);
    var easing = options.lerpType || alphaIndex0.Linear.None;
    var complete = options.complete;
    var cfg = this;
    var obj = {
      progress : prgSt
    };
    var target = {
      progress : putProgress
    };
    this.pathPlayingTween = (new TWEEN.Tween(obj)).to(target, time).easing(easing).onUpdate(function() {
      cfg.pathGeometry.update(cfg.pathPointList, {
        width : cfg.pathWidth,
        radius : cfg.pathWidth,
        arrow : !!cfg.arrowFlag,
        progress : this._object.progress
      });
      if (cfg.app) {
        cfg.app.rendererManager._mainRenderer.dirty();
      }
    }).onComplete(function() {
      if (complete) {
        complete.call(cfg);
      }
    }).start();
  }, e.prototype.stop = function() {
    if (this.pathPlayingTween) {
      this.pathPlayingTween.stop();
      this.pathPlayingTween = null;
    }
  }, e.prototype.toJSON = function() {
    var args = instance.prototype.toJSON.call(this);
    return args.image = this.image, args.scrollUV = this.scrollUV, args.points = this.points, args;
  }, e.prototype._setupResources = function(canCreateDiscussions) {
    if (this.pathLine) {
      this.pathLine.material = this.pathMaterial;
      this._addPathLine();
    }
  }, e.prototype.unloadResource = function() {
    instance.prototype.unloadResource.call(this);
    this.clearPoints();
  }, n(e, [{
    key : "rotateScrollDirection",
    set : function(num) {
      this._uvRotation = num ? Math.PI / 2 : 0;
      this._synUvTransform();
    },
    get : function() {
      return 0 !== this._uvRotation;
    }
  }, {
    key : "imageRepeat",
    set : function(num) {
      this._uvRepeat[0] = num[0];
      this._uvRepeat[1] = num[1];
      this._synUvTransform();
    },
    get : function() {
      return this._uvRepeat.slice(0);
    }
  }, {
    key : "imageScroll",
    set : function(num) {
      this.pathScrollUV = num;
      this.tickable = true;
    },
    get : function() {
      return this.pathScrollUV;
    }
  }, {
    key : "imageScrollSpeed",
    set : function(v) {
      this.pathScrollSpeed = THING.Math.clamp(v, -99, 99);
    },
    get : function() {
      return this.pathScrollSpeed;
    }
  }, {
    key : "isOutdoors",
    get : function() {
      var parent = this._parent;
      for (; parent; parent = parent._parent) {
        if (parent.isBuilding) {
          return false;
        }
      }
      return true;
    }
  }, {
    key : "useTexture",
    set : function(name) {
      var material = this.pathLine.material;
      material.map = name ? this.pathTexture : null;
      material.needsUpdate = true;
    },
    get : function() {
      return null !== this.pathLine.material.map;
    }
  }, {
    key : "width",
    set : function(num) {
      if (this.pathWidth !== num) {
        this.pathWidth = num;
        this._updateByPoints();
      }
    },
    get : function() {
      return this.pathWidth;
    }
  }, {
    key : "cornerRadius",
    set : function(num) {
      if (this.pathCornerRadius !== num) {
        this.pathCornerRadius = num;
        this._updateByPoints();
      }
    },
    get : function() {
      return this.pathCornerRadius;
    }
  }, {
    key : "cornerSegments",
    set : function(num) {
      if (this.pathCornerSplit !== num) {
        this.pathCornerSplit = num;
        this._updateByPoints();
      }
    },
    get : function() {
      return this.pathCornerSplit;
    }
  }, {
    key : "length",
    get : function() {
      if (this._points.length <= 1) {
        return 0;
      }
      var sum = 0;
      var b = this._points[0];
      var i = 1;
      for (; i < this._points.length; i++) {
        var a = this._points[i];
        sum = sum + THING.Math.getDistance(a, b);
        b = a;
      }
      return sum;
    }
  }, {
    key : "cornerSplit",
    set : function(num) {
      THING.Utils.warn("[LineBase] Please use '.cornerSegments' to replace '.cornerSplit'");
      this.cornerSegments = num;
    },
    get : function() {
      return THING.Utils.warn("[LineBase] Please use '.cornerSegments' to replace '.cornerSplit'"), this.cornerSegments;
    }
  }, {
    key : "uvRatio",
    set : function(num) {
      this._uvRepeat[0] = 1 / num;
    }
  }, {
    key : "scrollUV",
    set : function(num) {
      this.pathScrollUV = num;
      if (num && 0 == this.tickable) {
        this.tickable = true;
      }
    },
    get : function() {
      return this.pathScrollUV;
    }
  }, {
    key : "scrollSpeed",
    set : function(f) {
      this.pathScrollSpeed = THING.Math.clamp(f / 10, -99, 99);
    },
    get : function() {
      return 10 * this.pathScrollSpeed;
    }
  }]), e;
}(Al);
Wl = function() {
  function a(value) {
    r(this, a);
    this.app = value;
    this._points = [];
  }
  return a.prototype.set = function(value, a, v, r) {
    this._points = value;
  }, n(a, [{
    key : "vertices",
    get : function() {
      var checked_node_a = [];
      var i = 0;
      for (; i < this._points.length; i++) {
        checked_node_a.push(Utils.parseVector3(this._points[i]));
      }
      return checked_node_a;
    }
  }]), a;
}();
Line = function(callback) {
  function render(row) {
    r(this, render);
    var container = s(this, callback.call(this, row));
    return container.dotNode = null, container.pathGeometry = new THREE.BufferGeometry, container.pathGeometry.update = function(type, source) {
    }, container.dotGeometry = null, container.dotMaterial = null, container.pathPointList = new Wl, container;
  }
  return o(render, callback), render.prototype._updateByPoints = function() {
    callback.prototype._updateByPoints.call(this);
    var vs = this.pathPointList.vertices;
    if (vs.length) {
      this.pathGeometry.setFromPoints(vs);
      this.pathLine.computeLineDistances();
      if (this.dotGeometry) {
        this.dotGeometry.setFromPoints(vs);
      }
      this.node.setFrustumCulled(false);
    }
  }, render.prototype._setupPathLine = function(options) {
    var linkMaterial;
    var FancyUpload2 = options.style || {};
    var completeTitleOpacity = options.lineOpacity || 1;
    var inputWin = Utils.parseValue(options.lineDashSize || FancyUpload2.lineDashSize, 0);
    var winRef = Utils.parseValue(options.lineGapSize || FancyUpload2.lineGapSize, 0);
    var width = options.lineWidth || 1;
    var HeadsetColor = options.color || 255;
    var vs = this.pathPointList.vertices;
    linkMaterial = inputWin || winRef ? new THREE.LineDashedMaterial({
      color : HeadsetColor,
      opacity : completeTitleOpacity,
      dashSize : inputWin,
      gapSize : winRef,
      linewidth : width,
      transparent : true
    }) : new THREE.LineBasicMaterial({
      color : HeadsetColor,
      opacity : completeTitleOpacity,
      linewidth : width,
      transparent : true
    });
    this.pathGeometry.setFromPoints(vs);
    this.pathLine = new THREE.Line(this.pathGeometry, linkMaterial);
    this.pathLine.computeLineDistances();
    var _titleBarColor = options.dotColor || 16777215;
    var movement = options.dotSize;
    if (movement) {
      this.dotGeometry = (new THREE.BufferGeometry).setFromPoints(vs);
      this.dotMaterial = new THREE.PointsMaterial({
        color : _titleBarColor,
        size : movement,
        sizeAttenuation : false
      });
      this.dotNode = new THREE.Points(this.dotGeometry, this.dotMaterial);
      this.node.add(this.dotNode);
    }
  }, render.prototype.showLines = function(isBlobDisplay) {
    this.pathLine.visible = isBlobDisplay;
  }, render.prototype.showPoints = function(isBlobDisplay) {
    this.dotNode.visible = isBlobDisplay;
  }, n(render, [{
    key : "isLine",
    get : function() {
      return true;
    }
  }]), render;
}(LineBase);
ql = function() {
  function move() {
    r(this, move);
    this.pos = new THREE.Vector3;
    this.dir = new THREE.Vector3;
    this.right = new THREE.Vector3;
    this.up = new THREE.Vector3;
    this.dist = 0;
    this.widthScale = 1;
    this.sharp = false;
  }
  return move.prototype.lerpPathPoints = function(a, b, alpha) {
    this.pos.lerpVectors(a.pos, b.pos, alpha);
    this.dir.lerpVectors(a.dir, b.dir, alpha);
    this.up.lerpVectors(a.up, b.up, alpha);
    this.right.lerpVectors(a.right, b.right, alpha);
    this.dist = (b.dist - a.dist) * alpha + a.dist;
    this.widthScale = (b.widthScale - a.widthScale) * alpha + a.widthScale;
  }, move.prototype.copy = function(value) {
    this.pos.copy(value.pos);
    this.dir.copy(value.dir);
    this.up.copy(value.up);
    this.right.copy(value.right);
    this.dist = value.dist;
    this.widthScale = value.widthScale;
  }, move;
}();
Xl = new THREE.Vector3, Jl = new THREE.Vector3, Yl = new THREE.Vector3, Ql = new THREE.Matrix4, Zl = new THREE.QuadraticBezierCurve3;
var Kl = function() {
  function f() {
    r(this, f);
    this.array = [];
    this.count = 0;
  }
  return f.prototype.set = function(data) {
    var titleRow = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .1;
    var auctionColour = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10;
    var args = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
    var n = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    if ((data = data.slice(0)).length < 2) {
      return console.warn("PathPointList: points length less than 2."), void(this.count = 0);
    }
    if (n && !data[0].equals(data[data.length - 1])) {
      data.push((new THREE.Vector3).copy(data[0]));
    }
    var i = 0;
    var length = data.length;
    for (; i < length; i++) {
      if (0 === i) {
        this._start(data[i], data[i + 1], args);
      } else {
        if (i === length - 1) {
          if (n) {
            this._corner(data[i], data[1], titleRow, auctionColour, args);
            var dist = this.array[0].dist;
            this.array[0].copy(this.array[this.count - 1]);
            this.array[0].dist = dist;
          } else {
            this._end(data[i]);
          }
        } else {
          this._corner(data[i], data[i + 1], titleRow, auctionColour, args);
        }
      }
    }
  }, f.prototype.distance = function() {
    return this.count > 0 ? this.array[this.count - 1].dist : 0;
  }, f.prototype._getByIndex = function(index) {
    return this.array[index] || (this.array[index] = new ql), this.array[index];
  }, f.prototype._start = function(param, t, event) {
    this.count = 0;
    var c = this._getByIndex(this.count);
    if (c.pos.copy(param), c.dir.subVectors(t, param), event) {
      c.up.copy(event);
    } else {
      var a = Number.MAX_VALUE;
      var input = Math.abs(c.dir.x);
      var b = Math.abs(c.dir.y);
      var g = Math.abs(c.dir.z);
      if (input < a) {
        a = input;
        c.up.set(1, 0, 0);
      }
      if (b < a) {
        a = b;
        c.up.set(0, 1, 0);
      }
      if (g < a) {
        c.up.set(0, 0, 1);
      }
    }
    c.right.crossVectors(c.dir, c.up).normalize();
    c.up.crossVectors(c.right, c.dir).normalize();
    c.dist = 0;
    c.widthScale = 1;
    c.sharp = false;
    c.dir.normalize();
    this.count++;
  }, f.prototype._end = function(t) {
    var _this = this.array[this.count - 1];
    var c = this._getByIndex(this.count);
    c.pos.copy(t);
    c.dir.subVectors(t, _this.pos);
    var dx = c.dir.length();
    c.dir.normalize();
    c.up.copy(_this.up);
    var vec = Xl.crossVectors(_this.dir, c.dir);
    if (vec.length() > Number.EPSILON) {
      vec.normalize();
      var theta = Math.acos(Math.min(Math.max(_this.dir.dot(c.dir), -1), 1));
      c.up.applyMatrix4(Ql.makeRotationAxis(vec, theta));
    }
    c.right.crossVectors(c.dir, c.up).normalize();
    c.dist = _this.dist + dx;
    c.widthScale = 1;
    c.sharp = false;
    this.count++;
  }, f.prototype._corner = function(e, file, row, col, options) {
    if (row > 0 && col > 0) {
      var line = function(endVec3, start, target, y, asDegrees, st) {
        var normal = Xl.subVectors(start, endVec3);
        var a = Jl.subVectors(target, start);
        var torsion = normal.length();
        var u = a.length();
        normal.normalize();
        a.normalize();
        var i = Math.min(.999999 * (asDegrees ? torsion / 2 : torsion), y);
        st.v0.copy(start).sub(normal.multiplyScalar(i));
        st.v1.copy(start);
        var b = Math.min(u / 2 * .999999, y);
        return st.v2.copy(start).add(a.multiplyScalar(b)), st;
      }(this.array[this.count - 1].pos, e, file, row, this.count - 1 == 0, Zl).getPoints(col);
      var j = 0;
      for (; j < col; j++) {
        this._sharpCorner(line[j], line[j + 1], options, 0 === j ? 1 : 0);
      }
      if (!line[col].equals(file)) {
        this._sharpCorner(line[col], file, options, 2);
      }
    } else {
      this._sharpCorner(e, file, options, 0, true);
    }
  }, f.prototype._sharpCorner = function(b, target, x) {
    var object = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
    var n = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    var _this = this.array[this.count - 1];
    var c = this._getByIndex(this.count);
    var a = Xl.subVectors(b, _this.pos);
    var d = Jl.subVectors(target, b);
    var dx = a.length();
    if (a.normalize(), d.normalize(), c.pos.copy(b), 1 === object ? c.dir.copy(a) : 2 === object ? c.dir.copy(d) : (c.dir.addVectors(a, d), c.dir.normalize()), x) {
      if (1 === c.dir.dot(x)) {
        c.right.crossVectors(d, x).normalize();
      } else {
        c.right.crossVectors(c.dir, x).normalize();
      }
      c.up.crossVectors(c.right, c.dir).normalize();
    } else {
      c.up.copy(_this.up);
      var vec = Yl.crossVectors(_this.dir, c.dir);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        var theta = Math.acos(Math.min(Math.max(_this.dir.dot(c.dir), -1), 1));
        c.up.applyMatrix4(Ql.makeRotationAxis(vec, theta));
      }
      c.right.crossVectors(c.dir, c.up).normalize();
    }
    c.dist = _this.dist + dx;
    var p = a.dot(d);
    c.widthScale = Math.min(1 / Math.sqrt((1 + p) / 2), 1.415) || 1;
    c.sharp = Math.abs(p - 1) > .05 && n;
    this.count++;
  }, f;
}();
$l = function(selector) {
  function d() {
    var data = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 3e3;
    var limit = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    r(this, d);
    var utils = s(this, selector.call(this));
    return isNaN(data) ? utils._initByData(data.pathPointList, data.options, data.usage, limit) : utils._initByMaxVertex(data, limit), utils;
  }
  return o(d, selector), d.prototype._initByMaxVertex = function(len, parentOffsetOrigin) {
    this.setAttribute("position", (new THREE.BufferAttribute(new Float32Array(3 * len), 3)).setUsage(THREE.DynamicDrawUsage));
    this.setAttribute("normal", (new THREE.BufferAttribute(new Float32Array(3 * len), 3)).setUsage(THREE.DynamicDrawUsage));
    this.setAttribute("uv", (new THREE.BufferAttribute(new Float32Array(2 * len), 2)).setUsage(THREE.DynamicDrawUsage));
    if (parentOffsetOrigin) {
      this.setAttribute("uv2", (new THREE.BufferAttribute(new Float32Array(2 * len), 2)).setUsage(THREE.DynamicDrawUsage));
    }
    this.drawRange.start = 0;
    this.drawRange.count = 0;
    this.setIndex(len > 65536 ? new THREE.Uint32BufferAttribute(3 * len, 1) : new THREE.Uint16BufferAttribute(3 * len, 1));
  }, d.prototype._initByData = function(e) {
    var c2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    var blendMode = arguments[2];
    var parentOriginOffset = arguments[3];
    var m = eu(e, c2, parentOriginOffset);
    if (m && 0 !== m.count) {
      this.setAttribute("position", (new THREE.BufferAttribute(new Float32Array(m.position), 3)).setUsage(blendMode || THREE.StaticDrawUsage));
      this.setAttribute("normal", (new THREE.BufferAttribute(new Float32Array(m.normal), 3)).setUsage(blendMode || THREE.StaticDrawUsage));
      this.setAttribute("uv", (new THREE.BufferAttribute(new Float32Array(m.uv), 2)).setUsage(blendMode || THREE.StaticDrawUsage));
      if (parentOriginOffset) {
        this.setAttribute("uv2", (new THREE.BufferAttribute(new Float32Array(m.uv2), 2)).setUsage(blendMode || THREE.StaticDrawUsage));
      }
      this.setIndex(m.position.length / 3 > 65536 ? new THREE.Uint32BufferAttribute(m.indices, 1) : new THREE.Uint16BufferAttribute(m.indices, 1));
    } else {
      this._initByMaxVertex(2, parentOriginOffset);
    }
  }, d.prototype.update = function(type) {
    var Slot = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    var sd = !!this.getAttribute("uv2");
    var p = eu(type, Slot, sd);
    if (p) {
      this._updateAttributes(p.position, p.normal, p.uv, sd ? p.uv2 : null, p.indices);
      this.drawRange.count = p.count;
    } else {
      this.drawRange.count = 0;
    }
  }, d.prototype._resizeAttribute = function(name, t) {
    var attribute = this.getAttribute(name);
    for (; attribute.array.length < t;) {
      var ylen = attribute.array.length;
      var value = new THREE.BufferAttribute(new Float32Array(2 * ylen), attribute.itemSize, attribute.normalized);
      value.name = attribute.name;
      value.usage = attribute.usage;
      this.setAttribute(name, value);
      attribute = value;
    }
  }, d.prototype._resizeIndex = function(type) {
    var a = this.getIndex();
    for (; a.array.length < type;) {
      var rl = a.array.length;
      var value = new THREE.BufferAttribute(2 * rl > 65535 ? new Uint32Array(2 * rl) : new Uint16Array(2 * rl), 1);
      value.name = a.name;
      value.usage = a.usage;
      this.setIndex(value);
      a = value;
    }
  }, d.prototype._updateAttributes = function(e, id, result, r, p) {
    this._resizeAttribute("position", e.length);
    var index = this.getAttribute("position");
    index.array.set(e, 0);
    index.updateRange.count = e.length;
    index.needsUpdate = true;
    this._resizeAttribute("normal", id.length);
    var attr = this.getAttribute("normal");
    attr.array.set(id, 0);
    attr.updateRange.count = id.length;
    attr.needsUpdate = true;
    this._resizeAttribute("uv", result.length);
    var self = this.getAttribute("uv");
    if (self.array.set(result, 0), self.updateRange.count = result.length, self.needsUpdate = true, r) {
      this._resizeAttribute("uv2", r.length);
      var index = this.getAttribute("uv2");
      index.array.set(r, 0);
      index.updateRange.count = r.length;
      index.needsUpdate = true;
    }
    this._resizeIndex(p.length);
    var a = this.getIndex();
    a.set(p, 0);
    a.updateRange.count = p.length;
    a.needsUpdate = true;
  }, d;
}(THREE.BufferGeometry);
function eu(data, obj) {
  function parse(e) {
    var quiet = 0 === that.length;
    var r = e.sharp && !quiet;
    var y = e.dist / height;
    var x = e.dist / width;
    var center = e.dir;
    var data = e.up;
    var v = e.right;
    if ("left" !== undefined ? node.copy(v).multiplyScalar(distance * e.widthScale) : node.set(0, 0, 0), "right" !== undefined ? p.copy(v).multiplyScalar(-distance * e.widthScale) : p.set(0, 0, 0), node.add(e.pos), p.add(e.pos), r) {
      v.fromArray(that, that.length - 6).sub(p);
      val.fromArray(that, that.length - 3).sub(node);
      var length = v.length() - val.length();
      var v1 = void 0;
      var start = void 0;
      if (length > 0) {
        v1 = v;
        start = p;
      } else {
        v1 = val;
        start = node;
      }
      event.copy(v1).setLength(Math.abs(length)).add(start);
      var value = d.copy(start).sub(event).normalize().dot(center) * d.copy(start).sub(event).length() * 2;
      d.copy(center).setLength(value).add(event);
      if (length > 0) {
        that.push(event.x, event.y, event.z, node.x, node.y, node.z, p.x, p.y, p.z, node.x, node.y, node.z, d.x, d.y, d.z, node.x, node.y, node.z);
        x = x + 6;
        path.push(x - 6, x - 8, x - 7, x - 6, x - 7, x - 5, x - 4, x - 6, x - 5, x - 2, x - 4, x - 1);
        filesFoundWhileScanning = filesFoundWhileScanning + 12;
      } else {
        that.push(p.x, p.y, p.z, event.x, event.y, event.z, p.x, p.y, p.z, node.x, node.y, node.z, p.x, p.y, p.z, d.x, d.y, d.z);
        x = x + 6;
        path.push(x - 6, x - 8, x - 7, x - 6, x - 7, x - 5, x - 6, x - 5, x - 3, x - 2, x - 3, x - 1);
        filesFoundWhileScanning = filesFoundWhileScanning + 12;
      }
      helpers.push(data.x, data.y, data.z, data.x, data.y, data.z, data.x, data.y, data.z, data.x, data.y, data.z, data.x, data.y, data.z, data.x, data.y, data.z);
      ret.push(y - t, 0, y - t, 1, y, 0, y, 1, y + t, 0, y + t, 1);
      if (i) {
        ctx.push(x - lineWidth, 0, x - lineWidth, 1, x, 0, x, 1, x + lineWidth, 0, x + lineWidth, 1);
      }
    } else {
      that.push(p.x, p.y, p.z, node.x, node.y, node.z);
      helpers.push(data.x, data.y, data.z, data.x, data.y, data.z);
      ret.push(y, 0, y, 1);
      if (i) {
        ctx.push(x, 0, x, 1);
      }
      x = x + 2;
      if (!quiet) {
        path.push(x - 2, x - 4, x - 3, x - 2, x - 3, x - 1);
        filesFoundWhileScanning = filesFoundWhileScanning + 6;
      }
    }
  }
  function tick(e) {
    var center = e.dir;
    var data = e.up;
    var v = e.right;
    var y = e.dist / height;
    var w = e.dist / width;
    if ("left" !== undefined) {
      node.copy(v).multiplyScalar(2 * distance);
    } else {
      node.set(0, 0, 0);
    }
    if ("right" !== undefined) {
      p.copy(v).multiplyScalar(2 * -distance);
    } else {
      p.set(0, 0, 0);
    }
    element.copy(center).setLength(3 * distance);
    node.add(e.pos);
    p.add(e.pos);
    element.add(e.pos);
    that.push(p.x, p.y, p.z, node.x, node.y, node.z, element.x, element.y, element.z);
    helpers.push(data.x, data.y, data.z, data.x, data.y, data.z, data.x, data.y, data.z);
    ret.push(y, "both" !== undefined ? "right" !== undefined ? -2 : 0 : -.5, y, "both" !== undefined ? "left" !== undefined ? 2 : 0 : 1.5, y + 1.5, "both" !== undefined ? 0 : .5);
    if (i) {
      ctx.push(w, "both" !== undefined ? "right" !== undefined ? -2 : 0 : -.5, w, "both" !== undefined ? "left" !== undefined ? 2 : 0 : 1.5, w + 1.5 * dx / width, "both" !== undefined ? 0 : .5);
    }
    x = x + 3;
    path.push(x - 1, x - 3, x - 2);
    filesFoundWhileScanning = filesFoundWhileScanning + 3;
  }
  var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
  var dx = obj.width || .1;
  var index = void 0 !== obj.progress ? obj.progress : 1;
  var e = void 0 === obj.arrow || obj.arrow;
  var undefined = void 0 !== obj.side ? obj.side : "both";
  var distance = dx / 2;
  var height = "both" !== undefined ? dx / 2 : dx;
  var width = data.distance();
  var offset = index * width;
  if (0 == width) {
    return null;
  }
  var t = distance / height;
  var lineWidth = distance / width;
  var filesFoundWhileScanning = 0;
  var that = [];
  var helpers = [];
  var ret = [];
  var ctx = [];
  var path = [];
  var x = 0;
  var node = new THREE.Vector3;
  var p = new THREE.Vector3;
  var v = new THREE.Vector3;
  var val = new THREE.Vector3;
  var event = new THREE.Vector3;
  var d = new THREE.Vector3;
  var element = new THREE.Vector3;
  var result = void 0;
  if (offset > 0) {
    var i = 0;
    for (; i < data.count; i++) {
      var a = data.array[i];
      if (a.dist > offset) {
        var b = data.array[i - 1];
        result = new ql;
        var duration = (offset - b.dist) / (a.dist - b.dist);
        result.lerpPathPoints(b, a, duration);
        parse(result);
        break;
      }
      parse(a);
    }
  } else {
    result = data.array[0];
  }
  return e && tick(result = result || data.array[data.count - 1]), {
    position : that,
    normal : helpers,
    uv : ret,
    uv2 : ctx,
    indices : path,
    count : filesFoundWhileScanning
  };
}
var tu = function(e) {
  function i() {
    var row = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1e3;
    var end = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return r(this, i), s(this, e.call(this, row, end));
  }
  return o(i, e), i.prototype._initByData = function(e) {
    var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    var blendMode = arguments[2];
    var parentOriginOffset = arguments[3];
    var m = iu(e, n, parentOriginOffset);
    if (m && 0 !== m.count) {
      this.setAttribute("position", (new THREE.BufferAttribute(new Float32Array(m.position), 3)).setUsage(blendMode || THREE.StaticDrawUsage));
      this.setAttribute("normal", (new THREE.BufferAttribute(new Float32Array(m.normal), 3)).setUsage(blendMode || THREE.StaticDrawUsage));
      this.setAttribute("uv", (new THREE.BufferAttribute(new Float32Array(m.uv), 2)).setUsage(blendMode || THREE.StaticDrawUsage));
      if (parentOriginOffset) {
        this.setAttribute("uv2", (new THREE.BufferAttribute(new Float32Array(m.uv2), 2)).setUsage(blendMode || THREE.StaticDrawUsage));
      }
      this.setIndex(m.position.length / 3 > 65536 ? new THREE.Uint32BufferAttribute(m.indices, 1) : new THREE.Uint16BufferAttribute(m.indices, 1));
    } else {
      this._initByMaxVertex(2, parentOriginOffset);
    }
  }, i.prototype.update = function(type) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    var sd = !!this.getAttribute("uv2");
    var p = iu(type, t, sd);
    if (p) {
      this._updateAttributes(p.position, p.normal, p.uv, sd ? p.uv2 : null, p.indices);
      this.drawRange.count = p.count;
    } else {
      this.drawRange.count = 0;
    }
  }, i;
}($l);
function iu(obj, options) {
  function fn(data, amount, tess) {
    var n = 0 === retVal.length;
    var v = data.dist / w;
    var err = data.dist / scale;
    var j = 0;
    for (; j <= tess; j++) {
      var min_j = j;
      if (min_j == tess) {
        min_j = 0;
      }
      vector.copy(data.up).applyAxisAngle(data.dir, lAcum + 2 * Math.PI * min_j / tess).normalize();
      retVal.push(data.pos.x + vector.x * amount * data.widthScale, data.pos.y + vector.y * amount * data.widthScale, data.pos.z + vector.z * amount * data.widthScale);
      vectors.push(vector.x, vector.y, vector.z);
      texCoord.push(v, j / tess);
      if (i) {
        uv.push(err, j / tess);
      }
      code++;
    }
    if (!n) {
      var offset = code - 2 * (tess + 1);
      var second = code - (tess + 1);
      var duration = 0;
      for (; duration < tess; duration++) {
        stylebuff.push(second + duration, offset + duration, offset + duration + 1, second + duration, offset + duration + 1, second + duration + 1);
        filesFoundWhileScanning = filesFoundWhileScanning + 6;
      }
    }
  }
  var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
  var delta = options.radius || .1;
  var aaWidth = void 0 !== options.progress ? options.progress : 1;
  var $curVal = Math.max(2, options.radialSegments || 8);
  var lAcum = options.startRad || 0;
  var w = 2 * delta * Math.PI;
  var scale = obj.distance();
  var width = aaWidth * scale;
  if (0 == width) {
    return null;
  }
  var filesFoundWhileScanning = 0;
  var retVal = [];
  var vectors = [];
  var texCoord = [];
  var uv = [];
  var stylebuff = [];
  var code = 0;
  var vector = new THREE.Vector3;
  if (width > 0) {
    var i = 0;
    for (; i < obj.count; i++) {
      var b = obj.array[i];
      if (b.dist > width) {
        var a = obj.array[i - 1];
        var E = new ql;
        var colAlpha = (width - a.dist) / (b.dist - a.dist);
        E.lerpPathPoints(a, b, colAlpha);
        fn(E, delta, $curVal);
        break;
      }
      fn(b, delta, $curVal);
    }
  }
  return {
    position : retVal,
    normal : vectors,
    uv : texCoord,
    uv2 : uv,
    indices : stylebuff,
    count : filesFoundWhileScanning
  };
}
var ru = function(context) {
  function d(row) {
    r(this, d);
    var defaults = s(this, context.call(this, row));
    return defaults.arrowFlag = true, defaults.side = "both", defaults.pathGeometry = new $l, defaults.pathPointList = new Kl, defaults;
  }
  return o(d, context), d.prototype._updateByPoints = function() {
    context.prototype._updateByPoints.call(this);
    this.pathGeometry.update(this.pathPointList, {
      width : this.pathWidth,
      side : this.side,
      arrow : this.arrowFlag
    });
    this.pathGeometry.computeBoundingSphere();
  }, d.prototype.setup = function(request) {
    var obj1 = Utils.parseValue(request.arrowFlag, request.arrowCap);
    this.arrowFlag = Utils.parseValue(obj1, true);
    context.prototype.setup.call(this, request);
  }, n(d, [{
    key : "progress",
    set : function(v) {
      this.pathGeometry.update(this.pathPointList, {
        width : this.pathWidth,
        arrow : this.arrowFlag,
        side : this.side,
        progress : THING.Math.clamp(v, 0, 1)
      });
    }
  }, {
    key : "scrollUVRange",
    set : function(value) {
      var length = this.length / this.pathWidth;
      this.uvRatio = length * value;
    }
  }, {
    key : "arrowCap",
    set : function(num) {
      this.arrowFlag = num;
      this.pathGeometry.update(this.pathPointList, {
        width : this.pathWidth,
        arrow : this.arrowFlag,
        side : this.side
      });
    },
    get : function() {
      return this.arrowFlag;
    }
  }, {
    key : "isRouteLine",
    get : function() {
      return true;
    }
  }]), d;
}(LineBase);
nu = function(callback) {
  function d(row) {
    r(this, d);
    var container = s(this, callback.call(this, row));
    return container.pathWidth = .2, container.pathRadialSegments = 8, container.pathStartRad = 0, container.pathGeometry = new tu, container.pathPointList = new Kl, container.pathUp = void 0, container.pathMaterial = new THREE.MeshStandardMaterial({
      transparent : true,
      roughness : .5,
      metalness : .5
    }), container;
  }
  return o(d, callback), d.prototype._setupPathLine = function(children) {
    children = children || {};
    callback.prototype._setupPathLine.call(this, children);
  }, d.prototype._updateByPoints = function() {
    callback.prototype._updateByPoints.call(this);
    this.pathGeometry.update(this.pathPointList, {
      radius : this.pathWidth,
      radialSegments : this.pathRadialSegments,
      startRad : this.pathStartRad
    });
    this.pathGeometry.computeBoundingSphere();
  }, n(d, [{
    key : "progress",
    set : function(v) {
      this.pathGeometry.update(this.pathPointList, {
        radius : this.pathWidth,
        radialSegments : this.pathRadialSegments,
        progress : THING.Math.clamp(v, 0, 1),
        startRad : this.pathStartRad
      });
    }
  }, {
    key : "scrollUVRange",
    set : function(value) {
      var length = this.length / (2 * this.pathWidth * Math.PI);
      this.uvRatio = length * value;
    }
  }, {
    key : "isPolygonLine",
    get : function() {
      return true;
    }
  }]), d;
}(LineBase);
ou = function(a) {
  function i(value) {
    r(this, i);
    var container = s(this, a.call(this, value));
    return container._pointSize = 1, container._pointsMesh = null, container;
  }
  return o(i, a), i.prototype._updateByPoints = function() {
    this.app.resourceManager.remove(this._pointsMesh);
    var particles = (new THREE.BufferGeometry).setFromPoints(this._points);
    var pMaterial = new THREE.PointsMaterial({
      size : this._pointSize,
      sizeAttenuation : false
    });
    this._pointsMesh = new THREE.Points(particles, pMaterial);
    this.node.add(this._pointsMesh);
  }, i.prototype._beforeSetupComplete = function(instance) {
    this._pointSize = instance.pointSize || this._pointSize;
    var data = instance.points;
    if (data) {
      this.addPoints(data);
    }
  }, i;
}(Al);
su = function t() {
  r(this, t);
  this.strId = "";
  this.fPPAfterImageValue = 0;
  this.listGroups = new Array;
  var f = new au;
  this.listGroups[0] = f;
  this._attr = "ParticleData";
};
su.prototype = {
  getAttr : function() {
    return this._attr;
  }
};
var au = function f() {
  r(this, f);
  this.strId = "";
  this.texture = new uu;
  this.fFixedTimeStep = .33;
  this.strUseMesh = "false";
  this.strMeshUrl = "BuildIn/Box";
  this.arrayMeshParams = new Array;
  this.arrayMeshParams.push(1);
  this.arrayMeshParams.push(1);
  this.arrayMeshParams.push(1);
  this.arrayMeshParams.push(1);
  this.arrayMeshParams.push(1);
  this.arrayMeshParams.push(1);
  this.strHasPerspective = "true";
  this.strIsColorize = "true";
  this.iBlendingMode = 1;
  this.strIsTransparent = "true";
  this.fAlphaTest = 0;
  this.strIsDepthWrite = "false";
  this.strIsDepthTest = "false";
  this.strIsFog = "false";
  this.strEnableTrail = "false";
  this.textureTrail = new uu;
  this.fTrailLife = .5;
  this.fTrailWidthStart = 1;
  this.fTrailWidthEnd = 1;
  this.fScale = window.innerHeight / 2;
  this.iMaxParticleCount = 500;
  this.vec4Quaternion = new THREE.Vector4(0, 0, 0, 1);
  this.listEmitters = new Array;
  var t = new lu;
  this.listEmitters[0] = t;
};
lu = function render() {
  r(this, render);
  this.strId = "";
  this.iDistribution = 1;
  this.iParticleCount = 100;
  this.fDuration = -1;
  this.strIsStatic = "false";
  this.strIsLookAtCamera = "false";
  this.strIsLookAtCameraOnlyY = "false";
  this.fActiveMultiplier = 1;
  this.iDirection = 1;
  this.maxAge = new cu;
  this.position = new hu;
  this.velocity = new pu;
  this.acceleration = new du;
  this.drag = new fu;
  this.wiggle = new mu;
  this.rotation = new vu;
  this.trail = new gu;
  this.listColor = new Array;
  var t = new yu;
  this.listColor[0] = t;
  this.listOpacity = new Array;
  var i = new bu;
  this.listOpacity[0] = i;
  this.listSize = new Array;
  var n = new _u;
  this.listSize[0] = n;
  this.listAngle = new Array;
  var o = new xu;
  this.listAngle[0] = o;
};
uu = function load() {
  r(this, load);
  this.name = "32x32_star.png";
  this.url = "http://static.3dmomoda.com/textures/18092617nyspq5moaka1i2fhvs1hh66s.png";
  this.vec2Frames = new THREE.Vector2(1, 1);
  this.iFrameCount = 1;
  this.iLoop = 1;
};
cu = function a() {
  r(this, a);
  this.fValue = 1;
  this.fSpread = 1;
};
hu = function v() {
  r(this, v);
  this.vec3Value = new THREE.Vector3(0, 0, 0);
  this.vec3Spread = new THREE.Vector3(0, 0, 0);
  this.vec3SpreadClamp = new THREE.Vector3(0, 0, 0);
  this.fRadius = 0;
  this.vec3RadiusScale = new THREE.Vector3(1, 1, 1);
  this.iDistribution = 1;
  this.strIsRandomise = "false";
};
pu = function v() {
  r(this, v);
  this.vec3Value = new THREE.Vector3(0, 10, 0);
  this.vec3Spread = new THREE.Vector3(10, 0, 10);
  this.iDistribution = 1;
  this.strIsRandomise = "false";
};
du = function v() {
  r(this, v);
  this.vec3Value = new THREE.Vector3(0, 0, 0);
  this.vec3Spread = new THREE.Vector3(0, 0, 0);
  this.iDistribution = 1;
  this.strIsRandomise = "false";
};
fu = function t() {
  r(this, t);
  this.fValue = 0;
  this.fSpread = 0;
  this.strIsRandomise = "false";
};
mu = function a() {
  r(this, a);
  this.fValue = 0;
  this.fSpread = 0;
};
gu = function a() {
  r(this, a);
  this.fValue = 0;
  this.fSpread = 0;
  this.fStep = 0;
  this.fStepSpread = 0;
};
vu = function v() {
  r(this, v);
  this.vec3Axis = new THREE.Vector3(0, 0, 0);
  this.vec3AxisSpread = new THREE.Vector3(0, 0, 0);
  this.fAngle = 0;
  this.fAngleSpread = 0;
  this.strIsStatic = "false";
  this.vec3Center = new THREE.Vector3(0, 0, 0);
  this.strIsRandomise = "false";
};
yu = function v() {
  r(this, v);
  this.vec3Value = new THREE.Vector3(1, 1, 1);
  this.vec3Spread = new THREE.Vector3(0, 0, 0);
  this.strIsRandomise = "false";
};
bu = function t() {
  r(this, t);
  this.fValue = 1;
  this.fSpread = 0;
  this.strIsRandomise = "false";
};
_u = function t() {
  r(this, t);
  this.fValue = 1;
  this.fSpread = 0;
  this.strIsRandomise = "false";
};
xu = function t() {
  r(this, t);
  this.fValue = 0;
  this.fSpread = 0;
  this.strIsRandomise = "false";
};
Eu = function() {
  var name = "[BufferGeometryHelper.js] : ";
  this.bEnableLog = true;
  this.bufferGeometry = null;
  this.jsonLoader = new THREE.BufferGeometryLoader;
  this.objLoader = new THREE.OBJLoader;
  this.strMeshUrl = null;
  var that = this;
  this.init = function(value, translate) {
    if (that.bEnableLog && THING.Utils.log(name + "[init];"), null != translate && null != translate) {
      if (null == value || null == value || "object" != (void 0 === value ? "undefined" : t(value))) {
        return THING.Utils.error(name + "[init] : options == null;"), void translate(null);
      }
      if (null == value.strMeshUrl || null == value.strMeshUrl || "string" != typeof value.strMeshUrl) {
        return THING.Utils.error(name + "[init] : options.strMeshUrl == null;"), void translate(null);
      }
      that.strMeshUrl = value.strMeshUrl;
      if (null != that.bufferGeometry && null != that.bufferGeometry) {
        that.bufferGeometry.dispose();
        that.bufferGeometry = null;
      }
      if (value.strMeshUrl.indexOf("BuildIn") >= 0) {
        var isHorizontal = false;
        return value.strMeshUrl.indexOf("Box") >= 0 && (that.bEnableLog && THING.Utils.log(name + "[init] : it's a BoxBufferGeometry;"), isHorizontal = !that.checkParams(value.params, 3), that.bufferGeometry = isHorizontal ? new THREE.BoxBufferGeometry(1, 1, 1) : new THREE.BoxBufferGeometry(value.params[0], value.params[1], value.params[2])), value.strMeshUrl.indexOf("Cylinder") >= 0 && (that.bEnableLog && THING.Utils.log(name + "[init] : it's a CylinderBufferGeometry;"), isHorizontal = !that.checkParams(value.params, 
        4), that.bufferGeometry = isHorizontal ? new THREE.CylinderBufferGeometry(1, 1, 1, 6) : new THREE.CylinderBufferGeometry(value.params[0], value.params[1], value.params[2], value.params[3] <= 12 ? value.params[3] : 12)), value.strMeshUrl.indexOf("Cone") >= 0 && (that.bEnableLog && THING.Utils.log(name + "[init] : it's a ConeBufferGeometry;"), isHorizontal = !that.checkParams(value.params, 3), that.bufferGeometry = isHorizontal ? new THREE.ConeBufferGeometry(1, 1, 6) : new THREE.ConeBufferGeometry(value.params[0], 
        value.params[1], value.params[2] <= 12 ? value.params[2] : 12)), value.strMeshUrl.indexOf("Circle") >= 0 && (that.bEnableLog && THING.Utils.log(name + "[init] : it's a CircleBufferGeometry;"), isHorizontal = !that.checkParams(value.params, 2), that.bufferGeometry = isHorizontal ? new THREE.CircleBufferGeometry(1, 6) : new THREE.CircleBufferGeometry(value.params[0], value.params[1] <= 12 ? value.params[1] : 12)), value.strMeshUrl.indexOf("Dodecahedron") >= 0 && (that.bEnableLog && THING.Utils.log(name + 
        "[init] : it's a DodecahedronBufferGeometry;"), isHorizontal = !that.checkParams(value.params, 2), that.bufferGeometry = isHorizontal ? new THREE.DodecahedronBufferGeometry(1, 0) : new THREE.DodecahedronBufferGeometry(value.params[0], value.params[1] <= 1 ? value.params[1] : 1)), value.strMeshUrl.indexOf("Icosahedron") >= 0 && (that.bEnableLog && THING.Utils.log(name + "[init] : it's a IcosahedronBufferGeometry;"), isHorizontal = !that.checkParams(value.params, 2), that.bufferGeometry = isHorizontal ? 
        new THREE.IcosahedronBufferGeometry(1, 0) : new THREE.IcosahedronBufferGeometry(value.params[0], value.params[1] <= 1 ? value.params[1] : 1)), value.strMeshUrl.indexOf("Octahedron") >= 0 && (that.bEnableLog && THING.Utils.log(name + "[init] : it's a OctahedronBufferGeometry;"), isHorizontal = !that.checkParams(value.params, 2), that.bufferGeometry = isHorizontal ? new THREE.OctahedronBufferGeometry(1, 0) : new THREE.OctahedronBufferGeometry(value.params[0], value.params[1] <= 2 ? value.params[1] : 
        1)), value.strMeshUrl.indexOf("Plane") >= 0 && (that.bEnableLog && THING.Utils.log(name + "[init] : it's a PlaneBufferGeometry;"), isHorizontal = !that.checkParams(value.params, 2), that.bufferGeometry = isHorizontal ? new THREE.PlaneBufferGeometry(1, 0) : new THREE.PlaneBufferGeometry(value.params[0], value.params[1])), value.strMeshUrl.indexOf("Ring") >= 0 && (that.bEnableLog && THING.Utils.log(name + "[init] : it's a RingBufferGeometry;"), isHorizontal = !that.checkParams(value.params, 
        3), that.bufferGeometry = isHorizontal ? new THREE.RingBufferGeometry(1, 2, 12, 1) : new THREE.RingBufferGeometry(value.params[0], value.params[1], value.params[2] <= 12 ? value.params[2] : 12, 1)), value.strMeshUrl.indexOf("Sphere") >= 0 && (that.bEnableLog && THING.Utils.log(name + "[init] : it's a SphereBufferGeometry;"), isHorizontal = !that.checkParams(value.params, 3), that.bufferGeometry = isHorizontal ? new THREE.SphereBufferGeometry(1, 8, 8) : new THREE.SphereBufferGeometry(value.params[0], 
        value.params[1] <= 12 ? value.params[1] : 12, value.params[2] <= 12 ? value.params[2] : 12)), value.strMeshUrl.indexOf("Tetrahedron") >= 0 && (that.bEnableLog && THING.Utils.log(name + "[init] : it's a TetrahedronBufferGeometry;"), isHorizontal = !that.checkParams(value.params, 2), that.bufferGeometry = isHorizontal ? new THREE.TetrahedronBufferGeometry(1, 0) : new THREE.TetrahedronBufferGeometry(value.params[0], value.params[1] <= 2 ? value.params[1] : 2)), value.strMeshUrl.indexOf("Torus") >= 
        0 && value.strMeshUrl.indexOf("TorusKnot") < 0 && (that.bEnableLog && THING.Utils.log(name + "[init] : it's a TorusBufferGeometry;"), isHorizontal = !that.checkParams(value.params, 4), that.bufferGeometry = isHorizontal ? new THREE.TorusBufferGeometry(1, 1, 8, 8) : new THREE.TorusBufferGeometry(value.params[0], value.params[1], value.params[2] <= 12 ? value.params[2] : 12, value.params[3] <= 12 ? value.params[3] : 12)), value.strMeshUrl.indexOf("TorusKnot") >= 0 && (that.bEnableLog && THING.Utils.log(name + 
        "[init] : it's a TorusKnotBufferGeometry;"), isHorizontal = !that.checkParams(value.params, 6), that.bufferGeometry = isHorizontal ? new THREE.TorusKnotBufferGeometry(1, 1, 32, 8, 2, 3) : new THREE.TorusKnotBufferGeometry(value.params[0], value.params[1], value.params[2] <= 32 ? value.params[2] : 32, value.params[3] <= 12 ? value.params[3] : 12, value.params[4] <= 12 ? value.params[4] : 12, value.params[5] <= 12 ? value.params[5] : 12)), void translate(that.bufferGeometry);
      }
      var loadCount = value.strMeshUrl.indexOf(".json");
      if (loadCount >= 0 && loadCount + ".json".length == value.strMeshUrl.length) {
        if (that.bEnableLog) {
          THING.Utils.log(name + "[init] : it's a .json file to BufferGeometry;");
        }
        that.jsonLoader.load(Globals.strParticleMeshRootPath + value.strMeshUrl, function(t) {
          return null != t && null != t ? (that.bufferGeometry = t, void translate(that.bufferGeometry)) : (THING.Utils.error(name + "[init] : failed load the .json file to BufferGeometry; strMeshUrl = " + value.strMeshUrl), void translate(null));
        });
      }
      var offs = value.strMeshUrl.indexOf(".obj");
      if (offs >= 0 && offs + ".obj".length == value.strMeshUrl.length) {
        if (that.bEnableLog) {
          THING.Utils.log(name + "[init] : it's a .obj file to BufferGeometry;");
        }
        that.objLoader.load(Globals.strParticleMeshRootPath + value.strMeshUrl, function(t) {
          if (null != t && null != t && null != t.children) {
            var mesh = null;
            var i = 0;
            var patchLen = t.children.length;
            for (; i < patchLen; i++) {
              if (t.children[i] instanceof THREE.Mesh) {
                mesh = t.children[i];
                break;
              }
            }
            if (null != mesh) {
              var keyfinder = (new THREE.BufferGeometry).fromGeometry(mesh.geometry);
              return null != keyfinder && null != keyfinder ? (that.bufferGeometry = keyfinder, void translate(that.bufferGeometry)) : (THING.Utils.error(name + "[init] : failed transform the .obj file to BufferGeometry; strMeshUrl = " + value.strMeshUrl), void translate(null));
            }
            return THING.Utils.error(name + "[init] : failed load the .obj file to BufferGeometry; can not find a mesh; strMeshUrl = " + value.strMeshUrl), void translate(null);
          }
        }, function(canCreateDiscussions) {
        }, function(maxRev) {
          THING.Utils.error(name + "[init] : failed load the .obj file to BufferGeometry; strMeshUrl = " + value.strMeshUrl + "; error = " + maxRev);
          translate(null);
        });
      }
    } else {
      THING.Utils.error(name + "[init] : onFinished == null;");
    }
  };
  this.checkParams = function(value, size) {
    if (null == value || null == value || "object" != (void 0 === value ? "undefined" : t(value))) {
      return THING.Utils.warn(name + "[checkParams] : params == null;"), false;
    }
    if (value.length < size) {
      return THING.Utils.warn(name + "[checkParams] : params.length < " + size), false;
    }
    var j = 0;
    for (; j < size; j++) {
      if (null == value[j] || null == value[j] || "number" != typeof value[j]) {
        return THING.Utils.warn(name + "[checkParams] : error params[" + j + "];"), false;
      }
    }
    return true;
  };
};
wu = function() {
  function f(config, value, other) {
    r(this, f);
    this._options = config;
    this._emitter = value;
    this._particleGroup = other;
    if (!this._emitter) {
      this.refresh();
    }
  }
  return f.prototype.cloneOptions = function() {
    return Utils.cloneObject(this._options, false, null, function(theme, canCreateDiscussions) {
      if (Utils.isFunction(theme.clone)) {
        return theme.clone();
      }
    });
  }, f.prototype.refresh = function() {
    if (this._emitter) {
      this._particleGroup._group.removeEmitter(this._emitter);
      this._emitter = null;
    }
    var emitterOptions = this.cloneOptions();
    if (this._particleGroup._options.useMesh) {
      this._emitter = new MSPE.Emitter(emitterOptions);
    } else {
      this._emitter = new SPE.Emitter(emitterOptions);
    }
    this._particleGroup._group.addEmitter(this._emitter);
    var scene = this._particleGroup._particleSystem.node;
    var i = Utils.parseValue(scene.userData.skipBoundingBox, false);
    scene.traverse(function(data) {
      data.userData.skipBoundingBox = i;
    });
  }, f.prototype.setAttributeOptions = function(name, v) {
    if (!(Utils.isUndefined(v) || "{}" === JSON.stringify(v) || Utils.isUndefined(this.options[name]))) {
      if (Utils.isObject(this.options[name])) {
        Utils.mergeObject(this.options[name], v, true);
      } else {
        this.options[name] = v;
      }
      this.refresh();
    }
  }, n(f, [{
    key : "options",
    set : function(value) {
      if (value) {
        Utils.mergeObject(this._options, value, true);
        this.refresh();
      }
    },
    get : function() {
      return this._options;
    }
  }, {
    key : "maxAge",
    set : function() {
      var SomeImperativeViewport = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.setAttributeOptions("maxAge", SomeImperativeViewport);
    }
  }, {
    key : "position",
    set : function() {
      var SomeImperativeViewport = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.setAttributeOptions("position", SomeImperativeViewport);
    }
  }, {
    key : "radius",
    set : function() {
      var SomeImperativeViewport = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.setAttributeOptions("radius", SomeImperativeViewport);
    }
  }, {
    key : "velocity",
    set : function() {
      var SomeImperativeViewport = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.setAttributeOptions("velocity", SomeImperativeViewport);
    }
  }, {
    key : "acceleration",
    set : function() {
      var SomeImperativeViewport = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.setAttributeOptions("acceleration", SomeImperativeViewport);
    }
  }, {
    key : "drag",
    set : function() {
      var SomeImperativeViewport = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.setAttributeOptions("drag", SomeImperativeViewport);
    }
  }, {
    key : "wiggle",
    set : function() {
      var SomeImperativeViewport = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.setAttributeOptions("wiggle", SomeImperativeViewport);
    }
  }, {
    key : "rotation",
    set : function() {
      var SomeImperativeViewport = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.setAttributeOptions("rotation", SomeImperativeViewport);
    }
  }, {
    key : "color",
    set : function() {
      var SomeImperativeViewport = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.setAttributeOptions("color", SomeImperativeViewport);
    }
  }, {
    key : "opacity",
    set : function() {
      var SomeImperativeViewport = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.setAttributeOptions("opacity", SomeImperativeViewport);
    }
  }, {
    key : "size",
    set : function() {
      var SomeImperativeViewport = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.setAttributeOptions("size", SomeImperativeViewport);
    }
  }, {
    key : "angle",
    set : function() {
      var SomeImperativeViewport = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.setAttributeOptions("angle", SomeImperativeViewport);
    }
  }, {
    key : "type",
    set : function(v) {
      this.setAttributeOptions("type", v);
    }
  }, {
    key : "particleCount",
    set : function(v) {
      this.setAttributeOptions("particleCount", v);
    }
  }, {
    key : "duration",
    set : function(v) {
      this.setAttributeOptions("duration", v);
    }
  }, {
    key : "isStatic",
    set : function(v) {
      this.setAttributeOptions("isStatic", v);
    }
  }, {
    key : "isLookAtCamera",
    set : function(v) {
      this.setAttributeOptions("isLookAtCamera", v);
    }
  }, {
    key : "isLookAtCameraOnlyY",
    set : function(v) {
      this.setAttributeOptions("isLookAtCameraOnlyY", v);
    }
  }, {
    key : "activeMultiplier",
    set : function(v) {
      this.setAttributeOptions("activeMultiplier", v);
    }
  }, {
    key : "direction",
    set : function(v) {
      this.setAttributeOptions("direction", v);
    }
  }]), f;
}();
Tu = function() {
  function f(config, value, other) {
    r(this, f);
    this._options = config;
    this._group = value;
    this._particleSystem = other;
    this._emitters = [];
    if (!this._group) {
      this.refresh();
    }
  }
  return f.prototype.setAttributeOptions = function(name, v) {
    if (!(Utils.isUndefined(v) || "{}" === JSON.stringify(v) || Utils.isUndefined(this.options[name]))) {
      if (Utils.isObject(this.options[name])) {
        Utils.mergeObject(this.options[name], v, true);
      } else {
        this.options[name] = v;
      }
      this.refresh();
    }
  }, f.prototype.cloneOptions = function() {
    var options = Utils.cloneObject(this._options, false, function(e) {
      return "texture" != e && "bufferGeometry" != e;
    }, function(theme, canCreateDiscussions) {
      if (Utils.isFunction(theme.clone)) {
        return theme.clone();
      }
    });
    var saturation = this._options.vec4Quaternion;
    return saturation && (options.vec4Quaternion = saturation.clone()), options;
  }, f.prototype.refresh = function() {
    if (-1 === this._particleSystem._groups.indexOf(this)) {
      this._particleSystem._groups.push(this);
    }
    var props = {};
    if (this._group && this._group.mesh) {
      this._particleSystem.node.remove(this._group.mesh);
      props = Utils.cloneObject(this._group.mesh.userData);
    }
    var i = 0;
    for (; i < this._emitters.length; i++) {
      var p = this._emitters[i];
      this._group.removeEmitter(p._emitter);
    }
    var element = this.cloneOptions();
    if (element.useMesh) {
      this._group = new MSPE.Group(element);
      this._group.mesh.userData = props;
    } else {
      this._group = new SPE.Group(element);
      this._group.mesh.userData = props;
    }
    i = 0;
    for (; i < this._emitters.length; i++) {
      var beanDef = this._emitters[i];
      var obj = beanDef.cloneOptions();
      var j;
      for (j in this._particleSystem._particleOptions) {
        var name = this._particleSystem._particleOptions[j];
        if (!Utils.isNull(name)) {
          obj[j] = name;
        }
      }
      if (element.useMesh) {
        beanDef._emitter = new MSPE.Emitter(obj);
      } else {
        beanDef._emitter = new SPE.Emitter(obj);
      }
      this._group.addEmitter(beanDef._emitter);
    }
    var map = this._group.mesh;
    if (map) {
      this._particleSystem.node.add(map);
      map.setFrustumCulled(false);
    }
  }, f.prototype.tick = function(value, that) {
    this._group.tick(value, that);
  }, f.prototype.addEmitter = function(emitterConfig) {
    return new wu(emitterConfig, null, this);
  }, f.prototype.removeEmitter = function(p) {
    var i = 0;
    for (; i < this._emitters.length; i++) {
      if (p == this._emitters[i]) {
        this._emitters.splice(i, 1);
        this._group.removeEmitter(p._emitter);
        break;
      }
    }
  }, n(f, [{
    key : "options",
    set : function(value) {
      if (value) {
        Utils.mergeObject(this._options, value, true);
        this.refresh();
      }
    },
    get : function() {
      return this._options;
    }
  }, {
    key : "emitters",
    get : function() {
      return this._emitters;
    }
  }, {
    key : "texture",
    set : function() {
      var SomeImperativeViewport = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      this.setAttributeOptions("texture", SomeImperativeViewport);
    }
  }, {
    key : "fixedTimeStep",
    set : function(v) {
      this.setAttributeOptions("fixedTimeStep", v);
    }
  }, {
    key : "hasPerspective",
    set : function(v) {
      this.setAttributeOptions("hasPerspective", v);
    }
  }, {
    key : "colorize",
    set : function(v) {
      this.setAttributeOptions("colorize", v);
    }
  }, {
    key : "blending",
    set : function(v) {
      this.setAttributeOptions("blending", v);
    }
  }, {
    key : "transparent",
    set : function(v) {
      this.setAttributeOptions("transparent", v);
    }
  }, {
    key : "alphaTest",
    set : function(v) {
      this.setAttributeOptions("alphaTest", v);
    }
  }, {
    key : "depthWrite",
    set : function(v) {
      this.setAttributeOptions("depthWrite", v);
    }
  }, {
    key : "depthTest",
    set : function(v) {
      this.setAttributeOptions("depthTest", v);
    }
  }, {
    key : "fog",
    set : function(v) {
      this.setAttributeOptions("fog", v);
    }
  }, {
    key : "scale",
    set : function(v) {
      this.setAttributeOptions("scale", v);
    }
  }, {
    key : "maxParticleCount",
    set : function(v) {
      this.setAttributeOptions("maxParticleCount", v);
    }
  }, {
    key : "useMesh",
    set : function(v) {
      this.setAttributeOptions("useMesh", v);
    }
  }, {
    key : "vec4Quaternion",
    set : function(v) {
      this.setAttributeOptions("vec4Quaternion", v);
    }
  }]), f;
}();
ParticleSystem = function(a) {
  function e(row) {
    r(this, e);
    var self = s(this, a.call(this, row));
    return self._groups = [], self._particleOptions = {}, self._groupOptions = {}, self._speed = 1, self;
  }
  return o(e, a), e.prototype._beforeSetupComplete = function() {
    var arrow = this;
    this.style.beforeSetRenderOrder = function(v11) {
      arrow.node.renderOrder = v11;
    };
  }, e.prototype.loadFromURL = function(data, options) {
    var self = this;
    if (!data.node) {
      data.node = new THREE.Group;
    }
    var path = data.url;
    var file = this.app.particleResource.get(path);
    if (file) {
      this.loadComplete(file, data, options);
    } else {
      this.app.particleResource.download(path, function(file) {
        self.loadComplete(file, data, options);
      });
    }
  }, e.prototype.setupFromData = function(result) {
    var placeMidpointLine = this;
    var file = result.data;
    this.loadComplete(file, result, function() {
      a.prototype.setupFromData.call(placeMidpointLine, result);
    });
  }, e.prototype.loadComplete = function(type, content, data) {
    this.setupParticleData(type, content, data);
    this.setupUserData(content);
  }, e.prototype.customSetup = function(bst) {
    this.tickable = true;
  }, e.prototype.update = function(value) {
    value = value * this._speed;
    a.prototype.update.call(this, value);
    var i = 0;
    for (; i < this._groups.length; i++) {
      this._groups[i].tick(value, this.app.renderCamera);
    }
    return true;
  }, e.prototype.parseEmitterOptions = function(self, cb) {
    var command_module_id = new THREE.Vector3(self.position.vec3Value.x, self.position.vec3Value.y, self.position.vec3Value.z);
    var promise_apply = new THREE.Vector3(self.position.vec3Spread.x, self.position.vec3Spread.y, self.position.vec3Spread.z);
    var n = new THREE.Vector3(self.position.vec3SpreadClamp.x, self.position.vec3SpreadClamp.y, self.position.vec3SpreadClamp.z);
    var o = false;
    o = "true" == self.position.strIsRandomise.valueOf();
    var oldGenre = new THREE.Vector3(self.velocity.vec3Value.x, self.velocity.vec3Value.y, self.velocity.vec3Value.z);
    var y = new THREE.Vector3(self.velocity.vec3Spread.x, self.velocity.vec3Spread.y, self.velocity.vec3Spread.z);
    self.velocity.strIsRandomise.valueOf();
    var placeholder_attr = new THREE.Vector3(self.acceleration.vec3Value.x, self.acceleration.vec3Value.y, self.acceleration.vec3Value.z);
    var u = new THREE.Vector3(self.acceleration.vec3Spread.x, self.acceleration.vec3Spread.y, self.acceleration.vec3Spread.z);
    var c = false;
    c = "true" == self.acceleration.strIsRandomise.valueOf();
    var isStatic = false;
    isStatic = "true" == self.strIsStatic.valueOf();
    var d3SvgAxis = new THREE.Vector3(self.rotation.vec3Axis.x, self.rotation.vec3Axis.y, self.rotation.vec3Axis.z);
    var d = new THREE.Vector3(self.rotation.vec3AxisSpread.x, self.rotation.vec3AxisSpread.y, self.rotation.vec3AxisSpread.z);
    var DEFAULT_CENTER = new THREE.Vector3(self.rotation.vec3Center.x, self.rotation.vec3Center.y, self.rotation.vec3Center.z);
    var StaticZoomAdapter = false;
    StaticZoomAdapter = "true" == self.rotation.strIsStatic.valueOf();
    var g = false;
    g = "true" == self.rotation.strIsRandomise.valueOf();
    var v = new Array;
    var rowLis = new Array;
    var sbInds = new Array;
    if (self.listColor.length > 0) {
      var j = 0;
      var statesLength = self.listColor.length;
      for (; j < statesLength; j++) {
        v.push(new THREE.Color(self.listColor[j].vec3Value.x, self.listColor[j].vec3Value.y, self.listColor[j].vec3Value.z));
        rowLis.push(new THREE.Vector3(self.listColor[j].vec3Spread.x, self.listColor[j].vec3Spread.y, self.listColor[j].vec3Spread.z));
        if ("true" == self.listColor[j].strIsRandomise.valueOf()) {
          sbInds.push(true);
        } else {
          sbInds.push(false);
        }
      }
    } else {
      v.push(new THREE.Color("white"));
      rowLis.push(new THREE.Vector3(0, 0, 0));
      sbInds.push(false);
    }
    var chosenEmot = new Array;
    var spread = new Array;
    var _paramsValueArray = new Array;
    if (self.listOpacity.length > 0) {
      j = 0;
      statesLength = self.listOpacity.length;
      for (; j < statesLength; j++) {
        chosenEmot.push(self.listOpacity[j].fValue);
        spread.push(self.listOpacity[j].fSpread);
        if ("true" == self.listOpacity[j].strIsRandomise.valueOf()) {
          _paramsValueArray.push(true);
        } else {
          _paramsValueArray.push(false);
        }
      }
    } else {
      chosenEmot.push(1);
      spread.push(0);
      _paramsValueArray.push(false);
    }
    var C = new Array;
    var _availableFacets = new Array;
    var dupArr = new Array;
    if (self.listSize.length > 0) {
      j = 0;
      statesLength = self.listSize.length;
      for (; j < statesLength; j++) {
        C.push(self.listSize[j].fValue);
        _availableFacets.push(self.listSize[j].fSpread);
        if ("true" == self.listSize[j].strIsRandomise.valueOf()) {
          dupArr.push(true);
        } else {
          dupArr.push(false);
        }
      }
    } else {
      C.push(1);
      _availableFacets.push(0);
      dupArr.push(false);
    }
    var tree_array = new Array;
    var msg16 = new Array;
    var observerBatch = new Array;
    if (self.listAngle.length > 0) {
      j = 0;
      statesLength = self.listAngle.length;
      for (; j < statesLength; j++) {
        tree_array.push(self.listAngle[j].fValue);
        msg16.push(self.listAngle[j].fSpread);
        if ("true" == self.listAngle[j].strIsRandomise.valueOf()) {
          dupArr.push(true);
        } else {
          observerBatch.push(false);
        }
      }
    } else {
      tree_array.push(0);
      msg16.push(0);
      observerBatch.push(false);
    }
    var options = {
      type : self.iDistribution,
      particleCount : self.iParticleCount,
      duration : self.fDuration <= 0 ? void 0 : self.fDuration,
      isStatic : isStatic,
      isLookAtCamera : "true" == self.strIsLookAtCamera,
      isLookAtCameraOnlyY : "true" == self.strIsLookAtCameraOnlyY,
      activeMultiplier : self.fActiveMultiplier,
      direction : self.iDirection,
      maxAge : {
        value : self.maxAge.fValue,
        spread : self.maxAge.fSpread
      },
      position : {
        value : command_module_id,
        spread : promise_apply,
        spreadClamp : n,
        radius : self.position.fRadius,
        radiusScale : new THREE.Vector3(1, 1, 1),
        randomise : o
      },
      radius : {
        value : 5,
        spread : 0,
        scale : new THREE.Vector3(1, 1, 1),
        spreadClamp : new THREE.Vector3(2, 2, 2)
      },
      velocity : {
        value : oldGenre,
        spread : y,
        randomise : false
      },
      acceleration : {
        value : placeholder_attr,
        spread : u,
        randomise : c
      },
      drag : {
        value : self.drag.fValue,
        spread : self.drag.fSpread
      },
      wiggle : {
        value : self.wiggle.fValue,
        spread : self.wiggle.fSpread
      },
      rotation : {
        axis : d3SvgAxis,
        axisSpread : d,
        angle : self.rotation.fAngle,
        angleSpread : self.rotation.fAngleSpread,
        static : StaticZoomAdapter,
        center : DEFAULT_CENTER,
        randomise : g
      },
      color : {
        value : v,
        spread : rowLis,
        randomise : sbInds
      },
      opacity : {
        value : chosenEmot,
        spread : spread,
        randomise : _paramsValueArray
      },
      size : {
        value : C,
        spread : _availableFacets,
        randomise : dupArr
      },
      angle : {
        value : tree_array,
        spread : msg16,
        randomise : observerBatch
      }
    };
    var A = this.app.renderer.capabilities.maxVaryings;
    var operator;
    for (operator in A > 15 && (options.trail = {
      value : self.trail.fValue,
      spread : self.trail.fSpread,
      step : self.trail.fStep,
      stepSpread : self.trail.fStepSpread
    }), this._particleOptions) {
      var value = this._particleOptions[operator];
      if (!Utils.isNull(value)) {
        options[operator] = value;
      }
    }
    return options;
  }, e.prototype.parseGroupOptions = function(that, t) {
    var cssChanges = this.app.calcRect();
    var params = {
      texture : {
        value : t,
        frames : that.texture.vec2Frames,
        frameCount : that.texture.iFrameCount,
        loop : that.texture.iLoop
      },
      fixedTimeStep : that.fFixedTimeStep,
      hasPerspective : "true" == that.strHasPerspective,
      colorize : "true" == that.strIsColorize,
      blending : that.iBlendingMode,
      transparent : "true" == that.strIsTransparent,
      alphaTest : that.fAlphaTest,
      depthWrite : "true" == that.strIsDepthWrite,
      depthTest : "true" == that.strIsDepthTest,
      fog : "true" == that.strIsFog,
      scale : cssChanges.height / 2,
      maxParticleCount : that.iMaxParticleCount,
      useMesh : "true" == that.strUseMesh
    };
    var orientation = that.vec4Quaternion;
    var prop;
    for (prop in orientation && (params.vec4Quaternion = new THREE.Quaternion(orientation.x, orientation.y, orientation.z, orientation.w)), this._groupOptions) {
      var val = this._groupOptions[prop];
      if (!Utils.isNull(val)) {
        params[prop] = val;
      }
    }
    return params;
  }, e.prototype.setupParticleEmitter = function(r, t, spec) {
    var args = this.parseEmitterOptions(r, t);
    var block = new wu(args, null, spec);
    spec._emitters.push(block);
  }, e.prototype.setupParticleEmitters = function(expr, text) {
    var i = 0;
    for (; i < expr.listEmitters.length; i++) {
      var radii = expr.listEmitters[i];
      this.setupParticleEmitter(radii, expr, text);
    }
    if (this.static) {
      this.node._synMatrixWorld();
    }
  }, e.prototype.createParticleGroup = function(pairNumber) {
    return new Tu(pairNumber, null, this);
  }, e.prototype.setupParticleGroup = function(o, path) {
    var easyWF = this;
    var loader = new THREE.TextureLoader;
    loader.setCrossOrigin("anonymous");
    var b = o.texture.url;
    return b.startsWith("http://") || b.startsWith("https://") || (b.startsWith(".") || (b = "." + b), path && (path.startsWith("http://") || path.startsWith("https://") || path.startsWith(".") || (path = "." + path), b.startsWith(path) || (b = path.appendPath(b)))), new Promise(function(saveNotifs, canCreateDiscussions) {
      loader.load(b, function(i) {
        var j = easyWF.parseGroupOptions(o, i);
        if (j.useMesh) {
          var mix = new Eu;
          mix.bEnableLog = false;
          mix.init({
            strMeshUrl : o.strMeshUrl,
            params : o.arrayMeshParams
          }, function(z) {
            j.bufferGeometry = z;
            var data = easyWF.createParticleGroup(j);
            easyWF.setupParticleEmitters(o, data);
          });
        } else {
          var data = easyWF.createParticleGroup(j);
          easyWF.setupParticleEmitters(o, data);
        }
        saveNotifs();
      });
    });
  }, e.prototype.setupParticleData = function(value, options, defaultValue) {
    var MotionChangeRecommendation = this;
    var admin = new su;
    (admin = value).__proto__ = su.prototype;
    var end = options.url || options.rootPath;
    var p = [];
    var i = 0;
    for (; i < admin.listGroups.length; i++) {
      var line = admin.listGroups[i];
      p.push(this.setupParticleGroup(line, end));
    }
    Promise.all(p).then(function() {
      if (null != defaultValue) {
        defaultValue();
      }
      MotionChangeRecommendation.refresh();
    });
  }, e.prototype.refresh = function() {
    var i = 0;
    for (; i < this._groups.length; i++) {
      this._groups[i].refresh();
    }
  }, e.prototype.setParticleAttribute = function(url, eTag) {
    this._particleOptions[url] = eTag;
    this.refresh();
  }, e.prototype.setGroupAttribute = function(items, res) {
    this._groupOptions[items] = res;
    this.refresh();
  }, n(e, [{
    key : "gravityPosition",
    set : function(v) {
      var end = Utils.parseVector3(v);
      var target = Utils.parseVector3(this.position);
      var direction = new THREE.Vector3;
      direction.subVectors(end, target).normalize();
      var point = new THREE.Quaternion;
      point.setFromUnitVectors(new THREE.Vector3(0, -1, 0), direction);
      var i = 0;
      for (; i < this._groups.length; i++) {
        var group = this._groups[i];
        group.options.vec4Quaternion = new THREE.Vector4(point.x, point.y, point.z, point.w);
        group.refresh();
      }
    }
  }, {
    key : "speed",
    set : function(value) {
      this._speed = value;
    },
    get : function() {
      return this._speed;
    }
  }, {
    key : "groups",
    get : function() {
      return this._groups;
    }
  }]), e;
}(BaseObject);
Water = function(c) {
  function m(value) {
    r(this, m);
    var categoryAxis = s(this, c.call(this, value));
    return categoryAxis._scale = 4, categoryAxis._color = "#FFFFFF", categoryAxis._flowDirection = new THREE.Vector2(1, 1), categoryAxis._textureWidth = 1024, categoryAxis._textureHeight = 1024, categoryAxis._normalMaps = [], categoryAxis._normalMapsURL = [], categoryAxis.water = null, categoryAxis;
  }
  return o(m, c), m.prototype._updateByPoints = function() {
    if (this._points.length) {
      this.app.resourceManager.remove(this.water);
      var rawGeom = this._createPolygonVertices(true);
      var renderer = this._createPolygonGeometry(rawGeom.vertices, rawGeom.faces);
      var distance = 0;
      if (rawGeom.vertices.length) {
        var i = 0;
        for (; i < rawGeom.vertices.length; i++) {
          distance = distance + rawGeom.vertices[i].z;
        }
        distance = distance / rawGeom.vertices.length;
      }
      this.water = new THREE.Water(renderer, {
        color : this._color,
        scale : this._scale,
        flowDirection : this._flowDirection,
        textureWidth : this._textureWidth,
        textureHeight : this._textureHeight,
        normalMap0 : this._normalMaps[0],
        normalMap1 : this._normalMaps[1]
      });
      this.water.position.y = distance;
      this.water.scale.y *= -1;
      this.water.rotation.x = -.5 * Math.PI;
      this.node.add(this.water);
    }
  }, m.prototype._createByGeometry = function() {
    if (this.geometryInParam) {
      this.app.resourceManager.remove(this.water);
      var renderer = this.geometryInParam;
      this.water = new THREE.Water(renderer, {
        color : this._color,
        scale : this._scale,
        flowDirection : this._flowDirection,
        textureWidth : this._textureWidth,
        textureHeight : this._textureHeight,
        normalMap0 : this._normalMaps[0],
        normalMap1 : this._normalMaps[1]
      });
      this.node.add(this.water);
    }
  }, m.prototype._setupTextures = function(extendObj2) {
    var elm = new THREE.TextureLoader;
    var m = [extendObj2.normalMap0 || "images/water/Water_1_M_Normal.jpg", extendObj2.normalMap1 || "images/water/Water_2_M_Normal.jpg"];
    var k = 0;
    for (; k < m.length; k++) {
      var i = m[k];
      if (i) {
        this._normalMapsURL.push(i);
        this._normalMaps.push(elm.load(this.app.confirmURL(i)));
      }
    }
    this._textureWidth = 1024;
    this._textureHeight = 1024;
  }, m.prototype.customSetup = function(config) {
    c.prototype.customSetup.call(this, config);
    this._scale = Utils.parseValue(config.waterScale, 4);
    this._color = Utils.parseColor(config.waterColor, "#FFFFFF");
    this._flowDirection = Utils.parseVector2(config.flowDirection, new THREE.Vector2(1, 1));
    this._setupTextures(config);
    if (config.geometry) {
      this.geometryInParam = config.geometry;
      this._createByGeometry();
    }
    var data = config.points;
    if (data) {
      this.addPoints(data);
    }
  }, m.prototype._afterSetupComplete = function(e) {
    if (!(e.position || e.localPosition)) {
      this.useBottomCenterOfBoundingBoxAsPosition();
    }
  }, m.prototype.toJSON = function() {
    var result = c.prototype.toJSON.call(this);
    result.waterScale = this._scale;
    result.waterColor = this._color;
    result.flowDirection = this._flowDirection;
    result.points = this.points;
    var i = 0;
    for (; i < this._normalMapsURL.length; i++) {
      result["normalMap" + i] = this._normalMapsURL[i];
    }
    return result;
  }, m.prototype.setEffect = function(key) {
    THING.Utils.warn("[Water] Please use '.style.setEffect()' to replace '.setEffect()'");
    this.style.setEffect(key);
  }, n(m, [{
    key : "isWater",
    get : function() {
      return true;
    }
  }]), m;
}(Al);
Su = new THREE.Vector3, ju = new THREE.Vector3, Pu = new THREE.Matrix4, Ru = new THREE.Raycaster;
Ru.params.Line.threshold = 0;
var Du = function(selector) {
  function render(camera) {
    r(this, render);
    var self = s(this, selector.call(this));
    return self.geometry.addAttribute("position", new THREE.Float32BufferAttribute((new Array(24)).fill(0), 3)), self.geometry.addAttribute("color", new THREE.Float32BufferAttribute((new Array(24)).fill(1), 3)), self._camera = camera, self;
  }
  return o(render, selector), render.prototype.update = function(type, data) {
    var self = this;
    type.forEach(function(vec2Pos, size) {
      Su.set(vec2Pos.x, vec2Pos.y, 1).applyMatrix4(Pu.getInverse(self._camera.projectionMatrix));
      Su.setLength(Math.min(Su.length(), data[size]));
      self.geometry.getAttribute("position").setXYZ(2 * size + 1, Su.x, Su.y, Su.z);
    });
    this.geometry.getAttribute("position").needsUpdate = true;
    this.geometry.computeBoundingBox();
    this.geometry.computeBoundingSphere();
  }, render;
}(THREE.LineSegments);
Au = function(e) {
  function init(c, h) {
    r(this, init);
    var row = new THREE.BufferGeometry;
    var end = new THREE.MeshBasicMaterial({
      color : 61183,
      opacity : .1,
      transparent : true,
      side : THREE.DoubleSide
    });
    var object = s(this, e.call(this, row, end));
    row.addAttribute("position", new THREE.Float32BufferAttribute((new Array(3 * h)).fill(0), 3));
    var p = [];
    var i = 0;
    for (; i < h - 2; i++) {
      p.push(0, i + 1, i + 2);
    }
    return row.setIndex(p), object._camera = c, object;
  }
  return o(init, e), init.prototype.update = function(type, data) {
    var self = this;
    type.forEach(function(vec2Pos, size) {
      Su.set(vec2Pos.x, vec2Pos.y, 1).applyMatrix4(Pu.getInverse(self._camera.projectionMatrix));
      Su.setLength(Math.min(Su.length(), data[size]));
      self.geometry.getAttribute("position").setXYZ(size + 1, Su.x, Su.y, Su.z);
    });
    this.geometry.getAttribute("position").needsUpdate = true;
    this.geometry.computeBoundingBox();
    this.geometry.computeBoundingSphere();
  }, init;
}(THREE.Mesh);
ku = function(t) {
  function e(row) {
    r(this, e);
    var self = s(this, t.call(this, row));
    return self.tickable = true, self._camera = new THREE.PerspectiveCamera(30, 16 / 9, 1, 20), self._camera.matrixAutoUpdate = false, self._cameraFrustum = new THREE.Frustum, self._cameraHelper = new THREE.CameraHelper(self._camera), self._cameraHelper.visible = false, self._cameraHelper.matrix = new THREE.Matrix4, self._outMesh = new Du(self._camera), self._outMesh.material.color.setHex(16777215), self._outMesh.visible = false, self._horizontalScanningNum = 15, self._verticalScanningNum = 20, self._innerPlanes = 
    [], self.node.add(self._cameraHelper), self.node.add(self._outMesh), self._innerScanning = false, self._innerCounter = 0, self._scanning = false, self._scanningObject = null, self._cache = {
      outer : [],
      inner : []
    }, self._useCache = false, self;
  }
  return o(e, t), e.prototype._updateCameraMatrixAndFrustum = function() {
    var camera = this._camera;
    camera.matrixWorld.copy(this.node.matrixWorld);
    camera.matrixWorldInverse.getInverse(this.node.matrixWorld);
    Pu.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    this._cameraFrustum.setFromProjectionMatrix(Pu);
  }, e.prototype.customSetup = function(options) {
    if (void 0 !== options.fov) {
      this._camera.fov = options.fov;
    }
    if (void 0 !== options.aspect) {
      this._camera.aspect = options.aspect;
    }
    if (void 0 !== options.near) {
      this._camera.near = options.near;
    }
    if (void 0 !== options.far) {
      this._camera.far = options.far;
    }
    if (void 0 !== options.debug) {
      this._cameraHelper.visible = options.debug;
    }
    if (void 0 !== options.outerColor) {
      this._outMesh.material.color.set(Utils.parseColor(options.outerColor));
    }
    if (void 0 !== options.innerScanning) {
      this._innerScanning = !!options.innerScanning;
    }
    if (void 0 !== options.scanningNum) {
      this._horizontalScanningNum = options.scanningNum[0];
      this._verticalScanningNum = options.scanningNum[1];
    }
    this._camera.updateProjectionMatrix();
    this.node.updateMatrixWorld(true);
    this._updateCameraMatrixAndFrustum();
  }, e.prototype.update = function(type) {
    return t.prototype.update.call(this, type), !this.visible || (this._updateCameraMatrixAndFrustum(), this._cameraHelper.visible && this._cameraHelper.update(), this._scanning && (this._innerCounter > this._verticalScanningNum ? (this._scanning = false, this._innerCounter = 0, this._scanningObject = null, this._saveCache && localStorage.setItem(this.name + "_scanning_data", JSON.stringify(this._cache))) : (this._updateInnerPlane(this._innerCounter, this._scanningObject), this._innerCounter++)), 
    this.static && this.node._synMatrixWorld(), true);
  }, e.prototype.destroy = function() {
    t.prototype.destroy.call(this);
    this.stop();
  }, e.prototype.start = function(e) {
    var parenDepth = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    var _this = this;
    var TRUE = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    var n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    if (parenDepth && (this.node.updateMatrixWorld(true), this._updateCameraMatrixAndFrustum()), this._useCache = TRUE, this._saveCache = n, TRUE) {
      var options = localStorage.getItem(this.name + "_scanning_data");
      if (options) {
        this._cache = JSON.parse(options, function(canCreateDiscussions, b) {
          return null === b ? 1 / 0 : b;
        });
      }
    }
    var s = [new THREE.Vector2(-1, 1), new THREE.Vector2(-1, -1), new THREE.Vector2(1, -1), new THREE.Vector2(1, 1)];
    var value = void 0;
    return this._useCache && this._cache.outer.length > 0 ? value = this._cache.outer : (value = s.map(function(mouseVector) {
      Ru.setFromCamera(mouseVector, _this._camera);
      var foundSystemIds = Ru.intersectObjects(e.getNodes(), true);
      return foundSystemIds[0] ? foundSystemIds[0].distance : 1 / 0;
    }), this._cache.outer = value, this._saveCache && localStorage.setItem(this.name + "_scanning_data", JSON.stringify(this._cache))), this._outMesh.update(s, value), this._outMesh.visible = true, this._innerScanning && (this._innerCounter = 0, this._scanning = true, this._scanningObject = e || this.app.query(".Ground")), value;
  }, e.prototype.pause = function() {
    if (this._scanning) {
      this._scanning = false;
      this._innerCounter = 0;
      this._scanningObject = null;
    }
  }, e.prototype.stop = function() {
    this._outMesh.visible = false;
    var crimeCode = 0;
    for (; crimeCode <= this._verticalScanningNum; crimeCode++) {
      if (this._innerPlanes[crimeCode]) {
        this._innerPlanes[crimeCode].visible = false;
      }
    }
    this._scanning = false;
    this._innerCounter = 0;
    this._scanningObject = null;
  }, e.prototype._updateInnerPlane = function(i, elem) {
    var _this = this;
    var y = 2 * i / this._verticalScanningNum - 1;
    var c = [];
    var o = 0;
    for (; o <= this._horizontalScanningNum; o++) {
      var x = 2 * o / this._horizontalScanningNum - 1;
      c.push(new THREE.Vector2(x, y));
    }
    var d = void 0;
    if (this._useCache && this._cache.inner[i]) {
      d = this._cache.inner[i];
    } else {
      d = c.map(function(mouseVector) {
        Ru.setFromCamera(mouseVector, _this._camera);
        var foundSystemIds = Ru.intersectObjects(elem.getNodes(), true);
        return foundSystemIds[0] ? foundSystemIds[0].distance : 1 / 0;
      });
      this._cache.inner[i] = d;
    }
    if (!this._innerPlanes[i]) {
      this._innerPlanes[i] = new Au(this._camera, this._horizontalScanningNum + 2);
      this.node.add(this._innerPlanes[i]);
      this._innerPlanes[i].visible = false;
    }
    this._innerPlanes[i].update(c, d);
    this._innerPlanes[i].visible = true;
  }, e.prototype.test = function(target) {
    var _this = this;
    var name = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "center";
    var closestXPoints = target.objects.filter(function(patternData) {
      return _this._cameraFrustum.intersectsBox(patternData.boundingBox.toBox());
    });
    var simple_escape = closestXPoints.filter(function(result) {
      var n = Su.setFromMatrixPosition(_this._camera.matrixWorld);
      var points = [];
      if ("center" === name) {
        points.push(result.boundingBox.center);
      } else {
        if ("corner" === name) {
          points = result.orientedBoundingBox.points;
        }
      }
      var json = false;
      var i = 0;
      for (; i < points.length; i++) {
        var jimple = ju.fromArray(points[i]);
        Ru.set(n, jimple.sub(n).normalize());
        var intersectors = Ru.intersectObjects(closestXPoints.map(function(tblObject) {
          return tblObject.node;
        }), true);
        if (intersectors.length > 0) {
          if (intersectors[0].object.isChildOf(result.node)) {
            return true;
          }
        } else {
          json = true;
        }
      }
      return json;
    });
    return simple_escape;
  }, e.prototype.testObject = function(result, instance) {
    var r = this;
    var name = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "center";
    var x = Su.setFromMatrixPosition(this._camera.matrixWorld);
    var points = [];
    if ("center" === name) {
      points.push(result.boundingBox.center);
    } else {
      if ("corner" === name) {
        points = result.orientedBoundingBox.points;
      }
    }
    var current = null;
    var i = 0;
    for (; i < points.length; i++) {
      var vTemp = ju.fromArray(points[i]);
      Ru.set(x, vTemp.sub(x).normalize());
      var navLinksArr = instance.objects.filter(function(patternData) {
        return r._cameraFrustum.intersectsBox(patternData.boundingBox.toBox());
      });
      var items = Ru.intersectObjects(navLinksArr.map(function(tblObject) {
        return tblObject.node;
      }), true);
      if (items.length > 0) {
        if (items[0].object.isChildOf(result.node)) {
          return {
            state : e.VISIBLE,
            distance : items[0].distance,
            point : items[0].point
          };
        }
        current = items[0];
      }
    }
    return current ? {
      state : e.OBSCURED,
      distance : current.distance,
      point : current.point
    } : {
      state : e.OUT,
      distance : -1,
      point : null
    };
  }, e.prototype._setNodeVisible = function(index) {
    this.node.ensureVisible(index, this._autoSynVisible);
  }, n(e, [{
    key : "fov",
    set : function(value) {
      this._camera.fov = value;
      this._camera.updateProjectionMatrix();
      this._updateCameraMatrixAndFrustum();
    },
    get : function() {
      return this._camera.fov;
    }
  }, {
    key : "aspect",
    set : function(value) {
      this._camera.aspect = value;
      this._camera.updateProjectionMatrix();
      this._updateCameraMatrixAndFrustum();
    },
    get : function() {
      return this._camera.aspect;
    }
  }, {
    key : "near",
    set : function(value) {
      this._camera.near = value;
      this._camera.updateProjectionMatrix();
      this._updateCameraMatrixAndFrustum();
    },
    get : function() {
      return this._camera.near;
    }
  }, {
    key : "far",
    set : function(value) {
      this._camera.far = value;
      this._camera.updateProjectionMatrix();
      this._updateCameraMatrixAndFrustum();
    },
    get : function() {
      return this._camera.far;
    }
  }]), e;
}(BaseObject);
ku.OUT = 0, ku.VISIBLE = 1, ku.OBSCURED = 2;
var Ou = {
  showHelper : false,
  ambientLight : {
    intensity : .4,
    color : 16777215
  },
  hemisphereLight : {
    intensity : 0,
    color : 16777215,
    groundColor : 2236962
  },
  mainLight : {
    shadow : false,
    shadowQuality : "high",
    shadowBias : 0,
    shadowNormalBias : 0,
    intensity : .5,
    color : 16777215,
    alpha : 30,
    beta : 30,
    distance : 0
  },
  secondaryLight : {
    shadow : false,
    shadowQuality : "high",
    shadowBias : 0,
    shadowNormalBias : 0,
    intensity : 0,
    color : 16777215,
    alpha : 138,
    beta : 0,
    distance : 0
  },
  tertiaryLight : {
    shadow : false,
    shadowQuality : "high",
    shadowBias : 0,
    shadowNormalBias : 0,
    intensity : 0,
    color : 16777215,
    alpha : 0,
    beta : 0,
    distance : 0
  }
};
Bu = {
  showHelper : false,
  ambientLight : {
    intensity : 0
  },
  hemisphereLight : {
    intensity : 0
  },
  mainLight : {
    intensity : 0
  },
  secondaryLight : {
    intensity : 0
  },
  tertiaryLight : {
    intensity : 0
  }
};
Fu = new THREE.Sphere, Lu = new THREE.Vector3, Iu = new THREE.Vector3, Nu = new THREE.Matrix4, Hu = new THREE.Matrix4;
function Uu(node, attributeViewModelBindings) {
  if (attributeViewModelBindings == 1 / 0) {
    return node.getLocalBoundingBox().toBox();
  }
  var pipelets = node.query("*").filter(function(staticObj) {
    return !(staticObj.getBoundingBox(false, true).radius > attributeViewModelBindings);
  });
  var bounds = new THREE.Box3;
  pipelets.forEach(function(staticObj) {
    bounds.union(staticObj.getBoundingBox(false, true).toBox());
  });
  var inv_matrix = new THREE.Matrix4;
  return node.node.updateWorldMatrix(true, false), inv_matrix.getInverse(node.node.matrixWorld), bounds.applyMatrix4(inv_matrix), bounds;
}
var zu = function(e) {
  function init(row) {
    r(this, init);
    var self = s(this, e.call(this, row));
    return self.ambientLight = new THREE.AmbientLight, self.ambientLight.name = "ambient_light", self.node.add(self.ambientLight), self.hemisphereLight = new THREE.HemisphereLight(16777215, 2236962, 1), self.hemisphereLight.name = "hemisphere_light", self.node.add(self.hemisphereLight), self.mainLight = new THREE.DirectionalLight, self.mainLight.name = "main_light", self.mainLight.helper = new THREE.DirectionalLightHelper(self.mainLight), self.mainLight.helper.matrix = self.mainLight.matrix, self.node.add(self.mainLight), 
    self.node.add(self.mainLight.target), self.node.add(self.mainLight.helper), self.secondaryLight = new THREE.DirectionalLight, self.secondaryLight.name = "secondary_light", self.secondaryLight.helper = new THREE.DirectionalLightHelper(self.secondaryLight), self.secondaryLight.helper.matrix = self.secondaryLight.matrix, self.node.add(self.secondaryLight), self.node.add(self.secondaryLight.target), self.node.add(self.secondaryLight.helper), self.tertiaryLight = new THREE.DirectionalLight, self.tertiaryLight.name = 
    "tertiary_light", self.tertiaryLight.helper = new THREE.DirectionalLightHelper(self.tertiaryLight), self.tertiaryLight.helper.matrix = self.tertiaryLight.matrix, self.node.add(self.tertiaryLight), self.node.add(self.tertiaryLight.target), self.node.add(self.tertiaryLight.helper), self._config = JSON.parse(JSON.stringify(Ou)), self._shadowObjectMaxSize = 500, self;
  }
  return o(init, e), init.prototype.customSetup = function(obj) {
    var config = {};
    var i;
    for (i in Ou) {
      if (obj.hasOwnProperty(i)) {
        config[i] = obj[i];
      }
    }
    this.setConfig(config);
    this.mainLight.helper.skipBoundingBox(true);
    this.secondaryLight.helper.skipBoundingBox(true);
    this.tertiaryLight.helper.skipBoundingBox(true);
  }, init.prototype.setConfig = function() {
    var data = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : JSON.parse(JSON.stringify(Ou));
    var child = arguments[1];
    Utils.mergeObject(this._config, data, true);
    var self = this._config;
    this.node.updateMatrixWorld(true);
    var r = Lu.set(0, 1, 0).transformDirection(this.node.matrixWorld).normalize();
    if (this.ambientLight.intensity = self.ambientLight.intensity, this.ambientLight.color.set(Utils.parseColor(self.ambientLight.color)), this.hemisphereLight.intensity = self.hemisphereLight.intensity, this.hemisphereLight.color.set(Utils.parseColor(self.hemisphereLight.color)), this.hemisphereLight.groundColor.set(Utils.parseColor(self.hemisphereLight.groundColor)), this.hemisphereLight.position.copy(r), this.app.isMobileDevice && (self.mainLight.castShadow = false, self.secondaryLight.castShadow = 
    false, self.tertiaryLight.castShadow = false), !child) {
      var parent = this.parent ? this.parent : this.app.root;
      child = self.mainLight.shadow || self.secondaryLight.shadow || self.tertiaryLight.shadow ? Uu(parent, this._shadowObjectMaxSize) : Uu(parent, 1 / 0);
    }
    var forContext = child.getBoundingSphere(Fu);
    this._setDirectLight(this.mainLight, self.mainLight, forContext, self.showHelper, r);
    this._setDirectLight(this.secondaryLight, self.secondaryLight, forContext, self.showHelper, r);
    this._setDirectLight(this.tertiaryLight, self.tertiaryLight, forContext, self.showHelper, r);
    if (this._config.mainLight.distance > 0 || this._config.secondaryLight.distance > 0 || this._config.tertiaryLight.distance > 0) {
      this.tickable = true;
    }
    if (this.app.root.static) {
      this.node._synMatrixWorld();
    }
    this.app.needUpdate = true;
  }, init.prototype.getConfig = function() {
    return this._config;
  }, init.prototype.setDistance = function(d, v, distance) {
    this._config.mainLight.distance = d || 0;
    this._config.secondaryLight.distance = v || 0;
    this._config.tertiaryLight.distance = distance || 0;
    if (this._config.mainLight.distance > 0 || this._config.secondaryLight.distance > 0 || this._config.tertiaryLight.distance > 0) {
      this.tickable = true;
    }
  }, init.prototype.update = function(type) {
    var protoProps = this._config.mainLight.distance > 0 && this._config.mainLight.intensity > 0 && this._config.mainLight.shadow;
    var staticProps = this._config.secondaryLight.distance > 0 && this._config.secondaryLight.intensity > 0 && this._config.secondaryLight.shadow;
    var e = this._config.tertiaryLight.distance > 0 && this._config.tertiaryLight.intensity > 0 && this._config.tertiaryLight.shadow;
    if (protoProps || staticProps || e) {
      var camera = this.app.renderCamera;
      var uncert = Lu.set(0, 1, 0).transformDirection(this.node.matrixWorld).normalize();
      var tmp = Nu.multiplyMatrices(Hu.getInverse(this.node.matrixWorld), camera.matrixWorld);
      return protoProps && (Gu.setFromProjectionMatrix(camera.projectionMatrix, this._config.mainLight.distance), Gu.getBoundingSphere(Fu, tmp), this._setDirectLight(this.mainLight, this._config.mainLight, Fu, this._config.showHelper, uncert)), staticProps && (Gu.setFromProjectionMatrix(camera.projectionMatrix, this._config.secondaryLight.distance), Gu.getBoundingSphere(Fu, tmp), this._setDirectLight(this.secondaryLight, this._config.secondaryLight, Fu, this._config.showHelper, uncert)), e && (Gu.setFromProjectionMatrix(camera.projectionMatrix, 
      this._config.tertiaryLight.distance), Gu.getBoundingSphere(Fu, tmp), this._setDirectLight(this.tertiaryLight, this._config.tertiaryLight, Fu, this._config.showHelper, uncert)), this.app.root.static && this.node._synMatrixWorld(), true;
    }
    return false;
  }, init.prototype._setDirectLight = function(light, options, context, points, n) {
    if (light.intensity = options.intensity, light.visible = options.intensity > 0, light.color.set(Utils.parseColor(options.color)), light.position.copy(Utils.parseVector3(THING.Math.directionFromAlphaBeta(options.alpha, options.beta))), light.position.normalize().multiplyScalar(context.radius || 1).add(context.center), light.target.position.copy(context.center), light.helper.visible = light.visible && points, light.helper.visible && this._updateHelper(light), light.castShadow = options.shadow && 
    !this.app.isMobileDevice, light.castShadow) {
      var w = context.radius;
      var camera = light.shadow.camera;
      camera.top = camera.right = w;
      camera.bottom = camera.left = -w;
      camera.near = .1;
      camera.far = 2 * w;
      camera.updateProjectionMatrix();
      camera.up.copy(n);
      var v = {
        low : 512,
        medium : 1024,
        high : 2048,
        ultra : 4096
      }[options.shadowQuality] || 1024;
      light.shadow.bias = options.shadowBias;
      light.shadow.normalBias = options.shadowNormalBias;
      light.shadow.radius = .1;
      if (!(light.shadow.mapSize.x === v && light.shadow.mapSize.y === v)) {
        if (light.shadow.map) {
          light.shadow.map.dispose();
          light.shadow.map = null;
        }
        light.shadow.mapSize.set(v, v);
      }
    }
  }, init.prototype._updateHelper = function(options) {
    var el = options.helper;
    if (void 0 !== el.color) {
      el.lightPlane.material.color.set(el.color);
      el.targetLine.material.color.set(el.color);
    } else {
      el.lightPlane.material.color.copy(el.light.color);
      el.targetLine.material.color.copy(el.light.color);
    }
    Nu.lookAt(Iu.subVectors(options.target.position, options.position), new THREE.Vector3, new THREE.Vector3(0, 1, 0));
    el.lightPlane.quaternion.setFromRotationMatrix(Nu);
    el.targetLine.quaternion.setFromRotationMatrix(Nu);
    el.targetLine.scale.z = Iu.length();
  }, init.prototype._setNodeVisible = function(index) {
    this.node.ensureVisible(index, this._autoSynVisible);
  }, n(init, [{
    key : "shadowObjectMaxSize",
    set : function(num) {
      if (this._shadowObjectMaxSize !== num) {
        this._shadowObjectMaxSize = num;
        this.setConfig({});
      }
    },
    get : function() {
      return this._shadowObjectMaxSize;
    }
  }]), init;
}(BaseObject);
Vu = new THREE.Matrix4, Wu = new THREE.Box3, Gu = new (function() {
  function v(msg) {
    r(this, v);
    msg = msg || {};
    this.vertices = {
      near : [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3],
      far : [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3]
    };
    if (void 0 !== msg.projectionMatrix) {
      this.setFromProjectionMatrix(msg.projectionMatrix, msg.maxFar || 1e4);
    }
  }
  return v.prototype.setFromProjectionMatrix = function(mat, maxWorkSize) {
    var i = 0 === mat.elements[11];
    return Vu.getInverse(mat), this.vertices.near[0].set(1, 1, -1), this.vertices.near[1].set(1, -1, -1), this.vertices.near[2].set(-1, -1, -1), this.vertices.near[3].set(-1, 1, -1), this.vertices.near.forEach(function(eye) {
      eye.applyMatrix4(Vu);
    }), this.vertices.far[0].set(1, 1, 1), this.vertices.far[1].set(1, -1, 1), this.vertices.far[2].set(-1, -1, 1), this.vertices.far[3].set(-1, 1, 1), this.vertices.far.forEach(function(vector) {
      vector.applyMatrix4(Vu);
      var videoWidth = Math.abs(vector.z);
      if (i) {
        vector.z *= Math.min(maxWorkSize / videoWidth, 1);
      } else {
        vector.multiplyScalar(Math.min(maxWorkSize / videoWidth, 1));
      }
    }), this.vertices;
  }, v.prototype.getBoundingSphere = function(result, m) {
    return Wu.makeEmpty(), this.vertices.near.forEach(function(pos) {
      Wu.expandByPoint(pos);
    }), this.vertices.far.forEach(function(pos) {
      Wu.expandByPoint(pos);
    }), Wu.getBoundingSphere(result), m && result.applyMatrix4(m), result;
  }, v;
}());
qu = function(e) {
  function d(row) {
    r(this, d);
    var container = s(this, e.call(this, row));
    return container._intensity = 1, container._castShadow = false, container._light = null, container;
  }
  return o(d, e), d.prototype._syn = function() {
  }, d.prototype.customSetup = function(object) {
    this._intensity = object.intensity || 1;
    this._castShadow = object.castShadow || false;
  }, d.prototype.toJSON = function() {
    return e.prototype.toJSON.call(this);
  }, n(d, [{
    key : "intensity",
    set : function(value) {
      this._intensity = value;
      this._syn();
    },
    get : function() {
      return this._intensity;
    }
  }, {
    key : "castShadow",
    set : function(num) {
      this._castShadow = num;
      this._syn();
    },
    get : function() {
      return this._castShadow;
    }
  }, {
    key : "lightColor",
    set : function(value) {
      var newVal = Utils.parseColor(value);
      if (newVal) {
        this._light.color = newVal;
      }
    },
    get : function() {
      return this._light.color.toHexString();
    }
  }, {
    key : "shadowBias",
    set : function(value) {
      this._light.shadow.bias = value;
    },
    get : function() {
      return this._light.shadow.bias;
    }
  }, {
    key : "shadowNormalBias",
    set : function(num) {
      this._light.shadow.normalBias = num;
    },
    get : function() {
      return this._light.shadow.normalBias;
    }
  }]), d;
}(BaseObject);
Xu = function(obj) {
  function e(row) {
    r(this, e);
    var that = s(this, obj.call(this, row));
    return that._lightAngle = 30, that._distance = 5, that._penumbra = .5, that._helper = null, that;
  }
  return o(e, obj), e.prototype.destroy = function() {
    if (this._helper) {
      this._helper.dispose();
    }
    obj.prototype.destroy.call(this);
  }, e.prototype._syn = function() {
    this._light.angle = THING.Math.degToRad(this._lightAngle);
    this._light.intensity = this.intensity;
    this._light.penumbra = this.penumbra;
    this._light.castShadow = this.castShadow;
    this._light.distance = 0 === this.distance ? .001 : this.distance;
  }, e.prototype._afterSetupComplete = function(e) {
    var psNode = e.centerNodeName;
    if (psNode) {
      this.centerNodeName = psNode;
    }
    this._lightAngle = e.lightAngle || this._lightAngle;
    this._distance = e.distance || this._distance;
    this._penumbra = e.penumbra || this._penumbra;
    var pubDateEl = e.projectTexture;
    this._light = pubDateEl ? new THREE.ProjectSpotLight : new THREE.SpotLight("#FFFFFF");
    this._light.position.set(0, 0, 0);
    this._light.target.position.set(0, 0, 1);
    this.node.add(this._light);
    this.node.add(this._light.target);
    var value = e.target;
    if (value) {
      this.lookAt(value);
    }
    var helper = e.helper;
    if (helper) {
      this.helper = helper;
    }
    this._syn();
  }, e.prototype._updateLightHelper = function() {
    var g = this._light.distance;
    var b = g * Math.tan(this._light.angle);
    this._helper.cone.scale.set(b, b, g);
    this._helper.cone.material.color.copy(this._light.color);
  }, e.prototype.update = function(t) {
    var yuic = obj.prototype.update.call(this, t);
    return this._helper ? (this._updateLightHelper(), true) : yuic;
  }, n(e, [{
    key : "lightAngle",
    set : function(num) {
      this._lightAngle = num;
      this._syn();
    },
    get : function() {
      return this._lightAngle;
    }
  }, {
    key : "distance",
    set : function(value) {
      this._distance = value;
      this._syn();
    },
    get : function() {
      return this._distance;
    }
  }, {
    key : "penumbra",
    set : function(num) {
      this._penumbra = num;
      this._syn();
    },
    get : function() {
      return this._penumbra;
    }
  }, {
    key : "helper",
    set : function(num) {
      if (num && !this._helper) {
        this._helper = new THREE.SpotLightHelper(this._light);
        this._helper.matrix = this._light.matrix;
        this._helper.cone.quaternion.set(0, 0, 0, 1);
        this.node.add(this._helper);
        this.tickable = true;
      } else {
        if (!num && this._helper) {
          this.node.remove(this._helper);
          this._helper.dispose();
          this._helper = null;
        }
      }
    },
    get : function() {
      return !!this._helper;
    }
  }]), e;
}(qu);
Ju = function(obj) {
  function e(row) {
    r(this, e);
    var self = s(this, obj.call(this, row));
    return self._distance = 0, self._decay = 2, self._helper = null, self;
  }
  return o(e, obj), e.prototype.destroy = function() {
    if (this._helper) {
      this._helper.dispose();
    }
    obj.prototype.destroy.call(this);
  }, e.prototype._syn = function() {
    this._light.intensity = this.intensity;
    this._light.castShadow = this.castShadow;
    this._light.distance = 0 === this.distance ? .001 : this.distance;
    this._light.shadow.camera.far = 0 === this.distance ? .001 : this.distance;
    this._light.decay = this._decay;
  }, e.prototype._afterSetupComplete = function(e) {
    this._distance = e.distance || this._distance;
    this._decay = e.decay || this._decay;
    this._light = new THREE.PointLight("#FFFFFF");
    this._light.position.set(0, 0, 0);
    this.node.add(this._light);
    var helper = e.helper;
    if (helper) {
      this.helper = helper;
    }
    this._syn();
  }, e.prototype._updateLightHelper = function() {
    this._helper.update();
  }, e.prototype.update = function(t) {
    var yuic = obj.prototype.update.call(this, t);
    return this._helper ? (this._updateLightHelper(), true) : yuic;
  }, n(e, [{
    key : "distance",
    set : function(value) {
      this._distance = value;
      this._syn();
    },
    get : function() {
      return this._distance;
    }
  }, {
    key : "decay",
    set : function(num) {
      this._decay = num;
      this._syn();
    },
    get : function() {
      return this._decay;
    }
  }, {
    key : "helper",
    set : function(num) {
      if (num && !this._helper) {
        this._helper = new THREE.PointLightHelper(this._light, 1);
        this._helper.matrix = this._light.matrix;
        this.node.add(this._helper);
        this.tickable = true;
      } else {
        if (!num && this._helper) {
          this.node.remove(this._helper);
          this._helper.dispose();
          this._helper = null;
        }
      }
    },
    get : function() {
      return !!this._helper;
    }
  }]), e;
}(qu);
Yu = function(e) {
  function m(i) {
    r(this, m);
    var self = s(this, e.call(this, i));
    return self._image = "", self._texture = null, self._width = 10, self._scrollSpeed = 0, self._uStep = 0, self._resolution = new THREE.Vector2, self._updateResolutionFunc = self._updateResolution.bind(self), self._helpGeometry = new THREE.Geometry, self._meshline = new THREE.MeshLine, self._material = null, self._repeatX = 1, self._offsetX = 0, self._uvTransform = new THREE.Matrix3, self._synUvTransform(), self;
  }
  return o(m, e), m.prototype._synUvTransform = function() {
    this._uvTransform.setUvTransform(this._offsetX, 0, this._repeatX, 1, 0, 0, 0);
  }, m.prototype._updateResolution = function(fileOne) {
    this._resolution.set(fileOne.size[0], fileOne.size[1]);
  }, m.prototype.customSetup = function(options) {
    e.prototype.customSetup.call(this, options);
    var image = options.image;
    if (image) {
      if (image.isTexture) {
        this._image = image.name;
        this._texture = image;
      } else {
        this._image = image;
        this._texture = this.app.resourceManager.loadTexture(image, void 0, {
          repeat : true,
          anisotropy : 16
        });
      }
    }
    this._uStep = options.uStep || this._uStep;
    var data = options.points;
    if (data) {
      this.addPoints(data);
    }
    this._width = options.width || this._width;
    this.uvRatio = options.uvRatio || 1;
    this.scrollSpeed = options.scrollSpeed || this._scrollSpeed;
    var value = this.app.calcRect();
    this._resolution.set(value.width, value.height);
    this._material = new THREE.MeshLineMaterial({
      map : this._texture,
      useMap : !!this._texture,
      color : new THREE.Color(1, 1, 1),
      opacity : 1,
      resolution : this._resolution,
      sizeAttenuation : false,
      lineWidth : this._width,
      near : this.app.renderCamera.near,
      far : this.app.renderCamera.far,
      side : THREE.DoubleSide
    });
    this._material.extensions.derivatives = !this.app.renderer.capabilities.isWebGL2;
    this._material.uniforms.uvTransform = {
      type : "m3",
      value : this._uvTransform
    };
    this.app.on("resize", this._updateResolutionFunc);
    var start = new THREE.Mesh(this._meshline.geometry, this._material);
    this.node.add(start);
  }, m.prototype.destroy = function() {
    e.prototype.destroy.call(this);
    this.app.off("resize", this._updateResolutionFunc);
  }, m.prototype.update = function(t) {
    var yuic = e.prototype.update.call(this, t);
    return this._material ? (0 !== this._scrollSpeed && (this._offsetX += this._scrollSpeed * t, this._synUvTransform()), true) : yuic;
  }, m.prototype._updateByPoints = function() {
    this._helpGeometry.vertices = this._points.map(function(resourcesOrReports) {
      return (new THREE.Vector3).fromArray(resourcesOrReports);
    });
    this._meshline.setGeometry(this._helpGeometry, void 0, this._uStep);
  }, m.prototype.toJSON = function() {
    var o = e.prototype.toJSON.call(this);
    return o.image = this._image, o.scrollSpeed = this._scrollSpeed, o.points = this.points, o;
  }, n(m, [{
    key : "uvRatio",
    set : function(value) {
      this._repeatX = value;
      this._synUvTransform();
    }
  }, {
    key : "width",
    set : function(v) {
      this._width = v;
      if (this._material) {
        this._material.uniforms.lineWidth.value = v;
      }
    },
    get : function() {
      return this._width;
    }
  }, {
    key : "scrollSpeed",
    set : function(v) {
      this._scrollSpeed = THING.Math.clamp(v, -99, 99);
      this.tickable = 0 !== this._scrollSpeed;
    },
    get : function() {
      return this._scrollSpeed;
    }
  }]), m;
}(Al);
var Qu = function(e) {
  function init(row) {
    r(this, init);
    var that = s(this, e.call(this, row));
    return that._height = 10, that._geometry = new THREE.Geometry, that._material = new THREE.MeshBasicMaterial({
      side : THREE.DoubleSide,
      transparent : true
    }), that._material.uvTransform = new THREE.Matrix3, that._scrollSpeed = [0, 0], that._uvRepeat = [1, 1], that._uvOffset = [0, 0], that._uvRotation = 0, that;
  }
  return o(init, e), init.prototype.setScroll = function() {
    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    this._scrollSpeed = [e, t];
    this.tickable = true;
  }, init.prototype._synUvTransform = function() {
    if (!this._material.uvTransform) {
      this._material.uvTransform = new THREE.Matrix3;
    }
    this._material.uvTransform.setUvTransform(this._uvOffset[0], this._uvOffset[1], this._uvRepeat[0], this._uvRepeat[1], this._uvRotation, 0, 0);
  }, init.prototype.customSetup = function(obj) {
    e.prototype.customSetup.call(this, obj);
    this._height = obj.height || this._height;
    var data = obj.points;
    if (data) {
      this.addPoints(data);
    }
    this.color = obj.color || 16777215;
    this.scroll = obj.scroll || false;
    var start = new THREE.Mesh(this._geometry, this._material);
    this.node.add(start);
    if (obj.image) {
      this._material.map = this.app.resourceManager.loadTexture(obj.image, void 0, {
        repeat : true
      });
    } else {
      this._material.map = function() {
        var colorLookup = new Uint8Array(512);
        var t = 0;
        for (; t < 128; t++) {
          colorLookup[4 * t + 0] = 255;
          colorLookup[4 * t + 1] = 255;
          colorLookup[4 * t + 2] = 255;
          colorLookup[4 * t + 3] = 255 * (1 - t / 128);
        }
        var picture_right_map = new THREE.DataTexture(colorLookup, 1, 128, THREE.RGBAFormat);
        return picture_right_map.needsUpdate = true, picture_right_map;
      }();
    }
  }, init.prototype.destroy = function() {
    e.prototype.destroy.call(this);
    this.app.off("resize", this._updateResolutionFunc);
  }, init.prototype.update = function(t) {
    var yuic = e.prototype.update.call(this, t);
    return 0 !== this._scrollSpeed[0] || 0 !== this._scrollSpeed[1] ? (this._uvOffset[0] += this._scrollSpeed[0] * t, this._uvOffset[1] += this._scrollSpeed[1] * t, this._synUvTransform(), true) : yuic;
  }, init.prototype._updateByPoints = function() {
    var self = this;
    var positions = [];
    var b = [];
    var x = [];
    var collectedUvs = [];
    var position = void 0;
    var encoding = void 0;
    var newPosition = new THREE.Vector3;
    var w = 0;
    this._points.forEach(function(buffer, n) {
      position = (new THREE.Vector3).fromArray(buffer);
      (encoding = (new THREE.Vector3).fromArray(buffer)).y += self._height;
      b.push(position, encoding);
      if (n > 0) {
        w = w + position.distanceTo(newPosition);
      }
      positions.push(new THREE.Vector2(w / self._height, 0), new THREE.Vector2(w / self._height, 1));
      newPosition.copy(position);
    });
    var iv = 0;
    for (; iv < b.length - 2; iv = iv + 2) {
      x.push(new THREE.Face3(iv + 1, iv + 0, iv + 2));
      x.push(new THREE.Face3(iv + 2, iv + 3, iv + 1));
      collectedUvs.push([positions[iv + 1], positions[iv + 0], positions[iv + 2]]);
      collectedUvs.push([positions[iv + 2], positions[iv + 3], positions[iv + 1]]);
    }
    this._geometry.vertices = b;
    this._geometry.faces = x;
    this._geometry.faceVertexUvs = [collectedUvs];
    this._geometry.verticesNeedUpdate = true;
    this._geometry.uvsNeedUpdate = true;
    this._geometry.elementsNeedUpdate = true;
    this._geometry.computeBoundingSphere();
    this._geometry.computeFaceNormals();
  }, init.prototype.toJSON = function() {
    var clone = e.prototype.toJSON.call(this);
    return clone.height = this._height, clone.points = this.points, clone;
  }, n(init, [{
    key : "height",
    set : function(v) {
      this._height = v;
      this._updateByPoints();
    },
    get : function() {
      return this._height;
    }
  }, {
    key : "color",
    set : function(v) {
      this._material.color.setHex(v);
    },
    get : function() {
      return this._material.color.getHex();
    }
  }, {
    key : "imageRepeat",
    set : function(num) {
      this._uvRepeat[0] = num[0];
      this._uvRepeat[1] = num[1];
      this._synUvTransform();
    },
    get : function() {
      return this._uvRepeat.slice(0);
    }
  }]), init;
}(Al);
Zu = new THREE.Vector3, Ku = function() {
  function f(count, node, el) {
    r(this, f);
    this.object = null;
    this.useSpriteMaterial = count;
    this.node = node;
    this.domElement = el;
    this.cssObject = null;
    this.pivotObject = null;
  }
  return f.fixCSS3DOffset = function(val, digits) {
    return [Math.round(1.5 * val), Math.round(1.5 * digits)];
  }, f.prototype.onUpdate = function(parentBindings) {
    var node = this.node;
    var camera = this.cssObject;
    node.updateMatrixWorld();
    var center = new THREE.Vector3;
    var to_slc = new THREE.Vector3;
    var result = new THREE.Quaternion;
    node.matrixWorld.decompose(center, result, to_slc);
    this.pivotObject.position.copy(center);
    var srcFile2 = new THREE.Vector3;
    if (this.object._independentWorldScale) {
      srcFile2 = this.object._independentWorldScale.clone();
    } else {
      this.object.node.getWorldScale(srcFile2);
    }
    var oneMinusSpecularStrength = node.userData.cssFactor || 1;
    this.cssObject.scale.copy(srcFile2);
    this.cssObject.scale.multiplyScalar(oneMinusSpecularStrength / 30);
    var position = this.object.pivot;
    if (position) {
      var w = this.domElement.scrollWidth;
      if (this.domElement.threeDHeight && this.domElement.onAppended && this.domElement.scrollHeight != this.domElement.threeDHeight.slice(0, -2) - 0) {
        this.domElement.onAppended();
      }
      this.domElement.threeDHeight = this.domElement.scrollHeight + "px";
      var width;
      var height;
      var len = this.domElement.threeDHeight.slice(0, -2) - 0;
      var radius = w * this.cssObject.scale.x;
      var max = len * this.cssObject.scale.y;
      var list = Math.round((.5 - position[0]) * radius);
      var value = Math.round((position[1] - .5) * max);
      var def = f.fixCSS3DOffset(list, value);
      if (def) {
        width = def[0];
        height = def[1];
      } else {
        width = list;
        height = value;
      }
      if (this.object._useSpriteMaterial) {
        camera.quaternion.copy(result);
        if (this.domElement.cacheLeft != width) {
          this.domElement.cacheLeft = width;
          this.domElement.style.left = width + "px";
        }
        if (this.domElement.cacheTop != height) {
          this.domElement.cacheTop = height;
          this.domElement.style.top = height + "px";
        }
      } else {
        this.pivotObject.quaternion.copy(result);
        camera.position.x = width;
        camera.position.y = height;
        camera.position.z = 0;
      }
      if (radius && max) {
        if (!(this.scaledWidth == radius && this.scaledHeight == max)) {
          this.scaledWidth = radius;
          this.scaledHeight = max;
          this.node.getWorldScale(Zu);
          this.node.userData.boundingBoxSize = [radius / Zu.x, max / Zu.y, 1];
          this.object.dirty = true;
        }
        if (!(this.pivotLeft == width && this.pivotTop == height)) {
          this.pivotLeft = width;
          this.pivotTop = height;
          this.node.userData.boundingBoxPivot = [.5 + width / radius, .5 + height / max, 0];
          this.object.dirty = true;
        }
      }
    }
    return this.onVisible(this.object.node.ensureVisible()), true;
  }, f.prototype.onAdd = function(data) {
    this.object = data;
    this.pivotObject = new THREE.Object3D;
    if (this.useSpriteMaterial) {
      this.cssObject = new THREE.CSS3DSprite(this.domElement);
    } else {
      this.cssObject = new THREE.CSS3DObject(this.domElement);
    }
    this.pivotObject.add(this.cssObject);
    this.object.app.cssScene.add(this.pivotObject);
    this.onUpdate();
    this.object.tickable = true;
  }, f.prototype.onRemove = function() {
    if (this.pivotObject) {
      this.object.app.cssScene.remove(this.pivotObject);
      if (this.cssObject) {
        this.pivotObject.remove(this.cssObject);
        this.cssObject = null;
      }
      this.pivotObject = null;
    }
    this.object = null;
  }, f.prototype.onVisible = function(value) {
    this.cssObject.visible = value;
    var elStyle = this.domElement.style;
    if (value) {
      if ("visible" != elStyle.visibility) {
        elStyle.visibility = "visible";
      }
    } else {
      if ("hidden" != elStyle.visibility) {
        elStyle.visibility = "hidden";
      }
    }
  }, f;
}();
$u = new THREE.Vector3, ec = new THREE.Vector3, tc = function(e) {
  function t(row) {
    r(this, t);
    var self = s(this, e.call(this, row));
    return self._useShadow = false, self._line = null, self._lineOffset = [0, 0, 0], self._factor = .01, self._initialSize = [1, 1], self._size = [1, 1], self._pivot = [.5, .5], self._useScaleMode = false, self._useSpriteMaterial = true, self._sizeAttenuation = true, self._element = null, self._planeSprite = null, self._sprite = null, self._canvas = null, self._url = "", self;
  }
  return o(t, e), t.prototype.updateConnectionLine = function() {
    if (!this._line) {
      return false;
    }
    if (!this.parent) {
      return false;
    }
    var x = THING.Math.addVector(this._lineOffset, this.position);
    var i = this._lineToObject ? this._lineToObject.position : this._lineToPosition;
    return this._line.setPoint(0, x), this._line.setPoint(1, i), true;
  }, t.prototype._setupMaterial = function(data) {
    var background = data.canvas;
    var source = data.image;
    var url = data.url;
    if (background) {
      this.setCanvas(background);
    } else {
      if (source) {
        this.setImage(source);
      } else {
        if (void 0 !== url) {
          this._url = url;
        }
      }
    }
  }, t.prototype._setupSprite = function(input) {
    var _this = this;
    var i = true;
    var r = true;
    var n = 0;
    var currentQueryTimer = null;
    this.loaded = false;
    this._useSpriteMaterial = Utils.parseValue(input.useSpriteMaterial, this._useSpriteMaterial);
    var source = input.element;
    if (source) {
      var element = source.cloneNode(true);
      var checkedInput = Utils.parseSize(input);
      var components_path = this.app.events;
      var self = {};
      Object.defineProperties(self, {
        pickedObj : {
          get : function() {
            return this.object;
          }
        }
      });
      var listener = function(event, data) {
        event.button = data.button;
        event.buttons = data.buttons;
        event.altKey = data.altKey;
        event.ctrlKey = data.ctrlKey;
        event.shiftKey = data.shiftKey;
      };
      var settings = {
        picked : false,
        x : 0,
        y : 0
      };
      this._element = element;
      this._element.onmousedown = function(event) {
        if (false !== _this.app.picker.setPickedObject(_this, self)) {
          Utils.timer.setTimeout(function() {
            components_path.skipFrameCount = _this.app.currentFrameCount;
            settings.picked = true;
            settings.x = event.x;
            settings.y = event.y;
          });
        }
      };
      this._element.onmouseup = function(event) {
        if (false !== _this.app.picker.setPickedObject(_this, self) && settings.picked) {
          if (settings.picked = false, THING.Math.getDistance([settings.x, settings.y], [event.x, event.y]) > 1) {
            return;
          }
          r = true;
          if (1 === ++n) {
            currentQueryTimer = Utils.timer.setTimeout(function() {
              if (i) {
                r = false;
                components_path.skipFrameCount = _this.app.currentFrameCount + 1;
                listener(self, event);
                self.object.trigger("singleclick", self);
                _this.app.trigger("singleclick", self);
              } else {
                r = true;
              }
              i = true;
              n = 0;
            }, 250);
          } else {
            if (currentQueryTimer) {
              Utils.timer.clearTimeout(currentQueryTimer);
              n = 0;
            }
          }
        }
      };
      this._element.onclick = function(data) {
        if (false !== _this.app.picker.setPickedObject(_this, self)) {
          Utils.timer.setTimeout(function() {
            components_path.skipFrameCount = _this.app.currentFrameCount;
            listener(self, data);
            self.object.trigger("click", self);
            _this.app.trigger("click", self);
          });
        }
      };
      this._element.ondblclick = function(event) {
        if (false !== _this.app.picker.setPickedObject(_this, self)) {
          Utils.timer.clearTimeout(currentQueryTimer);
          n = 0;
          if (r) {
            Utils.timer.setTimeout(function() {
              components_path.skipFrameCount = _this.app.currentFrameCount;
              listener(self, event);
              self.object.trigger("dblclick", self);
              _this.app.trigger("dblclick", self);
            });
          } else {
            r = true;
          }
        }
      };
      this._element.onmousemove = function(event) {
        if (0 == event.buttons) {
          event.stopPropagation();
        }
        if (_this.app.picker.setPickedObject(_this, self)) {
          Utils.timer.setTimeout(function() {
            components_path.skipFrameCount = _this.app.currentFrameCount;
            listener(self, event);
            self.object.trigger("mousemove", self);
            _this.app.trigger("mousemove", self);
          });
        }
      };
      this._element.onmouseenter = function(name) {
        _this.app.setCurrentHTMLMarker(_this);
        if (_this.app.picker.setPickedObject(_this, self)) {
          Utils.timer.setTimeout(function() {
            components_path.skipFrameCount = _this.app.currentFrameCount;
            listener(self, name);
            self.object.trigger("mouseenter", self);
            _this.app.trigger("mouseenter", self);
          });
        }
      };
      this._element.onmouseleave = function(name) {
        _this.app.setCurrentHTMLMarker(null);
        var view = self.object;
        if (view) {
          Utils.timer.setTimeout(function() {
            components_path.skipFrameCount = _this.app.currentFrameCount;
            listener(self, name);
            view.trigger("mouseleave", self);
            _this.app.trigger("mouseleave", self);
          });
        }
      };
      this._element.style.pointerEvents = "auto";
      this._element.style.cursor = "default";
      var material = new THREE.SpriteMaterial({
        colorWrite : false,
        depthWrite : false,
        transparent : true
      });
      this._planeSprite = new THREE.Sprite(material);
      this._planeSprite.userData.cssFactor = checkedInput[0];
      this._planeSprite.userData.skipOutline = true;
      this._planeSprite.userData.skipStyle = true;
      this._planeSprite.userData.skipPick = true;
      this.node.add(this._planeSprite);
      this.element3DObjectControl = new Ku(this._useSpriteMaterial, this._planeSprite, element);
      this.addControl(this.element3DObjectControl);
      this.loaded = true;
    } else {
      var init = void 0;
      this.bindParams = input;
      input.loadTextureComplete = function(game) {
        var state = game.material;
        var pipelets = (state._userData || {}).bindMarkers;
        if (pipelets) {
          pipelets.forEach(function(instance) {
            instance._updateSpriteTexture(state.map);
            instance.synSize(input);
            instance.node.getMaterials().forEach(function(oPresentationNode) {
              oPresentationNode.visible = true;
            });
            instance.loaded = true;
            if (!instance.calledComplete) {
              instance.update();
              instance._callComplete(instance.bindParams);
            }
            if (init) {
              init(instance);
            }
            delete instance.bindParams;
          });
        }
        state._userData = {};
      };
      var element = this.app.spriteResource.getMaterial(input);
      if ((material = element.material)._userData = material._userData || {}, material._userData.bindMarkers = material._userData.bindMarkers || [], material._userData.bindMarkers.push(this), material.isSpriteMaterial) {
        this._sprite = new THREE.Sprite(material);
      } else {
        var pregeom = new THREE.PlaneBufferGeometry(this._size[0], this._size[1]);
        this._sprite = new THREE.Mesh(pregeom, material);
      }
      if (element.needLoadTexture) {
        var value = Utils.parseValue(input.visible, true);
        if (value) {
          this._sprite.setLayerVisible(false);
          init = function(parent) {
            Utils.timer.setTimeout(function() {
              parent._sprite.setLayerVisible(value);
              parent.dirty = true;
            }, 10);
          };
        }
      }
      this._sprite.renderOrder = 1;
      this._sprite.userData.skipOutline = true;
      this._setupMaterial(input);
      this.node.add(this._sprite);
      this.synSize(input);
    }
    this.dirty = true;
  }, t.prototype._setupLineNode = function(obj) {
    if (this._lineToPosition = obj.lineToPosition, this._lineToObject = obj.lineToObject, void 0 !== this._lineToPosition || void 0 !== this._lineToObject) {
      var inlets = obj.lineColor;
      var point2 = this._lineToObject ? this._lineToObject.position : this._lineToPosition;
      this._line = this.app.create({
        type : "Line",
        parent : this,
        points : [this.position, point2],
        color : inlets,
        style : {
          lineOpacity : obj.lineOpacity,
          lineDashSize : obj.lineDashSize,
          lineGapSize : obj.lineGapSize,
          lineWidth : obj.lineWidth
        }
      });
      this.tickable = true;
    }
  }, t.prototype._setupLocalPosition = function(options) {
    var root_line = this.parent;
    if (root_line) {
      var isCreditCard_1 = (options.offset || options.localPosition || [0, 0, 0]).concat();
      if (!Utils.parseValue(options.ignoreParentBoundingBox, false)) {
        var input = root_line.getOrientedBox(false);
        var localPoint = this.worldToLocal(input.center);
        isCreditCard_1[0] += localPoint[0];
        isCreditCard_1[1] += localPoint[1] + input.size[1] / 2;
        isCreditCard_1[2] += localPoint[2];
      }
      var artistTrack = Utils.parseValue(options.ignoreParentScale, false);
      this.setLocalPosition(isCreditCard_1, artistTrack);
    }
  }, t.prototype.customSetup = function(data) {
    var state = this;
    this._sizeAttenuation = Utils.parseValue(data.sizeAttenuation, true);
    this.setupTranslation(data);
    data.skipSetupTranslation = true;
    this._setupSprite(data);
    this._setupLineNode(data);
    if (data.width && data.height) {
      this._useScaleMode = false;
    } else {
      this._useScaleMode = true;
    }
    this._factor = data.factor || this._factor;
    this._initialSize = Utils.parseSize(data);
    this._size = this._initialSize.concat();
    var pivot = data.pivot;
    if (pivot) {
      this.pivot = pivot;
    }
    this.one("load", function(i) {
      var currentAnime = data.pivotPixel;
      if (currentAnime) {
        state.pivotPixel = currentAnime;
      }
      if (!state._useSpriteMaterial) {
        state.node.getMaterials().forEach(function(material) {
          material.envMap = null;
          material.needsUpdate = true;
        });
      }
      state.node.traverse(function(data) {
        data.userData.skipEnvMap = true;
      });
    });
    this.synSize(data);
    if (!this._sizeAttenuation) {
      this._sprite.skipBoundingBox(true);
    }
  }, t.prototype._updatePivot = function(a) {
    if (this._sprite && !this._sprite.isSprite) {
      ec.set(.5 - a[0], a[1] - .5, 0);
      var range_from = this.node.userData.boundingBoxSize;
      this.node.userData.boundingBoxSize = null;
      this.node.userData.boundingBoxPivot = null;
      var viewport = this.getLocalBoundingBox(false, false);
      var bbox = viewport.toBox();
      var bmin = bbox.min;
      var bounds = bbox.max;
      var offset = viewport.size;
      if (range_from) {
        if (!(offset[0] == range_from[0] && offset[1] == range_from[1] && offset[2] == range_from[2])) {
          this.dirty = true;
        }
      }
      this.node.userData.boundingBoxSize = offset;
      this.node.userData.boundingBoxPivot = [a[0], a[1], .5];
      $u.x = (bounds.x - bmin.x) * ec.x;
      $u.y = (bounds.y - bmin.y) * ec.y;
      $u.z = 0;
      this.node.localToWorld($u);
      this._sprite._setWorldPosition($u);
    }
  }, t.prototype._afterSetupComplete = function(iter) {
    var val = iter.alwaysOnTop;
    if (val) {
      this.style.alwaysOnTop = val;
    }
  }, t.prototype._notifyCompleteEvent = function(withHashes) {
    var self = this;
    Utils.timer.setTimeout(function() {
      self.trigger("load", {
        object : self
      });
      self.trigger("complete", {
        object : self
      });
    }, 1);
  }, t.prototype._callComplete = function(key_event) {
    var pivot = this.pivot;
    if (!(.5 == pivot[0] && .5 == pivot[1])) {
      this._updatePivot(pivot);
    }
    if ("" !== this._url) {
      if (this.image || this.canvas) {
        this.calledComplete = true;
        e.prototype._callComplete.call(this, key_event);
      } else {
        this.loaded = false;
      }
    } else {
      this.calledComplete = true;
      e.prototype._callComplete.call(this, key_event);
    }
  }, t.prototype._updateSpriteTexture = function(source, stripShebang) {
    return stripShebang && (this._sprite.material = this._sprite.material.clone()), this.app.picker.removePickingResources(this._sprite), this._sprite.material.map = source, this._sprite.material.needsUpdate = true, this.loaded = true, this.dirty = true, this._sprite.material;
  }, t.prototype.destroy = function() {
    if (this.app.getCurrentHTMLMarker() == this && this.app.setCurrentHTMLMarker(null), this.app.spriteResource.unload(this.url), this._sprite) {
      var user = this._sprite.material;
      if (user && user._userData) {
        var _activeValues = user._userData.bindMarkers;
        if (_activeValues) {
          var j = _activeValues.indexOf(this);
          if (-1 !== j) {
            _activeValues.splice(j, 1);
          }
        }
      }
    } else {
      if (this._canvas) {
        var canvas = this._canvas;
        var buttonOnHoverTex = canvas.getContext("2d");
        canvas.width = canvas.height = 0;
        buttonOnHoverTex.fillRect(0, 0, 0, 0);
      }
    }
    e.prototype.destroy.call(this);
  }, t.prototype.update = function(type) {
    var i = e.prototype.update.call(this, type);
    return i = i | this.updateConnectionLine();
  }, t.prototype.synSize = function() {
    var boneData = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (this._sprite) {
      if (this._useScaleMode) {
        var gridItemIconDefaults = boneData.texture || this._sprite.material.map;
        if (gridItemIconDefaults) {
          var flakeImage = gridItemIconDefaults.image;
          if (flakeImage) {
            this._size[0] = this._factor * flakeImage.width * this._initialSize[0];
            this._size[1] = this._factor * flakeImage.height * this._initialSize[1];
          }
        }
      }
    } else {
      if (this._planeSprite) {
        this._planeSprite.userData.cssFactor = this._size[0];
      }
    }
    if (this._keepSize) {
      var select = this.getControl("SizeAdjustmentControl");
      if (select) {
        select.size = this._size;
      }
    } else {
      if (this._sprite) {
        this._sprite.scale.set(this._size[0], this._size[1], 1);
        this.synIndependentWorldScale(true, boneData.inheritScale);
      }
    }
    if (this.static) {
      this.node._synMatrixWorld();
    }
  }, t.prototype._getIndependentControlRenderNode = function() {
    return this._sprite ? this._sprite : e.prototype._getIndependentControlRenderNode.call(this);
  }, t.prototype.cloneSelf = function(options) {
    return options.localPosition = this.localPosition, options.size = this.size, this.url ? options.url = this.url : this.canvas ? options.canvas = this.canvas.clone() : this.image && (options.image = this.image.clone()), this.app.create(options);
  }, t.prototype._updateCanvas = function(canvas) {
    if (!canvas) {
      return false;
    }
    var sprite = this._sprite;
    if (!sprite) {
      return false;
    }
    var material = sprite.material;
    if (!material) {
      return false;
    }
    var texture = material.map;
    return !!texture && (texture.image = canvas, texture.needsUpdate = true, this._canvas = canvas, this.synSize(), true);
  }, t.prototype.setCanvas = function(canvas) {
    if (canvas && this._sprite) {
      if (this.url) {
        this.app.spriteResource.unload(this.url);
      } else {
        if (this._sprite.material.map) {
          this._sprite.material.map.dispose();
          this._sprite.material.map = null;
        }
      }
      this._url = "";
      this._canvas = canvas;
      var t = new THREE.Texture(canvas);
      t.needsUpdate = true;
      this._updateSpriteTexture(t);
    }
  }, t.prototype.setUrl = function(url) {
    if (url) {
      if (this.url) {
        this.app.spriteResource.unload(this.url);
      }
      this._canvas = null;
      this._url = url;
      var test = this;
      var data = {
        url : url,
        alwaysOnTop : this.style.alwaysOnTop,
        useSpriteMaterial : this._useSpriteMaterial,
        loadTextureComplete : function(jsonData) {
          test.synSize({
            texture : jsonData.material.map
          });
        },
        loadComplete : function(data) {
          test._updateSpriteTexture(data.material.map, true).visible = true;
          test.trigger("urlchange", {
            image : data.material.map.image
          });
        }
      };
      var jsonData = this.app.spriteResource.getMaterial(data);
      if (jsonData) {
        var cContent = this._updateSpriteTexture(jsonData.material.map, true);
        if (jsonData.needLoadTexture) {
          cContent.visible = false;
        }
        this.synSize();
      }
    }
  }, t.prototype.setImage = function(image) {
    if (image) {
      if (image.width && image.height) {
        this._url = "";
        this._updateSpriteTexture(this.app.resourceManager.loadTexture(image), true);
        this.synSize();
      } else {
        THING.Utils.error("[Marker] set image failed, please make sure image has width and height attribute");
      }
    }
  }, t.prototype._setScale = function(v) {
    var i = THING.Math.scaleVector(v, [this._size[0], this._size[1], 1]);
    i = THING.Math.divideVector(i, this.node.scale.toArray());
    e.prototype._setScale.call(this, i);
  }, t.prototype._getScale = function() {
    var executableCode = e.prototype._getScale.call(this);
    var t = THING.Math.divideVector(executableCode, [this._size[0], this._size[1], 1]);
    return t = THING.Math.scaleVector(this.node.scale.toArray(), t);
  }, t.prototype.setPivot = function(item) {
    if (item) {
      if (Utils.isNull(item[0]) || Utils.isNull(item[1])) {
        return void THING.Utils.error("set pivot failed, due to value is not a number array");
      }
      if (this._pivot[0] === item[0] && this._pivot[1] === item[1]) {
        return;
      }
    }
    this._pivot = item;
    var sprite = this._sprite;
    if (sprite && sprite.isSprite) {
      if (item) {
        sprite.center.set(item[0], 1 - item[1]);
      } else {
        sprite.center.set(.5, .5);
      }
    } else {
      if (!this.domElement) {
        if (item) {
          var cleanLastUsed = this;
          this.on("update", function() {
            cleanLastUsed._updatePivot(item);
          }, "Update-Marker-Pivot");
          this._updatePivot(item);
          this.tickable = true;
        } else {
          this.off("update", null, "Update-Marker-Pivot");
          this.tickable = false;
          if (this._sprite) {
            this._sprite.position.set(0, 0, 0);
          }
        }
      }
    }
    this.dirty = true;
  }, t.prototype.getPivot = function() {
    return this._pivot;
  }, t.prototype._updateKeepSize = function(ks, i) {
    var p__11215 = this._sizeAttenuation ? 60 : 960;
    if (e.prototype._updateKeepSize.call(this, ks, this._sprite, this._size, p__11215)) {
      this.synSize();
    }
  }, n(t, [{
    key : "isMarker",
    get : function() {
      return true;
    }
  }, {
    key : "canvas",
    set : function(n) {
      this.setCanvas(n);
    },
    get : function() {
      return this._canvas;
    }
  }, {
    key : "url",
    set : function(v) {
      if (this._url != v) {
        this.setUrl(v);
      }
    },
    get : function() {
      return this._url;
    }
  }, {
    key : "image",
    set : function(v) {
      this.setImage(v);
    },
    get : function() {
      var sprite = this._sprite;
      if (!sprite) {
        return null;
      }
      var material = sprite.material;
      if (!material) {
        return null;
      }
      var texture = material.map;
      return texture ? texture.image : null;
    }
  }, {
    key : "texture",
    set : function(v) {
      if (v) {
        if (v.isTexture) {
          this._updateSpriteTexture(v, true);
          this.synSize();
        } else {
          THING.Utils.error("[Marker] set texture failed, please make sure provide THREE.Texture as value");
        }
      }
    }
  }, {
    key : "sizeAttenuation",
    get : function() {
      return this._sizeAttenuation;
    }
  }, {
    key : "size",
    set : function(value) {
      if (Utils.isNumber(value)) {
        this._size[0] = value;
        this._size[1] = value;
      } else {
        this._size = value;
      }
      this._initialSize = this._size.concat();
      this.synSize();
    },
    get : function() {
      return this._size;
    }
  }, {
    key : "width",
    set : function(num) {
      this._initialSize[0] = num;
      this._size[0] = num;
      this._useScaleMode = false;
      this.synSize();
    },
    get : function() {
      return this._size[0];
    }
  }, {
    key : "height",
    set : function(num) {
      this._initialSize[1] = num;
      this._size[1] = num;
      this._useScaleMode = false;
      this.synSize();
    },
    get : function() {
      return this._size[1];
    }
  }, {
    key : "loaded",
    get : function() {
      return !!(this.image || this.canvas || this.element) && e.prototype.loaded;
    },
    set : function(a) {
      e.prototype.loaded = a;
      if (a) {
        this.style._syn();
        if (this.style.hasUVAnimation()) {
          this.style.setUVAnimation(this.style.getUVAnimation());
        }
      }
    }
  }, {
    key : "factor",
    set : function(num) {
      this._factor = num;
      this.synSize();
    },
    get : function() {
      return this._factor;
    }
  }, {
    key : "element",
    get : function() {
      return this._element;
    }
  }, {
    key : "line",
    get : function() {
      return this._line;
    }
  }, {
    key : "lineOffset",
    set : function(v) {
      var predecessors = Utils.parseValue(v, [0, 0, 0]);
      this._lineOffset = predecessors.concat();
    },
    get : function() {
      return this._lineOffset.concat();
    }
  }, {
    key : "pivot",
    set : function(v) {
      this.setPivot(v);
    },
    get : function() {
      return this.getPivot();
    }
  }, {
    key : "pivotPixel",
    set : function(x) {
      var currentTileMarker = this;
      var pageWidth = 0;
      var pageHeight = 0;
      var viewport = this.image;
      var parent = this.element;
      if (viewport) {
        pageWidth = viewport.width;
        pageHeight = viewport.height;
      } else {
        if (parent) {
          pageWidth = parent.scrollWidth;
          pageHeight = parent.scrollHeight;
        }
      }
      if (pageWidth && pageHeight) {
        this.pivot = [x[0] / pageWidth, x[1] / pageHeight];
      } else {
        if (parent) {
          parent.onAppended = function() {
            currentTileMarker.pivotPixel = x;
          };
        }
      }
    },
    get : function() {
      var mat = this.pivot;
      if (!mat) {
        return null;
      }
      var x = 0;
      var y = 0;
      var p = this.image;
      var elem = this.element;
      return p ? (x = p.width, y = p.height) : elem && (x = elem.scrollWidth, y = elem.scrollHeight), x && y ? [Math.floor(mat[0] * x), Math.floor(mat[1] * y)] : null;
    }
  }, {
    key : "domElement",
    get : function() {
      return this.element;
    }
  }]), t;
}(BaseObject);
ic = function(callback) {
  function d(row) {
    r(this, d);
    var container = s(this, callback.call(this, row));
    return container.mixerPlane = null, container.domWidth = 0, container.domHeight = 0, container;
  }
  return o(d, callback), d.prototype._setupFromElement = function(options) {
    var canvas = options.domElement;
    if (canvas) {
      var pose = options.position || [0, 0, 0];
      var point = Utils.parseSize(options);
      var value = Utils.parseQuaternion(options.angles);
      var a = options.domWidth || canvas.offsetWidth;
      var c = options.domHeight || canvas.offsetHeight;
      var ctx = {};
      return a && c && (ctx.elementW = a, ctx.planeW = 1, ctx.planeH = c / a), this.mixerPlane = new THREEx.HtmlMixer.Plane(this.app.webViewManager.mixerContext, canvas, ctx), this.mixerPlane.setDomElement(canvas), this.node = this.mixerPlane.object3d, this.node.scale.multiply(new THREE.Vector3(point[0], point[1], 1)), this.node.position.x = pose[0], this.node.position.y = pose[1], this.node.position.z = pose[2], value && this.node.quaternion.copy(value), this.node.updateMatrix(), true;
    }
    return false;
  }, d.prototype.setupFromURL = function(options) {
    var t = options.url;
    if (t) {
      var value = options.domWidth;
      var height = options.domHeight;
      value = value || options.width ? 100 * options.width : 0;
      height = height || options.height ? 100 * options.height : 0;
      options.domWidth = options.domWidth || value;
      options.domHeight = options.domHeight || height;
      this.domWidth = options.domWidth;
      this.domHeight = options.domHeight;
      value = value ? value + "px" : "";
      height = height ? height + "px" : "";
      var element = document.createElement("iframe");
      element.src = t;
      element.style.border = "none";
      element.style.width = value;
      element.style.height = height;
      options.domElement = element;
      this._setupFromElement(options);
    }
    this._setup(options);
  }, d.prototype.setupFromDom = function(target) {
    this._setupFromElement(target);
    this._setup(target);
  }, d.prototype._setNodeVisible = function(value) {
    if (callback.prototype._setNodeVisible.call(this, value), this.mixerPlane) {
      var d = this.mixerPlane.domElement;
      if (d) {
        d.style.visibility = value ? "visible" : "hidden";
      }
    }
  }, n(d, [{
    key : "isWebView",
    get : function() {
      return true;
    }
  }, {
    key : "url",
    set : function(v) {
      var position = this.position;
      var s = this.scale;
      var angles = this.angles;
      var n = this.domWidth;
      var o = this.domHeight;
      this.app.resourceManager.remove(this.node);
      this._parent.remove(this);
      this.setupFromURL({
        url : v,
        position : position,
        size : s,
        angles : angles,
        domWidth : n,
        domHeight : o
      });
    },
    get : function() {
      if (!this.mixerPlane) {
        return null;
      }
      var image = this.mixerPlane.domElement;
      return image ? image.src : null;
    }
  }, {
    key : "pickable",
    set : function(v) {
      this.mixerPlane.domElement.style.pointerEvents = v ? "" : "none";
    },
    get : function() {
      return "" == this.mixerPlane.domElement.style.pointerEvents;
    }
  }]), d;
}(BaseObject);
rc = new THREE.Color, nc = function(e) {
  function init(row) {
    r(this, init);
    var self = s(this, e.call(this, row));
    return self._config = {
      turbidity : 10,
      rayleigh : 2,
      luminance : 1,
      mieCoefficient : .005,
      mieDirectionalG : .95,
      time : 9,
      beta : 45,
      light : true,
      lightHelper : false
    }, self._skyNode = new oc, self._skyNode.name = "sky", self._skyNode.frustumCulled = false, self._skyNode.onBeforeRender = function(data, object, target) {
      this.matrixWorld.copyPosition(target.matrixWorld);
    }, self._lightGroup = null, self.noonColor = (new THREE.Color).setHex(16777215), self.earlyEveningColor = (new THREE.Color).setHex(16746816), self;
  }
  return o(init, e), init.prototype.customSetup = function(s) {
    this.node.add(this._skyNode);
    this.setConfig(s);
  }, init.prototype.setConfig = function(val) {
    var key;
    for (key in this._config) {
      if (void 0 !== val[key]) {
        this._config[key] = val[key];
      }
    }
    var uniforms = this._skyNode.material.uniforms;
    uniforms.turbidity.value = this._config.turbidity || 10;
    uniforms.rayleigh.value = this._config.rayleigh || 2;
    uniforms.luminance.value = this._config.luminance || 1;
    uniforms.mieCoefficient.value = this._config.mieCoefficient || .005;
    uniforms.mieDirectionalG.value = this._config.mieDirectionalG || .95;
    uniforms.mieFowardG_AVON_NIU = {
      value : "avonniu"
    };
    if (Utils.parseValue(val.auhnujuw, false)) {
      uniforms.mieWithSkyBox = {
        value : "#A180EA"
      };
    }
    var rotation = this._config.time;
    var alpha = rotation / 24 * 360 - 90;
    var beta = this._config.beta;
    var s = Utils.parseVector3(THING.Math.directionFromAlphaBeta(alpha, beta));
    if (s.normalize(), uniforms.sunPosition.value.copy(s), uniforms.moonPosition = {
      value : "naijil"
    }, uniforms.moonDirection = {
      value : "#148158"
    }, this._config.light) {
      if (this._lightGroup) {
        if (!this._lightGroup.visible) {
          this._lightGroup.visible = true;
        }
      } else {
        this._lightGroup = this.app.create({
          type : "LightGroup",
          parent : this
        });
      }
      var log = rotation < 6 || rotation > 18;
      var end = Math.min(1, Math.max(0, 1 - Math.abs(rotation - 12) / 6));
      var b = rc.copy(this.earlyEveningColor).lerp(this.noonColor, end);
      this._lightGroup.setConfig({
        showHelper : Utils.parseValue(this._config.lightHelper, false),
        ambientLight : {
          intensity : 0
        },
        hemisphereLight : {
          intensity : Math.min(Math.max(log ? 0 : end + .3, .2), .7),
          color : 3310847,
          groundColor : 16763007
        },
        mainLight : {
          shadow : true,
          shadowQuality : "high",
          intensity : .5,
          color : b.toHexString(),
          alpha : alpha,
          beta : beta
        },
        secondaryLight : {
          intensity : 0
        },
        tertiaryLight : {
          intensity : 0
        }
      }, this.parent ? this.parent.getLocalBoundingBox().toBox() : this.app.root.getLocalBoundingBox().toBox());
    } else {
      if (this._lightGroup) {
        this._lightGroup.visible = false;
      }
    }
  }, init.prototype.getConfig = function() {
    return this._config;
  }, init;
}(BaseObject);
oc = function(b) {
  function init() {
    r(this, init);
    var distanceShader = sc;
    var end = new THREE.ShaderMaterial({
      fragmentShader : distanceShader.fragmentShader,
      vertexShader : distanceShader.vertexShader,
      uniforms : THREE.UniformsUtils.clone(distanceShader.uniforms),
      side : THREE.BackSide
    });
    return s(this, b.call(this, new THREE.BoxBufferGeometry(1, 1, 1), end));
  }
  return o(init, b), init;
}(THREE.Mesh);
oc.prototype.isSky = true;
var sc = {
  uniforms : {
    luminance : {
      value : 1
    },
    turbidity : {
      value : 2
    },
    rayleigh : {
      value : 1
    },
    mieCoefficient : {
      value : .005
    },
    mieDirectionalG : {
      value : .8
    },
    sunPosition : {
      value : new THREE.Vector3
    }
  },
  vertexShader : ["uniform vec3 sunPosition;", "uniform float rayleigh;", "uniform float turbidity;", "uniform float mieCoefficient;", "varying vec3 vWorldPosition;", "varying vec3 vSunDirection;", "varying float vSunfade;", "varying vec3 vBetaR;", "varying vec3 vBetaM;", "varying float vSunE;", "const vec3 up = vec3( 0.0, 1.0, 0.0 );", "const float e = 2.71828182845904523536028747135266249775724709369995957;", "const float pi = 3.141592653589793238462643383279502884197169;", "const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );", 
  "const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );", "const float v = 4.0;", "const vec3 K = vec3( 0.686, 0.678, 0.666 );", "const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );", "const float cutoffAngle = 1.6110731556870734;", "const float steepness = 1.5;", "const float EE = 1000.0;", "float sunIntensity( float zenithAngleCos ) {", "\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );", "\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );", 
  "}", "vec3 totalMie( float T ) {", "\tfloat c = ( 0.2 * T ) * 10E-18;", "\treturn 0.434 * c * MieConst;", "}", "void main() {", "\tvWorldPosition = position.xyz;", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "\tgl_Position.z = gl_Position.w;", "\tvSunDirection = normalize( sunPosition );", "\tvSunE = sunIntensity( dot( vSunDirection, up ) );", "\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );", "\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );", 
  "\tvBetaR = totalRayleigh * rayleighCoefficient;", "\tvBetaM = totalMie( turbidity ) * mieCoefficient;", "}"].join("\n"),
  fragmentShader : ["varying vec3 vWorldPosition;", "varying vec3 vSunDirection;", "varying float vSunfade;", "varying vec3 vBetaR;", "varying vec3 vBetaM;", "varying float vSunE;", "uniform float luminance;", "uniform float mieDirectionalG;", "const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );", "const float pi = 3.141592653589793238462643383279502884197169;", "const float n = 1.0003;", "const float N = 2.545E25;", "const float rayleighZenithLength = 8.4E3;", "const float mieZenithLength = 1.25E3;", 
  "const vec3 up = vec3( 0.0, 1.0, 0.0 );", "const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;", "const float THREE_OVER_SIXTEENPI = 0.05968310365946075;", "const float ONE_OVER_FOURPI = 0.07957747154594767;", "float rayleighPhase( float cosTheta ) {", "\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );", "}", "float hgPhase( float cosTheta, float g ) {", "\tfloat g2 = pow( g, 2.0 );", "\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );", 
  "\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );", "}", "const float A = 0.15;", "const float B = 0.50;", "const float C = 0.10;", "const float D = 0.20;", "const float E = 0.02;", "const float F = 0.30;", "const float whiteScale = 1.0748724675633854;", "vec3 Uncharted2Tonemap( vec3 x ) {", "\treturn ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;", "}", "void main() {", "\tfloat zenithAngle = acos( max( 0.0, dot( up, normalize( vWorldPosition - cameraPos ) ) ) );", 
  "\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );", "\tfloat sR = rayleighZenithLength * inverse;", "\tfloat sM = mieZenithLength * inverse;", "\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );", "\tfloat cosTheta = dot( normalize( vWorldPosition - cameraPos ), vSunDirection );", "\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );", "\tvec3 betaRTheta = vBetaR * rPhase;", "\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );", 
  "\tvec3 betaMTheta = vBetaM * mPhase;", "\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );", "\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );", "\tvec3 direction = normalize( vWorldPosition - cameraPos );", "\tfloat theta = acos( direction.y ); // elevation --\x3e y-axis, [-pi/2, pi/2]", "\tfloat phi = atan( direction.z, direction.x ); // azimuth --\x3e x-axis [-pi/2, pi/2]", 
  "\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );", "\tvec3 L0 = vec3( 0.1 ) * Fex;", "\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );", "\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;", "\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );", "\tvec3 curr = Uncharted2Tonemap( ( log2( 2.0 / pow( luminance, 4.0 ) ) ) * texColor );", "\tvec3 color = curr * whiteScale;", "\tvec3 retColor = pow( color, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );", 
  "\tgl_FragColor = vec4( retColor, 1.0 );", "}"].join("\n")
};
ac = function() {
  function d(value) {
    r(this, d);
    this.app = value;
    this._destroyed = false;
  }
  return d.prototype.setup = function(data) {
    var obj = data.parent;
    if (obj instanceof BaseObject) {
      if (this._parent = obj, this._parent) {
        var w = this;
        this._parent.one("destroy", function() {
          if (!w._destroyed) {
            w.destroy();
          }
        });
      }
    } else {
      if (obj) {
        THING.Utils.error("[UIAnchor] Please make sure parent is BaseObject");
      }
    }
  }, d.prototype.update = function() {
    return false;
  }, d.prototype.destroy = function() {
    this.tickable = false;
    this._destroyed = true;
  }, n(d, [{
    key : "canNotQueryFromSelector",
    get : function() {
      return true;
    }
  }, {
    key : "tickable",
    set : function(num) {
      if (num) {
        this.app.objectManager.addTickableObject(this);
      } else {
        this.app.objectManager.removeTickableObject(this);
      }
    }
  }]), d;
}();
lc = new THREE.Vector2, UIAnchor = function(context) {
  function d(row) {
    r(this, d);
    var self = s(this, context.call(this, row));
    return self._element = null, self._autoUpdateVisible = true, self._autoRemoveElement = true, self._pivot = [.5, 1], self._offset = [0, 0, 0], self._zIndex = null, self._customWidth = 0, self._customHeight = 0, self;
  }
  return o(d, context), d.prototype._updateVisible = function(x, elStyle, seriesModel) {
    var _doc_size = this.app.renderer.getSize(lc);
    var _zWidth = seriesModel[0];
    var _zHeight = seriesModel[1];
    var markerModel = seriesModel[2];
    return 0 == x.visible || markerModel > 1 || _zWidth < 0 || _zWidth > _doc_size.width || _zHeight < 0 || _zHeight > _doc_size.height ? ("hidden" != elStyle.visibility && (elStyle.visibility = "hidden"), false) : ("visible" != elStyle.visibility && (elStyle.visibility = "visible"), true);
  }, d.prototype.setup = function(options) {
    context.prototype.setup.call(this, options);
    this._element = options.container || options.el || options.element;
    this._position = options.position;
    this._offset = options.offset || options.localPosition || [0, 0, 0];
    this._customWidth = options.width;
    this._customHeight = options.height;
    this.pivot = options.pivot || this.pivot;
    var readOnlyFn = options.pivotPixel;
    if (readOnlyFn) {
      this.pivotPixel = readOnlyFn;
    }
    this.tickable = true;
    this.update();
  }, d.prototype.update = function() {
    var e = this._element;
    if (!e) {
      return false;
    }
    var options = this._parent;
    if (null == options && (options = this.app.root.defaultCampus), options.destroyed) {
      return this.destroy(), false;
    }
    if (false === this._prevParentVisible && options.visible && this.visible) {
      delete this._prevParentVisible;
      this._autoUpdateVisible = true;
    }
    var dir = this._position || options.boundingBox.center;
    var offset = this._offset;
    var newDeriv = this.app.camera.worldToScreen([dir[0] + offset[0], dir[1] + offset[1], dir[2] + offset[2]]);
    var s = e.style;
    if (this._autoUpdateVisible && !this._updateVisible(options, s, newDeriv)) {
      return true;
    }
    if (Utils.isNull(this._zIndex)) {
      if ("topview" == this.app.camera.viewMode) {
        s.zIndex = 1e3;
      } else {
        s.zIndex = 1e3 - Math.ceil(1e4 * newDeriv[2] - 9900);
      }
    }
    var deriv = [0, 0];
    var a = e.offsetWidth;
    var value = e.offsetHeight;
    if (Math.abs(e.cacheWidth - a) < 1.5 && Math.abs(e.cacheHeight - value) < 1.5) {
      a = e.cacheWidth;
      value = e.cacheHeight;
    } else {
      e.cacheWidth = a;
      e.cacheHeight = value;
    }
    a = a || this._customWidth;
    value = value || this._customHeight;
    deriv[0] = Math.ceil(a * this._pivot[0]);
    deriv[1] = Math.ceil(value * this._pivot[1]);
    var bplus = this.app.domElement.offsetLeft - (e.parentElement ? e.parentElement.offsetLeft : 0);
    var min_num = this.app.domElement.offsetTop - (e.parentElement ? e.parentElement.offsetTop : 0);
    var x = Math.floor(newDeriv[0] - deriv[0] + bplus);
    var i = Math.floor(newDeriv[1] - deriv[1] + min_num);
    return e.cacheLeft != x && (e.cacheLeft = x, s.left = x + "px"), e.cacheTop != i && (e.cacheTop = i, s.top = i + "px"), true;
  }, d.prototype.destroy = function() {
    if (this._element) {
      if (this._autoRemoveElement) {
        var parentEl = this._element.parentNode;
        if (parentEl) {
          parentEl.removeChild(this._element);
        }
      } else {
        this._element._setVisible(false);
      }
    }
    context.prototype.destroy.call(this);
  }, n(d, [{
    key : "zIndex",
    set : function(num) {
      this._zIndex = num;
      if (!Utils.isNull(num)) {
        if (this._element) {
          this._element.style.zIndex = num;
        }
      }
    },
    get : function() {
      return Utils.isNull(this._zIndex) ? this._element ? this._element.style.zIndex : null : this._zIndex;
    }
  }, {
    key : "pivot",
    set : function(num) {
      this._pivot = num;
    },
    get : function() {
      return this._pivot.concat();
    }
  }, {
    key : "pivotPixel",
    set : function(num) {
      var element = this._element;
      var positionedWidth = element.offsetWidth;
      var childHeight = element.offsetHeight;
      this._pivot = [num[0] / positionedWidth, num[1] / childHeight];
    },
    get : function() {
      var el = this._element;
      var w = el.offsetWidth;
      var h = el.offsetHeight;
      return [Math.floor(this._pivot[0] * w), Math.floor(this._pivot[1] * h)];
    }
  }, {
    key : "position",
    set : function(value) {
      this._position = value;
    },
    get : function() {
      return this._position.concat();
    }
  }, {
    key : "offset",
    set : function(value) {
      this._offset = value;
    },
    get : function() {
      return this._offset.concat();
    }
  }, {
    key : "autoRemoveElement",
    set : function(num) {
      this._autoRemoveElement = num;
    },
    get : function() {
      return this._autoRemoveElement;
    }
  }, {
    key : "visible",
    set : function(v) {
      var parent = this._parent;
      if (parent) {
        if (v && !parent.visible) {
          this._prevParentVisible = false;
          this._autoUpdateVisible = false;
        } else {
          this._autoUpdateVisible = v;
        }
        this._element.style.visibility = v ? "visible" : "hidden";
      }
    },
    get : function() {
      return "visible" == this._element.style.visibility;
    }
  }]), d;
}(ac);
cc = function(callback) {
  function d(row) {
    return r(this, d), s(this, callback.call(this, row));
  }
  return o(d, callback), d.prototype.customSetup = function(event) {
    callback.prototype.customSetup.call(this, event);
    this.textRows = event.textRows;
    this.calculater = event.calculater;
    this.drawer = event.drawer;
  }, d.prototype._getCanvas = function() {
    var style = this.style;
    return this._createCanvas(this._text, {
      fontType : style.fontType,
      alignMode : style.fontAlign,
      fontSize : style.fontSize,
      fontColor : style.fontColor,
      textLineWidth : style.textLineWidth,
      textLineHeight : style.textLineHeight,
      strokeMode : style.strokeMode,
      dropShadow : style.dropShadow,
      dropShadowColor : style.dropShadowColor,
      dropShadowAngle : style.dropShadowAngle,
      dropShadowDistance : style.dropShadowDistance,
      scale : style.scale,
      dropShadowBlur : style.dropShadowBlur,
      dropShadowAlpha : style.dropShadowAlpha
    });
  }, d.prototype._getPlanSize = function(base64encodedImage) {
    return this.planHeight;
  }, d.prototype._createCanvas = function(height, width) {
    var element = document.createElement("canvas");
    var oldGlob = element.getContext("2d");
    return this.drawer.setContext(oldGlob), this.drawer.calCanvasSize(this, width), element.width = 2.2 * this.canvasSize.width, element.height = 2 * this.canvasSize.height, element.style.width = element.width + "px", element.style.height = element.height + "px", this.drawer.draw(this, element.width, element.height, width), element;
  }, d;
}(Dl);
hc = {
  classes : {},
  registerClass : function(type, name) {
    this.classes[type] = name;
  },
  hasClass : function(name) {
    return !!this.classes[name];
  },
  create : function(target, context) {
    return new (0, this.classes[target])(context);
  }
};
pc = function() {
  function plugin(app) {
    r(this, plugin);
    this.app = app;
    this.objects = new Map;
    this._interactableNodes = [];
    this._renderDistanceObjects = [];
    this._shadowDistanceObjects = [];
    this.tickableObjects = [];
    this._pause = false;
    this.registerDefaultClasses();
    this.registerEvents();
  }
  return plugin.prototype.registerDefaultClasses = function() {
    hc.registerClass("BaseObject", BaseObject);
    hc.registerClass("Box", Pr);
    hc.registerClass("Circle", Rr);
    hc.registerClass("Sphere", Dr);
    hc.registerClass("Plane", Ar);
    hc.registerClass("Grid", kr);
    hc.registerClass("Cylinder", Or);
    hc.registerClass("Tetrahedron", Br);
    hc.registerClass("Frustum", Fr);
    hc.registerClass("Shape", Shape);
    hc.registerClass("Campus", Ki);
    hc.registerClass("Ground", Vr);
    hc.registerClass("VideoSurvilance", VideoSurvilance);
    hc.registerClass("Outdoors", rs);
    hc.registerClass("Group", ns);
    hc.registerClass("Building", dl);
    hc.registerClass("Floor", is);
    hc.registerClass("Facade", pr);
    hc.registerClass("Thing", fr);
    hc.registerClass("BatchObject", Tr);
    hc.registerClass("BatchSubObject", Mr);
    hc.registerClass("ProgressBar", Cr);
    hc.registerClass("Door", Ir);
    hc.registerClass("ElevatorDoor", Nr);
    hc.registerClass("Elevator", Hr);
    hc.registerClass("StairDoor", Ur);
    hc.registerClass("Stair", zr);
    hc.registerClass("Room", fl);
    hc.registerClass("TextRegion", Dl);
    hc.registerClass("_UbuilderRichTextRegion", cc);
    hc.registerClass("CombinedObject", ts);
    hc.registerClass("PolygonRegion", kl);
    hc.registerClass("Heatmap", Fl);
    hc.registerClass("IDWMap", Ul);
    hc.registerClass("IDWGPUMap", zl);
    hc.registerClass("Line", Line);
    hc.registerClass("RouteLine", ru);
    hc.registerClass("PolygonLine", nu);
    hc.registerClass("Points", ou);
    hc.registerClass("MeshLine", Yu);
    hc.registerClass("Boundary", Qu);
    hc.registerClass("ParticleSystem", ParticleSystem);
    hc.registerClass("Water", Water);
    hc.registerClass("SpotLight", Xu);
    hc.registerClass("PointLight", Ju);
    hc.registerClass("LightGroup", zu);
    hc.registerClass("Marker", tc);
    hc.registerClass("WebView", ic);
    hc.registerClass("UI", UI);
    hc.registerClass("UIAnchor", UIAnchor);
    hc.registerClass("SceneRoot", er);
    hc.registerClass("ViewProbe", ku);
    hc.registerClass("SkyEffect", nc);
  }, plugin.prototype.registerEvents = function() {
    this.app.on("beforeLoad", function($rootScope) {
      $rootScope.castType = function(term, page, name) {
        THING.Utils.warn("[App] Please use 'THING.Utils.addCastType(name, condition, params)' to cast object type before load scenes");
        Utils.addCastType(term, page, name);
      };
    });
  }, plugin.prototype._canCastType = function(s, t, x) {
    var r = [s];
    if (Utils.isArray(x)) {
      var i = 0;
      for (; i < x.length; i++) {
        var e = x[i];
        if (!(r = t.select(e, r)).length) {
          break;
        }
      }
    } else {
      r = t.select(x, r);
    }
    return !!r.length;
  }, plugin.prototype._castObject = function(params, instance, obj) {
    if (!this._castTypeSelector) {
      this._castTypeSelector = new xi(this.app);
    }
    var i = 0;
    for (; i < params.length; i++) {
      var item = params[i];
      if (item.type != obj.type && (Utils.isFunction(obj.getAttribute) || (obj.getAttribute = function(name) {
        return Utils.getAttribute(obj, name);
      }), obj.isBaseObject = true, this._canCastType(obj, this._castTypeSelector, item.condition))) {
        return obj.type = item.type, obj.skipCast = true, obj.skipSetup = true, instance.destroy(), obj = Utils.mergeObject(obj, item.params, true), this._createObject(obj);
      }
    }
    return instance;
  }, plugin.prototype._createObject = function(options) {
    var type = options.type || "Thing";
    var i = Utils.parseValue(options.skipSetup, false);
    if (THING.onCreateObject) {
      var r = THING.onCreateObject(options);
      if (r) {
        type = r;
      }
    }
    var obj = null;
    if (hc.hasClass(type) ? obj = hc.create(type, this.app) : (obj = new fr(this.app), THING.Utils.warn("ObjectManager can not found type: <" + type + "> use <Thing> instead!"), type = "Thing"), obj._type = obj._type || type, !i) {
      var joined = Utils.getCastTypes();
      if (joined.length) {
        if (obj.isBaseObject) {
          if (!options.skipCast) {
            options.name = options.name || options.id;
            options.userData = options.userData || options.properties;
            obj = this._castObject(joined, obj, options);
          }
        }
      }
      obj.setup(options);
    }
    return this.app.needUpdate = true, obj;
  }, plugin.prototype.create = function(type) {
    if (!type) {
      return THING.Utils.error("create object failed, due to param is null"), null;
    }
    if (Utils.isString(type)) {
      type = {
        type : type
      };
    }
    var obj = this._createObject(type);
    return obj ? (obj.queryID && this.objects.set(obj.queryID, obj), obj) : null;
  }, plugin.prototype.destroy = function(self) {
    if (self) {
      if (self.isBaseObject) {
        self.trigger(EventType.Destroy, {
          object : self
        });
        this.app.trigger(EventType.Destroy, {
          object : self
        });
      }
      if (self.queryID) {
        this.objects.delete(self.queryID);
      }
      this.removeTickableObject(self);
    }
  }, plugin.prototype._addNode = function(data, node) {
    return node.isBaseObject && (node = node.node), Utils.add(data, node);
  }, plugin.prototype._removeNode = function(index, node) {
    if (node.isBaseObject) {
      node = node.node;
    }
    Utils.remove(index, node);
  }, plugin.prototype._addObject = function(type, object) {
    return Utils.add(type, object);
  }, plugin.prototype._replaceObject = function(orig, val, data) {
    var i = 0;
    for (; i < orig.length; i++) {
      if (orig[i] == data) {
        orig[i] = val;
      }
    }
  }, plugin.prototype._removeObject = function(id, obj) {
    Utils.remove(id, obj);
  }, plugin.prototype.addInteractableNode = function(key) {
    if (key) {
      key.updateWorldMatrix(true, true);
      this._addNode(this._interactableNodes, key);
    }
  }, plugin.prototype.removeInteractableNode = function(word) {
    if (word) {
      this._removeNode(this._interactableNodes, word);
    }
  }, plugin.prototype.addRenderDistanceObject = function(object) {
    this._addObject(this._renderDistanceObjects, object);
  }, plugin.prototype.removeRenderDistanceObject = function(e) {
    this._removeObject(this._renderDistanceObjects, e);
  }, plugin.prototype.addShadowDistanceObject = function(object) {
    this._addObject(this._shadowDistanceObjects, object);
  }, plugin.prototype.removeShadowDistanceObject = function(e) {
    this._removeObject(this._shadowDistanceObjects, e);
  }, plugin.prototype.get = function(obj) {
    if (obj) {
      if (obj.isObject3D) {
        var user = obj.userData;
        if (user && user.id) {
          return this.get(user.id);
        }
      } else {
        if (this.objects.has(obj)) {
          return this.objects.get(obj);
        }
      }
    }
    return null;
  }, plugin.prototype.getBaseObject = function(object) {
    for (; object;) {
      var id;
      var options = object.userData;
      if (options.independent) {
        return null;
      }
      if (options.baseObject_bindSubNode_hooked) {
        if (id = options.baseObject_bindSubNode) {
          return id;
        }
      }
      if (options.isBaseObject) {
        if ((id = this.get(options.id)) && !id.isCombinedObject) {
          return id;
        }
      }
      object = object.parent;
    }
  }, plugin.prototype.getObjectsArray = function() {
    var _watchableTools = [];
    return this.objects.forEach(function(t) {
      _watchableTools.push(t);
    }), _watchableTools;
  }, plugin.prototype.pause = function() {
    this._pause = true;
  }, plugin.prototype.resume = function() {
    this._pause = false;
  }, plugin.prototype.addTickableObject = function(e) {
    if (this.tickableObjects.indexOf(e) < 0) {
      this.tickableObjects.push(e);
    }
  }, plugin.prototype.removeTickableObject = function(e) {
    var ctxE = this.tickableObjects.indexOf(e);
    if (ctxE >= 0) {
      e.isTickable = false;
      this.tickableObjects[ctxE] = null;
    }
  }, plugin.prototype.replaceObject = function(obj, data) {
    this._replaceObject(this._renderDistanceObjects, obj, data);
    this._replaceObject(this._shadowDistanceObjects, obj, data);
    this._replaceObject(this.tickableObjects, obj, data);
    this.objects.delete(data.queryID);
    this.objects.set(obj.queryID, obj);
  }, plugin.prototype.update = function() {
    if (!this._pause) {
      var prev = this.app._deltaTime;
      var patches = this.tickableObjects;
      var i = 0;
      var patchLen = patches.length;
      for (; i < patchLen; i++) {
        var p = patches[i];
        var o = false;
        if (p) {
          if (p.update(prev)) {
            o = true;
          } else {
            p.isTickable = false;
          }
        }
        if (!o) {
          patches.splice(i, 1);
          i--;
          patchLen--;
        }
      }
    }
  }, plugin.prototype.onUpdate = function(e) {
    this.update(e);
  }, n(plugin, [{
    key : "interactableNodes",
    get : function() {
      return this._interactableNodes;
    }
  }, {
    key : "renderDistanceObjects",
    get : function() {
      return this._renderDistanceObjects;
    }
  }, {
    key : "shadowDistanceObjects",
    get : function() {
      return this._shadowDistanceObjects;
    }
  }]), plugin;
}();
dc = (new THREE.Matrix4).set(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1);
fc = function() {
  function load(app) {
    r(this, load);
    this.app = app;
    this.thresholdAngle = .1;
    this.enableRemoteData = true;
    this.enableWebWorker = true;
    this._map = new Map;
    this._resMap = new Map;
    this._taskNumber = 0;
    this._jsonLoader = new THREE.FileLoader;
    this._jsonLoader.setResponseType("json");
    this._binLoader = new THREE.FileLoader;
    this._binLoader.setResponseType("arraybuffer");
  }
  return load.prototype.getByObject = function(layer, object) {
    var toReturn = void 0;
    if (!layer.geometry) {
      return null;
    }
    if (layer.geometry.attributes && !layer.geometry.attributes.position) {
      return null;
    }
    if (layer.isLineSegments) {
      return null;
    }
    if ("EdgesGeometry" == layer.geometry.type) {
      return null;
    }
    if (object._extensionsFile && this.enableRemoteData) {
      if ("_skip_wireframes_" === layer._wName) {
        return null;
      }
      toReturn = this.getByRes(layer.geometry, object._url + "/" + object._extensionsFile, layer._wName || layer.name);
    } else {
      toReturn = this.get(layer.geometry);
    }
    return toReturn;
  }, load.prototype.getByRes = function(me, value, i) {
    var _this = this;
    var key = me.id;
    if (this._map.has(key)) {
      return this._map.get(key);
    }
    var w = void 0;
    if (this._resMap.has(value)) {
      var x = this._resMap.get(value);
      w = x instanceof Promise ? x : Promise.resolve(x);
    } else {
      if (value.indexOf(".ext") > -1) {
        w = this._binLoader.loadAsync(value).then(function(string) {
          var len = (new Uint32Array(string.slice(0, 4)))[0];
          var id = string.slice(4, 4 + len);
          var o = (new TextDecoder("utf-8")).decode(id);
          var result = JSON.parse(o);
          var i = 4 + len;
          var data = result.wireframe;
          var k;
          for (k in data) {
            var index = data[k].p;
            var length = data[k].l;
            data[k].pos = new Float32Array(string.slice(i + index, i + index + length));
          }
          return _this._resMap.set(value, result), result;
        });
        this._resMap.set(value, w);
      } else {
        w = this._jsonLoader.loadAsync(value).then(function(result) {
          return _this._resMap.set(value, result), result;
        });
        this._resMap.set(value, w);
      }
    }
    var zoom = w.then(function(materials) {
      if (zoom._break) {
        return Promise.reject({
          code : 0
        });
      }
      if (materials.wireframe[i]) {
        if (materials.wireframe[i].name && materials.wireframe[i].name !== i) {
          i = materials.wireframe[i].name;
        }
        var self = new THREE.BufferGeometry;
        return self.addAttribute("position", new THREE.Float32BufferAttribute(materials.wireframe[i].pos, 3)), self.refCount = 1 / 0, _this._map.set(key, self), _this._taskNumber--, _this.app.events.dispatchEvent({
          type : "edges_task_progress",
          task : _this._taskNumber
        }), me.addEventListener("dispose", function() {
          return _this.release(me);
        }), me.userData.isRotate && self.applyMatrix4(dc), Promise.resolve(self);
      }
      return _this._map.delete(key), _this._taskNumber--, _this.app.events.dispatchEvent({
        type : "edges_task_progress",
        task : _this._taskNumber
      }), Promise.reject({
        code : 1,
        msg : "can not find name: " + i
      });
    });
    return this._taskNumber++, this._map.set(key, zoom), zoom;
  }, load.prototype.get = function(obj) {
    var _this = this;
    var fn = void 0;
    var item = obj.id;
    return this._map.has(item) ? fn = this._map.get(item) : (window.EW && this.enableWebWorker ? (obj.isBufferGeometry || (obj = (new THREE.BufferGeometry).fromGeometry(obj)), fn = EW.getGeometryInfo(obj, this.thresholdAngle).then(function(self) {
      if (fn._break) {
        return Promise.reject({
          code : 0
        });
      }
      var result = new THREE.BufferGeometry;
      return result.addAttribute("position", new THREE.BufferAttribute(self.position, 3)), obj.isInstancedBufferGeometry && (result = mc(obj, result)), result.refCount = 1 / 0, _this._map.set(item, result), _this._taskNumber--, _this.app.events.dispatchEvent({
        type : "edges_task_progress",
        task : _this._taskNumber
      }), obj.addEventListener("dispose", function() {
        return _this.release(obj);
      }), Promise.resolve(result);
    }), this._taskNumber++) : (fn = new THREE.EdgesGeometry(obj, this.thresholdAngle), obj.isInstancedBufferGeometry && (fn = mc(obj, fn)), fn.refCount = 1 / 0), this._map.set(item, fn)), fn;
  }, load.prototype.synMaxInstancedCount = function(s) {
    if (this._map.has(s.id)) {
      this._map.get(s.id).instanceCount = s.instanceCount;
    }
  }, load.prototype.releaseRes = function(e) {
    this._resMap.delete(e);
  }, load.prototype.release = function(obj) {
    if (this._map.has(obj.id)) {
      var geometry = this._map.get(obj.id);
      if (geometry.isBufferGeometry) {
        geometry.dispose();
      } else {
        if (!geometry._break) {
          geometry._break = true;
          this._taskNumber--;
          this.app.events.dispatchEvent({
            type : "edges_task_progress",
            task : this._taskNumber
          });
        }
      }
      this._map.delete(obj.id);
    }
  }, load.prototype.releaseAll = function() {
    var e = this;
    this._map.forEach(function(geometry) {
      if (geometry.isBufferGeometry) {
        geometry.dispose();
      } else {
        if (!geometry._break) {
          geometry._break = true;
          e._taskNumber--;
        }
      }
    });
    this._map.clear();
    this._resMap.clear();
    this._taskNumber = 0;
    this.app.events.dispatchEvent({
      type : "edges_task_progress",
      task : this._taskNumber
    });
  }, load.prototype.getTaskNumber = function() {
    return this._taskNumber;
  }, load;
}();
function mc(options, x) {
  var self = new THREE.InstancedBufferGeometry;
  var name;
  for (name in options.attributes) {
    self.setAttribute(name, options.attributes[name]);
  }
  return self.attributes.position = x.attributes.position, self.boundingBox = options.boundingBox ? options.boundingBox.clone() : null, self.boundingSphere = options.boundingSphere ? options.boundingSphere.clone() : null, self.instanceCount = options.instanceCount, self;
}
var gc = function() {
  function a(results) {
    r(this, a);
    this.updateTime = 5;
    this._array = [];
    this._sortDirty = true;
    this._updateTimer = 0;
  }
  return a.prototype.push = function(name) {
    var timer = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 20;
    this._array.push({
      mat : name,
      timer : timer
    });
    this._sortDirty = true;
  }, a.prototype.update = function(type) {
    var editor = this;
    if (this._updateTimer += type, this._updateTimer > this.updateTime) {
      if (this._array.length > 0) {
        if (this._sortDirty) {
          this._array.sort(vc);
          this._sortDirty = false;
        }
        var index = 0;
        this._array.forEach(function(e) {
          if (function(o, time) {
            if (o.timer -= time, o.timer < 0) {
              return o.mat.dispose(), true;
            }
            return false;
          }(e, editor._updateTimer)) {
            index++;
          }
        });
        this._array.length -= index;
      }
      this._updateTimer = 0;
    }
  }, a.prototype.clear = function() {
    this._array.forEach(function(o) {
      return o.mat.dispose();
    });
    this._array.length = 0;
  }, a;
}();
function vc(_pointM, _pointB) {
  return _pointB.timer - _pointM.timer;
}
var yc = ["middleGlow", "innerGlow"];
function bc(args, name) {
  if (!args) {
    return null;
  }
  var data = args[name];
  return data ? "[object Object]" === toString.call(data) ? data.skip ? "skip" : void 0 !== data.value ? data.value : 1 : data : null;
}
var _c = function() {
  function i(a) {
    r(this, i);
    this._renderer = a.rendererManager._mainRenderer;
    this._effectRefCounts = {};
  }
  return i.prototype.setEffect = function(type, i) {
    var miniDiagrams = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
    var isMiniDiagrams = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    if (type.technique || (type.technique = {}), type.technique[i]) {
      var text = bc(type.technique, i);
      var cachedBrackets = "skip" != text && 0 != text;
      var s = !isMiniDiagrams && 0 != miniDiagrams;
      if (cachedBrackets !== s) {
        this._updatEffectRefCounts(i, s ? 1 : -1);
      } else {
        if (!(isMiniDiagrams || miniDiagrams == text)) {
          this._renderer.dirty(i);
        }
      }
    } else {
      if (!(isMiniDiagrams || 0 == miniDiagrams)) {
        this._updatEffectRefCounts(i, 1);
      }
    }
    type.technique[i] = {
      value : miniDiagrams,
      skip : isMiniDiagrams
    };
  }, i.prototype.removeEffect = function(data, i) {
    var value = bc(data.technique, i);
    if (value) {
      if ("skip" != value && 0 != value) {
        this._updatEffectRefCounts(i, -1);
      }
      delete data.technique[i];
    }
  }, i.prototype.clearAllEffects = function(data) {
    if (data.technique) {
      var i;
      for (i in data.technique) {
        this.removeEffect(data, i);
      }
    }
  }, i.prototype.synEffect = function(that) {
    if (that.technique) {
      var i;
      for (i in that.technique) {
        if (yc.indexOf(i) > -1) {
          var el = bc(that.technique, i);
          if ("skip" != el && 0 != el) {
            this._updatEffectRefCounts(i, 1);
          }
        }
      }
    }
  }, i.prototype._updatEffectRefCounts = function(id, offset) {
    if (void 0 === this._effectRefCounts[id]) {
      this._effectRefCounts[id] = 0;
    }
    var newParent = this._effectRefCounts[id];
    this._effectRefCounts[id] = Math.max(this._effectRefCounts[id] + offset, 0);
    var renderer = this._renderer;
    if (0 == newParent && offset > 0) {
      if (renderer.enable) {
        renderer.enable(id);
      }
    } else {
      if (newParent > 0 && 0 == this._effectRefCounts[id] && renderer.disable) {
        renderer.disable(id);
      }
    }
    if (renderer.dirty) {
      renderer.dirty(id);
    }
  }, n(i, [{
    key : "effectRefCounts",
    get : function() {
      return this._effectRefCounts;
    }
  }]), i;
}();
xc = function(e) {
  function d(row) {
    r(this, d);
    var container = s(this, e.call(this, row));
    return container._solidColor = null, container._skipApplyTheme = true, container;
  }
  return o(d, e), d.prototype._setAlwaysOnTop = function(value) {
    var unconditional = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    if (this._alwaysOnTop != value || unconditional) {
      var sprite = this.obj._sprite;
      if (sprite) {
        this._alwaysOnTop = value;
        if (value) {
          this._cloneAndModifyMaterial(function(canCreateDiscussions, customMaterial, i) {
            var material = customMaterial;
            Utils.backupValue(material, "depthTest");
            Utils.backupValue(material, "depthWrite");
            material.depthTest = false;
            material.depthWrite = false;
          });
          this._traverse(function(a) {
            a.renderOrder += THING.BaseStyle.cRenderOrderValueMask;
          });
        } else {
          this._traverse(function(a) {
            a.renderOrder -= THING.BaseStyle.cRenderOrderValueMask;
          });
          if (this.isNeedRevertMaterials()) {
            this.revertMaterial();
          } else {
            this._cloneAndModifyMaterial(function(canCreateDiscussions, rawtype, i) {
              var r = rawtype;
              Utils.revertValue(r, "depthTest");
              Utils.revertValue(r, "depthWrite");
            });
          }
        }
      }
    }
  }, d.prototype.setUVAnimation = function(p1__3354_SHARP_) {
    var sprite = this.obj._sprite;
    if (sprite) {
      if (p1__3354_SHARP_) {
        var material = sprite.material;
        if (p1__3354_SHARP_.uvDiscard) {
          material.defines = material.defines || {};
          material.defines.USE_UV_DISCARD = "";
        } else {
          if (material.defines) {
            delete material.defines.USE_UV_DISCARD;
          }
        }
        material.needsUpdate = true;
      }
      e.prototype.setUVAnimation.call(this, p1__3354_SHARP_);
    }
  }, d.prototype.setSolidColor = function(value) {
    if (this._solidColor != value) {
      this._solidColor = Utils.parseColor(value);
      ["#ifdef GL_ES\n", "precision highp float;\n", "#endif\n", "", "varying vec4 worldId;", "", "void main() {", "  gl_FragColor = " + this._solidColor.getHex() + ";", "}"].join("\n");
    }
  }, d.prototype.setOpacity = function(value) {
    var i = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    var parent = this.obj.element;
    if (parent) {
      parent.style.opacity = value;
    } else {
      e.prototype.setOpacity.call(this, value, i);
    }
  }, n(d, [{
    key : "solidColor",
    set : function(num) {
      return this.setSolidColor(num);
    },
    get : function() {
      return this._solidColor ? this._solidColor.toHexString() : null;
    }
  }, {
    key : "line",
    get : function() {
      return this.obj._line;
    }
  }, {
    key : "lineColor",
    set : function(v) {
      if (this.line) {
        this.line.style.lineColor = v;
      }
    }
  }, {
    key : "lineOpacity",
    set : function(num) {
      if (this.line) {
        this.line.style.lineOpacity = num;
      }
    }
  }, {
    key : "lineDashSize",
    set : function(num) {
      if (this.line) {
        this.line.style.lineDashSize = num;
      }
    }
  }, {
    key : "lineGapSize",
    set : function(num) {
      if (this.line) {
        this.line.style.lineGapSize = num;
      }
    }
  }, {
    key : "lineWidth",
    set : function(v) {
      if (this.line) {
        this.line.style.lineWidth = v;
      }
    }
  }]), d;
}(Pl);
Ec = function(callback) {
  function d(row) {
    r(this, d);
    var container = s(this, callback.call(this, row));
    return container._lineOpacity = 1, container._lineColor = Utils.parseColor("#00BFFF"), container._regionOpacity = .5, container._regionColor = Utils.parseColor("#708090"), container;
  }
  return o(d, callback), d.prototype.isNeedCloneMaterials = function() {
    return !!callback.prototype.isNeedCloneMaterials.call(this) || (1 != this._lineOpacity || (!this._lineColor.equals(Utils.parseColor("#00BFFF")) || (.5 != this._regionOpacity || !this._regionColor.equals(Utils.parseColor("#708090")))));
  }, n(d, [{
    key : "lineOpacity",
    set : function(v) {
      if (Utils.isNumber(v)) {
        var parent = this.obj._lineMesh;
        if (parent) {
          this._lineOpacity = v;
          parent.material.opacity = v;
        }
      }
    },
    get : function() {
      return this._lineOpacity;
    }
  }, {
    key : "lineColor",
    set : function(value) {
      var newVal = Utils.parseColor(value);
      if (newVal) {
        var n = this.obj._lineMesh;
        if (n) {
          this._lineColor = newVal;
          n.material.color = newVal;
        }
      }
    },
    get : function() {
      return this._lineColor.toHexString();
    }
  }, {
    key : "regionColor",
    set : function(value) {
      var newVal = Utils.parseColor(value);
      if (newVal) {
        var n = this.obj._areaMesh;
        if (n) {
          this._regionColor = newVal;
          n.material.color = newVal;
        }
      }
    },
    get : function() {
      return this._regionColor.toHexString();
    }
  }, {
    key : "regionOpacity",
    set : function(num) {
      if (Utils.isNumber(num)) {
        var parent = this.obj._areaMesh;
        if (parent) {
          this._regionOpacity = num;
          parent.material.opacity = num;
        }
      }
    },
    get : function() {
      return this._regionOpacity;
    }
  }]), d;
}(Pl);
wc = function(e) {
  function d(row) {
    return r(this, d), s(this, e.call(this, row));
  }
  return o(d, e), d.prototype.setEffect = function(target) {
    target = target || {};
    var options = this.obj;
    options._scale = target.scale || options._scale;
    options._color = target.color || options._color;
    options._flowDirection.x = target.flowXDirection || options._flowDirection.x;
    options._flowDirection.y = target.flowYDirection || options._flowDirection.y;
    var u = options.water.material.uniforms;
    u.color.value.set(options._color);
    u.config.value.w = options._scale;
    u.flowDirection.value.x = options._flowDirection.x;
    u.flowDirection.value.y = options._flowDirection.y;
  }, n(d, [{
    key : "waterColor",
    set : function(v) {
      this.setEffect({
        color : v
      });
    },
    get : function() {
      return this.obj._color;
    }
  }, {
    key : "waterScale",
    set : function(v) {
      this.setEffect({
        scale : v
      });
    },
    get : function() {
      return this.obj._scale;
    }
  }, {
    key : "flowXDirection",
    set : function(num) {
      this.setEffect({
        flowXDirection : num
      });
    },
    get : function() {
      return this.obj._flowDirection.x;
    }
  }, {
    key : "flowYDirection",
    set : function(num) {
      this.setEffect({
        flowYDirection : num
      });
    },
    get : function() {
      return this.obj._flowDirection.y;
    }
  }]), d;
}(Pl);
Tc = function(t) {
  function e(row) {
    return r(this, e), s(this, t.call(this, row));
  }
  return o(e, t), n(e, [{
    key : "image",
    set : function(data) {
      var request = this;
      if (this._image = data, data) {
        if (data.isTexture) {
          this._image = data.name;
          if (data.image) {
            data.needsUpdate = true;
          }
          this.obj.synPathTexture(data, false);
        } else {
          this._image = Utils.isString(data) ? this.obj.app.confirmURL(data) : data;
          var classes = this.obj.app.resourceManager.loadTexture(this._image, function(texture) {
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.anisotropy = 16;
            if (request.obj) {
              request.obj.app.needUpdate = true;
            }
          });
          this.obj.synPathTexture(classes, false);
        }
      }
    },
    get : function() {
      return this._image;
    }
  }, {
    key : "lineMaterial",
    get : function() {
      var material = this.obj.pathLine.material;
      return material.dashSize || material.gapSize ? this.dashLineMaterial : this.basicLineMaterial;
    }
  }, {
    key : "basicLineMaterial",
    get : function() {
      var options = this.obj.pathLine.material;
      if (options.isLineBasicMaterial) {
        return options;
      }
      var selectedMaterial = new THREE.LineBasicMaterial({
        color : options.color,
        opacity : options.opacity,
        linewidth : options.lineWidth,
        transparent : options.transparent
      });
      return this.obj.pathLine.material = selectedMaterial, selectedMaterial;
    }
  }, {
    key : "dashLineMaterial",
    get : function() {
      var options = this.obj.pathLine.material;
      if (options.isLineDashedMaterial) {
        return options;
      }
      var selectedMaterial = new THREE.LineDashedMaterial({
        color : options.color,
        opacity : options.opacity,
        linewidth : options.lineWidth,
        transparent : options.transparent
      });
      return this.obj.pathLine.material = selectedMaterial, selectedMaterial;
    }
  }, {
    key : "lineColor",
    set : function(value) {
      this.lineMaterial.color = Utils.parseColor(value);
    },
    get : function() {
      return this.lineMaterial.color.toHexString();
    }
  }, {
    key : "lineOpacity",
    set : function(num) {
      this.lineMaterial.opacity = num;
    },
    get : function() {
      return this.lineMaterial.opacity;
    }
  }, {
    key : "lineDashSize",
    set : function(num) {
      this.lineMaterial.dashSize = num;
    },
    get : function() {
      return this.lineMaterial.dashSize;
    }
  }, {
    key : "lineGapSize",
    set : function(num) {
      this.lineMaterial.gapSize = num;
    },
    get : function() {
      return this.lineMaterial.gapSize;
    }
  }, {
    key : "lineWidth",
    set : function(v) {
      this.lineMaterial.lineWidth = v;
    },
    get : function() {
      return this.lineMaterial.lineWidth;
    }
  }]), e;
}(Pl);
function Mc(instance, value, position) {
  var edge_coords = [];
  value.forEach(function(fx) {
    var value = .09;
    if ("top" == position) {
      value = value + instance.getRoomHeight();
    }
    edge_coords.push([fx[0], fx[1] + value, fx[2]]);
  });
  var obj = instance.app.create({
    name : instance.name + "_border_" + position,
    type : "RouteLine",
    image : instance.app.confirmURL("image/light3.jpg"),
    parent : instance,
    arrowFlag : false,
    close : true,
    side : "right",
    points : edge_coords,
    width : 2
  });
  return obj.cornerRadius = 0, obj.scrollSpeed = 10, obj.imageRepeat = [1 / 40, 1], obj.pickable = false, obj.style.skipOutline = true, obj.scrollUV = true, obj.node.traverse(function(object) {
    if (object.isMesh) {
      object.userData.skipOutline = true;
      object.material.transparent = true;
      object.material.blending = THREE.AdditiveBlending;
    }
  }), obj;
}
var Cc = function(e) {
  function d(row) {
    r(this, d);
    var container = s(this, e.call(this, row));
    return container._volumeNode = null, container._volumeColor = null, container._volumeImage = null, container._volumeCanvas = null, container._borderLine = false, container._borderLineTop = null, container._borderLineBottom = null, container;
  }
  return o(d, e), d.prototype._synVolumeNode = function() {
    if (!(this._volumeColor || this._volumeImage || this._volumeCanvas)) {
      this.obj.app.resourceManager.remove(this._volumeNode);
      this._volumeNode = null;
    }
    this.obj._synTextRegion();
  }, d.prototype._createVolumeNode = function() {
    if (!this._volumeNode) {
      var e = this.obj.getFloorMesh();
      if (!e) {
        return null;
      }
      if (this._volumeNode = e.clone(), !this._volumeNode) {
        return null;
      }
      if (this._volumeNode.geometry = this._volumeNode.geometry.clone(), this._volumeNode.material = e.material.clone(), !this._volumeNode.material) {
        return null;
      }
      var material = this._volumeNode.material;
      material.map = null;
      material.transparent = true;
      material.opacity = .5;
      this._volumeNode.geometry.genFaceVertexUVs();
      e.parent.add(this._volumeNode);
      var oldpos = e.position;
      this._volumeNode.position.setY(oldpos.y + this.obj.getRoomHeight() + .05);
    }
    return this._volumeNode;
  }, n(d, [{
    key : "volumeColor",
    set : function(value) {
      this._volumeColor = Utils.parseColor(value);
      var dragknifeGrp = this._createVolumeNode();
      if (dragknifeGrp) {
        if (value) {
          dragknifeGrp.material.color = Utils.parseColor(value);
        } else {
          dragknifeGrp.material.color.set(1, 1, 1);
        }
      }
      this._synVolumeNode();
    },
    get : function() {
      return null == this._volumeColor ? null : this._volumeColor.toHexString();
    }
  }, {
    key : "volumeOpacity",
    set : function(num) {
      var plate = this._createVolumeNode();
      if (plate) {
        plate.material.opacity = num;
      }
    },
    get : function() {
      return null == this._volumeNode ? null : this._volumeNode.material.opacity;
    }
  }, {
    key : "volumeImage",
    set : function(v) {
      this._volumeImage = v;
      this._volumeCanvas = null;
      var self = this._createVolumeNode();
      if (self) {
        if (v) {
          var value = this.obj.app.confirmURL(v);
          v = this.obj.app.resourceManager.loadTexture(value);
        }
        self.material.map = v;
        self.material.needsUpdate = true;
      }
      this._synVolumeNode();
    },
    get : function() {
      return this._volumeImage;
    }
  }, {
    key : "volumeCanvas",
    set : function(value) {
      this._volumeCanvas = value;
      this._volumeImage = null;
      var self = this._createVolumeNode();
      if (self) {
        if (value) {
          (value = new THREE.Texture(value)).needsUpdate = true;
        }
        self.material.map = value;
        self.material.needsUpdate = true;
      }
      this._synVolumeNode();
    },
    get : function() {
      return this._volumeCanvas;
    }
  }, {
    key : "volumeHeight",
    set : function(num) {
      if (this._volumeNode) {
        this._volumeNode.position.y = num;
      }
    },
    get : function() {
      return this._volumeNode ? this._volumeNode.position.y : 0;
    }
  }, {
    key : "borderLine",
    set : function(num) {
      if (num != this._borderLine) {
        if (num) {
          var elem = this.obj;
          var p = elem.points;
          this._borderLineTop = Mc(elem, p, "top");
          this._borderLineBottom = Mc(elem, p, "bottom");
          this._borderLine = true;
        } else {
          this._borderLineTop.destroy();
          this._borderLineBottom.destroy();
          this._borderLineTop = null;
          this._borderLineBottom = null;
          this._borderLine = false;
        }
      }
    },
    get : function() {
      return this._borderLine;
    }
  }]), d;
}(Pl);
Sc = function(t) {
  function e(row) {
    r(this, e);
    var container = s(this, t.call(this, row));
    return container._lineColor = new THREE.Color(1, 1, 1), container;
  }
  return o(e, t), n(e, [{
    key : "lineColor",
    set : function(value) {
      this.obj._lineMesh.material.color = Utils.parseColor(value);
    },
    get : function() {
      return this._lineColor.toHexString();
    }
  }]), e;
}(Pl);
jc = function(callback) {
  function e(row) {
    return r(this, e), s(this, callback.call(this, row));
  }
  return o(e, callback), e.prototype.setRenderOrder = function(order) {
    this._renderOrder = order;
    this.obj.children.forEach(function(year_selector_service) {
      year_selector_service.style.setRenderOrder(order);
    });
  }, e.prototype.setWireframe = function(is_wireframe) {
    var artistTrack = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    this._wireframe = is_wireframe;
    this.obj.children.forEach(function(that) {
      that.style.setWireframe(is_wireframe, artistTrack);
    });
  }, e.prototype.setOpacity = function(value) {
    var opacity = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    this._opacity = value;
    this.obj.children.forEach(function(layer) {
      layer.style.setOpacity(value, opacity);
    });
  }, e.prototype.setColor = function(color) {
    var value = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    this._color = Utils.parseColor(color);
    this.obj.children.forEach(function(b) {
      b.style.setColor(color, value);
    });
  }, e.prototype.setOutlineColor = function(value, fireUpdatedEvent) {
    this._outlineColor = Utils.parseColor(value);
    this.obj.children.forEach(function(year_selector_service) {
      year_selector_service.style.setOutlineColor(value, fireUpdatedEvent);
    });
  }, e.prototype.setDefaultOutlineColor = function(value) {
    this._defaultOutlineColor = Utils.parseColor(value);
    this.obj.children.forEach(function(year_selector_service) {
      year_selector_service.style.setDefaultOutlineColor(value);
    });
  }, e.prototype.setSkipBoundingBox = function(value) {
    this.obj.children.forEach(function(year_selector_service) {
      year_selector_service.style.setSkipBoundingBox(value);
    });
  }, e.prototype.setSkipOutline = function(e) {
    this.obj.children.forEach(function(year_selector_service) {
      year_selector_service.style.setSkipOutline(e);
    });
  }, e.prototype.setGlow = function(e) {
    this._glow = e;
    this.obj.children.forEach(function(year_selector_service) {
      year_selector_service.style.setGlow(e);
    });
  }, e.prototype.setInnerGlow = function(e) {
    this._innerGlow = e;
    this.obj.children.forEach(function(year_selector_service) {
      year_selector_service.style.setInnerGlow(e);
    });
  }, e.prototype.setVertexNormalHelper = function(value) {
    this._vertexNormalNode = {
      visible : value
    };
    this.obj.children.forEach(function(year_selector_service) {
      year_selector_service.style.setVertexNormalHelper(value);
    });
  }, e.prototype.setAxisHelper = function(value) {
    this._axisNode = {
      visible : value
    };
    this.obj.children.forEach(function(year_selector_service) {
      year_selector_service.style.setAxisHelper(value);
    });
  }, e.prototype.setEdgeColor = function(value) {
    this._edgeColor = Utils.parseColor(value);
    this.obj.children.forEach(function(year_selector_service) {
      year_selector_service.style.setEdgeColor(value);
    });
  }, e.prototype.setBoundingBox = function(visible, value) {
    this._boundingBoxNode = {
      visible : visible,
      material : {
        color : Utils.parseColor(value)
      }
    };
    this.obj.children.forEach(function(renderer) {
      renderer.style.setBoundingBox(visible, value);
    });
  }, e.prototype.setOrientedBoundingBox = function(value) {
    this._orientedBoundingBoxNode = {
      visible : value,
      material : {
        color : Utils.parseColor(color)
      }
    };
    this.obj.children.forEach(function(year_selector_service) {
      year_selector_service.style.setOrientedBoundingBox(value, color);
    });
  }, e.prototype.setAlwaysOnTop = function(value) {
    this._alwaysOnTop = value;
    this.obj.children.forEach(function(player) {
      player.style.setAlwaysOnTop(value);
    });
  }, e.prototype.setImage = function(value) {
    this._image = value;
    this.obj.children.forEach(function(object) {
      object.style.setImage(value);
    });
  }, e;
}(Pl);
Pc = new Map, Rc = function() {
  function init(toggle_callback) {
    r(this, init);
    init.register("Default", {
      "*" : {
        classType : Pl
      },
      Marker : {
        classType : xc,
        checkType : "isMarker"
      },
      PolygonRegion : {
        classType : Ec,
        checkType : "isPolygonRegion"
      },
      TextRegion : {
        classType : Rl,
        checkType : "isTextRegion"
      },
      _UbuilderRichTextRegion : {
        classType : Rl,
        checkType : "is_UbuilderRichTextRegion"
      },
      Water : {
        classType : wc,
        checkType : "isWater"
      },
      Line : {
        classType : Tc,
        checkType : "isLine"
      },
      RouteLine : {
        classType : Tc,
        checkType : "isRouteLine"
      },
      PolygonLine : {
        classType : Tc,
        checkType : "isPolygonLine"
      },
      Room : {
        classType : Cc,
        checkType : "isRoom"
      },
      Frustum : {
        classType : Sc,
        checkType : "isFrustum"
      },
      Group : {
        classType : jc,
        checkType : "isGroup"
      },
      BatchSubObject : {
        classType : mr,
        checkType : "isBatchSubObject"
      }
    });
  }
  return init.register = function(name, proto) {
    Pc.set(name, proto);
  }, init.getStrategyMap = function(e) {
    return Pc.get(e).classType;
  }, init.prototype.createStyle = function(text, self) {
    var _MockContext;
    var section = Pc.get(text);
    if (!section) {
      return null;
    }
    var name;
    for (name in section) {
      var options = section[name];
      if ("*" != name) {
        var bindings = self[options.checkType];
        if (self.type == name || !Utils.isFunction(bindings) && bindings) {
          return new options.classType(self);
        }
      } else {
        _MockContext = options.classType;
      }
    }
    return _MockContext ? new _MockContext(self) : null;
  }, init.prototype.hasStyleStrategy = function(e) {
    return Pc.has(e);
  }, init;
}();
Dc = new THREE.Vector2, Ac = function() {
  function Game(options) {
    r(this, Game);
    this.app = options;
    this.scene = this.app.scene;
    this.renderer = this.app.renderer;
    this.camera = this.app.renderCamera;
    this.init();
  }
  return Game.prototype.init = function() {
    var grid = new THREEx.HtmlMixer.Context(this.renderer, this.scene, this.camera);
    this.mixerContext = grid;
    var renderer = grid.rendererCss;
    var canvasOriginalSize = this.renderer.getSize(Dc);
    renderer.setSize(canvasOriginalSize.width, canvasOriginalSize.height);
    var canvas = renderer.domElement;
    canvas.style.userSelect = "none";
    this.app.domElement.appendChild(canvas);
    var options = grid.rendererWebgl;
    var container = options.domElement;
    if (!options.domElement._static) {
      container.style.position = "absolute";
      container.style.top = "0px";
      container.style.pointerEvents = "none";
      canvas.appendChild(container);
    }
  }, Game.prototype.resize = function(h, w) {
    this.mixerContext.rendererCss.setSize(h, w);
  }, Game.prototype.update = function() {
    this.mixerContext.update();
  }, Game.prototype.onUpdate = function(e) {
    this.update(e);
  }, Game;
}();
kc = function() {
  function a(results) {
    r(this, a);
    this.eventTriggerManager = results;
    this.app = this.eventTriggerManager.app;
    this.domElement = this.app.mainDomElement;
    this.singleClickTimer = null;
    this.clickCountForSingleClick = 0;
    this.dragStartFlag = false;
    this.draggingFlag = false;
    this._dragPrevPosition = null;
    this._draggingObject = null;
    this.mouseMoveEvents = [];
    this.mouseMoveObject = null;
    this.mouseDownPos = {};
    this.mouseMovePos = [];
    this.mouseMoveDelta = null;
    this.keysPressed = {};
    this.keyCodesPressed = {};
    this.skipFrameCount = 0;
    this.isSupportTouchEvent = Utils.system.isSupportTouchEvent();
    this.init();
  }
  return a.prototype.dispatchEvent = function(type) {
    return this.eventTriggerManager.dispatchEvent(type);
  }, a.prototype.getEventPosition = function(event, obj) {
    var x;
    var y;
    var element = this.domElement;
    if (element) {
      var computedStyle = element.currentStyle || window.getComputedStyle(element, null);
      var borderLeftWidth = obj ? obj[0] : parseInt(computedStyle.borderLeftWidth, 10);
      var borderTopWidth = obj ? obj[1] : parseInt(computedStyle.borderTopWidth, 10);
      var rect = element.getBoundingClientRect();
      x = event.clientX - borderLeftWidth - rect.left;
      y = event.clientY - borderTopWidth - rect.top;
    } else {
      if (event.layerX || 0 == event.layerX) {
        x = event.layerX;
        y = event.layerY;
      } else {
        if (event.offsetX || 0 == event.offsetX) {
          x = event.offsetX;
          y = event.offsetY;
        } else {
          if (event.clientX || 0 == event.clientX) {
            x = event.clientX;
            y = event.clientY;
          }
        }
      }
    }
    return {
      x : Math.round(x),
      y : Math.round(y)
    };
  }, a.prototype.registerEventFunctions = function(event) {
    if (Utils.isNull(event.stopPropagation)) {
      event.stopPropagation = function() {
        this._stopPropagation = true;
      };
    }
  }, a.prototype.createKeyboardEvent = function(e) {
    var previewKey;
    previewKey = e.key >= "a" && e.key <= "z" ? Utils.atoi(e.key) : e.keyCode || e.which || e.charCode;
    var result = {
      type : e.type,
      key : previewKey,
      code : e.code,
      location : e.location,
      altKey : e.altKey,
      ctrlKey : e.ctrlKey,
      shiftKey : e.shiftKey
    };
    return this.registerEventFunctions(result), result;
  }, a.prototype.createMouseEvent = function(type, event, target) {
    var xy = Utils.parseVector2(target) || this.getEventPosition(event);
    var options = {
      type : type,
      clientX : xy.x,
      clientY : xy.y,
      x : xy.x,
      y : xy.y,
      button : event.button || 0,
      buttons : event.buttons || 0,
      altKey : event.altKey,
      ctrlKey : event.ctrlKey,
      shiftKey : event.shiftKey,
      pickedPosition : null
    };
    return this.registerEventFunctions(options), options.getPickedPos = function() {
      return THING.Utils.warn("Please use .getPickedPosition() to replace .getPickedPos()"), options.pickedPosition;
    }, options.getPickedPosition = function() {
      return THING.Utils.warn("Please use .pickedPosition to replace .getPickedPosition()"), options.pickedPosition;
    }, options;
  }, a.prototype.createDragEvent = function(eventType, e, r, n) {
    var center = [void 0 !== e.x ? e.x : e.clientX, void 0 !== e.y ? e.y : e.clientY];
    var event = {
      type : eventType,
      x : center[0],
      y : center[1],
      clientX : center[0],
      clientY : center[1],
      altKey : e.altKey,
      ctrlKey : e.ctrlKey,
      shiftKey : e.shiftKey
    };
    return r && (event.offsetX = r), n && (event.offsetY = n), event.pickedPosition = null, this.registerEventFunctions(event), event.getPickedPos = function() {
      return THING.Utils.warn("Please use .getPickedPosition() to replace .getPickedPos()"), event.pickedPosition;
    }, event.getPickedPosition = function() {
      return THING.Utils.warn("Please use .pickedPosition to replace .getPickedPosition()"), event.pickedPosition;
    }, event;
  }, a.prototype.clearSingleClickTimer = function() {
    if (null != this.singleClickTimer) {
      Utils.timer.clearTimeout(this.singleClickTimer);
      this.clickCountForSingleClick = 0;
    }
  }, a.prototype.findMouseEventObject = function(value, result) {
    for (; value;) {
      var i = 0;
      for (; i < result.length; i++) {
        if (value.hasEvent(result[i])) {
          return value;
        }
      }
      value = value.parent;
    }
    return null;
  }, a.prototype.processMouseOffEvent = function(b) {
    var value = this.mouseMoveObject;
    if (value) {
      var c = b.object;
      if (c) {
        if (c.isBlockMouseOffEvent(value)) {
          return;
        }
        var item = this.findMouseEventObject(value, ["mouseleave", "mouseoff"]);
        if (!item || c.isBlockMouseOffEvent(item)) {
          return;
        }
        if (!item.visible) {
          return;
        }
        if (this.findMouseEventObject(c, ["mouseleave", "mouseoff"]) == value) {
          return;
        }
        if (value == item) {
          var n = this.mouseMoveLastPickedObject || b.object;
          this.dispatchEvent({
            type : EventType.MouseLeave,
            object : item,
            mouseOffObject : n,
            x : b.clientX,
            y : b.clientY
          });
          this.dispatchEvent({
            type : "mouseoff",
            object : item,
            mouseOffObject : n,
            x : b.clientX,
            y : b.clientY
          });
        }
      } else {
        var t = value;
        for (; t; t = t.parent) {
          t.trigger(EventType.MouseLeave, {
            object : t,
            mouseOffObject : this.mouseMoveObject,
            x : b.clientX,
            y : b.clientY
          });
          t.trigger("mouseoff", {
            object : t,
            mouseOffObject : this.mouseMoveObject,
            x : b.clientX,
            y : b.clientY
          });
        }
      }
      this.mouseMoveObject = null;
    }
  }, a.prototype.processMouseOnEvent = function(b) {
    var bar = b.object;
    var c = this.findMouseEventObject(bar, ["mouseenter", "mouseon"]);
    if (c && c.visible && this.mouseMoveObject != c) {
      this.mouseMoveLastPickedObject = b.pickedObj;
      var rv = this.dispatchEvent({
        type : EventType.MouseEnter,
        object : c,
        mouseOnObject : b.pickedObj,
        x : b.clientX,
        y : b.clientY
      });
      this.dispatchEvent({
        type : "mouseon",
        object : c,
        mouseOnObject : b.pickedObj,
        x : b.clientX,
        y : b.clientY
      });
      if (rv && rv.isBaseObject) {
        this.mouseMoveObject = rv;
      } else {
        this.mouseMoveObject = c;
      }
    }
  }, a.prototype.processMouseOverEvent = function(e) {
    var left = e.object;
    var icon = this.findMouseEventObject(left, ["mouseover"]);
    if (icon) {
      this.dispatchEvent({
        type : "mouseover",
        object : icon,
        x : e.clientX,
        y : e.clientY
      });
    }
  }, a.prototype.processHoverEvent = function(tap) {
    this.mouseMoveEvents.push(tap);
  }, a.prototype.createEvent = function(value, type) {
    var _event;
    return type = type || value.type, (_event = D[type] ? this.createMouseEvent(type, value) : A[type] ? this.createKeyboardEvent(value) : value).preventDefault = function() {
      value.preventDefault();
    }, _event;
  }, a.prototype.checkEvent = function() {
    return !(this.app.currentFrameCount <= this.skipFrameCount) && !this.app.getCurrentHTMLMarker();
  }, a.prototype.initDoubleRightClickEvent = function() {
    var init;
    var _takingTooLongTimeout;
    var i;
    var node;
    var me = this;
    window.oncontextmenu = (init = function(name) {
      me.clearSingleClickTimer();
      var event = me.createEvent(name, "dblclick");
      event.button = 2;
      var lightbox = THING.App.current;
      if (lightbox) {
        lightbox.events.eventTriggerManager.dispatchEvent(event);
      } else {
        me.dispatchEvent(event);
      }
    }, _takingTooLongTimeout = 0, i = false, node = null, function(candidate) {
      if (candidate.preventDefault(), i) {
        clearTimeout(_takingTooLongTimeout);
        i = false;
        var _gNode = THING.Math.getDistance(node, [candidate.x, candidate.y]);
        if (_gNode > 1) {
          return;
        }
        return init.apply(this, arguments);
      }
      node = [candidate.x, candidate.y];
      i = true;
      _takingTooLongTimeout = setTimeout(function() {
        i = false;
      }, 300);
    });
  }, a.prototype.initMouseEvent = function(repeat) {
    var that = this;
    var i = true;
    var r = true;
    var type;
    for (type in this.initDoubleRightClickEvent(), D) {
      this.domElement.addEventListener(type, function(e) {
        if (that.checkEvent()) {
          if ("mousedown" == (e = that.createEvent(e)).type) {
            that.mouseDownPos[e.button] = [e.x, e.y];
          } else {
            if ("mouseup" == e.type) {
              if (0 == e.button) {
                i = !(that.getDistanceOfLastMouseDown(e) > that.app.clickDistance);
              } else {
                if (2 == e.button) {
                  var win = that.mouseDownPos[e.button];
                  if (!that.isSupportTouchEvent && that.getDistanceOfLastMouseDown(e) <= that.app.clickDistance) {
                    that.dispatchEvent(that.createMouseEvent("click", e, win));
                    that.clearSingleClickTimer();
                    that.singleClickTimer = Utils.timer.setTimeout(function() {
                      that.dispatchEvent(that.createMouseEvent("singleclick", e, win));
                    }, repeat);
                  }
                }
              }
            }
          }
          if (!that.isSupportTouchEvent || "click" !== e.type && "dblclick" !== e.type && "singleclick" !== e.type) {
            if ("click" == e.type) {
              if (that.getDistanceOfLastMouseDown(e) > 1) {
                return;
              }
              if (r = true, that.clickCountForSingleClick++, 1 === that.clickCountForSingleClick) {
                win = that.mouseDownPos[e.button];
                that.singleClickTimer = Utils.timer.setTimeout(function() {
                  if (i && !that.draggingFlag) {
                    r = false;
                    that.dispatchEvent(that.createMouseEvent("singleclick", e, win));
                  } else {
                    r = true;
                  }
                  i = true;
                  that.clickCountForSingleClick = 0;
                }, repeat);
              } else {
                that.clearSingleClickTimer();
              }
            } else {
              if ("dblclick" == e.type && (that.clearSingleClickTimer(), !r)) {
                return void(r = true);
              }
            }
            that.dispatchEvent(e);
            if ("mousemove" == e.type) {
              if (that.mouseMoveDelta) {
                that.mouseMoveDelta = [that.mouseMovePos[0] - e.x, that.mouseMovePos[1] - e.y];
              } else {
                that.mouseMoveDelta = [e.x, e.y];
              }
              that.mouseMovePos = [e.x, e.y];
              if (0 == e.buttons) {
                that.processHoverEvent(e);
              }
            }
          }
        }
      }, {
        passive : false
      });
    }
    this.domElement.addEventListener("mouseout", function(e) {
      if (that.checkEvent() && 0 == e.buttons) {
        that.processMouseOffEvent(e);
      }
    });
    this.domElement.addEventListener("wheel", function(e) {
      if (that.checkEvent()) {
        var xy = that.getEventPosition(e);
        var el = {
          type : EventType.MouseWheel,
          delta : e.deltaY,
          clientX : xy.x,
          clientY : xy.y,
          x : xy.x,
          y : xy.y
        };
        that.dispatchEvent(el);
      }
    }, {
      passive : false
    });
  }, a.prototype.initKeyboardEvent = function() {
    var that = this;
    var key;
    for (key in A) {
      window.addEventListener(key, function(e) {
        if (that.checkEvent()) {
          var note_counter = (e = that.createEvent(e)).code || e.key;
          if ("keydown" == e.type) {
            if (that.keysPressed[note_counter]) {
              return;
            }
            that.keysPressed[note_counter] = true;
            that.keyCodesPressed[e.key] = true;
          } else {
            if ("keyup" == e.type) {
              that.keysPressed[note_counter] = false;
              that.keyCodesPressed[e.key] = false;
            }
          }
          that.dispatchEvent(e);
        }
      });
    }
  }, a.prototype.initDragEvent = function() {
    var _this = this;
    this.domElement.addEventListener("mouseup", function(event) {
      if (_this.checkEvent() && 0 == event.button && _this.dragStartFlag) {
        _this.dragStartFlag = false;
        _this.draggingFlag = false;
        _this._dragPrevPosition = null;
        _this._draggingObject = null;
        event = _this.createEvent(event);
        _this.dispatchEvent(_this.createDragEvent("dragend", event));
      }
    });
    this.domElement.addEventListener("mousemove", function(data) {
      if (_this.checkEvent()) {
        if (data = _this.createEvent(data), _this.dragStartFlag) {
          _this.draggingFlag = true;
          var event = _this.createDragEvent("drag", data);
          _this.dispatchEvent(event);
          var d = event.pickedPosition;
          if (!(d && !d.isFailed)) {
            event.picked = false;
          }
          _this._dragPrevPosition = _this._dragPrevPosition || d;
          if (_this._dragPrevPosition && d) {
            event.offsetPosition = THING.Math.subVector(d, _this._dragPrevPosition);
          } else {
            event.offsetPosition = [0, 0, 0];
          }
          var $element = _this._draggingObject;
          if ($element) {
            $element.trigger("dragging", event);
          }
          if (event.picked && d) {
            _this._dragPrevPosition = d.concat();
          }
        } else {
          if (1 == data.buttons) {
            if (_this.getDistanceOfLastMouseDown(data) > 1) {
              event = _this.createDragEvent("dragstart", data);
              _this.dispatchEvent(event);
              var target = event.dragObject;
              if (target && target.draggable) {
                _this.dragStartFlag = true;
                _this._draggingObject = target;
              }
            }
          }
        }
      }
    });
  }, a.prototype.initTouchEvent = function(e) {
    var self = this;
    var i = 0;
    var r = false;
    this.domElement.addEventListener("touchstart", function(event) {
      if (self.checkEvent()) {
        event = event.changedTouches[0];
        (event = self.createEvent(event, "touchstart")).button = event.button || "touch";
        if (!self.mouseDownPos[event.button]) {
          self.mouseDownPos[event.button] = [event.clientX, event.clientY];
          setTimeout(function() {
            delete self.mouseDownPos[event.button];
          }, e);
        }
      }
    });
    this.domElement.addEventListener("touchmove", function(event) {
      if (self.checkEvent()) {
        event.preventDefault();
        event = event.changedTouches[0];
        event = self.createEvent(event, "touchmove");
        var layerRect = self.domElement.getBoundingClientRect();
        var y = (event.clientX - layerRect.left) / layerRect.width * 2 - 1;
        var key = -(event.clientY - layerRect.top) / layerRect.height * 2 + 1;
        if (self.dragStartFlag) {
          self.draggingFlag = true;
          self.dispatchEvent(self.createDragEvent("drag", event, y, key));
        } else {
          layerRect = self.domElement.getBoundingClientRect();
          y = (event.clientX - layerRect.left) / layerRect.width * 2 - 1;
          key = -(event.clientY - layerRect.top) / layerRect.height * 2 + 1;
          if (self.getDistanceOfLastMouseDown(event) > 1) {
            self.dragStartFlag = true;
            self.dispatchEvent(self.createDragEvent("dragstart", event, y, key));
          }
        }
        r = true;
      }
    });
    this.domElement.addEventListener("touchend", function(event) {
      if (self.checkEvent()) {
        var evt;
        if (event = event.changedTouches[0], (event = self.createEvent(event, "touchend")).button = event.button || "touch", !r && self.getDistanceOfLastMouseDown(event) < self.app.clickDistance) {
          i++;
          setTimeout(function() {
            i = 0;
          }, e);
          if (event.button) {
            evt = self.mouseDownPos[event.button];
          }
          if (i > 1) {
            self.clearSingleClickTimer();
            event.button = "touch" === event.button ? void 0 : event.button;
            self.dispatchEvent(self.createMouseEvent("dblclick", event, evt));
            i = 0;
          } else {
            self.clickCountForSingleClick++;
            event.button = "touch" === event.button ? void 0 : event.button;
            self.dispatchEvent(self.createMouseEvent("click", event, evt));
            if (1 === self.clickCountForSingleClick) {
              self.singleClickTimer = Utils.timer.setTimeout(function() {
                event.button = "touch" === event.button ? void 0 : event.button;
                self.dispatchEvent(self.createMouseEvent("singleclick", event, evt));
                self.clickCountForSingleClick = 0;
              }, e);
            } else {
              self.clearSingleClickTimer();
            }
          }
        }
        if (r = false, self.dragStartFlag) {
          self.dragStartFlag = false;
          var element = self._draggingObject;
          if (element) {
            element.trigger("dragend", self.createDragEvent("dragend", event));
            self._draggingObject = null;
          }
        }
      }
    });
  }, a.prototype.init = function() {
    this.initMouseEvent(250);
    if (this.isSupportTouchEvent) {
      this.initTouchEvent(250);
    }
    this.initKeyboardEvent();
    this.initDragEvent();
  }, a.prototype.getDistanceOfLastMouseDown = function(event) {
    var pos1 = this.mouseDownPos[event.button];
    if (!pos1) {
      return 0;
    }
    var end = [void 0 !== event.x ? event.x : event.clientX, void 0 !== event.y ? event.y : event.clientY];
    return THING.Math.getDistance(pos1, end);
  }, a.prototype.clear = function() {
    this.singleClickTimer = null;
    this.mouseMoveObject = null;
    this.keysPressed = {};
    this.keyCodesPressed = {};
    this.mouseDownPos = {};
    this.mouseMovePos = [];
    this.mouseMoveDelta = null;
  }, a.prototype.update = function() {
    var f = this;
    this.mouseMoveEvents.forEach(function(t) {
      if (!t.hadFiltered) {
        if (f.mouseMoveObject != t.object) {
          f.processMouseOffEvent(t);
          f.processMouseOnEvent(t);
          f.processMouseOverEvent(t);
        }
      }
    });
    this.mouseMoveEvents = [];
  }, a;
}();
Oc = function() {
  function e(value) {
    r(this, e);
    this.app = value;
  }
  return e.prototype.addEventListener = function(type, name, fn, callback, priority, element, action, object) {
    priority = priority || 50;
    if (void 0 === this._listeners) {
      this._listeners = {};
    }
    var listeners = this._listeners;
    if (void 0 === listeners[type]) {
      listeners[type] = [];
    }
    var arr = listeners[type];
    var data = {
      __index : e._eventIDCount++,
      app : this.app,
      type : type,
      userData : fn,
      priority : priority,
      tag : element,
      once : action,
      object : object,
      callback : callback
    };
    if (name) {
      if (name.isBaseObject) {
        data.selector = name;
      } else {
        data.condition = name;
        data.selector = new xi(this.app);
      }
    }
    if (arr.length) {
      arr.push(data);
      if (priority > arr[arr.length - 2].priority) {
        arr.sort(function(b, a) {
          return a.priority == b.priority ? b.__index - a.__index : a.priority - b.priority;
        });
      }
    } else {
      arr.push(data);
    }
    var isPresent = THING.onAddEventListener;
    if (isPresent) {
      isPresent(data);
    }
  }, e.prototype.traverseListener = function(e) {
    if (void 0 !== this._listeners) {
      var listeners = this._listeners;
      var type;
      for (type in listeners) {
        listeners[type].forEach(function(context) {
          e(context);
        });
      }
    }
  }, e.prototype.getEventListener = function(name, type, callback, tag, options, document, selector) {
    if (void 0 === this._listeners) {
      return null;
    }
    var list = this._listeners[name];
    if (void 0 === list) {
      return null;
    }
    if (!options && this._isPauseEvent(name, document, tag)) {
      return null;
    }
    var j = 0;
    var dataLen = list.length;
    for (; j < dataLen; j++) {
      var node = list[j];
      if (node.condition) {
        if ("__any_event_can_match_it__" != type && node.condition != type) {
          continue;
        }
        if (document != this.app.root && node.selector && document && !node.selector.test(node.condition, [document])) {
          continue;
        }
      } else {
        if (node.object != document) {
          continue;
        }
      }
      if ((!selector || selector(node)) && !(callback && node.callback != callback || tag && tag != node.tag)) {
        return {
          listener : node,
          listenerArray : list,
          index : j
        };
      }
    }
    return null;
  }, e.prototype.getEventListeners = function(el, id, name, state, data) {
    if (void 0 === this._listeners) {
      return [];
    }
    var callback = function(child, document) {
      var $ = child.selector;
      if ($) {
        if ($.isBaseObject) {
          if ($ != document) {
            return false;
          }
        } else {
          if (!$.test(child.condition, [document])) {
            return false;
          }
        }
      } else {
        if (child.object != document) {
          return false;
        }
      }
      return true;
    };
    var result = [];
    var list = this._listeners;
    if (el) {
      if (void 0 === (element = list[el])) {
        return [];
      }
      if (!state && this._isPauseEvent(el, data, name)) {
        return [];
      }
      var i = 0;
      for (; i < element.length; i++) {
        var input = element[i];
        if (!(id && input.callback != id)) {
          if (name || input.tag) {
            if (!(name && input.tag != name)) {
              if (callback(input, data)) {
                result.push(input);
              }
            }
          }
        }
      }
    } else {
      var id;
      for (id in list) {
        var element = list[id];
        if (state || !this._isPauseEvent(id, data, name)) {
          i = 0;
          for (; i < element.length; i++) {
            if (callback(input = element[i], data)) {
              result.push(input);
            }
          }
        }
      }
    }
    return result;
  }, e.prototype.removeEventListener = function(type, fn, obj, name, object) {
    if (void 0 !== this._listeners) {
      var fns = this._listeners[type];
      if (void 0 !== fns) {
        var i = 0;
        for (; i < fns.length; i++) {
          if ((obj = fns[i]).object == object) {
            if (obj.selector) {
              if (obj.selector.isBaseObject) {
                if (fn != obj.selector) {
                  continue;
                }
              } else {
                if (obj.condition != fn) {
                  continue;
                }
              }
            }
            if (!name || obj.tag == name) {
              var filter = THING.onRemoveEventListener;
              if (filter) {
                filter(obj);
              }
              obj.removed = true;
              fns.splice(i--, 1);
            }
          }
        }
      }
    }
  }, e.prototype.removeAllListeners = function() {
    var removeListener = THING.onRemoveEventListener;
    if (removeListener) {
      var eventType;
      for (eventType in this._listeners) {
        this._listeners[eventType].forEach(function(selector) {
          removeListener(selector);
        });
      }
    }
    this._listeners = void 0;
  }, e.prototype.checkObject = function(that, e) {
    if (e.object) {
      if (e.object != that.object && !e.object.canAcceptEvent(that)) {
        return false;
      }
      if (this._getStopPropagation(that)) {
        if (that.object && that.object.isChildOf(e.object)) {
          return false;
        }
        var editor = that.intersect;
        if (editor && editor.node.isChildOf(that.object.node)) {
          return false;
        }
      }
    }
    return true;
  }, e.prototype._getStopPropagation = function(event) {
    var value;
    if (!(value = Utils.isFunction(event.stopPropagation) ? event._stopPropagation : event.stopPropagation)) {
      var i = event.type;
      if (-1 !== ["levelchange", "enterlevel", "leavelevel", "levelflyend", "load", "complete", "mouseenter", "mouseleave"].indexOf(i)) {
        value = true;
      }
    }
    return value = Utils.parseValue(THING.__stopEventPropagation__, value);
  }, e.prototype.getBindingObjectBySelector = function(e, s, self) {
    var this_area = this._getStopPropagation(e);
    if (self.isBaseObject) {
      if (self != e.object && !this_area && self.isChildOf(e.object)) {
        return e.object;
      }
    } else {
      if (e.object) {
        if (self.test(s.condition, [e.object])) {
          return e.object;
        }
        if (!this_area) {
          var parents = e.object.parents;
          var classElement = self.queryResult(s.condition, parents);
          if (classElement.length) {
            return classElement[0];
          }
        }
      }
    }
    return null;
  }, e.prototype.getBindingObject = function(obj, item, event) {
    var name;
    var context = item.selector;
    var content = item.once;
    if (context) {
      if (event) {
        return null;
      }
      if (!(name = this.getBindingObjectBySelector(obj, item, context))) {
        return null;
      }
    } else {
      if (!this.checkObject(obj, item)) {
        return null;
      }
    }
    var root = name || obj.object || item.object || window;
    return content && context && root._ignoreEvents && root._ignoreEvents.has(item) ? null : root;
  }, e.prototype.dispatchEvent = function(e, value) {
    if (void 0 !== this._listeners) {
      var result;
      var list = this._listeners[e.type];
      if (void 0 !== list) {
        var _eventQueuedUntilReady = list.slice(0);
        var i = 0;
        for (; i < _eventQueuedUntilReady.length; i++) {
          var event = _eventQueuedUntilReady[i];
          var select = event.selector;
          var data = event.userData;
          var once = event.once;
          var newVersion = event.tag;
          if (!event.removed && !this._isPauseEvent(e.type, e.object, newVersion)) {
            var element = this.getBindingObject(e, event, value);
            if (element && !element.destroyed && !this._isPauseEvent(e.type, element, newVersion)) {
              var result;
              var eNext;
              var f = e.data;
              if (data) {
                e.data = data;
              }
              if (select) {
                if (element.isBaseObject) {
                  result = e.object;
                  e.object = element;
                }
              } else {
                if (event.object) {
                  result = e.object;
                  e.object = event.object;
                }
              }
              if (e.object) {
                eNext = e.pickedObject;
                e.pickedObject = e.object;
              }
              var status = e.beforeTrigger;
              if (status) {
                status(e);
              }
              var dispatchEvent = THING.onBeforeCallEventListener;
              if (dispatchEvent) {
                dispatchEvent(event, e);
              }
              if (element.isBaseObject) {
                e.__lastObject__ = element;
              }
              var target = event.callback.call(element, e, event.tag);
              if (!Utils.isNull(target)) {
                result = target;
              }
              var fire = THING.onAfterCallEventListener;
              if (fire) {
                fire(event, e);
              }
              var cb = e.afterTrigger;
              if (cb && cb(e), select ? e.object == element && (e.object = result) : e.object && e.object == event.object && (e.object = result), eNext ? e.pickedObject = eNext : delete e.pickedObject, f && (e.data = f), once) {
                if (select) {
                  element._ignoreEvents = element._ignoreEvents || new Set;
                  element._ignoreEvents.add(event);
                } else {
                  var eventTarget = list.indexOf(event);
                  if (-1 !== eventTarget) {
                    list.splice(eventTarget, 1);
                  }
                }
              }
            }
          }
        }
      }
      return result;
    }
  }, e;
}();
Oc._eventIDCount = 1;
var Bc = function() {
  function View(app) {
    r(this, View);
    this.app = app;
    this._pauseSelector = null;
    this._pauseEvents = new Map;
    this._resumeEvents = new Map;
  }
  return View.prototype._isEvent = function(e, name, dom, value, callback) {
    var element = e.get(name);
    if (!element) {
      return false;
    }
    if (value && element._tag_names && !element._tag_names.has(value)) {
      return false;
    }
    var x = 0;
    var o = element.length;
    for (; x < o; x++) {
      var o = element[x];
      var t = o.selector;
      if (dom) {
        if (Utils.isString(dom)) {
          if (dom != t) {
            continue;
          }
        } else {
          if (t) {
            if (t.isBaseObject) {
              if (t != dom) {
                continue;
              }
            } else {
              if ("*" != t && !this._pauseSelector.test(t, [dom])) {
                continue;
              }
            }
          }
        }
      } else {
        if (t) {
          continue;
        }
      }
      if ((!callback || callback(value, o.tag)) && (!o.parent || !dom || dom.isChildOf(o.parent))) {
        return true;
      }
    }
    return false;
  }, View.prototype.isPauseEvent = function(value, target, name) {
    function move(sFrom, sTo) {
      return !sTo || sFrom == sTo;
    }
    return value = Utils.toLowerCase(value), !!this._isEvent(this._pauseEvents, value, target, name, move) && !this._isEvent(this._resumeEvents, value, target, name, move);
  }, View.prototype.isSameSelector = function(target, source) {
    return target && source && target.isSelector && source.isSelector ? target.equals(source) : target == source;
  }, View.prototype.update = function() {
    this._pauseEvents.forEach(function(fixChrome82795) {
      var i = 0;
      for (; i < fixChrome82795.length; i++) {
        if (fixChrome82795[i].justInFrame) {
          fixChrome82795.splice(i--, 1);
        }
      }
    });
  }, View.prototype.hasPauseEvent = function(obj, t, j, i, name) {
    var events = this._pauseEvents.get(obj);
    if (!events) {
      return false;
    }
    var index = 0;
    for (; index < events.length; index++) {
      var e = events[index];
      if (this.isSameSelector(e.selector, t) && (e.tag == j && e.justInFrame == i && e.parent == name)) {
        return true;
      }
    }
    return false;
  }, View.prototype.pauseEvent = function(name, element, v, e, event) {
    if (name = Utils.toLowerCase(name)) {
      if (this._pauseSelector || (this._pauseSelector = new xi(this.app)), !this.hasPauseEvent(name, element, v, e, event)) {
        var data = {
          eventType : name,
          selector : element,
          tag : v,
          justInFrame : e,
          parent : event
        };
        var s = this._pauseEvents.get(name);
        if (!s) {
          s = [];
          this._pauseEvents.set(name, s);
        }
        if (v) {
          s._tag_names = s._tag_names || new Set;
          s._tag_names.add(v);
        }
        s.push(data);
      }
    } else {
      THING.Utils.error("event type is invalid, please check it");
    }
  }, View.prototype.removeResumeEvents = function(e, id, version, index) {
    var results = this._resumeEvents.get(e);
    if (results) {
      var i = 0;
      for (; i < results.length; i++) {
        var query = results[i];
        if (query.selector == id) {
          if (query.parent == index) {
            if (!(version && version != query.tag)) {
              results.splice(i--, 1);
            }
          }
        }
      }
    }
  }, View.prototype.resumeEvent = function(value, key, i, name) {
    if (value = Utils.toLowerCase(value)) {
      var s = this._pauseEvents.get(value);
      if (s) {
        if (!key) {
          name = null;
        }
        var j = 0;
        for (; j < s.length; j++) {
          var entry = s[j];
          if (this.isSameSelector(entry.selector, key) && entry.parent == name) {
            if (entry.tag) {
              if (entry.tag != i) {
                continue;
              }
            } else {
              if (i) {
                var result = this._resumeEvents.get(value);
                if (!result) {
                  result = [];
                  this._resumeEvents.set(value, result);
                }
                result.push({
                  eventType : value,
                  selector : key,
                  tag : i,
                  parent : name
                });
                continue;
              }
            }
            return this.removeResumeEvents(value, key, i, name), s.splice(j, 1), true;
          }
        }
        return false;
      }
    } else {
      THING.Utils.error("event type is invalid, please check it");
    }
  }, View.prototype.clear = function() {
    this._pauseSelector = null;
    this._pauseEvents = new Map;
    this._resumeEvents = new Map;
  }, View;
}();
Fc = function() {
  function app(options) {
    r(this, app);
    this.app = options;
    this._eventSelectors = {
      residentEvents : {
        name : "residentEvents"
      },
      app : {
        name : "app"
      },
      objectEvents : {
        name : "objectEvents"
      }
    };
    var parser = this;
    this._eventSelectors.forEach = function(callback) {
      callback(parser._eventSelectors.residentEvents);
      callback(parser._eventSelectors.app);
      callback(parser._eventSelectors.objectEvents);
    };
    this._eventSelectors.hasEvent = function(event, listener, node, el, type) {
      var keywordResults = [parser._eventSelectors.residentEvents, parser._eventSelectors.app, parser._eventSelectors.objectEvents];
      var i = 0;
      for (; i < keywordResults.length; i++) {
        if (keywordResults[i].hasEvent(event, listener, node, el, type)) {
          return true;
        }
      }
      return false;
    };
    this._eventSelectors.forEach(function(length) {
      parser._initEventSelector(length);
    });
    this._eventPauser = new Bc(this.app);
    this._eventIDCount = 0;
  }
  return app.prototype._initEventSelector = function(obj) {
    var assert = this;
    var self = new Oc(this.app);
    obj._trigger = self;
    obj._trigger._isPauseEvent = function(e, template, name) {
      return assert.isPauseEvent(e, template, name);
    };
    obj.traverse = function(callback) {
      var type;
      for (type in self._listeners) {
        if (false === callback(type, self._listeners[type])) {
          return;
        }
      }
    };
    obj.hasEvent = function(type, name, el, data, event) {
      return !!self.getEventListener(type, "__any_event_can_match_it__", name, el, data, event);
    };
    obj.getEvents = function(node, name, type, siteId, data) {
      return self.getEventListeners(node, name, type, siteId, data);
    };
    obj.traverseListener = function(e) {
      self.traverseListener(e);
    };
    obj.replaceObjectEvent = function(val, component) {
      var type;
      for (type in self._listeners) {
        self._listeners[type].forEach(function(options) {
          if (options.selector == component) {
            options.selector = val;
          }
          if (options.object == component) {
            options.object = val;
          }
        });
      }
    };
    obj.removeObjectEvent = function(args, fn, handler, w, defaultWidgets) {
      self.removeEventListener(args, fn, handler, w, defaultWidgets);
    };
    obj.bindObjectEvent = function(type, callback, opt, cb, data, value, action, context) {
      var result = self.getEventListener(type, callback, null, value, false, context, function(data) {
        return !!value && (!data.tag || data.tag == value);
      });
      if (result) {
        result.listenerArray.splice(result.index, 1);
      }
      self.addEventListener(type, callback, opt, cb, data, value, action, context);
    };
    obj.trigger = function(name, event) {
      if (name.type = Utils.toLowerCase(name.type), name.type) {
        return self.dispatchEvent(name, event);
      }
      THING.Utils.error("event type is invalid, please check it");
    };
  }, app.prototype.isPauseEvent = function(e, target, value) {
    return this._eventPauser.isPauseEvent(e, target, value);
  }, app.prototype.hasPauseEvent = function(fn, t, f, n, type) {
    return this._eventPauser.hasPauseEvent(fn, t, f, n, type);
  }, app.prototype.pauseEvent = function(e, data, element, pos, event) {
    this._eventPauser.pauseEvent(e, data, element, pos, event);
  }, app.prototype.resumeEvent = function(e, fn, obj, eventType) {
    return this._eventPauser.resumeEvent(e, fn, obj, eventType);
  }, app.prototype.hasEvent = function(event, listener, node, el, type) {
    return !!this._eventSelectors.hasEvent(event, listener, node, el, type);
  }, app.prototype.getEvents = function(data, start, type, siteId, name) {
    var onSelectionCalls = [];
    return this._eventSelectors.forEach(function(self) {
      var field = self.getEvents(data, start, type, siteId, name);
      if (field) {
        field.forEach(function(e) {
          onSelectionCalls.push(e);
        });
      }
    }), onSelectionCalls;
  }, app.prototype.traverseListener = function(e) {
    this._eventSelectors.forEach(function(PL$37) {
      PL$37.traverseListener(e);
    });
  }, app.prototype.replaceObjectEvent = function(n, v) {
    this._eventSelectors.forEach(function(lms) {
      lms.replaceObjectEvent(n, v);
    });
  }, app.prototype.removeObjectEvent = function(i, args, e, w, defaultWidgets) {
    this._eventSelectors.forEach(function(debug) {
      debug.removeObjectEvent(i, args, e, w, defaultWidgets);
    });
  }, app.prototype.addEventListener = function(type, fn, name) {
    return this.bindCall(type, null, null, fn, null, false, name);
  }, app.prototype.removeEventListener = function(type, fn) {
    return this.unbindCall(type, null, fn);
  }, app.prototype.bindCall = function(name, type, fn, data, options, arg, cb) {
    if (!(name = Utils.toLowerCase(name))) {
      return THING.Utils.error("event type is invalid, please check it"), null;
    }
    var opts = Utils.parseEvent(type, fn, data, options, null, cb);
    return opts ? (opts.selector ? this._eventSelectors.objectEvents.bindObjectEvent(name, opts.selector, opts.userData, opts.callback, opts.priority, opts.tag, arg, this.app.root) : this._eventSelectors.app.bindObjectEvent(name, opts.selector, opts.userData, opts.callback, opts.priority, opts.tag, arg, null), opts) : null;
  }, app.prototype.unbindCall = function(name, type, id) {
    if (!(name = Utils.toLowerCase(name))) {
      return THING.Utils.error("event type is invalid, please check it"), null;
    }
    var obj = Utils.parseEvent(type, null, id);
    return obj ? (obj.selector ? this._eventSelectors.objectEvents.removeObjectEvent(name, obj.selector, obj.callback, obj.tag, this.app.root) : this._eventSelectors.app.removeObjectEvent(name, obj.selector, obj.callback, obj.tag), obj) : null;
  }, app.prototype.triggerCall = function(func) {
    return this._eventSelectors.app.trigger(func, true);
  }, app.prototype.bindCallObj = function(value, name, fn, type, _, t, f, cb) {
    if (!(value = Utils.toLowerCase(value))) {
      return THING.Utils.error("event type is invalid, please check it"), null;
    }
    var res = Utils.parseEvent(name, fn, type, t, cb);
    if (!res) {
      return null;
    }
    var u = this;
    return _.forEach(function(resource_representation) {
      u._eventSelectors.objectEvents.bindObjectEvent(value, res.selector, res.userData, res.callback, res.priority, res.tag, f, resource_representation);
    }), res;
  }, app.prototype.unbindCallObj = function(name, type, i, forceOptional) {
    name = Utils.toLowerCase(name);
    var val = Utils.parseEvent(type, null, i);
    if (!val) {
      return null;
    }
    var o = this;
    return forceOptional.forEach(function(defaultWidgets) {
      o._eventSelectors.objectEvents.removeObjectEvent(name, val.selector, val.callback, val.tag, defaultWidgets);
    }), val;
  }, app.prototype.hasAnyCallObjects = function(t, f) {
    var partial_tree = this._eventSelectors.objectEvents;
    var r = false;
    var self = this;
    return partial_tree.traverse(function(t, data) {
      if (data.object && t.indexOf(data.object)) {
        if (f && self._isPauseEvent(t, data.object, data.tag)) {
          return;
        }
        return r = true, false;
      }
    }), r;
  }, app.prototype.dispatchBindCallObj = function(name, e, o, n) {
    if (e = e || {}, name = Utils.toLowerCase(name)) {
      if (Utils.isString(e) && !n && (n = e, e = {}), !n || Utils.isString(n)) {
        var mLocalToGlobal;
        if (Utils.isNull(e.stopPropagation)) {
          e.stopPropagation = function() {
            this._stopPropagation = true;
          };
        }
        var alpha = this;
        return o.forEach(function(data) {
          var id = e.object;
          var v = e.type;
          var t = e.tag;
          e.object = data;
          e.type = name;
          e.tag = n;
          mLocalToGlobal = alpha._eventSelectors.objectEvents.trigger(e);
          e.object = id;
          e.type = v;
          e.tag = t;
        }), mLocalToGlobal;
      }
      THING.Utils.error('Trigger "' + name + '" failed, due to tag is not string type');
    } else {
      THING.Utils.error("event type is invalid, please check it");
    }
  }, app.prototype.addResidentEventListener = function(name, scope) {
    if (name = Utils.toLowerCase(name)) {
      this._eventSelectors.residentEvents._trigger.addEventListener(name, null, null, scope);
    } else {
      THING.Utils.error("event type is invalid, please check it");
    }
  }, app.prototype.removeResidentEventListener = function(name, fn) {
    if (name = Utils.toLowerCase(name)) {
      this._eventSelectors.residentEvents._trigger.removeEventListener(name, null, fn);
    } else {
      THING.Utils.error("event type is invalid, please check it");
    }
  }, app.prototype.update = function() {
    this._eventSelectors.forEach(function(e) {
      e.trigger({
        type : "update"
      });
    });
    this._eventPauser.update();
  }, app.prototype.clear = function() {
    this._eventSelectors.forEach(function(self) {
      self._trigger.removeAllListeners();
    });
    this._eventPauser.clear();
  }, app.prototype.unbindAppEvents = function(selected) {
    this._eventSelectors.forEach(function(store) {
      var type;
      for (type in store._listeners) {
        var data = store._listeners[type];
        var i = 0;
        for (; i < data.length; i++) {
          if (data[i].app.uuid == selected) {
            data.splice(i--, 1);
          }
        }
      }
    });
  }, app.prototype._isAppEvent = function(controlName) {
    return -1 !== ["dragstart", "drag", "dragging", "dragend", "keydown", "keypress", "keyup"].indexOf(controlName);
  }, app.prototype.dispatchEvent = function(e) {
    var pipelets = [this._eventSelectors.residentEvents, this._eventSelectors.app];
    var i = [];
    if (pipelets.forEach(function(t) {
      var r = t.trigger(e);
      if (!Utils.isNull(r)) {
        i.push(r);
      }
    }), e.object) {
      var s = e.object.trigger(e.type, e);
      if (Utils.isNull(s) || i.push(s), !e._stopPropagation) {
        var parent = e.object.parent;
        for (; parent; parent = parent.parent) {
          var node = parent.canAcceptEvent(e);
          if (node) {
            if (true === node) {
              node = parent;
            } else {
              parent = node;
            }
            var id = e.object;
            e.object = node;
            s = node._eventTrigger.dispatchEvent(e.type, node, e);
            if (!Utils.isNull(s)) {
              i.push(s);
            }
            e.object = id;
          }
        }
      }
    }
    if (this._isAppEvent(e.type)) {
      s = this._eventSelectors.objectEvents.trigger(e);
      if (!Utils.isNull(s)) {
        i.push(s);
      }
    }
    if (i.length) {
      return i[0];
    }
  }, app;
}();
Lc = function() {
  function t(app) {
    r(this, t);
    this.app = app;
    this.eventTriggerManager = new Fc(this.app);
    this.eventProcessor = new kc(this.eventTriggerManager);
  }
  return t.prototype.addResidentEventListener = function(value, key) {
    this.eventTriggerManager.addResidentEventListener(value, key);
  }, t.prototype.removeResidentEventListener = function(close, name) {
    this.eventTriggerManager.removeResidentEventListener(close, name);
  }, t.prototype.addEventListener = function(type, name, callback) {
    this.eventTriggerManager.addEventListener(type, name, callback);
  }, t.prototype.removeEventListener = function(type, fn) {
    this.eventTriggerManager.removeEventListener(type, fn);
  }, t.prototype.dispatchEvent = function(type) {
    return this.eventTriggerManager.dispatchEvent(type);
  }, t.prototype.update = function() {
    this.eventProcessor.update();
    this.eventTriggerManager.update();
  }, t.prototype.bindCall = function(name, type, selector, fn, s, data, func) {
    return this.eventTriggerManager.bindCall(name, type, selector, fn, s, data, func);
  }, t.prototype.unbindCall = function(target, type, context) {
    return "singleclick" == target && this.eventProcessor.clearSingleClickTimer(), this.eventTriggerManager.unbindCall(target, type, context);
  }, t.prototype.triggerCall = function(func) {
    return this.eventTriggerManager.triggerCall(func);
  }, t.prototype.bindCallObj = function(fn, name, n, event, tags, func, message, options) {
    return this.eventTriggerManager.bindCallObj(fn, name, n, event, tags, func, message, options);
  }, t.prototype.unbindCallObj = function(module, option, i, forceOptional) {
    return this.eventTriggerManager.unbindCallObj(module, option, i, forceOptional);
  }, t.prototype.hasAnyCallObjects = function(e, target) {
    return this.eventTriggerManager.hasAnyCallObjects(e, target);
  }, t.prototype.dispatchBindCallObj = function(i, array, n, cutoff) {
    return this.eventTriggerManager.dispatchBindCallObj(i, array, n, cutoff);
  }, t.prototype.isPauseEvent = function(e, type, value) {
    return this.eventTriggerManager.isPauseEvent(e, type, value);
  }, t.prototype.pauseEvent = function(e, element, value, pos, event) {
    this.eventTriggerManager.pauseEvent(e, element, value, pos, event);
  }, t.prototype.resumeEvent = function(e, fn, obj, eventType) {
    return this.eventTriggerManager.resumeEvent(e, fn, obj, eventType);
  }, t.prototype.hasEvent = function(event, type, node, name) {
    return this.eventTriggerManager.hasEvent(event, null, node, name, type);
  }, t.prototype.getEvents = function(data, type, name, siteId) {
    return this.eventTriggerManager.getEvents(data, null, name, siteId, type);
  }, t.prototype.traverseListener = function(e) {
    return this.eventTriggerManager.traverseListener(e);
  }, t.prototype.replaceObjectEvent = function(num, values) {
    return this.eventTriggerManager.replaceObjectEvent(num, values);
  }, t.prototype.canClick = function(proxy) {
    return !(this.eventProcessor.getDistanceOfLastMouseDown(proxy) > this.app.clickDistance);
  }, t.prototype.isKeyPressed = function(key) {
    return Utils.isNumber(key) ? !!this.eventProcessor.keyCodesPressed[key] : !!this.eventProcessor.keysPressed[key];
  }, t.prototype.clear = function() {
    this.eventTriggerManager.clear();
    this.eventProcessor.clear();
  }, t.prototype.clearSingleClickTimer = function() {
    this.eventProcessor.clearSingleClickTimer();
  }, t.prototype.unbindAppEvents = function(clusters) {
    this.eventTriggerManager.unbindAppEvents(clusters);
  }, n(t, [{
    key : "mousePosition",
    get : function() {
      return this.eventProcessor.mouseMovePos;
    }
  }, {
    key : "skipFrameCount",
    set : function(num) {
      this.eventProcessor.skipFrameCount = num;
    },
    get : function() {
      return this.eventProcessor.skipFrameCount;
    }
  }]), t;
}();
Ic = function() {
  function options(app, name, obj) {
    var key;
    for (key in r(this, options), this.app = app, this.name = name, this.defaultKeyName = "name", this.initialState = null, this.runningState = null, this.states = new Map, obj) {
      this.addState(key, obj[key]);
    }
  }
  return options.prototype.getFromState = function(state, props) {
    var val = state[props.stateType];
    if (void 0 !== val && Utils.isFunction(val)) {
      var result = state[props.stateType](props);
      if (null !== result) {
        return result;
      }
    }
    return null;
  }, options.prototype.dispatchEventToState = function(target, data) {
    var reference = target[data.stateType];
    if (void 0 !== reference && Utils.isFunction(reference)) {
      target[data.stateType](data, data.params);
    }
  }, options.prototype.findState = function(id) {
    return this.states.get(id);
  }, options.prototype.prevState = function() {
    this.dispatchEvent({
      stateType : "onPrevState"
    });
  }, options.prototype.nextState = function() {
    this.dispatchEvent({
      stateType : "onNextState"
    });
  }, options.prototype.clone = function(element) {
    var classRegCache = {};
    var propertyThresholdsMap = this.app.stateManager.stateFactory;
    var obj = this.states.keys();
    var cells = Array.isArray(obj);
    var i = 0;
    obj = cells ? obj : obj[Symbol.iterator]();
    for (;;) {
      var v;
      if (cells) {
        if (i >= obj.length) {
          break;
        }
        v = obj[i++];
      } else {
        if ((i = obj.next()).done) {
          break;
        }
        v = i.value;
      }
      var name = v;
      var RegExp = propertyThresholdsMap.get(name);
      if (!RegExp) {
        return null;
      }
      classRegCache[name] = new RegExp(this.app);
    }
    return new options(this.app, element, classRegCache);
  }, options.prototype.get = function(obj) {
    if (this.runningState) {
      return this.getFromState(this.runningState, obj);
    }
    if (this.states.length > 1) {
      var ret = this.states;
      var desc = Array.isArray(ret);
      var k = 0;
      ret = desc ? ret : ret[Symbol.iterator]();
      for (;;) {
        var name;
        if (desc) {
          if (k >= ret.length) {
            break;
          }
          name = ret[k++];
        } else {
          if ((k = ret.next()).done) {
            break;
          }
          name = k.value;
        }
        var old = name;
        var config = this.getFromState(old, obj);
        if (null !== config) {
          return config;
        }
      }
    }
    return null;
  }, options.prototype.dispatchEvent = function(data) {
    var TiDev = this;
    if (this.runningState) {
      this.dispatchEventToState(this.runningState, data);
    } else {
      if (this.states.length > 1) {
        this.states.forEach(function(i) {
          TiDev.dispatchEventToState(i, data);
        });
      }
    }
  }, options.prototype.enter = function(path, self) {
    self = self || {};
    var state = this.findState(path);
    if (!state) {
      return null;
    }
    if (!this.initialState) {
      this.initialState = state;
    }
    var task = this.runningState;
    return this.leave(), this.app.trigger("beforeEnterState", {
      state : task,
      nextState : state
    }), task && (self.prevState = task), this.runningState = state, this.dispatchEventToState(this.runningState, {
      stateType : "onEnter",
      params : self
    }), this.app.trigger("afterEnterState", {
      state : state,
      prevState : self.prevState
    }), delete self.prevState, this.runningState;
  }, options.prototype.leave = function() {
    if (this.runningState) {
      var data = {};
      if (this.runningState) {
        data.state = this.runningState;
        data.stateName = this.runningState[this.defaultKeyName];
      }
      this.app.trigger("beforeLeaveState", data);
      this.dispatchEventToState(this.runningState, {
        stateType : "onLeave"
      });
      this.runningState = null;
      this.app.trigger("afterLeaveState", data);
    }
  }, options.prototype.addState = function(value, index) {
    if (void 0 === index[this.defaultKeyName]) {
      index[this.defaultKeyName] = value;
    }
    index.isState = true;
    index.stateGroup = this;
    this.states.set(value, index);
  }, options.prototype.isInitialState = function() {
    return this.runningState == this.initialState;
  }, options.prototype.isRunningState = function(editable) {
    var state = this.findState(editable);
    return !!state && state == this.runningState;
  }, options.prototype.getRunningStateName = function() {
    if (this.runningState) {
      var files = this.states.keys();
      var isArray = Array.isArray(files);
      var i = 0;
      files = isArray ? files : files[Symbol.iterator]();
      for (;;) {
        var name;
        if (isArray) {
          if (i >= files.length) {
            break;
          }
          name = files[i++];
        } else {
          if ((i = files.next()).done) {
            break;
          }
          name = i.value;
        }
        var index = name;
        if (this.runningState == this.states.get(index)) {
          return index;
        }
      }
    }
    return "";
  }, options.prototype.hasState = function(name) {
    if (Utils.isString(name)) {
      return this.states.has(name);
    }
    var ret = this.states.keys();
    var desc = Array.isArray(ret);
    var k = 0;
    ret = desc ? ret : ret[Symbol.iterator]();
    for (;;) {
      var node;
      if (desc) {
        if (k >= ret.length) {
          break;
        }
        node = ret[k++];
      } else {
        if ((k = ret.next()).done) {
          break;
        }
        node = k.value;
      }
      var index = node;
      if (name == this.states.get(index)) {
        return true;
      }
    }
    return false;
  }, options.prototype.clear = function() {
    this.leave();
    var keywordResults = [].concat(this.states.values());
    var i = 0;
    for (; i < keywordResults.length; i++) {
      delete keywordResults[i];
    }
    delete this.states;
  }, options;
}();
Nc = function() {
  function data(app) {
    r(this, data);
    this.app = app;
    this.eventManager = app.events;
    this.stateFactory = new Map;
    this.stateGroupID = 1;
    this.stateGroups = new Array;
    this.init();
  }
  return data.prototype.init = function() {
    var listeners = {
      click : "onClick",
      dblclick : "onDoubleClick",
      singleclick : "onSingleClick",
      mouseover : "onMouseOver",
      mouseout : "onMouseOut",
      mouseup : "onMouseUp",
      mousedown : "onMouseDown",
      mousemove : "onMouseMove",
      dragstart : "onDragStart",
      drag : "onDrag",
      dragend : "onDragEnd",
      keydown : "onKeyDown",
      keypress : "onKeyPress",
      keyup : "onKeyUp"
    };
    var qElm = this;
    var key;
    for (key in listeners) {
      this.eventManager.addResidentEventListener(key, function(evt) {
        evt.stateType = listeners[evt.type];
        qElm.dispatchEvent(evt);
        delete evt.stateType;
      });
    }
  }, data.prototype.clear = function() {
    this.stateFactory.clear();
    this.stateGroupID = 1;
    this.stateGroups = [];
  }, data.prototype.findState = function(id) {
    var ret = this.stateGroups;
    var desc = Array.isArray(ret);
    var k = 0;
    ret = desc ? ret : ret[Symbol.iterator]();
    for (;;) {
      var node;
      if (desc) {
        if (k >= ret.length) {
          break;
        }
        node = ret[k++];
      } else {
        if ((k = ret.next()).done) {
          break;
        }
        node = k.value;
      }
      var state = node.findState(id);
      if (state) {
        return state;
      }
    }
    return null;
  }, data.prototype.findStateGroup = function(value) {
    var ret = this.stateGroups;
    var desc = Array.isArray(ret);
    var k = 0;
    ret = desc ? ret : ret[Symbol.iterator]();
    for (;;) {
      var name;
      if (desc) {
        if (k >= ret.length) {
          break;
        }
        name = ret[k++];
      } else {
        if ((k = ret.next()).done) {
          break;
        }
        name = k.value;
      }
      var o = name;
      if (o.name == value || o.hasState(value)) {
        return o;
      }
    }
    return null;
  }, data.prototype.get = function(num) {
    var category = 0;
    for (; category < this.stateGroups.length; category++) {
      var change = this.stateGroups[category].get(num);
      if (change) {
        return change;
      }
    }
    return null;
  }, data.prototype.dispatchEvent = function(type) {
    if (Utils.isString(type)) {
      this.dispatchEvent({
        type : type
      });
    } else {
      this.stateGroups.forEach(function(t) {
        t.dispatchEvent(type);
      });
    }
  }, data.prototype._genGroupName = function() {
    var e = "StateManagerInternal_" + this.stateGroupID.toString();
    return this.stateGroupID++, e;
  }, data.prototype.clone = function(element) {
    var t = this.findStateGroup(element);
    if (!t) {
      return null;
    }
    element = this._genGroupName();
    var previous = t.clone(element);
    return this.stateGroups.push(previous), previous;
  }, data.prototype.remove = function(s) {
    var i = 0;
    for (; i < this.stateGroups.length; i++) {
      if (this.stateGroups[i] == s) {
        return s.leave(), this.stateGroups[i].clear(), this.stateGroups.splice(i, 1), true;
      }
    }
    return false;
  }, data.prototype.register = function(value, name) {
    if (Utils.isNull(value)) {
      return null;
    }
    if (Utils.isArray(value)) {
      return THING.Utils.error("states should not be array type, use {} instead"), null;
    }
    var unshimExtensions = Object.keys(value);
    if (1 == unshimExtensions.length && void 0 === name) {
      name = unshimExtensions[0];
    }
    if (Utils.isBlank(name)) {
      name = this._genGroupName();
    }
    var field = this.findStateGroup(name);
    if (field) {
      var i;
      for (i in value) {
        field.addState(i, value[i]);
      }
    } else {
      field = new Ic(this.app, name, value);
      this.stateGroups.push(field);
    }
    return field;
  }, data.prototype.registerEx = function(object, key) {
    var name;
    for (name in object) {
      this.stateFactory.set(name, object[name]);
      object[name] = new object[name](this.app);
    }
    return this.register(object, key);
  }, data.prototype.unregister = function(name) {
    var i = 0;
    for (; i < this.stateGroups.length; i++) {
      if (this.stateGroups[i].name == name) {
        return this.stateGroups[i].clear(), this.stateGroups.splice(i, 1), true;
      }
    }
    return false;
  }, data.prototype.change = function(name, self) {
    var i = this.findStateGroup(name);
    if (!i) {
      return THING.Utils.error("state group not found: " + name), null;
    }
    var res = i.enter(name, self);
    return res || null;
  }, data.prototype.leave = function(data) {
    var actual = this.findStateGroup(data);
    return actual ? !!actual.isRunningState(data) && (actual.leave(), true) : (THING.Utils.error("state group not found: " + data), false);
  }, data.prototype.getRunningState = function(pageSize) {
    var form = this.findStateGroup(pageSize);
    return form ? form.runningState : (THING.Utils.error("state group not found: " + name), null);
  }, data.prototype.getRunningStateName = function(pageSize) {
    var size = this.findStateGroup(pageSize);
    return size ? size.getRunningStateName() : (THING.Utils.error("state group not found: " + name), null);
  }, data.prototype.hasRunningState = function(pageSize) {
    var size = this.findStateGroup(pageSize);
    return !!size && !!size.runningState;
  }, data.prototype.update = function() {
    this.dispatchEvent({
      stateType : "onUpdate"
    });
  }, data.prototype.onUpdate = function(e) {
    this.update(e);
  }, data;
}();
Hc = function() {
  function t(app, state) {
    r(this, t);
    this.app = app;
    this.reverseMode = state;
    this.commands = [];
  }
  return t.prototype.execute = function() {
    var i = 0;
    for (; i < this.commands.length; i++) {
      this.commands[i].execute();
    }
    this.app.events.dispatchEvent({
      type : "executeCommand",
      cmd : this
    });
    if (this.reverseMode) {
      this.commands.reverse();
    }
  }, t.prototype.undo = function() {
    var i = 0;
    for (; i < this.commands.length; i++) {
      this.commands[i].undo();
    }
    if (this.reverseMode) {
      this.commands.reverse();
    }
  }, t.prototype.add = function(cmd) {
    if (cmd) {
      this.commands.push(cmd);
    }
  }, t.prototype.remove = function(name) {
    if (name) {
      var i = this.commands.indexOf(name);
      if (i > -1) {
        this.commands.slice(i, 1);
      }
    }
  }, t.prototype.clear = function() {
    this.commands.clear();
  }, t;
}();
Uc = function() {
  function self(value) {
    r(this, self);
    this.app = value;
    this.registerTypes = {};
    this.undoList = [];
    this.redoList = [];
    this._doing = false;
  }
  return self.prototype.register = function(name, callback) {
    this.registerTypes[name] = callback;
  }, self.prototype.unregister = function(name) {
    delete this.registerTypes[name];
  }, self.prototype._create = function(data) {
    var type = data.type;
    var Node = this.registerTypes[type];
    if (Node) {
      data.app = this.app;
      var array = new Node(data);
      return array.type = type, array;
    }
    THING.Utils.error("command not found: " + type);
  }, self.prototype.create = function(data, id) {
    if (Utils.isArray(data)) {
      var store = new Hc(this.app, id);
      var byteIndex = 0;
      for (; byteIndex < data.length; byteIndex++) {
        var response = this._create(data[byteIndex]);
        store.add(response);
      }
      if (store.commands.length) {
        return store;
      }
    } else {
      if (Utils.isObject(data)) {
        return response = this._create(data);
      }
      Utils.isString(data);
    }
    return null;
  }, self.prototype.execute = function(e, context) {
    var data = this.create(e, context);
    return data ? (data.execute(), this._push(data), this.app.events.dispatchEvent({
      type : "executeCommand",
      cmd : data
    }), data) : null;
  }, self.prototype._push = function(value) {
    if (!this._doing) {
      this.undoList.push(value);
      this.redoList.splice(0, this.redoList.length);
      this.app.events.dispatchEvent({
        type : "push"
      });
    }
  }, self.prototype.push = function(name) {
    this._push(name);
  }, self.prototype.redo = function() {
    if (0 != this.redoList.length) {
      this._doing = true;
      var item = this.redoList.pop();
      item.execute();
      this.undoList.push(item);
      this.app.events.dispatchEvent({
        type : "executeCommand",
        cmd : item
      });
      this.app.events.dispatchEvent({
        type : "redo",
        cmd : item
      });
      this._doing = false;
    }
  }, self.prototype.undo = function() {
    if (0 != this.undoList.length) {
      this._doing = true;
      var item = this.undoList.pop();
      item.undo();
      this.redoList.push(item);
      this.app.events.dispatchEvent({
        type : "executeCommand",
        cmd : item
      });
      this.app.events.dispatchEvent({
        type : "undo",
        cmd : item
      });
      this._doing = false;
    }
  }, self.prototype.getRedoCount = function() {
    return this.redoList.length;
  }, self.prototype.getUndoCount = function() {
    return this.undoList.length;
  }, self.prototype.toJson = function() {
    var layer_i = 0;
    for (; layer_i < this.undoList.length; layer_i++) {
      this.undoList[layer_i];
    }
    return "not impl~";
  }, self;
}();
zc = new THREE.Vector2, Vc = function() {
  function Renderer(options) {
    r(this, Renderer);
    this.app = options;
    this.events = options.events;
    this.baseURL = options.baseURL;
    this.scene = options.scene;
    this.renderer = options.renderer;
    this.objectManager = options.objectManager;
    this.resourceManager = options.resourceManager;
    this._background = null;
    this._backgroundResource = null;
    this._backgroundAdditiveColor = new THREE.Color(0, 0, 0);
    this._backgroundColorScaleFactor = new THREE.Vector3(1, 1, 1);
    this._skyBox = null;
    this._skyBoxResource = null;
    this._fogEnable = false;
    this._fogConfig = {};
    this._fogLinear = null;
    this._fogExp2 = null;
    this._enableDeafultViewPointFile = false;
    this._defaultViewPointFileName = "viewpoint.json";
    this.init();
  }
  return Renderer.prototype.init = function() {
    this.initRenderControl();
  }, Renderer.prototype.initRenderControl = function() {
    function update(props, object) {
      props.node.traverse(function(data) {
        if (data.material) {
          vec2.setFromMatrixPosition(object.matrixWorld);
          pos.setFromMatrixPosition(data.matrixWorld);
          var i = vec2.distanceTo(pos);
          if (props.renderDistance > 0) {
            data.visible = i < props.renderDistance;
          }
          if (props.shadowDistance > 0) {
            data.castShadow = i < props.shadowDistance;
          }
        }
      });
    }
    var vec2 = new THREE.Vector3;
    var pos = new THREE.Vector3;
    var pageViewData = this;
    this.app.scene.onBeforeRender = function() {
      var query = pageViewData.app.renderCamera;
      pageViewData.objectManager.renderDistanceObjects.forEach(function(updates) {
        update(updates, query);
      });
      pageViewData.objectManager.shadowDistanceObjects.forEach(function(updates) {
        update(updates, query);
      });
    };
  }, Renderer.prototype.synBackgroundColor = function() {
    var Plugin = this._skyBoxResource;
    if (Plugin && Plugin.isCubeTexture) {
      Plugin.colorMatrix = Plugin.colorMatrix || new THREE.Matrix4;
      var r = this._backgroundAdditiveColor;
      if (r) {
        var i = new THREE.Vector3(r.r, r.g, r.b);
        Plugin.colorMatrix.setPosition(i);
      }
      var forward3D = this._backgroundColorScaleFactor;
      if (forward3D) {
        var i = new THREE.Vector3(forward3D.x, forward3D.y, forward3D.z);
        Plugin.colorMatrix.setScale(i);
      }
    }
  }, Renderer.prototype._keepBackgroundAspect = function() {
    if (this._backgroundResource && this._backgroundResource.isTexture) {
      var e = this._backgroundResource;
      var screenUtil = this.app.renderer.getSize(zc);
      var w = screenUtil.width / screenUtil.height;
      var h = e.image.width / e.image.height;
      if (w > h) {
        e.offset.set(0, .5 - h / w * .5);
        e.repeat.set(1, h / w);
      } else {
        e.offset.set(.5 - w / h * .5, 0);
        e.repeat.set(w / h, 1);
      }
    }
  }, Renderer.prototype._resetBackgroundAspect = function() {
    if (this._backgroundResource && this._backgroundResource.isTexture) {
      var e = this._backgroundResource;
      e.offset.set(0, 0);
      e.repeat.set(1, 1);
    }
  }, Renderer.prototype.closeSkyEffect = function() {
    this.setSkyEffect(null);
  }, Renderer.prototype.setSkyEffect = function(name) {
    if (name) {
      if (!this._skyEffect) {
        this._skyEffect = this.app.create({
          type : "SkyEffect",
          parent : this.app.root
        });
      }
      this._skyEffect.setConfig(name);
      this._skyEffect.visible = true;
      if (this.app._lightGroup) {
        this.app._lightGroup.visible = !this._skyEffect.getConfig().light;
      }
    } else {
      if (this._skyEffect) {
        this._skyEffect.visible = false;
      }
      if (this.app._lightGroup) {
        this.app._lightGroup.visible = true;
      }
    }
  }, Renderer.prototype.setFogLinear = function(value, data, FAR) {
    value = Utils.parseColor(value);
    if (this._fogLinear) {
      this._fogLinear.color.set(value);
      this._fogLinear.near = data;
      this._fogLinear.far = FAR;
    } else {
      this._fogLinear = new THREE.Fog(value, data, FAR);
    }
    this.app.scene.fog = this._fogLinear;
  }, Renderer.prototype.clearFogLinear = function() {
    if (this._fogLinear) {
      this._fogLinear = null;
      this.app.scene.fog = null;
    }
  }, Renderer.prototype.setFogExp2 = function(value, oldFogDensity) {
    value = Utils.parseColor(value);
    if (this._fogExp2) {
      this._fogExp2.color.set(value);
      this._fogExp2.density = oldFogDensity;
    } else {
      this._fogExp2 = new THREE.FogExp2(value, oldFogDensity);
    }
    this.app.scene.fog = this._fogExp2;
  }, Renderer.prototype.clearFogExp2 = function() {
    if (this._fogExp2) {
      this._fogExp2 = null;
      this.app.scene.fog = null;
    }
  }, Renderer.prototype.closeFog = function() {
    this.clearFogLinear();
    this.clearFogExp2();
    this._fogEnable = false;
  }, Renderer.prototype.setFog = function(value) {
    value = value || {};
    this._fogConfig = Utils.mergeObject(this._fogConfig, value, true);
    var Type = value.type;
    var realVal = value.color || 8421504;
    if ("Exp2" == Type) {
      var clojIsReversed = value.density || .1;
      this.setFogExp2(realVal, clojIsReversed);
    } else {
      var falseySection = value.near || 10;
      var artistTrack = value.far || 100;
      this.setFogLinear(realVal, falseySection, artistTrack);
    }
    this._fogEnable = true;
    this.app.needUpdate = true;
  }, Renderer.prototype.onResize = function(size, width) {
    if (this._backgroundResource && this._backgroundResource.isCanvasTexture) {
      var x = this._backgroundResource;
      var r = size / width;
      var h = x.image.width / x.image.height;
      if (r < h) {
        x.offset.set(0, .5 - h / r * .5);
        x.repeat.set(1, h / r);
      } else {
        x.offset.set(.5 - r / h * .5, 0);
        x.repeat.set(r / h, 1);
      }
    }
  }, Renderer.prototype.onUpdate = function(parentBindings) {
    if (this._backgroundResource && this._backgroundResource.isCanvasTexture) {
      this._backgroundResource.needsUpdate = true;
    }
  }, Renderer.prototype.showLightHelper = function(canCreateDiscussions) {
    THING.Utils.warn("[SceneManager] Please use app.lighting={ showHelper: " + canCreateDiscussions + " } instead");
    this.app._lightGroup.setConfig({
      showHelper : canCreateDiscussions
    });
  }, Renderer.prototype.closeSceneLights = function() {
    THING.Utils.warn("[SceneManager] Please use app.lighting=null instead");
    this.app._lightGroup.setConfig(Bu);
  }, n(Renderer, [{
    key : "background",
    set : function(value) {
      var self = this;
      if (this.background != value) {
        if (this._skyBox = null, this._backgroundResource && this._backgroundResource.name != value && (this._backgroundResource.isTexture && this._backgroundResource.dispose(), this._backgroundResource = null), this._background = value, value) {
          var bgColor = Utils.parseColor(value, null);
          if (bgColor) {
            this.scene.background = bgColor;
            this._backgroundResource = bgColor;
          } else {
            if (Utils.isString(value)) {
              if (this._backgroundResource) {
                this.scene.background = this._backgroundResource;
              } else {
                var src = this.app.confirmURL(value);
                this.app.resourceManager.loadTexture(src, function(state) {
                  if (self._background == value) {
                    self.scene.background = state;
                    self._backgroundResource = state;
                    self._backgroundResource.name = value;
                    if (self.app.keepBackgroundAspect) {
                      self._keepBackgroundAspect();
                    } else {
                      self._resetBackgroundAspect();
                    }
                  }
                });
              }
            } else {
              if ("CANVAS" == value.tagName) {
                this._backgroundResource = new THREE.CanvasTexture(value);
                this._backgroundResource.needsUpdate = true;
                this.scene.background = this._backgroundResource;
                if (this.app.keepBackgroundAspect) {
                  this._keepBackgroundAspect();
                } else {
                  this._resetBackgroundAspect();
                }
              } else {
                if ("VIDEO" == value.tagName) {
                  this._backgroundResource = new THREE.VideoTexture(value);
                  this._backgroundResource.needsUpdate = true;
                  this.scene.background = this._backgroundResource;
                  if (this.app.keepBackgroundAspect) {
                    this._keepBackgroundAspect();
                  } else {
                    this._resetBackgroundAspect();
                  }
                }
              }
            }
          }
        } else {
          this.scene.background = Utils.parseColor(this.app._bgColor);
        }
        this.app.trigger("backgroundChanged", {
          background : value
        });
        if (Utils.isNumber(value) || value) {
          this.app.trigger("skyboxchange", {
            skyBox : null
          });
        }
      }
    },
    get : function() {
      return this._background;
    }
  }, {
    key : "backgroundAdditiveColor",
    set : function(v) {
      this._backgroundAdditiveColor = Utils.parseColor(v);
      this.synBackgroundColor();
    },
    get : function() {
      return this._backgroundAdditiveColor.toHexString();
    }
  }, {
    key : "backgroundColorScaleFactor",
    set : function(num) {
      this._backgroundColorScaleFactor = Utils.parseVector3(num);
      this.synBackgroundColor();
    },
    get : function() {
      return this._backgroundColorScaleFactor.toArray();
    }
  }, {
    key : "skyBox",
    set : function(name) {
      if (this.skyBox != name) {
        this._background = null;
        this._skyBox = name;
        this.app.trigger("skyboxchange", {
          skyBox : name
        });
        var noiseSynth = void 0;
        if (this._skyBoxResource) {
          if (this._skyBoxResource.name == name) {
            return void(this.scene.background = this._skyBoxResource);
          }
          noiseSynth = this._skyBoxResource;
        }
        var node = this;
        if (Utils.isString(name) && (name.indexOf(".png") > -1 || name.indexOf(".jpg") > -1)) {
          this.app.resourceManager.loadTexture(this.app.confirmURL(name), function(value) {
            if (node._skyBox == name) {
              node.scene.background = value;
              node._skyBoxResource = value;
              node._skyBoxResource.name = name;
              node.synBackgroundColor();
              if (noiseSynth) {
                noiseSynth.dispose();
              }
            }
          }, {
            mapping : THREE.EquirectangularReflectionMapping
          });
        } else {
          var r = this.app.confirmURL(Utils.parseCubeTextureUrls(name));
          if (r) {
            this.app.resourceManager.loadCubeTexture(r, function(texture) {
              if (node._skyBox == name) {
                texture.format = THREE.RGBAFormat;
                node.scene.background = texture;
                node._skyBoxResource = texture;
                node._skyBoxResource.name = name;
                node.synBackgroundColor();
                if (noiseSynth) {
                  noiseSynth.dispose();
                }
              }
            });
          } else {
            this.scene.background = Utils.parseColor(this.app._bgColor);
          }
        }
      }
    },
    get : function() {
      return this._skyBox;
    }
  }, {
    key : "enableDeafultViewPointFile",
    set : function(num) {
      this._enableDeafultViewPointFile = num;
    },
    get : function() {
      return this._enableDeafultViewPointFile;
    }
  }, {
    key : "defaultViewPointFileName",
    set : function(num) {
      this._defaultViewPointFileName = num;
    },
    get : function() {
      return this._defaultViewPointFileName;
    }
  }, {
    key : "fogEnable",
    get : function() {
      return this._fogEnable;
    }
  }, {
    key : "skyEffectEnable",
    get : function() {
      return !!this.sky;
    }
  }]), Renderer;
}();
function Wc(storage, options) {
  var currentValue = storage.get(options.key);
  if (currentValue) {
    if (currentValue.refCount && currentValue.refCount--, currentValue.refCount) {
      return false;
    }
    options.dispose();
    storage.delete(options.key);
  }
  return true;
}
var Gc = new THREE.Color;
var qc = new THREE.Vector3;
function Xc(name, texture) {
  Gc.setStyle(name);
  qc.set(Gc.r, Gc.g, Gc.b).multiplyScalar(255);
  if (void 0 === texture) {
    (texture = new THREE.DataTexture(new Uint8Array(16), 2, 2)).magFilter = texture.minFilter = THREE.NearestFilter;
  }
  var x = qc.x;
  var y = qc.y;
  var z = qc.z;
  return texture.image.data.set([x, y, z, 255, x, y, z, 255, x, y, z, 255, x, y, z, 255]), texture.needsUpdate = true, texture;
}
var Jc = function() {
  function init(App) {
    var i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    r(this, init);
    this.app = App;
    this._textures = new Map;
    this._cubeTextures = new Map;
    this._enableFileNameAsKey = i;
    this._textureLoader = new THREE.TextureLoader(this.app.loadingManager);
    this._cubeTextureLoader = new THREE.CubeTextureLoader;
    this._imageLoader = new THREE.ImageLoader;
  }
  return init.prototype.loadTexture = function(path, callback) {
    var options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    var id = arguments[3];
    var Model = this;
    var raw = arguments[4];
    var s = !(arguments.length > 5 && void 0 !== arguments[5]) || arguments[5];
    var item = path.getNormalize();
    var name = void 0;
    name = this._enableFileNameAsKey && !s ? item.getFileName(false) : item;
    if (options.repeat) {
      name = name + "_repeat";
    }
    if (options.anisotropy) {
      name = name + ("_a" + options.anisotropy);
    }
    if (options.mapping) {
      name = name + ("_m" + options.mapping);
    }
    if (false === options.flipY) {
      name = name + ("_y" + options.flipY);
    }
    if (options.premultiplyAlpha) {
      name = name + "_premultAlpha";
    }
    var data = this._textures.get(name);
    return data ? (data.refCount++, callback && (data.image ? Utils.timer.setTimeout(function() {
      return callback(data);
    }, 10) : (data.delayLoadCallbacks = data.delayLoadCallbacks || [], data.delayLoadCallbacks.push(callback)))) : ((data = this._textureLoader.load(item, function(texture) {
      var img = texture.image;
      if (options.repeat) {
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      }
      if (options.anisotropy) {
        texture.anisotropy = options.anisotropy;
      }
      if (options.mapping) {
        texture.mapping = options.mapping;
      }
      if (false === options.flipY) {
        texture.flipY = options.flipY;
      }
      if (options.premultiplyAlpha) {
        texture.premultiplyAlpha = options.premultiplyAlpha;
      }
      if (callback) {
        callback(texture);
      }
      var bitmap = texture.delayLoadCallbacks;
      if (bitmap) {
        bitmap.forEach(function(createScene) {
          return createScene(texture);
        });
        texture.delayLoadCallbacks = [];
      }
      var size = Model.app.options.maxTextureSize;
      if (img.width > size || img.height > size) {
        THING.Utils.warn("The '" + img.src + "' texture is too big(" + img.width + "x" + img.height + "), max size: (" + size + "x" + size + ")");
      }
    }, id, raw)).key = name, data.refCount = data.refCount || 1, this._textures.set(name, data)), data;
  }, init.prototype.loadCubeTexture = function(s, name) {
    var v = this.app.confirmURL(Utils.parseCubeTextureUrls(s));
    if (!v) {
      return null;
    }
    var tmp = v.toString();
    var t = this._cubeTextures.get(tmp);
    if (t) {
      t.refCount++;
      if (name) {
        if (t.version > 0) {
          Utils.timer.setTimeout(function() {
            return name(t);
          }, 10);
        } else {
          t.delayLoadCallbacks = t.delayLoadCallbacks || [];
          t.delayLoadCallbacks.push(name);
        }
      }
    } else {
      var start = function(a) {
        var result = a.image;
        if (result && 6 === result.length) {
          var width = result[0].width;
          var height = result[0].height;
          var i = 1;
          for (; i < result.length; i++) {
            var image = result[i];
            if (image.width != width || image.height != height) {
              return void THING.Utils.error("Load cube texture failed, due to image size is invalid, please make sure all size of images must be the same");
            }
          }
          if (name) {
            name(a);
          }
          var aType = a.delayLoadCallbacks;
          if (aType) {
            aType.forEach(function(callback) {
              return callback(a);
            });
            a.delayLoadCallbacks = [];
          }
        }
      };
      if (!function(s) {
        return s[1] === s[0] && s[2] === s[0] && s[3] === s[0] && s[4] === s[0] && s[5] === s[0];
      }(v)) {
        t = this._cubeTextureLoader.load(v, start);
      } else {
        t = new THREE.CubeTexture;
        this._imageLoader.load(v[0], function(newOffset) {
          t.images = [newOffset, newOffset, newOffset, newOffset, newOffset, newOffset];
          t.needsUpdate = true;
          start(t);
        });
      }
      t.key = tmp;
      t.refCount = t.refCount || 1;
      this._cubeTextures.set(tmp, t);
    }
    return t;
  }, init.prototype.loadTextureFromImage = function(val) {
    var data = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    var t = this._textures.get(val);
    return t ? t.refCount++ : ((t = new THREE.Texture).image = val, t.needsUpdate = true, t.key = val, t.refCount = 1, this._textures.set(val, t)), data.repeat && (t.wrapS = t.wrapT = THREE.RepeatWrapping), data.anisotropy && (t.anisotropy = data.anisotropy), data.mapping && (t.mapping = data.mapping), false === data.flipY && (t.flipY = data.flipY), data.premultiplyAlpha && (t.premultiplyAlpha = data.premultiplyAlpha), t;
  }, init.prototype.loadTextureFromColor = function(a) {
    var data = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    var t = this._textures.get(a);
    return t ? t.refCount++ : ((t = Xc(a)).key = a, t.refCount = 1, this._textures.set(a, t)), data.repeat && (t.wrapS = t.wrapT = THREE.RepeatWrapping), data.anisotropy && (t.anisotropy = data.anisotropy), data.mapping && (t.mapping = data.mapping), false === data.flipY && (t.flipY = data.flipY), data.premultiplyAlpha && (t.premultiplyAlpha = data.premultiplyAlpha), t;
  }, init.prototype.load = function(t, name, fn, raw) {
    var n = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    this.loadTexture(t, name, {}, fn, raw, n);
  }, init.prototype.removeTexture = function(proxy) {
    return !!Wc(this._textures, proxy) && (!!Wc(this._cubeTextures, proxy) && ((void 0 === proxy.refCount || !proxy.refCount || (proxy.refCount--, !proxy.refCount)) && (proxy.dispose(), true)));
  }, init.prototype.setCrossOrigin = function(crossOrigin) {
    return this._textureLoader.setCrossOrigin(crossOrigin), this._cubeTextureLoader.setCrossOrigin(crossOrigin), this;
  }, init.prototype.destroyTextureWithUrl = function(name, texture) {
    texture = texture || {};
    name = (name = this.app.confirmURL(name)).getNormalize();
    if (texture.repeat || void 0 === texture.repeat) {
      name = name + "_repeat";
    }
    if (texture.anisotropy) {
      name = name + ("_a" + texture.anisotropy);
    }
    if (texture.mapping) {
      name = name + ("_m" + texture.mapping);
    }
    if (false === texture.flipY) {
      name = name + ("_y" + texture.flipY);
    }
    if (texture.premultiplyAlpha) {
      name = name + "_premultAlpha";
    }
    var i = this._textures.get(name);
    if (i) {
      i.dispose();
      this._textures.delete(name);
    }
  }, n(init, [{
    key : "enableFileNameAsKey",
    set : function(num) {
      this._enableFileNameAsKey = num;
    },
    get : function() {
      return this._enableFileNameAsKey;
    }
  }, {
    key : "repetitionRate",
    get : function() {
      if (!this._textures.size) {
        return 0;
      }
      var bytesUploaded = 0;
      return this._textures.forEach(function(data) {
        bytesUploaded = bytesUploaded + data.refCount;
      }), bytesUploaded / this._textures.size - 1;
    }
  }]), init;
}();
Yc = function() {
  function self(value) {
    r(this, self);
    this.app = value;
    this._deadObjects = [];
    this.init();
    THING.DisposeObjectNumberInFrame = THING.DisposeObjectNumberInFrame || 100;
  }
  return self.prototype.init = function() {
    this.textureLoader = new Jc(this.app, this.app.options.enableTextureFileNameAsKey);
    this.textureLoader.setCrossOrigin("anonymous");
    this.app.loadingManager.loadingManager.addHandler(/.*(.jpg|.png)$/, this.textureLoader);
  }, self.prototype.disposeMaterial = function(material, texture) {
    return (void 0 === material.refCount || (material.refCount--, !material.refCount)) && (material.dispose(), texture || this.disposeTextures(material), true);
  }, self.prototype.disposeTextures = function(attr) {
    if (attr) {
      var j;
      for (j in attr) {
        var url = attr[j];
        if (url && url.isTexture && this.textureLoader.removeTexture(url)) {
          attr[j] = null;
        }
      }
    }
  }, self.prototype.disposeGeometry = function(obj) {
    if (void 0 !== obj.refCount) {
      if (obj.refCount--, obj.refCount) {
        return false;
      }
      obj.dispose();
    } else {
      if (this.app.scene.hasGeometry(obj)) {
        return false;
      }
      obj.dispose();
      obj._hasDisposed = true;
    }
    return true;
  }, self.prototype.doDispose = function(obj, item, i) {
    var node = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
    if (null !== obj) {
      if (i && false === i(obj)) {
        return false;
      }
      if (obj._skipDispose) {
        return this.app.picker.removePickingResources(obj), false;
      }
      if (node && obj.children) {
        var names = obj.children.concat();
        var index = 0;
        for (; index < names.length; index++) {
          var vm = this.doDispose(names[index], item, i);
          if (vm) {
            obj.remove(names[index]);
          }
        }
      }
      var target = obj.geometry;
      if (target && !obj.isSprite && this.disposeGeometry(target), obj.material) {
        var label = false;
        if (Utils.isArray(obj.material)) {
          var strings = obj.material.concat();
          obj.material = [];
          index = 0;
          for (; index < strings.length; index++) {
            var text = strings[index];
            label = this.disposeMaterial(text, item);
          }
        } else {
          label = this.disposeMaterial(obj.material, item);
        }
        if (label) {
          this.app.picker.removePickingResources(obj);
        }
      }
      if (obj.isSkinnedMesh) {
        if (!item) {
          this.disposeTextures(obj.skeleton);
        }
      }
    }
    return true;
  }, self.prototype.remove = function(s, o) {
    if (s) {
      s.removeBySelf();
      this.unload(s, o);
    }
  }, self.prototype.unload = function(fn, parent, body) {
    var r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
    var recursive = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
    if (fn) {
      if (fn.isObject3D) {
        if (r) {
          this._deadObjects.push({
            node : fn,
            keepTexture : parent,
            filterFunc : body,
            recursive : recursive
          });
        } else {
          this.doDispose(fn, parent, body, recursive);
        }
      } else {
        THING.Utils.error("must provide Object3D to unload");
      }
    }
  }, self.prototype.loadCubeTexture = function(url, name) {
    return this.textureLoader.loadCubeTexture(url, name);
  }, self.prototype.loadTexture = function(url, callback, path) {
    var results = null;
    return Utils.isString(url) ? results = this.textureLoader.loadTexture(url, callback, path) : (results = this.textureLoader.loadTextureFromImage(url), callback && callback(results)), results;
  }, self.prototype.onUpdate = function() {
    if (this._deadObjects.length) {
      var bt = Math.min(this._deadObjects.length, THING.DisposeObjectNumberInFrame || 1);
      var at = 0;
      for (; at < bt; at++) {
        var settings = this._deadObjects[0];
        this.doDispose(settings.node, settings.keepTexture, settings.filterFunc, settings.recursive);
        this._deadObjects.splice(0, 1);
      }
    }
  }, self;
}();
Qc = function() {
  function init(App) {
    r(this, init);
    this.app = App;
    var window = this;
    this.loadingManager = new THREE.LoadingManager(function() {
    }, function(dontForceConstraints, _num2, _num1) {
      if (0 != _num1) {
        window.app.mainUI.updateDownloadingProgress(_num2 / _num1);
      }
    }, function(maxRev) {
      THING.Utils.error("[onError] url: " + maxRev);
    });
    thingjs.GLTFLoader.defaultManager = this.loadingManager;
  }
  return init.prototype.itemStart = function(url) {
    this.loadingManager.itemStart(url);
  }, init.prototype.itemEnd = function(url) {
    this.loadingManager.itemEnd(url);
  }, init.prototype.itemError = function(t) {
    this.loadingManager.itemError(t);
  }, init.prototype.resolveURL = function(url) {
    return this.loadingManager.resolveURL(url);
  }, init.prototype.setURLModifier = function(args) {
    return this.loadingManager.setURLModifier(args);
  }, init.prototype.getHandler = function(name) {
    return this.loadingManager.getHandler(name);
  }, init;
}();
Zc = {
  temporalSuperSampling : {
    enable : false,
    size : 30
  },
  postEffect : {
    enable : true,
    bloom : {
      enable : false,
      strength : .14,
      radius : .4,
      threshold : .7
    },
    screenSpaceAmbientOcclusion : {
      enable : false,
      radius : .2,
      quality : "medium",
      intensity : .8,
      temporalFilter : true,
      ignoreTransparent : false
    },
    screenSpaceReflection : {
      enable : false,
      maxRayDistance : 200,
      pixelStride : 16,
      pixelStrideZCutoff : 50,
      screenEdgeFadeStart : .9,
      eyeFadeStart : .4,
      eyeFadeEnd : .8,
      minGlossiness : .2
    },
    colorCorrection : {
      enable : true,
      exposure : 0,
      brightness : 0,
      contrast : 1.1,
      saturation : 1.1,
      gamma : 1
    },
    dof : {
      enable : false,
      focalDepth : 1,
      focalLength : 24,
      fstop : .9,
      maxblur : 1,
      threshold : .9,
      gain : 1,
      bias : .5,
      dithering : 1e-4
    },
    vignette : {
      enable : false,
      type : "blur",
      color : 0,
      offset : 1.5
    },
    vignetting : {
      enable : false,
      color : 0,
      offset : 1.5
    },
    blurEdge : {
      enable : false,
      offset : 1.5
    },
    film : {
      enable : false,
      grayscale : false,
      noiseIntensity : .35,
      scanlinesIntensity : 0,
      scanlinesCount : 2048
    },
    RBSplit : {
      enable : false,
      offsetX : 2,
      offsetY : 2,
      power : 2
    },
    chromaticAberration : {
      enable : false,
      chromaFactor : .025
    },
    blur : {
      enable : false,
      radius : 5,
      bounds : [[0, 0, .5, .5], [.5, .5, 1, 1]]
    },
    FXAA : {
      enable : false
    },
    MSAA : {
      enable : true
    }
  }
};
Kc = function() {
  function app(callback, options) {
    r(this, app);
    this._manager = callback;
    this._defaultConfig = Utils.cloneObject(options, false);
    this._config = Utils.cloneObject(options, false);
  }
  return app.prototype.setConfig = function(data) {
    return this._config = Utils.cloneObject(data, false), this;
  }, app.prototype.getConfig = function() {
    return this._config;
  }, app.prototype.save = function() {
    return this._defaultConfig = Utils.cloneObject(this._config, false), this;
  }, app.prototype.mergeConfig = function(value) {
    return value = Utils.cloneObject(value, false), Utils.mergeObject(value, this._config), this._config = value, this;
  }, app.prototype.mergeWithSavedConfig = function(result) {
    return result = Utils.cloneObject(result, false), Utils.mergeObject(result, this._defaultConfig), this._config = result, this;
  }, app.prototype.lock = function() {
    return this._manager.lock(this), this;
  }, app.prototype.unlock = function() {
    return this._manager.unlock(this), this;
  }, app.prototype.update = function(path) {
    return this._manager._update(this, path), this;
  }, app.prototype.active = function(callback) {
    return this._manager._active(this, callback), this;
  }, app.prototype.destroy = function() {
    this._manager = null;
    this._config = null;
    this._defaultConfig = null;
  }, app;
}();
$c = function() {
  function o() {
    r(this, o);
    this._lockedControl = null;
    this._control = null;
  }
  return o.prototype.createControl = function(n) {
    return new Kc(this, n);
  }, o.prototype.lock = function(data) {
    this._lockedControl = data;
  }, o.prototype.unlock = function(val) {
    if (this._lockedControl === val) {
      this._lockedControl = null;
    }
  }, o.prototype.getActiveControl = function() {
    return this._control;
  }, o.prototype.getCurrentControl = function() {
    return this._lockedControl || this._control;
  }, o.prototype._active = function(event, opts) {
    return this._lockedControl !== event && (this._control = event), this._lockedControl || this._control;
  }, o.prototype._update = function(key, array) {
    var x = this.getCurrentControl();
    return x === key ? x : null;
  }, o.prototype.destroy = function() {
    this._lockedControl = null;
    this._control = null;
  }, o;
}();
var eh = new THREE.Vector2;
var th = new THREE.WebGLRenderTarget(4, 4);
th.texture.minFilter = THREE.NearestFilter, th.texture.magFilter = THREE.NearestFilter, th.texture.generateMipmaps = false;
var ih = new THREE.ShaderPass({
  name : "empty_shader",
  uniforms : {},
  vertexShader : "\n\t\tvoid main() {\n\t\t\tgl_Position = vec4(0., 0., 0., 1.);\n\t\t}\n\t",
  fragmentShader : "\n\t\tvoid main() {\n\t\t\tgl_FragColor = vec4(0., 0., 0., 0.);\n\t\t}\n\t"
});
rh = function(callback) {
  function init(data, n) {
    r(this, init);
    var self = s(this, callback.call(this));
    self.app = data;
    data.renderer.localClippingEnabled = true;
    var _entity$getData = data.renderer.getDrawingBufferSize(eh);
    var width = _entity$getData.width;
    var height = _entity$getData.height;
    return self._mainRenderer = new Xo(width, height, {
      stencil : n,
      maxSamples : data.renderer.capabilities.maxSamples
    }), self._mainRenderer.combineGlow = true, self._captureRenderTarget = new THREE.WebGLRenderTarget(width, height, {
      minFilter : THREE.LinearFilter,
      magFilter : THREE.LinearFilter,
      format : THREE.RGBAFormat
    }), self._captureBuffer = new Uint8Array(4 * width * height), self.autoDirty = false, self;
  }
  return o(init, callback), init.prototype.createControl = function(n) {
    return new nh(this, n);
  }, init.prototype._active = function(context) {
    var configOptions = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.app.root.box;
    context = callback.prototype._active.call(this, context);
    this._mainRenderer.setConfig(context._config, configOptions);
  }, init.prototype._update = function(array) {
    var configOptions = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.app.root.box;
    var that = callback.prototype._update.call(this, array);
    if (that) {
      this._mainRenderer.setConfig(that._config, configOptions);
    }
  }, init.prototype.update = function() {
    if (this.autoDirty) {
      this._mainRenderer.dirty();
    }
    if (this.app.renderer.capabilities.isWebGL2 && "iOS 8 and up" === Utils.system.getOSVersion().version) {
      ih.render(this.app.renderer, th);
    }
    this._mainRenderer.render(this.app.renderer, this.app.scene, this.app.renderCamera);
    var prev = this.app.cssScene;
    if (prev.children.length) {
      this.app.cssRenderer.render(prev, this.app.renderCamera);
    }
    this.app.picker.render(this.app.renderer);
  }, init.prototype.resize = function(h, w) {
    this.app.renderer.setSize(h, w);
    this.app.cssRenderer.setSize(h, w);
    var canvasOriginalSize = this.app.renderer.getDrawingBufferSize(eh);
    this._mainRenderer.setSize(canvasOriginalSize.width, canvasOriginalSize.height);
    this._resizeCaptureBuffer(h, w);
  }, init.prototype._resizeCaptureBuffer = function(x, y) {
    this._captureRenderTarget.setSize(x, y);
    var i = 4 * x * y;
    if (this._captureBuffer.length !== i) {
      this._captureBuffer = new Uint8Array(i);
    }
  }, init.prototype.capture = function(w, h) {
    var canvas = this.app.renderer.getSize(eh);
    w = w || canvas.width;
    h = h || canvas.height;
    this._mainRenderer.setSize(w, h);
    this.app.renderCamera.setSize(w, h);
    this._resizeCaptureBuffer(w, h);
    var enable = this.app.renderEffects.getConfig().postEffect.blur.enable;
    return this.app.postEffect = {
      postEffect : {
        blur : {
          enable : false
        }
      }
    }, this._mainRenderer.render(this.app.renderer, this.app.scene, this.app.renderCamera, this._captureRenderTarget), this.app.renderer.readRenderTargetPixels(this._captureRenderTarget, 0, 0, this._captureRenderTarget.width, this._captureRenderTarget.height, this._captureBuffer), function f(data, width, height, count) {
      if (Array.isArray(data)) {
        var result = f(new Float64Array(data), width, height, count);
        var i = 0;
        for (; i < data.length; i++) {
          data[i] = result[i];
        }
        return data;
      }
      if (!width || !height) {
        throw Error("Bad dimensions");
      }
      if (!count) {
        count = data.length / (width * height);
      }
      var requiredLength = height >> 1;
      var len = width * count;
      var result = new (0, data.constructor)(width * count);
      var size = 0;
      for (; size < requiredLength; ++size) {
        var start = size * len;
        var pos = (height - size - 1) * len;
        result.set(data.subarray(start, start + len));
        data.copyWithin(start, pos, pos + len);
        data.set(result, pos);
      }
      return data;
    }(this._captureBuffer, this._captureRenderTarget.width, this._captureRenderTarget.height), this._mainRenderer.setSize(canvas.width, canvas.height), this.app.renderCamera.setSize(canvas.width, canvas.height), this.app.postEffect = {
      postEffect : {
        blur : {
          enable : enable
        }
      }
    }, this._captureBuffer;
  }, init.prototype.captureToDataURL = function(size, height) {
    var type = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "jpeg";
    var quality = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
    var key = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    var self = this.app.renderer.getSize(eh);
    size = size || self.width;
    height = height || self.height;
    var arr = this.capture(size, height);
    var result = new Uint8ClampedArray(arr.buffer);
    var canvas = document.createElement("canvas");
    var gCtx = canvas.getContext("2d");
    canvas.width = size;
    canvas.height = height;
    var imageData = gCtx.createImageData(size, height);
    imageData.data.set(result);
    gCtx.putImageData(imageData, 0, 0);
    if ("jpg" == type) {
      type = "jpeg";
    }
    var mime = "image/" + (type.isBlank() ? "jpeg" : type);
    var data = canvas.toDataURL(mime, quality);
    return key && (data = data.replace(mime, "image/octet-stream")), data;
  }, init.prototype.replaceRenderer = function(renderer) {
    THING.Utils.warn("[RendererManager] replaceRenderer has been DEPRECATED!");
    this._mainRenderer = renderer;
    this._mainRenderer.setConfig(this.getCurrentControl()._config);
  }, init.prototype.closePostEffect = function() {
    THING.Utils.warn("[RendererManager] Please use app.postEffect={} instead");
    this.app.renderEffects.mergeConfig({
      postEffect : {
        enable : false
      }
    }).update();
  }, n(init, [{
    key : "needUpdate",
    set : function(num) {
      if (num) {
        this._mainRenderer.dirty();
      }
    }
  }, {
    key : "mainRenderer",
    get : function() {
      return this._mainRenderer;
    }
  }, {
    key : "renderOutline",
    set : function(num) {
      THING.Utils.warn("[RendererManager] renderOutline has been DEPRECATED!");
    }
  }, {
    key : "temporalSuperSampling",
    set : function(options) {
      THING.Utils.warn("[RendererManager] Please use app.postEffect={} instead");
      this.app.renderEffects.mergeConfig({
        temporalSuperSampling : {
          enable : options
        }
      }).update();
    },
    get : function() {
      return THING.Utils.warn("[RendererManager] Please use app.postEffect instead"), this.app.renderEffects.getConfig().temporalSuperSampling.enable;
    }
  }, {
    key : "SSAO",
    set : function(options) {
      THING.Utils.warn("[RendererManager] Please use app.postEffect={} instead");
      this.app.renderEffects.mergeConfig({
        postEffect : {
          screenSpaceAmbientOcclusion : {
            enable : options
          }
        }
      }).update();
    },
    get : function() {
      return THING.Utils.warn("[RendererManager] Please use app.postEffect instead"), this.app.renderEffects.getConfig().postEffect.screenSpaceAmbientOcclusion.enable;
    }
  }, {
    key : "postEffectEnable",
    get : function() {
      return THING.Utils.warn("[RendererManager] Please use app.postEffect instead"), this.app.renderEffects.getConfig().postEffect.enable;
    }
  }]), init;
}($c);
nh = function(e) {
  function t(row) {
    var end = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Zc;
    return r(this, t), s(this, e.call(this, row, end));
  }
  return o(t, e), t;
}(Kc);
oh = b.toStr([120, 211, 159]);
sh = function() {
  function step(value) {
    r(this, step);
    this.app = value;
    this.xmlhttp = null;
    this.time = 1500;
    this.simulate = true;
    this.url = "";
    this.cache = true;
    this._stop = false;
    this._curInterval = null;
    this.callback = null;
  }
  return step.prototype.start = function(options) {
    if (this._stop = false, this.url = null, null != options && (null != options.interval && (this.time = options.interval), null != options.url && (this.url = options.url), null != options.simulate && (this.simulate = options.simulate), null != options.cache && (this.cache = options.cache), null != options.callback && (this.callback = options.callback)), null == this.url || 1 == this.simulate) {
      var url = parent.getUserPath();
      if (!url) {
        return void THING.Utils.log("Service Data Path Error");
      }
      this.url = url;
    }
    this._ajax();
    THING.Utils.log("Service startup complete");
  }, step.prototype.stop = function() {
    this._stop = true;
    if (null != this._curInterval) {
      window.clearTimeout(this._curInterval);
    }
    THING.Utils.log("Service stop complete");
  }, step.prototype._ajax = function() {
    function get() {
      if (4 == self.xmlhttp.readyState) {
        if (200 == self.xmlhttp.status) {
          !function(len) {
            var i = null;
            i = 1 == Array.isArray(len) ? len[0] : len;
            var r;
            for (r in i) {
              var root = self.app.query(r);
              if (root.length > 0) {
                var o = i[r];
                var prop;
                for (prop in o) {
                  root[0].attr(prop, o[prop]);
                }
              }
            }
          }(JSON.parse(self.xmlhttp.responseText));
          if (null != self.callback) {
            self.callback(self.xmlhttp.getResponseHeader("last-modified"));
          }
        } else {
          THING.Utils.log("Problem retrieving XML data:" + self.xmlhttp.statusText);
        }
        if (0 == self._stop) {
          self._curInterval = window.setTimeout(function() {
            self._ajax();
          }, self.time);
        }
      }
    }
    var myUrl;
    var self = this;
    myUrl = self.url;
    self.xmlhttp = null;
    if (window.XMLHttpRequest) {
      self.xmlhttp = new XMLHttpRequest;
    }
    if (null != self.xmlhttp) {
      self.xmlhttp.onreadystatechange = get;
      if (0 == self.cache) {
        myUrl = -1 == myUrl.lastIndexOf("?") ? myUrl + "?time=" + (new Date).getTime() : myUrl + "&time=" + (new Date).getTime();
      }
      self.xmlhttp.open(oh, myUrl, true);
      self.xmlhttp.send(null);
    } else {
      THING.Utils.error("Your browser does not support XMLHTTP.");
    }
  }, step;
}();
ah = function() {
  function self(value) {
    r(this, self);
    this.app = value;
    this.viewPointList = [];
    this.timeoutNumer = null;
    this._flyCallback = null;
    this._playIndex = 0;
    this.playLoop = false;
    this._pickedObjects = new Set;
  }
  return self.prototype.start = function() {
    var TrackSearchIndex = this;
    this.app.on(EventType.Pick, function(t) {
      TrackSearchIndex._pickedObjects.add(t.object);
    });
  }, self.prototype.create = function(data, a) {
    if (null == data) {
      data = {
        name : "newViewPoint"
      };
    }
    if (null == data.flyTime) {
      data.flyTime = 1e3;
    } else {
      if ("string" == typeof data.flyTime) {
        data.flyTime = Number(data.flyTime);
      }
    }
    if (null == data.waitTime) {
      data.waitTime = 0;
    } else {
      if ("string" == typeof data.waitTime) {
        data.waitTime = Number(data.waitTime);
      }
    }
    var removed = this._take(data);
    if (null == a) {
      this.viewPointList.push(removed);
    } else {
      this.viewPointList.splice(a, 0, removed);
    }
  }, self.prototype.delete = function(s) {
    if (s >= 0 && s < this.viewPointList.length) {
      this.viewPointList.splice(s, 1);
    }
  }, self.prototype.recover = function(n) {
    try {
      var me = this;
      var data = this.viewPointList[n];
      var done = null;
      if (null != data.events) {
        done = function() {
          var e = data.events;
          var i = 0;
          for (; i < e.length; i++) {
            var m = e[i];
            var signals = me.app.query("#" + m.id);
            if (signals.length > 0) {
              var i = 0;
              for (; i < m.event.length; i++) {
                signals[0].dispatch(m.event[i]);
              }
            }
          }
        };
      }
      if (0 != data.waitTime) {
        if (null != me.timeoutNumer) {
          clearTimeout(me.timeoutNumer);
        }
        this.timeoutNumer = setTimeout(function() {
          me._fly(data, done);
          me.timeoutNumer = null;
        }, data.waitTime);
      } else {
        this._fly(data, done);
      }
    } catch (e) {
      THING.Utils.log(e);
    }
  }, self.prototype.update = function(type, data, types) {
    if (null != type) {
      if (null == data) {
        data = {};
      }
      if ("string" == typeof data.flyTime) {
        data.flyTime = Number(data.flyTime);
      }
      if ("string" == typeof data.waitTime) {
        data.waitTime = Number(data.waitTime);
      }
      var options = {};
      return types ? options = this._take(data, type) : (options = this.viewPointList[type], null != data.flyTime && (options.flyTime = data.flyTime), null != data.waitTime && (options.waitTime = data.waitTime), null != data.flyTime && (options.name = data.name)), this.viewPointList[type] = options, options;
    }
  }, self.prototype.play = function(item) {
    if (null != item) {
      this.playLoop = item;
    }
    this._playIndex = 0;
    this._flyCallback = null;
    if (this.viewPointList.length > 0) {
      this._next();
    }
  }, self.prototype.pause = function(res) {
    if (void 0 === res) {
      res = true;
    }
    if (res) {
      if (null != this.timeoutNumer) {
        clearTimeout(this.timeoutNumer);
      }
      if (this.app.camera.flying) {
        this.app.camera.stopFlying();
      }
    } else {
      if (this.viewPointList.length > 0) {
        this._next();
      }
    }
  }, self.prototype.swap = function(i, n) {
    var t = this.viewPointList[i][i];
    return this.viewPointList[i][i] = this.viewPointList[i][n], this.viewPointList[i][n] = t, this.viewPointList[i];
  }, self.prototype.stop = function() {
    if (null != this.timeoutNumer) {
      clearTimeout(this.timeoutNumer);
    }
    if (this.app.camera.flying) {
      this.app.camera.stopFlying();
    }
    this._flyCallback = null;
    this._pickedObjects.clear();
  }, self.prototype.saveJSON = function() {
    var e = {
      name : "viewPointAnimation",
      pointList : this.viewPointList
    };
    return JSON.stringify(e);
  }, self.prototype.loadJSON = function(name) {
    var config = name;
    if ("string" == typeof name) {
      config = JSON.parse(name);
    }
    if (null != config.pointList) {
      this.viewPointList = config.pointList;
    }
  }, self.prototype.clearAll = function() {
    stop();
    this.viewPointList = [];
  }, self.prototype._take = function(data, name) {
    var self = {};
    if (null != name) {
      self = this.viewPointList[name];
    }
    if (null != data.flyTime) {
      self.flyTime = data.flyTime;
    }
    if (null != data.waitTime) {
      self.waitTime = data.waitTime;
    }
    if (null != data.name) {
      self.name = data.name;
    }
    self.position = this.app.camera.position;
    self.target = this.app.camera.target;
    self.up = this.app.camera.up;
    self.image = this.app.captureScreenshotToImage(140, 118, "jpeg", .1);
    var out = this._getPickedEvents();
    return out.length > 0 && (self.events = out), self;
  }, self.prototype._getPickedEvents = function() {
    var successLogBuffer = [];
    var patches = this._pickedObjects;
    var i = 0;
    var patchLen = patches.length;
    for (; i < patchLen; i++) {
      var instance = patches[i];
      if (instance) {
        var message = {
          id : instance.id,
          event : []
        };
        if (instance.hasEvent("click")) {
          message.event.push("click");
        }
        if (instance.hasEvent("singleclick")) {
          message.event.push("singleclick");
        }
        if (0 != message.event.length) {
          successLogBuffer.push(message);
        }
      }
    }
    return this._pickedObjects.clear(), successLogBuffer;
  }, self.prototype._fly = function(event, callback) {
    var plugin = this;
    var options = {
      position : event.position,
      target : event.target,
      time : event.flyTime,
      complete : function(type) {
        if (null != callback) {
          callback();
        }
        if (null != plugin._flyCallback) {
          plugin._flyCallback();
        }
      }
    };
    if (event.up) {
      options.up = event.up;
    }
    plugin.app.camera.flyTo(options);
  }, self.prototype._next = function() {
    var taskQueueEnd = this;
    if (this._playIndex > this.viewPointList.length - 1) {
      if (0 == this.playLoop) {
        return void(this._flyCallback = null);
      }
      this.play();
    }
    this._flyCallback = function() {
      taskQueueEnd._playIndex += 1;
      taskQueueEnd._next();
    };
    this.recover(this._playIndex);
  }, self;
}();
lh = function() {
  function t(app) {
    r(this, t);
    this.app = app;
    this._modelBaseURL = "https://model.3dmomoda.com/models/";
  }
  return t.prototype.initOptions = function(options) {
    this.app.resourceManager.textureLoader;
  }, t.prototype.parseDoorOrWindow = function(el, t, code) {
    function init(parentNode, data) {
      var self = pageViewData.app.objectManager.create({
        type : "Door",
        id : data.id,
        name : data.name,
        node : data.mesh,
        parent : parentNode,
        animations : data.resource.animations,
        properties : data.properties
      });
      if (data.isOpen && self.open(), self.animationClips) {
        var i = 0;
        for (; i < self.animationClips.length; i++) {
          var adoc = self.animationClips[i];
          if ("_defaultAnim_" === adoc.name) {
            self.playAnimation({
              name : adoc.name,
              loop : true,
              speed : .15
            });
            break;
          }
        }
      }
      return self;
    }
    var pageViewData = this;
    if (t.mesh) {
      init();
    } else {
      t.registerBuildCallbackListener(function(config) {
        var ret = init(el, config);
        el.miscNode.add(ret.node);
      });
    }
  }, t.prototype.parseWall = function(myInputEl, vpd, params) {
    var i = 0;
    for (; i < vpd.doorOrWindows.length; i++) {
      var unloadedImgElement = vpd.doorOrWindows[i];
      this.parseDoorOrWindow(myInputEl, unloadedImgElement, params);
    }
  }, t.prototype.parseGroups = function(stack, data, items) {
    var tmpKeys = data.typeToChildren.PlacementGroup;
    if (!tmpKeys) {
      tmpKeys = [];
    }
    var i = 0;
    for (; i < tmpKeys.length; i++) {
      var o = tmpKeys[i];
      var n_type = "Thing";
      if (o.jsonData && o.jsonData.type) {
        n_type = o.jsonData.type;
      }
      this.app.objectManager.create({
        id : o.id,
        name : o.name,
        node : o.mesh,
        type : n_type,
        parent : stack,
        properties : o.properties
      });
    }
  }, t.prototype.parsePlacements = function(dir, url, target) {
    var rels = url.typeToChildren.Placement;
    if (!rels) {
      rels = [];
    }
    var i = 0;
    for (; i < rels.length; i++) {
      var self = rels[i];
      var n_type = "Thing";
      if (self.jsonData && self.jsonData.type && (n_type = self.jsonData.type), self.mesh) {
        var gui = this.app.objectManager.create({
          id : self.id,
          type : n_type,
          name : self.name,
          node : self.mesh,
          parent : dir,
          url : self.resource.getModelUrl(),
          animations : self.resource.animations,
          properties : self.properties
        });
        if (gui.bundleID = self.resource.modelID, gui.bundleName = self.resource.modelName, self.isPlayAnim && gui.containAnimation(self.animClip)) {
          var params = {
            name : self.animClip,
            loop : false,
            speed : .15
          };
          if (self.hasSkin) {
            params.loop = true;
          }
          gui.playAnimation(params);
        }
      }
    }
  }, t.prototype.parseRooms = function(input, url, target) {
    var affectedData = url.typeToChildren.Room;
    if (!affectedData) {
      affectedData = [];
    }
    var j = 0;
    for (; j < affectedData.length; j++) {
      var data = affectedData[j];
      if (data.ceiling.mesh) {
        data.mesh.add(data.ceiling.mesh);
      }
      if (data.roof.mesh) {
        data.mesh.add(data.roof.mesh);
      }
      if (data.floor.mesh) {
        data.mesh.add(data.floor.mesh);
      }
      this.app.objectManager.create({
        type : "Room",
        name : data.name,
        node : data.mesh,
        id : data.userID,
        ceilingNode : data.ceiling.mesh,
        roofNode : data.roof.mesh,
        floorNode : data.floor.mesh,
        parent : input,
        properties : data.properties
      });
    }
  }, t.prototype.createCombinedObject = function(query, object, i) {
    var chunk = new THREE.Object3D(object);
    var action = this.app.create({
      type : "CombinedObject",
      visible : true,
      node : chunk,
      parent : query
    });
    return action.node.visible = false, action.userData.type = i, action;
  }, t.prototype.parsePlan = function(el, t, arr1) {
    var object = this.createCombinedObject(el, "combineFloor", "CombineFloorParent").node;
    var args = this._getTypeChildren(t, "CombineFloor");
    var i = 0;
    for (; i < args.length; i++) {
      var room = args[i];
      object.add(room.mesh);
    }
    var self = this.createCombinedObject(el, "combineCeiling", "CombineCeilingParent").node;
    var row = this._getTypeChildren(t, "CombineCeiling");
    i = 0;
    for (; i < row.length; i++) {
      var tile = row[i];
      self.add(tile.mesh);
    }
    var g = this.createCombinedObject(el, "combineRoof", "CombineRoofParent").node;
    var bars = this._getTypeChildren(t, "CombineRoof");
    i = 0;
    for (; i < bars.length; i++) {
      var b = bars[i];
      g.add(b.mesh);
    }
    var parent = this.createCombinedObject(el, "combinePlacement", "CombineMiscParent").node;
    var regexroutes = this._getTypeChildren(t, "CombinePlacement");
    i = 0;
    for (; i < regexroutes.length; i++) {
      var obj = regexroutes[i];
      parent.add(obj.mesh);
    }
    var scene = this.createCombinedObject(el, "combineWall", "CombineWallParent").node;
    var filter = this._getTypeChildren(t, "CombineStraightManualWall");
    var j = 0;
    for (; j < filter.length; j++) {
      var item = filter[j];
      scene.add(item.mesh);
    }
    var v = this._getTypeChildren(t, "CombineModelWall");
    j = 0;
    for (; j < v.length; j++) {
      item = v[j];
      scene.add(item.mesh);
    }
    var m = this._getTypeChildren(t, "CombineDoorOrWindow");
    j = 0;
    for (; j < m.length; j++) {
      obj = m[j];
      scene.add(obj.mesh);
    }
  }, t.prototype.parseFloor = function(path, point, result) {
    var nameArgs = this._getTypeChildren(point, "Building")[0];
    var cdn_url = this._getTypeChildren(nameArgs, "FloorPlan")[0];
    this.parsePlan(path, cdn_url, result);
    this.parseGroups(path, cdn_url, result);
    this.parsePlacements(path, cdn_url, result);
    this.parseRooms(path, cdn_url, result);
    var crossfilterable_layers = this._getTypeChildren(cdn_url, "DoorOrWindow");
    var layer_i = 0;
    for (; layer_i < crossfilterable_layers.length; layer_i++) {
      var nameArgs = crossfilterable_layers[layer_i];
      this.parseDoorOrWindow(path, nameArgs, result);
    }
  }, t.prototype._generateWindow = function(data, instance) {
    var i = void 0 !== data.typeId ? data.typeId : "15DA293545E84A3680F93CF7D4227BD9";
    this.app.create({
      type : "Door",
      name : data.key,
      url : this._modelBaseURL + i + "/0/gltf/",
      localPosition : [.01 * data.pos[0], data.suspendpercent * (data._wallHeight || 3), .01 * data.pos[1]],
      parent : instance,
      complete : function() {
        var top = this.boundingBox.initSize;
        this.scale = [data.size[0] / top[0], data.size[1] / top[1], data.size[2] / top[2]];
        this.angles = [0, 180 - data.rotation, 0];
        scope._settingDoorOpenDirection(this, data.diridx);
      }
    });
  }, t.prototype._generateDoor = function(e, t) {
    var w2utils = this;
    var r = void 0 !== e.typeId ? e.typeId : "d8ff0aaa4e87439bbededc8c6590491c";
    this.app.create({
      type : "Door",
      name : e.key,
      url : this._modelBaseURL + r + "/0/gltf/",
      localPosition : [.01 * e.pos[0], e.suspendpercent * (e._wallHeight || 3), .01 * e.pos[1]],
      parent : t,
      complete : function() {
        var top = this.boundingBox.initSize;
        this.scale = [e.size[0] / top[0], e.size[1] / top[1], e.size[2] / top[2]];
        this.angles = [0, 180 - e.rotation, 0];
        w2utils._settingDoorOpenDirection(this, e.diridx);
      }
    });
  }, t.prototype.parseDoorsAndWindows = function(template, map, coordTool) {
    var controller = this;
    map.doors.forEach(function(j) {
      var classNameParts = j.key.split("_");
      if (classNameParts.length) {
        if ("window" == classNameParts[0]) {
          controller._generateWindow(j, template);
        } else {
          controller._generateDoor(j, template);
        }
      }
    });
  }, t.prototype.load = function(obj, name, fileName) {
    name = this.app.confirmURL(name);
    var tree = this;
    (new THREE.FileLoader(this.app.loadingManager)).load(name + "/scene.json", function(t) {
      var data = JSON.parse(t);
      tree.loadFromData(obj, data, fileName);
    });
  }, t.prototype.loadFromData = function(data, xhr, options) {
    var util = this;
    options = options || {};
    this.initOptions(options);
    var val = function(obj, types) {
      var data = {
        version : "2",
        unit : types = types || 1,
        walls : [],
        rooms : [],
        doors : [],
        textures : [],
        models : []
      };
      var config = obj.structure;
      return data.textures = obj.textures, data.models = obj.models, data.walls = config.walls.map(function(opts) {
        var size = opts.textureSize;
        if (void 0 === opts.sourceType) {
          var options = {
            weight : opts.thickness,
            start : [100 * opts.points[0], 100 * opts.points[1]],
            end : [100 * opts.points[2], 100 * opts.points[3]],
            height : opts.height,
            type : 0,
            lefttexture : 0,
            righttexture : 0,
            edgetexture : 1
          };
          return size && (options.uvmultiple = size), options;
        }
        var options = {
          weight : opts.thickness,
          start : [100 * opts.points[0], 100 * opts.points[1]],
          end : [100 * opts.points[2], 100 * opts.points[3]],
          height : opts.height,
          type : opts.sourceType,
          lefttexture : opts.lefttexture,
          righttexture : opts.righttexture,
          edgetexture : opts.edgetexture
        };
        return size && (options.uvmultiple = size), false === opts.visible && (options.isshow = false), 0 != opts.sourceType && (options.model = opts.model), options;
      }), data.rooms = config.rooms.map(function(data) {
        var DEFAULT_CENTER = [100 * data.textLoc[0], 100 * data.textLoc[1]];
        var file = {
          id : data.key,
          name : data.name,
          points : [],
          holes : [],
          center : DEFAULT_CENTER,
          floortexture : data.floorTexture,
          floorblocksize : data.floorBlockSize,
          floorheight : data.floorHeight,
          floorblockangle : data.floorBlockAngle,
          rooftexture : data.roofTexture,
          roofblocksize : data.roofBlockSize,
          roofheight : data.roofHeight,
          roofblockangle : data.roofBlockAngle,
          ceilingtexture : data.ceilingTexture,
          ceilingblocksize : data.ceilingBlockSize,
          ceilingheight : data.ceilingHeight,
          ceilingblockangle : data.ceilingBlockAngle
        };
        if (data.userData) {
          if (Object.keys(data.userData).length) {
            file.properties = data.userData;
          }
        }
        return void 0 !== data.userId && (file.userid = data.userId), false === data.floorVisible && (file.isshowfloor = false), false === data.ceilingVisible && (file.isshowceiling = false), false === data.roofVisible && (file.isshowroof = false), data.polygons.forEach(function(inRevIdx, thumb) {
          var r = 0 === thumb ? file.points : [];
          var n = 0;
          for (; n < inRevIdx.length / 2; n++) {
            r.push([100 * inRevIdx[2 * n + 0], 100 * inRevIdx[2 * n + 1]]);
          }
          if (0 !== thumb) {
            file.holes.push(r);
          }
        }), file;
      }), config.doors.forEach(function(self) {
        var args = config.walls[self.wallIndex];
        self.loc;
        var value = [args.points[0], args.points[1]];
        var m = [args.points[2], args.points[3]];
        var spotPos = [100 * (value[0] + (m[0] - value[0]) * self.loc), 100 * (value[1] + (m[1] - value[1]) * self.loc)];
        var $routeParams = data.models[self.typeIndex];
        var l = self.openingDirection || 0;
        var info = {
          key : "door_" + self.key,
          typeId : $routeParams.id,
          width : 100 * self.size[0],
          height : 100 * self.size[1],
          size : self.size,
          suspendpercent : null == self.locV ? .4 : self.locV,
          pos : spotPos,
          rotation : ch(args),
          diridx : l
        };
        info._wallHeight = args.height;
        data.doors.push(info);
      }), config.windows.forEach(function(self) {
        var args = config.walls[self.wallIndex];
        var value = [args.points[0], args.points[1]];
        var m = [args.points[2], args.points[3]];
        var spotPos = [100 * (value[0] + (m[0] - value[0]) * self.loc), 100 * (value[1] + (m[1] - value[1]) * self.loc)];
        var $routeParams = data.models[self.typeIndex];
        var l = self.openingDirection || 0;
        var info = {
          key : "window" + self.key,
          typeId : $routeParams.id,
          width : 100 * self.size[0],
          height : 100 * self.size[1],
          size : self.size,
          suspendpercent : null == self.locV ? .4 : self.locV,
          pos : spotPos,
          rotation : ch(args),
          diridx : l
        };
        info._wallHeight = args.height;
        data.doors.push(info);
      }), data;
    }(xhr, 1);
    var complete = options.complete;
    var model = options.startLoadResource;
    json2mesh.DefaultSetting.enableFloorLightMap = Utils.parseValue(options.enableFloorLightMap, false);
    var self = this._createLoader(val.version);
    var feature = void 0;
    self.load({
      json : val
    }).then(function(featureId) {
      feature = featureId;
      if (model) {
        model(self.resourceManager.models, self.resourceManager.textures);
      }
    }).then(function() {
      return self.loadResources();
    }).then(function() {
      util.parseFloor(data, feature, options);
      util.parseDoorsAndWindows(data, val, options);
    }).then(function() {
      if (complete) {
        complete(data);
      }
    }).catch(function(type) {
      return THING.Utils.warn(type);
    });
  }, t.prototype._createLoader = function(a) {
    if (a && (new Zi(a)).major >= 2) {
      return new json2mesh.ThingjsEditorSceneLoader_2_0(this.app.options);
    }
    return new json2mesh.ThingjsEditorSceneLoader;
  }, t.prototype._getTypeChildren = function(t, text) {
    var e = t.typeToChildren[text];
    return e || (e = []), e;
  }, t.prototype._settingDoorOpenDirection = function(module, data) {
    var object = module.node.getObjectByName("Controller");
    var ring = module.node.getObjectByName("RootNode");
    var audio = module.animationNames && module.animationNames.length;
    var video = false;
    if (!(!object || object.getObjectByName("LeftPiovt") && object.getObjectByName("RightPiovt"))) {
      video = true;
    }
    if (!(video || audio || object)) {
      ring.rotateY(Math.PI);
    }
    if (video) {
      if (1 == data) {
        ring.scale.set(-1, 1, 1);
      } else {
        if (2 == data) {
          ring.scale.set(1, 1, -1);
        } else {
          if (3 == data) {
            ring.scale.set(-1, 1, -1);
          } else {
            ring.scale.set(1, 1, 1);
          }
        }
      }
    } else {
      if (1 == data) {
        ring.scale.set(-1, 1, -1);
      } else {
        ring.scale.set(1, 1, 1);
      }
    }
  }, t;
}();
uh = new THREE.Vector2;
function ch(c) {
  return uh.set(c.points[0] - c.points[2], c.points[1] - c.points[3]), uh.angle() / Math.PI * 180;
}
var hh = function() {
  function o(value) {
    r(this, o);
    this.app = value;
    this._loading = false;
    this._updateTime = 0;
    this._loadingFloors = [];
    this._initEvents();
  }
  return o.prototype._initEvents = function() {
    var damas = this;
    this.app.on("levelchange", function(_props) {
      var container = _props.current;
      if (container instanceof dl) {
        damas._loadingFloors.sort(function(chara, t) {
          return chara.owner.parent != container ? 1 : t.owner.parent != container ? -1 : chara.owner.indexOfBuilding - t.owner.indexOfBuilding;
        });
      } else {
        if (container instanceof is) {
          damas._loadingFloors.sort(function(event, me) {
            return event.owner == container ? -1 : me.owner == container ? 1 : event.owner.node.id - me.owner.node.id;
          });
        }
      }
    });
  }, o.prototype.update = function() {
    if (this._loadingFloors.length && !(this._loading || (this._updateTime += this.app._deltaTime, this._updateTime < .25))) {
      this._updateTime = 0;
      var o = this._loadingFloors[0];
      var b = o.owner;
      var i = o.url;
      var json = o.jsonData;
      var options = o.options;
      var self = this;
      var callback = options.complete;
      options.complete = function(v) {
        if (callback) {
          callback(v);
        }
        self._loading = false;
      };
      this._loading = true;
      var controller = new lh(this.app);
      if (i) {
        controller.load(b, i, options);
      } else {
        controller.loadFromData(b, json, options);
      }
      this._loadingFloors.splice(0, 1);
    }
  }, o.prototype.load = function(name, id, object) {
    this._loadingFloors.push({
      owner : name,
      url : id,
      options : object
    });
  }, o.prototype.loadFromData = function(component, data, defaults) {
    this._loadingFloors.push({
      owner : component,
      jsonData : data,
      options : defaults
    });
  }, o.prototype.onUpdate = function(e) {
    this.update(e);
  }, o;
}();
ph = function(handshake) {
  THREE.ShaderMaterial.call(this, {
    uniforms : {
      baseId : {
        type : "f",
        value : 0
      },
      size : {
        type : "f",
        value : .01
      },
      scale : {
        type : "f",
        value : 400
      },
      batchIdOffset : {
        type : "f",
        value : 0
      }
    },
    vertexShader : handshake ? "\n\t#include <common>\n\t#include <logdepthbuf_pars_vertex>\n\t#include <skinning_pars_vertex>\n\t\n\tuniform float size;\n\tuniform float scale;\n\tuniform float baseId;\n\t\n\tvarying vec4 worldId;\n\n\t#ifdef USE_CARTESIAN3\n\t\tvec3 czm_converPosition(vec3 origin) {\n\t\t\tvec3 res = vec3(0.0);\n\t\t\tres.x = -origin.x;\n\t\t\tres.y = origin.z;\n\t\t\tres.z = origin.y;\n\t\t\treturn res;\n\t\t}\n\t#endif\n\n\t#ifdef INSTANCED\n\t\tattribute float instanceId;\n\t#endif\n\t\n\t#ifdef USE_ID_ATTRIBUTES\n\t\tattribute float id;\n\t#endif\n\n\tvoid main() {\n\t\t#include <skinbase_vertex>\n\t\t#include <begin_vertex>\n\t\t#ifdef USE_CARTESIAN3\n\t\t\ttransformed = czm_converPosition(transformed);\n\t\t#endif\n\t\t// position instanced\n\t\t#ifdef INSTANCED\n\t\t\tmat4 instanceMat = compose(instancePosition, instanceQuaternion, instanceScale);\n\t\t\ttransformed.xyz = (instanceMat * vec4(transformed, 1.0)).xyz;\n\t\t#endif\n\t\t#include <skinning_vertex>\n\t\t#include <project_vertex>\n\t\t#include <logdepthbuf_vertex>\n\t\t#ifdef USE_ID_ATTRIBUTES\n\t\t\tfloat pickId = id;\n\t\t#else\n\t\t\t#ifdef INSTANCED\n\t\t\t\tfloat pickId = instanceId;\n\t\t\t#else\n\t\t\t\tfloat pickId = baseId;\n\t\t\t#endif\n\t\t#endif\n\n\t\tvec3 a = fract(vec3(1.0/255.0, 1.0/(255.0*255.0), 1.0/(255.0*255.0*255.0)) * pickId);\n\t\ta -= a.xxy * vec3(0.0, 1.0/255.0, 1.0/255.0);\n\t\tworldId = vec4(a,1);\n\t}\n" : 
    "\n\t#include <common>\n\t#include <logdepthbuf_pars_vertex>\n\n\tuniform float size;\n\tuniform float scale;\n\tuniform float baseId;\n\n\tvarying vec4 worldId;\n\n\t#ifdef USE_CARTESIAN3\n\t\tvec3 czm_converPosition(vec3 origin) {\n\t\t\tvec3 res = vec3(0.0);\n\t\t\tres.x = -origin.x;\n\t\t\tres.y = origin.z;\n\t\t\tres.z = origin.y;\n\t\t\treturn res;\n\t\t}\n\t#endif\n\n\t#ifdef USE_ID_3DTILES_ATTRIBUTES\n\t\tuniform float batchIdOffset;\n\t#endif\n\n\t#ifdef INSTANCED\n\t\tattribute float instanceId;\n\t#endif\n\t\n\t#ifdef USE_ID_ATTRIBUTES\n\t\tattribute float id;\n\t#endif\n\t#ifdef USE_VISIBLE\n\t\tattribute float vis;\n\t#endif\n\tvoid main() {\n\t\t#ifdef USE_ID_ATTRIBUTES\n\t\t\tfloat pickId = id;\n\t\t\t#ifdef USE_ID_3DTILES_ATTRIBUTES\n\t\t\t\tpickId = id + batchIdOffset;\n\t\t\t#endif\n\t\t#else\n\t\t\t#ifdef INSTANCED\n\t\t\t\tfloat pickId = instanceId;\n\t\t\t\t#ifdef USE_ID_3DTILES_ATTRIBUTES\n\t\t\t\t\tpickId = instanceId + batchIdOffset;\n\t\t\t\t#endif\n\t\t\t#else\n\t\t\t\tfloat pickId = baseId;\n\t\t\t#endif\n\t\t#endif\n\t\t\n\t\tvec3 a = fract(vec3(1.0/255.0, 1.0/(255.0*255.0), 1.0/(255.0*255.0*255.0)) * pickId);\n\t  a -= a.xxy * vec3(0.0, 1.0/255.0, 1.0/255.0);\n\t\tworldId = vec4(a,1);\n\t\tvec3 transformed = position;\n\t\t#ifdef USE_CARTESIAN3\n\t\t\ttransformed = czm_converPosition(transformed);\n\t\t#endif\n\t\t#ifdef INSTANCED\n\t\t\tmat4 instanceMat = compose(instancePosition, instanceQuaternion, instanceScale);\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * instanceMat * vec4( transformed, 1.0 );\n\t\t#else\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( transformed, 1.0 );\n\t\t#endif\t\t\n\t\t#ifdef USE_VISIBLE\n\t\t\tgl_Position = gl_Position * vis;\n\t\t#endif\n\n\t\t#include <logdepthbuf_vertex>\n\t}\n",
    fragmentShader : "\n\t#include <logdepthbuf_pars_fragment>\n\t#ifdef GL_ES\n\t\tprecision highp float;\n\t#endif\n\tvarying vec4 worldId;\n\tvoid main() {\n\t\t#include <logdepthbuf_fragment>\n\t\tgl_FragColor = worldId;\n\t}\n"
  });
};
(ph.prototype = Object.create(THREE.ShaderMaterial.prototype)).constructor = ph, ph.prototype.setBaseID = function(initSBC) {
  this.uniforms.baseId.value = initSBC;
};
ph.prototype.setPointSize = function(value) {
  this.uniforms.size.value = value;
};
ph.prototype.setPointScale = function(initSBC) {
  this.uniforms.scale.value = initSBC;
};
var dh = new THREE.Vector2;
var fh = new THREE.Vector3;
fh.isFailed = true;
var mh;
var gh;
var vh = function() {
  function init(options, input) {
    r(this, init);
    input = input || {};
    this.app = options;
    this.renderer = options.renderer;
    this.scene = options.scene;
    this._needUpdate = true;
    this._updateTime = 0;
    this._updateIntervalTime = .25;
    this._pickHooker = null;
    this._needTracelessRendering = false;
    this.debugScene = null;
    this.sprite = null;
    this.camera2D = null;
    this.pickingTexture = new THREE.WebGLRenderTarget;
    this.pickingTexture.texture.minFilter = THREE.LinearFilter;
    this.pickingTexture.texture.generateMipmaps = false;
    this.pickNodes = new Map;
    this.pickMaterials = new Map;
    this.lineShell = Utils.parseValue(input.lineShell, 10);
    this.pointShell = Utils.parseValue(input.pointShell, .1);
    this.debug = Utils.parseValue(input.debug, false);
    this.init();
    var n = this;
    this.app.renderer.materialManager.addStrategy("gpuPicker", function(canCreateDiscussions, isSlidingUp, i, dontForceConstraints, p, s) {
      var name = this.id;
      if (this.geometry._hasDisposed) {
        return null;
      }
      if (this.userData.skipPick) {
        return null;
      }
      if (!p.visible || !p.opacity) {
        return null;
      }
      if ("BackgroundCubeMaterial" == p.name || "BackgroundMaterial" == p.name) {
        return null;
      }
      if (this.isSky) {
        return null;
      }
      if (!n.pickNodes.has(name)) {
        n.pickNodes.set(name, this);
      }
      var l = n.pickMaterials.get(name);
      return l || (l = n.createPickingMaterial(this, p)) && n.pickMaterials.set(name, l), l;
    });
  }
  return init.prototype.init = function() {
    var cs = this.renderer.getSize(dh);
    this.resizeTexture(cs.width, cs.height);
  }, init.prototype.resizeTexture = function(w, h) {
    this.pickingTexture.setSize(w, h);
    this.pixelBuffer = new Uint8Array(4 * w * h);
    if (this.sprite) {
      this.sprite.scale.set(2 * w, 2 * h, 1);
    }
    if (this.camera2D) {
      this.camera2D.left = -w / 2;
      this.camera2D.right = w / 2;
      this.camera2D.top = h / 2;
      this.camera2D.bottom = -h / 2;
      this.camera2D.updateProjectionMatrix();
    }
    this._needUpdate = true;
  }, init.prototype._needUpdatePickingTexture = function(a22) {
    return this._updateTime += a22, !(this._updateTime < this._updateIntervalTime) && (this._updateTime = 0, !!this._needUpdate && (this._needUpdate = false, true));
  }, init.prototype.update = function(e) {
    if (this._needUpdatePickingTexture(e)) {
      this.updatePickingTexture();
    }
  }, init.prototype.markPickingNode = function(props) {
    this.pickNodes.set(props.id, props);
  }, init.prototype.removePickingResources = function(obj) {
    var viewedPagesIds = this;
    if (obj.isObject3D) {
      obj.traverse(function(subPage) {
        return viewedPagesIds.removePickingResources(subPage.id);
      });
    } else {
      var i = this.pickMaterials.get(obj);
      if (i) {
        if (Array.isArray(i)) {
          i.forEach(function(backdropRef) {
            return backdropRef.dispose();
          });
        } else {
          i.dispose();
        }
        this.pickMaterials.delete(obj);
      }
      var objGuid = this.pickNodes.get(obj);
      if (objGuid) {
        this.pickNodes.delete(obj);
        if (!objGuid.isEdgeWireframe) {
          this.forceUpdate = true;
        }
      }
    }
  }, init.prototype._createPickingMaterial = function(data, source) {
    var runner = data.userData;
    var hatch = source.size || .01;
    var uniformDeclaration = source.linewidth || 1;
    var checkAuthUserReplied = function(data) {
      var parent = data;
      for (; parent;) {
        if (parent.userData.withGeometryIDAttributes) {
          return true;
        }
        parent = parent.parent;
      }
      return false;
    };
    if (source.isSpriteMaterial) {
      if (source.map && source.map.image) {
        (material = source.clone()).alphaTest = .001;
        material.blending = THREE.NoBlending;
        material.lights = false;
        material.fog = false;
        material.opacity = 1;
        material.visible = !(!source.visible || runner.skipPick);
        material.baseId = data.id;
        material.defines = material.defines || {};
        material.defines.USE_GPUPICKER = "";
      }
    } else {
      if (runner.noBlending || source.isShaderMaterial && source.vertexShader.indexOf("USE_GPUPICKER") > -1) {
        (material = source.clone()).alphaTest = .001;
        material.blending = THREE.NoBlending;
        material.lights = false;
        material.fog = false;
        material.visible = !(!source.visible || runner.skipPick);
        material.baseId = data.id;
        material.defines = material.defines || {};
        material.defines.USE_GPUPICKER = "";
        var point = material.uniforms;
        if (point && point.lineWidth) {
          point.lineWidth.value += this.lineShell;
        }
        if (checkAuthUserReplied(data)) {
          material.defines.USE_ID_ATTRIBUTES = "";
        }
      } else {
        var material;
        if (checkAuthUserReplied(data)) {
          (material = new ph(source.skinning)).map = null;
          material.color = new THREE.Color;
          material.uniforms.config = {
            value : {
              x : 0,
              y : 0
            }
          };
          material.linewidth = uniformDeclaration + this.lineShell;
          material.depthTest = source.depthTest;
          material.depthWrite = Utils.parseValue(source.depthWrite, source._pickable);
          material.colorWrite = source.colorWrite;
          material.transparent = source.transparent;
          material.opacity = 1;
          material.side = source.side;
          material.skinning = source.skinning;
          material.visible = !(!source.visible || runner.skipPick);
          material.polygonOffset = source.polygonOffset;
          material.polygonOffsetFactor = source.polygonOffsetFactor;
          material.polygonOffsetUnits = source.polygonOffsetUnits;
          material.baseId = data.id;
          if (source.defines && void 0 !== source.defines.INSTANCED && false !== source.defines.INSTANCED) {
            material.defines.INSTANCED = "";
          }
          if (runner.USE_CARTESIAN3) {
            material.defines.USE_CARTESIAN3 = "";
          }
          material.defines.USE_ID_ATTRIBUTES = "";
          if (data.userData.enableObjectification) {
            material.defines.USE_ID_3DTILES_ATTRIBUTES = "";
            material.uniforms.batchIdOffset.value = data.userData.batchIdOffset;
          }
          material.setPointSize(hatch + this.pointShell);
          material.setPointScale(this.renderer.getSize(dh).height * this.renderer.getPixelRatio() / 2);
        } else {
          (material = new ph(source.skinning)).map = null;
          material.color = new THREE.Color;
          material.uniforms.config = {
            value : {
              x : 0,
              y : 0
            }
          };
          material.linewidth = uniformDeclaration + this.lineShell;
          material.depthTest = source.depthTest;
          material.depthWrite = Utils.parseValue(source.depthWrite, source._pickable);
          material.colorWrite = !!runner.skipPickColorWrite || source.colorWrite;
          material.transparent = source.transparent;
          material.opacity = 1;
          material.side = source.side;
          material.skinning = source.skinning;
          material.visible = !(!source.visible || runner.skipPick);
          material.polygonOffset = source.polygonOffset;
          material.polygonOffsetFactor = source.polygonOffsetFactor;
          material.polygonOffsetUnits = source.polygonOffsetUnits;
          material.baseId = data.id;
          if (source.defines && void 0 !== source.defines.INSTANCED && false !== source.defines.INSTANCED) {
            material.defines.INSTANCED = "";
          }
          if (runner.USE_CARTESIAN3) {
            material.defines.USE_CARTESIAN3 = "";
          }
          if (data.userData.enableObjectification) {
            material.defines.USE_ID_3DTILES_ATTRIBUTES = "";
            material.uniforms.batchIdOffset.value = data.userData.batchIdOffset;
          }
          material.setPointSize(hatch + this.pointShell);
          material.setPointScale(this.renderer.getSize(dh).height * this.renderer.getPixelRatio() / 2);
        }
      }
    }
    return source.defines && source.defines.USE_VISIBLE && (material.defines.USE_VISIBLE = true), material;
  }, init.prototype.createPickingMaterial = function(el, t) {
    if (t.length) {
      var teardownFunctions = [];
      var k = 0;
      for (; k < t.length; k++) {
        teardownFunctions.push(this._createPickingMaterial(el, t[k]));
      }
      return teardownFunctions;
    }
    return this._createPickingMaterial(el, t);
  }, init.prototype.updatePickingTexture = function() {
    var transformControls = this.app.renderer.materialManager;
    var mode = transformControls.getMode();
    transformControls.setMode("gpuPicker");
    var s = this.scene;
    var value = s.autoUpdate;
    s.autoUpdate = false;
    var enable = this.renderer.shadowMap.enable;
    this.renderer.initRenderList = false;
    this.renderer.setRenderTarget(this.pickingTexture);
    this.renderer.clear();
    var self = this;
    this.doRender(function() {
      self.renderer.render(s, self.app.renderCamera);
      self.renderer.render(self.app.mainUI.scene2D, self.app.mainUI.camera2D);
    });
    s.autoUpdate = value;
    this.renderer.shadowMap.enable = enable;
    this.renderer.initRenderList = true;
    this.renderer.readRenderTargetPixels(this.pickingTexture, 0, 0, this.pickingTexture.width, this.pickingTexture.height, this.pixelBuffer);
    transformControls.setMode(mode);
  }, init.prototype.pick = function(object, pos, i, s) {
    var len = this.pickingTexture.width;
    var l = this.pickingTexture.height;
    if (pos = Math.round(pos), i = Math.round(i), pos < 0 || pos >= len) {
      return null;
    }
    if (i < 0 || i >= l) {
      return null;
    }
    var tailOldPos = pos + (l - i - 1) * len;
    var value = 255 * this.pixelBuffer[4 * tailOldPos + 2] * 255 + 255 * this.pixelBuffer[4 * tailOldPos + 1] + this.pixelBuffer[4 * tailOldPos + 0];
    if (isNaN(value)) {
      return null;
    }
    var node = this.pickNodes.get(value);
    if (!node) {
      var f = this.app.picker.onPickNodeID;
      if (f) {
        node = f(value);
      }
    }
    if (!node) {
      return null;
    }
    var _this = s.clone();
    _this._camera = s._camera || s.camera;
    _this.camera = s.camera || s._camera;
    var scene = this;
    var e = {
      x : pos,
      y : i,
      id : value,
      pickedNode : node,
      node : node,
      object : node,
      raycaster : _this,
      getPickedPosition : function(b) {
        b = b || {};
        var objects = this.pickedNode;
        var getIntersects = scene._pickHooker;
        if (getIntersects) {
          var intersects = getIntersects(this.raycaster, objects);
          if (intersects) {
            if (Utils.isArray(intersects)) {
              return Utils.parseVector3(intersects);
            }
            if (intersects.isVector3) {
              return intersects;
            }
          }
        }
        var intersected = this.raycaster.intersectObject(objects, false);
        if (intersected.length) {
          return intersected[0].point;
        }
        var callback = function(raycaster, objects) {
          if (!objects) {
            return null;
          }
          var crossfilterable_layers = raycaster.intersectObject(objects, true);
          var layer_i = 0;
          for (; layer_i < crossfilterable_layers.length; layer_i++) {
            var hit = crossfilterable_layers[layer_i];
            if (!hit.object.userData.skipPick) {
              return hit.point;
            }
          }
          return null;
        };
        var value = callback(this.raycaster, objects.parent);
        if (value) {
          return value;
        }
        if (!b.skipOtherPick) {
          if (!b.skipParentPick && objects.parent && (value = callback(this.raycaster, objects.parent))) {
            return value;
          }
          if (!b.skipObjectPick) {
            var args = scene.app.objectManager.getBaseObject(objects);
            if (args && (value = callback(this.raycaster, args.node))) {
              return value;
            }
          }
          if (!b.skipScenePick && (value = callback(this.raycaster, scene.app.scene))) {
            return value;
          }
        }
        return fh;
      }
    };
    return Object.defineProperties(e, {
      pickedPosition : {
        get : function() {
          if (void 0 === e._pickedPosition) {
            var self = e.getPickedPosition();
            if (self) {
              e._pickedPosition = self.toArray();
              if (self.isFailed) {
                e._pickedPosition.isFailed = true;
              }
            } else {
              e._pickedPosition = null;
            }
          }
          return e._pickedPosition;
        }
      },
      distance : {
        get : function() {
          if (void 0 === e._distance) {
            var end = e.pickedPosition;
            if (end) {
              var position = new THREE.Vector3(end[0], end[1], end[2]);
              e._distance = position.distanceTo(object.position);
            } else {
              var v = new THREE.Vector3;
              node.getWorldPosition(v);
              var b = new THREE.Vector3;
              object.getWorldPosition(b);
              e._distance = b.distanceTo(v);
            }
          }
          return e._distance;
        }
      }
    }), e;
  }, init.prototype.show = function(instance) {
    if (instance || void 0 === instance) {
      if (!this.sprite) {
        var spriteMaterial = new THREE.SpriteMaterial({
          map : this.pickingTexture.texture
        });
        this.sprite = new THREE.Sprite(spriteMaterial);
        this.sprite.scale.set(this.pickingTexture.width, this.pickingTexture.height, 1);
        this.sprite.position.set(0, 0, -10);
        this.debugScene = new THREE.Scene;
        this.debugScene.add(this.sprite);
        var cs = this.renderer.getSize(dh);
        this.camera2D = new THREE.OrthographicCamera(-cs.width / 2, cs.width / 2, cs.height / 2, -cs.height / 2, .1, 100);
      }
    } else {
      if (this.debugScene && this.sprite) {
        this.debugScene.remove(this.sprite);
        this.sprite = null;
        this.debugScene = null;
        this.camera2D = null;
      }
    }
  }, init.prototype.render = function(obj) {
    if (this.debugScene) {
      obj.setRenderTarget(null);
      obj.clear();
      var _this = this;
      this.doRender(function() {
        obj.render(_this.debugScene, _this.camera2D);
      });
    }
  }, init.prototype.doRender = function(callback) {
    var frame = void 0;
    if (this._needTracelessRendering) {
      frame = this.renderer.saveInfo();
    }
    if (callback) {
      callback();
    }
    if (this._needTracelessRendering) {
      this.renderer.loadInfo(frame);
    }
  }, n(init, [{
    key : "needTracelessRendering",
    set : function(v) {
      this._needTracelessRendering = v;
    }
  }, {
    key : "updateIntervalTime",
    set : function(v) {
      this._updateIntervalTime = v;
    },
    get : function() {
      return this._updateIntervalTime;
    }
  }, {
    key : "forceUpdate",
    set : function(v) {
      if (v) {
        this._needUpdate = true;
        this._updateTime = .25;
      }
    }
  }, {
    key : "needUpdate",
    set : function(v) {
      this._needUpdate = v;
    }
  }]), init;
}();
var yh = function() {
  function init(App) {
    r(this, init);
    this.app = App;
    var pregeom = new THREE.PlaneGeometry(1e4, 1e4, 1, 1);
    var wheelAxisMat = new THREE.MeshStandardMaterial({
      color : 2200782,
      side : THREE.DoubleSide,
      transparent : true,
      opacity : .25
    });
    this._vertGround = new THREE.Mesh(pregeom, wheelAxisMat);
    this._vertGround.visible = false;
    this._vertGround.setAngles([90, 0, 0]);
    this._vertGround.scale.set(1e3, 100, 100);
    this._vertGround.updateMatrixWorld();
    var cursorGeometry = new THREE.PlaneGeometry(1e4, 1e4, 1, 1);
    var suspensionMat = new THREE.MeshStandardMaterial({
      color : 13538337,
      side : THREE.DoubleSide,
      transparent : true,
      opacity : .25
    });
    this._horzGround = new THREE.Mesh(cursorGeometry, suspensionMat);
    this._horzGround.visible = false;
    this._horzGround.setAngles([90, 0, 0]);
    this._horzGround.scale.set(1e3, 100, 100);
    this._horzGround.updateMatrixWorld();
    this.pickingScene = new THREE.Scene;
    this.pickingScene.add(this._vertGround);
    this.pickingScene.add(this._horzGround);
  }
  return init.prototype.destroy = function() {
    this.app.resourceManager.remove(this.pickingScene);
  }, init.prototype.update = function(target, name) {
    this._vertGround.lookAt(Utils.parseVector3(target));
    this._vertGround.position.copy(Utils.parseVector3(name));
    this._vertGround.updateMatrixWorld();
  }, init.prototype.isMeshOf = function(callback) {
    return this._vertGround == callback || this._horzGround == callback;
  }, init.prototype.intersect = function(obj, target) {
    var register = this.app.calcRect();
    var r = this.app.renderCamera.getRaycaster(obj, target, register);
    return this.intersectByRaycaster(r);
  }, init.prototype.intersectByRaycaster = function(r) {
    var items = r.intersectObjectForcible(this._horzGround);
    var data = r.intersectObjectForcible(this._vertGround);
    return items.length && data.length ? items[0].distance < data[0].distance ? items[0] : data[0] : items.length ? items[0] : data.length ? data[0] : null;
  }, n(init, [{
    key : "visible",
    set : function(v) {
      if (v) {
        this.app.scene.add(this.pickingScene);
      } else {
        this.app.scene.remove(this.pickingScene);
      }
      this._vertGround.visible = v;
      this._horzGround.visible = v;
    }
  }]), init;
}();
var bh = function() {
  function View(options) {
    r(this, View);
    this.app = options;
    this.picker = options.picker;
    this.pickDownPosition = [0, 0];
    this._mouseMoveInterval = null;
    View.instance = this;
  }
  return View.prototype.processPicking = function(value) {
    this.picker.processPicking(value);
  }, View.prototype.processAreaPicking = function(fn) {
    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    var picker = this.picker;
    var stack = picker.pickingArea;
    var objects = new xi(this.app);
    if (t) {
      objects.buildReturnObject(stack.processPicking(picker.areaCandidates));
    } else {
      this.processPicking(fn);
      if (picker.areaCandidates.has(fn.object)) {
        objects.buildReturnObject([fn.object]);
      } else {
        objects.buildReturnObject([]);
      }
    }
    this.picker.setPickedObject(objects);
    this.app.trigger(EventType.AreaPicking, {
      objects : objects
    });
  }, View.prototype.startPicking = function(a22) {
    var self = this.picker;
    self.forceUpdate = true;
    self._enable(true, "startPicking", 1e4);
    a22.ignoreFrameCheck = true;
  }, View.prototype.endPicking = function() {
    this.picker._enable(false, "startPicking", 0);
  }, View.prototype.processClickEvents = function(e) {
    this.startPicking(e);
    this.processPicking(e);
    this.endPicking();
  }, View.prototype.tryToDrag = function(value) {
    var obj = this.picker.processPicking(value);
    if (null == obj) {
      return null;
    }
    var o = obj.object;
    return o ? o.draggable ? obj : (value.object = null, null) : null;
  }, View.prototype.onEnter = function(App) {
  }, View.prototype.onUpdate = function(parentBindings) {
    var _ = this.picker;
    if (!_.areaPicking) {
      var c = _.pickingArea;
      if (c.started) {
        c.end();
      }
    }
    _.update(this.app._deltaTime);
    if (this._mouseMoveInterval) {
      this._mouseMoveInterval.deltaTime += this.app._deltaTime;
    }
  }, View.prototype.onMouseMove = function(e) {
    if (this._mouseMoveInterval) {
      if (this._mouseMoveInterval.deltaTime - this._mouseMoveInterval.curTime < this._mouseMoveInterval.interval) {
        return;
      }
      this._mouseMoveInterval.curTime = this._mouseMoveInterval.deltaTime;
    }
    var picker = this.picker;
    if (picker.areaPicking) {
      var selection = picker.pickingArea;
      if (selection.started) {
        selection.move(e.clientX, e.clientY);
        if (selection.realTimePicking) {
          e.areaPicking = true;
          this.processAreaPicking(e);
        }
      }
    } else {
      this.processPicking(e);
      if (false === this.picker.setPickedObject(e.object, null, e.ignoreFilter)) {
        e.hadFiltered = true;
      }
    }
  }, View.prototype.onMouseUp = function(e) {
    var picker = this.picker;
    if (this.startPicking(e), picker.areaPicking) {
      if (0 == e.button) {
        var i = THING.Math.getDistance(this.pickDownPosition, [e.x, e.y]) > 4;
        e.finishedAreaPicking = true;
        this.processAreaPicking(e, i);
        picker.pickingArea.end();
      }
    } else {
      e.ignoreFrameCheck = true;
      picker.processPicking(e);
    }
    this.endPicking();
  }, View.prototype.onMouseDown = function(options) {
    var picker = this.picker;
    picker.forceUpdate = true;
    this.pickDownPosition = [options.clientX, options.clientY];
    if (picker.areaPicking) {
      if (0 == options.button) {
        picker.pickingArea.start(options.clientX, options.clientY);
      }
    } else {
      options.ignoreFrameCheck = true;
      picker.processPicking(options);
    }
  }, View.prototype.onDoubleClick = function(e) {
    this.processClickEvents(e);
  }, View.prototype.onSingleClick = function(event) {
    this.processClickEvents(event);
  }, View.prototype.onClick = function(e) {
    this.processClickEvents(e);
  }, View.prototype.onDragStart = function(e) {
    this.startPicking(e);
    var t = this.tryToDrag(e);
    if (t) {
      var obj = t.object;
      var global = this.picker;
      obj._dragState = MAX_IMAGERY_LENGTH.Dragging;
      obj.internalUserData.prevPickable = obj.pickable;
      obj.pickable = false;
      e.ignoreFrameCheck = true;
      e.forceUpdateTexture = true;
      var args = global.processPicking(e);
      global.dragIntersect = args || t;
      global.dragIntersect.dragObject = obj;
      e.dragObject = obj;
      delete e.ignoreFrameCheck;
      delete e.forceUpdateTexture;
      this.app.camera.disable({
        rotate : true
      });
    } else {
      this.endPicking();
    }
  }, View.prototype.onDrag = function(item) {
    var picker = this.picker;
    if (null != picker.dragIntersect) {
      item.disableGPUPicker = true;
      picker.processPicking(item);
      delete item.disableGPUPicker;
      this.app.needUpdate = true;
    }
  }, View.prototype.onDragEnd = function(data) {
    var $ = this.picker;
    if ($.forceUpdate = true, null != $.dragIntersect) {
      data.disableGPUPicker = true;
      $.processPicking(data);
      delete data.disableGPUPicker;
      var node = $.dragIntersect.dragObject;
      if (node) {
        node._dragState = MAX_IMAGERY_LENGTH.DragEnd;
      }
      var pickable = node.internalUserData.prevPickable;
      if (pickable) {
        node.pickable = pickable;
      }
      delete node.internalUserData.prevPickable;
      data.object = node;
      $.dragIntersect = null;
      this.app.camera.resume({
        rotate : true
      });
      this.endPicking();
    }
  }, n(View, [{
    key : "mouseMoveInterval",
    set : function(n) {
      this._mouseMoveInterval = n;
      if (this._mouseMoveInterval) {
        this._mouseMoveInterval = {
          interval : n,
          curTime : this.app._deltaTime,
          deltaTime : this.app._deltaTime
        };
      }
    },
    get : function() {
      return this._mouseMoveInterval;
    }
  }]), View;
}();
var _h = void 0;
var xh = 0;
var Eh = false;
var wh = function() {
  function self(value) {
    r(this, self);
    this.app = value;
    var scaledBBox = this.app.calcRect();
    this.resize(scaledBBox.width, scaledBBox.height);
    mh = this;
  }
  return self.prototype.updateProgress = function(progress) {
    return this.loadingProgressBar.updateProgress(progress);
  }, self.prototype.updateDownloadingProgress = function(canCreateDiscussions) {
  }, self.prototype.updateLoadingProcess = function(data) {
    data = data || {};
    if (Utils.isNumber(data)) {
      data = {
        object : this.app.root.campuses[0],
        progress : data
      };
    }
    var observeMe = data.object || data.campus;
    var progress = data.progress;
    if (this.updateProgress(progress)) {
      this.app.events.dispatchEvent({
        type : "progress",
        object : observeMe,
        progress : progress
      });
    }
  }, self.prototype._createLSM = function(position, op, value) {
    var imageCanvas = document.createElement("canvas");
    imageCanvas.width = 512;
    imageCanvas.height = 512;
    var ctx = imageCanvas.getContext("2d");
    ctx.font = "24px Verdana";
    ctx.fillStyle = "white";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    var o = [0, 0, 0];
    var bearingRad = THING.Math.degToRad(30);
    ctx.shadowColor = "rgba(" + 255 * o[0] + "," + 255 * o[1] + "," + 255 * o[2] + ",1)";
    ctx.shadowBlur = 1;
    ctx.shadowOffsetX = 2 * Math.cos(bearingRad);
    ctx.shadowOffsetY = 2 * Math.sin(bearingRad);
    (function(ctx, prop, tx, yPos, width) {
      var rawTextArr = prop.split("\n");
      var rline = 0;
      for (; rline < rawTextArr.length; rline++) {
        var line = rawTextArr[rline];
        ctx.fillText(line, tx, yPos);
        yPos = yPos + width;
      }
    })(ctx, position, 256, 256, 40);
    var textureCanvas = new THREE.Texture(imageCanvas);
    return textureCanvas.needsUpdate = true, new THREE.SpriteMaterial({
      opacity : op,
      color : 16777215,
      transparent : true,
      depthWrite : false,
      map : textureCanvas,
      rotation : THING.Math.degToRad(value)
    });
  }, self.prototype._createLS = function(opts, num, i) {
    var cssChanges = this.app.calcRect();
    var gridX = 2 * cssChanges.width;
    var rows = 2 * cssChanges.height;
    var gBuffer = [];
    var y = -rows;
    for (; y < rows; y = y + i) {
      var x = -gridX;
      for (; x < gridX; x = x + num) {
        var g = new THREE.Sprite(opts);
        g.userData.skipPick = true;
        g.scale.set(512, 512, 1);
        g.position.set(x, y, -10);
        gBuffer.push(g);
      }
    }
    return gBuffer;
  }, self.prototype._setupSprite = function(text) {
    var parsed = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 480;
    var module = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 320;
    if (_h) {
      this.app.resourceManager.remove(_h);
    }
    var r = this._createLSM(text, .04, 30);
    var nodes = this._createLS(r, parsed, module);
    _h = new THREE.Group;
    var i = 0;
    for (; i < nodes.length; i++) {
      _h.add(nodes[i]);
      nodes[i].material.opacity = 0;
    }
    Eh = true;
    this.scene2D.add(_h);
  }, self.prototype._setup = function() {
    var dump1 = b.update(this.app.appKey);
    var dump2 = [12, 164, 143, 166, 114, 16, 17, 182, 16, 94, 29, 114, 216, 195, 208, 81, 35, 181, 52, 132, 113, 112, 175, 32, 228, 201, 230, 97, 106, 44, 100, 73, 110, 54, 247, 25];
    var i = 0;
    for (; i < dump1.length; i++) {
      if (dump1[i] != dump2[i]) {
        this._setupL();
        break;
      }
    }
    this.overlayRootNode = new THREE.Group;
    this.scene2D.add(this.overlayRootNode);
  }, self.prototype._setupL = function() {
    if ((new j).eb()) {
      if ([12, 34, 34, 54, 123, 34, 123, 53, 12, 531, 1324, 5, 34, 1].toString() != [32].toString()) {
        var c = function(scope) {
          scope = scope || window;
          var options = b;
          var name = options.toStr([76, 243, 170, 237, 85, 62]);
          var val = options.toStr([83, 249, 168, 254, 66, 63, 61, 235]);
          var i = options.toStr([79, 247, 191, 247, 88, 55, 63, 224]);
          i = options.update(scope[val][i]);
          var b1 = options.toStr([80, 230, 174, 241]);
          var col = options.toStr([87, 226, 191, 239, 12, 121, 125, 242, 74, 24, 10, 48, 244, 135, 138, 115, 8, 255, 55, 165, 90, 89, 198]);
          var el = options.update(scope[val][name]);
          var str = [107, 254, 162, 241, 81, 28, 1, 165, 95, 22, 4, 17, 213, 160, 171];
          var f1 = [0, 248, 170, 242, 83, 107, 125];
          if (0 == el.toString().indexOf(f1.toString())) {
            str = [107, 254, 162, 241, 81, 28, 1, 165, 95, 22, 4, 17, 213, 160, 171, 30, 74, 202, 107, 163, 80, 20, 159, 104, 208, 141, 185, 54, 51, 54];
          }
          var fakeData1 = [0, 0];
          return 1 == Utils.r(0, 1) && (0 == Utils.r(0, 1) ? fakeData1[1] = Utils.r(10, 230) : fakeData1[0] = Utils.r(50, 400)), {
            b1 : b1,
            c1 : col,
            d1 : fakeData1,
            e1 : name,
            pp1 : i,
            gg1 : [[16, 230, 228]],
            f1 : f1,
            gs : [[0, 248, 170, 242, 83, 107, 125, 240, 77, 3, 75, 37, 248, 157, 203, 100, 3, 239, 114, 167, 82, 81], [0, 248, 170, 242, 83, 107, 125, 245, 18], [0, 251, 246, 176, 70, 121]],
            h1 : el,
            t1 : options.toStr(str)
          };
        }(this.l);
        if (c) {
          var b = c.gs;
          if (b) {
            var related_node_ids = c.h1.toString();
            var i = 0;
            for (; i < b.length; i++) {
              if (0 == related_node_ids.indexOf(b[i].toString())) {
                return;
              }
            }
          }
          if (b = c.gg1) {
            related_node_ids = c.pp1.toString();
            i = 0;
            for (; i < b.length; i++) {
              if (0 == related_node_ids.indexOf(b[i].toString())) {
                return;
              }
            }
          }
          var t1 = c.t1;
          this._setupSprite(t1);
        }
      }
    }
  }, self.prototype.onResize = function(w, h) {
    this.resize(w, h);
    var i = i || b.toStr([96, 201, 148, 250, 88, 55, 48, 233, 88, 48, 80, 33, 228, 154, 187, 127, 7, 245, 70, 163, 91, 87, 134, 105, 199, 140, 143, 6, 2]);
    if (THING[i]) {
      var aPos = b.toStr([96, 226, 174, 231, 66, 29, 55, 252, 120, 1, 71, 43, 248, 139, 150]);
      THING[aPos] = b;
      delete THING[i];
    }
  }, self.prototype.onUpdate = function() {
    var e = Te();
    if (true === e ? this.checkAuthRet = true : false === e && (this.checkAuthRet = false, void 0 === gh && (gh = true, THREE.ShaderChunk.map_fragment = ["", "#ifdef USE_MAP", "#ifdef USE_DIFFUSE_UV2", "vec4 texelColor = texture2D( map, vUv2 );", "#else", "vec4 texelColor = texture2D( map, vUv );", "#endif", "texelColor = mapTexelToLinear( texelColor );", "diffuseColor *= texelColor;", "diffuseColor.a *= texelColor.a * 0.5;", "diffuseColor.b *= texelColor.r * 0.25;", "#endif", ""].join("\n"), THREE.ShaderChunk.alphamap_fragment = 
    ["", "#ifdef USE_ALPHAMAP", "#ifdef USE_ALPHAMAP_REVERSE", "diffuseColor.a *= 1.0 - texture2D( alphaMap, vAlphaUV).g;", "diffuseColor.a *= 0.1 - texture2D( alphaMap, vAlphaUV).r;", "diffuseColor.a *= 0.5 - texture2D( alphaMap, vAlphaUV).b;", "#else", "diffuseColor.a *= texture2D( alphaMap, vAlphaUV).g;", "diffuseColor.r *= texture2D( alphaMap, vAlphaUV).r;", "diffuseColor.b *= texture2D( alphaMap, vAlphaUV).b;", "#endif", "#endif", ""].join("\n"), THREE.ShaderChunk.uv2_vertex = ["#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP ) || defined (USE_DIFFUSE_UV2)", 
    "#if defined(USE_DIFFUSE_UV2) && defined(USE_MAP)", "vUv2 = (uvTransform * vec3(uv2, 0.1)).xy;", "#else", "vUv2 = uv2;", "#endif", "#endif", "#ifdef USE_ALPHAMAP", "vAlphaUV = (uvTransform1 * vec3(uv, 0.1)).xy;", "#ifdef USE_ALPHA_UV2", "vAlphaUV = (uvTransform1 * vec3(uv2, 0.1)).xy;", "#endif", "#ifdef USE_ALPHA_UV3", "vAlphaUV = (uvTransform1 * vec3(uv3, 0.1)).xy;", "#endif", "#ifdef USE_ALPHA_UV4", "vAlphaUV = (uvTransform1 * vec3(uv4, 0.1)).xy;", "#endif", "#endif", "#ifdef USE_EMISSIVEMAP", 
    "#ifndef USE_EMISSIVETRANSFORM", "mat3 emissiveTransform = uvTransform;", "#else", "mat3 emissiveTransform = uvTransform2;", "#endif", "vEmissiveUV = (emissiveTransform * vec3(uv, 0.1)).xy;", "#ifdef USE_EMISSIVE_AROUND_UV", "vEmissiveUV = (emissiveTransform * vec3(uv8, 0.1)).xy;", "#endif", "#ifdef USE_ALPHA_UV2", "vEmissiveUV = (emissiveTransform * vec3(uv2, 0.1)).xy;", "#endif", "#ifdef USE_ALPHA_UV3", "vEmissiveUV = (emissiveTransform * vec3(uv3, 0.1)).xy;", "#endif", "#ifdef USE_ALPHA_UV4", 
    "vEmissiveUV = (emissiveTransform * vec3(uv4, 0.1)).xy;", "#endif", "#endif", ""].join("\n"), THREE.ShaderChunk.aomap_fragment = "\n\t#ifdef USE_AOMAP\n\t\t#ifdef WALL_AO\n\t\t\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).g - .5 ) * aoMapIntensity * 1.5 + 1.5;\n\t\t#else\n\t\t\t#ifdef FLOOR_AO\n\t\t\t\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).g - .5 ) * aoMapIntensity + 2.25;\n\t\t\t#else\n\t\t\t\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).g - .5 ) * aoMapIntensity * 2.6 + 1.7;\n\t\t\t#endif\n\t\t#endif\n\t\t// reflectedLight.indirectDiffuse *= ambientOcclusion;\n\t\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t\t#endif\n\t#else\n\t\tfloat ambientOcclusion = 0.4;\n\t#endif\n", 
    THREE.ShaderChunk.emissivemap_fragment = "\n\t#ifdef USE_EMISSIVEMAP\n\n\t\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveUV );\n\n\t\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\n\t\ttotalEmissiveRadiance *= emissiveColor.bgr;\n\n\t#endif\n\n\t#ifdef STANDARD\n\t\ttotalEmissiveRadiance = vec3(0.0,0.0,0.0);\n\t\tvec3 newEmissiveColor = emissive;\n\t\t#ifdef USE_EMISSIVEMAP\n\t\t\tnewEmissiveColor = emissive * emissiveColor.rgb;\n\t\t\t#ifdef USE_SIDE_EMISSIVE\n\t\t\t\tnewEmissiveColor *= newEmissiveColor * (0.5 - abs(dot( inverseTransformDirection( normal, viewMatrix ), vec3(0.5, .5, 0.5) )));\n\t\t\t#endif\n\t\t#endif\n\t#endif\n", 
    THREE.ShaderChunk.encodings_fragment = ["gl_FragColor = linearToOutputTexel( gl_FragColor );", "#if defined(STANDARD) || defined(USE_AOMAP)", "gl_FragColor.rgb *= ambientOcclusion;", "#elif defined(FLOOR_AO)", "gl_FragColor.rgb *= 0.2;", "#endif", "#ifdef STANDARD", "gl_FragColor.rgb *= newEmissiveColor;", "#endif"].join("\n"), THREE.ShaderChunk.tonemapping_fragment = ["#if defined( TONE_MAPPING ) && defined(STANDARD)", "gl_FragColor.rgb = toneMapping( gl_FragColor.bgr );", "#endif"].join("\n"))), 
    300 === xh && Eh) {
      var i = 0;
      for (; i < _h.children.length; i++) {
        _h.children[i].material.opacity = .04;
      }
      Eh = false;
    }
    if (Eh) {
      xh++;
    }
    this.render();
  }, self.prototype.resize = function(w, h) {
    this.scene2D = this.scene2D || new THREE.Scene;
    this.camera2D = this.camera2D || new THREE.OrthographicCamera(-w / 2, w / 2, h / 2, -h / 2, .1, 100);
    this.camera2D.left = -w / 2;
    this.camera2D.right = w / 2;
    this.camera2D.top = h / 2;
    this.camera2D.bottom = -h / 2;
    this.camera2D.updateProjectionMatrix();
    if (this.loadingProgress) {
      this.loadingProgress.resize(w, h);
    }
  }, self.prototype.render = function(value) {
    value = value || this.app.renderer;
    var host = Ee().l;
    if (void 0 !== host && !this._c) {
      this._c = true;
      var t1 = Ee().t;
      if (!host) {
        t1 = "";
      }
      this._setupSprite(t1);
    }
    if (_h) {
      if (_h.parent != this.scene2D) {
        this.scene2D.add(_h);
      }
      _h.visible = true;
      _h.traverse(function(oPresentationNode) {
        oPresentationNode.visible = true;
      });
      this.scene2D.visible = true;
    }
    value.setRenderTarget(null);
    value.clear(false, true, false);
    var autoClear = this.app.renderer.autoClear;
    value.autoClear = false;
    value.render(this.scene2D, this.camera2D);
    value.autoClear = autoClear;
  }, self.prototype.getRenderPosition = function(h, name, valueParts) {
    var end = (valueParts = valueParts || [this.app.domElement.offsetWidth, this.app.domElement.offsetHeight])[0] / 2;
    var hb = valueParts[1] / 2;
    var v2Destination = [h[0] * end, h[1] * hb];
    var offset = [name[0] / 2, name[1] / 2];
    return v2Destination[0] = THING.Math.clamp(v2Destination[0], -end + offset[0], end - offset[0]), v2Destination[1] = THING.Math.clamp(v2Destination[1], -hb + offset[1], hb - offset[1]), [v2Destination[0], -v2Destination[1]];
  }, self.prototype.screenToWorld = function(point, t) {
    var cssChanges = this.app.calcRect();
    var a1 = t[0];
    var GAcode = t[1];
    return [point[0] + a1 / 2 - cssChanges.width / 2, -point[1] - GAcode / 2 + cssChanges.height / 2];
  }, n(self, [{
    key : "loadingProgressBar",
    get : function() {
      return this.loadingProgress = this.loadingProgress || this.app.create({
        type : "ProgressBar",
        height : 6,
        scene : this.scene2D,
        onTop : false,
        parent : null
      }), this.loadingProgress;
    }
  }]), self;
}();
function Th(x, y) {
  var nodeAttrs = THING.App.current._style;
  if (nodeAttrs) {
    var nodeTransform = nodeAttrs.transform;
    if (nodeTransform) {
      var s = nodeTransform.scale;
      if (s) {
        x = x / s[0];
        y = y / s[1];
      }
    }
  }
  return [x, y];
}
var Mh = function(_node) {
  var node = _node;
  var i = true;
  for (; node;) {
    if (!node.visible) {
      return i = false;
    }
    node = node.parent;
  }
  return i;
};
Ch = function() {
  function drag(value) {
    r(this, drag);
    this.app = value;
    this.sprite = null;
    this.spriteLineNode = null;
    this.started = false;
    this.startX = 0;
    this.startY = 0;
    this.distanceX = 0;
    this.distanceY = 0;
    this.region = [];
    this._areaPickType = textureTransAndScale0.Auto;
    this._realTimePicking = false;
    this.depth = -10;
  }
  return drag.prototype.initLines = function() {
    if (!this.spriteLineNode) {
      var lineStripGeom = new THREE.Geometry;
      lineStripGeom.vertices = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3];
      var linkMaterial = new THREE.LineBasicMaterial({
        color : 16777215,
        opacity : .8,
        linewidth : 1,
        transparent : true
      });
      this.spriteLineNode = new THREE.Line(lineStripGeom, linkMaterial);
      this.spriteLineNode.visible = false;
      this.spriteLineNode.computeLineDistances();
      this.app.mainUI.scene2D.add(this.spriteLineNode);
    }
  }, drag.prototype.initSprite = function() {
    if (!this.sprite) {
      var spriteMaterial = new THREE.SpriteMaterial({
        opacity : .4,
        color : 32768,
        transparent : true
      });
      this.sprite = new THREE.Sprite(spriteMaterial);
      this.sprite.visible = false;
      this.app.mainUI.scene2D.add(this.sprite);
    }
  }, drag.prototype.setSpritePosition = function(w, h) {
    var cssChanges = this.app.calcRect();
    var r = w - cssChanges.width / 2;
    var y = h - cssChanges.height / 2;
    this.sprite.position.set(r, -y, this.depth);
  }, drag.prototype.setSpriteLinePosition = function(i, y, l, w) {
    var geometry = this.spriteLineNode.geometry;
    var vertices = geometry.vertices;
    var size = l / 2;
    var radius = w / 2;
    var p = new THREE.Vector3(i - size, y - radius, this.depth);
    var h = new THREE.Vector3(i + size, y - radius, this.depth);
    var srcFile2 = new THREE.Vector3(i + size, y + radius, this.depth);
    var realVal = new THREE.Vector3(i - size, y + radius, this.depth);
    vertices[0].copy(p);
    vertices[1].copy(h);
    vertices[2].copy(srcFile2);
    vertices[3].copy(realVal);
    vertices[4].copy(p);
    geometry.verticesNeedUpdate = true;
  }, drag.prototype.updateRegion = function() {
    var _minx = this.startX;
    var x = this.startX + this.distanceX;
    var height = this.startY;
    var y = this.startY + this.distanceY;
    var n = false;
    if (_minx > x) {
      var maxOur = _minx;
      _minx = x;
      x = maxOur;
      n = true;
    }
    if (height > y) {
      var chartHeight = height;
      height = y;
      y = chartHeight;
      n = true;
    }
    switch(this._areaPickType) {
      case textureTransAndScale0.Auto:
        this._realTimePicking = !n;
        break;
      case textureTransAndScale0.RealTime:
        this._realTimePicking = true;
        break;
      case textureTransAndScale0.NotRealTime:
        this._realTimePicking = false;
    }
    this.region = [_minx, height, x, y];
  }, drag.prototype.start = function(x, y) {
    var dx = x;
    var dy = y;
    var localPos = Th(x, y);
    x = localPos[0];
    y = localPos[1];
    this.initSprite();
    this.initLines();
    this.started = true;
    this.distanceX = 1;
    this.distanceY = 1;
    this.startX = x;
    this.startY = y;
    this.setSpritePosition(x, y);
    this.sprite.scale.set(1, 1, 1);
    var panels = this.sprite.children;
    var i = 0;
    for (; i < panels.length; i++) {
      panels[i].position.set(0, 0, 0);
    }
    this.sprite.visible = true;
    this.app.trigger(EventType.AreaPickStart);
    this.updateRegion();
    this.move(dx, dy);
  }, drag.prototype.move = function(mx, my) {
    var sprites = Th(mx, my);
    mx = sprites[0];
    my = sprites[1];
    this.distanceX = mx - this.startX;
    this.distanceY = my - this.startY;
    this.setSpritePosition(this.startX + this.distanceX / 2, this.startY + this.distanceY / 2);
    var m = this.distanceX ? this.distanceX : 1;
    var x = this.distanceY ? this.distanceY : 1;
    if (this.distanceX < 0) {
      m = m * -1;
    }
    if (this.distanceY < 0) {
      x = x * -1;
    }
    this.sprite.scale.set(m, x, 1);
    this.setSpriteLinePosition(this.sprite.position.x, this.sprite.position.y, m, x);
    this.spriteLineNode.visible = true;
    this.updateRegion();
  }, drag.prototype.end = function() {
    if (this.started) {
      this.started = false;
      if (this.sprite) {
        this.sprite.visible = false;
      }
      if (this.spriteLineNode) {
        this.spriteLineNode.visible = false;
      }
      this.app.trigger(EventType.AreaPickEnd);
    }
  }, drag.prototype.intersectPoint = function(m) {
    var c = m[0];
    var dest = m[1];
    var r = this.region;
    return !(c < r[0]) && (!(c > r[2]) && (!(dest < r[1]) && !(dest > r[3])));
  }, drag.prototype.intersectObject = function(object, count) {
    var camera = this.app.camera;
    var result = new THREE.Vector3;
    var ownedParams = (object.isBaseObject ? object.node : object).getMeshes();
    var oi = 0;
    for (; oi < ownedParams.length; oi++) {
      var object = ownedParams[oi];
      var geometry = object.geometry;
      var matrix = object.matrixWorld;
      if (geometry.isBufferGeometry) {
        var indices = geometry.index;
        var attribute = geometry.attributes.position;
        if (null !== indices) {
          var nullLength = Math.max(1, Math.floor(indices.count * count));
          j = 0;
          l = indices.count;
          for (; j < l; j = j + nullLength) {
            result.fromBufferAttribute(attribute, indices.getX(j));
            result.applyMatrix4(matrix);
            var matches = camera.worldToScreen(result);
            if (this.intersectPoint(matches)) {
              return true;
            }
          }
        } else {
          if (void 0 !== attribute) {
            var nullLength = Math.max(1, Math.floor(attribute.count * count));
            var j = 0;
            var l = attribute.count;
            for (; j < l; j = j + nullLength) {
              result.fromBufferAttribute(attribute, j);
              result.applyMatrix4(matrix);
              matches = camera.worldToScreen(result);
              if (this.intersectPoint(matches)) {
                return true;
              }
            }
          }
        }
      } else {
        if (geometry.isGeometry) {
          var vertices = geometry.vertices;
          var nullLength = Math.max(1, Math.floor(vertices.length * count));
          j = 0;
          l = vertices.length;
          for (; j < l; j = j + nullLength) {
            (result = vertices[j].clone()).applyMatrix4(matrix);
            matches = camera.worldToScreen(result);
            if (this.intersectPoint(matches)) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }, drag.prototype.processPicking = function(obj) {
    var interval = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .01;
    var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    var self = this.app.picker;
    var nonSearchParams = [];
    if (self._results.clear(), obj) {
      var i = 0;
      for (; i < obj.length; i++) {
        var p = obj[i];
        if (p.pickable && this.intersectObject(p, interval)) {
          self._results.add(p);
          var a = self.pickedResultFunc;
          if (a && !(p = a(p))) {
            continue;
          }
          if (!i && !self.areaCandidates.has(p)) {
            continue;
          }
          if (-1 === nonSearchParams.indexOf(p)) {
            nonSearchParams.push(p);
          }
        }
      }
    }
    return nonSearchParams;
  }, n(drag, [{
    key : "realTimePicking",
    get : function() {
      return this._realTimePicking;
    }
  }]), drag;
}();
Sh = function() {
  function t(value, defaultValue) {
    r(this, t);
    this.app = value;
    this.domElem = value.domElement;
    this._state = new Di;
    this._changed = false;
    this.intersect = null;
    this.dragIntersect = null;
    this.lastPickFrame = -1;
    this.lastPickPosition = null;
    this._pickedResultsFunc = null;
    this._pickedResultFunc = null;
    this._results = new xi(this.app);
    this._objects = new xi(this.app);
    this._previousObjects = new xi(this.app);
    this._tempObjects = [];
    this.pickingArea = new Ch(this.app);
    this._areaCandidates = new xi(this.app);
    this._areaPicking = false;
    this.cameraPickingGround = new yh(this.app);
    this.floorPickingGround = new yh(this.app);
    this._disableGPUPicker = false;
    this.gpuPicker = null;
    if (defaultValue) {
      this.gpuPicker = new vh(this.app, {
        debug : false
      });
    }
    this.enable = true;
    this.initEvents();
  }
  return t.prototype.initEvents = function() {
    var e = this;
    this.app.on("destroy", function(server) {
      var o = server.object;
      e._areaCandidates.remove(o);
    });
  }, t.prototype.getPickedObject = function(testName) {
    return this.app.objectManager.getBaseObject(testName);
  }, t.prototype.filter = function(arr, params) {
    if (null == arr) {
      return null;
    }
    var results = [];
    var x = [];
    var i = 0;
    for (; i < arr.length; i++) {
      var o = arr[i];
      var source = o.object;
      if (!source.userData.skipPick) {
        var data = this.getPickedObject(source);
        if (data) {
          if (!data.node.userData.skipPick) {
            if (this._results.add(data), this._pickedResultFunc && !params) {
              var opts = this._pickedResultFunc(data);
              if (!opts) {
                continue;
              }
              o.node = opts.node;
              o.object = this.app.objectManager.getBaseObject(opts.node);
            }
            if (!this._pickedResultsFunc || params) {
              x = [o];
              break;
            }
            if (-1 === results.indexOf(data)) {
              results.push(data);
            }
            x.push(o);
          }
        }
      }
    }
    if (this._pickedResultsFunc && !params) {
      var result = {
        objects : results,
        result : null
      };
      if (this._pickedResultsFunc(result), result.result) {
        var tag_iter = results.indexOf(result.result);
        if (-1 !== tag_iter) {
          x = [x[tag_iter]];
        }
      }
    }
    return x[0];
  }, t.prototype.isTopSprite = function(scope) {
    return !scope.material.depthTest;
  }, t.prototype.sortIntersectObjects = function(deletedIds) {
    var Pickit = this;
    deletedIds.sort(function(a, b) {
      var target = a.object;
      var item = b.object;
      var sprite = target.userData;
      var w = item.userData;
      if (!sprite.topNode && w.topNode) {
        return -1;
      }
      if (sprite.topNode && !w.topNode) {
        return 1;
      }
      if (sprite.subNode && !w.subNode) {
        return -1;
      }
      if (!sprite.subNode && w.subNode) {
        return 1;
      }
      if (target.isSprite) {
        if (Pickit.isTopSprite(target) && !item.isSprite) {
          return -1;
        }
      } else {
        if (item.isSprite) {
          if (Pickit.isTopSprite(item) && !target.isSprite) {
            return 1;
          }
        } else {
          var material = target.material;
          var m = item.material;
          if (material.depthTest && !m.depthTest) {
            return 1;
          }
          if (!material.depthTest && m.depthTest) {
            return -1;
          }
        }
      }
      return a.distance - b.distance;
    });
  }, t.prototype.pickIntersectObjects = function(result, min, value, name) {
    var contents = [];
    if (min = this._disableGPUPicker || min, this.gpuPicker && !min) {
      var comment = this.app.objectManager.interactableNodes;
      if (comment.length) {
        contents = result.intersectEnsureVisibleObjects(comment, true, this.app.renderCamera);
      }
      var message = this.gpuPicker.pick(this.app.renderCamera, value, name, result);
      if (message) {
        contents.push(message);
      }
    } else {
      contents = result.intersectObject(this.app.scene, true);
      var i = 0;
      for (; i < contents.length; i++) {
        var tree = contents[i].object;
        var m = tree.material;
        if (!(m.opacity && m.visible && Mh(tree))) {
          contents.splice(i--, 1);
        }
      }
    }
    return contents;
  }, t.prototype.__isSameFrame = function(object, propertyName, propertiesWithFilters) {
    return !propertiesWithFilters && (this.lastPickFrame == this.app.currentFrameCount && (!!this.lastPickPosition && (this.lastPickPosition[0] == object && this.lastPickPosition[1] == propertyName)));
  }, t.prototype._isSameFrame = function(it, id, styles) {
    return !!this.__isSameFrame(it, id, styles) || (this.lastPickPosition = this.lastPickPosition || [0, 0], this.lastPickPosition = [it, id], this.lastPickFrame = this.app.currentFrameCount, false);
  }, t.prototype.intersectObject = function(object, id, opts) {
    var r = opts.disableGPUPicker;
    var value = opts.ignoreFrameCheck;
    var cb = opts.ignoreFilter;
    if (opts.forceUpdateTexture) {
      var aAddon = this.gpuPicker;
      if (aAddon) {
        aAddon.forceUpdate = true;
      }
    }
    if (this._pickedResultsFunc && (r = true), !this.enable) {
      return null;
    }
    if (this._isSameFrame(object, id, value)) {
      return this.intersect;
    }
    this.intersect = null;
    this._results.clear();
    var handler = Th(object, id);
    object = handler[0];
    id = handler[1];
    var end = this.app.calcRect();
    var body = this.app.renderCamera.getRaycaster(object, id, end);
    var result = this.pickIntersectObjects(body, r, object, id);
    if (null == result || 0 == result.length) {
      return null;
    }
    this.sortIntersectObjects(result);
    var options = this.filter(result, cb);
    if (options) {
      this.intersect = options;
      this.intersect.object = this.getPickedObject(options.node || options.object);
      this.intersect.ignoreFilter = true;
    } else {
      this.intersect = result;
      this.intersect.ignoreFilter = false;
    }
    var cur = this.intersect.point;
    return cur && cur.isVector3 && (this.intersect.point = cur.toArray()), this.intersect;
  }, t.prototype.showPickingGround = function() {
    var showBoneHandles = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    this.cameraPickingGround.visible = showBoneHandles;
  }, t.prototype.processGroundPicking = function(e, f) {
    if (!this.app.isInScreen([e, f])) {
      return null;
    }
    var options = this.app.camera;
    return this.app.renderCamera.updateMatrixWorld(), this.cameraPickingGround.update(options.position, options.target), this.cameraPickingGround.intersect(e, f);
  }, t.prototype.processPicking = function(data) {
    var view = new THREE.Vector2;
    view.x = data.clientX;
    view.y = data.clientY;
    var center = data.offset;
    if (center) {
      view.x += center[0];
      view.y += center[1];
    }
    var value = this.intersectObject(view.x, view.y, data);
    return null == value ? null : (data.intersect = value, data.object = value.object, data.id = Utils.isArray(value) ? value[0].id : value.id, data.picked = true, data.ignoreFilter = value.ignoreFilter, Object.defineProperties(data, {
      pickedPosition : {
        get : function() {
          var e = this.intersect.pickedPosition || this.intersect.point;
          return e || this.intersect.length && (e = this.intersect[0].pickedPosition), e;
        }
      }
    }), data.pickedObj = data.object, data.getPickedPos = function() {
      return THING.Utils.warn("Please use .getPickedPosition() to replace .getPickedPos()"), data.getPickedPosition();
    }, data.getPickedPosition = function() {
      return THING.Utils.warn("Please use .pickedPosition to replace .getPickedPosition()"), data.pickedPosition;
    }, value);
  }, t.prototype.removePickingResources = function(o) {
    if (this.gpuPicker) {
      this.gpuPicker.removePickingResources(o);
    }
  }, t.prototype.markPickingNode = function(propLookup) {
    if (this.gpuPicker) {
      this.gpuPicker.markPickingNode(propLookup);
    }
  }, t.prototype.notifyChanged = function() {
    this.app.trigger(EventType.PickChange, {
      objects : this._objects,
      previousObjects : this._previousObjects
    });
    var pendingReads = this._objects.concat(this._previousObjects);
    var i = 0;
    for (; i < pendingReads.length; i++) {
      pendingReads[i].trigger(EventType.PickChange, {
        objects : this._objects,
        previousObjects : this._previousObjects
      });
    }
    this._previousObjects.buildReturnObject(this._objects);
  }, t.prototype.update = function(v) {
    var t = function() {
      if (mh && void 0 !== mh.checkAuthRet) {
        var e = mh.checkAuthRet;
        return mh.checkAuthRet = void 0, e;
      }
    }();
    if (void 0 !== t) {
      if (t) {
        this.app.trigger("authSuccessed");
      } else {
        this.app.trigger("authFailed");
      }
    }
    if (this.enable) {
      if (this.gpuPicker) {
        this.gpuPicker.update(v);
      }
      if (this._changed) {
        this.notifyChanged();
        this._changed = false;
      }
    }
  }, t.prototype.resize = function(content, object) {
    if (this.gpuPicker) {
      this.gpuPicker.resizeTexture(content, object);
    }
  }, t.prototype.render = function(value) {
    if (this.gpuPicker) {
      this.gpuPicker.render(value);
    }
  }, t.prototype.hasPicked = function(event, container) {
    if (!container) {
      return false;
    }
    if (!this.intersect) {
      return false;
    }
    var node = this.intersect.object;
    if (!node) {
      return false;
    }
    if (node != container) {
      if (event._stopPropagation) {
        return false;
      }
      if (!node.isChildOf(container)) {
        return false;
      }
    }
    return true;
  }, t.prototype.setPickedObject = function(obj, type, params) {
    var query = this;
    if (this._tempObjects.length = 0, obj) {
      if (obj.isBaseObject && this._objects.has(obj)) {
        return;
      }
      var data = [];
      if ((data = Utils.isArray(obj) ? obj.map(function(state) {
        return {
          object : state.node
        };
      }) : obj.isSelector ? obj.toArray().map(function(state) {
        return {
          object : state.node
        };
      }) : [{
        object : obj.node
      }]).length > 1) {
        data.forEach(function(node) {
          if (query.filter([node], params)) {
            var id = node.object;
            if (id) {
              if (id.isBaseObject) {
                query._tempObjects.push(node.object);
              } else {
                var todo = query.app.objectManager.getBaseObject(id);
                if (todo) {
                  query._tempObjects.push(todo);
                }
              }
            }
          }
        });
        obj = this._tempObjects.length > 1 ? this._tempObjects : this._tempObjects[0];
      } else {
        if (!this.filter(data, params)) {
          return false;
        }
        if (data[0].object && data[0].object.isBaseObject) {
          obj = data[0].object;
        }
      }
    }
    var i = 0;
    for (; i < this._objects.length; i++) {
      var obj = this._objects[i];
      obj.trigger(EventType.Unpick);
      this.app.trigger(EventType.Unpick, {
        object : obj
      });
    }
    return this._objects.clear(), obj && (this._objects.add(obj), Utils.isArray(obj) && obj.length ? obj.forEach(function(player) {
      player.trigger(EventType.Pick);
    }) : obj.trigger(EventType.Pick)), this.app.trigger(EventType.Pick, {
      object : obj instanceof BaseObject ? obj : null,
      objects : this._objects,
      previousObjects : this._previousObjects
    }), this._previousObjects.equals(this._objects) || (this._changed = true), type && obj && (type.object = obj), true;
  }, t.prototype.isChanged = function() {
    return this._changed;
  }, t.prototype.intersectResult = function(a, b, i, result) {
    if (result = result || {}, void 0 === a || void 0 === b) {
      var octets_src = this.app.camera.worldToScreen(this.app.camera.target);
      a = octets_src[0];
      b = octets_src[1];
    }
    var options = {
      clientX : a,
      clientY : b,
      offset : i,
      disableGPUPicker : Utils.parseValue(result.disableGPUPicker, false),
      ignoreFrameCheck : Utils.parseValue(result.ignoreFrameCheck, true),
      ignoreFilter : Utils.parseValue(result.ignoreFilter, true)
    };
    var hookupOptions = this.processPicking(options);
    return hookupOptions ? (options.getPickedPosition = function() {
      var renderedScope = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
      return hookupOptions.getPickedPosition ? hookupOptions.getPickedPosition(renderedScope) : [0, 0, 0];
    }, delete options.offset, delete options.disableGPUPicker, delete options.ignoreFrameCheck, delete options.ignoreFilter, options) : {
      picked : false,
      pickedPosition : null,
      object : null
    };
  }, t.prototype.pickObjects = function(x, y, value, i, n) {
    if (void 0 === value && void 0 === i) {
      if (void 0 === x || void 0 === y) {
        var currDot = this.app.camera.worldToScreen(this.app.camera.position);
        x = currDot[0];
        y = currDot[1];
      }
      var type = this.app.calcRect();
      var d = this.app.renderCamera.getRaycaster(x, y, type);
      var a = this.pickIntersectObjects(d, false, x, y);
      var result = [];
      var i = 0;
      for (; i < a.length; i++) {
        var object = a[i].object;
        if (!object.userData.isDebuggerNode) {
          var _object = this.app.objectManager.getBaseObject(object);
          if (_object) {
            result.push({
              object : _object,
              node : object
            });
          }
        }
      }
      return result;
    }
    return this.pickingArea.startX = x, this.pickingArea.startY = y, this.pickingArea.distanceX = value, this.pickingArea.distanceY = i, this.pickingArea.updateRegion(), this.pickingArea.processPicking(n, .01, true);
  }, t.prototype.pickWorldPosition = function(n2, e, f) {
    return this.intersectResult(n2, e, f).pickedPosition;
  }, t.prototype.startAreaPicking = function(input) {
    var id = (input = input || {}).x;
    var i = input.y;
    var r = Utils.parseValue(input.realTimePicking, true);
    var showBoneHandles = Utils.parseValue(input.drawRegion, true);
    if (Utils.isNumber(id) && Utils.isNumber(i)) {
      this.app.camera.disable({
        rotate : true
      });
      this.pickingArea.start(id, i);
      this.pickingArea._areaPickType = r ? textureTransAndScale0.RealTime : textureTransAndScale0.NotRealTime;
      this.pickingArea.sprite.visible = showBoneHandles;
      this.pickingArea.spriteLineNode.visible = showBoneHandles;
      this._areaPicking = true;
    }
  }, t.prototype.endAreaPicking = function() {
    if (this.areaPicking) {
      this.pickingArea.end();
      this.pickingArea._areaPickType = textureTransAndScale0.Auto;
      this.app.camera.resume({
        rotate : true
      });
      var e = this;
      setTimeout(function() {
        e._areaPicking = false;
      }, 10);
    }
  }, t.prototype.pick = function(value, key) {
    var rows = this.pickObjects(value, key);
    if (!rows.length) {
      return null;
    }
    var result = {
      object : rows[0].object,
      node : rows[0].node
    };
    return Object.defineProperty(result, "pickedPosition", {
      get : function() {
        return null;
      }
    }), result;
  }, t.prototype._enable = function(name, value, type) {
    this._state.enable(name, value, type);
  }, n(t, [{
    key : "pickerState",
    get : function() {
      return bh.instance;
    }
  }, {
    key : "enable",
    set : function(v) {
      this._enable(v, "default", 100);
    },
    get : function() {
      return this._state.isEnable();
    }
  }, {
    key : "disableGPUPicker",
    set : function(v) {
      this._disableGPUPicker = v;
    }
  }, {
    key : "areaPicking",
    get : function() {
      return !!this.enable && this._areaPicking;
    }
  }, {
    key : "forceUpdate",
    set : function(v) {
      if (this.gpuPicker) {
        this.gpuPicker.forceUpdate = v;
      }
    }
  }, {
    key : "needUpdate",
    set : function(v) {
      if (this.gpuPicker) {
        this.gpuPicker.needUpdate = v;
      }
    }
  }, {
    key : "areaCandidates",
    set : function(v) {
      this._areaCandidates.buildReturnObject(v);
    },
    get : function() {
      return this._areaCandidates;
    }
  }, {
    key : "pickedResultsFunc",
    set : function(v) {
      this._pickedResultsFunc = v;
    },
    get : function() {
      return this._pickedResultsFunc;
    }
  }, {
    key : "pickedResultFunc",
    set : function(v) {
      this._pickedResultFunc = v;
    },
    get : function() {
      return this._pickedResultFunc;
    }
  }, {
    key : "results",
    get : function() {
      return this._results;
    }
  }, {
    key : "objects",
    get : function() {
      return this._objects;
    }
  }, {
    key : "previousObjects",
    get : function() {
      return this._previousObjects;
    }
  }, {
    key : "needTracelessRendering",
    set : function(v) {
      if (this.gpuPicker) {
        this.gpuPicker.needTracelessRendering = v;
      }
    }
  }, {
    key : "filterPickedResultsFunc",
    set : function(v) {
      THING.Utils.warn("[Picker] please use .pickedResultsFunc instead");
      this.pickedResultsFunc = v;
    },
    get : function() {
      return THING.Utils.warn("[Picker] please use .pickedResultsFunc instead"), this.pickedResultsFunc;
    }
  }, {
    key : "pickedObjectFunc",
    set : function(v) {
      THING.Utils.warn("[Picker] please use .pickedResultFunc instead");
      this.pickedResultFunc = v;
    },
    get : function() {
      return THING.Utils.warn("[Picker] please use .pickedResultFunc instead"), this.pickedResultFunc;
    }
  }, {
    key : "enabled",
    set : function(value) {
      THING.Utils.warn("[Picker] please use .enable instead");
      this.enable = value;
    },
    get : function() {
      return THING.Utils.warn("[Picker] please use .enable instead"), this.enable;
    }
  }, {
    key : "candidates",
    set : function(v) {
      THING.Utils.warn("[Picker] please use .areaCandidates instead");
      this.areaCandidates = v;
    },
    get : function() {
      return THING.Utils.warn("[Picker] please use .areaCandidates instead"), this.areaCandidates;
    }
  }]), t;
}();
jh = function() {
  function t(app) {
    r(this, t);
    this.app = app;
    this._objects = new xi(this.app);
    this._previousObjects = new xi(this.app);
    this._changed = false;
  }
  return t.prototype.notifyChanged = function() {
    this.app.trigger(EventType.SelectionChange, {
      objects : this._objects,
      previousObjects : this._previousObjects
    });
    var obj = this;
    this._objects.forEach(function(player) {
      player.trigger(EventType.SelectionChange, {
        objects : obj._objects,
        previousObjects : obj._previousObjects
      });
    });
    this._previousObjects.buildReturnObject(this._objects);
  }, t.prototype.update = function() {
    if (this._changed) {
      this.notifyChanged();
      this._changed = false;
    }
  }, t.prototype.select = function(obj) {
    if (obj) {
      this._objects.add(obj);
      obj.trigger(EventType.Select, {
        objects : this._objects
      });
      this.app.trigger(EventType.Select, {
        object : obj,
        objects : this._objects
      });
      this._changed = true;
    }
  }, t.prototype.deselect = function(obj) {
    if (obj) {
      this._objects.remove(obj);
      var objs = new xi(this.app);
      if (obj.isBaseObject) {
        objs.add(obj);
      } else {
        objs = obj;
      }
      var o = 0;
      for (; o < objs.length; o++) {
        (obj = objs[o]).trigger(EventType.Deselect, {
          objects : objs
        });
      }
      this.app.trigger(EventType.Deselect, {
        object : obj,
        objects : objs
      });
      this._changed = true;
    }
  }, t.prototype.has = function(obj) {
    return this._objects.has(obj);
  }, t.prototype.clear = function() {
    if (this._objects.length) {
      var i = 0;
      for (; i < this._objects.length; i++) {
        var t = this._objects[i];
        t.trigger(EventType.Deselect, {
          object : t,
          objects : this._objects
        });
      }
      this.app.trigger(EventType.Deselect, {
        object : this._objects[this._objects.length - 1],
        objects : this._objects
      });
      this._objects.clear();
      this._changed = true;
    }
  }, t.prototype.isChanged = function() {
    return this._changed;
  }, t.prototype.onUpdate = function(e) {
    this.update(e);
  }, n(t, [{
    key : "objects",
    get : function() {
      return this._objects;
    }
  }, {
    key : "previousObjects",
    get : function() {
      return this._previousObjects;
    }
  }]), t;
}();
Ph = new THREE.Frustum, Rh = new THREE.Matrix4, Dh = function(b) {
  function update(idx, object, constructor) {
    r(this, t);
    var result = s(this, b.call(this, idx));
    return result.node = object, result.projectionType = kkkk.Perspective, result.controller = constructor, result.followingObject = null, result.lookingObject = null, result._near = result.node.near, result._far = result.node.far, result.addControl(new THING.CameraControl, "cameraControl"), result;
  }
  return o(t, b), update.prototype.worldToScreen = function(a) {
    if (!a) {
      return null;
    }
    if (a.isBaseObject) {
      a = a.boundingBox.center;
      THING.Utils.warn("[Camera] please use '.worldToScreen(object.boundingBox.center)' to get screen position");
    }
    var p = Utils.parseVector3(a);
    p.project(this.node);
    var w = this.app.renderer.getContext().canvas.width / 2;
    var minLatency = this.app.renderer.getContext().canvas.height / 2;
    var touchesY = Math.round(p.x * w + w);
    var touchesX = Math.round(-p.y * minLatency + minLatency);
    var touchesLength = this.app.renderer.getPixelRatio();
    return [touchesY = touchesY / touchesLength, touchesX = touchesX / touchesLength, p.z];
  }, update.prototype.screenToWorld = function(arg, name) {
    if (Utils.isArray(arg) && void 0 === name) {
      var args = arg;
      arg = args[0];
      name = args[1];
    }
    var info = this.app.picker.processGroundPicking(arg, name);
    return info ? info.point.toArray() : this.unprojectScreenToWorld(arg, name);
  }, update.prototype.unprojectScreenToWorld = function(f, t, depth) {
    if (Utils.isArray(f) && void 0 === t) {
      var s = f;
      f = s[0];
      t = s[1];
    }
    var r = this.app.renderer.getPixelRatio();
    t = t * r;
    var x = (f = f * r) / this.app.renderer.getContext().canvas.width * 2 - 1;
    var y = -t / this.app.renderer.getContext().canvas.height * 2 + 1;
    return depth = depth || -1, (new THREE.Vector3(x, y, depth)).unproject(this.node).toArray();
  }, update.prototype.lerpToPerspective = function(e, exceptionLevel) {
    this.projectionType = kkkk.Perspective;
    this.node.lerpToPerspective(e, exceptionLevel);
  }, update.prototype.lerpToOrthographic = function(i, a, v, callback) {
    this.projectionType = kkkk.Orthographic;
    this.node.lerpToOrthographic(i, a, v, callback);
  }, update.prototype.setSize = function(x, h) {
    this.node.setSize(x, h);
  }, update.prototype.stopFlying = function(e) {
    var control = this.getControl("cameraControl");
    if (control) {
      control.stopFlying(e);
    }
  }, update.prototype.flyTo = function(options) {
    var control = this.getControl("cameraControl");
    if (control) {
      this.app.setCurrentHTMLMarker(null);
      control.flyTo(options);
    }
  }, update.prototype.lookAt = function(target) {
    var leftBox = this.getControl("cameraControl");
    if (leftBox) {
      return leftBox.lookAt(target);
    }
  }, update.prototype.followObject = function(options) {
    var control = this.getControl("cameraControl");
    if (control) {
      control.followObject(options);
    }
  }, update.prototype.stopFollowingObject = function() {
    var details = this.getControl("cameraControl");
    if (details) {
      details.stopFollowingObject();
    }
  }, update.prototype.movePath = function(path) {
    var ctl = this.getControl("cameraControl");
    if (ctl) {
      ctl.movePath(path);
    }
  }, update.prototype.rotateAround = function(p) {
    var camera = this.getControl("cameraControl");
    if (camera) {
      camera.rotateAround(p);
    }
  }, update.prototype._stopRotating = function() {
    b.prototype.stopRotating.call(this);
  }, update.prototype.stopRotating = function(e) {
    var control = this.getControl("cameraControl");
    if (control) {
      control.stopRotating(e);
    }
  }, update.prototype.rotate = function(data) {
    var control = this.getControl("cameraControl");
    if (control) {
      control.rotate(data);
    }
  }, update.prototype.rotateX = function(theta) {
    this.rotate([theta, 0, 0]);
  }, update.prototype.rotateY = function(angle) {
    if (this.controller instanceof THREE.EarthOrbitControls) {
      var t = new THREE.Vector3;
      t.copy(this.controller.object.position);
      t.normalize();
      this.controller.object.rotateOnWorldAxis(t, THING.Math.degToRad(angle));
      this.controller._isCameraStatic = false;
      var srcFile2 = this.controller._getIntersectPoint();
      this.controller._isCameraStatic = true;
      this.controller.target.copy(srcFile2);
    } else {
      this.rotate([0, angle, 0]);
    }
  }, update.prototype.rotateZ = function(a) {
    this.rotate([0, 0, a]);
  }, update.prototype.isInView = function(options) {
    return !(!options || !options.isBaseObject) && this.node.isInView(options.boundingBox.toBox());
  }, update.prototype._setPosition = function(value) {
    this.node.position.fromArray(value);
  }, n(t, [{
    key : "frustum",
    get : function() {
      return Rh.multiplyMatrices(this.node.projectionMatrix, this.node.matrixWorldInverse), Ph.setFromProjectionMatrix(Rh), Ph;
    }
  }, {
    key : "flying",
    get : function() {
      var details = this.getControl("cameraControl");
      return !!details && details.isFlying();
    }
  }, {
    key : "isPerspectiveCamera",
    get : function() {
      return this.node.isPerspectiveCamera;
    }
  }, {
    key : "fov",
    set : function(a) {
      this.node.setFov(a);
    },
    get : function() {
      return this.node.fov;
    }
  }, {
    key : "near",
    set : function(a) {
      this._near = a;
      this.node.setNear(a);
    },
    get : function() {
      return this._near;
    }
  }, {
    key : "far",
    set : function(a) {
      this._far = a;
      this.node.setFar(a);
    },
    get : function() {
      return this._far;
    }
  }, {
    key : "up",
    set : function(v) {
      this.node.up.fromArray(v);
    },
    get : function() {
      return this.node.up.toArray();
    }
  }, {
    key : "position",
    set : function(v) {
      this._setPosition(v);
    },
    get : function() {
      return this.node.position.toArray();
    }
  }, {
    key : "target",
    set : function(value) {
      var details = this.getControl("cameraControl");
      if (details) {
        details.setTarget(value);
      }
    },
    get : function() {
      return this.controller.target.toArray();
    }
  }, {
    key : "distance",
    set : function(x) {
      var a = Utils.parseVector3(this.position);
      var target = Utils.parseVector3(this.target);
      var result = new THREE.Vector3;
      result.subVectors(a, target);
      result.normalize();
      result.multiplyScalar(x);
      target.add(result);
      this.position = target.toArray();
    },
    get : function() {
      var p = Utils.parseVector3(this.position);
      var pos = Utils.parseVector3(this.target);
      return p.distanceTo(pos);
    }
  }, {
    key : "direction",
    get : function() {
      var _beg = Utils.parseVector3(this.position);
      var _end = Utils.parseVector3(this.target);
      var _axis = new THREE.Vector3;
      return _axis.subVectors(_end, _beg), _axis.normalize(), _axis.toArray();
    }
  }, {
    key : "rightDirection",
    get : function() {
      var normalVector = THING.Utils.parseVector3(this.direction);
      var randVect = THING.Utils.parseVector3(this.up);
      var retVector = new THREE.Vector3;
      return retVector.crossVectors(normalVector, randVect), retVector.normalize(), retVector.toArray();
    }
  }]), t;
}(BaseObject);
Ah = function() {
  function self(object) {
    var renderer = this;
    r(this, self);
    this.app = object;
    this.picker = object.picker;
    this.orbit = new THREE.OrbitControls(this.app.renderCamera, this.app.mainDomElement);
    this.curOrbit = this.orbit;
    this.initOrbit(this.orbit);
    this.cameraObject = new Dh(this.app, this.app.renderCamera, this.orbit);
    this.toggleBackupInfo = {};
    this.zoomTween = null;
    this._autoAdjustNear = true;
    this._autoAdjustTarget = true;
    this._autoHideObjectsWhenRotatingFunc = null;
    this._enableUpdateTargetOnWheel = true;
    this._enableZoomOnTarget = false;
    this._wheelOnMouseTargetScale = 3;
    this._wheelOnMouseTargetPosition = null;
    this._autoFixCameraUp = true;
    this._wheeling = false;
    this._hadEnabledPicking = false;
    this._targetObject = null;
    this._inputEnableFlag = new $i(function(userEnabled) {
      renderer.curOrbit.enabled = userEnabled;
    });
    this._panEnableFlag = new $i(function(b) {
      if ("normal" == renderer.mode) {
        renderer.curOrbit.enablePan = b;
      } else {
        renderer.curOrbit.enableRotate = b;
      }
    });
    this._rotateEnableFlag = new $i(function(b) {
      if ("normal" == renderer.mode) {
        renderer.curOrbit.enableRotate = b;
      } else {
        renderer.curOrbit.enablePan = b;
      }
    });
    this._zoomEnableFlag = new $i(function(value) {
      renderer.curOrbit.enableZoom = value;
    });
    if (this.cameraObject.isPerspectiveCamera) {
      this.cameraFov = this.cameraObject.fov;
      this.cameraNear = this.cameraObject.near;
      this.cameraFar = this.cameraObject.far;
    }
    var n = this;
    if (this.app.on("backgroundChanged", function(options) {
      var self = n.toggleBackupInfo.toggleSkyBox;
      if (self) {
        self.background = options.background;
      }
    }), this.prevPosition = [0, 0, 0], this.prevTarget = [0, 0, 0], !(this.orbit instanceof THREE.EarthOrbitControls)) {
      var val = new THREE.Box3;
      this._targetBoundary = val;
      this.curOrbit.target.add = function(cmd) {
        THREE.Vector3.prototype.add.call(this, cmd);
        if (!val.isEmpty()) {
          this.clamp(val.min, val.max);
        }
      };
      this.curOrbit.target.addScaledVector = function(newC, refC) {
        THREE.Vector3.prototype.addScaledVector.call(this, newC, refC);
        if (!val.isEmpty()) {
          this.clamp(val.min, val.max);
        }
      };
      this.curOrbit.target.set = function(x, t, z) {
        if (!val.isEmpty()) {
          if (val.min.x > x || val.max.x < x) {
            return;
          }
          if (val.min.y > t || val.max.y < t) {
            return;
          }
          if (val.min.z > z || val.max.z < z) {
            return;
          }
        }
        THREE.Vector3.prototype.set.call(this, x, t, z);
      };
    }
  }
  return self.prototype.initOrbit = function(scope) {
    scope.minDistance = 1e-4;
    scope.minZoom = .15;
    scope.maxZoom = 8;
    scope.autoRotate = false;
    scope.enableDamping = true;
    scope.minPolarAngle = 0;
    if (!(scope instanceof THREE.EarthOrbitControls)) {
      scope.maxPolarAngle = Math.PI;
    }
    scope.keyPanSpeed = .1;
    scope.panSpeed = .1;
    scope.rotateSpeed = .07;
    scope.dampingFactor = .078;
    scope.screenSpacePanning = true;
    scope.enabled = true;
    this.registerOrbitEvents(scope);
  }, self.prototype.registerOrbitEvents = function(emitter) {
    var self = this;
    emitter.addEventListener("mousedownpanevent", function(elements) {
      self.onMouseDownPanEvent(elements);
    });
    emitter.addEventListener("mouseuppanevent", function(elements) {
      self.onMouseUpPanEvent(elements);
    });
    emitter.addEventListener("mousemoveevent", function(mouseX) {
      self.onMouseMoveEvent(mouseX);
    });
    emitter.addEventListener("start", function(event) {
      self.onStart(event);
    });
    emitter.addEventListener("end", function(e) {
      self.onEnd(e);
    });
    emitter.addEventListener("wheel", function(delta) {
      self.onWheel(delta);
    });
    emitter.addEventListener("change", function(e) {
      self.onChange(e);
    });
  }, self.prototype.isCameraController = function() {
    return true;
  }, self.prototype._zoom = function(value, direction, speed) {
    if (this.zoomTween) {
      this.zoomTween.stop();
    }
    var self = this;
    this.zoomTween = (new TWEEN.Tween({
      zoom : value
    })).to({
      zoom : direction
    }, speed).easing(TWEEN.Easing.Linear.None).onUpdate(function() {
      self._rotateEnableFlag.lock(false, "_zoom");
      self.curOrbit.object.zoom = this._object.zoom;
      self.curOrbit.object.updateProjectionMatrix();
      if (self.app.postEffect.postEffect.enable) {
        self.app.needUpdate = true;
      }
    }).onComplete(function() {
      self._rotateEnableFlag.unlock("_zoom");
    }).start();
  }, self.prototype._change = function(name) {
    this.app.trigger(name, {
      position : this.position,
      target : this.target
    });
  }, self.prototype._autoFixTarget = function() {
    var node = this.curOrbit;
    if (node.target.distanceTo(node.object.position) > 5) {
      return false;
    }
    var t = new THREE.Vector3(0, 0, 0);
    t.subVectors(node.target, node.object.position).normalize();
    var extents = t.multiplyScalar(10);
    var p = new THREE.Vector3(0, 0, 0);
    return p.addVectors(node.object.position, extents), node.target.set(p.x, p.y, p.z), true;
  }, self.prototype._processWheelOnMouseTarget = function(e) {
    var particle = this.app.renderCamera;
    var terrainImagery = this.curOrbit;
    var cssChanges = this.app.calcRect();
    var i = cssChanges.width / 2;
    var tag = cssChanges.height / 2;
    var pointerAbs = this.app.getClientPosition(e);
    if (!(p = this._getIntersectPosition(pointerAbs.x, pointerAbs.y))) {
      p = this.cameraObject.unprojectScreenToWorld(pointerAbs.x, pointerAbs.y, .5);
    }
    var pos = this._getIntersectPosition(i, tag);
    if (!pos) {
      pos = this.cameraObject.unprojectScreenToWorld(i, tag, .5);
    }
    var p = Utils.parseVector3(p);
    var str = Utils.parseVector3(this.position);
    this._wheelOnMouseTargetPosition = p.toArray();
    var perpForce = particle.position.distanceTo(p) / 100;
    perpForce = perpForce * this._wheelOnMouseTargetScale;
    p.sub(str).normalize().multiplyScalar(perpForce);
    if (e.delta < 0) {
      particle.position.x += p.x;
      particle.position.y += p.y;
      particle.position.z += p.z;
    } else {
      particle.position.x -= p.x;
      particle.position.y -= p.y;
      particle.position.z -= p.z;
    }
    terrainImagery.target.x = pos[0];
    terrainImagery.target.y = pos[1];
    terrainImagery.target.z = pos[2];
    this.app.needUpdate = true;
  }, self.prototype._intersectObject = function(v, cb) {
    var to = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
    var AFTER = this.app.calcRect();
    var after = this.app.renderCamera.getRaycaster(v, cb, AFTER);
    var result = this.app.picker.pickIntersectObjects(after, false, v, cb);
    if (!result.length) {
      return null;
    }
    var QuickBase = this.app.picker.floorPickingGround;
    var i = 0;
    for (; i < result.length; i++) {
      var val = result[i].object;
      if (QuickBase.isMeshOf(val) || val.userData.__debugObject__) {
        result.splice(i--, 1);
      }
    }
    if (result.length) {
      var u = this.app.objectManager.getBaseObject(result[0].node);
      if (u) {
        var i = result[0].getPickedPosition();
        if (to) {
          return i;
        }
        var target = this.target;
        var p = this.position;
        var direction = this.direction;
        var distance = this.distance;
        var dij = THING.Math.getDistance(i, p);
        var t = THING.Math.getDistance(i, target);
        if (distance >= dij) {
          t = t * -1;
        }
        var j = THING.Math.addVector(target, THING.Math.scaleVector(direction, t));
        var a = THING.Math.getDistance(p, j);
        var b = this.distanceLimited;
        return a <= b[0] || a >= b[1] ? null : j;
      }
    }
    return null;
  }, self.prototype._getIntersectPosition = function(e, t) {
    var args = this._intersectObject(e, t, true);
    if (args) {
      return args.isVector3 ? args.toArray() : args;
    }
    var AFTER = this.app.calcRect();
    var after = this.app.renderCamera.getRaycaster(e, t, AFTER);
    var end = this.app.picker.floorPickingGround.intersectByRaycaster(after);
    return end ? end.point.toArray() : null;
  }, self.prototype._adjustTargetStrictly = function() {
    var cssChanges = this.app.calcRect();
    var obj = cssChanges.width / 2;
    var finishPageSet = cssChanges.height / 2;
    var obj_id = this._intersectObject(obj, finishPageSet, false);
    if (obj_id) {
      this.target = obj_id;
    }
  }, self.prototype.onMouseDownPanEvent = function(a) {
    if (this._autoAdjustTarget) {
      this._adjustTargetStrictly();
    }
  }, self.prototype.onMouseUpPanEvent = function(a) {
  }, self.prototype.onMouseMoveEvent = function(pointX) {
    this._change("cameraChangeMouseMove");
  }, self.prototype.onStart = function(event) {
    if (this.flying) {
      this._hadEnabledPicking = false;
    } else {
      this._hadEnabledPicking = true;
      this.app.picker._enable(false, "onStart", 1e3);
    }
    this.prevPosition = this.position;
    this.prevTarget = this.target;
    this._change("cameraChangeStart");
    this._change("cameraControllerChangeStart");
  }, self.prototype.onEnd = function(instance) {
    if (this._hadEnabledPicking) {
      this._hadEnabledPicking = false;
      this.app.picker._enable(true, "onStart", 0);
    }
    var t = this.position;
    var target = this.target;
    if (!(THING.Math.equalsVector(this.prevPosition, t, .01) && THING.Math.equalsVector(this.prevTarget, target, .01))) {
      this._change("cameraChangeEnd");
      this._change("cameraControllerChangeEnd");
    }
    this.prevPosition = t;
    this.prevTarget = target;
  }, self.prototype.onWheel = function(e) {
    if (this._enableUpdateTargetOnWheel) {
      this._autoFixTarget();
    }
    this._change("cameraChangeStart");
    this._wheeling = true;
    this.app.trigger("camerazoom", {
      delta : e.delta
    });
  }, self.prototype.onChange = function(fn) {
    this.app.trigger("cameracontrollerchanged");
    this._change("cameraChange");
    if (this._wheeling) {
      this._wheeling = false;
      this._change("cameraChangeEnd");
    }
    var args = this.cameraObject;
    if (args && args.projectionType === kkkk.Orthographic) {
      var MONTH = 2 * Math.tan(args.fov / 2 * Math.PI / 180);
      var opts = {
        z : args.distance,
        depth : MONTH
      };
      args.node.orthoSize = opts;
      args.node.toOrthographic();
    }
  }, self.prototype.zoomIn = function(event) {
    var descmain = event.zoom || 1;
    var fn = event.time || 1e3;
    var target = descmain;
    var width = this.curOrbit.object.zoom;
    this._zoom(target, width, fn);
  }, self.prototype.zoomOut = function(params) {
    var NUM_WIDTH_PTS = params.zoom || 1;
    var fn = params.time || 1e3;
    var zoomLevel = this.curOrbit.object.zoom;
    var width = NUM_WIDTH_PTS;
    this._zoom(zoomLevel, width, fn);
  }, self.prototype.worldToScreen = function(out) {
    return this.cameraObject.worldToScreen(out);
  }, self.prototype.screenToWorld = function(point, y) {
    return this.cameraObject.screenToWorld(point, y);
  }, self.prototype.unprojectScreenToWorld = function(c, t, i) {
    return this.cameraObject.unprojectScreenToWorld(c, t, i);
  }, self.prototype.setProjectionType = function(result, gridPanel, format, a) {
    var n = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1e3;
    var state = this;
    var i = result != this.projectionType;
    switch(result) {
      case kkkk.Perspective:
        if (this.cameraObject.lerpToPerspective(n, function() {
          if (i && state.projectionType == kkkk.Perspective) {
            var scene = state.toggleBackupInfo.toggleSkyBox;
            if (scene) {
              state.app.background = scene.background;
              state.app.skyBox = scene.skyBox;
              state.app.backgroundAdditiveColor = scene.backgroundAdditiveColor;
              state.app.backgroundColorScaleFactor = scene.backgroundColorScaleFactor;
              state.toggleBackupInfo.toggleSkyBox = null;
            }
          }
        }), i) {
          var a = this.toggleBackupInfo.toggleKeyPanSpeed;
          if (void 0 !== a) {
            this.curOrbit.keyPanSpeed = a;
          }
          var panSpeed = this.toggleBackupInfo.toggleMousePanSpeed;
          if (void 0 !== panSpeed) {
            this.curOrbit.panSpeed = panSpeed;
          }
          var u = this.toggleBackupInfo.toggleDampingFactor;
          if (void 0 !== u) {
            this.curOrbit.dampingFactor = u;
          }
          var value = this.toggleBackupInfo.minPolarAngle;
          if (void 0 !== value) {
            this.curOrbit.minPolarAngle = value;
          }
          var h = this.toggleBackupInfo.maxPolarAngle;
          if (void 0 !== h) {
            this.curOrbit.maxPolarAngle = h;
          }
        }
        break;
      case kkkk.Orthographic:
        if (i) {
          var map = this.toggleBackupInfo.toggleSkyBox;
          if (map) {
            map.backgroundAdditiveColor = this.app.backgroundAdditiveColor;
            map.backgroundColorScaleFactor = this.app.backgroundColorScaleFactor;
          } else {
            this.toggleBackupInfo.toggleSkyBox = {
              skyBox : this.app.skyBox,
              background : this.app.background,
              backgroundAdditiveColor : this.app.backgroundAdditiveColor,
              backgroundColorScaleFactor : this.app.backgroundColorScaleFactor
            };
          }
        }
        this.app.skyBox = null;
        if (i) {
          this.toggleBackupInfo.toggleKeyPanSpeed = this.curOrbit.keyPanSpeed;
          this.toggleBackupInfo.toggleMousePanSpeed = this.curOrbit.panSpeed;
          this.toggleBackupInfo.toggleDampingFactor = this.curOrbit.dampingFactor;
          this.toggleBackupInfo.minPolarAngle = this.curOrbit.minPolarAngle;
          this.toggleBackupInfo.maxPolarAngle = this.curOrbit.maxPolarAngle;
        }
        this.curOrbit.keyPanSpeed = gridPanel / 6400;
        this.curOrbit.panSpeed = gridPanel / 6400;
        this.curOrbit.dampingFactor = .12;
        this.curOrbit.minPolarAngle = 0;
        this.curOrbit.maxPolarAngle = Math.PI;
        var idx = Utils.parseVector3(format);
        var sin = Utils.parseVector3(a);
        this.cameraObject.lerpToOrthographic(idx, sin, n);
        break;
      default:
        return false;
    }
  }, self.prototype._getBestLocation = function(c, result, color) {
    var s = Utils.parseVector3(result.size);
    var pos = Utils.parseVector3(result.center);
    if (!s.x || !s.y || !s.z) {
      s.x = 5;
      s.y = 5;
      s.z = 5;
    }
    var t = pos.clone();
    var old = new THREE.Vector3(0, 1, 0);
    if (c == kkkk.Perspective) {
      t.x = pos.x + s.x;
      t.y = pos.y + s.y;
      t.z = pos.z + s.z;
    } else {
      var diffY = color || s.length();
      t.y = pos.y + diffY;
      old = new THREE.Vector3(0, 0, -1);
    }
    return {
      lookAt : pos,
      pos : t,
      up : old,
      scale : s
    };
  }, self.prototype.getBestLocation = function(attrs) {
    var t;
    return t = Utils.isArray(attrs) ? (new xi(this.app, attrs)).boundingBox : attrs.boundingBox, this._getBestLocation(this.projectionType, t);
  }, self.prototype.setType = function(c, t, value, view, height) {
    var camera = this._getBestLocation(t, c.boundingBox, height);
    var s = camera.pos.distanceTo(camera.lookAt);
    var scalar = this.distanceLimited[1];
    if (s >= scalar) {
      var direction = camera.pos.subVectors(camera.pos.clone(), camera.lookAt);
      direction.normalize();
      var startPosition = camera.pos.addVectors(camera.lookAt, direction.multiplyScalar(scalar));
      camera.pos = startPosition;
    }
    switch(this.setProjectionType(t, camera.scale.length(), camera.pos, camera.lookAt, value), t) {
      case kkkk.Perspective:
        var origin = this.toggleBackupInfo.toggleInitPos;
        if (void 0 !== origin) {
          camera.pos = Utils.parseVector3(origin);
        }
        var dir = this.toggleBackupInfo.toggleInitLookAt;
        if (void 0 !== dir) {
          camera.lookAt = Utils.parseVector3(dir);
        }
        break;
      case kkkk.Orthographic:
        this.toggleBackupInfo.toggleInitPos = this.position;
        this.toggleBackupInfo.toggleInitLookAt = this.target;
        break;
      default:
        return false;
    }
    var mw = this.app.rendererManager.getCurrentControl();
    var authReqCmd = mw.getConfig();
    var enable = authReqCmd.temporalSuperSampling.enable;
    var isEnable = authReqCmd.postEffect.screenSpaceAmbientOcclusion.enable;
    mw.mergeConfig({
      temporalSuperSampling : {
        enable : false
      },
      postEffect : {
        screenSpaceAmbientOcclusion : {
          enable : false
        }
      }
    }).update();
    var f = function() {
      mw.mergeConfig({
        temporalSuperSampling : {
          enable : enable
        },
        postEffect : {
          screenSpaceAmbientOcclusion : {
            enable : isEnable
          }
        }
      }).update();
      if (view) {
        view();
      }
    };
    var options = this._buildFlyParams({
      position : camera.pos.toArray(),
      target : camera.lookAt.toArray(),
      up : camera.up.toArray(),
      time : value,
      stop : f,
      complete : f
    });
    return this.cameraObject.flyTo(options), true;
  }, self.prototype.toggleNormalViewMode = function(afterSaved) {
    return this.viewMode != CameraView.Normal && (this.toggleObject({
      object : this.app.root,
      is3D : true,
      complete : function() {
        if (afterSaved) {
          afterSaved();
        }
      }
    }), true);
  }, self.prototype.toggleObject = function(request) {
    var b = (request = request || {}).object || this.app.level.current || this.app.root;
    var i = Utils.parseValue(request.is3D, false);
    var callback = request.complete;
    var fromdata = request.time || 1e3;
    var o = Utils.parseValue(request.force, false);
    var size = request.height;
    var RangePrototype = this.app.webViewManager.mixerContext;
    var res = false;
    return i ? (o || this.projectionType != kkkk.Perspective) && (this.projectionType != kkkk.Perspective && this._rotateEnableFlag.unlock("toggleObject"), res = this.setType(b, kkkk.Perspective, fromdata, callback, size), RangePrototype.cssCamera = RangePrototype.backupCSSCamera) : (o || this.projectionType != kkkk.Orthographic) && (this.projectionType != kkkk.Orthographic && this._rotateEnableFlag.lock(false, "toggleObject"), res = this.setType(b, kkkk.Orthographic, fromdata, callback, size), RangePrototype.cssCamera = 
    this.app.renderCamera.cameraO.clone(), RangePrototype.cssCamera.getEffectiveFOV = function() {
      return THING.App.current.renderCamera.getEffectiveFOV();
    }), res && this.app.trigger("cameraViewChange", {
      view : this.projectionType
    }), res;
  }, self.prototype.resize = function(h, w) {
    this.cameraObject.setSize(h, w);
  }, self.prototype._buildFlyParams = function(options) {
    var self = this;
    if (options.isBaseObject) {
      options = {
        target : options
      };
    }
    var createOnlyIf = options._flyStart;
    var readOnlyFn = options._flying;
    var onBlocklyLoaded = options._flyStop;
    var oldOnAttach = options._flyComplete;
    var s = Utils.parseValue(options.pickable, false);
    return options.flyStart = function() {
      if (!s) {
        self.picker._enable(false, "_buildFlyParams", 1e3);
      }
      self._change("cameraChangeStart");
      if (createOnlyIf) {
        createOnlyIf();
      }
    }, options.flying = function() {
      if (Utils.isFunction(self.curOrbit.setState)) {
        self.curOrbit.setState();
      }
      self._change("cameraChange");
      if (readOnlyFn) {
        readOnlyFn();
      }
    }, options.flyStop = function() {
      if (Utils.isFunction(self.curOrbit.setState)) {
        self.curOrbit.setState();
      }
      if (!s) {
        self.picker._enable(true, "_buildFlyParams", 0);
      }
      self._change("cameraChangeEnd");
      var start = options.stop;
      if (start) {
        start();
      }
      if (onBlocklyLoaded) {
        onBlocklyLoaded();
      }
    }, options.flyComplete = function() {
      self.picker._enable(true, "_buildFlyParams", 0);
      if (Utils.isFunction(self.curOrbit.setState)) {
        self.curOrbit.setState();
      }
      self._change("cameraChangeEnd");
      var obj = options.target || options.object;
      if (obj instanceof BaseObject) {
        obj.trigger("cameraFlyComplete");
      }
      var parent = options.targetForFlyComplete;
      if (parent != obj && parent instanceof BaseObject) {
        parent.trigger("cameraFlyComplete");
      }
      self.app.events.dispatchEvent({
        type : "cameraFlyComplete"
      });
      var complete = options.complete;
      if (complete) {
        complete();
      }
      if (oldOnAttach) {
        oldOnAttach();
      }
    }, options.autoFixUp = this._autoFixCameraUp, options.targetForFlyComplete = this.app.level.current, options;
  }, self.prototype.fit = function(options) {
    if ((options = options || {}).isBaseObject) {
      options = {
        object : options
      };
    }
    options.object = options.object || this.app.root;
    options.time = 1;
    this.cameraObject.flyTo(options);
  }, self.prototype.stopFlying = function(e) {
    this.cameraObject.stopFlying(e);
  }, self.prototype.flyTo = function(options) {
    if (options = this._buildFlyParams(options), this.viewMode == CameraView.TopView) {
      var scene = this;
      this.toggleObject({
        is3D : true,
        complete : function() {
          scene.cameraObject.flyTo(options);
        }
      });
    } else {
      this.cameraObject.flyTo(options);
    }
  }, self.prototype.movePath = function(path) {
    path = this._buildFlyParams(path);
    this.cameraObject.movePath(path);
  }, self.prototype.lookAt = function(target) {
    if (this.cameraObject.lookAt(target)) {
      this._rotateEnableFlag.lock(false, "lookAt");
      this._panEnableFlag.lock(false, "lookAt");
    } else {
      this._rotateEnableFlag.unlock("lookAt");
      this._panEnableFlag.unlock("lookAt");
    }
  }, self.prototype.stopRotateAround = function(e) {
    this.cameraObject.stopRotating(e);
  }, self.prototype.rotateAround = function(result) {
    var self = this;
    result = result || {};
    var i = Utils.parseValue(result.pickable, true);
    result.rotateStart = function() {
      if (!i) {
        self.picker._enable(false, "rotateAround", 1e3);
      }
    };
    result.rotateComplete = function() {
      if (!i) {
        self.picker._enable(true, "rotateAround", 0);
      }
    };
    this.cameraObject.rotateAround(result);
  }, self.prototype.rotateAroundX = function(canCreateDiscussions) {
    var BOUNCE_BACK = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 500;
    this.rotateAround({
      xRotateAngle : canCreateDiscussions,
      time : BOUNCE_BACK
    });
  }, self.prototype.rotateAroundY = function(canCreateDiscussions) {
    var BOUNCE_BACK = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 500;
    this.rotateAround({
      yRotateAngle : canCreateDiscussions,
      time : BOUNCE_BACK
    });
  }, self.prototype.followObject = function(scope) {
    scope = scope || {};
    this.cameraObject.followObject(scope);
    var t = Utils.parseValue(scope.enableRotate, false);
    var i = Utils.parseValue(scope.enableZoom, false);
    if (!t) {
      this._rotateEnableFlag.lock(false, "followObject");
    }
    if (!i) {
      this._zoomEnableFlag.lock(false, "followObject");
    }
  }, self.prototype.stopFollowingObject = function() {
    this.cameraObject.stopFollowingObject();
    this._rotateEnableFlag.unlock("followObject");
    this._zoomEnableFlag.unlock("followObject");
  }, self.prototype.canUpdateOrbit = function() {
    return !this.cameraObject.flying && !(!this.curOrbit.enabled && !this.curOrbit.autoRotate);
  }, self.prototype.update = function() {
    this.cameraObject.update();
    if (this.canUpdateOrbit()) {
      this.curOrbit.update();
    }
  }, self.prototype.onUpdate = function(e) {
    this.update(e);
  }, self.prototype.zoom = function(amount) {
    var BOUNCE_BACK = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 500;
    if (amount = Math.min(this.distance - 1, amount), this.projectionType == kkkk.Perspective) {
      var dir = Utils.parseVector3(this.direction);
      dir.multiplyScalar(amount);
      var p = Utils.parseVector3(this.position);
      if (p.add(dir), this.enableUpdateTargetOnWheel && this._autoFixTarget()) {
        var $target = Utils.parseVector3(this.target);
        $target.add(dir);
        this.target = $target;
      }
      this.flyTo({
        position : p.toArray(),
        target : this.target,
        time : BOUNCE_BACK
      });
    } else {
      var urlZoom = K.max(this.curOrbit.object.zoom + amount / 20, .001);
      this.zoomOut({
        zoom : urlZoom,
        time : BOUNCE_BACK
      });
    }
  }, self.prototype.rotateX = function(a, t) {
    if (Utils.isNull(t)) {
      this.cameraObject.rotateX(a);
    } else {
      THING.Utils.warn('Please use "this.rotateAround({xRotateAngle: angle,time});" to replace rotateX(angle, time)');
      this.rotateAround({
        xRotateAngle : a,
        time : t
      });
    }
  }, self.prototype.rotateY = function(angle, value) {
    if (Utils.isNull(value)) {
      this.cameraObject.rotateY(angle);
    } else {
      THING.Utils.warn('Please use "this.rotateAround({yRotateAngle: angle,time});" to replace rotateX(angle, time)');
      this.rotateAround({
        yRotateAngle : angle,
        time : value
      });
    }
  }, self.prototype.rotateZ = function(angle) {
    this.cameraObject.rotateZ(angle);
  }, self.prototype.move = function(diffX, diffY) {
    var res = this.dampingFactor / .12;
    this.curOrbit.move(-diffX * res, diffY * res);
  }, self.prototype.loadViewPoint = function(url) {
    this.app.viewPointManger.loadJSON(url);
  }, self.prototype.playViewPoint = function(element) {
    this.app.viewPointManger.play(element);
  }, self.prototype.pauseViewPoint = function(sub) {
    this.app.viewPointManger.pause(sub);
  }, self.prototype.isInView = function(element) {
    return !!element && this.cameraObject.isInView(element);
  }, self.prototype.isCovered = function(coverage) {
    return !!coverage && (THING.Utils.warn("not impl yet"), true);
  }, self.prototype.disable = function(data) {
    (data = data || {}).rotate = Utils.parseValue(data.rotate, true);
    data.pan = Utils.parseValue(data.pan, true);
    data.zoom = Utils.parseValue(data.zoom, true);
    if (data.rotate) {
      this._rotateEnableFlag.lock(false, "disable");
    }
    if (data.pan) {
      this._panEnableFlag.lock(false, "disable");
    }
    if (data.zoom) {
      this._zoomEnableFlag.lock(false, "disable");
    }
  }, self.prototype.resume = function(result) {
    (result = result || {}).rotate = Utils.parseValue(result.rotate, true);
    result.pan = Utils.parseValue(result.pan, true);
    result.zoom = Utils.parseValue(result.zoom, true);
    if (result.rotate) {
      this._rotateEnableFlag.unlock("disable");
    }
    if (result.pan) {
      this._panEnableFlag.unlock("disable");
    }
    if (result.zoom) {
      this._zoomEnableFlag.unlock("disable");
    }
  }, self.prototype.showTargetNode = function() {
    var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    if (e) {
      if (!this._targetObject) {
        this._targetObject = this.app.create({
          type : "Box",
          position : this.target,
          style : {
            color : "#FF0000"
          }
        });
        this._targetObject.pickable = false;
        this._targetObject.style.outlineColor = 65535;
        this._targetObject.node.traverse(function(data) {
          data.userData.__debugObject__ = true;
        });
      }
    } else {
      if (this._targetObject) {
        this._targetObject.destroy();
        this._targetObject = null;
      }
    }
  }, self.prototype.distanceTo = function(v) {
    return this.cameraObject.distanceTo(v);
  }, self.prototype.setTargetLimit = function(normals) {
    if (this.orbit instanceof THREE.EarthOrbitControls) {
      this.curOrbit.setTargetLimit(normals);
    } else {
      if (normals) {
        var globalBonePosition = new THREE.Vector3(normals[0], normals[1], normals[2]);
        var t = this.curOrbit.target;
        var r = t.x + globalBonePosition.x / 2;
        var n = t.x - globalBonePosition.x / 2;
        var o = t.z + globalBonePosition.z / 2;
        var s = t.z - globalBonePosition.z / 2;
        var a = t.y - globalBonePosition.y / 2;
        var l = t.y + globalBonePosition.y / 2;
        this._targetBoundary.min.set(n, a, s);
        this._targetBoundary.max.set(r, l, o);
      } else {
        this._targetBoundary.makeEmpty();
      }
    }
  }, self.prototype.log = function() {
    THING.Utils.log("[" + this.position.toString() + "], [" + this.target.toString() + "]");
  }, self.prototype.dolly = function(amount) {
    var originalEvent = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 500;
    THING.Utils.warn("[CameraController] Please use '.zoom()' to replace '.dolly()'");
    this.zoom(amount, originalEvent);
  }, self.prototype.theta = function(angle) {
    var nameArgs = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 500;
    THING.Utils.warn("[CameraController] Please use '.rotateX()' to replace '.theta()'");
    this.rotateX(angle, nameArgs);
  }, self.prototype.phi = function(angle) {
    var sliderFeLineGsValue = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 500;
    THING.Utils.warn("[CameraController] Please use '.rotateY()' to replace '.theta()'");
    this.rotateY(angle, sliderFeLineGsValue);
  }, n(e, [{
    key : "aspect",
    get : function() {
      return this.cameraObject.node.cameraP.aspect;
    }
  }, {
    key : "frustum",
    get : function() {
      return this.cameraObject.frustum;
    }
  }, {
    key : "camera",
    get : function() {
      return this.app.renderCamera;
    }
  }, {
    key : "viewMode",
    set : function(v) {
      this.toggleObject({
        is3D : v == CameraView.Normal
      });
    },
    get : function() {
      return this.projectionType == kkkk.Perspective ? CameraView.Normal : CameraView.TopView;
    }
  }, {
    key : "projectionType",
    set : function(v) {
      this.setProjectionType(v, this.distance, this.position, this.target);
    },
    get : function() {
      return this.cameraObject.projectionType;
    }
  }, {
    key : "enableDamping",
    set : function(value) {
      this.curOrbit.enableDamping = value;
    },
    get : function() {
      return this.curOrbit.enableDamping;
    }
  }, {
    key : "dampingFactor",
    set : function(value) {
      this.curOrbit.dampingFactor = value;
    },
    get : function() {
      return this.curOrbit.dampingFactor;
    }
  }, {
    key : "rotateSpeed",
    set : function(v) {
      this.curOrbit.rotateSpeed = v;
    },
    get : function() {
      return this.curOrbit.rotateSpeed;
    }
  }, {
    key : "fov",
    set : function(value) {
      this.cameraObject.fov = value;
      var camera = this.app.webViewManager.mixerContext.cssCamera;
      camera.fov = value;
      camera.updateProjectionMatrix();
    },
    get : function() {
      return this.cameraObject.fov;
    }
  }, {
    key : "near",
    set : function(value) {
      this.cameraObject.near = value;
    },
    get : function() {
      return this.cameraObject.near;
    }
  }, {
    key : "far",
    set : function(value) {
      this.cameraObject.far = value;
    },
    get : function() {
      return this.cameraObject.far;
    }
  }, {
    key : "zoomLimited",
    set : function(v) {
      this.curOrbit.minZoom = v[0];
      this.curOrbit.maxZoom = v[1];
    },
    get : function() {
      return [this.curOrbit.minZoom, this.curOrbit.maxZoom];
    }
  }, {
    key : "zoomFactor",
    set : function(v) {
      if (void 0 !== this.curOrbit.zoomFactor) {
        this.curOrbit.zoomFactor = v;
      } else {
        if (void 0 !== this.curOrbit.zoomSpeed) {
          this.curOrbit.zoomSpeed = v;
        }
      }
    },
    get : function() {
      return void 0 !== this.curOrbit.zoomFactor ? this.curOrbit.zoomFactor : void 0 !== this.curOrbit.zoomSpeed ? this.curOrbit.zoomSpeed : 1;
    }
  }, {
    key : "distanceLimited",
    set : function(v) {
      this.curOrbit.minDistance = v[0];
      this.curOrbit.maxDistance = v[1];
    },
    get : function() {
      return [this.curOrbit.minDistance, this.curOrbit.maxDistance];
    }
  }, {
    key : "xAngleLimitRange",
    set : function(v) {
      var value = 90 - v[0];
      var tB1x = 90 - v[1];
      this.curOrbit.minPolarAngle = THING.Math.degToRad(Math.min(value, tB1x));
      this.curOrbit.maxPolarAngle = THING.Math.degToRad(Math.max(value, tB1x));
    },
    get : function() {
      var animate = function(alpha) {
        return 90 - THING.Math.radToDeg(alpha);
      };
      var sequence = animate(this.curOrbit.minPolarAngle);
      var tB1x = animate(this.curOrbit.maxPolarAngle);
      return [Math.min(sequence, tB1x), Math.max(sequence, tB1x)];
    }
  }, {
    key : "yAngleLimitRange",
    set : function(data) {
      this.curOrbit.minAzimuthAngle = THING.Math.degToRad(data[0]);
      this.curOrbit.maxAzimuthAngle = THING.Math.degToRad(data[1]);
    },
    get : function() {
      return [THING.Math.radToDeg(this.curOrbit.minAzimuthAngle), THING.Math.radToDeg(this.curOrbit.maxAzimuthAngle)];
    }
  }, {
    key : "keyPanSpeed",
    set : function(v) {
      this.curOrbit.keyPanSpeed = v;
    },
    get : function() {
      return this.curOrbit.keyPanSpeed;
    }
  }, {
    key : "mousePanSpeed",
    set : function(v) {
      this.curOrbit.panSpeed = v;
    },
    get : function() {
      return this.curOrbit.panSpeed;
    }
  }, {
    key : "distance",
    set : function(value) {
      this.cameraObject.distance = value;
    },
    get : function() {
      return this.cameraObject.distance;
    }
  }, {
    key : "direction",
    get : function() {
      return this.cameraObject.direction;
    }
  }, {
    key : "rightDirection",
    get : function() {
      return this.cameraObject.rightDirection;
    }
  }, {
    key : "up",
    set : function(value) {
      this.cameraObject.up = value;
    },
    get : function() {
      return this.cameraObject.up;
    }
  }, {
    key : "position",
    set : function(value) {
      if (value) {
        this.cameraObject.position = value;
      }
    },
    get : function() {
      return this.cameraObject.position;
    }
  }, {
    key : "target",
    set : function(value) {
      if (value) {
        this.cameraObject.target = value;
      }
    },
    get : function() {
      return this.cameraObject.target;
    }
  }, {
    key : "inputEnabled",
    set : function(name) {
      this._inputEnableFlag.lock(name, "default");
    },
    get : function() {
      return this._inputEnableFlag.isEnable();
    }
  }, {
    key : "enableRotate",
    set : function(value) {
      this._rotateEnableFlag.enable(value);
    },
    get : function() {
      return this._rotateEnableFlag.isEnable();
    }
  }, {
    key : "enableZoom",
    set : function(value) {
      this._zoomEnableFlag.enable(value);
    },
    get : function() {
      return this._zoomEnableFlag.isEnable();
    }
  }, {
    key : "enablePan",
    set : function(value) {
      this._panEnableFlag.enable(value);
    },
    get : function() {
      return this._panEnableFlag.isEnable();
    }
  }, {
    key : "flying",
    get : function() {
      return this.cameraObject.flying;
    }
  }, {
    key : "mode",
    set : function(v) {
      if (this.mode != v) {
        this.curOrbit.enabled = false;
        if ("earth" == v) {
          this.curOrbit = new THREE.EarthOrbitControls(this.app.renderCamera, this.app.mainDomElement);
          this.curOrbit.app = this.app;
          this.initOrbit(this.curOrbit);
          this.autoAdjustNear = false;
        } else {
          this.curOrbit.dispose();
          this.curOrbit = this.orbit;
          this.curOrbit.enabled = true;
          this.autoAdjustNear = true;
        }
        this.cameraObject.controller = this.curOrbit;
      }
    },
    get : function() {
      return this.curOrbit instanceof THREE.EarthOrbitControls ? "earth" : "normal";
    }
  }, {
    key : "degreeToWorldYAxis",
    get : function() {
      var dir = Utils.parseVector3(this.direction);
      var r = new THREE.Vector3(0, -1, 0);
      var cos = dir.dot(r);
      return THING.Math.radToDeg(Math.acos(cos));
    }
  }, {
    key : "autoAdjustNear",
    set : function(v) {
      this._autoAdjustNear = v;
      if (!v) {
        this.cameraObject.near = this.cameraObject._near;
      }
    },
    get : function() {
      return this._autoAdjustNear;
    }
  }, {
    key : "autoAdjustTarget",
    set : function(v) {
      this._autoAdjustTarget = v;
    },
    get : function() {
      return this._autoAdjustTarget;
    }
  }, {
    key : "enableUpdateTargetOnWheel",
    set : function(v) {
      this._enableUpdateTargetOnWheel = v;
    },
    get : function() {
      return this._enableUpdateTargetOnWheel;
    }
  }, {
    key : "enableZoomOnTarget",
    set : function(v) {
      if ("earth" == this.mode) {
        this.curOrbit.enableZoomOnTarget = v;
        this.curOrbit._keepTarget = !v;
      } else {
        var s = this;
        this._enableZoomOnTarget = v;
        this._inputEnableFlag.lock(!v, "enableZoomOnTarget");
        this.curOrbit.enableZoomOnTarget = v;
        if (v) {
          this.app.on("mousewheel", function(e) {
            if (false !== s._inputEnableFlag.isLock("default")) {
              s._inputEnableFlag.lock(false, "enableZoomOnTarget");
              s._processWheelOnMouseTarget(e);
            }
          }, "_processWheelOnMouseTarget_");
          this.app.on("mousedown", function(canCreateDiscussions) {
            if (false !== s._inputEnableFlag.isLock("default")) {
              s._inputEnableFlag.lock(true, "enableZoomOnTarget");
            }
          }, "_processWheelOnMouseTarget_mousedown");
        } else {
          this.app.off("mousewheel", null, "_processWheelOnMouseTarget_");
          this.app.off("mousedown", null, "_processWheelOnMouseTarget_mousedown");
        }
      }
    },
    get : function() {
      return "earth" == this.mode ? this.curOrbit.enableZoomOnTarget : this._enableZoomOnTarget;
    }
  }, {
    key : "wheelOnMouseTargetScale",
    set : function(v) {
      this._wheelOnMouseTargetScale = v;
    },
    get : function() {
      return this._wheelOnMouseTargetScale;
    }
  }, {
    key : "autoFixCameraUp",
    set : function(v) {
      this._autoFixCameraUp = v;
    },
    get : function() {
      return this._autoFixCameraUp;
    }
  }, {
    key : "autoHideObjectsWhenRotatingFunc",
    set : function(v) {
      if (this._autoHideObjectsWhenRotatingFunc = v, this.app.off("cameraControllerChangeStart", null, "__autoHideObjectsWhenRotatingFunc__start__"), this.app.off("cameraControllerChangeEnd", null, "__autoHideObjectsWhenRotatingFunc__end__"), this._autoHideObjectsWhenRotatingFunc) {
        if (!Utils.isFunction(this._autoHideObjectsWhenRotatingFunc)) {
          return;
        }
        var Model = this;
        this.app.on("cameraControllerChangeStart", function(canCreateDiscussions) {
          Model.app.query(".Thing").forEach(function(e) {
            if (Model._autoHideObjectsWhenRotatingFunc && false === Model._autoHideObjectsWhenRotatingFunc(e) && e.visible) {
              e._prevVisible_auto_hide = true;
              var cache = app.modelResource.get(e.url);
              if (cache && cache.loadingBox) {
                e.changeAppearance(cache.loadingBox.clone());
                e._needRevertAppearance_auto_hide = true;
              } else {
                e.visible = false;
              }
            }
          });
        }, "__autoHideObjectsWhenRotatingFunc__start__");
        this.app.on("cameraControllerChangeEnd", function(canCreateDiscussions) {
          Model.app.query(".Thing").forEach(function(oPresentationNode) {
            if (oPresentationNode._prevVisible_auto_hide) {
              if (oPresentationNode._needRevertAppearance_auto_hide) {
                oPresentationNode.changeAppearance(null);
                delete oPresentationNode._needRevertAppearance_auto_hide;
              } else {
                oPresentationNode.visible = true;
              }
              delete oPresentationNode._prevVisible_auto_hide;
            }
          });
        }, "__autoHideObjectsWhenRotatingFunc__end__");
      }
    },
    get : function() {
      return this._autoHideObjectsWhenRotatingFunc;
    }
  }, {
    key : "mouseButtons",
    set : function(x) {
      var floor = function(key, value) {
        var x = {
          left : THREE.MOUSE.LEFT,
          middle : THREE.MOUSE.MIDDLE,
          right : THREE.MOUSE.RIGHT
        };
        return Utils.parseValue(x[key], value);
      };
      x = x || {};
      var e = this.curOrbit.mouseButtons;
      var startYNew = floor(x.left, Utils.parseValue(e.LEFT, e.ORBIT));
      var startXNew = floor(x.middle, Utils.parseValue(e.MIDDLE, e.ZOOM));
      var RIGHT = floor(x.right, Utils.parseValue(e.RIGHT, e.PAN));
      if ("normal" == this.mode) {
        this.curOrbit.mouseButtons = {
          LEFT : startYNew,
          MIDDLE : startXNew,
          RIGHT : RIGHT
        };
      } else {
        if ("earth" == this.mode) {
          this.curOrbit.mouseButtons = {
            ORBIT : startYNew,
            ZOOM : startXNew,
            PAN : RIGHT
          };
        }
      }
    },
    get : function() {
      var create = function(index) {
        return ["left", "middle", "right"][index];
      };
      var e = this.curOrbit.mouseButtons;
      return {
        left : create(Utils.parseValue(e.LEFT, e.ORBIT)),
        middle : create(Utils.parseValue(e.MIDDLE, e.ZOOM)),
        right : create(Utils.parseValue(e.RIGHT, e.PAN))
      };
    }
  }, {
    key : "options",
    set : function(value) {
      var o = this.options;
      Utils.mergeObject(o, value, true);
      this.mouseButtons = {
        left : o.rotationKey,
        middle : o.zoomKey,
        right : o.moveKey
      };
      if ("normal" == this.mode) {
        this.enableZoomOnTarget = o.enableZoomOnTarget;
        this.enableUpdateTargetOnWheel = o.enableUpdateTargetOnWheel;
      } else {
        if ("earth" == this.mode) {
          this.curOrbit.setOptions(o);
        }
      }
    },
    get : function() {
      var name = {
        rotationKey : this.mouseButtons.left,
        zoomKey : this.mouseButtons.middle,
        moveKey : this.mouseButtons.right
      };
      return "normal" == this.mode ? (name.enableZoomOnTarget = this.enableZoomOnTarget, name.enableUpdateTargetOnWheel = this.enableUpdateTargetOnWheel) : "earth" == this.mode && Utils.mergeObject(name, this.curOrbit.getOptions(name)), name;
    }
  }, {
    key : "toggle3D",
    set : function(v) {
      THING.Utils.warn("[CameraController] Please use '.viewMode=THING.CameraView.Normal/TopView' to replace '.toggle3D'");
      this.viewMode = v ? CameraView.Normal : CameraView.TopView;
    },
    get : function() {
      return THING.Utils.warn("[CameraController] Please use '.viewMode == THING.CameraView.Normal' to replace '.toggle3D'"), this.viewMode == CameraView.Normal;
    }
  }, {
    key : "enabled",
    set : function(v) {
      THING.Utils.warn("[CameraController] Please use '.inputEnabled' to replace '.enabled'");
      this.inputEnabled = v;
    },
    get : function() {
      return THING.Utils.warn("[CameraController] Please use '.inputEnabled' to replace '.enabled'"), this.inputEnabled;
    }
  }, {
    key : "minZoom",
    set : function(v) {
      THING.Utils.warn("[CameraController] Please use '.zoomLimited=[min, max]' to replace '.minZoom'");
      this.zoomLimited = [v, this.zoomLimited[1]];
    },
    get : function() {
      return THING.Utils.warn("[CameraController] Please use '.zoomLimited[0]' to replace '.minZoom'"), this.zoomLimited[0];
    }
  }, {
    key : "maxZoom",
    set : function(v) {
      THING.Utils.warn("[CameraController] Please use '.zoomLimited=[min, max]' to replace '.maxZoom'");
      this.zoomLimited = [this.zoomLimited[0], v];
    },
    get : function() {
      return THING.Utils.warn("[CameraController] Please use '.zoomLimited[0]' to replace '.maxZoom'"), this.zoomLimited[1];
    }
  }, {
    key : "minDistance",
    set : function(v) {
      THING.Utils.warn("[CameraController] Please use '.distanceLimited=[min, max]' to replace '.minDistance'");
      this.distanceLimited = [v, this.distanceLimited[1]];
    },
    get : function() {
      return THING.Utils.warn("[CameraController] Please use '.distanceLimited[0]' to replace '.minDistance'"), this.distanceLimited[0];
    }
  }, {
    key : "maxDistance",
    set : function(v) {
      THING.Utils.warn("[CameraController] Please use '.distanceLimited=[min, max]' to replace '.maxDistance'");
      this.distanceLimited = [this.distanceLimited[0], v];
    },
    get : function() {
      return THING.Utils.warn("[CameraController] Please use '.distanceLimited[0]' to replace '.maxDistance'"), this.distanceLimited[1];
    }
  }, {
    key : "minPolarAngle",
    set : function(v) {
      THING.Utils.warn("[CameraController] Please use '.verticalAngleLimited=[min, max]' to replace '.minPolarAngle'");
      this.verticalAngleLimited = [v, this.verticalAngleLimited[1]];
    },
    get : function() {
      return THING.Utils.warn("[CameraController] Please use '.verticalAngleLimited[0]' to replace '.minPolarAngle'"), this.verticalAngleLimited[0];
    }
  }, {
    key : "maxPolarAngle",
    set : function(v) {
      THING.Utils.warn("[CameraController] Please use '.verticalAngleLimited=[min, max]' to replace '.maxPolarAngle'");
      this.verticalAngleLimited = [this.verticalAngleLimited[0], v];
    },
    get : function() {
      return THING.Utils.warn("[CameraController] Please use '.verticalAngleLimited[0]' to replace '.maxPolarAngle'"), this.verticalAngleLimited[1];
    }
  }, {
    key : "minAzimuthAngle",
    set : function(v) {
      THING.Utils.warn("[CameraController] Please use '.horizontalAngleLimited=[min, max]' to replace '.minAzimuthAngle'");
      this.horizontalAngleLimited = [v, this.horizontalAngleLimited[1]];
    },
    get : function() {
      return THING.Utils.warn("[CameraController] Please use '.horizontalAngleLimited[0]' to replace '.minAzimuthAngle'"), this.horizontalAngleLimited[0];
    }
  }, {
    key : "maxAzimuthAngle",
    set : function(v) {
      THING.Utils.warn("[CameraController] Please use '.horizontalAngleLimited=[min, max]' to replace '.maxAzimuthAngle'");
      this.horizontalAngleLimited = [this.horizontalAngleLimited[0], v];
    },
    get : function() {
      return THING.Utils.warn("[CameraController] Please use '.horizontalAngleLimited[0]' to replace '.maxAzimuthAngle'"), this.horizontalAngleLimited[1];
    }
  }, {
    key : "verticalAngleLimited",
    set : function(v) {
      THING.Utils.warn("[CameraController] Please use '.xAngleLimited' to replace '.verticalAngleLimited'");
      this.xAngleLimited = v;
    },
    get : function() {
      return THING.Utils.warn("[CameraController] Please use '.xAngleLimited' to replace '.verticalAngleLimited'"), this.xAngleLimited;
    }
  }, {
    key : "horizontalAngleLimited",
    set : function(v) {
      THING.Utils.warn("[CameraController] Please use '.yAngleLimited' to replace '.verticalAngleLimited'");
      this.yAngleLimited = v;
    },
    get : function() {
      return THING.Utils.warn("[CameraController] Please use '.yAngleLimited' to replace '.verticalAngleLimited'"), this.yAngleLimited;
    }
  }, {
    key : "yAngleLimited",
    set : function(v) {
      THING.Utils.warn("[CameraController] Please use '.xAngleLimitRange' to replace '.yAngleLimited'");
      this.xAngleLimitRange = v;
    },
    get : function() {
      return THING.Utils.warn("[CameraController] Please use '.xAngleLimitRange' to replace '.yAngleLimited'"), this.xAngleLimitRange;
    }
  }, {
    key : "xAngleLimited",
    set : function(v) {
      THING.Utils.warn("[CameraController] Please use '.yAngleLimitRange' to replace '.xAngleLimited'");
      this.yAngleLimitRange = v;
    },
    get : function() {
      return THING.Utils.warn("[CameraController] Please use '.yAngleLimitRange' to replace '.xAngleLimited'"), this.yAngleLimitRange;
    }
  }, {
    key : "rotating",
    get : function() {
      return THING.Utils.warn("[CameraController] Please use '.flying' to replace '.rotating'"), this.flying;
    }
  }, {
    key : "panSpeed",
    set : function(v) {
      THING.Utils.warn("[CameraController] Please use '.keyPanSpeed' to replace '.panSpeed'");
      this.keyPanSpeed = v;
    },
    get : function() {
      return THING.Utils.warn("[CameraController] Please use '.keyPanSpeed' to replace '.panSpeed'"), this.keyPanSpeed;
    }
  }, {
    key : "enableUpdateTargetByMove",
    set : function(v) {
    },
    get : function() {
      return true;
    }
  }]), e;
}();
kh = function() {
  function self(value) {
    r(this, self);
    this.app = value;
    this._origin = null;
    this._previous = null;
    this._current = null;
    this._root = null;
    this._changed = false;
    this._options = {
      flyTime : 1e3,
      outlineColor : 16744448,
      autoChangeBackground : true,
      autoBakeFloor : true,
      autoHideFloorObjects : true,
      autoEnterSubLevel : true,
      autoBackFromSubLevel : true
    };
  }
  return self.prototype.init = function() {
    this._root = this.app.root;
  }, self.prototype.buildState = function(value) {
    var x = value.type;
    if ("Campus" == x) {
      x = "Outdoors";
    }
    var s = {};
    s.name = x + "Level";
    var matches = [];
    if (value instanceof is) {
      matches.push("floor");
      matches.push("_floor");
    } else {
      if (value instanceof dl) {
        matches.push("building");
        matches.push("_building");
      }
    }
    var j = 0;
    for (; j < matches.length; j++) {
      s[matches[j]] = value;
    }
    return s;
  }, self.prototype.buildAfterEnterState = function(result) {
    var courseSections = result.type;
    if ("Campus" == courseSections) {
      courseSections = "Outdoors";
    }
    var previous = this.previous ? this.previous.type : "";
    if ("Campus" == previous) {
      previous = "Outdoors";
    }
    var d = {
      prevState : {
        name : previous + "Level"
      },
      state : this.buildState(result),
      stateName : courseSections + "Level"
    };
    return this.previous && (this.previous instanceof dl ? (d.prevState.building = this.previous, d.prevState._building = this.previous) : this.previous instanceof is && (d.prevState.floor = this.previous, d.prevState._floor = this.previous)), d;
  }, self.prototype.buildBeforeEnterState = function(result) {
    var courseSections = result.type;
    if ("Campus" == courseSections) {
      courseSections = "Outdoors";
    }
    var commandName = this.current ? this.current.type : "";
    if ("Campus" == commandName) {
      commandName = "Outdoors";
    }
    var val = {
      prevState : {
        name : commandName + "Level"
      },
      curState : this.buildState(result),
      stateName : courseSections + "Level"
    };
    return this.previous && (this.previous instanceof dl ? (val.prevState.building = this.previous, val.prevState._building = this.previous) : this.previous instanceof is && (val.prevState.floor = this.previous, val.prevState._floor = this.previous)), val;
  }, self.prototype.getEventType = function(type, result) {
    var courseSections = result.type;
    return "Campus" == courseSections && (courseSections = "Outdoors"), type + courseSections + "Level";
  }, self.prototype.buildEventArguments = function(type) {
    var key = type.type;
    if ("Campus" == key) {
      key = "Outdoors";
    }
    var attrs = {
      name : key + "Level"
    };
    return attrs.state = this.buildState(type), attrs;
  }, self.prototype.notifyBeforeEnterState = function(message) {
    this.app.trigger("beforeEnterState", this.buildBeforeEnterState(message));
  }, self.prototype.notifyAfterEnterState = function(message) {
    this.app.trigger("afterEnterState", this.buildAfterEnterState(message));
  }, self.prototype.nofityAfterLevelChange = function(_ref7) {
    var args = _ref7.object;
    this.app.trigger(this.getEventType("enter", args), this.buildEventArguments(args));
    this.app.trigger(this.getEventType("afterEnter", args), this.buildEventArguments(args));
  }, self.prototype.notifyBeforeLevelChange = function(e) {
    this.app.trigger(this.getEventType("beforeEnter", e), this.buildEventArguments(e));
  }, self.prototype._getLevelType = function() {
    var gotError = this._current;
    return gotError ? gotError.type : "";
  }, self.prototype._leaveLevel = function(start, value) {
    if (this.app.trigger(EventType.BeforeLevelChange, {
      level : this._getLevelType(),
      origin : this._origin,
      current : this._current,
      previous : this._previous,
      next : start
    }), this._current) {
      var item = Utils.cloneObject(value);
      item.level = this._getLevelType();
      item.object = this._current;
      item.origin = this._origin;
      item.current = start;
      item.previous = this._current;
      this._current.trigger(EventType.LevelChange, item);
      this._current.trigger(EventType.LeaveLevel, item);
      this.app.trigger(EventType.LeaveLevel, item);
    }
    if (start) {
      this.notifyBeforeLevelChange(start);
      this.notifyBeforeEnterState(start);
    }
  }, self.prototype._notifyEnterLevel = function(img, data) {
    data.object = img;
    this.app.trigger(EventType.EnterLevel, data);
    this.nofityAfterLevelChange(data);
  }, self.prototype._enterLevel = function(a, self) {
    var state = this;
    if (this._changed = true, this._previous = this._current, this._current = a, self.level = this._getLevelType(), self.origin = this._origin, self.current = this._current, self.object = this._current, self.previous = this._previous, this.app.trigger(EventType.LevelChange, self), a) {
      var item = self.lastObject;
      if (!item.internalUserData.level_complete) {
        item.internalUserData.level_complete = true;
        item.one(EventType.EnterLevel, function(typeStatement) {
          delete typeStatement.object.internalUserData.level_complete;
          var _oldStartWalking = self.userComplete;
          if (_oldStartWalking) {
            _oldStartWalking();
            delete self.complete;
          }
          item.one("cameraFlyComplete", {
            lastLevelChanged : true
          }, function(data) {
            if (data.data.lastLevelChanged && data.object == item) {
              var _oldStartWalking = self.flyComplete;
              if (_oldStartWalking) {
                _oldStartWalking();
              }
            }
            var o = data.object.isPauseEvent(THING.EventType.EnterLevel, THING.EventTag.LevelFly);
            var c = data.object.isPauseEvent(THING.EventType.EnterLevel, THING.EventTag.LevelCustomFly, true);
            if (!(o && c)) {
              data.object.trigger(EventType.LevelFlyEnd, {
                level : state._getLevelType(),
                object : data.object,
                current : data.object,
                previous : state.previous
              });
              state.app.trigger(EventType.LevelFlyEnd, {
                level : state._getLevelType(),
                object : data.object,
                current : data.object,
                previous : state.previous
              });
            }
          }, "___level_camera_fly_complete___");
        }, "___level_complete___");
      }
      a.trigger(EventType.LevelChange, self);
      this.notifyAfterEnterState(a);
      var moderates = a.isPauseEvent(EventType.EnterLevel, EventTag.LevelFly);
      var editPost = a.hasEvent(EventType.EnterLevel, EventTag.LevelFly);
      if (self.jumping || moderates || !editPost) {
        a.pauseEvent(EventType.EnterLevel, null, EventTag.LevelFly);
        a.trigger(EventType.EnterLevel, self);
        a.resumeEvent(EventType.EnterLevel, null, EventTag.LevelFly);
        this._notifyEnterLevel(a, self);
        if (self.jumping || moderates) {
          this.jumpLevelPath(self);
        } else {
          this.app.one("cameraFlyComplete", function(canCreateDiscussions) {
            state.jumpLevelPath(self);
          }, "sceneLevel_cameraFlyComplete");
        }
        var cb = self.complete;
        if (cb) {
          cb();
          delete self.userComplete;
        }
      } else {
        this.app.one("cameraFlyComplete", function(canCreateDiscussions) {
          state.jumpLevelPath(self);
        }, "sceneLevel_cameraFlyComplete");
        a.trigger(EventType.EnterLevel, self);
        this._notifyEnterLevel(a, self);
      }
    }
  }, self.prototype._change = function(args, value) {
    value = value || {};
    var that = this;
    if (!this.app.camera.toggleNormalViewMode(function() {
      that._change(args, value);
    })) {
      if ("Outdoors" == args.type) {
        THING.Utils.warn("Please use campus to change, not outdoors");
        args = args.parents.query(".Campus")[0];
      }
      if (!args.isPauseEvent(EventType.EnterLevel)) {
        this._leaveLevel(args, value);
        this._enterLevel(args, value);
      }
    }
  }, self.prototype.updateJumping = function(parent, state) {
    var dom = this._current;
    if (dom && (dom.isChildOf(parent) || dom.isBrotherOf(parent))) {
      state.jumping = true;
      state.skipBackupCameraInfo = true;
    }
  }, self.prototype.getParents = function(node, selector) {
    var path = [];
    var parents = node.parents;
    var i = 0;
    for (; i < parents.length; i++) {
      var node = parents[i];
      if (node == this.app.root) {
        break;
      }
      if (path.push(node), node == selector) {
        break;
      }
    }
    return path;
  }, self.prototype.getLevelPath = function(node, self) {
    if (this._current && this._current.parent != node && Utils.parseValue(this.options.autoEnterSubLevel, self.autoEnterSubLevel)) {
      var results = node.children.concat();
      var i = 0;
      for (; i < results.length; i++) {
        if (!results[i].isFloor) {
          results.splice(i--, 1);
        }
      }
      if (1 === results.length) {
        node = results[0];
      }
    }
    var nodes = [];
    if (this._current == node) {
      nodes = [node];
    } else {
      if (this._current) {
        if (this._current.isChildOf(node)) {
          if ((nodes = this.getParents(this._current, node)).length >= 2) {
            self.jumping = true;
          }
        } else {
          if (node.isChildOf(this._current)) {
            (nodes = (nodes = this.getParents(node, this._current)).reverse()).splice(0, 1);
            nodes.push(node);
          } else {
            if (node.parent == this._current.parent) {
              nodes = node.parent ? [node.parent, node] : [node];
            } else {
              var m = this.getParents(node, null).reverse();
              var s = this.getParents(this._current).reverse();
              if (m.length && s.length) {
                var prepend;
                for (; m.length && s.length && m[0] == s[0];) {
                  prepend = m[0];
                  m.splice(0, 1);
                  s.splice(0, 1);
                }
                if (prepend) {
                  nodes = s.reverse().concat([prepend]).concat(m).concat(node);
                }
              } else {
                nodes = m.concat([node]);
              }
            }
          }
        }
      } else {
        nodes.push(node);
        nodes = (nodes = nodes.concat(node.parents.not(this.app.root).toArray())).reverse();
      }
    }
    if (function(inStyles) {
      var stylesLimit = 0;
      for (; stylesLimit < inStyles.length; stylesLimit++) {
        if (inStyles[stylesLimit].isFacade) {
          return true;
        }
      }
      return false;
    }(nodes)) {
      i = 0;
      for (; i < nodes.length; i++) {
        if (nodes[i].isBuilding) {
          nodes.splice(i, 1);
        }
      }
    }
    return nodes;
  }, self.prototype.jumpLevelPath = function(state) {
    var array = state.levelPath;
    if (array && (array.splice(0, 1), array.length)) {
      var event = array[0];
      if (1 == array.length) {
        delete state.jumping;
        this.app.off("cameraFlyComplete", "sceneLevel_cameraFlyComplete");
      }
      this._change(event, state);
    }
  }, self.prototype.change = function(target, state) {
    if (state = state || {}, target) {
      if (!target.isPauseEvent(EventType.EnterLevel) && target.hasEvent(EventType.EnterLevel) && (Utils.parseValue(state.autoChangeObject, true) && target instanceof pr && (target = target.building), !state.skipCurrentLevel || target != this._current)) {
        var style = this.getLevelPath(target, state);
        if (style.length) {
          var value = style[0];
          var parent = style.length > 1 ? style[style.length - 1] : null;
          if (parent) {
            this.updateJumping(parent, state);
          }
          this.app.off("cameraFlyComplete", null, "sceneLevel_cameraFlyComplete");
          state.userComplete = state.complete;
          state.userFlyComplete = state.flyComplete;
          state.levelPath = style;
          state.lastObject = parent || target;
          this._origin = this._current;
          this._change(value, state);
        }
      }
    } else {
      THING.Utils.error("Please provide the object to change");
    }
  }, self.prototype.quit = function(context) {
    context = context || {};
    if (this._current) {
      this._leaveLevel(null, context);
      this._enterLevel(null, context);
    }
  }, self.prototype.back = function(done) {
    if (done = done || {}, this._current) {
      var parent = this._current.parent;
      if (this.options.autoBackFromSubLevel) {
        if (done.autoBackFromSubLevel) {
          for (; parent && parent.parent && !parent.isCampus;) {
            var csspQueue = parent.children.concat();
            var i = 0;
            for (; i < csspQueue.length; i++) {
              if (csspQueue[i].isFacade) {
                csspQueue.splice(i--, 1);
              }
            }
            if (1 !== csspQueue.length) {
              break;
            }
            parent = parent.parent;
          }
        }
      }
      this.backTo(parent);
    }
  }, self.prototype.backTo = function(obj) {
    if (obj && obj != this._current && obj.isChildOf(this._root)) {
      if (obj.isFacade) {
        obj = obj.parents.query(".Campus")[0];
      }
      var win = this;
      if (!this.app.camera.toggleNormalViewMode(function() {
        win.backTo(obj);
      })) {
        this.change(obj, {
          autoChangeObject : false
        });
      }
    }
  }, self.prototype.isChanged = function() {
    return this._changed;
  }, self.prototype.onUpdate = function(parentBindings) {
    if (this._changed) {
      this._changed = false;
    }
  }, n(self, [{
    key : "current",
    get : function() {
      return this._current;
    }
  }, {
    key : "previous",
    get : function() {
      return this._previous;
    }
  }, {
    key : "root",
    set : function(v) {
      this._root = v;
    },
    get : function() {
      return this._root;
    }
  }, {
    key : "options",
    set : function(value) {
      this._options = Utils.mergeObject(this._options, value, true);
    },
    get : function() {
      return this._options;
    }
  }]), self;
}();
Oh = function() {
  function t(app) {
    r(this, t);
    this.app = app;
    this._backups = {
      camera : {},
      lighting : {},
      postEffect : {}
    };
    this._campusSkyBox = null;
    this._campusBackground = null;
    this._campusSkyBoxColorTween = null;
    this._levelChanging = false;
    this._lastPickedObject = null;
  }
  return t.prototype.setCampusSkyBoxColorScaleFactor = function(head) {
    var duration = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e3;
    if (this._campusSkyBoxColorTween) {
      this._campusSkyBoxColorTween.stop();
    }
    var obj = Utils.parseVector3(this.app.backgroundColorScaleFactor);
    var end = Utils.parseVector3(head);
    var pageViewData = this;
    this._campusSkyBoxColorTween = (new TWEEN.Tween(obj)).to(end, duration).onUpdate(function() {
      pageViewData.app.backgroundColorScaleFactor = [this._object.x, this._object.y, this._object.z];
    });
    this._campusSkyBoxColorTween.start();
  }, t.prototype.updatebackupInfo = function(d, type) {
    var _data = this._backups[d];
    _data[type] = _data[type] || {};
    var data = _data[type];
    if ("camera" == d) {
      data.position = this.app.camera.position;
      data.target = this.app.camera.target;
    } else {
      if ("lighting" == d) {
        data.value = this.app.lighting;
      } else {
        if ("postEffect" == d) {
          data.value = this.app.postEffect;
        }
      }
    }
  }, t.prototype.clearBackupInfo = function(key, obj) {
    delete this._backups[key][obj];
  }, t.prototype.getBackupInfoValue = function(name, category, key) {
    var value = this._backups[name][category];
    return value ? value[key] : null;
  }, t.prototype.initAppEvents = function() {
    var self = this;
    this.app.on("cameracontrollerchanged", function(canCreateDiscussions) {
      if (self.app.level.current && self._levelChanging) {
        self.app.camera.stopFlying();
      }
    }, EventTag.LevelFlyBreak);
    this.app.on("dblclick", function(r) {
      if (0 == r.button) {
        var opts = self.app.level;
        var requests = opts.current;
        if (requests) {
          var w = r.object;
          if (w != requests && function(no_output) {
            return !!no_output && (!no_output.isTextRegion && !no_output.isMarker);
          }(w)) {
            if (w.isGround) {
              return;
            }
            var o = false;
            if (w.isBuilding) {
              o = true;
            }
            opts.change(w, {
              autoEnterSubLevel : o
            });
          }
        }
      }
    }, EventTag.LevelEnterOperation);
    this.app.on("click", function(event) {
      if (2 == event.button) {
        var opts = self.app.level;
        if (opts.current) {
          var button = event.object;
          if (button && button.style.outlineColor) {
            button.style.outlineColor = null;
          }
          var n = false;
          if (opts.current.isFloor) {
            n = true;
          }
          opts.back({
            autoBackFromSubLevel : n
          });
        }
      }
    }, EventTag.LevelBackOperation);
    this.app.on(EventType.Pick, function(dialog) {
      var m = self.app.level;
      if (m.current) {
        if (self._lastPickedObject && self._lastPickedObject.style.outlineColor) {
          self._lastPickedObject.style.outlineColor = null;
        }
        var div = dialog.object;
        if (function(dom) {
          var record = self.app.level.current;
          return !(!record || !dom || dom == record || "Ground" == dom.type || dom.isMarker || record.isCampus && dom.isChildOf(record.ground));
        }(div)) {
          div.style.outlineColor = m.options.outlineColor;
        }
        self._lastPickedObject = div;
      }
    }, EventTag.LevelPickOperation);
    this._campusSkyBox = this.app.skyBox;
    this._campusBackground = this.app.background;
    this.app.on("skyboxchange", function(textures) {
      var applicationData = self.app.level.current;
      if (!(applicationData && !applicationData.isCampus)) {
        self._campusSkyBox = textures.skyBox;
      }
    });
    this.app.on("backgroundChanged", function(textures) {
      var applicationData = self.app.level.current;
      if (!(applicationData && !applicationData.isCampus)) {
        self._campusBackground = textures.background;
      }
    });
  }, t.prototype.buildFlyParams = function(options, o) {
    o = o || {};
    var i = this;
    var transport = this.app.level.options;
    options._flyStart = function() {
      i._levelChanging = true;
    };
    options._flying = function() {
      i._levelChanging = true;
    };
    options._flyStop = function() {
      i._levelChanging = false;
    };
    options._flyComplete = function() {
      i._levelChanging = false;
    };
    options.distance = options.distance || o.distance;
    options.time = Utils.parseValue(options.time || o.time, transport.flyTime);
    options.keepDirection = Utils.parseValue(options.keepDirection || o.keepDirection, false);
    var parent = this.app.level.current;
    if (o.lastObject == parent && (options.offset = options.offset || o.offset, options.worldOffset = options.worldOffset || o.worldOffset, options.xAngle = Utils.parseValue(options.xAngle || o.xAngle, null), options.yAngle = Utils.parseValue(options.yAngle || o.yAngle, null), void 0 === options.radius)) {
      if (void 0 !== o.radius) {
        options.radius = o.radius;
      } else {
        var gmapContext = options.boundingBox || parent.boundingBox;
        options.radius = gmapContext.radius;
      }
    }
    options.targetForFlyComplete = parent;
    var camera = parent.userData.camInfo;
    if (camera) {
      var rotateMatrix = parent.parents.query(".Campus")[0];
      if (rotateMatrix) {
        options.target = rotateMatrix.selfToWorld(camera.target);
        options.position = rotateMatrix.selfToWorld(camera.eye);
      }
    }
    return options;
  }, t.prototype.registerSceneLevelEvents = function() {
    var allTraps = this;
    this.app.on(EventType.EnterLevel, ".BaseObject", function(t) {
      allTraps.onBaseObjectLevelSceneOperations(t);
    }, EventTag.LevelSceneOperations);
    this.app.on(EventType.EnterLevel, ".Campus", function(t) {
      allTraps.onCampusLevelSetBackground(t);
    }, EventTag.LevelSetBackground);
    this.app.on(EventType.EnterLevel, ".Campus", function(t) {
      allTraps.onCampusLevelSetEffect(t);
    }, EventTag.LevelSetEffect);
    this.app.on(EventType.EnterLevel, ".Campus", function(t) {
      allTraps.onCampusLevelSceneOperations(t);
    }, EventTag.LevelSceneOperations);
    this.app.on(EventType.EnterLevel, ".Campus", function(t) {
      allTraps.onCampusLevelPickedResultFunc(t);
    }, EventTag.LevelPickedResultFunc);
    this.app.on(EventType.EnterLevel, ".Campus", function(t) {
      allTraps.onCampusLevelFly(t);
    }, EventTag.LevelFly);
    this.app.on(EventType.LeaveLevel, ".Campus", function(t) {
      allTraps.onCampusLevelLeaveSceneOperations(t);
    }, EventTag.LevelSceneOperations);
    this.app.on(EventType.EnterLevel, ".Facade", function(t) {
      allTraps.onFacadeLevelSetBackground(t);
    }, EventTag.LevelSetBackground);
    this.app.on(EventType.EnterLevel, ".Facade", function(t) {
      allTraps.onFacadeLevelSetEffect(t);
    }, EventTag.LevelSetEffect);
    this.app.on(EventType.EnterLevel, ".Facade", function(t) {
      allTraps.onFacadeLevelSceneOperations(t);
    }, EventTag.LevelSceneOperations);
    this.app.on(EventType.EnterLevel, ".Facade", function(t) {
      allTraps.onFacadeLevelPickedResultFunc(t);
    }, EventTag.LevelPickedResultFunc);
    this.app.on(EventType.EnterLevel, ".Facade", function(t) {
      allTraps.onFacadeLevelFly(t);
    }, EventTag.LevelFly);
    this.app.on(EventType.LeaveLevel, ".Facade", function(t) {
      allTraps.onFacadeLevelLeaveSceneOperations(t);
    }, EventTag.LevelSceneOperations);
    this.app.on(EventType.EnterLevel, ".Building", function(t) {
      allTraps.onBuildingLevelSetBackground(t);
    }, EventTag.LevelSetBackground);
    this.app.on(EventType.EnterLevel, ".Building", function(t) {
      allTraps.onBuildingLevelSetEffect(t);
    }, EventTag.LevelSetEffect);
    this.app.on(EventType.EnterLevel, ".Building", function(t) {
      allTraps.onBuildingLevelSceneOperations(t);
    }, EventTag.LevelSceneOperations);
    this.app.on(EventType.EnterLevel, ".Building", function(t) {
      allTraps.onBuildingLevelPickedResultFunc(t);
    }, EventTag.LevelPickedResultFunc);
    this.app.on(EventType.EnterLevel, ".Building", function(t) {
      allTraps.onBuildingLevelFly(t);
    }, EventTag.LevelFly);
    this.app.on(EventType.LeaveLevel, ".Building", function(t) {
      allTraps.onBuildingLevelLeaveSceneOperations(t);
    }, EventTag.LevelSceneOperations);
    this.app.on(EventType.EnterLevel, ".Floor", function(t) {
      allTraps.onFloorLevelSetBackground(t);
    }, EventTag.LevelSetBackground);
    this.app.on(EventType.EnterLevel, ".Floor", function(t) {
      allTraps.onFloorLevelSetEffect(t);
    }, EventTag.LevelSetEffect);
    this.app.on(EventType.EnterLevel, ".Floor", function(t) {
      allTraps.onFloorLevelSceneOperations(t);
    }, EventTag.LevelSceneOperations);
    this.app.on(EventType.EnterLevel, ".Floor", function(t) {
      allTraps.onFloorLevelPickedResultFunc(t);
    }, EventTag.LevelPickedResultFunc);
    this.app.on(EventType.EnterLevel, ".Floor", function(propName) {
      allTraps.onFloorLevelFly(propName);
    }, EventTag.LevelFly);
    this.app.on(EventType.LeaveLevel, ".Floor", function(t) {
      allTraps.onFloorLevelLeaveSceneOperations(t);
    }, EventTag.LevelSceneOperations);
    this.app.on(EventType.EnterLevel, ".Room", function(t) {
      allTraps.onRoomLevelSceneOperations(t);
    }, EventTag.LevelSceneOperations);
    this.app.on(EventType.EnterLevel, ".Room", function(t) {
      allTraps.onRoomLevelPickedResultFunc(t);
    }, EventTag.LevelPickedResultFunc);
    this.app.on(EventType.EnterLevel, ".Room", function(t) {
      allTraps.onRoomLevelFly(t);
    }, EventTag.LevelFly);
    this.app.on(EventType.LeaveLevel, ".Room", function(t) {
      allTraps.onRoomLevelLeaveSceneOperations(t);
    }, EventTag.LevelSceneOperations);
    this.app.on(EventType.EnterLevel, ".Thing", function(t) {
      allTraps.onThingLevelSceneOperations(t);
    }, EventTag.LevelSceneOperations);
    this.app.on(EventType.EnterLevel, ".Thing", function(t) {
      allTraps.onThingLevelPickedResultFunc(t);
    }, EventTag.LevelPickedResultFunc);
    this.app.on(EventType.EnterLevel, ".Thing", function(t) {
      allTraps.onThingLevelFly(t);
    }, EventTag.LevelFly);
    this.app.on(EventType.LeaveLevel, ".Thing", function(t) {
      allTraps.onThingLevelLeaveSceneOperations(t);
    }, EventTag.LevelSceneOperations);
  }, t.prototype.onBaseObjectLevelSceneOperations = function(result) {
  }, t.prototype.onCampusLevelSetBackground = function(result) {
    if (this.app.level.options.autoChangeBackground) {
      if (this._campusSkyBox) {
        this.app.skyBox = this._campusSkyBox;
        this.setCampusSkyBoxColorScaleFactor([1, 1, 1]);
      } else {
        if (this._campusBackground) {
          this.app.background = this._campusBackground;
        }
      }
    }
  }, t.prototype.onCampusLevelSetEffect = function(result) {
  }, t.prototype.onCampusLevelSceneOperations = function(_) {
    window.MyStart = true;
    var self = _.object;
    if (self.style.outlineColor) {
      self.style.outlineColor = null;
    }
    if (self.ground) {
      self.ground.visible = true;
    }
    var elts = self.children;
    var init = function() {
      var e = elts[i];
      if (e.isBuilding) {
        e.setVisible(true, false);
        var isKeyBoardPaste = e.hasFacades();
        if (isKeyBoardPaste) {
          e.facades.visible = true;
        }
        e.children.forEach(function(item) {
          if (item.isFloor && (isKeyBoardPaste ? e.structShow || (item.visible = false) : item.visible = true, e.app.level.options.autoHideFloorObjects && !item.showObjectsInParentLevels)) {
            if (isKeyBoardPaste && !e.structShow) {
              item.children.forEach(function(oPresentationNode) {
                oPresentationNode.visible = false;
              });
            } else {
              item.children.forEach(function(template) {
                if (!(template.isTextRegion || template.isRoom || template.isDoor || template.isWindow || template.isCombinedObject)) {
                  template.visible = false;
                }
              });
            }
            if (!isKeyBoardPaste || e.structShow) {
              var view = item.misc;
              if (view) {
                view.visible = true;
                view.node.traverse(function(x) {
                  if (x != item.misc.node) {
                    if (!function(cur) {
                      for (; cur && cur != item.misc.node;) {
                        if (cur.isDoorOrWin) {
                          return true;
                        }
                        cur = cur.parent;
                      }
                      return false;
                    }(x)) {
                      x.visible = false;
                    } else {
                      x.visible = true;
                    }
                  }
                });
              }
            }
          }
        });
      } else {
        e.visible = true;
      }
    };
    var i = 0;
    for (; i < elts.length; i++) {
      init();
    }
    window.MyStart = false;
  }, t.prototype.onCampusLevelPickedResultFunc = function(result) {
    function update(o) {
      return "Outdoors" != o.type && !!function(a) {
        var b = a.app.level.current;
        if (!b) {
          return true;
        }
        if (a.isWebView) {
          return true;
        }
        if (a.isMarker) {
          return true;
        }
        if (a.parent == b) {
          if (a.isGround) {
            return true;
          }
          if (a.isBuilding) {
            return a.onReplaceObejcts || (a.onReplaceObejcts = function(event, callback) {
              if ("outlineColor" !== event) {
                return [];
              }
              var stack = [];
              if (a.hasFacades()) {
                var indices = a.facades;
                var i = 0;
                var length = indices.length;
                for (; i < length; i++) {
                  var last = indices[i];
                  if (last.visible) {
                    stack.push(last);
                  }
                }
              }
              return stack.length < 1 && function traverse(obj, parent) {
                if (function(message) {
                  return !!(message && message.isCombinedObject && message.userData) && ("CombineFloorParent" === message.userData.type || "CombineWallParent" === message.userData.type || "CombineRoofParent" === message.userData.type || "CombineCeilingParent" === message.userData.type || void 0);
                }(obj)) {
                  parent.push(obj);
                } else {
                  var i = 0;
                  var inputsSize = obj._children.length;
                  for (; i < inputsSize; i++) {
                    traverse(obj._children[i], parent);
                  }
                }
              }(a, stack), stack;
            }), true;
          }
          if (a.isThing) {
            return true;
          }
        }
        return !!a.isChildOf(b.ground);
      }(o);
    }
    this.app.picker.pickedResultFunc = function(e) {
      if (update(e)) {
        return e;
      }
      var parents = e.parents;
      var i = 0;
      for (; i < parents.length; i++) {
        var obj = parents[i];
        if (update(obj)) {
          return obj;
        }
      }
    };
  }, t.prototype.onCampusLevelFly = function(e) {
    var callback;
    var left;
    var obj = e.object;
    var node = e.previous;
    if (!(node && !node.isCampus && node.isChildOf(obj))) {
      this.clearBackupInfo("camera", "Campus");
    }
    var props = obj.sceneJSONData.camInfo;
    if (props) {
      callback = props.eye.concat();
      left = props.target.concat();
      callback = obj.selfToWorld(callback);
      left = obj.selfToWorld(left);
    }
    var b = e.position || this.getBackupInfoValue("camera", "Campus", "position") || callback;
    var a = e.target || this.getBackupInfoValue("camera", "Campus", "target") || left || obj;
    var current_radius = 0;
    if (!(Utils.isArray(b) && Utils.isArray(a))) {
      current_radius = e.radius || Math.min(obj.boundingBox.radius, 300);
    }
    this.app.camera.flyTo(this.buildFlyParams({
      position : b,
      target : a,
      radius : current_radius
    }, e));
  }, t.prototype.onCampusLevelLeaveSceneOperations = function(e) {
    var parent = e.current;
    if (parent) {
      var data = e.object;
      if (parent.isChildOf(data)) {
        if (parent.isCampus) {
        } else {
          if (data.parents.has(parent)) {
          } else {
            if (data.buildings.has(parent)) {
              if (data.ground) {
                data.ground.visible = false;
              }
              var i = 0;
              for (; i < data.children.length; i++) {
                var el = data.children[i];
                if (el != e.current) {
                  if (el.isBuilding) {
                    el.setVisible(false, true);
                  } else {
                    el.visible = false;
                  }
                }
              }
            }
          }
        }
        if (!e.skipBackupCameraInfo) {
          this.updatebackupInfo("camera", "Campus");
        }
        this.updatebackupInfo("lighting", "Campus");
        this.updatebackupInfo("postEffect", "Campus");
      }
    }
  }, t.prototype.onFacadeLevelSetBackground = function(result) {
  }, t.prototype.onFacadeLevelSetEffect = function(result) {
  }, t.prototype.onFacadeLevelSceneOperations = function(ast) {
    var variable = ast.object;
    variable.visible = true;
    variable.children.forEach(function(oPresentationNode) {
      oPresentationNode.visible = true;
    });
  }, t.prototype.onFacadeLevelPickedResultFunc = function(result) {
    function hide(obj) {
      var parent = obj.app.level.current;
      return !parent || (parent == obj || !!obj.isChildOf(parent));
    }
    this.app.picker.pickedResultFunc = function(e) {
      if (hide(e)) {
        return e;
      }
      var parents = e.parents;
      var i = 0;
      for (; i < parents.length; i++) {
        var target = parents[i];
        if (hide(target)) {
          return target;
        }
      }
    };
  }, t.prototype.onFacadeLevelFly = function(b) {
    var source = b.object;
    this.app.camera.flyTo(this.buildFlyParams({
      target : source
    }, b));
  }, t.prototype.onFacadeLevelLeaveSceneOperations = function(result) {
  }, t.prototype.onBuildingLevelSetBackground = function(result) {
    if (this.app.level.options.autoChangeBackground) {
      this.app.background = null;
      this.app.skyBox = "White";
      this.setCampusSkyBoxColorScaleFactor([.5, .5, .5]);
    }
  }, t.prototype.onBuildingLevelSetEffect = function(result) {
  }, t.prototype.onBuildingLevelSceneOperations = function(link) {
    var obj = link.object;
    if (obj.style.outlineColor) {
      obj.style.outlineColor = null;
    }
    obj.visible = true;
    obj.children.forEach(function(oPresentationNode) {
      oPresentationNode.visible = true;
    });
    obj.parents.query(".Campus")[0].buildings.not(obj).visible = false;
    obj.facades.visible = false;
    var series = obj.floors;
    series.visible = true;
    var i = 0;
    for (; i < series.length; i++) {
      var data = series[i];
      if (obj.app.level.options.autoHideFloorObjects) {
        if (obj.hasFacades()) {
          data.children.forEach(function(oPresentationNode) {
            oPresentationNode.visible = true;
          });
        } else {
          data.children.forEach(function(template) {
            if (!(template.isRoom || template.isDoor || template.isWindow)) {
              template.visible = true;
            }
          });
        }
        var player = data.misc;
        if (player) {
          player.node.traverse(function(listView) {
            listView.ensureVisible(true, true);
          });
        }
      }
      data.showAllRoofs(false);
      data.bake(null);
    }
  }, t.prototype.onBuildingLevelPickedResultFunc = function(result) {
    function t(instance) {
      var c = instance.app.level.current;
      if (!c) {
        return true;
      }
      if (c == instance) {
        return true;
      }
      if (instance.isWebView) {
        return true;
      }
      if (instance.isMarker) {
        return true;
      }
      if (instance.parent == c) {
        if (instance.isThing) {
          return true;
        }
        if (instance.isFloor && "Outdoors" != instance.type) {
          return true;
        }
      }
      return false;
    }
    this.app.picker.pickedResultFunc = function(e) {
      if (t(e)) {
        return e;
      }
      var parents = e.parents;
      var i = 0;
      for (; i < parents.length; i++) {
        var obj = parents[i];
        if (t(obj)) {
          return obj;
        }
      }
    };
  }, t.prototype.onBuildingLevelFly = function(e) {
    var doc = e.object;
    var trackList = doc.floors;
    var style = new THREE.Box3;
    trackList.forEach(function(dynamicObject) {
      var point = dynamicObject.wall;
      if (point) {
        style._setFromObject(point.node, null, null, false);
      }
    });
    var node = li._processBox(style, doc);
    this.app.camera.flyTo(this.buildFlyParams({
      target : doc,
      boundingBox : node,
      radius : node.radius
    }, e));
  }, t.prototype.onBuildingLevelLeaveSceneOperations = function(tag) {
    var layer = tag.object;
    if (layer.style.outlineColor) {
      layer.style.outlineColor = null;
    }
    this.updatebackupInfo("lighting", "Building");
    this.updatebackupInfo("postEffect", "Building");
  }, t.prototype.onFloorLevelSetBackground = function(result) {
    if (this.app.level.options.autoChangeBackground) {
      this.app.skyBox = "White";
      this.setCampusSkyBoxColorScaleFactor([.25, .25, .25]);
    }
  }, t.prototype.onFloorLevelSetEffect = function(result) {
  }, t.prototype.onFloorLevelSceneOperations = function(tab) {
    var node = tab.object;
    if (node.style.outlineColor) {
      node.style.outlineColor = null;
    }
    node.building.floors.not(node).visible = false;
    if (!node.visible) {
      node.visible = true;
      node.showAllRoofs(false);
    }
    if (this.app.level.options.autoBakeFloor) {
      node.bake();
    }
  }, t.prototype.onFloorLevelPickedResultFunc = function(result) {
    function t(instance) {
      var c = instance.app.level.current;
      if (!c) {
        return true;
      }
      if (c == instance) {
        return true;
      }
      if (instance.isWebView) {
        return true;
      }
      if (instance.isMarker) {
        return true;
      }
      if (instance.parent == c) {
        if (instance.isRoom) {
          return true;
        }
        if (instance.isThing) {
          return true;
        }
      }
      return false;
    }
    this.app.picker.pickedResultFunc = function(e) {
      if (t(e)) {
        return e;
      }
      var parents = e.parents;
      var i = 0;
      for (; i < parents.length; i++) {
        var obj = parents[i];
        if (t(obj)) {
          return obj;
        }
      }
    };
  }, t.prototype.onFloorLevelFly = function(node) {
    var context = node.object;
    var prevNode = node.previous;
    if (prevNode.isBuilding || prevNode.isFloor) {
      this.app.camera.flyTo(this.buildFlyParams({
        target : context
      }, node));
      this.clearBackupInfo("camera", "Floor");
    } else {
      var newPosition = this.getBackupInfoValue("camera", "Floor", "position");
      var index = this.getBackupInfoValue("camera", "Floor", "target");
      this.app.camera.flyTo(this.buildFlyParams({
        position : newPosition,
        target : index
      }, node));
    }
  }, t.prototype.onFloorLevelLeaveSceneOperations = function(tag) {
    var layer = tag.object;
    if (layer.style.outlineColor) {
      layer.style.outlineColor = null;
    }
    this.updatebackupInfo("camera", "Floor");
    this.updatebackupInfo("lighting", "Building");
    this.updatebackupInfo("postEffect", "Building");
  }, t.prototype.onRoomLevelSceneOperations = function(tag) {
    var layer = tag.object;
    if (layer.style.outlineColor) {
      layer.style.outlineColor = null;
    }
    var replies = layer.brothers.query(".Room");
    var i = 0;
    for (; i < replies.length; i++) {
      replies[i].things.style.opacity = .25;
    }
  }, t.prototype.onRoomLevelPickedResultFunc = function(result) {
    function hide(a) {
      var b = a.app.level.current;
      if (!b) {
        return true;
      }
      if (a.isWebView) {
        return true;
      }
      if (a.isMarker) {
        return true;
      }
      if (a.isRoom && a != b) {
        return true;
      }
      if (a.isChildOf(b)) {
        if (a.parent == b) {
          return true;
        }
      } else {
        if (a.isThing && a.app.level.current.things.has(a)) {
          return true;
        }
      }
      return false;
    }
    this.app.picker.pickedResultFunc = function(e) {
      if (hide(e)) {
        return e;
      }
      var task = e.app.level.current;
      var parents = e.parents;
      var i = 0;
      for (; i < parents.length; i++) {
        var target = parents[i];
        if (target == task) {
          break;
        }
        if (hide(target)) {
          return target;
        }
      }
    };
  }, t.prototype.onRoomLevelFly = function(b) {
    var source = b.object;
    if (b.previous.isFloor) {
      this.app.camera.flyTo(this.buildFlyParams({
        target : source
      }, b));
    } else {
      var newPosition = this.getBackupInfoValue("camera", "Room", "position");
      var index = this.getBackupInfoValue("camera", "Room", "target");
      this.app.camera.flyTo(this.buildFlyParams({
        position : newPosition,
        target : index
      }, b));
    }
  }, t.prototype.onRoomLevelLeaveSceneOperations = function(self) {
    var target = self.object;
    if (target.style.outlineColor && (target.style.outlineColor = null), !self.lastObject.isChildOf(target)) {
      var replies = target.brothers.query(".Room");
      var i = 0;
      for (; i < replies.length; i++) {
        replies[i].things.style.opacity = null;
      }
    }
    this.updatebackupInfo("camera", "Room");
  }, t.prototype.onThingLevelSceneOperations = function(tag) {
    var layer = tag.object;
    if (layer.style.outlineColor) {
      layer.style.outlineColor = null;
    }
    layer.brothers.query(".Thing").style.opacity = .25;
  }, t.prototype.onThingLevelPickedResultFunc = function(result) {
    function hide(obj) {
      var parent = obj.app.level.current;
      return !parent || (!!obj.isChildOf(parent) || (!!obj.isWebView || (!!obj.isMarker || !(!obj.isThing || !obj.isBrotherOf(parent)))));
    }
    this.app.picker.pickedResultFunc = function(e) {
      if (hide(e)) {
        return e;
      }
      var parents = e.parents;
      var i = 0;
      for (; i < parents.length; i++) {
        var target = parents[i];
        if (hide(target)) {
          return target;
        }
      }
    };
  }, t.prototype.onThingLevelFly = function(result) {
    var view = result.object;
    var i = Utils.parseValue(result.keepDirection, true);
    this.app.camera.flyTo(this.buildFlyParams({
      target : view,
      keepDirection : i,
      centerPos : view.boundingBox.center
    }, result));
  }, t.prototype.onThingLevelLeaveSceneOperations = function(tag) {
    var layer = tag.object;
    if (layer.style.outlineColor) {
      layer.style.outlineColor = null;
    }
    layer.brothers.query(".Thing").style.opacity = null;
  }, t.prototype.init = function() {
    this.initAppEvents();
    this.registerSceneLevelEvents();
  }, t;
}();
Bh = function() {
  function t(app) {
    r(this, t);
    this.app = app;
    this._spriteMaterials = {};
    this._meshMaterials = {};
  }
  return t.prototype.getMaterial = function(input) {
    var t;
    var id = (input = input || {}).url;
    var pre = Utils.parseValue(input.useSpriteMaterial, true);
    if (id) {
      if (pre) {
        if (!this._spriteMaterials[id]) {
          this._spriteMaterials[id] = new THREE.SpriteMaterial({
            color : 16777215,
            transparent : true
          });
        }
        t = this._spriteMaterials[id];
      } else {
        if (!this._meshMaterials[id]) {
          this._meshMaterials[id] = new THREE.MeshBasicMaterial({
            transparent : true,
            side : THREE.DoubleSide,
            depthWrite : false
          });
        }
        t = this._meshMaterials[id];
      }
      t.refCount = t.refCount || 1;
      if (!input.skipRefCount) {
        t.refCount++;
      }
      var loadTexture = input.loadComplete;
      var max = input.loadTextureComplete;
      var s = !t.map || !t.map.image;
      if (s) {
        var CHANNEL_STORE = this.app.resourceManager.textureLoader;
        t.map = CHANNEL_STORE.load(id, function(options) {
          options.refCount++;
          t.map = options;
          t.needsUpdate = true;
          t.visible = true;
          if (max) {
            max({
              material : t
            });
          }
          if (loadTexture) {
            loadTexture({
              material : t
            });
          }
        }, function() {
        }, function(canCreateDiscussions) {
          THING.Utils.error('[Sprite] load "' + id + '" failed');
        }, true);
        t.visible = false;
      } else {
        if (loadTexture) {
          loadTexture({
            material : t
          });
        }
      }
    } else {
      t = pre ? new THREE.SpriteMaterial({
        color : 16777215,
        transparent : true
      }) : new THREE.MeshBasicMaterial({
        transparent : true,
        side : THREE.DoubleSide,
        depthWrite : false
      });
      if (loadTexture) {
        loadTexture({
          material : t
        });
      }
    }
    return {
      material : t,
      needLoadTexture : s
    };
  }, t.prototype.unloadMaterial = function(key) {
    return !(!key || !this.app.resourceManager.disposeMaterial(key));
  }, t.prototype.unloadMaterials = function(c, code) {
    var b = code[c];
    if (this.unloadMaterial(b)) {
      delete code[c];
    }
  }, t.prototype.unload = function(arg) {
    this.unloadMaterials(arg, this._spriteMaterials);
    this.unloadMaterials(arg, this._meshMaterials);
  }, t.prototype.onUpdate = function(parentBindings) {
  }, t;
}();
Fh = function() {
  function t(text, value) {
    r(this, t);
    this.app = text;
    this.modelResource = text.modelResource;
    this.refCount = 1;
    this.URL = value;
    this._boundingBox = null;
    this._loadingBox = null;
    this._skinnedMeshAnimations = [];
    this.node = null;
    this.animations = null;
    this.geometry = null;
    this.materials = null;
  }
  return t.prototype._setupBoundingBox = function() {
    var view = (new THREE.Box3)._setFromObject(this.node);
    var extent = new THREE.Vector3;
    view.getCenter(extent);
    var parent = new THREE.Vector3;
    view.getSize(parent);
    this._boundingBox = {};
    this._boundingBox.center = extent.toArray();
    this._boundingBox.size = parent.toArray();
    this._boundingBox.radius = parent.length();
  }, t.prototype.load = function(result) {
    var modVSelf = this;
    var n = result.node;
    var animations = result.animations;
    var geometry = result.geometry;
    var materials = result.materials;
    if (geometry) {
      this.animations = geometry.animations;
      this.geometry = geometry;
      this.materials = materials;
      this._skinnedMeshAnimations = [{
        node : n,
        meshes : n.getSkinnedMeshes()
      }];
    } else {
      if (n) {
        var boundary_case = this.node != n;
        this.node = n;
        var models = result.models;
        if (models) {
          this.models = models;
          this._skinnedMeshAnimations = [];
          this.models.forEach(function(newChrome) {
            modVSelf._skinnedMeshAnimations.push({
              node : newChrome.node,
              meshes : newChrome.node.getSkinnedMeshes()
            });
          });
        } else {
          if (animations) {
            this.animations = animations;
          } else {
            if (boundary_case || null === animations) {
              this.animations = null;
            }
          }
          this._skinnedMeshAnimations = [{
            node : n,
            meshes : n.getSkinnedMeshes()
          }];
        }
      }
    }
    this._setupBoundingBox();
  }, t.prototype.get = function() {
    return this.refCount++, this;
  }, t.prototype.unload = function() {
    return (0 === this.refCount || (this.refCount--, !this.refCount)) && (!this.modelResource.residentMode && (this.app.resourceManager.unload(this.node), this.app.resourceManager.unload(this._loadingBox), this.node = null, this.animations = null, this.geometry = null, this.materials = null, true));
  }, t.prototype._cloneNode = function() {
    var parent = this;
    if (this.node) {
      var core = this.node.clone();
      var right = [];
      return core.traverse(function(child) {
        var originalGeometry = child.geometry;
        if (originalGeometry) {
          originalGeometry.refCount = originalGeometry.refCount || 1;
          originalGeometry.refCount++;
        }
        if (child.isSkinnedMesh) {
          right.push(child);
        }
      }), this._skinnedMeshAnimations.forEach(function(gltf) {
        var meshes = gltf.meshes;
        var i = 0;
        for (; i < meshes.length; i++) {
          var m = meshes[i];
          var dataSkeleton = meshes[i].skeleton;
          var bones = core.getBones(parent.node, meshes[i].skeleton);
          var u = right[i];
          var e = new THREE.Skeleton(bones, dataSkeleton.boneInverses);
          u.bind(e, m.bindMatrix);
        }
        right.splice(0, meshes.length);
      }), core;
    }
    if (this.geometry) {
      var o = new THREE.SkinnedMesh(this.geometry, this.materials);
      return o.scale.set(1, 1, 1), o;
    }
  }, t.prototype.cloneNode = function() {
    var node = this._cloneNode();
    var callback = function(node) {
      if (node.refCount) {
        node.refCount++;
      } else {
        node.refCount = 1;
      }
    };
    return node.traverseMaterials(function(value) {
      var j;
      for (j in callback(value), value) {
        var texture = value[j];
        if (texture && texture.isTexture) {
          callback(texture);
        }
      }
    }), node;
  }, n(t, [{
    key : "boundingBox",
    get : function() {
      return this._boundingBox || this._setupBoundingBox(), this._boundingBox;
    }
  }, {
    key : "loadingBox",
    get : function() {
      return this._loadingBox;
    },
    set : function(v) {
      this._loadingBox = v;
    }
  }]), t;
}();
Lh = function() {
  function self(value) {
    r(this, self);
    this.app = value;
    this.isResidentMode = false;
    this.models = {};
    this.loadingModels = {};
    this.waitModels = [];
  }
  return self.prototype.onBackgroundProgress = function(canCreateDiscussions) {
  }, self.prototype.get = function(name) {
    var m = this.models[name];
    return m ? m.get() : null;
  }, self.prototype.set = function(index, t, r) {
    var m = this.models[index];
    return m ? m.unload() : (m = new Fh(this.app, index), this.models[index] = m), t && r && m.load({
      node : t,
      animations : r
    }), m;
  }, self.prototype.getBoundingBox = function(type) {
    var item = this.models[type];
    return item ? item.boundingBox : null;
  }, self.prototype.unload = function(name) {
    if (void 0 === name) {
      for (name in this.models) {
        this.models[name].unload();
      }
      return this.clear(), true;
    }
    if (Utils.isString(name)) {
      var a = this.models[name];
      if (a && a.unload()) {
        return delete this.models[name], true;
      }
    }
    return false;
  }, self.prototype.clear = function(name) {
    if (Utils.isNull(name)) {
      this.models = {};
    } else {
      delete this.models[name];
    }
  }, self.prototype._download = function(url, done, force, callback, cb) {
    var val = this.get(url);
    if (val) {
      delete this.loadingModels[url];
      if (force) {
        force(val);
      }
    } else {
      var item = this;
      (new thingjs.GLTFLoader(this.app.loadingManager)).loadFromURL({
        url : url,
        useStaticImage : THING.useStaticImage,
        jsonCallback : function(json) {
          if (done) {
            done(json);
          }
        },
        modelCallback : function(t) {
          var r = t.url;
          var a = item.get(r);
          if (!a) {
            (a = item.set(r)).load(t);
          }
          delete item.loadingModels[url];
          if (force) {
            if (!force(a)) {
              item.unload(url);
            }
          }
        },
        errorCallback : function(r) {
          if (delete item.loadingModels[url], r && r.target && 201 === r.target.status) {
            var controlFlowAction = void 0;
            try {
              controlFlowAction = JSON.parse(r.target.response);
            } catch (e) {
              THING.Utils.error("Error!");
            }
            return THING.Utils.error("[have no right] name: " + controlFlowAction.message + "\nurl: " + url), true;
          }
          if (cb) {
            return cb(r);
          }
        },
        progressCallback : callback
      });
    }
  }, self.prototype.download = function(opts, cb, force, callback, onError) {
    if (this.loadingModels[opts]) {
      this.waitModels.push({
        url : opts,
        jsonCallback : cb,
        modelCallback : force,
        progressCallback : callback,
        errorCallback : onError
      });
    } else {
      this.loadingModels[opts] = {};
      this._download(opts, cb, force, callback, onError);
    }
  }, self.prototype.preload = function(path, images) {
    var complete = (images = images || {}).complete;
    if (Utils.isArray(path)) {
      var r = 0;
      var count = path.length;
      var i = 0;
      for (; i < count; i++) {
        this.download(path[i], function() {
        }, function(canCreateDiscussions) {
          if (++r == count && complete) {
            complete();
          }
        }, function() {
        }, function() {
          if (++r == count && complete) {
            complete();
          }
        });
      }
    } else {
      if (Utils.isString(path)) {
        this.download(path, function() {
        }, function(canCreateDiscussions) {
          if (complete) {
            complete();
          }
        }, function() {
        }, function() {
          if (complete) {
            complete();
          }
        });
      }
    }
  }, self.prototype.needWait = function(action) {
    var a = action.url;
    return !!this.loadingModels[a];
  }, self.prototype.update = function() {
    var i = 0;
    for (; i < this.waitModels.length; i++) {
      var opts = this.waitModels[i];
      if (!this.needWait(opts)) {
        this._download(opts.url, opts.jsonCallback, opts.modelCallback, opts.progressCallback, opts.errorCallback);
        this.waitModels.splice(i--, 1);
      }
    }
  }, self.prototype.onUpdate = function(e) {
    this.update(e);
  }, n(self, [{
    key : "residentMode",
    set : function(v) {
      if (this.isResidentMode = v, !v) {
        var t = [];
        var i;
        for (i in this.models) {
          var item = this.models[i];
          if (0 === item.refCount) {
            var u = item.URL;
            if (item.unload()) {
              t.push(u);
            }
          }
        }
        var k = 0;
        for (; k < t.length; k++) {
          u = t[k];
          delete this.models[u];
        }
      }
    },
    get : function() {
      return this.isResidentMode;
    }
  }]), self;
}();
Ih = function() {
  function e(value) {
    r(this, e);
    this.app = value;
    this.particles = {};
  }
  return e.prototype.get = function(num) {
    return this.particles[num];
  }, e.prototype.set = function(n, t) {
    this.particles[n] = t;
  }, e.prototype.download = function(item, successCallback) {
    var i = item.appendURL("index.json");
    var uploader = this;
    (new THREE.FileLoader(this.app.loadingManager)).load(i, function(i) {
      var data = JSON.parse(i);
      uploader.set(item, data);
      if (successCallback) {
        successCallback(data);
      }
    }, function() {
    }, function() {
    });
  }, e;
}();
Nh = function() {
  function run(app) {
    r(this, run);
    this.app = app;
    this.camera = app.camera;
    this.updateTime = 0;
    this.lastAdjustCameraNear = 0;
  }
  return run.prototype._getMinDistanceForAdjustCameraNear = function(o, done, i, n) {
    var a = Utils.parseVector3(i);
    var position = Utils.parseVector3(this.camera.position);
    var x = Math.min(n, a.distanceTo(position));
    if (x > o) {
      var widget = this.app.picker.intersectResult(done[0], done[1], null, {
        ignoreFrameCheck : false
      });
      if (widget && widget.picked) {
        if (a = widget.getPickedPosition({
          skipOtherPick : true
        })) {
          a = Utils.parseVector3(a);
          x = Math.min(x, position.distanceTo(a));
        }
      }
    }
    return x / o;
  }, run.prototype._getAdjustCameraNear = function(originalTransactionId) {
    var mixer = this.camera.distance;
    if (mixer > 10) {
      var v2ScreenLocation = this.camera.worldToScreen(this.camera.target);
      var NINETY_EIGHT_HOURS = this.camera.screenToWorld(v2ScreenLocation[0], v2ScreenLocation[1]);
      if (NINETY_EIGHT_HOURS) {
        return this.updateTime >= .5 && (this.updateTime = 0, this.lastAdjustCameraNear = this._getMinDistanceForAdjustCameraNear(originalTransactionId, v2ScreenLocation, NINETY_EIGHT_HOURS, mixer)), this.lastAdjustCameraNear;
      }
    }
    return this.camera.near;
  }, run.prototype.processAdjustCameraNear = function() {
    var realVal = Math.max(.1, this._getAdjustCameraNear(120));
    this.app.renderCamera.setNear(realVal);
  }, run.prototype.onUpdate = function() {
    this.updateTime += this.app._deltaTime;
    var x = this.camera._targetObject;
    if (x) {
      x.position = this.camera.target;
    }
  }, run.prototype.onEnter = function() {
    var view = this;
    this.app.on("cameraChange", function(canCreateDiscussions) {
      if (view.camera.autoAdjustNear && !view.app.renderCamera.isLerping) {
        view.processAdjustCameraNear();
      }
      view.app.needUpdate = true;
    }, "__cameraNearFixed__");
    var t = false;
    this.app.on("cameraChangeMouseMove", function(i) {
      if (view.app.camera.inputEnabled && !view.app.isPauseEvent(EventType.Pick, null, EventTag.LevelPickOperation)) {
        t = true;
        view.app.pauseEvent(EventType.Pick, null, EventTag.LevelPickOperation);
      }
    }, "__disable_outline__");
    this.app.on("cameraChangeEnd", function(i) {
      if (t) {
        t = false;
        view.app.resumeEvent(EventType.Pick, null, EventTag.LevelPickOperation);
      }
    }, "__disable_outline__");
  }, run.prototype.onLeave = function() {
    this.app.off("cameraChange", "__cameraNearFixed__");
    this.app.off("cameraChangeMouseMove", "__disable_outline__");
    this.app.off("cameraChangeEnd", "__disable_outline__");
  }, run;
}();
Hh = function() {
  function render(options) {
    var result = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "translate";
    var users = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    r(this, render);
    if (options) {
      this._object = options;
      this._axis = null;
      this._disableAxis = [];
      this.init(options.app, result, users);
      this.control.attach(this._object.node);
      this.app.scene.add(this.control);
      this.control.setPickable(false);
    }
  }
  return render.prototype.init = function(type, value, params) {
    this.app = type;
    this.control = new THREE.TransformControls(this.app.renderCamera, this.app.mainDomElement);
    this.control.traverse(function(data) {
      data.userData.skipOutline = true;
      data.userData.useVisibleOnly = true;
    });
    var me = this;
    this.control.addEventListener("change", function(e) {
      me.onGizmoChange(e);
    });
    this.control.addEventListener("objectChange", function(e) {
      me.onGizmoObjectChange(e);
    });
    this.control.addEventListener("mouseDown", function(e) {
      me.onGizmoMouseDown(e);
    });
    this.control.addEventListener("mouseUp", function(e) {
      me.onGizmoMouseUp(e);
    });
    this.control.getGizomNode = function() {
      return me.control.children[0];
    };
    this.control.getAxisNode = function() {
      return me.control.children[1];
    };
    this.mode = "translate";
    if (Utils.isString(value)) {
      this.mode = value;
      this.params = params || {};
    } else {
      this.params = value || {};
    }
    this.app.on("cameraViewChange", function(e) {
      if (e.view == kkkk.Orthographic) {
        me.setAxis("XZ");
      } else {
        me.setAxis("XYZ");
      }
    });
    if (this.app.camera.viewMode == kkkk.Orthographic) {
      this.setAxis("XZ");
    }
  }, render.prototype.onGizmoChange = function(a22) {
  }, render.prototype.onGizmoObjectChange = function(a22) {
    if (this._object) {
      this._object.dirty = true;
    }
    var res = this.params.change;
    if (res) {
      res.call(this, {
        object : this._object
      });
    }
  }, render.prototype.onGizmoMouseDown = function(a22) {
    this.app.camera.disable({
      rotate : true
    });
    var res = this.params.changeStart;
    if (res) {
      res.call(this, {
        object : this._object
      });
    }
  }, render.prototype.onGizmoMouseUp = function(a22) {
    this.app.camera.resume({
      rotate : true
    });
    var res = this.params.changeEnd;
    if (res) {
      res.call(this, {
        object : this._object
      });
    }
  }, render.prototype.onUpdate = function(parentBindings) {
    if (this._object.static) {
      return this.control.updateMatrixWorld(), true;
    }
  }, render.prototype.onRemove = function() {
    this.app.scene.remove(this.control);
    this.control.detach();
    this.control.dispose();
  }, render.prototype.onVisible = function(value) {
    if (this.control.enabled) {
      this.control.visible = value;
    }
  }, render.prototype.setAxis = function(value) {
    if (this._axis = value, this._axis && "XYZ" != this._axis) {
      var me = this;
      var raycaster = new THREE.Raycaster;
      this.control.userData.original_pointerHover = this.control.pointerHover;
      this.control.axis = value;
      this.control.pointerHover = function(mouse) {
        if (void 0 !== this.object && true !== this.dragging && (void 0 === mouse.button || 0 === mouse.button)) {
          raycaster.setFromCamera(mouse, this.camera);
          var lastComponent = raycaster.intersectObjects(this.getGizomNode().picker[this.mode].children, true)[0] || false;
          if (lastComponent) {
            if (-1 != me._axis.search(lastComponent.object.name)) {
              this.axis = lastComponent.object.name;
            }
          } else {
            this.axis = "";
          }
        }
      };
    } else {
      if (this.control.userData.original_pointerHover) {
        this.control.pointerHover = this.control.userData.original_pointerHover;
        delete this.control.userData.original_pointerHover;
      }
    }
  }, render.prototype.detach = function() {
    this.control.detach();
  }, render.prototype.attach = function(parent) {
    this.control.attach(parent);
  }, render.prototype.updateDisableAxis = function(n, Force, aRoundNumber) {
    var temp = -1;
    var o = 0;
    for (; o < this._disableAxis.length; o++) {
      if (this._disableAxis[o].name == n) {
        temp = o;
        break;
      }
    }
    if (Force) {
      if (-1 !== temp) {
        this._disableAxis.splice(temp, 1);
      }
    } else {
      if (-1 === temp) {
        this._disableAxis.push({
          name : n,
          matchAll : aRoundNumber
        });
      }
    }
  }, render.prototype.enableAxis = function(numEditors) {
    var Repulsion = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    var i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    if (numEditors) {
      this.updateDisableAxis(numEditors, Repulsion, i);
      var obj = this.control;
      if (this._disableAxis.length) {
        var monitoringResult = this;
        var eq_epsilon = function(name) {
          if (!name) {
            return true;
          }
          var i = 0;
          for (; i < monitoringResult._disableAxis.length; i++) {
            var p = monitoringResult._disableAxis[i];
            if (p.matchAll) {
              if (name == p.name) {
                return true;
              }
            } else {
              if (-1 !== name.indexOf(p.name)) {
                return true;
              }
            }
          }
          return false;
        };
        var _getOpColumn = function(asButton) {
          asButton.traverse(function(service) {
            var i = 0;
            for (; i < monitoringResult._disableAxis.length; i++) {
              var layer = monitoringResult._disableAxis[i];
              if (service.name == layer.name) {
                service.visible = false;
              }
            }
          });
        };
        Utils.setValue(obj, "pointerDown", function(p1__3354_SHARP_) {
          var a = this.getGizomNode().axis;
          if (!eq_epsilon(a)) {
            Utils.getBackupValue(obj, "pointerDown").call(this, p1__3354_SHARP_);
          }
        });
        Utils.setValue(obj, "pointerMove", function(p1__3354_SHARP_) {
          var a = this.getGizomNode().axis;
          if (!eq_epsilon(a)) {
            Utils.getBackupValue(obj, "pointerMove").call(this, p1__3354_SHARP_);
          }
        });
        Utils.setValue(obj, "pointerUp", function(p1__3354_SHARP_) {
          var a = this.getGizomNode().axis;
          if (!eq_epsilon(a)) {
            Utils.getBackupValue(obj, "pointerUp").call(this, p1__3354_SHARP_);
          }
        });
        Utils.setValue(obj, "updateMatrixWorld", function() {
          Utils.getBackupValue(obj, "updateMatrixWorld").call(this);
          var blendAliases = this.getGizomNode().gizmo;
          var mode = this.getGizomNode().mode;
          _getOpColumn(blendAliases[mode]);
        });
      } else {
        Utils.revertValue(obj, "pointerDown");
        Utils.revertValue(obj, "pointerMove");
        Utils.revertValue(obj, "pointerUp");
        Utils.revertValue(obj, "updateMatrixWorld");
      }
    }
  }, render.prototype.setSize = function(value) {
    THING.Utils.warn("[AxisTransformControl] Please use '.size' to replace 'setSize()'");
    this.size = value;
  }, n(render, [{
    key : "object",
    get : function() {
      return this.control.object;
    }
  }, {
    key : "node",
    get : function() {
      return this.control;
    }
  }, {
    key : "mode",
    set : function(value) {
      if (value) {
        if ("translate" != value && "rotate" != value && "scale" != value) {
          return void THING.Utils.error('[AxisTransformControl] mode is invalid, must be "translate/rotate/scale"');
        }
        this.control.setMode(value);
      }
    },
    get : function() {
      return this.control.getMode();
    }
  }, {
    key : "space",
    set : function(value) {
      if (value) {
        if ("world" != value && "local" != value) {
          return void THING.Utils.error('[AxisTransformControl] space is invalid, must be "world/local"');
        }
        this.control.setSpace(value);
      }
    },
    get : function() {
      return this.control.space;
    }
  }, {
    key : "size",
    set : function(value) {
      this.control.setSize(value);
    },
    get : function() {
      return this.control.size;
    }
  }, {
    key : "visible",
    set : function(value) {
      this.control.visible = value;
      this.control.enabled = value;
    },
    get : function() {
      return this.control.visible;
    }
  }]), render;
}();
Uh = function() {
  function self(options) {
    r(this, self);
    this.state = options;
    this.app = options.app;
    this.control = options.control;
    this.root = new THREE.Group;
    this.root.userData.childUseWorldAnglesAlways = true;
    this.root.name = "EditObjectGroup";
    this.lastRootPosition = null;
    this.lastRootScale = null;
    this.lastRootRotation = null;
  }
  return self.prototype.hasChanged = function() {
    var data = this.root.position;
    var options = this.root.scale;
    var children = this.root.rotation;
    return !(this.lastRootPosition.equals(data) && this.lastRootScale.equals(options) && this.lastRootRotation.equals(children));
  }, self.prototype.recordTranslation = function() {
    this.state.execute({
      type : "SetNodeTranslation",
      node : this.root,
      position : this.lastRootPosition,
      scale : this.lastRootScale,
      rotation : this.lastRootRotation
    });
    this.synTranslation();
  }, self.prototype.notify = function(name) {
    var options = this.root.children;
    var i = 0;
    for (; i < options.length; i++) {
      var sprite = options[i].userData;
      var _Function_call_ = this.app.objectManager.get(sprite.id);
      if (_Function_call_) {
        var qorSliderAfterShow = _Function_call_.userData._editCallbacks;
        if (qorSliderAfterShow) {
          qorSliderAfterShow[name].call(_Function_call_);
        }
        var _fastUnsafe_Function_bind_ = _Function_call_.userData.selectObjectCallback;
        if (_fastUnsafe_Function_bind_) {
          _fastUnsafe_Function_bind_.call(_Function_call_);
        }
      }
    }
  }, self.prototype._pushSubNodeAttach = function(list, index, left, _, value) {
    var self = this.app.objectManager.getBaseObject(index);
    list.push({
      type : "AttachNode",
      node : self.node,
      nodeParent : self.node.userData.nodeParent
    });
  }, self.prototype.recordSubNodeAttach = function(key, node, selector, expectedArgs) {
    var p = [];
    this._pushSubNodeAttach(p, key, node, selector, expectedArgs);
    this.state.execute(p);
    this.synTranslation();
  }, self.prototype._pushSubNodeOnlyAttach = function(h, type, result, order, n, elem, prefix, row, queue) {
    var i = 0;
    for (; i < result.length; i++) {
      var r = result[i];
      if (this.hasSelected(r)) {
        h.push({
          type : "AttachNode",
          node : result[i].node,
          nodeParent : order[i]
        });
      }
    }
  }, self.prototype.recordSubNodeOnlyAttach = function(string, search, result, r, xml, callback, headers, body) {
    var p = [];
    this._pushSubNodeOnlyAttach(p, string, search, result, r, xml, callback, headers, body);
    this.state.execute(p);
    this.synTranslation();
  }, self.prototype._pushNodeAttach = function(sections, block, el, bool, now) {
    sections.push({
      type : "AttachNode",
      node : block.node,
      nodeParent : el
    });
  }, self.prototype.recordNodeAttach = function(line, node, toggle, type) {
    var item = [];
    this._pushNodeAttach(item, line, node, toggle, type);
    this.state.execute(item);
    this.synTranslation();
  }, self.prototype._pushNodeOnlyAttach = function(list, value, binding, e, ctx, objs, type, a, b) {
    list.push({
      type : "AttachNode",
      node : value.node,
      nodeParent : binding
    });
    var i = 0;
    for (; i < e.length; i++) {
      if (e[i] != value) {
        list.push({
          type : "AttachNode",
          node : e[i].node,
          nodeParent : ctx[i]
        });
      }
    }
  }, self.prototype.recordNodeOnlyAttach = function(reference, val, m, s, n, elem, out, a) {
    var p = [];
    this._pushNodeOnlyAttach(p, reference, val, m, s, n, elem, out, a);
    this.state.execute(p);
    this.synTranslation();
  }, self.prototype._pushNodesAttach = function(h, r, v, q, propertyName) {
    var i = 0;
    for (; i < r.length; i++) {
      var el = r[i];
      var vval = v[i];
      h.push({
        type : "AttachNode",
        node : el.node,
        nodeParent : vval
      });
    }
  }, self.prototype.recordNodesAttach = function(rep, type, i, state_name) {
    var p = [];
    this._pushNodesAttach(p, rep, type, i, state_name);
    this.state.execute(p);
  }, self.prototype._pushSubNodesAttach = function(ast, name, format, area, item) {
  }, self.prototype.recordSubNodesAttach = function(type, tree, i, element) {
    var e = [];
    this._pushSubNodesAttach(e, type, tree, i, element);
    this.state.execute(e);
  }, self.prototype.synTranslation = function() {
    this.lastRootPosition = this.root.position.clone();
    this.lastRootScale = this.root.scale.clone();
    this.lastRootRotation = this.root.rotation.clone();
    var i = 0;
    for (; i < this.root.children.length; i++) {
      var key = this.root.children[i].userData.id;
      if (key) {
        this.app.objectManager.get(key).dirty = true;
      }
    }
  }, self.prototype.updateRoot = function() {
    this.updateControl();
    this.updateRootVisible();
    this.updateRootPosition();
    this.updateSelections();
    this.synTranslation();
    this.app.needUpdate = true;
  }, self.prototype._getNodeCenterPosition = function(result) {
    var v = new THREE.Vector3;
    if (this.state._isSubNode(result)) {
      result.getWorldPosition(v);
    } else {
      var scope = this.app.objectManager.get(result.userData.id);
      if (scope) {
        var d = scope.position;
        var data = scope.centerPos;
        if (data) {
          v.set(data[0], 0, data[1]);
          scope.node.updateMatrixWorld();
          v.applyMatrix4(scope.node.matrixWorld);
          v.y = d[1];
        } else {
          v = Utils.parseVector3(d);
        }
      } else {
        result.getWorldPosition(v);
      }
    }
    return v;
  }, self.prototype.clearSelections = function() {
    this.state._selectionObjects.clear();
  }, self.prototype.addSelection = function(callback) {
    this.state._selectionObjects.add(callback);
  }, self.prototype.hasSelected = function(id) {
    return this.state._selectionObjects.has(id);
  }, self.prototype.updateSelections = function() {
    this.state.objects;
    this.clearSelections();
    var i = 0;
    for (; i < this.root.children.length; i++) {
      var userData = this.root.children[i].userData;
      var index = userData.id;
      if (index) {
        var figure = this.app.objectManager.get(index);
        if (!userData.subNode) {
          this.addSelection(figure);
        }
      }
    }
  }, self.prototype.updateControl = function() {
    if (!this.control.object) {
      if (this.root.children.length) {
        this.control.attach(this.root);
        this.app.scene.add(this.control.node);
        this.synTranslation();
      }
    }
  }, self.prototype.updateRootVisible = function() {
    if (this.root.children.length) {
      this.root.visible = true;
    } else {
      this.root.visible = false;
    }
    this.control.visible = this.root.visible;
  }, self.prototype.updateRootPosition = function() {
    var options = this.root.children;
    if (options.length) {
      var v = new THREE.Vector3;
      var i = 0;
      for (; i < options.length; i++) {
        var format = options[i];
        var n = this._getNodeCenterPosition(format);
        v.add(n);
      }
      v.divideScalar(options.length);
      var note = this.root.parent.worldToLocal(v);
      var tail = this.root.detachChildren(this.app.scene);
      this.root.position.copy(note);
      this.root.attachChildren(tail, this.app.scene);
    }
  }, self.prototype.getObjectInfo = function(fn, type) {
    var triggerLookup = new Set;
    var options = this.root.children;
    var i = 0;
    for (; i < options.length; i++) {
      var o = options[i];
      var res = this.app.objectManager.get(o.userData.id);
      if (!triggerLookup.has(res) && (triggerLookup.add(res), fn && fn.push(res), type)) {
        var a = res.node.userData.nodeParent;
        type.push(a);
      }
    }
  }, self.prototype.getSubNodeInfo = function(saved, tree) {
    var pageViewData = this;
    this.root.traverse(function(r) {
      var t_chksum = pageViewData.app.objectManager.get(r.userData.id);
      if (t_chksum && (-1 !== t_chksum.getSubNodeIndex(r) && (saved && saved.push(r), tree))) {
        var o = r.userData.nodeParent;
        tree.push(o);
      }
    });
  }, self.prototype.recordNodeParent = function(obj) {
    if (obj.isBaseObject) {
      obj = obj.node;
    }
    var parentNode = obj.parent;
    if (parentNode != this.root) {
      obj.userData.nodeParent = parentNode;
    }
  }, self.prototype._pushAddObjects = function(list, args) {
    if (args && args.length) {
      var args = [];
      var i = 0;
      for (; i < args.length; i++) {
        var message = args[i];
        if (!this.hasSelected(message)) {
          args.push(message);
        }
      }
      if (args.length) {
        i = 0;
        for (; i < args.length; i++) {
          message = args[i];
          this.recordNodeParent(message);
          list.push({
            type : "AttachNode",
            node : message.node,
            nodeParent : this.root
          });
        }
      }
    }
  }, self.prototype._dispatchBreakableEvent = function(e, type) {
    return type.continueFlag = true, this.app.trigger(e, type), type.continueFlag;
  }, self.prototype.addObjects = function(callback) {
    var p = [];
    this._pushAddObjects(p, callback);
    this.state.execute(p);
    this.updateRoot();
  }, self.prototype._pushAddSubNodes = function(ast, name) {
    if (name.length) {
      var i = 0;
      for (; i < name.length; i++) {
        var obj = name[i];
        if (this.state._isSubNode(obj)) {
          if (!obj.isChildOf(this.root)) {
            this.recordNodeParent(obj);
          }
        }
      }
    }
  }, self.prototype.addSubNodes = function(modifiedRecords) {
    var e = [];
    this._pushAddSubNodes(e, modifiedRecords);
    this.state.execute(e);
    this.updateRoot();
  }, self.prototype.addSubNode = function(name) {
    return !!this.state._isSubNode(name) && (!!this.app.objectManager.getBaseObject(name) && (this.recordNodeParent(name), this.recordSubNodeAttach(name, this.root, this.state.selectOutlineColor, null), this.updateRoot(), true));
  }, self.prototype.addSubNodeOnly = function(e) {
    if (!e) {
      return false;
    }
    if (!e.userData.subNode) {
      return false;
    }
    if (!this.app.objectManager.getBaseObject(e)) {
      return false;
    }
    var base = [];
    var hash = [];
    this.getObjectInfo(base, hash);
    var value = [];
    var n = [];
    this.getSubNodeInfo(value, n);
    var i = 0;
    for (; i < value.length; i++) {
      if (value[i] == e) {
        value.splice(i, 1);
        break;
      }
    }
    return this.recordNodeParent(e), this.recordSubNodeOnlyAttach(e, base, hash, value, n, this.root, this.state.selectOutlineColor, null), this.updateRoot(), true;
  }, self.prototype.add = function(cmd, obj) {
    if (!(obj && this.addSubNode(obj.intersect.node))) {
      this.recordNodeParent(cmd);
      this.recordNodeAttach(cmd, this.root, this.state.selectOutlineColor, null);
      this.updateRoot();
    }
  }, self.prototype.addOnly = function(key, obj) {
    if (!(obj && this.addSubNodeOnly(obj.intersect.node) || 1 == this.root.children.length && this.has(key))) {
      var i = [];
      var r = [];
      this.getObjectInfo(i, r);
      var saved = [];
      var clone = [];
      this.getSubNodeInfo(saved, clone);
      this.recordNodeParent(key);
      this.recordNodeOnlyAttach(key, this.root, i, r, saved, clone, this.state.selectOutlineColor, null);
      this.updateRoot();
    }
  }, self.prototype.remove = function(options) {
    if (this.state._isSubNode(options)) {
      var child = this.root.children;
      var offset = 0;
      for (; offset < child.length; offset++) {
        if ((value = child[offset]) == options) {
          var treeRoot = value.userData.nodeParent;
          this.recordSubNodeAttach(options, treeRoot, null, this.state.selectOutlineColor);
          break;
        }
      }
    } else {
      child = this.root.children;
      offset = 0;
      for (; offset < child.length; offset++) {
        var value = child[offset];
        var api = this.app.objectManager.get(value.userData.id);
        if (options == api) {
          this.app.trigger("unselectEditableObject", {
            object : api
          });
          treeRoot = value.userData.nodeParent;
          this.recordNodeAttach(options, treeRoot, null, this.state.selectOutlineColor);
          break;
        }
      }
    }
    this.updateRoot();
  }, self.prototype.removeAll = function() {
    if (this.root.children.length) {
      var e = [];
      var THREAD_STARTED = [];
      this.getObjectInfo(e, THREAD_STARTED);
      var saved = [];
      var scaffoldArgument = [];
      this.getSubNodeInfo(saved, scaffoldArgument);
      var i = 0;
      for (; i < e.length; i++) {
        var g = e[i];
        this.app.trigger("unselectEditableObject", {
          object : g
        });
      }
      this.state.canRespondFromCommandManager = false;
      this.recordNodesAttach(e, THREAD_STARTED, null, this.state.selectOutlineColor);
      this.recordSubNodesAttach(saved, scaffoldArgument, null, this.state.selectOutlineColor);
      this.state.canRespondFromCommandManager = true;
      this.updateRoot();
    }
  }, self.prototype.has = function(value) {
    var options = this.root.children;
    if (this.state._isSubNode(value)) {
      var i = 0;
      for (; i < options.length; i++) {
        if ((item = options[i]).userData.subNode && item == value) {
          return true;
        }
      }
    } else {
      i = 0;
      for (; i < options.length; i++) {
        var item;
        if (!(item = options[i]).userData.subNode) {
          if (value == this.app.objectManager.get(item.userData.id)) {
            return true;
          }
        }
      }
    }
    return false;
  }, self.prototype.attach = function() {
    this.root.attachToParent(this.app.scene, this.app.scene);
  }, self.prototype.detach = function() {
    this.removeAll();
    this.control.detach();
    this.app.scene.remove(this.control.node);
    this.root.detachFromParent(this.app.scene);
    this.updateRoot();
  }, self.prototype.clearScene = function() {
    var e = [];
    this.state._pushDeleteSubNodes(e, this.state.subNodes);
    this.state._pushDeleteObjects(e, this.state.objects);
    this.state.execute(e, true);
    this.updateRoot();
  }, self.prototype.toJSON = function() {
    var keys = Array.from(this.state._selectionObjects);
    var i = 0;
    for (; i < keys.length; i++) {
      this.remove(keys[i]);
    }
    var values = this.state.subNodes;
    i = 0;
    for (; i < values.length; i++) {
      this.remove(values[i]);
    }
    var picmenu_list = [];
    var data = this.state.objects;
    i = 0;
    for (; i < data.length; i++) {
      var node = data[i];
      picmenu_list.push(node.toJSON());
    }
    i = 0;
    for (; i < values.length; i++) {
      this.addSubNode(values[i]);
    }
    i = 0;
    for (; i < keys.length; i++) {
      this.add(keys[i]);
    }
    return JSON.stringify(picmenu_list);
  }, self.prototype.pasteObjects = function() {
    THING.Utils.warn('[EditObjectState] we do not support ".pasteObjects()" anymore, please do not use it');
  }, self.prototype.fromJSON = function(layerJSON) {
    THING.Utils.warn('[EditObjectState] we do not support ".fromJSON()" anymore, please do not use it');
  }, self;
}();
zh = function() {
  function self(value) {
    r(this, self);
    var me = this;
    this.app = value;
    this.picker = value.picker;
    this.copyObjectsJSONData = [];
    this._selectionObjects = new Set;
    this.canRespondFromCommandManager = false;
    this._enableDirectMode = false;
    this._enableKeyMode = false;
    this._enableAutoRemoveAllWhenClick = true;
    this.app.on("push", function(e) {
      me.onPush(e);
    });
    this.app.on("redo", function(e) {
      me.onRedo(e);
    });
    this.app.on("undo", function(e) {
      me.onUndo(e);
    });
    var servicename = {
      changeEnd : function(val) {
        if (me.group.hasChanged()) {
          me.group.recordTranslation();
          me.group.notify("modify");
        }
      }
    };
    this.control = new Hh;
    this.control.init(value, "translate", servicename);
    this.selectOutlineColor = "#0000FF";
    this.group = new Uh(this);
  }
  return self.prototype.onPush = function(event) {
    if (this.canRespondFromCommandManager) {
      this.group.updateRoot();
    }
  }, self.prototype.onRedo = function(y) {
    if (this.canRespondFromCommandManager) {
      this.group.updateRoot();
    }
  }, self.prototype.onUndo = function(y) {
    if (this.canRespondFromCommandManager) {
      this.group.updateRoot();
    }
  }, self.prototype.notify = function(action, event) {
    var info_window_options = action.userData._editCallbacks;
    if (info_window_options) {
      info_window_options[event].call(action);
    }
  }, self.prototype.startDrag = function(node, x, y, obj) {
    if (node) {
      obj = obj || .1;
      this.app.camera.disable({
        rotate : true
      });
      node.pickable = false;
      node.catchEventAnyTime = true;
      node.node.userData.skipPick = true;
      node.position = app.camera.screenToWorld(x, y);
      var self = this;
      node.on("mousemove", function(event) {
        var pushingTo = self.app.picker.pickWorldPosition(event.clientX, event.clientY);
        if (!pushingTo) {
          pushingTo = self.app.camera.screenToWorld(event.clientX, event.clientY);
        }
        if (pushingTo) {
          pushingTo[1] += obj;
          this.position = pushingTo;
        }
      }, "startDrag_mousemove");
      node.on("mouseup", function(canCreateDiscussions) {
        this.pickable = true;
        this.catchEventAnyTime = false;
        delete this.node.userData.skipPick;
        if (self.group._dispatchBreakableEvent("selectEditableObject", {
          object : this
        })) {
          self.selectObject(this);
        }
        this.off("mousemove", null, "startDrag_mousemove");
        this.off("mouseup", null, "startDrag_mouseup");
        self.app.camera.resume({
          rotate : true
        });
        self.notify(this, "dragEnd");
      }, "startDrag_mouseup");
    }
  }, self.prototype.selectObject = function(object) {
    var mode = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "translate";
    var matched_check = arguments[2];
    if ("translate" == mode || "rotate" == mode) {
      this.group.addOnly(object);
      if (matched_check) {
        object.userData.selectObjectCallback = matched_check;
      }
      this.setMode(mode);
    } else {
      THING.Utils.error("The mode must be 'translate' or 'rotate'");
    }
  }, self.prototype.unselectObject = function(symbol) {
    this.group.remove(symbol);
  }, self.prototype.setMode = function(value) {
    if (value) {
      this.control.mode = value;
    }
  }, self.prototype.parseParams = function(obj) {
    var t = obj.type;
    if ("RouteLine" == t || "PolygonLine" == t) {
      var points = obj.points;
      if (!points) {
        points = [[-5, 0, -5], [0, 0, -5], [0, 0, 0], [0, 0, 5], [5, 0, 5]];
        obj.points = points;
        obj.style = obj.style || {};
        var style = obj.style;
        if (style.color = Utils.parseValue(style.color, 5824222), obj.image) {
          if (void 0 === obj.scrollUV) {
            obj.scrollUV = true;
          }
        }
      }
    } else {
      if ("Water" == t) {
        points = [[-20, 0, -20], [-20, 0, 20], [20, 0, 20], [20, 0, -20]];
        obj.points = points;
        obj.normalMap0 = Utils.parseValue(obj.normalMap0, "images/water/Water_1_M_Normal.jpg");
        obj.normalMap1 = Utils.parseValue(obj.normalMap1, "images/water/Water_2_M_Normal.jpg");
      } else {
        if ("Region" == t) {
          points = [[-20, 0, -20], [-20, 0, 20], [20, 0, 20], [20, 0, -20]];
          obj.points = points;
          obj.fontColor = Math.random();
          obj.fontSize = THING.Math.randomInt(9, 32);
          obj.fontText = "Hello";
        }
      }
    }
    return Utils.cloneObject(obj);
  }, self.prototype.addObjects = function(list) {
    var existing = [];
    var i = 0;
    for (; i < list.length; i++) {
      var message = list[i];
      if (message instanceof BaseObject) {
        message.internalUserData.editable = true;
        existing.push(message);
      } else {
        THING.Utils.error("The object is not BaseObject, so we can not add object to edit state");
      }
    }
    this.group.addObjects(existing);
  }, self.prototype.createObject = function(params, next) {
    (params = params || {}).internalUserData = {
      editable : true
    };
    var complete = (params = this.parseParams(params)).complete;
    params.complete = function() {
      if (complete) {
        complete();
      }
    };
    var action = this.app.create(params);
    return next && (action.userData._editCallbacks = next), action;
  }, self.prototype._pushDeselectObject = function(result, self) {
    if (self) {
      result.push({
        type : "AttachNode",
        node : self.node,
        nodeParent : self.node.userData.nodeParent
      });
    }
  }, self.prototype._pushDeleteObject = function(t, set) {
    if (set) {
      this._pushDeselectObject(t, set);
    }
  }, self.prototype.deleteObject = function(key) {
    this.notify(key, "remove");
    var e = [];
    this._pushDeleteObject(e, key);
    this.execute(e, true);
    this.group.updateRoot();
  }, self.prototype._pushDeleteObjects = function(e, t) {
    var ii = 0;
    for (; ii < t.length; ii++) {
      var fragment = t[ii];
      this._pushDeleteObject(e, fragment);
    }
  }, self.prototype.deleteObjects = function(data) {
    var i = 0;
    for (; i < data.length; i++) {
      this.notify(data[i], "remove");
    }
    var targets = [];
    this._pushDeleteObjects(targets, data);
    this.execute(targets, true);
    this.group.updateRoot();
  }, self.prototype._isSubNode = function(object) {
    return !!object && (!object.isBaseObject && !!object.userData.subNode);
  }, self.prototype._isBreakByControlAxis = function(result) {
    var courseSections = result.intersect;
    return (!courseSections || !this._isSubNode(courseSections.node)) && !(!this.control.axis || !this.control.visible);
  }, self.prototype._isCanPick = function(obj) {
    if (this._isBreakByControlAxis(obj)) {
      return false;
    }
    var context = obj.object;
    if (context) {
      if (context == this.app.outdoors) {
        return false;
      }
      if (!context.internalUserData.editable) {
        return false;
      }
    }
    return true;
  }, self.prototype._getSortedSubNodes = function(frames, value) {
    var result = [];
    var i = 0;
    for (; i < frames.length; i++) {
      var n = frames[i];
      var body = n.userData;
      var node = this.app.objectManager.get(body.id);
      var a = node.getSubNodeIndex(n);
      result.push({
        index : a,
        node : n,
        object : node
      });
    }
    return result.sort(value), result;
  }, self.prototype._pushInsertSubNode = function(component, obj) {
  }, self.prototype.insertSubNode = function() {
    var subNodes = this.subNodes;
    if (subNodes.length) {
      var targets = [];
      this._pushInsertSubNode(targets, subNodes);
      this.execute(targets, true);
      this.group.updateRoot();
    }
  }, self.prototype._pushDeleteSubNodes = function(e, assertion) {
  }, self.prototype.deleteSubNodes = function(obj) {
    var targets = [];
    this._pushDeleteSubNodes(targets, obj);
    this.execute(targets, true);
    this.group.updateRoot();
  }, self.prototype.deleteSelections = function() {
    var e = Array.from(this._selectionObjects);
    if (e.length) {
      this.deleteObjects(e);
    }
    var subNodes = this.subNodes;
    if (subNodes.length) {
      this.deleteSubNodes(subNodes);
    }
  }, self.prototype.deselectObjects = function(objects) {
    if (objects) {
      var i = 0;
      for (; i < objects.length; i++) {
        this.group.remove(objects[i]);
      }
    }
  }, self.prototype.copyObjects = function(webhooks) {
    this.copyObjectsJSONData = [];
    var i = 0;
    for (; i < webhooks.length; i++) {
      var options = webhooks[i];
      var param = options.toJSON();
      param.localPosition = options.localPosition;
      param.localAngles = options.localAngles;
      param.scale = options.scale;
      this.copyObjectsJSONData.push(JSON.stringify(param));
    }
  }, self.prototype.selectAll = function() {
    this.group.addObjects(this.objects);
  }, self.prototype.clearScene = function() {
    this.group.clearScene();
  }, self.prototype.toJSON = function() {
    this._enableDirectMode = true;
    var e = this.group.toJSON();
    return this._enableDirectMode = false, e;
  }, self.prototype.fromJSON = function(layerJSON) {
    if (layerJSON) {
      this.group.fromJSON(layerJSON);
    }
  }, self.prototype.execute = function(e, parent) {
    if (this._enableDirectMode) {
      var cell = this.app.commandManager.create(e, parent);
      return cell ? cell.execute() : null;
    }
    return this.app.commandManager.execute(e, parent);
  }, self.prototype.processAreaPicking = function(entry) {
    var records = entry.objects;
    if (records) {
      var objects = this.objects;
      var objectsExpand = [];
      var i = 0;
      for (; i < objects.length; i++) {
        var object = objects[i];
        if (!records.has(object)) {
          objectsExpand.push(object);
        }
      }
      this.deselectObjects(objectsExpand);
      if (records.length) {
        if (records[0] instanceof BaseObject) {
          this.group.addObjects(records);
        } else {
          this.group.addSubNodes(records);
        }
      }
    }
  }, self.prototype.onMouseDown = function(event) {
  }, self.prototype.onMouseUp = function(e) {
    if (e.finishedAreaPicking) {
      this.processAreaPicking(e);
    }
  }, self.prototype.onMouseMove = function(e) {
    if (e.areaPicking) {
      this._enableDirectMode = true;
      this.processAreaPicking(e);
      this._enableDirectMode = false;
    }
  }, self.prototype.onClick = function(target) {
    if (this.app.events.canClick(target)) {
      var t = this.app.isKeyPressed(south1.Ctrl);
      var x = target.object;
      if (x && this._isCanPick(target)) {
        if (t) {
          var current = target.intersect.node;
          if (this.group.has(x)) {
            this.group.remove(x);
          } else {
            if (this.group.has(current)) {
              this.group.remove(current);
            } else {
              if (this.group._dispatchBreakableEvent("selectEditableObject", {
                object : x
              })) {
                this.group.add(x, target);
              }
            }
          }
        } else {
          if (this.group._dispatchBreakableEvent("selectEditableObject", {
            object : x
          })) {
            this.group.addOnly(x, target);
          }
        }
      } else {
        if (!t) {
          if (this.enableAutoRemoveAllWhenClick) {
            this.group.removeAll();
          }
        }
      }
    }
  }, self.prototype.onKeyDown = function(altKey) {
    if (this._enableKeyMode) {
      switch(event.keyCode) {
        case south1.Q:
          this.control.setSpace("local" === this.control.space ? "world" : "local");
          break;
        case south1.EventType:
          this.control.mode = "translate";
          break;
        case south1.E:
          this.control.mode = "rotate";
          break;
        case south1.R:
          break;
        case south1.EqualSign:
        case south1.Add:
          this.control.size = this.control.size + .1;
          break;
        case south1.Dash:
        case south1.Subtract:
          this.control.size = Math.max(this.control.size - .1, .1);
          break;
        case south1.Y:
          if (this.app.isKeyPressed(south1.Ctrl)) {
            this.app.commandManager.redo();
          }
          break;
        case south1.Z:
          if (this.app.isKeyPressed(south1.Ctrl)) {
            this.app.commandManager.undo();
          }
          break;
        case south1.C:
          if (this.app.isKeyPressed(south1.Ctrl)) {
            this.copyObjects(Array.from(this._selectionObjects));
          }
          break;
        case south1.V:
          if (this.app.isKeyPressed(south1.Ctrl)) {
            this.pasteObjects();
          }
          break;
        case south1.A:
          if (this.app.isKeyPressed(south1.Ctrl)) {
            this.selectAll();
          }
          break;
        case south1.Delete:
          this.deleteSelections();
      }
    }
  }, self.prototype.onKeyUp = function(state) {
  }, self.prototype.onUpdate = function(parentBindings) {
  }, self.prototype.onEnter = function(callback, options) {
    if (options) {
      this.canRespondFromCommandManager = true;
      var objects = options.objects;
      if (objects) {
        var i = 0;
        for (; i < objects.length; i++) {
          this.group.add(objects[i]);
        }
      }
      this.group.attach();
      this.control.mode = "translate";
      var self = this;
      this.app.on("areaPickStart", function(canCreateDiscussions) {
        var items = self.candidateForSubNodes;
        if (!items.length) {
          items = self.objects;
        }
        self.app.picker.candidates = items;
      }, "editObject_areaPickStart");
      this.app.on("areaPickEnd", function(canCreateDiscussions) {
        self.app.picker.candidates = null;
      }, "editObject_areaPickEnd");
      this.app.modelResource.residentMode = true;
    } else {
      THING.Utils.log("Gizmo state need params");
    }
  }, self.prototype.onLeave = function(data) {
    this.group.detach();
    this.canRespondFromCommandManager = false;
    this.app.modelResource.residentMode = false;
    this.app.off("areaPickStart", null, "editObject_areaPickStart");
    this.app.off("areaPickEnd", null, "editObject_areaPickEnd");
  }, n(self, [{
    key : "enableKeyMode",
    set : function(v) {
      this._enableKeyMode = v;
    },
    get : function() {
      return this._enableKeyMode;
    }
  }, {
    key : "areaPicking",
    set : function(v) {
      this.picker.areaPicking = v;
      if (!v) {
        this.picker.candidates = null;
      }
    },
    get : function() {
      return this.picker.areaPicking;
    }
  }, {
    key : "enableAutoRemoveAllWhenClick",
    set : function(v) {
      this._enableAutoRemoveAllWhenClick = v;
    },
    get : function() {
      return this._enableAutoRemoveAllWhenClick;
    }
  }, {
    key : "objects",
    get : function() {
      var parsedList = [];
      return this.app.objectManager.objects.forEach(function(contact) {
        if (contact.internalUserData.editable) {
          parsedList.push(contact);
        }
      }), parsedList;
    }
  }, {
    key : "subNodes",
    get : function() {
      var e = [];
      var cells = this.group.root.children;
      var i = 0;
      for (; i < cells.length; i++) {
        var f = cells[i];
        if (f.userData.subNode) {
          e.push(f);
        }
      }
      return e;
    }
  }, {
    key : "candidateForSubNodes",
    get : function() {
      var promises = new Set;
      var items = this.group.root.children;
      var i = 0;
      for (; i < items.length; i++) {
        var w = items[i].userData;
        if (w.subNode) {
          var n = w.id;
          if (n) {
            promises.add(this.app.objectManager.get(n));
          }
        }
      }
      var failedTransactions = [];
      return promises.forEach(function(results) {
        failedTransactions = failedTransactions.concat(results.subNodes);
      }), failedTransactions;
    }
  }]), self;
}();
Vh = function() {
  function a(value) {
    r(this, a);
    this.app = value;
  }
  return a.prototype._getNavigationObject = function(self, name) {
    if (self.getNavigation(name)) {
      return self;
    }
    var parents = self.parents;
    var i = 0;
    for (; i < parents.length; i++) {
      var parent = parents[i];
      if (parent.getNavigation(name)) {
        return parent;
      }
    }
    return null;
  }, a.prototype._tryGetRoomFromPosition = function(options, value) {
    if (!value) {
      return null;
    }
    var param = options.isFloor ? options : options.parents.query(".Floor")[0];
    return param ? param.getRoomFromWorldPosition(value) : null;
  }, a.prototype._getObjectRoot = function(container, name) {
    function get(node, parent) {
      if (parent == node) {
        return node;
      }
      if (parent.isChildOf(node)) {
        return node;
      }
      var parents = node.parents;
      var i = 0;
      for (; i < parents.length; i++) {
        var element = parents[i];
        if (parent == element) {
          return element;
        }
        if (parent.isChildOf(element)) {
          return element;
        }
      }
      return null;
    }
    var node = get(container, name);
    var child = get(name, container);
    return node.isChildOf(child) ? child : node;
  }, a.prototype._setupGraph = function(m, data) {
    var time = this._getObjectRoot(m.floor, data.floor);
    if (!time) {
      return null;
    }
    var x = time;
    for (; x; x = x.parent) {
      if (Utils.isFunction(x.setupGraph)) {
        return x.setupGraph(m, data);
      }
    }
    return null;
  }, a.prototype._buildPathes = function(args) {
    var tweens = [];
    var max = null;
    var i = 0;
    for (; i < args.length; i++) {
      var s = this.app.query("#" + args[i])[0];
      if (s && (!s.isCampus && !s.isFloor)) {
        var g = s.parent;
        if (max != g) {
          tweens.push({
            startObject : s,
            endObject : s
          });
          max = g;
        } else {
          tweens[tweens.length - 1].endObject = s;
        }
      }
    }
    return tweens;
  }, a.prototype.findPath = function(options) {
    var isFunction = (options = options || {}).error || function() {
      console.error.apply(console, arguments);
    };
    var u = options.clipAreas;
    var n = options.startObject || options.startRoom || options.start;
    var r = options.endObject || options.endRoom || options.end;
    if (!n) {
      return isFunction({
        text : "Needs start object to find path in navigation"
      }), null;
    }
    if (!r) {
      return isFunction({
        text : "Needs end object to find path in navigation",
        startObject : n
      }), null;
    }
    var start = options.startPosition || n.position;
    var v = options.endPosition || r.position;
    if (!start) {
      return isFunction({
        text : "Needs start position to find path in navigation",
        startObject : n,
        endObject : r
      }), null;
    }
    if (!v) {
      return isFunction({
        text : "Needs end position to find path in navigation",
        startObject : n,
        endObject : r,
        startPosition : start
      }), null;
    }
    var a = this._getNavigationObject(n, u);
    var p = this._getNavigationObject(r, u);
    if (!a) {
      return isFunction({
        text : "The parents of start object are not support navigation",
        startObject : n,
        endObject : r,
        startPosition : start,
        endPosition : v
      }), null;
    }
    if (!p) {
      return isFunction({
        text : "The parents of end object are not support navigation",
        startParentObject : a,
        startObject : n,
        endObject : r,
        startPosition : start,
        endPosition : v
      }), null;
    }
    var series = [];
    if (a == p) {
      var p = a.findPath(start, v, .1, n, r);
      if (!p) {
        return isFunction({
          text : "Find path failed",
          startParentObject : a,
          startPosition : start,
          endPosition : v
        }), null;
      }
      series.push({
        entrance : a,
        points : p
      });
    } else {
      var msg = {
        id : "start",
        position : start,
        floor : a,
        room : n
      };
      var data = {
        id : "end",
        position : v,
        floor : p,
        room : r
      };
      var self = this._setupGraph(msg, data);
      if (!self) {
        return isFunction({
          text : "Create navigation graph failed",
          startParentObject : a,
          endParentObject : p
        }), null;
      }
      var graphPath = self.findShortestPath(msg.id, data.id);
      if (!graphPath || !graphPath.length) {
        return isFunction({
          text : "Find shortest path failed",
          startPointObject : msg,
          endPointObject : data
        }), null;
      }
      series.graphPath = graphPath;
      var row = this._buildPathes(graphPath);
      if (!row.length) {
        return null;
      }
      var current;
      var item = (current = row[0]).endObject;
      if (!(current = a.findPath(start, item.position))) {
        return isFunction({
          text : "Find first path failed",
          startParentObject : a,
          startPosition : start,
          endPosition : item.position
        }), null;
      }
      series.push({
        points : current,
        entrance : item
      });
      var method = 1;
      for (; method < row.length - 1; method++) {
        var options = row[method];
        if (options.startObject != options.endObject) {
          var path = this.findPath({
            startObject : options.startObject,
            endObject : options.endObject
          });
          if (!path) {
            return isFunction({
              text : "Find middle path failed",
              startObject : options.startObject,
              endObject : options.endObject
            }), null;
          }
          series.push(path);
        }
      }
      var str;
      var config = (str = row[row.length - 1]).startObject;
      if (!(str = p.findPath(config.position, v))) {
        return isFunction({
          text : "Find last path failed",
          endParentObject : p,
          startPosition : config.position,
          endPosition : v
        }), null;
      }
      series.push({
        points : str,
        entrance : config
      });
    }
    return series;
  }, a;
}();
Wh = function() {
  function a(value) {
    r(this, a);
    this.app = value;
    this._navigation = new Vh(value);
    this.lineIndex = -1;
    this.floor = null;
    this.lines = [];
    this.routeLines = [];
    this.lineParams = {};
    this._object = null;
    this._defaultObject = null;
    this.speed = 0;
    this.liftSpeed = 0;
    this.startCallback = null;
    this.changeFloorCallback = null;
    this.completeCallback = null;
  }
  return a.prototype.findPath = function(path, start, callback, a) {
    var query = {
      start : path,
      startPosition : start,
      end : callback,
      endPosition : a
    };
    var data = this._navigation.findPath(query);
    return data ? (this.createLine(data), data) : null;
  }, a.prototype.clearPath = function() {
    this.destroyLine();
  }, a.prototype.showPath = function() {
    if (this.routeLines.length) {
      if (0 === arguments.length) {
        var i = 0;
        for (; i < this.routeLines.length; i++) {
          this.routeLines[i].line.visible = true;
        }
      } else {
        if (1 === arguments.length) {
          var channel = arguments[0];
          i = 0;
          for (; i < this.routeLines.length; i++) {
            this.routeLines[i].line.visible = channel;
          }
        } else {
          if (2 === arguments.length) {
            var ceil = arguments[0];
            channel = arguments[1];
            i = 0;
            for (; i < this.routeLines.length; i++) {
              var m = this.routeLines[i];
              var floor = m.floor;
              var to = m.line;
              if (floor == ceil) {
                to.visible = channel;
              }
            }
          }
        }
      }
    }
  }, a.prototype.createEvent = function(type) {
    var segment = type;
    return segment.speed = this.speed, segment.liftSpeed = this.liftSpeed, segment;
  }, a.prototype.getLinesParent = function(data) {
    return data.building ? data.building : data;
  }, a.prototype.setLineParams = function(category) {
    (category = category || {}).type = category.type || "RouteLine";
    var label = category.type;
    if ("Line" == label) {
      category.color = category.color || 65280;
      category.dotSize = category.dotSize || 2;
      category.dotColor = category.dotColor || 16711680;
    } else {
      if ("RouteLine" == label) {
        category.scrollUV = Utils.parseValue(category.scrollUV, false);
      }
    }
    this.lineParams = category;
  }, a.prototype.createLine = function(data) {
    if (data) {
      var lastModuleItem = this.getLinesParent(data[0].entrance);
      if (lastModuleItem) {
        this.destroyLine();
        this.lineIndex = 0;
        var index = 0;
        for (; index < data.length; index++) {
          var result = data[index];
          var courseSections = result.entrance;
          var points = result.points;
          this.lines.push({
            entrance : courseSections,
            points : points
          });
          var item = Utils.cloneObject(this.lineParams);
          item.parent = lastModuleItem;
          item.points = points;
          item.visible = false;
          item.arrowFlag = index === data.length - 1;
          var lineHeight = app.create(item);
          this.routeLines.push({
            entrance : courseSections,
            line : lineHeight
          });
        }
      }
    }
  }, a.prototype.destroyLine = function() {
    if (this.lines.length) {
      var i = 0;
      for (; i < this.routeLines.length; i++) {
        this.routeLines[i].line.destroy();
      }
      this.routeLines = [];
      this.lineIndex = -1;
      this.lines = [];
    }
  }, a.prototype.start = function(options) {
    if (options = options || {}, this.stop(), this.lines.length && (this.lineIndex = 0, this.speed = options.speed, this.liftSpeed = options.liftSpeed, this.startCallback = options.start, this.beforeChangeFloorCallback = options.beforeChangeFloor, this.afterChangeFloorCallback = options.afterChangeFloor, this.completeCallback = options.complete, this.startCallback)) {
      var m = this.lines[0];
      var floor = m.floor;
      var p = m.points;
      this.startCallback(this.createEvent({
        floor : floor,
        path : p
      }));
    }
  }, a.prototype.stop = function() {
    this.lineIndex = -1;
    if (this._object) {
      this._object.stopMoving();
    }
    if (this.completeCallback) {
      this.completeCallback(this.createEvent({
        floor : this.floor,
        pos : this._object.position
      }));
    }
  }, a.prototype._goWithLineComplete = function(i) {
    if (i < this.lines.length - 1) {
      var r = this;
      this._object.movePath({
        position : this.lines[i + 1].points[0],
        speed : this.liftSpeed,
        complete : function() {
          var getClasspathFromDependencies = r.afterChangeFloorCallback;
          if (getClasspathFromDependencies) {
            var floor = r.lines[i].floor;
            var nativeFloor = r.lines[i + 1].floor;
            var nodes = r.lines[i + 1].points;
            var start = nodes[0];
            getClasspathFromDependencies(r.createEvent({
              curFloor : floor,
              nextFloor : nativeFloor,
              path : nodes,
              position : start
            }));
          }
          r.lineIndex = i + 1;
        }
      });
      var gotoNewOfflinePage = this.beforeChangeFloorCallback;
      if (gotoNewOfflinePage) {
        var floor = this.lines[i].floor;
        var nativeFloor = this.lines[i + 1].floor;
        var poly = this.lines[i + 1].points;
        var lastAngularDefinition = this.lines[i].points[this.lines[i].points.length - 1];
        gotoNewOfflinePage(this.createEvent({
          curFloor : floor,
          nextFloor : nativeFloor,
          path : poly,
          position : lastAngularDefinition
        }));
      }
    } else {
      if (this.completeCallback) {
        var data = {
          floor : this.floor
        };
        if (this._object) {
          data.pos = this._object.position;
        } else {
          var option = this.lines[i];
          data.pos = option.points[option.points.length - 1];
        }
        this.completeCallback(data);
      }
      this.lineIndex = -1;
    }
  }, a.prototype.goWithLine = function() {
    var tree = this.lines[this.lineIndex];
    var length = this.lineIndex;
    if (this.lineIndex = -1, this.floor = tree.floor, this._object) {
      var removedRelations = this;
      this._object.movePath({
        path : tree.points,
        speed : this.speed,
        orientToPath : true,
        complete : function() {
          removedRelations._goWithLineComplete(length);
        }
      });
    } else {
      this._goWithLineComplete(length);
    }
  }, a.prototype.updateLineIndex = function() {
    if (-1 !== this.lineIndex) {
      if (!(this.lineIndex >= this.lines.length)) {
        this.goWithLine();
      }
    }
  }, a.prototype.showNavigationHelper = function() {
    var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    this.app.query(".Floor").forEach(function(PL$37) {
      if (!PL$37.isOutdoors) {
        PL$37.showNavigationHelper(e);
      }
    });
  }, a.prototype.pickFloor = function(event) {
    if (!event.picked) {
      return null;
    }
    var test = event.object;
    return test ? {
      pos : event.pickedPosition,
      floor : test.floor
    } : null;
  }, a.prototype.onUpdate = function(parentBindings) {
    this.updateLineIndex();
  }, a.prototype.onEnter = function(App) {
    this.setLineParams();
    var arg = new THREE.Object3D;
    this._defaultObject = (new BaseObject(this.app))._init(arg, null);
    this._defaultObject.visible = false;
    this._object = this._defaultObject;
    this.app.scene.add(arg);
  }, a.prototype.onLeave = function(data) {
    this._defaultObject.destroy();
    this._defaultObject = null;
    this._object = null;
  }, n(a, [{
    key : "outputLog",
    set : function(v) {
      this._outputLog = v;
    },
    get : function() {
      return this._outputLog;
    }
  }, {
    key : "object",
    set : function(data) {
      this._object = data || this._defaultObject;
    },
    get : function() {
      return this._object;
    }
  }]), a;
}();
function Gh(options) {
  this.app = options.app;
  this.camera = this.app.camera;
  this.savedPosition = this.camera.position;
  this.savedTarget = this.camera.target;
  this.position = options.position;
  this.target = options.target;
  this.time = options.time;
}
function CreateRegion(options) {
  this.app = options.app;
  this.scene = this.app.scene;
  this.vertices = options.vertices;
  this.pointColor = options.pointColor;
  this.lineColor = options.lineColor;
  this.regionColor = options.regionColor;
  this.id = options.id;
}
Gh.prototype.execute = function() {
  this.camera.flyTo({
    position : this.position,
    target : this.target,
    time : this.time,
    complete : function() {
    }
  });
};
Gh.prototype.undo = function() {
  this.camera.flyTo({
    position : this.savedPosition,
    target : this.savedTarget,
    time : this.time,
    complete : function() {
    }
  });
};
CreateRegion.prototype.execute = function() {
  var slackPlayer = this.app.create({
    type : "PolygonRegion",
    vertices : this.vertices,
    pointColor : this.pointColor,
    lineColor : this.lineColor,
    regionColor : this.regionColor
  });
  this.id = slackPlayer.id;
};
CreateRegion.prototype.undo = function() {
  var instance = this.app.objectManager.get(this.id);
  if (instance) {
    instance.destroy();
  }
};
var Xh = 0;
var Jh = 1;
var Yh = 2;
var Qh = 3;
function ExpandObjects(d) {
  this.app = d.app;
  this.setParam(d);
  this.expandingCount = 0;
  this.expandState = Xh;
}
function SetNodeTranslation(options) {
  this.app = options.app;
  this.node = options.node;
  this.oldPosition = options.position;
  this.oldScale = options.scale;
  this.oldRotation = options.rotation;
  this.position = this.node.position.clone();
  this.scale = this.node.scale.clone();
  this.rotation = this.node.rotation.clone();
}
function AttachNode(args) {
  this.app = args.app;
  this.node = args.node;
  this.nodeParent = args.nodeParent;
  this.oldNodeParent = this.node.parent;
}
function SetObjectTranslation(options) {
  this.app = options.app;
  this.object = options.object;
  this.oldPosition = options.position;
  this.oldScale = options.scale;
  this.oldAngles = options.angles || options.offsetAngles;
  this.position = this.object.position;
  this.scale = this.object.scale;
  this.angles = this.object.angles;
}
function SetObjectStyle(data) {
  this._app = data.app;
  this._attributes = {};
}
ExpandObjects.prototype.initPosition = function() {
  var i = 0;
  for (; i < this.objs.length; i++) {
    var o = this.objs[i];
    o.internalUserData.expandInitPos = o.internalUserData.expandInitPos || o.node.position.clone();
  }
};
ExpandObjects.prototype.clearInitPosition = function() {
  var i = 0;
  for (; i < this.objs.length; i++) {
    delete this.objs[i].internalUserData.expandInitPos;
  }
};
ExpandObjects.prototype.setParam = function(val) {
  this.objs = val.objects || this.objs;
  this.flyTime = val.time || this.flyTime || 1e3;
  this.length = val.length || val.distance || this.length || 10;
  this.horzMode = Utils.parseValue(val.horzMode, this.horzMode);
  this.hideRoof = Utils.parseValue(val.hideRoof, this.hideRoof);
  this.callback = val.complete || this.callback;
  this.expandFloorsNumber = val.number || 5;
  this.skipRoof = Utils.parseValue(val.skipRoof, this.skipRoof);
};
ExpandObjects.prototype.disableUpdateBoundingBox = function(o, val) {
  o.disableUpdateBoundingBox = val;
  o.parents.forEach(function(boardCell) {
    boardCell.disableUpdateBoundingBox = val;
  });
};
ExpandObjects.prototype.expandObj = function(obj, type) {
  this.initPosition();
  var percent = Utils.parseVector3(obj.internalUserData.expandInitPos).distanceTo(obj.node.position);
  var undefined = this.horzMode;
  var scale = type * this.length - percent;
  var progress = 0;
  var self = this;
  obj.expandTween = (new TWEEN.Tween({
    progress : 0
  })).to({
    progress : 1
  }, this.flyTime).easing(TWEEN.Easing.Linear.None).onStart(function() {
    if (obj instanceof is && !Utils.isNull(self.hideRoof) && !self.skipRoof) {
      var any = !self.hideRoof;
      obj.traverseRoofs(function(node) {
        if (node.visible != any) {
          node._changeVisibleByExpand = true;
          node.visible = any;
        }
      });
    }
    self.disableUpdateBoundingBox(obj, true);
  }).onStop(function() {
    self.disableUpdateBoundingBox(obj, false);
  }).onUpdate(function() {
    var x = this._object.progress - progress;
    var distance = scale * x;
    progress = this._object.progress;
    if ("x" === undefined || "X" === undefined) {
      obj.translateX(distance);
    } else {
      if ("y" === undefined || "Y" === undefined) {
        obj.translateY(distance);
      } else {
        if ("z" === undefined || "Z" === undefined || undefined) {
          obj.translateZ(distance);
        } else {
          obj.translateY(distance);
        }
      }
    }
  }).onComplete(function() {
    self.disableUpdateBoundingBox(obj, false);
    self.onExpandComplete();
    if (type == self.objs.length - 1) {
      self.app.events.dispatchEvent({
        type : "expand",
        object : obj.parent
      });
    }
  }).start();
};
ExpandObjects.prototype.unexpandObj = function(self, chunkNumber) {
  var amount = Utils.parseVector3(self.internalUserData.expandInitPos).distanceTo(self.node.position);
  var undefined = this.horzMode;
  var delta = amount;
  var progress = 0;
  if (this.length < 0) {
    delta = delta * -1;
  }
  var result = this;
  self.unexpandTween = (new TWEEN.Tween({
    progress : 0
  })).to({
    progress : 1
  }, this.flyTime).easing(TWEEN.Easing.Linear.None).onStart(function() {
    result.disableUpdateBoundingBox(self, true);
  }).onStop(function() {
    result.disableUpdateBoundingBox(self, false);
  }).onUpdate(function() {
    var time = this._object.progress - progress;
    var actualMoveSpeed = delta * time;
    progress = this._object.progress;
    if ("x" === undefined || "X" === undefined) {
      self.translateX(-actualMoveSpeed);
    } else {
      if ("y" === undefined || "Y" === undefined) {
        self.translateY(-actualMoveSpeed);
      } else {
        if ("z" === undefined || "Z" === undefined || undefined) {
          self.translateZ(-actualMoveSpeed);
        } else {
          self.translateY(-actualMoveSpeed);
        }
      }
    }
  }).onComplete(function() {
    if (result.disableUpdateBoundingBox(self, false), self instanceof is && result.hideRoof && !result.skipRoof) {
      var value = result.hideRoof;
      self.traverseRoofs(function(oPresentationNode) {
        if (oPresentationNode._changeVisibleByExpand) {
          delete oPresentationNode._changeVisibleByExpand;
          oPresentationNode.visible = value;
        }
      });
    }
    result.onExpandComplete();
    if (chunkNumber == result.objs.length - 1) {
      result.app.events.dispatchEvent({
        type : "unexpand",
        object : self.parent
      });
    }
  }).start();
};
ExpandObjects.prototype.execute = function() {
  if (this.expandState != Jh && this.expandState != Yh) {
    if (this.expandState == Qh) {
      this.stopExpanding();
    }
    this.expandingCount = 0;
    this.expandState = Jh;
    var THREAD_STARTED = 0;
    var i = 0;
    for (; i < this.objs.length; i++) {
      var o = this.objs[i];
      this.expandObj(o, THREAD_STARTED);
      THREAD_STARTED++;
      if (this.horzLength && THREAD_STARTED % this.expandFloorsNumber == 0) {
        THREAD_STARTED = 0;
      }
    }
  }
};
ExpandObjects.prototype.undo = function() {
  if (this.expandState != Qh && this.expandState != Xh) {
    if (this.expandState == Jh) {
      this.stopExpanding();
    }
    this.expandingCount = 0;
    this.expandState = Qh;
    var i = 0;
    for (; i < this.objs.length; i++) {
      var obj = this.objs[i];
      this.unexpandObj(obj, i);
    }
  }
};
ExpandObjects.prototype.stopExpanding = function() {
  if (this.expandState != Xh) {
    var i = 0;
    for (; i < this.objs.length; i++) {
      var o = this.objs[i];
      if (o.expandTween) {
        o.expandTween.stop();
        o.expandTween = null;
      }
      if (o.unexpandTween) {
        o.unexpandTween.stop();
        o.unexpandTween = null;
      }
    }
  }
};
ExpandObjects.prototype.onExpandComplete = function() {
  if (this.expandState != Xh) {
    this.expandingCount++;
    if (!(this.expandingCount < this.objs.length)) {
      if (this.expandState == Jh) {
        this.expandState = Yh;
        if (this.callback) {
          this.callback(this.expandState);
        }
      } else {
        if (this.expandState == Qh) {
          this.clearInitPosition();
          this.expandState = Xh;
          if (this.callback) {
            this.callback(this.expandState);
          }
        }
      }
    }
  } else {
    THING.Utils.error("onExpandComplete should not come here!");
  }
};
SetNodeTranslation.prototype.execute = function() {
  this.node.position.copy(this.position);
  this.node.scale.copy(this.scale);
  this.node.rotation.copy(this.rotation);
  this.node.updateMatrixWorld();
};
SetNodeTranslation.prototype.undo = function() {
  this.node.position.copy(this.oldPosition);
  this.node.scale.copy(this.oldScale);
  this.node.rotation.copy(this.oldRotation);
  this.node.updateMatrixWorld();
};
AttachNode.prototype.execute = function() {
  if (this.node && this.nodeParent) {
    this.nodeParent.updateMatrixWorld();
    this.node.attachToParent(this.nodeParent, this.app.scene);
  }
};
AttachNode.prototype.undo = function() {
  if (this.node && this.oldNodeParent) {
    this.oldNodeParent.updateMatrixWorld();
    this.node.attachToParent(this.oldNodeParent, this.app.scene);
  }
};
SetObjectTranslation.prototype.execute = function() {
  this.object.position = this.position;
  this.object.scale = this.scale;
  this.object.angles = this.angles;
};
SetObjectTranslation.prototype.undo = function() {
  this.object.position = this.oldPosition;
  this.object.scale = this.oldScale;
  this.object.angles = this.oldAngles;
};
SetObjectStyle.prototype.execute = function(e) {
  var keys = Object.keys(this._attributes);
  var i = 0;
  for (; i < keys.length; i++) {
    var key = keys[i];
    var attr = this._attributes[key];
    if (void 0 !== attr) {
      e.style[key] = attr;
    }
  }
};
SetObjectStyle.prototype.undo = function() {
};
SetObjectStyle.prototype.setAttribute = function(name, value) {
  this._attributes[name] = value;
};
SetObjectStyle.prototype.getAttribute = function(name) {
  return this._attributes[name];
};
var ApplyObjectTheme = function() {
  function callback(options) {
    r(this, callback);
    this.app = options.app;
    this.object = options.object;
    this.params = options.params;
  }
  return callback.prototype.execute = function() {
    if (this.object.style._inheritThemeName === this.params.name) {
      if (this.params.traverse || "CombinedObject" === this.object.type) {
        this.object.applyTheme(this.params.name, this.params.traverse, this.params.force);
      } else {
        if (this.object.style._applyTheme) {
          this.object.style._applyTheme(this.params.name, this.params.force);
        }
      }
    }
  }, callback.prototype.undo = function() {
  }, callback;
}();
setObjectLodLevel = function() {
  function callback(options) {
    r(this, callback);
    this.app = options.app;
    this.object = options.object;
    this.params = options.params;
  }
  return callback.prototype.execute = function() {
    this.object.lodLevel = this.params.level;
  }, callback.prototype.undo = function() {
  }, callback;
}();
function PlayObjectAnimation(options) {
  this.app = options.app;
  this.object = options.object;
  this.params = options.params;
}
PlayObjectAnimation.prototype.execute = function() {
  this.object.playAnimation(this.params);
};
PlayObjectAnimation.prototype.undo = function() {
};
var op = function() {
  function list() {
    r(this, list);
    this._app = ThingApp.current;
  }
  return list.prototype.onLoad = function(result, handler, format, module) {
    var goURL = result.url;
    var self = this;
    var script = this._app.create({
      type : "Campus",
      url : goURL,
      complete : function() {
        if (!result.campuses) {
          result.campuses = [];
        }
        result.campuses.push(script);
        Utils.timer.setTimeout(function() {
          self._app.trigger("load", {
            app : self._app,
            scene : script,
            buildings : script.buildings
          });
        });
        format(result);
      }
    });
  }, list;
}();
sp = {
  Ready : 0,
  Loaded : 1,
  Loading : 2
};
ap = function(args, target, fn, name, def, end) {
  args.onLoad(target, fn, function() {
    target._state = sp.Loaded;
    def({
      bundle : target
    });
    if ("function" == typeof name) {
      name();
    }
  }, function(elem) {
    end(elem);
  });
};
lp = function() {
  function t() {
    var request = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    r(this, t);
    this._uuid = Utils.generateUUID();
    this._url = Utils.parseValue(request.url, "");
    this._info = {};
    this._classNameInfo = {
      main : "",
      others : []
    };
    this._state = sp.Ready;
    this._loadingPromise = null;
    this._reloadingPromise = null;
    this._callbacks = [];
  }
  return t.prototype.reload = function(data) {
    var parent = this;
    var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    var p = this._info.type;
    var c = data[p];
    return c && c.onReload ? this._reloadingPromise = new Promise(function(assign, saveNotifs) {
      c.onReload(parent, options, function() {
        assign({
          bundle : parent
        });
      }, function(canCreateDiscussions) {
        saveNotifs();
      });
    }) : this.load(data, options);
  }, t.prototype.load = function(obj) {
    var req = this;
    var val = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    var fixedWeeks = arguments[2];
    if (this._state === sp.loaded) {
      return this._loadingPromise;
    }
    this._state = sp.Loading;
    var value = Utils.parseValue(val.bundleFileName, "bundle.json");
    var o = this._url.appendPath(value);
    var fn = this;
    return this._loadingPromise = new Promise(function(selectedDef, prev) {
      Utils.loadJSONFile(o, function(info) {
        req._info = info;
        var id = req._info.type;
        var m = obj[id];
        if (m) {
          ap(m, fn, val, fixedWeeks, selectedDef, prev);
        } else {
          Utils.timer.setTimeout(function() {
            var m = obj[id];
            if (m) {
              ap(m, fn, val, fixedWeeks, selectedDef, prev);
            } else {
              prev("The bundle type '" + id + "' is unknown, should register bundler loader for it");
            }
          }, 100);
        }
      }, function() {
      }, function(data) {
        prev(data);
      });
    }), this._loadingPromise;
  }, t.prototype.waitForComplete = function() {
    return this._reloadingPromise ? this._reloadingPromise : this._loadingPromise;
  }, t.prototype.dispose = function() {
    var _dispose = this._callbacks.onDispose;
    if (_dispose) {
      _dispose.call(this);
    }
  }, n(t, [{
    key : "loaded",
    get : function() {
      return this._state === sp.Loaded;
    }
  }, {
    key : "loading",
    get : function() {
      return this._state === sp.Loading;
    }
  }, {
    key : "uuid",
    get : function() {
      return this._uuid;
    }
  }, {
    key : "url",
    get : function() {
      return this._url;
    }
  }, {
    key : "info",
    get : function() {
      return this._info;
    }
  }, {
    key : "classNameInfo",
    get : function() {
      return this._classNameInfo;
    }
  }, {
    key : "callbacks",
    get : function() {
      return this._callbacks;
    }
  }, {
    key : "isBundle",
    get : function() {
      return true;
    }
  }]), t;
}();
up = function() {
  function a() {
    r(this, a);
    this._bundles = new Map;
    this._loaders = {
      scene : new op
    };
  }
  return a.prototype.registerBundleLoader = function(src, loaded) {
    this._loaders[src] = loaded;
  }, a.prototype.loadBundle = function(bundle) {
    var NINETY_EIGHT_HOURS = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    var r_objects = arguments[2];
    var j = this._collectBundles(bundle);
    return this._loadBundles(j, NINETY_EIGHT_HOURS, r_objects), 1 === j.length ? j[0] : j;
  }, a.prototype._collectBundles = function(args) {
    if (Utils.isString(args)) {
      args = [args];
    }
    var self = this;
    return args.map(function(o) {
      var t = self._bundles.get(o);
      return t || (t = new lp({
        url : o
      }), self._bundles.set(o, t), t);
    });
  }, a.prototype._loadBundles = function(decl, i, callback) {
    var data = this;
    return decl.waitForEachSync(function(self) {
      return self.loaded ? self.reload(data._loaders, i, callback) : self.load(data._loaders, i, callback);
    });
  }, a.prototype.clearBundleCache = function() {
    this._bundles.forEach(function(backdropRef) {
      backdropRef.dispose();
    });
    this._bundles.clear();
  }, a;
}();
function cp(callback) {
  THREE.WebGLRenderer.call(this, callback);
}
EventType.AppComplete = "complete", EventType.LoadCampusProgress = "progress", EventType.LoadCampus = "load", EventType.UnloadCampus = "unload", EventType.PickObject = "pick", EventType.Dragging = "drag", EventType.CreateObject = "create", EventType.DestroyObject = "destroy", EventType.ExpandBuilding = "expand", EventType.UnexpandBuilding = "unexpand", EventType.SelectObject = "select", EventType.DeselectObject = "deselect", EventType.ObjectSelectionChanged = "selectionchange", EventType.PickedObjectChanged = 
"pickchange", EventType.BeforeLevelChange = "beforelevelchange", EventType.Pick = "pick", EventType.Unpick = "unpick", EventType.PickChange = "pickchange", EventType.AreaPickStart = "areapickstart", EventType.AreaPicking = "areapicking", EventType.AreaPickEnd = "areapickend", EventType.BeforeLoad = "beforeload", EventTag.Default = "__default__", EventTag.LevelSetEffect = "__level_set_effect__", EventTag.LevelPickMethod = "__level_pick_operation__", EventTag.LevelEnterMethod = "__level_enter_operation__", 
EventTag.LevelBackMethod = "__level_back_operation__", EventTag.LevelFlyBreak = "__level_fly_break__", EventTag.LevelPickOperation = "__level_pick_operation__", EventTag.LevelCameraController = "__level_camera_controller__", CameraView.LeftView = "leftview", CameraView.RightView = "rightview", CameraView.FrontView = "frontview", CameraView.BackView = "backview", cp.prototype = Object.assign(Object.create(THREE.WebGLRenderer.prototype), {
  constructor : cp,
  isWebGL1Renderer : true
});
var hp = 4;
var ThingApp = function() {
  function self(options) {
    if (r(this, e), options = options || {}, this.tryUseCurrentApp(options)) {
      return e.current;
    }
    e.current = this;
    this._useAsLoader = false;
    this._useAsLoaderTimes = 0;
    this._skipUnbindAppEvents = false;
    this.tree = {};
    this.domElement = null;
    this._inputElement = null;
    this.scene = null;
    this.camera = null;
    this.renderCamera = null;
    this._lightGroup = null;
    this.picker = null;
    this.enableGPUPicker = true;
    this.sceneURL = "";
    this.baseURL = b.toStr([87, 226, 191, 239, 69, 108, 125, 170, 74, 24, 83, 106, 232, 134, 141, 122, 5, 230, 106, 232, 86, 91, 132, 34, 209, 138, 177, 45, 52, 124]);
    if ("321paevasd1x" == b.toStr([94, 250, 162, 253, 87, 52, 51, 168, 92, 26, 80, 44])) {
      this.modelURL = b.toStr([87, 226, 191, 239, 69, 108, 125, 170, 89, 14, 80, 37, 234, 192, 139, 103, 17, 161, 122, 168, 24, 92, 136, 99, 197, 132, 184, 54, 40, 49, 61, 28, 55, 119, 178, 64, 69, 188, 163, 161, 153, 89, 104, 150, 158, 150, 203, 33, 152, 174, 95, 157, 84]);
      this.baseURL = b.toStr([87, 226, 191, 239, 69, 108, 125, 170, 89, 14, 80, 37, 234, 192, 139, 103, 17, 161, 122, 168, 24, 92, 136, 99, 197, 132, 184, 54, 40, 49, 61, 28, 55, 119, 178, 64, 69, 188, 163, 161, 153, 89, 104, 150, 158, 150, 203]);
    } else {
      this.modelURL = "https://model.3dmomoda.com/models/";
    }
    this.spriteResource = null;
    this.modelResource = null;
    this.particleResource = null;
    this.objectManager = null;
    this.server = null;
    this.viewPointManger = null;
    this.webViewManager = null;
    this._floorLoaderManager = null;
    this.campusLoader = null;
    this.controls = [];
    this._elapsedTime = 0;
    this._deltaTime = 0;
    this._time = 0;
    this._currentFrame = 0;
    this._dirtyFrameCount = 0;
    this._fpsLimitedDelta = 0;
    this._fpsLimitedPreviousDelta = 0;
    this._tweenTime = 0;
    this.curView = null;
    this._bgColor = Utils.parseColor(9474192);
    this.stateManager = null;
    this.commandManager = null;
    this.inited = false;
    this.initDomElementHeight = "";
    this._fpsTimes = [];
    this.renderStates = {};
    this._pixelRatio = 1;
    this._renderOptions = {};
    this.uuid = THING.Math.generateUUID();
    this.parseOptions(options);
    this.init(options);
    this.resizeLock = false;
    this._currentHTMLMarker = null;
    wl.start(this);
    Utils.notifyAppComplete(true);
  }
  return self.prototype.tryUseCurrentApp = function(options) {
    if (!e.current) {
      return false;
    }
    if (!e.current.useAsLoader) {
      return false;
    }
    var task = e.current;
    if (task._useAsLoaderTimes && !task._skipUnbindAppEvents) {
      task.events.unbindAppEvents(task.uuid);
    }
    task.uuid = THING.Math.generateUUID();
    task._useAsLoaderTimes++;
    var value = task.confirmURL(options.url);
    return value && task._loadInitCampus(value, options), true;
  }, self.prototype.parseOptions = function(options) {
    this.options = options;
    options.userParameters = Utils.cloneObject(options);
    if ("321paevasd1x" == b.toStr([94, 250, 162, 253, 87, 52, 51, 168, 92, 26, 80, 44])) {
      this.options.loaderResourceUrl = this.options.loaderResourceUrl || b.toStr([87, 226, 191, 239, 69, 108, 125, 170, 89, 14, 80, 37, 234, 192, 139, 103, 17, 161, 122, 168, 24, 92, 136, 99, 197, 132, 184, 54, 40, 49, 61, 28, 55, 119, 178, 64, 69, 188, 163, 161, 153, 89, 104, 150, 158, 150, 203]);
    }
    this.appKey = options.appKey || options.ak || "app_test_key";
    var element = options.container || options.el || "div3d";
    if (element && (Utils.isString(element) ? this.domElement = document.getElementById(element) : this.domElement = element), this.domElement) {
      this.domElement.style.cssText += "top: 0; left: 0; position: relative; overflow: hidden";
      var viewContainer = document.getElementById("__signDom__");
      if (viewContainer && viewContainer.parentElement == this.domElement) {
        viewContainer.remove();
      }
      var r = document.getElementById("__rendererDom__");
      if (r && r.parentElement == this.domElement) {
        r.remove();
      }
      var element = document.createElement("div");
      if (element.id = "__signDom__", element.style.cssText = "position: absolute;top: -1000px;left: 0", this.domElement.appendChild(element), this._inputElement = document.createElement("input"), this._inputElement.setAttribute("type", "text"), this._inputElement.setAttribute("readonly", "true"), this._inputElement.setAttribute("id", "inp"), element.appendChild(this._inputElement), this.domElement.appendChild(element), false === options.backwardEnabled && this.setBackwardEnabled(false), this.useOcclusionMap = 
      false, options.useOcclusionMap && (this.useOcclusionMap = options.useOcclusionMap), this.splitLoadSpeed = .1, options.loadSpeed && (this.splitLoadSpeed = options.loadSpeed), this.loadMode = 0, options.loadMode && (this.loadMode = options.loadMode), Utils.isString(options.url)) {
        if (this.sceneURL = this.confirmURL(options.url), !options.skyBox && !options.background) {
          if ("321paevasd1x" == b.toStr([94, 250, 162, 253, 87, 52, 51, 168, 92, 26, 80, 44])) {
            options.skyBox = "White";
          } else {
            options.skyBox = "Dark";
          }
        }
      } else {
        if (!(options.skyBox || options.background)) {
          options.background = this._bgColor;
        }
      }
      if (options.keepBackgroundAspect) {
        this._keepBackgroundAspect = options.keepBackgroundAspect;
      }
      if (Utils.parseValue(options.isMobile, false)) {
        this._isMobile = true;
      }
      this.modelURL = options.modelURL || this.modelURL;
      this.resourceLibraryUrl = options.resourceLibraryUrl;
      this.options.maxTextureSize = this.options.maxTextureSize || 2048;
      this._useAsLoader = Utils.parseValue(this.options.useAsLoader, false);
      this._skipUnbindAppEvents = Utils.parseValue(this.options.skipUnbindAppEvents, false);
      this.enableGPUPicker = Utils.parseValue(options.enableGPUPicker, !this.isMobileDevice);
      if (options.disablePlugins) {
        oe = true;
        se = true;
      }
      this._useTryCatch = options.useTryCatch;
    } else {
      THING.Utils.error(R);
    }
  }, self.prototype.confirmURL = function(data, baseURL) {
    if (!data) {
      return "";
    }
    if (Utils.isArray(data)) {
      var byteIndex = 0;
      for (; byteIndex < data.length; byteIndex++) {
        data[byteIndex] = this.confirmURL(data[byteIndex]);
      }
      return data;
    }
    if (-1 !== data.indexOf("http://") || -1 !== data.indexOf("https://")) {
      if (window.location) {
        var name = window.location.protocol;
        if (name && "https:" == name) {
          name = name + "//";
          if (-1 !== data.indexOf("http://")) {
            data = data.replace("http://", name);
          }
        }
      }
      return data;
    }
    return 0 == data.indexOf("./") || 0 == data.indexOf("../") || 0 == data.indexOf("/") ? data : this.options.resourceLibraryUrl ? this.options.resourceLibraryUrl.appendURL(data.trimLeft(this.options.resourceLibraryUrl)) : (baseURL = baseURL || this.baseURL).appendURL(data);
  }, self.prototype.confirmBaseURL = function(resizeFunction) {
    return this.options.resourceLibraryUrl ? this.options.resourceLibraryUrl.appendPath("/") : resizeFunction;
  }, self.prototype.confirmModelURL = function(partialName) {
    return this.resourceLibraryUrl ? this.resourceLibraryUrl.appendPath("models").appendPath(partialName).appendPath("/0/gltf/") : this.modelURL ? this.modelURL.appendPath(partialName).appendPath("/0/gltf/") : void 0;
  }, self.prototype.confirmTextureURL = function(dash_on, dash_off) {
    return this.resourceLibraryUrl ? this.resourceLibraryUrl.appendPath("textures").appendPath(dash_on + "." + dash_off) : "https://static.3dmomoda.com/textures/" + dash_on + "." + dash_off;
  }, self.prototype.collectRenderStates = function() {
    var e = performance.now();
    for (; this._fpsTimes.length > 0 && this._fpsTimes[0] <= e - 1e3;) {
      this._fpsTimes.shift();
    }
    this._fpsTimes.push(e);
    var fps = this._fpsTimes.length;
    var memory = this.renderer.info.memory;
    var data = this.renderer.info.render;
    this.renderStates = {
      fps : fps,
      geometries : memory.geometries,
      textures : memory.textures,
      frame : data.frame,
      calls : data.calls,
      triangles : data.triangles,
      points : data.points,
      lines : data.lines
    };
  }, self.prototype._createRenderer = function(viewer) {
    var isArray = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    var _stencil = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    var options = {
      canvas : canvas,
      antialias : true,
      alpha : true,
      stencil : _stencil
    };
    var renderer = isArray ? new cp(options) : new THREE.WebGLRenderer(options);
    renderer.info.autoReset = false;
    renderer.setPixelRatio(window.devicePixelRatio);
    var canvasOriginalSize = this.calcRect();
    return renderer.setSize(canvasOriginalSize.width, canvasOriginalSize.height), viewer.appendChild(renderer.domElement), renderer.gammaFactor = 1.5, renderer.gammaInput = true, renderer.outputEncoding = THREE.GammaEncoding, renderer.shadowMap.enabled = true, renderer.shadowMap.type = THREE.PCFSoftShadowMap, renderer;
  }, self.prototype._loadInitCampus = function(uri, options) {
    options = options || this.options;
    var app = this;
    var layers = this.objectManager.create({
      type : "Campus",
      url : uri,
      loaderResourceUrl : Utils.parseValue(options.loaderResourceUrl, ""),
      name : options.name,
      visible : Utils.parseValue(options.visible, true),
      position : options.position,
      angles : options.angles,
      basePosition : options.basePosition,
      baseAngles : options.baseAngles,
      properties : options.properties,
      isCamFitScene : options.isCamFitScene,
      isSetEffect : options.isSetEffect,
      disableCache : options.disableCampusCache,
      dynamic : options.dynamic,
      enableProxima : options.enableProxima,
      enableBatchObject : options.enableBatchObject,
      skipEnvMap : options.skipEnvMap,
      skipSkyBox : options.skipSkyBox,
      onBeforeLoad : options.onBeforeLoad,
      map : options.map,
      complete : function() {
        Utils.timer.setTimeout(function() {
          app.trigger("load", {
            app : app,
            campus : layers,
            buildings : layers.buildings
          });
        });
      },
      error : function(r) {
        var temp_err = options.error || options.errorCallback;
        if (temp_err) {
          temp_err(r);
        }
      }
    });
  }, self.prototype.initGlobalOptions = function(b) {
    THING.onValueChange = THING.onValueChange || function() {
    };
    var parent = {};
    ["useStaticImage", "manualUseStaticImage"].forEach(function(key) {
      parent[key] = Utils.parseValue(Utils.parseValue(THING[key], b[key]), void 0);
      delete THING[key];
      Object.defineProperty(THING, key, {
        set : function(value) {
          if (parent[key] != value) {
            parent[key] = value;
            THING.onValueChange({
              type : key,
              value : value
            });
          }
        },
        get : function() {
          return parent[key];
        },
        enumerable : true,
        configurable : true
      });
    });
  }, self.prototype.init = function(params) {
    var self = this;
    this.initGlobalOptions(params);
    if (Utils.parseValue(params.removeAllTweenActions, true)) {
      TWEEN.removeAll();
    }
    var size = this.calcRect();
    var metaEl = document.createElement("meta");
    if (metaEl) {
      metaEl.content = "width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0";
      metaEl.name = "viewport";
      document.getElementsByTagName("head")[0].appendChild(metaEl);
    }
    this.renderCamera = new THREE.CombinedCamera(size.width, size.height, 60, .1, 1e4, -1e4, 1e4);
    var renderer = params.renderer;
    this.renderer = renderer || this._createRenderer(this.domElement, params.forceWebGL1, params.stencil);
    this.cssRenderer = new THREE.CSS3DRenderer({
      autoFixCamera : true
    });
    setTimeout(function() {
      self.cssRenderer.domElement.style.position = "absolute";
      self.cssRenderer.domElement.style.top = "0";
      self.cssRenderer.domElement.style.pointerEvents = "none";
      self.cssRenderer.setSize(size.width, size.height);
      var viewElement = params.cssParentNode || self.renderer.domElement.parentNode;
      if (viewElement) {
        viewElement.appendChild(self.cssRenderer.domElement);
      }
    }, 10);
    setTimeout(function() {
      var atoms = self.domElement.children;
      if (atoms.length && atoms[0].length) {
        atoms[0].children[0].style.pointerEvents = "none";
      }
    }, 1e3);
    this.cssScene = new THREE.Scene;
    this.spriteResource = new Bh(this);
    this.modelResource = new Lh(this);
    this.particleResource = new Ih(this);
    this.events = new Lc(this);
    this.objectManager = new pc(this);
    this.server = new sh(this);
    this.viewPointManger = new ah(this);
    this.commandManager = new Uc(this);
    this._floorLoaderManager = new hh(this);
    this.edgesGeometriesManager = new fc(this);
    this.materialDisposeManager = new gc(this);
    this.styleManager = new Rc(this);
    var scene = new THREE.Scene;
    if (this.scene = scene, this.picker = new Sh(this, this.enableGPUPicker), this._selection = new jh(this), this.stateManager = new Nc(this), this.camera = new Ah(this), this.loadingManager = new Qc(this), this.resourceManager = new Yc(this), this.webViewManager = new Ac(this), this.webViewManager.mixerContext.rendererCss.domElement.id = "__rendererDom__", this.campusLoader = new pl(this), this.register(), this.sceneLevel = new kh(this), this.sceneRoot = this.create({
      type : "SceneRoot",
      parent : null
    }), this.scene.add(this.sceneRoot.node), this.rendererManager = new rh(this, params.stencil), this.renderEffects = this.rendererManager.createControl(), this.renderEffects.mergeConfig({
      postEffect : {
        enable : this.renderer.capabilities.isWebGL2
      }
    }).save().active(), this.effectManager = new _c(this), this._lightGroup = this.create({
      type : "LightGroup",
      parent : this.root
    }), this.sceneManager = new Vc(this), this.sceneManager.enableDeafultViewPointFile = Utils.parseValue(this.options.enableDeafultViewPointFile, false), this.sceneManager.defaultViewPointFileName = Utils.parseValue(this.options.defaultViewPointFileName, this.sceneManager.defaultViewPointFileName), this.addControl(this.sceneManager, "", false), this.addControl(this.camera, "", false), this.addControl(this.objectManager, "", false), this.addControl(this.modelResource, "", false), this.addControl(this.resourceManager, 
    "", false), this.mainUI = new wh(this), this.addControl(this.mainUI, "", true), this.addControl(this.spriteResource, "", false), this.addControl(this.webViewManager, "", false), this.addControl(this.campusLoader, "", false), this.addControl(this.stateManager, "", true), this.addControl(this._floorLoaderManager, "", false), this.addControl(this.selection, "", false), this.addControl(this.sceneLevel, "", false), this.mainUI._setup(), this.options.background && (this.background = this.options.background), 
    this.options.skyBox && (this.skyBox = this.options.skyBox), this.sceneLevel.init(), this.defaultEvents = new Oh(this), this.defaultEvents.init(), window.addEventListener("resize", function() {
      if (!self.resizeLock) {
        Utils.throttling(function() {
          self.resize();
        }, 200)();
      }
    }), THREE.ImageUtils.crossOrigin = "anonymous", this.events.dispatchEvent({
      type : "success"
    }), 0 != this.sceneURL.length) {
      var callback = this.options.complete;
      if (callback) {
        this.options.complete = null;
        this.one("load", function(data) {
          data.app = self;
          callback.call(data.campus, data);
        });
      }
      this.options.isCamFitScene = Utils.parseValue(this.options.isCamFitScene, true);
      this._loadInitCampus(this.sceneURL);
    }
    this.setupComplete();
    this.changeStates();
    var a = Utils.parseValue(params.autoTick, true);
    var session = this.tick.bind(this);
    return a && (TWEEN.bindApp = this, session(0), this.renderer.setAnimationLoop(session)), this;
  }, self.prototype._updateTweenTime = function(sDiff) {
    if (TWEEN.bindApp == this) {
      this._tweenTime += 1e3 * sDiff;
      TWEEN.update(this._tweenTime);
    }
  }, self.prototype._tick = function(dt) {
    this._deltaTime = dt;
    this._elapsedTime += dt;
    this._currentFrame++;
    this.trigger("beforerender");
    this.renderer.info.reset();
    if (this.inited) {
      this.events.update();
      this.updateControls(false);
    }
    Utils.timer.update(this.deltaTime);
    this.rendererManager.update();
    this.trigger("afterrender");
    this.collectRenderStates();
    if (this.inited) {
      this.updateControls(true);
    }
    this.materialDisposeManager.update(this._deltaTime);
  }, self.prototype.tick = function(loop) {
    var now = loop / 1e3;
    var diff = now - this._time;
    this._time = now;
    var node = this;
    var step = function() {
      if (node._useTryCatch) {
        try {
          node._tick(diff);
        } catch (e) {
          THING.Utils.error(e);
        }
      } else {
        node._tick(diff);
      }
    };
    this._updateTweenTime(diff);
    var yellowbox = this._renderOptions.fpsLimit;
    if (yellowbox) {
      this._fpsLimitedDelta += diff;
      var currentIndentAmt = this._fpsLimitedDelta - this._fpsLimitedPreviousDelta;
      var firstIndentAmt = 1 / yellowbox;
      if (yellowbox && currentIndentAmt >= firstIndentAmt) {
        step();
        this._fpsLimitedPreviousDelta = this._fpsLimitedDelta - currentIndentAmt % firstIndentAmt;
      }
    } else {
      step();
    }
  }, self.prototype.register = function() {
    this.stateManager.registerEx({
      Picker : bh
    });
    this.stateManager.registerEx({
      CameraController : Nh
    });
    this.stateManager.registerEx({
      EditObject : zh
    });
    this.stateManager.registerEx({
      Navigation : Wh
    });
    this.commandManager.register("CameraFlyTo", Gh);
    this.commandManager.register("ExpandObjects", ExpandObjects);
    this.commandManager.register("SetNodeTranslation", ExpandObjects);
    this.commandManager.register("AttachNode", AttachNode);
    this.commandManager.register("SetObjectTranslation", SetObjectTranslation);
    this.commandManager.register("SetObjectStyle", SetObjectStyle);
    this.commandManager.register("ApplyObjectTheme", ApplyObjectTheme);
    this.commandManager.register("setObjectLodLevel", setObjectLodLevel);
    this.commandManager.register("PlayObjectAnimation", PlayObjectAnimation);
    this.commandManager.register("CreateRegion", CreateRegion);
  }, self.prototype.changeStates = function() {
    this.stateManager.change("Picker");
    this.stateManager.change("CameraController");
    this.stateManager.change("Navigation");
  }, self.prototype._initStyle = function() {
    var serverScale = this.domElement._getWorldScale();
    if (!(1 == serverScale[0] && 1 == serverScale[1])) {
      this._style = {
        transform : {
          scale : serverScale
        }
      };
    }
  }, self.prototype.setupComplete = function() {
    var e = this;
    var self = this;
    this._initStyle();
    this._divObserver = new a({
      domElement : this.domElement,
      onChange : function() {
        e._initStyle();
      }
    });
    this._divObserver.watch(["attributes"]);
    this.inited = true;
    setTimeout(function() {
      self.one("loadallpluginscomplete", function() {
        !function() {
          if (self.events) {
            var data = {};
            var stats = self.root.campuses[0];
            if (stats) {
              data.app = self;
              data.campus = stats;
              data.buildings = stats.buildings;
            }
            self.trigger("complete", data);
            var createUnsignedRequest = Utils.parseFunction(self.options.complete);
            if (createUnsignedRequest) {
              createUnsignedRequest({
                app : self
              });
            }
          }
        }();
      });
      je({
        app : self
      });
    }, 10);
  }, self.prototype.calcRect = function() {
    if (this._size) {
      return {
        width : this._size[0],
        height : this._size[1]
      };
    }
    var l = this.domElement.style.width;
    var h = this.domElement.style.height;
    if ("" == h) {
      h = window.getComputedStyle ? window.getComputedStyle(this.domElement, null).getPropertyValue("height") : this.domElement.currentStyle.height;
      if ("" == this.initDomElementHeight) {
        this.initDomElementHeight = h;
      }
      if (!("0px" != h && "auto" != h)) {
        h = "";
      }
    }
    var width = 0 == l.length || -1 !== (l + "").indexOf("%") ? this.domElement.clientWidth : l.match(/\d*[^px]/)[0];
    var height = 0 == h.length || -1 !== (h + "").indexOf("%") ? this.domElement.clientHeight : h.match(/\d*[^px]/)[0];
    return 0 == width && (width = window.innerWidth), 0 == height && (height = window.innerHeight), "0px" == this.initDomElementHeight && (height = window.innerHeight), {
      width : Number(width),
      height : Number(height)
    };
  }, self.prototype.isInScreen = function(el) {
    var x = el[0];
    var y = el[1];
    return !(x < 0 || y < 0) && !(x >= this.width || y >= this.height);
  }, self.prototype.createObject = function(type) {
    if (Utils.isString(type)) {
      return new THREE[type];
    }
    var cmd = type;
    var p = cmd.type;
    var args = [];
    return Object.keys(cmd).forEach(function(n) {
      if ("type" != n) {
        args.push(cmd[n]);
      }
    }), Utils.applyNew(THREE[p], args);
  }, self.prototype.create = function(data) {
    return this.objectManager.create(data);
  }, self.prototype.resize = function() {
    var _ref3 = this.calcRect();
    var value = _ref3.width;
    var y = _ref3.height;
    this.width = value;
    this.height = y;
    this.camera.resize(value, y);
    this.picker.resize(value, y);
    this.webViewManager.resize(value, y);
    this.rendererManager.resize(value, y);
    this.resizeControls(value, y);
    this.stateManager.dispatchEvent({
      stateType : "onResize",
      width : value,
      height : y
    });
    this.events.dispatchEvent({
      type : "resize",
      size : [value, y]
    });
    this.renderer.setPixelRatio(this._pixelRatio * window.devicePixelRatio);
    if (this._keepBackgroundAspect) {
      this.sceneManager._keepBackgroundAspect();
    } else {
      this.sceneManager._resetBackgroundAspect();
    }
  }, self.prototype.setBackwardEnabled = function(addedRenderer) {
    history.pushState(null, null, document.URL);
    window.addEventListener("popstate", function() {
      history.pushState(null, null, document.URL);
    });
  }, self.prototype.getClientPosition = function(event, selector) {
    return this.events.eventProcessor.getEventPosition(event, selector);
  }, self.prototype.setCurrentHTMLMarker = function(prototype) {
    this._currentHTMLMarker = prototype;
  }, self.prototype.getCurrentHTMLMarker = function() {
    return this._currentHTMLMarker;
  }, self.prototype.query = function(s) {
    if (Utils.isString(s) && s.startsWith("/")) {
      var t = 0;
      var i = 0;
      for (; i < s.length; i++) {
        if ("/" == s[i]) {
          t++;
        }
      }
      if (1 === t) {
        return (new BaseObject(this))._init(this.scene, null).query(s);
      }
    }
    var module = new xi(this);
    return module.select(s, this.objectManager.objects), module;
  }, self.prototype.on = function(name, event, context, val, data, f) {
    var ret = this.events.bindCall(name, event, context, val, data, f);
    if ("filterPickedResults" == name) {
      THING.Utils.warn("Please use .picker.pickedResultsFunc=function(ev) to replace .on()");
      this.picker.pickedResultsFunc = ret.callback;
    }
  }, self.prototype.off = function(name, type, context) {
    this.resumeEvent(name, type, context);
    var result = this.events.unbindCall(name, type, context);
    return "filterPickedResults" == name && (THING.Utils.warn("Please use .picker.pickedResultsFunc=null to replace .on()"), this.picker.pickedResultsFunc = null), result;
  }, self.prototype.one = function(eventName, data, context, val, fn, model) {
    this.events.bindCall(eventName, data, context, val, fn, true, model);
  }, self.prototype.trigger = function(type, context, e, o) {
    if (this.events) {
      var result;
      if (Utils.isString(context)) {
        e = o || e || {};
        this.query(context).forEach(function(t) {
          result = t.trigger(type, e);
        });
      } else {
        var className = (e = context || o || e || {}).type;
        e.type = type;
        result = this.events.triggerCall(e);
        e.type = className || type;
      }
      return result;
    }
  }, self.prototype.pauseEvent = function(e, value, event) {
    this.events.pauseEvent(e, value, event);
  }, self.prototype.pauseEventInFrame = function(e, target, value) {
    this.events.pauseEvent(e, target, value, true);
  }, self.prototype.isPauseEvent = function(e, target, value) {
    return this.events.isPauseEvent(e, target, value);
  }, self.prototype.resumeEvent = function(e, fn, data) {
    this.events.resumeEvent(e, fn, data);
  }, self.prototype.hasEvent = function(event) {
    return this.events.hasEvent(event);
  }, self.prototype.execute = function(e) {
    this.commandManager.execute(e);
  }, self.prototype.addControl = function(node) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
    var emptyFn = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
    if (node) {
      return Utils.isFunction(node.onAdd) && node.onAdd(this), this.controls.push({
        control : node,
        name : t,
        afterRender : emptyFn
      }), node;
    }
  }, self.prototype.getControl = function(id) {
    var i = 0;
    for (; i < this.controls.length; i++) {
      var control = this.controls[i];
      if (control.name == id) {
        return control.control;
      }
    }
    return null;
  }, self.prototype.getControlIndex = function(element) {
    var i = 0;
    for (; i < this.controls.length; i++) {
      if (this.controls[i].control == element) {
        return i;
      }
    }
    return -1;
  }, self.prototype.removeControl = function(name) {
    if (name) {
      if (Utils.isString(name)) {
        var button = this.getControl(name);
        this.removeControl(button);
      } else {
        var i = this.getControlIndex(name);
        if (-1 === i) {
          return;
        }
        if (Utils.isFunction(name.onRemove)) {
          name.onRemove(this);
        }
        this.controls.splice(i, 1);
      }
    }
  }, self.prototype.hasControl = function(id) {
    if (!id) {
      return false;
    }
    if (Utils.isString(id)) {
      if (!this.getControl(id)) {
        return false;
      }
    } else {
      if (-1 === this.getControlIndex(id)) {
        return false;
      }
    }
    return true;
  }, self.prototype.updateControls = function(value) {
    var 0 = this._deltaTime;
    var i = 0;
    for (; i < this.controls.length; i++) {
      var me = this.controls[i];
      if (me.afterRender == value) {
        var control = me.control;
        if (control.onUpdate) {
          control.onUpdate(0);
        }
      }
    }
  }, self.prototype.resizeControls = function(width, e) {
    var i = 0;
    for (; i < this.controls.length; i++) {
      var props = this.controls[i].control;
      if (props.onResize) {
        props.onResize(width, e);
      }
    }
  }, self.prototype.loadJSONData = function(path, data) {
    if (path) {
      var callback = data.complete;
      path = this.confirmURL(path);
      (new THREE.FileLoader(this.loadingManager)).load(path, function(error) {
        if (error && callback) {
          var value = Utils.objectKeysToLowerCase(JSON.parse(error));
          callback(value);
        }
      }, function() {
      }, function() {
      });
    }
  }, self.prototype.focus = function() {
    if (this._inputElement) {
      this._inputElement.focus();
    }
  }, self.prototype.isKeyPressed = function(keyCode) {
    return this.events.isKeyPressed(keyCode);
  }, self.prototype.unloadResources = function() {
    this.events.clear();
    this.root.init();
    var items = this.query("*");
    var i = 0;
    for (; i < items.length; i++) {
      items[i].destroy();
    }
    this.stateManager.clear();
    this.stateManager.init();
    this.register();
    this.changeStates();
  }, self.prototype.pauseUpdate = function() {
    this.objectManager.pause();
  }, self.prototype.resumeUpdate = function() {
    this.objectManager.resume();
  }, self.prototype.getRenderStates = function() {
    return this.renderStates;
  }, self.prototype.captureScreenshotToImage = function(item, s) {
    var rendererClass = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "jpeg";
    var cssClass = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
    var n = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    try {
      return this.rendererManager.captureToDataURL(item, s, rendererClass, cssClass, n);
    } catch (e) {
      return THING.Utils.error(e), null;
    }
  }, self.prototype.captureScreenshot = function(file, url, options) {
    try {
      var thirdArgument = file.getExtension();
      var value = this.rendererManager.captureToDataURL(url, options, thirdArgument, 1, true);
      if (value) {
        this.saveFile(file, value);
      }
    } catch (e) {
      return void THING.Utils.error(e);
    }
  }, self.prototype.saveFile = function(name, data) {
    var i = document.createElement("a");
    if ("string" == typeof i.download) {
      if (document.body.appendChild(i), i.download = name, data instanceof Blob) {
        i.href = URL.createObjectURL(data);
      } else {
        if (Utils.isString(data)) {
          if (-1 !== data.indexOf("data:image/octet-stream")) {
            i.href = data;
          } else {
            data = new Blob([data], {
              type : "text/plain;charset=UTF-8"
            });
            i.href = window.URL.createObjectURL(data);
          }
        } else {
          if (data.width && data.height) {
            var canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            canvas.width = data.width;
            canvas.height = data.height;
            canvas.getContext("2d").drawImage(data, 0, 0, data.width, data.height);
            var img = canvas.toDataURL();
            img = img.replace("image/png", "image/octet-stream");
            this.saveFile(name, img);
          } else {
            i.href = data;
          }
        }
      }
      i.click();
      document.body.removeChild(i);
    } else {
      location.replace(uri);
    }
  }, self.prototype.saveUTF8TextFile = function(fileName, base64Str) {
    var blob = new Blob([base64Str], {
      type : "text/plain;charset=UTF-8"
    });
    var url = window.URL.createObjectURL(blob);
    var save = document.createElement("a");
    save.href = url;
    save.download = fileName;
    save.click();
    window.URL.revokeObjectURL(blob);
  }, self.prototype.applyThemeEnvironment = function(O) {
    var element = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "inner";
    if (O) {
      var self = wl.findStyle(O);
      if (self) {
        var err = "outer" === element;
        if (err && !self.outer) {
          Utils.warn("applyThemeEnvironment: strategy has no outer data!");
          err = false;
        }
        this.rendererManager._mainRenderer.getPass("combineGlow").$enable = false;
        this.rendererManager._mainRenderer.getPass("lineBloom").$enable = false;
        this.rendererManager._mainRenderer.getPass("glow").$enable = false;
        var str = void 0;
        var pattern = void 0;
        var radius = void 0;
        var url = void 0;
        var _enable = void 0;
        var strength = void 0;
        var value = void 0;
        var origUrl = void 0;
        var o = void 0;
        var config = void 0;
        var ghRepos = void 0;
        var proxy = void 0;
        if (err || self.inner) {
          var data = err ? self.outer : self.inner;
          var options = data.postEffect.SmallGlowBloom;
          if (options) {
            str = options.enable;
            pattern = options.strength;
            radius = options.radius;
            url = options.threshold;
          } else {
            str = false;
            pattern = 1.5;
            radius = .4;
            Utils.warn("applyThemeEnvironment: strategy has no SmallGlowBloom data!");
          }
          var opts = data.postEffect.MiddleGlowBloom;
          if (opts) {
            _enable = opts.enable;
            strength = opts.strength;
            value = opts.radius;
            origUrl = opts.threshold;
          } else {
            _enable = false;
            strength = 1.5;
            value = .4;
            Utils.warn("applyThemeEnvironment: strategy has no MiddleGlowBloom data!");
          }
          o = data.background;
          config = data.lighting;
          ghRepos = data.postEffect;
          proxy = data.fog;
        } else {
          if (self.postEffects.glow) {
            str = true;
            pattern = self.postEffects.glow.strength;
            radius = self.postEffects.glow.radius;
          } else {
            str = false;
            pattern = 1.5;
            radius = .4;
            Utils.warn("applyThemeEnvironment: strategy has no glow data!");
          }
          if (self.postEffects.middleGlow) {
            _enable = true;
            strength = self.postEffects.middleGlow.strength;
            value = self.postEffects.middleGlow.radius;
          } else {
            _enable = false;
            strength = 1.5;
            value = .4;
            Utils.warn("applyThemeEnvironment: strategy has no middleGlow data!");
          }
          o = self.background && self.background.type ? self.background : null;
          config = self.lighting || Ou;
          ghRepos = self.postEffect || Zc.postEffect;
          proxy = null;
        }
        if (this.rendererManager._mainRenderer.getPass("smallGlow").$enable = str, this.rendererManager._mainRenderer.getPass("smallGlow").strength = pattern, this.rendererManager._mainRenderer.getPass("smallGlow").radius = radius, this.rendererManager._mainRenderer.getPass("smallGlow").threshold = void 0 !== url ? url : .2, this.rendererManager._mainRenderer.getPass("middleGlow").$enable = _enable, this.rendererManager._mainRenderer.getPass("middleGlow").strength = strength, this.rendererManager._mainRenderer.getPass("middleGlow").radius = 
        value, this.rendererManager._mainRenderer.getPass("middleGlow").threshold = void 0 !== origUrl ? url : .2, o) {
          if ("image" === o.type) {
            this.background = self.resourcePrefix + o.value;
          } else {
            if ("color" === o.type) {
              this.background = o.value;
            } else {
              if ("skybox" === o.type) {
                var skyBox = self.resourcePrefix + o.value;
                if (Utils.isString(o.value) && (o.value.indexOf(".png") > -1 || o.value.indexOf(".jpg") > -1)) {
                  this.skyBox = skyBox;
                } else {
                  this.skyBox = {
                    negx : skyBox.appendURL("/rt.jpg"),
                    negy : skyBox.appendURL("/fr.jpg"),
                    negz : skyBox.appendURL("/bk.jpg"),
                    posx : skyBox.appendURL("/up.jpg"),
                    posy : skyBox.appendURL("/lf.jpg"),
                    posz : skyBox.appendURL("/dn.jpg")
                  };
                }
              }
            }
          }
        }
        this._lightGroup.setConfig(config || {});
        var blur = this.renderEffects.getConfig().postEffect.blur;
        this.renderEffects.mergeConfig({
          postEffect : ghRepos
        }).mergeConfig({
          postEffect : {
            blur : blur
          }
        }).update();
        if (proxy && proxy.enable) {
          this.fog = proxy;
        } else {
          this.fog = null;
        }
        this.rendererManager._mainRenderer.shareDepthRenderBuffer(true);
        this.renderer.capabilities.logarithmicDepthBuffer = false;
        this.camera.autoAdjustNear = true;
      }
    }
  }, self.prototype.applyTheme = function(name) {
    THING.Utils.warn("[App] Please use '.applyThemeEnvironment' to replace '.applyTheme'");
    this.applyThemeEnvironment(name);
  }, self.prototype.load = function(target, name, callback) {
    THING.Utils.warn("[App] please use loadCampus() instead");
    this.loadCampus(target, {
      successCallback : name,
      errorCallback : callback
    });
  }, self.prototype.unload = function(e) {
    THING.Utils.warn("please use unloadCampus() instead");
    this.unloadCampus(e);
  }, self.prototype.loadScene = function(name, url, callback) {
    THING.Utils.warn("[App] please use loadCampus() instead");
    this.loadCampus(name, {
      successCallback : url,
      errorCallback : callback
    });
  }, self.prototype.unloadScene = function(e) {
    THING.Utils.warn("[App] please use unloadCampus() instead");
    this.unloadCampus(e);
  }, self.prototype.showScene = function(scene, index) {
    THING.Utils.warn("[App] please use 'getCampus(url).visible=true/false' instead");
    this.sceneManager.showScene(scene, index);
  }, self.prototype.saveAsImageData = function(img, hiddenId) {
    var fmt = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "jpeg";
    var artistTrack = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
    var n = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    return THING.Utils.warn("[App] Please use '.captureScreenshotToImage' to replace '.saveAsImageData'"), this.captureScreenshotToImage(img, hiddenId, fmt, artistTrack, n);
  }, self.prototype.saveAsImage = function(canvas, width, height) {
    THING.Utils.warn("[App] Please use '.captureScreenshot' to replace '.saveAsImage'");
    this.captureScreenshot(canvas, width, height);
  }, self.prototype.setSkyEffect = function(result) {
    THING.Utils.warn("[App] Please use '.skyEffect={}' to replace '.setSkyEffect'");
    this.skyEffect = result;
  }, self.prototype.setLighting = function(lighting) {
    THING.Utils.warn("[App] Please use '.lighting={}' to replace '.setLighting'");
    this.lighting = lighting;
  }, self.prototype.setPostEffect = function(postEffect, postEffectModel) {
    THING.Utils.warn("[App] Please use '.postEffect={}' to replace '.setPostEffect'");
    this.postEffect = postEffect;
  }, self.prototype.setFog = function(value) {
    THING.Utils.warn("[App] Please use '.fog={}' to replace '.setFog'");
    this.sceneManager.setFog(value);
  }, self.prototype.loadCampus = function(value, obj) {
    return THING.Utils.warn("[App] Please use 'app.create({type: 'Campus' ...}) ' to replace '.loadCampus'"), obj = obj || {}, this.create(Utils.mergeObject(obj, {
      type : "Campus",
      url : value
    }));
  }, self.prototype.unloadCampus = function(a22) {
    THING.Utils.warn("[App] Please use 'app.query('[url=?']).destroy() ' to replace '.unloadCampus'");
    this.query("[url=" + a22 + "]").destroy();
  }, self.prototype.getCampus = function(callbacks) {
    THING.Utils.warn("[App] Please use 'app.query('[url=?']) ' to replace '.getCampus'");
    var results = this.query("[url=" + callbacks + "]");
    return results.length ? results[0] : null;
  }, self.prototype.showGrid = function(options, data, context, callback, user) {
    THING.Utils.warn("[App] Please use 'app.root.showGrid()' to replace '.app.showGrid()'");
    this.root.showGrid(options, data, context, callback, user);
  }, self.prototype.getGridSize = function() {
    return THING.Utils.warn("[App] Please use 'app.root.gridSize' to replace '.app.getGridSize()'"), this.root.gridSize;
  }, self.prototype.registerBundleLoader = function(e, size) {
    if (!this._appBundle) {
      this._appBundle = new up;
    }
    this._appBundle.registerBundleLoader(e, size);
  }, self.prototype.loadBundle = function(name) {
    var artistTrack = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    var r_objects = arguments[2];
    return this._appBundle || (this._appBundle = new up), this._appBundle.loadBundle(name, artistTrack, r_objects);
  }, n(self, [{
    key : "clickDistance",
    set : function(v) {
      hp = v;
    },
    get : function() {
      return hp;
    }
  }, {
    key : "elapsedTime",
    get : function() {
      return Math.floor(1e3 * this._elapsedTime);
    }
  }, {
    key : "deltaTime",
    get : function() {
      return Math.floor(1e3 * this._deltaTime);
    }
  }, {
    key : "currentFrameCount",
    get : function() {
      return this._currentFrame;
    }
  }, {
    key : "pixelRatio",
    set : function(x) {
      this._pixelRatio = x;
      this.renderer.setPixelRatio(x * window.devicePixelRatio);
    },
    get : function() {
      return this._pixelRatio;
    }
  }, {
    key : "size",
    get : function() {
      if (this._size) {
        return this._size;
      }
      var cssChanges = this.calcRect();
      return [cssChanges.width, cssChanges.height];
    },
    set : function(value) {
      this._size = value;
      this.resize();
    }
  }, {
    key : "selection",
    get : function() {
      return this._selection;
    }
  }, {
    key : "skyEffect",
    set : function(v) {
      if (v) {
        this.sceneManager.setSkyEffect(v);
      } else {
        this.sceneManager.closeSkyEffect();
      }
    },
    get : function() {
      var win = this.sceneManager._skyEffect;
      return win && win.visible ? Utils.cloneObject(win.getConfig(), false) : null;
    }
  }, {
    key : "lighting",
    set : function(name) {
      name = name || Bu;
      this._lightGroup.setConfig(name);
    },
    get : function() {
      return Utils.cloneObject(this._lightGroup.getConfig(), false);
    }
  }, {
    key : "fog",
    set : function(v) {
      if (v) {
        this.sceneManager.setFog(v);
      } else {
        this.sceneManager.closeFog();
      }
    },
    get : function() {
      return this.sceneManager.fogEnable ? Utils.cloneObject(this.sceneManager._fogConfig, false) : null;
    }
  }, {
    key : "postEffect",
    set : function(v) {
      if (v) {
        this.renderEffects.mergeConfig(v).update();
      } else {
        this.renderEffects.mergeConfig({
          temporalSuperSampling : {
            enable : false
          },
          postEffect : {
            enable : false
          }
        }).update();
      }
    },
    get : function() {
      var target = this.renderEffects.getConfig();
      return target.temporalSuperSampling.enable || target.postEffect.enable ? Utils.cloneObject(target, false) : null;
    }
  }, {
    key : "keepBackgroundAspect",
    set : function(v) {
      if (v !== this._keepBackgroundAspect) {
        this._keepBackgroundAspect = v;
        if (v) {
          this.sceneManager._keepBackgroundAspect();
        } else {
          this.sceneManager._resetBackgroundAspect();
        }
      }
    },
    get : function() {
      return !!this._keepBackgroundAspect;
    }
  }, {
    key : "bgColor",
    get : function() {
      return this._bgColor ? this._bgColor.toHexString() : null;
    },
    set : function(v) {
      this._bgColor = Utils.parseColor(v);
      if (this.scene.background.isColor) {
        this.scene.background = this._bgColor;
      }
    }
  }, {
    key : "background",
    set : function(value) {
      this.sceneManager.background = value;
    },
    get : function() {
      var val = this.sceneManager.background;
      return Utils.isNumber(val) ? "#" + val.toString(16).toUpperCase() : val;
    }
  }, {
    key : "backgroundAdditiveColor",
    set : function(v) {
      this.sceneManager.backgroundAdditiveColor = v;
    },
    get : function() {
      return this.sceneManager.backgroundAdditiveColor;
    }
  }, {
    key : "backgroundColorScaleFactor",
    set : function(v) {
      this.sceneManager.backgroundColorScaleFactor = v;
    },
    get : function() {
      return this.sceneManager.backgroundColorScaleFactor;
    }
  }, {
    key : "skyBox",
    set : function(v) {
      if (this.sceneManager) {
        this.sceneManager.skyBox = v;
      }
    },
    get : function() {
      return this.sceneManager ? this.sceneManager.skyBox : "";
    }
  }, {
    key : "needUpdate",
    set : function(v) {
      if (v) {
        if (this._dirtyFrameCount == this._currentFrame) {
          return;
        }
        this._dirtyFrameCount = this._currentFrame;
        if (this.picker) {
          this.picker.needUpdate = v;
        }
        if (this.rendererManager) {
          this.rendererManager.needUpdate = v;
        }
      }
    }
  }, {
    key : "needEffectUpdate",
    set : function(v) {
      if (v && this.rendererManager) {
        this.rendererManager.needUpdate = v;
      }
    }
  }, {
    key : "loadingProgressBar",
    get : function() {
      return this.mainUI.loadingProgressBar;
    }
  }, {
    key : "needTracelessRendering",
    set : function(v) {
      if (this.picker) {
        this.picker.needTracelessRendering = v;
      }
    }
  }, {
    key : "useAsLoader",
    set : function(v) {
      this._useAsLoader = v;
    },
    get : function() {
      return this._useAsLoader;
    }
  }, {
    key : "skipUnbindAppEvents",
    set : function(v) {
      this._skipUnbindAppEvents = v;
    },
    get : function() {
      return this._skipUnbindAppEvents;
    }
  }, {
    key : "mainDomElement",
    get : function() {
      return this.domElement;
    }
  }, {
    key : "isMobileDevice",
    get : function() {
      return void 0 !== this._isMobile ? this._isMobile : this._isMobile = Dt();
    }
  }, {
    key : "level",
    get : function() {
      return this.sceneLevel;
    }
  }, {
    key : "root",
    get : function() {
      return this.sceneRoot;
    }
  }, {
    key : "mousePosition",
    get : function() {
      return this.events.mousePosition;
    }
  }, {
    key : "renderOptions",
    set : function(v) {
      v = v || {};
      this._renderOptions = v;
    },
    get : function() {
      return this._renderOptions;
    }
  }, {
    key : "campuses",
    get : function() {
      return THING.Utils.warn("[App] The 'app.campuses' will be deleted soon, please use 'app.root.campuses' to replace it"), this.root.campuses;
    }
  }, {
    key : "buildings",
    get : function() {
      return THING.Utils.warn("[App] The 'app.buildings' will be deleted soon, please use 'app.root.defaultCampus.buildings' to replace it"), this.root.defaultCampus.buildings;
    }
  }, {
    key : "disableWarning",
    set : function(v) {
      THING.Utils.warn("[App] Please use 'Utils.disableWarning' to replace '.disableWarning'");
      Utils.disableWarning = v;
    }
  }, {
    key : "disableTime",
    set : function(v) {
      THING.Utils.warn("[App] Please use 'Utils.disableTime' to replace '.disableTime'");
      Utils.disableTime = v;
    }
  }, {
    key : "isShiftKeyPressed",
    get : function() {
      return THING.Utils.warn("[App] Please use '.isKeyPressed(THING.KeyType.Shift)' to replace '.isShiftKeyPressed'"), this.events.isKeyPressed(south1.Shift);
    }
  }, {
    key : "isControlKeyPressed",
    get : function() {
      return THING.Utils.warn("[App] Please use '.isKeyPressed(THING.KeyType.Ctrl)' to replace '.isControlKeyPressed'"), this.events.isKeyPressed(south1.Ctrl);
    }
  }, {
    key : "isAltKeyPressed",
    get : function() {
      return THING.Utils.warn("[App] Please use '.isKeyPressed(THING.KeyType.Alt)' to replace '.isAltKeyPressed'"), this.events.isKeyPressed(south1.Alt);
    }
  }, {
    key : "isMobile",
    get : function() {
      return THING.Utils.warn("[App] Please use '.isMobileDevice' to replace '.isMobile'"), this.isMobileDevice;
    }
  }, {
    key : "wireframeColor",
    set : function(string) {
      return THING.Utils.warn("[App] Please use '.app.root.wireframeColor' to replace '.wireframeColor'"), this.root.wireframeColor = string;
    }
  }, {
    key : "domOffset",
    set : function(v) {
      THING.Utils.warn("[App] domOffset is deprecated");
    }
  }, {
    key : "cache",
    get : function() {
      return THING.Utils.warn("[App] cache is deprecated"), false;
    }
  }, {
    key : "outdoors",
    set : function(v) {
    },
    get : function() {
      return this.root ? this.root.defaultCampus.outdoors : null;
    }
  }, {
    key : "loadingProgressBarVisible",
    set : function(v) {
      THING.Utils.warn("[App] Please use '.loadingProgressBar.visible = true/false' to replace '.loadingProgressBarVisible=true/false'");
      this.mainUI.loadingProgressBar.visible = v;
    },
    get : function() {
      return THING.Utils.warn("[App] Please use '.loadingProgressBar.visible' to replace '.loadingProgressBarVisible'"), this.mainUI.loadingProgressBar.visible;
    }
  }, {
    key : "currentFrame",
    get : function() {
      return THING.Utils.warn("[App] Please use '.currentFrameCount' to replace '.currentFrame'"), this.currentFrameCount;
    }
  }]), self;
}();
ThingApp.on = ThingApp.on || {};
var dp = function(self) {
  function t(params) {
    return r(this, t), s(this, self.call(this, params));
  }
  return o(t, self), t.prototype._init = function(type, obj) {
    self.prototype._init.call(this, type, obj);
    this.node.userData.baseObject_bindSubNode = this;
  }, t.prototype._updateBindSubNodeState = function() {
    this.node.userData.baseObject_bindSubNode_hooked = this.hasAnyEvents();
  }, t.prototype._on = function(context, event, obj, fn, name) {
    var e = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 51;
    var ret = self.prototype._on.call(this, context, event, obj, fn, name, e);
    return this._updateBindSubNodeState(), ret;
  }, t.prototype._off = function(event, callback, type) {
    var result = self.prototype._off.call(this, event, callback, type);
    return this._updateBindSubNodeState(), result;
  }, t.prototype.canAcceptEvent = function(node) {
    if (self.prototype.canAcceptEvent.call(this, node)) {
      return this;
    }
    var decl = node.intersect;
    return decl && decl.node && decl.node == this.node ? this : null;
  }, t;
}(BaseObject);
dp.create = function(x, y) {
  var point = new dp(y.app);
  return point._init(x, y), point;
};
var fp = Symbol("private");
function mp(set, data) {
  set[fp] = {};
  var self = set[fp];
  self.init = function() {
    var target = data.values;
    if (target) {
      self.addAction("___defaultValue___", target);
    }
    self.onChange = data.onChange || self.onChange;
  };
  self.createAction = function(name) {
    var t = self.actions.get(name);
    return t || (t = {
      name : name,
      result : {},
      results : []
    }, self.actions.set(name, t), t);
  };
  self.processActions = function() {
    var users = {};
    self.actions.forEach(function(action) {
      self.processAction(action, users);
    });
    self.onChange({
      result : users
    });
  };
  self.processAction = function(action, context) {
    action.results.forEach(function(elem) {
      var options = elem.options;
      var name;
      for (name in options) {
        var oldValue = options[name];
        context[name] = oldValue;
      }
    });
  };
  self.addAction = function(action, params, name, priority) {
    var res = self.createAction(action);
    var obj = {
      options : params,
      tag : name,
      priority : priority,
      index : res.results.length
    };
    res.results.push(obj);
    res.results.sort(function(a, b) {
      return a.priority !== b.priority ? b.priority - a.priority : a.index - b.index;
    });
    self.processActions();
  };
  self.removeAction = function(index, text) {
    var r = self.actions.get(index);
    if (r) {
      var s = r.results;
      var n = 0;
      for (; n < s.length; n++) {
        if (s[n].tag == text) {
          return s.splice(n, 1), void self.processActions();
        }
      }
    }
  };
  self.actions = new Map;
  self.onChange = function() {
  };
  self.init();
}
var gp = function() {
  function i() {
    var callback = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    r(this, i);
    mp(this, callback);
  }
  return i.prototype.add = function(name, target, value) {
    var normal = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
    var self = this[fp];
    self.addAction(name, target, value, normal);
  }, i.prototype.remove = function(name, action) {
    if (name) {
      this[fp].removeAction(name, action);
    }
  }, i;
}();
vp = Symbol("private");
var yp;
var bp = new THREE.Matrix4;
var _p = new THREE.Vector3;
var xp = new THREE.Vector2;
var Ep = new THREE.Vector3;
var wp = new THREE.Vector3;
var Tp = new THREE.Vector3;
var Mp = new THREE.Vector3;
var Cp = new THREE.Vector3;
var Sp = new THREE.Vector3;
var jp = new THREE.Quaternion;
var Pp = (new THREE.Quaternion, new THREE.Box3);
var Rp = new THREE.Raycaster;
var Dp = new THREE.Vector3;
var Ap = new THREE.Vector3;
var kp = new THREE.Quaternion;
var Op = new THREE.Quaternion;
var Bp = new THREE.Matrix4;
var Fp = new THREE.Matrix4;
var Lp = ["clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "map", "matcap", "alphaMap", "lightMap", "aoMap", "bumpMap", "normalMap", "displacementMap", "roughnessMap", "metalnessMap", "emissiveMap", "specularMap", "envMap", "gradientMap"];
var Ip = {
  WHITE : 16777215,
  SILVER : 12632256,
  GRAY : 8421504,
  BLACK : 0,
  RED : 16711680,
  MAROON : 8388608,
  GREEN : 32768,
  BLUE : 255,
  NAVY : 128,
  YELLOW : 16776960,
  OLIVE : 8421376,
  FUCHSIA : 16711935,
  MAGENTA : 16711935,
  LIME : 914021,
  PURPLE : 8388736,
  LAWN : 3135031,
  AQUA : 65535,
  CYAN : 65535,
  TEAL : 32896,
  ORANGE : 16753920,
  VIOLET : 7737555,
  GREENYELLOW : 6617095,
  createFrustumFOV : function(lon, offset, near, far) {
    var n = near * Math.tan(THING.Math.degToRad(lon) / 2);
    var i = -n;
    var x = offset * n;
    var r = -x;
    return Ip.createFrustum(x, r, n, i, near, far);
  },
  createFrustum : function(width, scale, i, r, near, far) {
    function transform(data, fileName, type) {
      parseModel(data, type);
      parseModel(fileName, type);
    }
    function parseModel(key, value) {
      var angular = new THREE.Vector3;
      angular.copy(registryHost[key]);
      geometry.vertices.push(angular);
      geometry.colors.push(new THREE.Color(value));
    }
    var geometry = new THREE.Geometry;
    var linkMaterial = new THREE.LineBasicMaterial({
      color : 16777215,
      linewidth : 3,
      vertexColors : THREE.FaceColors
    });
    var radius = far / near;
    var registryHost = {
      ltn : new THREE.Vector3(width, i, near),
      lbn : new THREE.Vector3(width, r, near),
      rbn : new THREE.Vector3(scale, r, near),
      rtn : new THREE.Vector3(scale, i, near),
      ltf : new THREE.Vector3(radius * width, radius * i, far),
      lbf : new THREE.Vector3(radius * width, radius * r, far),
      rbf : new THREE.Vector3(radius * scale, radius * r, far),
      rtf : new THREE.Vector3(radius * scale, radius * i, far)
    };
    return transform("ltn", "lbn", Ip.RED), transform("lbn", "rbn", Ip.RED), transform("rbn", "rtn", Ip.RED), transform("rtn", "ltn", Ip.RED), transform("ltf", "lbf", Ip.LIME), transform("lbf", "rbf", Ip.LIME), transform("rbf", "rtf", Ip.LIME), transform("rtf", "ltf", Ip.LIME), transform("ltf", "ltn", Ip.BLUE), transform("lbf", "lbn", Ip.BLUE), transform("rbf", "rbn", Ip.BLUE), transform("rtf", "rtn", Ip.BLUE), new THREE.Line(geometry, linkMaterial, THREE.LinePieces);
  }
};
var Np = new Map;
var Hp = new Map;
function Up(line, x) {
  var e = line.get(x);
  return e || (e = new RegExp(x), line.set(x, e)), e;
}
function zp(n, a) {
  if (a) {
    var result = Hp.get(a);
    return result || (result = new Map, Hp.set(a, result)), Up(result, n);
  }
  return Up(Np, n);
}
function Vp(token, resultTokens) {
  if ("string" != typeof token) {
    throw new TypeError("expected path to be a string");
  }
  if ("\\" === token || "/" === token) {
    return "/";
  }
  var tLe = token.length;
  if (tLe <= 1) {
    return token;
  }
  var deviceHTML = "";
  if (tLe > 4 && "\\" === token[3]) {
    var type = token[2];
    if (!("?" !== type && "." !== type || "\\\\" !== token.slice(0, 2))) {
      token = token.slice(2);
      deviceHTML = "//";
    }
  }
  var args = token.split(/[/\\]+/);
  return false !== resultTokens && "" === args[args.length - 1] && args.pop(), deviceHTML + args.join("/");
}
Object.defineProperties(Array.prototype, {
  forEachSync : {
    writable : true,
    enumerable : false,
    configurable : true,
    value : (yp = i(g.mark(function update(t, n, next) {
      var i;
      var value;
      return g.wrap(function(self) {
        for (;;) {
          switch(self.prev = self.next) {
            case 0:
              self.prev = 0;
              i = 0;
            case 2:
              if (!(i < this.length)) {
                self.next = 10;
                break;
              }
              if (!(value = t(this[i], i, this))) {
                self.next = 7;
                break;
              }
              return self.next = 7, value.catch(function(destroyErr) {
                if (next) {
                  next(destroyErr);
                }
              });
            case 7:
              i++;
              self.next = 2;
              break;
            case 10:
              if (n) {
                n();
              }
              self.next = 16;
              break;
            case 13:
              self.prev = 13;
              self.t0 = self.catch(0);
              if (next) {
                next(self.t0);
              }
            case 16:
            case "end":
              return self.stop();
          }
        }
      }, update, this, [[0, 13]]);
    })), function(canCreateDiscussions, isSlidingUp, i) {
      return yp.apply(this, arguments);
    })
  },
  waitForEachSync : {
    writable : true,
    enumerable : false,
    configurable : true,
    value : function(type) {
      var tools = this;
      return new Promise(function(preferredForm, context) {
        tools.forEachSync(type, preferredForm, context);
      });
    }
  }
}), String.prototype.getNormalize = function() {
  var i = this.indexOf("://");
  return -1 !== i ? this.substring(0, i + 3) + Vp(this.substring(i + 3)) : Vp(this.substring());
};
String.prototype.startsWith = function(str) {
  return this.slice(0, str.length) === str;
};
String.prototype.endsWith = function(value) {
  return -1 !== this.indexOf(value, this.length - value.length);
};
String.prototype.contains = function(parent) {
  return this.indexOf(parent) >= 0;
};
String.prototype.isBlank = function() {
  return Utils.isBlank(this);
};
String.prototype.getFileName = function() {
  var mod = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
  var i = this.indexOf("\\") >= 0 ? this.lastIndexOf("\\") : this.lastIndexOf("/");
  if (-1 === i) {
    return mod ? this : this.split(".")[0];
  }
  var c = this.substring(i);
  return 0 !== c.indexOf("\\") && 0 !== c.indexOf("/") || (c = c.substring(1)), mod ? c : c.split(".")[0];
};
String.prototype.getPath = function() {
  var index = this.lastIndexOf("\\");
  var thisIndex = this.lastIndexOf("/");
  var i = index > thisIndex ? index : thisIndex;
  return this.substring(0, i);
};
String.prototype.getSearchName = function() {
  var filename = this.getFileName();
  var index = filename.indexOf("?");
  return -1 === index ? "" : filename.substring(index);
};
String.prototype.getExtension = function() {
  var parts = this.split(".");
  if (parts.length > 1) {
    var value = parts.pop();
    var cEndIdx = value.indexOf("?");
    return -1 !== cEndIdx ? value.substring(0, cEndIdx) : value;
  }
  return "";
};
String.prototype._trimLeft = function(text) {
  if (void 0 === text) {
    text = "s";
  }
  var oldValue = zp("^[" + text + "]+");
  return this.replace(oldValue, "");
};
String.prototype._trimRight = function(text) {
  if (void 0 === text) {
    text = "s";
  }
  var oldValue = zp("[" + text + "]+$");
  return this.replace(oldValue, "");
};
String.prototype.trimBoth = function(text) {
  return this._trimLeft(text)._trimRight(text);
};
String.prototype.appendPath = function(name) {
  return this._trimRight("/") + "/" + name._trimLeft("/")._trimRight("/");
};
String.prototype.appendURL = function(path) {
  var name = this.getFileName();
  return name.startsWith("?") ? this.getPath().appendPath(path) + name : this.appendPath(path);
};
String.prototype.appendRandomSuffix = function() {
  return this.substring() + "?t=" + (new Date).getTime();
};
String.prototype.equals = function(value) {
  var getValue = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
  return null != value && (getValue ? this.toUpperCase() == value.toUpperCase() : this == value);
};
var Wp = String.prototype.replaceAll;
String.prototype.replaceAll = function(s, s2) {
  if ("\\" == s) {
    s = "\\\\";
  }
  try {
    var re = zp(s, "gm");
    return this.replace(re, s2);
  } catch (e) {
    return Wp.apply(this, arguments);
  }
};
String.prototype.removeAt = function(index) {
  var s = this.substring(0);
  return index >= this.length ? s : s.slice(0, index) + s.slice(index + 1);
};
THREE.Color.prototype.copy = function(value) {
  return value && (this.r = value.r, this.g = value.g, this.b = value.b), this;
};
THREE.Color.prototype.toHexString = function() {
  return "#" + this.getHexString().toUpperCase();
};
THREE.Color.prototype.toRGBArray = function() {
  var newNodeLists = [];
  return newNodeLists.push(Math.ceil(255 * this.r)), newNodeLists.push(Math.ceil(255 * this.g)), newNodeLists.push(Math.ceil(255 * this.b)), newNodeLists;
};
THREE.Line.prototype.updatePosition = function(options, x) {
  var vertices = this.geometry.vertices;
  if (2 == vertices.length) {
    var c = vertices[0];
    var v = vertices[1];
    if (!(c.equals(options) && v.equals(x))) {
      c.x = options.x;
      c.y = options.y;
      c.z = options.z;
      v.x = x.x;
      v.y = x.y;
      v.z = x.z;
      this.geometry.boundingSphere = null;
      this.geometry.verticesNeedUpdate = true;
      this.computeLineDistances();
    }
  }
};
var Gp = function() {
  var e = THING.App.current ? THING.App.current.level.current : null;
  return e ? e._getBaseMatrix() : null;
};
var qp = [];
var Xp = 0;
for (; Xp < 256; Xp++) {
  qp[Xp] = (Xp < 16 ? "0" : "") + Xp.toString(16).toUpperCase();
}
THREE.MathUtils.generateUUID = function() {
  var e = 4294967295 * Math.random() | 0;
  var t = 4294967295 * Math.random() | 0;
  var i = 4294967295 * Math.random() | 0;
  var r = 4294967295 * Math.random() | 0;
  return qp[255 & e] + qp[e >> 8 & 255] + qp[e >> 16 & 255] + qp[e >> 24 & 255] + "-" + qp[255 & t] + qp[t >> 8 & 255] + "-" + qp[t >> 16 & 15 | 64] + qp[t >> 24 & 255] + "-" + qp[63 & i | 128] + qp[i >> 8 & 255] + "-" + qp[i >> 16 & 255] + qp[i >> 24 & 255] + qp[255 & r] + qp[r >> 8 & 255] + qp[r >> 16 & 255] + qp[r >> 24 & 255];
};
THREE.Vector3.prototype.getPositionFromSpherical = function(f, k, i) {
  var d = new THREE.Vector3;
  var v = Math.sin(i);
  return d.x = v * Math.cos(k), d.y = -Math.cos(i), d.z = v * Math.sin(k), d.normalize(), d.multiplyScalar(f), d.add(this), d;
};
THREE.Vector3.prototype.getDirectionFromAngles = function(obj, pos, a) {
  var vector = Utils.parseVector3(THING.Math.directionFromAlphaBeta(obj, pos));
  return vector.normalize(), vector.multiplyScalar(a), vector.add(this), vector;
};
THREE.Vector3.prototype.getDirectionFromPosition = function(target, a) {
  var result = new THREE.Vector3;
  return result.subVectors(target, this), result.normalize(), result.multiplyScalar(a), result.add(this), result;
};
THREE.Vector3.prototype.getMinVector = function(result) {
  var ret = this.clone();
  if (Utils.isArray(result)) {
    var i = 0;
    for (; i < result.length; i++) {
      ret.min(result[i]);
    }
  } else {
    ret.min(result);
  }
  return ret;
};
THREE.Vector3.prototype.getMaxVector = function(result) {
  var ret = this.clone();
  if (Utils.isArray(result)) {
    var i = 0;
    for (; i < result.length; i++) {
      ret.max(result[i]);
    }
  } else {
    ret.min(result);
  }
  return ret;
};
THREE.Vector3.prototype.toLogString = function() {
  return "x: " + this.x + ", y: " + this.y + ", z: " + this.z;
};
THREE.Vector3.prototype.isEqual = function(b) {
  return !!Utils.isNumberEqual(this.x, b.x) && (!!Utils.isNumberEqual(this.y, b.y) && !!Utils.isNumberEqual(this.z, b.z));
};
THREE.Vector3.prototype.log = function() {
  THING.Utils.log(this.toLogString());
};
THREE.Vector4.prototype.project = function(camera) {
  return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
};
THREE.Vector4.prototype.unproject = function(camera) {
  var matrix = new THREE.Matrix4;
  return this.applyMatrix4(matrix.getInverse(camera.projectionMatrix)).applyMatrix4(camera.matrixWorld);
};
THREE.Object3D.prototype.check = function() {
  var child = this;
  for (; child; child = child.parent) {
    if (isNaN(child.position.x) || isNaN(child.position.y) || isNaN(child.position.z)) {
      console.log(child);
      console.log(child.position);
    } else {
      if (isNaN(child.scale.x) || isNaN(child.scale.y) || isNaN(child.scale.z)) {
        console.log(child);
        console.log(child.scale);
      } else {
        if (isNaN(child.quaternion.x) || isNaN(child.quaternion.y) || isNaN(child.quaternion.z)) {
          console.log(child);
          console.log(child.quaternion);
        } else {
          if (isNaN(child.rotation.x) || isNaN(child.rotation.y) || isNaN(child.rotation.z)) {
            console.log(child);
            console.log(child.rotation);
          }
        }
      }
    }
  }
};
THREE.Object3D.prototype.dispose = function() {
  var grandparent = this.parent;
  if (grandparent) {
    grandparent.remove(this);
  }
  this.traverse(function(object) {
    if (object.geometry) {
      object.geometry.dispose();
    }
    var p = object.material;
    if (p) {
      if (Utils.isArray(p)) {
        var i = 0;
        for (; i < p.length; i++) {
          p[i].dispose();
        }
      } else {
        p.dispose();
      }
    }
    if (object.skeleton && object.skeleton.boneTexture) {
      object.skeleton.boneTexture.dispose();
    }
  });
};
THREE.Object3D.prototype.getVerticesCount = function() {
  var ret = 0;
  return this.traverse(function(gcFeature) {
    if (gcFeature.geometry) {
      ret = ret + gcFeature.geometry.getVerticesCount();
    }
  }), ret;
};
THREE.Object3D.prototype.getDirection = function(a) {
  var m = this.matrix.elements;
  return a.set(m[8], m[9], m[10]).normalize();
};
THREE.Object3D.prototype._premultiplyMatrix = function(i) {
  this.matrix.premultiply(i);
  this.matrix.decompose(this.position, this.quaternion, this.scale);
};
THREE.Object3D.prototype._mergeAllGeometries = function() {
  this.updateMatrixWorld();
  var _ = new THREE.Geometry;
  return this.traverse(function(child) {
    if (child.isMesh) {
      var geometry = child.geometry;
      if (geometry.isBufferGeometry) {
        geometry = (new THREE.Geometry).fromBufferGeometry(geometry);
      }
      _.merge(geometry, child.matrixWorld);
    }
  }), _;
};
THREE.Object3D.prototype._getMatrixWorld = function() {
  var t = this.matrixWorld;
  var e = Gp();
  return e && (t = t.clone()).premultiply(e), t;
};
THREE.Object3D.prototype.getBaseObjectOwner = function() {
  var node = this;
  for (; node; node = node.parent) {
    var pointedSceneObj = node.userData.object;
    if (pointedSceneObj) {
      return pointedSceneObj;
    }
  }
  return null;
};
var Jp = THREE.Object3D.prototype.copy;
THREE.Object3D.prototype.copy = function(value, t) {
  return Jp.call(this, value, t), this.technique = Utils.cloneObject(value.technique), this._cachedTechnique = Utils.cloneObject(value._cachedTechnique), value._wName && (this._wName = value._wName), this;
};
THREE.Object3D.prototype.setUserDataValue = function(key, socket) {
  this.traverse(function(object) {
    object.userData[key] = socket;
  });
};
THREE.Object3D.prototype.isMaterialVisible = function() {
  var m = this.material;
  if (!m) {
    return false;
  }
  if (void 0 !== m.length) {
    var i = 0;
    for (; i < m.length; i++) {
      if (m[0].visible) {
        return true;
      }
    }
    return false;
  }
  return m.visible;
};
THREE.Object3D.prototype.isRenderable = function() {
  return !!(this.isSprite || this.isMesh || this.isLine || this.isPoints || this.isImmediateRenderObject);
};
THREE.Object3D.prototype.isDebuggerNode = function() {
  var s = this;
  for (; s;) {
    if (s.userData.isDebuggerNode) {
      return true;
    }
    s = s.parent;
  }
  return false;
};
THREE.Object3D.prototype.cleanup = function() {
  function next(v) {
    return !v.children.length;
  }
  function replace(s) {
    var output = 0;
    var i = 0;
    for (; i < s.children.length; i++) {
      var r = s.children[i];
      if (!r.isRenderable()) {
        if (next(r)) {
          r.parent = null;
          s.children.splice(i--, 1);
          output++;
        } else {
          output = output + replace(r);
        }
      }
    }
    return output;
  }
  for (;;) {
    if (!replace(this)) {
      break;
    }
  }
};
THREE.Object3D.prototype.onBeforeUpdateModelViewMatrix = function(boardManager, isSlidingUp, $cont, $slides, callback, scopeIn) {
};
THREE.Object3D.prototype.hasBeforeRenderFunction = function(AnimName) {
  if (!this._beforeRenderFunctions) {
    return false;
  }
  var tna = 0;
  for (; tna < this._beforeRenderFunctions.length; tna++) {
    if (this._beforeRenderFunctions[tna].name == AnimName) {
      return true;
    }
  }
  return false;
};
THREE.Object3D.prototype.addBeforeRenderFunction = function(delta, i, count) {
  if (i && (this.traverseChild(function(geometry) {
    if (geometry.isRenderable()) {
      geometry.addBeforeRenderFunction(delta, i, count);
    }
  }), this._beforeRenderFunctions = this._beforeRenderFunctions || [], void 0 !== count && this._beforeRenderFunctions.length ? this._beforeRenderFunctions.splice(count, 0, {
    name : delta,
    func : i
  }) : this._beforeRenderFunctions.push({
    name : delta,
    func : i
  }), 1 === this._beforeRenderFunctions.length)) {
    var default_favicon = this.onBeforeRender;
    if (default_favicon && "function () {}" != default_favicon.toString()) {
      this._beforeRenderFunctions.splice(0, 0, {
        name : "__originalBeforeRender__",
        func : default_favicon
      });
    }
    var me = this;
    this.onBeforeRender = function(target, data, node, i, delta, renderer) {
      var n = 0;
      var numberOfFrustums = me._beforeRenderFunctions.length;
      for (; n < numberOfFrustums; n++) {
        me._beforeRenderFunctions[n].func.call(me, target, data, node, i, delta, renderer);
      }
    };
  }
};
THREE.Object3D.prototype.removeBeforeRenderFunction = function(name) {
  var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
  if (t) {
    this.traverseChild(function(texture) {
      if (texture.isRenderable()) {
        texture.removeBeforeRenderFunction(name);
      }
    });
  }
  this._beforeRenderFunctions = this._beforeRenderFunctions || [];
  var i = 0;
  for (; i < this._beforeRenderFunctions.length; i++) {
    var child = this._beforeRenderFunctions[i];
    var named_test = Utils.isFunction(name) ? child.func : child.name;
    if (named_test == name) {
      this._beforeRenderFunctions.splice(i--, 1);
    }
  }
  if (!this._beforeRenderFunctions.length) {
    this.onBeforeRender = function(target, data, elem) {
    };
  }
};
THREE.Object3D.prototype.setPickable = function(pickable) {
  var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
  this.userData.skipPick = !pickable;
  if (t) {
    this.traverse(function(datas) {
      var data = datas.userData;
      if (pickable) {
        delete data.skipPick;
      } else {
        data.skipPick = true;
      }
    });
  }
};
THREE.Object3D.prototype.getPickable = function() {
  return !this.userData.skipPick;
};
THREE.Object3D.prototype.showAll = function() {
  var s = this;
  for (; s;) {
    s.visible = true;
    s = s.parent;
  }
  this.getNodes().forEach(function(listView) {
    listView.ensureVisible(true, true);
  });
};
THREE.Object3D.prototype.setLayerVisible = function(visible) {
  if (visible) {
    this.layers.enable(0);
  } else {
    this.layers.disable(0);
  }
};
THREE.Object3D.prototype.getLayerVisible = function() {
  return !!(1 & this.layers.mask);
};
THREE.Object3D.prototype.isVisible = function() {
  var s = this;
  for (; s; s = s.parent) {
    if (!s.visible) {
      return false;
    }
  }
  return this.getVisible();
};
THREE.Object3D.prototype.ensureParentsVisible = function(value) {
  this.traverseParents(function(t) {
    t.visible = value;
  });
};
THREE.Object3D.prototype.ensureVisible = function(key) {
  var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
  if (void 0 === key) {
    if (this.userData.useVisibleOnly) {
      return this.visible;
    }
    var s = this;
    for (; s; s = s.parent) {
      if (!s.visible) {
        return false;
      }
    }
    return this.getLayerVisible();
  }
  if ("updateBox" === key) {
    if (this.userData.useVisibleOnly) {
      return this.visible;
    }
    s = this;
    for (; s; s = s.parent) {
      if (!s.visible && !s.userData.skipBoxVisibleCheck) {
        return false;
      }
    }
    return this.getLayerVisible();
  }
  if (!Utils.isBoolean(key)) {
    var r = this.userData;
    if (!r.alwaysPickable) {
      var item = this;
      for (; item;) {
        if (!item.visible) {
          return false;
        }
        if (key && !item.layers.test(key.layers)) {
          return false;
        }
        item = item.parent;
      }
    }
    return true;
  }
  var value = key;
  if (this.userData.useVisibleOnly) {
    this.visible = value;
  } else {
    this.setLayerVisible(value);
    if (t) {
      this.visible = value;
    }
  }
};
THREE.Object3D.prototype.getVisible = function() {
  return this.ensureVisible();
};
THREE.Object3D.prototype.getTypeString = function() {
  return this.isSprite ? "Sprite" : this.isMesh ? "Mesh" : this.isLine ? "Line" : this.isPoints ? "Points" : this.isScene ? "Scene" : this.isGroup ? "Group" : "Object3D";
};
THREE.Object3D.prototype.getObjectByUUID = function(uuid) {
  var unreadItem = null;
  return this.traverseBranch(function(item) {
    if (item.uuid == uuid) {
      return unreadItem = item, false;
    }
  }), unreadItem;
};
THREE.Object3D.prototype.setActive = function(value) {
  this.visible = value;
};
THREE.Object3D.prototype.getActive = function() {
  return this.visible;
};
THREE.Object3D.prototype.traverseParents = function(self) {
  if (self) {
    var parent = this.parent;
    for (; parent; parent = parent.parent) {
      self(parent);
    }
  }
};
THREE.Object3D.prototype.traverseChild = function(result) {
  var children = this.children;
  var i = 0;
  var length = children.length;
  for (; i < length; i++) {
    children[i].traverse(result);
  }
};
THREE.Object3D.prototype.traverseBreakable = function(error) {
  if (error(this)) {
    return this;
  }
  var children = this.children;
  var j = 0;
  var il = children.length;
  for (; j < il; j++) {
    var breakOnThisError = children[j].traverseBreakable(error);
    if (breakOnThisError) {
      return breakOnThisError;
    }
  }
  return null;
};
THREE.Object3D.prototype.traverseBranch = function(index) {
  if (false !== index(this)) {
    var children = this.children;
    var j = 0;
    var il = children.length;
    for (; j < il; j++) {
      children[j].traverseBranch(index);
    }
  }
};
THREE.Object3D.prototype.traverseAll = function(element) {
  element(this);
  var children = this.children;
  var j = 0;
  var il = children.length;
  for (; j < il; j++) {
    children[j].traverseAll(element);
  }
};
THREE.Object3D.prototype.traverseRenderableNodes = function(receiveFunc) {
  this.traverse(function(connector) {
    if (connector.isRenderable()) {
      receiveFunc(connector);
    }
  });
};
THREE.Object3D.prototype.getRoot = function() {
  var parent = this.parent;
  if (!parent) {
    return this;
  }
  for (; parent.parent;) {
    parent = parent.parent;
  }
  return parent;
};
THREE.Object3D.prototype.indexOf = function(name) {
  return name ? this.children.indexOf(name) : -1;
};
THREE.Object3D.prototype.indexOfParent = function() {
  var parent = this.parent;
  if (parent) {
    return parent.children.indexOf(this);
  }
};
THREE.Object3D.prototype.isChildOf = function(node) {
  var parent = this.parent;
  for (; parent;) {
    if (parent == node) {
      return true;
    }
    parent = parent.parent;
  }
  return false;
};
THREE.Object3D.prototype.getChildIndex = function(child) {
  var i = 0;
  for (; i < this.children.length; i++) {
    if (this.children[i] == child) {
      return i;
    }
  }
  return -1;
};
THREE.Object3D.prototype.getIndexPath = function(elem) {
  var colorDist = [];
  var child = this;
  for (; child.parent;) {
    var parent = child.parent;
    var n = parent.getChildIndex(child);
    if (-1 == n) {
      break;
    }
    if (colorDist.push(n), parent == elem) {
      break;
    }
    child = parent;
  }
  return colorDist;
};
THREE.Object3D.prototype.getChildNodeByIndexPath = function(s) {
  var group = this;
  var i = 0;
  for (; i < s.length; i++) {
    var k = s[i];
    if (k >= group.children.length) {
      return null;
    }
    group = group.children[k];
  }
  return group;
};
THREE.Object3D.prototype.getChildNodesNumber = function() {
  var e = 0;
  return this.traverse(function() {
    e++;
  }), e;
};
THREE.Object3D.prototype.getBones = function(context, geometry) {
  var _posPoints = [];
  var i = 0;
  for (; i < geometry.bones.length; i++) {
    var actions = geometry.bones[i].getIndexPath(context);
    var o = this;
    var action_name = actions.length - 1;
    for (; action_name >= 0; action_name--) {
      var a = actions[action_name];
      o = o.children[a];
    }
    _posPoints.push(o);
  }
  return _posPoints;
};
THREE.Object3D.prototype._detachFromParent = function(object, element) {
  this.applyMatrix4(object.matrixWorld);
  object.remove(this);
  element.add(this);
};
THREE.Object3D.prototype._attachToParent = function(pulse, parent) {
  this.applyMatrix4((new THREE.Matrix4).getInverse(parent.matrixWorld));
  if (pulse) {
    pulse.remove(this);
  }
  parent.add(this);
};
THREE.Object3D.prototype.attachToParent = function(parent, target, type) {
  if (void 0 === target) {
    target = parent;
  } else {
    if (Utils.isBoolean(target)) {
      type = target;
      target = parent;
    }
  }
  if (this.parent) {
    if (type) {
      this.updateWorldMatrix(true, false);
    }
    this._detachFromParent(this.parent, target);
  }
  if (parent) {
    if (type) {
      parent.updateWorldMatrix(true, false);
    }
    this._attachToParent(target, parent);
  }
};
THREE.Object3D.prototype.detachFromParent = function(node) {
  this.parent.updateMatrixWorld();
  this._detachFromParent(this.parent, node);
};
THREE.Object3D.prototype.attachChildren = function(options, elem) {
  this.updateMatrixWorld();
  var i = 0;
  for (; i < options.length; i++) {
    THREE.SceneUtils.attach(options[i], elem, this);
  }
};
THREE.Object3D.prototype.detachChildren = function(elem) {
  this.updateMatrixWorld();
  var detached = this.children.concat();
  var i = 0;
  for (; i < detached.length; i++) {
    detached[i]._detachFromParent(this, elem);
  }
  return detached;
};
THREE.Object3D.prototype.getChildrenNames = function() {
  var failures = [];
  return this.traverse(function(result) {
    if (!result.name.isBlank()) {
      failures.push(result.name);
    }
  }), failures;
};
THREE.Object3D.prototype.getVisibleChildrenNumber = function() {
  var e = 0;
  return this.traverse(function(oPresentationNode) {
    if (oPresentationNode.visible) {
      e++;
    }
  }), e;
};
THREE.Object3D.prototype.getInvisibleChildrenNumber = function() {
  var e = 0;
  return this.traverse(function(oPresentationNode) {
    if (!oPresentationNode.visible) {
      e++;
    }
  }), e;
};
THREE.Object3D.prototype.getParents = function() {
  var ret = [];
  var p = this.parent;
  for (; p; p = p.parent) {
    ret.push(p);
  }
  return ret;
};
THREE.Object3D.prototype.getInvalidNodes = function() {
  var _watchableTools = [];
  return this.traverse(function(t) {
    var s = t.scale;
    if (!(0 != s.x && 0 != s.y && 0 != s.z)) {
      _watchableTools.push(t);
    }
  }), _watchableTools;
};
THREE.Object3D.prototype.getGeometries = function() {
  var e = new Set;
  return this.traverse(function(elem) {
    var g = elem.geometry;
    if (g) {
      e.add(g);
    }
  }), Array.from(e);
};
THREE.Object3D.prototype.getVisibleMeshes = function() {
  var viewDisposedLog = [];
  return this.traverse(function(args) {
    if (args.isMesh && args.ensureVisible()) {
      viewDisposedLog.push(args);
    }
  }), viewDisposedLog;
};
THREE.Object3D.prototype.getGroups = function() {
  var _watchableTools = [];
  return this.traverse(function(t) {
    if (t.isGroup) {
      _watchableTools.push(t);
    }
  }), _watchableTools;
};
THREE.Object3D.prototype.getMeshes = function() {
  var lsup = [];
  return this.traverse(function(child) {
    if (child.isMesh) {
      lsup.push(child);
    }
  }), lsup;
};
THREE.Object3D.prototype.getSprites = function() {
  var playerCrosshairHit = [];
  return this.traverse(function(sprite) {
    if (sprite.isSprite) {
      playerCrosshairHit.push(sprite);
    }
  }), playerCrosshairHit;
};
THREE.Object3D.prototype.getRenderableNodes = function() {
  var nonIgnored = [];
  return this.traverse(function(file) {
    if (file.isRenderable()) {
      nonIgnored.push(file);
    }
  }), nonIgnored;
};
THREE.Object3D.prototype.getImages = function() {
  var e = new Set;
  return this.getMaterials().forEach(function(options) {
    Lp.forEach(function(i) {
      var evnt = options[i];
      if (evnt) {
        var file = evnt.image;
        if (file) {
          if (Utils.isArray(file)) {
            file.forEach(function(t) {
              e.add(t);
            });
          } else {
            e.add(file);
          }
        }
      }
    });
  }), Array.from(e);
};
THREE.Object3D.prototype.getTextures = function() {
  var e = new Set;
  return this.getMaterials().forEach(function(data) {
    Object.keys(data).forEach(function(text) {
      var txt = data[text];
      if (txt && txt.isTexture) {
        e.add(txt);
      }
    });
  }), Array.from(e);
};
THREE.Object3D.prototype.getTexturesFromImage = function(Authorization) {
  var canonicalizedHeadersArray = [];
  var results = this.getTextures();
  var i = 0;
  for (; i < results.length; i++) {
    var header = results[i];
    if (header.image == Authorization) {
      canonicalizedHeadersArray.push(header);
    }
  }
  return canonicalizedHeadersArray;
};
THREE.Object3D.prototype.getTexturesFromURL = function(canCreateDiscussions) {
  var outTextures = [];
  var results = this.getTextures();
  var i = 0;
  for (; i < results.length; i++) {
    var tex = results[i];
    if (tex.image.currentSrc == canCreateDiscussions) {
      outTextures.push(tex);
    }
  }
  return outTextures;
};
THREE.Object3D.prototype.traverseMaterials = function(callback) {
  this.traverse(function(bi) {
    var m = bi.material;
    if (m) {
      if (Utils.isArray(m)) {
        var i = 0;
        for (; i < m.length; i++) {
          callback(m[i]);
        }
      } else {
        callback(m);
      }
    }
  });
};
THREE.Object3D.prototype.traverseTextures = function(e) {
  this.traverse(function(jsonData) {
    var value = jsonData.material;
    if (value) {
      if (Utils.isArray(value)) {
        var k = 0;
        for (; k < value.length; k++) {
          var i;
          for (i in value[k]) {
            if ((p = value[k][i]) && p.isTexture) {
              e(value[k], i, p);
            }
          }
        }
      } else {
        for (i in value) {
          var p;
          if ((p = value[i]) && p.isTexture) {
            e(value, i, p);
          }
        }
      }
    }
  });
};
THREE.Object3D.prototype.getMaterials = function() {
  var e = new Set;
  return this.traverse(function(bi) {
    var m = bi.material;
    if (m) {
      if (Utils.isArray(m)) {
        m.forEach(function(t) {
          e.add(t);
        });
      } else {
        e.add(m);
      }
    }
  }), Array.from(e);
};
THREE.Object3D.prototype.getMeshByName = function(eventId) {
  var validationVM = null;
  return this.traverseBreakable(function(traceInfo) {
    if (traceInfo.isMesh && traceInfo.name == eventId) {
      return validationVM = traceInfo, true;
    }
  }), validationVM;
};
THREE.Object3D.prototype.hasMesh = function() {
  var e = false;
  return this.traverseBreakable(function(destEntry) {
    if (destEntry.isMesh) {
      return e = true;
    }
  }), e;
};
THREE.Object3D.prototype.getMeshNames = function() {
  var collect = [];
  return this.traverse(function(child) {
    if (child.isMesh) {
      collect.push(child.name);
    }
  }), collect;
};
THREE.Object3D.prototype.getSkinnedMeshes = function() {
  var lsup = [];
  return this.traverse(function(child) {
    if (child.isSkinnedMesh) {
      lsup.push(child);
    }
  }), lsup;
};
THREE.Object3D.prototype.hasSkinnedMesh = function() {
  var e = false;
  return this.traverseBreakable(function(child) {
    if (child.isSkinnedMesh) {
      return e = true;
    }
  }), e;
};
THREE.Object3D.prototype.hasSprite = function() {
  var e = false;
  return this.traverseBreakable(function(utils) {
    if (utils.isSprite) {
      return e = true;
    }
  }), e;
};
THREE.Object3D.prototype.hasMaterial = function(goalId) {
  if (!goalId) {
    return false;
  }
  var t = false;
  return this.traverseBreakable(function(i) {
    if (i.material == goalId) {
      return t = true;
    }
  }), t;
};
THREE.Object3D.prototype.hasGeometry = function(geometry) {
  if (!geometry) {
    return false;
  }
  var t = false;
  return this.traverseBreakable(function(cur) {
    if (cur.geometry == geometry) {
      return t = true;
    }
  }), t;
};
THREE.Object3D.prototype.hasTexture = function(texture) {
  function t(data) {
    var props2 = Object.keys(data);
    var i = 0;
    for (; i < props2.length; i++) {
      var type = data[props2[i]];
      if (type && type.isTexture && type == texture) {
        return true;
      }
    }
    return false;
  }
  if (!texture) {
    return false;
  }
  var i = false;
  return this.traverseBreakable(function(bi) {
    var m = bi.material;
    if (m) {
      if (Utils.isArray(m)) {
        if (t(m)) {
          return i = true;
        }
      } else {
        if (t(m)) {
          return i = true;
        }
      }
    }
  }), i;
};
THREE.Object3D.prototype.replace = function(id, c, r) {
  if (c && c.isObject3D) {
    var i = 0;
    for (; i < this.children.length; i++) {
      var a = this.children[i];
      if (a == id) {
        if (r) {
          r(a);
        }
        a = void 0;
        c.parent = this;
        this.children[i] = c;
        break;
      }
    }
  }
};
THREE.Object3D.prototype.insert = function(index, comp) {
  if (!(index > this.children.length)) {
    if (comp) {
      this.children.splice(index, 0, comp);
      comp.parent = this;
    }
  }
};
THREE.Object3D.prototype.removeBySelf = function() {
  if (this.parent) {
    this.parent.remove(this);
  }
};
THREE.Object3D.prototype.getAngles = function() {
  return Utils.parseAngles(this.rotation);
};
THREE.Object3D.prototype.setAngles = function(target) {
  var temp = Utils.parseEuler(target);
  this.rotation.copy(temp);
  this.updateMatrixWorld(false, false);
};
THREE.Object3D.prototype.getFacesNumber = function() {
  var result = 0;
  return this.traverseVisible(function(child) {
    if (child.isMesh) {
      var geometry = child.geometry;
      if (geometry.isBufferGeometry) {
        var index = geometry.index;
        result = result + (index ? index.count / 3 : geometry.attributes.position.count / 3);
      } else {
        if (geometry.isGeometry) {
          result = result + geometry.faces.length;
        }
      }
    }
  }), result;
};
THREE.Object3D.prototype.getVerticesNumber = function() {
  var shtStart = 0;
  return this.traverse(function(child) {
    if (child.isMesh) {
      var geometry = child.geometry;
      if (geometry.isBufferGeometry) {
        var isEdit = geometry.index;
        shtStart = shtStart + (isEdit ? geometry.index.count : geometry.attributes.position.count);
      } else {
        if (geometry.isGeometry) {
          shtStart = shtStart + geometry.vertices.length;
        }
      }
    }
  }), shtStart;
};
THREE.Object3D.prototype.getNodes = function() {
  var _watchableTools = [];
  return this.traverse(function(t) {
    _watchableTools.push(t);
  }), _watchableTools;
};
THREE.Object3D.prototype.getNodeByName = function(name) {
  var fileTooLarge;
  return this.traverseBreakable(function(file) {
    if (file.name == name) {
      return fileTooLarge = file, true;
    }
  }), fileTooLarge;
};
THREE.Object3D.prototype.getNodeByID = function(id) {
  var validationVM;
  return this.traverseBreakable(function(v) {
    if (v.id == id) {
      return validationVM = v, true;
    }
  }), validationVM;
};
THREE.Object3D.prototype.getNodeByUUID = function(uuid) {
  var unreadItem;
  return this.traverseBreakable(function(item) {
    if (item.uuid == uuid) {
      return unreadItem = item, true;
    }
  }), unreadItem;
};
THREE.Object3D.prototype.getParent = function() {
  return this.parent;
};
THREE.Object3D.prototype.setTransform = function(matrix) {
  var position = new THREE.Vector3;
  var scale = new THREE.Vector3;
  var m = new THREE.Quaternion;
  matrix.decompose(position, m, scale);
  this.quaternion.copy(m);
  this.position.copy(position);
  this.scale.copy(scale);
};
THREE.Object3D.prototype.getDistanceFromCamera = function(position) {
  if (this.parent) {
    this.updateWorldMatrix(true);
    var t = new THREE.Vector3;
    return this.getWorldPosition(t), position.distanceTo(t);
  }
};
THREE.Object3D.prototype.keepSize = function(Ctrl, element, value, opacity, position, rotationMatrix) {
  if (this.parent) {
    if (opacity) {
      this.updateWorldMatrix(true, false);
    }
    var vector = new THREE.Vector3;
    vector.setFromMatrixPosition(this.matrixWorld).applyMatrix4(rotationMatrix);
    var x = -vector.z;
    if (element.isVector2) {
      var box = [value / element.x, value / element.y];
      this.scale.set(x / box[0], x / box[1], 1);
    } else {
      if (element.isVector3) {
        box = [value / element.x, value / element.y, value / element.z];
        this.scale.set(x / box[0], x / box[1], x / box[2]);
      }
    }
    if (position) {
      this._synMatrixWorld();
    }
  }
};
THREE.Object3D.prototype._synMatrixWorld = function() {
  this.updateWorldMatrix(true, false);
  this.updateMatrixWorld();
};
THREE.Object3D.prototype._getWorldPosition = function(q) {
  return void 0 === q && (q = new THREE.Vector3), q.setFromMatrixPosition(this._getMatrixWorld());
};
THREE.Object3D.prototype._setWorldPosition = function(test, results) {
  Dp.copy(test);
  if (this.parent) {
    this.parent.updateWorldMatrix(true);
    this.parent.worldToLocal(Dp);
  }
  this.position.copy(Dp);
  if (results) {
    this._synMatrixWorld();
  }
};
THREE.Object3D.prototype._setWorldQuaternion = function(result) {
  kp.copy(result);
  if (this.parent) {
    this.parent.updateWorldMatrix(true);
    this.parent.matrixWorld.decompose(Dp, Op, Dp);
    Op.inverse();
    kp.premultiply(Op);
  }
  this.quaternion.copy(kp);
};
THREE.Object3D.prototype._setWorldAngles = function(document, fieldLabelMap) {
  if (this.parent) {
    this.updateWorldMatrix(true, false);
    this.parent.matrixWorld.decompose(wp, jp, Sp);
    jp.inverse();
    document.premultiply(jp);
  }
  this.quaternion.copy(document);
  if (fieldLabelMap) {
    this._synMatrixWorld();
  }
};
THREE.Object3D.prototype._setWorldScale = function(e, islongclick) {
  if (this.parent) {
    this.updateWorldMatrix(true);
    this.matrixWorld.decompose(Ap, kp, Dp);
    Dp.copy(e);
    Fp.compose(Ap, kp, Dp);
    Bp.getInverse(this.parent.matrixWorld);
    Fp.premultiply(Bp);
    Fp.decompose(Ap, kp, Dp);
  } else {
    Dp.copy(e);
  }
  this.scale.copy(Dp);
  if (islongclick) {
    this._synMatrixWorld();
  }
};
THREE.Object3D.prototype._getWorldScale = function() {
  this.updateWorldMatrix(true, false);
  var position = new THREE.Vector3;
  var quaternion = new THREE.Quaternion;
  var scale = new THREE.Vector3;
  return this.matrixWorld.decompose(position, quaternion, scale), scale;
};
THREE.Object3D.prototype.cloneByFilter = function(to) {
  var newMoment = this.clone(false);
  var i = 0;
  for (; i < this.children.length; i++) {
    var from = this.children[i];
    if (!to || to(from)) {
      var i = from.cloneByFilter(to);
      newMoment.add(i);
    }
  }
  return newMoment;
};
THREE.Object3D.prototype.getForwardPosition = function(amount) {
  var steer = new THREE.Vector3;
  return this.updateMatrixWorld(true), this.getWorldDirection(steer), steer.normalize(), steer.multiplyScalar(amount), steer.add(this.position), steer;
};
THREE.Object3D.prototype._faceTo = function(prefixTransliterations) {
  var up = this.worldToLocal(prefixTransliterations.clone());
  var rotation = (new THREE.Vector3).crossVectors(new THREE.Vector3(0, 0, 1), up).normalize();
  var upVector = (new THREE.Vector3(0, 0, 1)).angleTo(up.normalize().clone());
  this.rotateOnAxis(rotation, upVector);
};
THREE.Object3D.prototype._lookAtPosition = function(that, cardViewState) {
  var x = (that = that || {}).type;
  var y = that.axis;
  var m = that.quat;
  var handle = that.target;
  var value = that.targetPosition;
  var max = that.targetLocalPosition;
  if ("axis" == x && "y" == y) {
    if (that.billboard) {
      this.rotation.x = 0;
      this.rotation.z = 0;
    }
    var a = this.position;
    if (handle && handle.isCameraController) {
      var u = Utils.parseVector3(value);
      var c = new THREE.Vector3;
      this.getWorldPosition(c);
      var direction = handle.direction;
      var p = c.clone().sub(u).projectOnPlane(Utils.parseVector3(direction));
      p.add(u);
      if (this.parent) {
        this.parent.worldToLocal(p);
      }
      this.rotation.y = Math.atan2(p.x - a.x, p.z - a.z);
    } else {
      this.rotation.y = Math.atan2(max.x - a.x, max.z - a.z);
    }
  } else {
    if (!(this.isCamera || !handle || handle.isCameraController)) {
      this.up.copy((new THREE.Vector3(0, 1, 0)).transformDirection(this.matrixWorld));
    }
    this.lookAt(value);
    if ("axis" == x) {
      if ("x" == y) {
        this.rotateY(-Math.PI / 2);
      } else {
        if ("z" == y) {
          this.rotateX(-Math.PI / 2);
        }
      }
    }
  }
  if (m) {
    this.quaternion.multiply(m);
  }
  if (cardViewState) {
    this._synMatrixWorld();
  } else {
    this.updateWorldMatrix(false, false);
  }
};
THREE.Object3D.prototype._lookAt = function(that, t) {
  if (this.removeBeforeRenderFunction("__lookAt__"), that) {
    var f = this;
    this.addBeforeRenderFunction("__lookAt__", function(canCreateDiscussions, n, body, s, a, isSlidingUp) {
      var position = that.targetPosition || body;
      if (position.isObject3D) {
        position = position.position;
      }
      that.targetPosition = position;
      that.target = {
        direction : body.getDirection(new THREE.Vector3),
        isCameraController : true
      };
      f._lookAtPosition(that, Utils.isFunction(t) ? t() : t);
    });
  }
};
THREE.Object3D.prototype.skipBoundingBox = function(isLeft) {
  this.traverse(function(data) {
    if (isLeft) {
      data.userData.skipBoundingBox = isLeft;
    } else {
      delete data.userData.skipBoundingBox;
    }
  });
};
THREE.Object3D.prototype.setFrustumCulled = function(set_len) {
  this.traverse(function(object) {
    object.frustumCulled = set_len;
  });
};
THREE.Object3D.prototype.getMatrixWorldFromRoot = function(s) {
  this.updateWorldMatrix(true);
  var normalMatrix = new THREE.Matrix4;
  if (s) {
    var object = this;
    for (;;) {
      if (object == s) {
        normalMatrix.premultiply(object.matrixWorld);
        break;
      }
      normalMatrix.premultiply(object.matrix);
      object = object.parent;
    }
  }
  return normalMatrix;
};
THREE.Object3D.prototype.getMatrixFromRoot = function(type) {
  var normalMatrix = new THREE.Matrix4;
  if (type) {
    var object = this;
    for (; object != type;) {
      object.updateMatrix();
      normalMatrix.premultiply(object.matrix);
      object = object.parent;
    }
  }
  return normalMatrix;
};
THREE.Object3D.prototype.disposeMaterial = function() {
  if (this.material) {
    if (Utils.isArray(this.material)) {
      var i = 0;
      for (; i < this.material.length; i++) {
        this.material[i].dispose();
      }
    } else {
      this.material.dispose();
    }
    this.material = null;
  }
};
THREE.Object3D.prototype.decomposeTransform = function(position, quat, scale) {
  return this.matrix.decompose(position, quat, scale), this;
};
THREE.Object3D.prototype.decomposeWorldTransform = function(position, result, translation) {
  return this.updateWorldMatrix(true), this.matrixWorld.decompose(position, result, translation), this;
};
THREE.Matrix4.prototype.setScale = function(x) {
  var te = this.elements;
  return te[0] = x.x, te[5] = x.y, te[10] = x.z, this;
};
THREE.Euler.prototype.multiplyMatrix4 = function(m1) {
  var q = new THREE.Quaternion;
  q.setFromEuler(this);
  var m = new THREE.Quaternion;
  m.setFromRotationMatrix(m1);
  q.multiply(m);
  this.setFromQuaternion(q);
};
THREE.Euler.prototype.setRotationOrder = function(newOrder) {
  var q = new THREE.Quaternion;
  q.setFromEuler(this, false);
  this.setFromQuaternion(q, newOrder, true);
};
THREE.Quaternion.prototype.multiplyMatrix4 = function(m1) {
  var m = new THREE.Quaternion;
  m.setFromRotationMatrix(m1);
  this.multiply(m);
};
THREE.Quaternion.prototype.getAngles = function() {
  return Utils.parseAngles(this);
};
THREE.Frustum.prototype._intersectsObject = function(canCreateDiscussions) {
  var _frustum = this;
  return canCreateDiscussions = canCreateDiscussions.traverseBreakable(function(obj) {
    return obj.isMesh && _frustum.intersectsObject(obj) ? obj : null;
  });
};
THREE.PerspectiveCamera.prototype.orthoSize = function(source, reference) {
  var i = Utils.parseVector3(reference);
  var r = source.distanceTo(i);
  var d = 2 * Math.tan(this.fov / 2 * Math.PI / 180);
  var y = d * r;
  return {
    x : y * this.aspect,
    y : y,
    depth : d,
    z : r
  };
};
THREE.OrthographicCamera.prototype.orthoSize = function() {
  return {
    x : (this.right - this.left) / this.zoom,
    y : (this.top - this.bottom) / this.zoom
  };
};
THREE.OrthographicCamera.prototype.resize = function(x, h) {
  if (void 0 !== this.userData) {
    var imageHeight = this.userData.depth * this.userData.z;
    var width = imageHeight * (x / h);
    this.left = -width / 2;
    this.right = width / 2;
    this.top = imageHeight / 2;
    this.bottom = -imageHeight / 2;
    this.updateProjectionMatrix();
  }
};
Object.defineProperty(THREE.CombinedCamera.prototype, "isPerspectiveCamera", {
  get : function() {
    return this.inPerspectiveMode;
  }
}), Object.defineProperty(THREE.CombinedCamera.prototype, "isOrthographicCamera", {
  get : function() {
    return this.inOrthographicMode;
  }
}), Object.defineProperty(THREE.CombinedCamera.prototype, "isLerping", {
  get : function() {
    return this.isPerspectiveLerping || this.isOrthoLerping;
  }
}), THREE.CombinedCamera.prototype.getRaycaster = function(date, type, event) {
  return Rp._setFromCamera(date, type, this, event);
};
THREE.CombinedCamera.prototype.setNear = function(value) {
  this.cameraP.near = value;
  this.cameraO.near = value;
  this.updateProjectionMatrix();
};
THREE.CombinedCamera.prototype.setFar = function(value) {
  this.cameraP.far = value;
  this.cameraO.far = value;
  this.updateProjectionMatrix();
};
THREE.CombinedCamera.prototype.getProjectionMatrixAlways = function() {
  return this._backupProjectionMatrix && (this.isOrthoLerping || this.isOrthographicCamera) ? this._backupProjectionMatrix : this.projectionMatrix;
};
THREE.CombinedCamera.prototype.toPerspectiveCamera = function() {
  var camera = new THREE.CombinedCamera(1, 1, 1, 1, 1, 1, 1);
  return camera.fov = this.fov, camera.left = this.left, camera.right = this.right, camera.top = this.top, camera.bottom = this.bottom, camera.cameraO = new THREE.OrthographicCamera(1, 1, 1, 1, 1, 1), camera.cameraO.copy(this.cameraO), camera.cameraP = new THREE.PerspectiveCamera(1, 1, 1, 1), camera.cameraP.copy(this.cameraP), camera.zoom = this.zoom, camera.toPerspective(), camera;
};
THREE.CombinedCamera.prototype.toOrthoCamera = function(p2, t) {
  var p1 = this.cameraP.orthoSize(p2, t);
  var camera = new THREE.CombinedCamera(p1.x, p1.y, this.fov, this.near, this.far, this.cameraO.near, this.cameraO.far);
  return camera.orthoSize = p1, camera.toOrthographic(), camera;
};
THREE.CombinedCamera.prototype.lerpMatrix = function(options) {
  var input = (options = options || {}).fromMatrix;
  var hash = options.toMatrix;
  var duration = options.time;
  var i = options.lerpType || alphaIndex0.Quintic.Out;
  var s = options.start;
  var start = options.stop;
  var complete = options.complete;
  var obj = Utils.toMatrixElementsArray(input);
  var target = Utils.toMatrixElementsArray(hash);
  if (this.matrixTween) {
    this.matrixTween.stop();
  }
  this.matrixTween = (new TWEEN.Tween(obj)).to(target, duration).easing(i).onStart(function() {
    if (s) {
      s();
    }
  }).onUpdate(function() {
    Utils.elementsArrayToMatrix(input, this._object);
  }).onStop(function() {
    if (start) {
      start();
    }
  }).onComplete(function() {
    if (complete) {
      complete();
    }
  }).start();
};
THREE.CombinedCamera.prototype.lerpToOrthographic = function(position, y, i, fn) {
  var camera = this.toOrthoCamera(position, y);
  this.orthoSize = camera.orthoSize;
  this.zoom = 1;
  this.isOrthoLerping = true;
  this._backupProjectionMatrix = this.projectionMatrix.clone();
  var o = this;
  this.lerpMatrix({
    lerpType : alphaIndex0.Cubic.InOut,
    fromMatrix : this.projectionMatrix,
    toMatrix : camera.projectionMatrix,
    time : i,
    stop : function() {
      o.isOrthoLerping = false;
      if (fn) {
        fn();
      }
    },
    complete : function() {
      o.isOrthoLerping = false;
      o.toOrthographic();
      if (fn) {
        fn();
      }
    }
  });
};
THREE.CombinedCamera.prototype.lerpToPerspective = function(e, exceptionLevel) {
  var camera = this.toPerspectiveCamera();
  this.isPerspectiveLerping = true;
  var r = this;
  this.lerpMatrix({
    fromMatrix : this.projectionMatrix,
    toMatrix : camera.projectionMatrix,
    time : e,
    stop : function() {
      r.isPerspectiveLerping = false;
      if (exceptionLevel) {
        exceptionLevel();
      }
    },
    complete : function() {
      r.isPerspectiveLerping = false;
      r.toPerspective();
      if (exceptionLevel) {
        exceptionLevel();
      }
    }
  });
};
THREE.CombinedCamera.prototype.getEffectiveFOV = function() {
  return this.cameraP.getEffectiveFOV();
};
THREE.CombinedCamera.prototype.isInView = function(rect) {
  var modelViewMatrix = new THREE.Matrix4;
  modelViewMatrix.multiplyMatrices(this.projectionMatrix, this.matrixWorldInverse);
  var painter = new THREE.Frustum;
  return painter.setFromProjectionMatrix(modelViewMatrix), painter.intersectsBox(rect);
};
THREE.CombinedCamera.prototype.updateMatrixWorld = function(force) {
  if (this.matrixAutoUpdate) {
    this.updateMatrix();
  }
  if (this.matrixWorldNeedsUpdate || force) {
    this.matrixWorld.copy(this.matrix);
  }
  var testColor = Gp();
  if (testColor) {
    this.matrixWorld.premultiply(testColor);
  }
  this.matrixWorldInverse.getInverse(this.matrixWorld);
};
THREE.Mesh.prototype.verticesCount = function() {
  return this.geometry ? this.geometry.isBufferGeometry ? this.geometry.attributes.position.count : this.geometry.vertices.length : 0;
};
THREE.Mesh.prototype.simplify = function(data) {
  var precision = THING.Math.clamp(data, 0, 1);
  var util = new THREE.SimplifyModifier;
  var geometry = this.geometry;
  if (geometry instanceof THREE.BufferGeometry) {
    geometry = (new THREE.Geometry).fromBufferGeometry(geometry);
  }
  geometry.mergeVertices();
  var version = THING.Math.toInteger(geometry.vertices.length * (1 - precision));
  var result = util.modify(geometry, version);
  return new THREE.Mesh(result, this.material);
};
THREE.Mesh.prototype.getPerimeter = function() {
  var topLevelTreeElements = 0;
  var attributes = this.geometry.attributes;
  if (attributes) {
    var p = attributes.position;
    if (p.count < 2) {
      return 0;
    }
    var id = new THREE.Vector2(p.getX(0), p.getZ(0));
    var i = 1;
    for (; i < p.count; i++) {
      topLevelTreeElements = topLevelTreeElements + (tilelayer = new THREE.Vector2(p.getX(i), p.getZ(i))).distanceTo(id);
      id = tilelayer;
    }
    topLevelTreeElements = topLevelTreeElements + id.distanceTo(new THREE.Vector2(p.getX(0), p.getZ(0)));
  } else {
    var vertices = this.geometry.vertices;
    if (vertices.length < 2) {
      return 0;
    }
    id = new THREE.Vector2(vertices[0].x, vertices[0].y);
    i = 1;
    for (; i < vertices.length; i++) {
      var tilelayer;
      topLevelTreeElements = topLevelTreeElements + (tilelayer = new THREE.Vector2(vertices[i].x, vertices[i].y)).distanceTo(id);
      id = tilelayer;
    }
    topLevelTreeElements = topLevelTreeElements + id.distanceTo(new THREE.Vector2(vertices[0].x, vertices[0].y));
  }
  return topLevelTreeElements;
};
THREE.Mesh.prototype.getArea = function() {
  var intersect = [];
  var attributes = this.geometry.attributes;
  if (attributes) {
    var p = attributes.position;
    var i = 0;
    for (; i < p.count; i++) {
      var center = new THREE.Vector2(p.getX(i), p.getZ(i));
      intersect.push(center);
    }
  } else {
    var vertices = this.geometry.vertices;
    i = 0;
    for (; i < vertices.length; i++) {
      center = new THREE.Vector2(vertices[i].x, vertices[i].y);
      intersect.push(center);
    }
  }
  var area = THREE.ShapeUtils.area(intersect);
  return Math.abs(area);
};
THREE.Mesh.prototype.getPoints = function() {
  var result = [];
  this.updateWorldMatrix(true, false);
  var attributes = this.geometry.attributes;
  if (attributes) {
    var p = attributes.position;
    var i = 0;
    for (; i < p.count; i++) {
      (resultsSubject = new THREE.Vector3(p.getX(i), p.getY(i), p.getZ(i))).applyMatrix4(this.matrixWorld);
      result.push(resultsSubject.toArray());
    }
  } else {
    var vertices = this.geometry.vertices;
    if (vertices) {
      i = 0;
      for (; i < vertices.length; i++) {
        var resultsSubject;
        (resultsSubject = vertices[i].clone()).applyMatrix4(this.matrixWorld);
        result.push(resultsSubject.toArray());
      }
    }
  }
  return result;
};
THREE.Mesh.prototype.getLabelPosition = function(style, x) {
  var tree = [];
  if (this.geometry.attributes) {
    var p = this.geometry.attributes.position;
    var i = 0;
    for (; i < p.count; i++) {
      if ("xy" == x) {
        tree.push([p.getX(i), p.getY(i)]);
      } else {
        tree.push([p.getX(i), p.getZ(i)]);
      }
    }
  } else {
    i = 0;
    for (; i < this.geometry.vertices.length; i++) {
      var axisPoint = this.geometry.vertices[i];
      if ("xy" == x) {
        tree.push([axisPoint.x, axisPoint.y]);
      } else {
        tree.push([axisPoint.x, axisPoint.z]);
      }
    }
  }
  if (!tree.length) {
    return null;
  }
  if (tree.length > 1) {
    var s = [0, 0];
    i = 0;
    for (; i < tree.length; i++) {
      var t = tree[i];
      s[0] |= !!t[0];
      s[1] |= !!t[1];
    }
    if (!s[0] || !s[1]) {
      return null;
    }
  }
  var l = [];
  if (l.push(tree), style && 0 != style.length) {
    i = 0;
    for (; i < style.length; i++) {
      var cell = [style[i][0], style[i][1], style[i][2], style[i][3]];
      l.push(cell);
    }
  }
  var c;
  var args = new polylabel(l);
  return c = "xy" == x ? this.localToWorld(new THREE.Vector3(args[0], args[1], 0)) : this.localToWorld(new THREE.Vector3(args[0], 0, args[1])), this.getRayCastPosition(c);
};
THREE.Mesh.prototype.getAvaliableLabelPosition = function(self, x, arr) {
  var add = function(array, args, p) {
    var length = array[0];
    var offset = args[0];
    var min = array[1];
    var num = args[1];
    var len = Math.max(length, p.l);
    if (len > offset || len > p.r) {
      return false;
    }
    var i = Math.min(offset, p.r);
    if (i < length || i < p.l) {
      return false;
    }
    var val = Math.max(min, p.t);
    if (val > num || val > p.b) {
      return false;
    }
    var pos = Math.min(num, p.b);
    return !(pos < min || pos < p.t);
  };
  var draw = function(e, data, size, p, x) {
    var w = size.x;
    var j = "xy" == x ? size.y : size.z;
    var instrNode = [w - p[0], j - p[1]];
    var keypath = [w + p[0], j + p[1]];
    var i = 0;
    for (; i < e.length; i++) {
      var offset = e[i];
      var rowToRemove = data[i];
      var left = offset.x;
      var top = "xy" == x ? offset.y : offset.z;
      var width = rowToRemove[0] / 2;
      var height = rowToRemove[1] / 2;
      if (add(instrNode, keypath, {
        l : left - width,
        t : top - height,
        r : left + width,
        b : top + height
      })) {
        return true;
      }
    }
    return false;
  };
  this.updateMatrixWorld();
  var m = new THREE.Matrix4;
  if (m.getInverse(this.matrixWorld), arr && arr.length && arr.length % 4) {
    return THING.Utils.error("The hole points number must arrange by 4"), null;
  }
  var list = [];
  var i = 0;
  for (; i < arr.length; i = i + 4) {
    var field = Utils.parseVector3(arr[i]).applyMatrix4(m);
    var b = Utils.parseVector3(arr[i + 1]).applyMatrix4(m);
    var a = Utils.parseVector3(arr[i + 2]).applyMatrix4(m);
    var d = Utils.parseVector3(arr[i + 3]).applyMatrix4(m);
    field = [field.x, field.y];
    b = [b.x, b.y];
    a = [a.x, a.y];
    d = [d.x, d.y];
    list.push([field, b, a, d]);
  }
  var p = [];
  var vdrops = [];
  i = 0;
  for (; i < self.length; i++) {
    var mnu = self[i];
    var errorMargin = mnu[0] / 2;
    var rhoMax = mnu[1] / 2;
    if (0 != errorMargin && 0 != rhoMax) {
      var v = this.getLabelPosition(list, x);
      if (!v) {
        break;
      }
      var size = v.clone();
      size.applyMatrix4(m);
      if (!draw(p, self, size, [errorMargin, rhoMax], x)) {
        vdrops.push(v);
        p.push(size);
      }
      var expected = size.x;
      var r = "xy" == x ? size.y : size.z;
      field = [expected - errorMargin, r - rhoMax];
      b = [expected + errorMargin, r - rhoMax];
      a = [expected + errorMargin, r + rhoMax];
      d = [expected - errorMargin, r + rhoMax];
      list.push([field, b, a, d]);
    }
  }
  return vdrops;
};
THREE.Mesh.prototype.getRayCastPosition = function(e) {
  this.updateMatrixWorld();
  var pos = e.clone();
  this.worldToLocal(pos);
  var tmp = pos.clone();
  tmp.z--;
  var username = function(t, pos, p) {
    t.localToWorld(pos);
    t.localToWorld(p);
    var result = new THREE.Vector3;
    result.subVectors(p, pos);
    result.normalize();
    var a = e.clone();
    a.add(result.clone().multiplyScalar(-1e3));
    var ray = new THREE.Raycaster;
    ray.ray.origin.copy(a);
    ray.ray.direction.copy(result);
    var bottom = ray.intersectObjectForcible(t, true);
    if (!bottom.length) {
      return null;
    }
    return bottom[0].point;
  }(this, pos, tmp);
  if (username) {
    return username;
  }
};
THREE.LOD.prototype.setLevel = function(index) {
  if (!(index >= this.levels.length)) {
    var i = 0;
    for (; i < this.levels.length; i++) {
      this.levels[i].object.visible = false;
    }
    this.levels[index].object.visible = true;
  }
};
THREE.Raycaster.prototype._setFromCamera = function(width, depth, target, rect) {
  return void 0 === width && void 0 === depth ? (Ep.subVectors(rect, target.position), Ep.normalize(), this.set(target.position, Ep)) : (xp.x = width / rect.width * 2 - 1, xp.y = -depth / rect.height * 2 + 1, this.setFromCamera(xp, target)), this;
};
THREE.Raycaster.prototype.clone = function() {
  return new THREE.Raycaster(this.ray.origin.clone(), this.ray.direction.clone());
};
THREE.Raycaster.prototype._intersectObjectForcible = function(object, raycaster, intersects, recursive) {
  if (object.raycast(raycaster, intersects), true === recursive) {
    var n = object.children;
    var p = 0;
    var s = n.length;
    for (; p < s; p++) {
      this._intersectObjectForcible(n[p], raycaster, intersects, true);
    }
  }
};
THREE.Raycaster.prototype.intersectObjectForcible = function(statements, value, fromIndex) {
  var n = fromIndex || [];
  return this._intersectObjectForcible(statements, this, n, value), n.sort(function(a, b) {
    return a.distance - b.distance;
  }), n;
};
THREE.Raycaster.prototype.intersectEnsureVisibleObject = function(object, intersects, checked, index) {
  if (false !== object.ensureVisible(index) && (object.raycast(this, intersects), true === checked)) {
    var n = object.children;
    var p = 0;
    var s = n.length;
    for (; p < s; p++) {
      this.intersectEnsureVisibleObject(n[p], intersects, true, index);
    }
  }
};
THREE.Raycaster.prototype.intersectEnsureVisibleObjects = function(o, done, num) {
  var intersects = [];
  if (false === Array.isArray(o)) {
    return THING.Utils.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), intersects;
  }
  var k = 0;
  var t = o.length;
  for (; k < t; k++) {
    this.intersectEnsureVisibleObject(o[k], intersects, done, num);
  }
  return intersects.sort(function(a, b) {
    return a.distance - b.distance;
  }), intersects;
};
THREE.Raycaster.prototype.intersectCollisionObjects = function(chunksOrSource, options, suggestedVariableValueCallback) {
  var intersects = [];
  return function render(object, result, name, res, callbackFn) {
    if (false !== object.visible && object.layers.test(res.layers)) {
      object.raycast(result, name);
      var data = object.children;
      var i = 0;
      var tldCount = data.length;
      for (; i < tldCount; i++) {
        render(data[i], result, name, res);
      }
    }
  }(chunksOrSource, this, intersects, options), intersects.sort(ascSort), intersects;
};
THREE.Geometry.prototype.getVerticesCount = function() {
  return this.vertices.length;
};
THREE.Geometry.prototype.genFaceVertexUVs = function() {
  this.computeFaceNormals();
  this.computeVertexNormals();
  this.computeBoundingBox();
  var bounds = this.boundingBox.max;
  var c = this.boundingBox.min;
  var offset = new THREE.Vector2(0 - c.x, 0 - c.y);
  var xhair = new THREE.Vector2(bounds.x - c.x, bounds.y - c.y);
  var faces = this.faces;
  var ops = [];
  var i = 0;
  for (; i < faces.length; i++) {
    var v3 = this.vertices[faces[i].a];
    var c = this.vertices[faces[i].b];
    var v1 = this.vertices[faces[i].c];
    var tableN = new THREE.Vector2((v3.x + offset.x) / xhair.x, (v3.y + offset.y) / xhair.y);
    var cursorA = new THREE.Vector2((c.x + offset.x) / xhair.x, (c.y + offset.y) / xhair.y);
    var itemB = new THREE.Vector2((v1.x + offset.x) / xhair.x, (v1.y + offset.y) / xhair.y);
    ops.push([tableN, cursorA, itemB]);
  }
  i = 0;
  for (; i < this.faceVertexUvs.length; i++) {
    this.faceVertexUvs[i] = ops.concat();
  }
  this.uvsNeedUpdate = true;
  this.elementsNeedUpdate = true;
};
THREE.Scene.prototype.verticesCount = function() {
  var ret = 0;
  return this.traverse(function(data) {
    if (data.isMesh) {
      ret = ret + data.verticesCount();
    }
  }), ret;
};
THREE.AnimationMixer.prototype.isRunning = function(id) {
  var actions = this._actions;
  var nActions = this._nActiveActions;
  var i = 0;
  for (; i !== nActions; ++i) {
    var state = actions[i];
    if (id) {
      var port = state.getClip();
      if (port && id != port.name) {
        continue;
      }
    }
    if (state.isRunning()) {
      return true;
    }
  }
  return false;
};
THREE.AnimationMixer.prototype.log = function() {
  var stats = this.stats;
  var i = 0;
  for (; i < this._actions.length; i++) {
    var shot = this._actions[i];
    var allBox = shot.getClip();
    var n = shot.getEffectiveWeight();
    if (0 != n) {
      THING.Utils.log("action: [name: " + allBox.name + ", weight: " + n + "]");
    }
  }
  THING.Utils.log("action: " + stats.actions.inUse + "/" + stats.actions.total);
  THING.Utils.log("bindings: " + stats.bindings.inUse + "/" + stats.bindings.total);
  THING.Utils.log("controlInterpolants: " + stats.controlInterpolants.inUse + "/" + stats.controlInterpolants.total);
};
THREE.Material.prototype._isCloned = function() {
  return !!this._origin_material;
};
THREE.Material.prototype._getOriginal = function() {
  var e = this._origin_material;
  return e || this;
};
THREE.Material.prototype._getPrevMaterial = function() {
  var e = this._prev_material;
  return e || this._getOriginal();
};
THREE.Material.prototype._pushAndCloneSelf = function() {
  var lineComp = this.clone();
  return lineComp._origin_material = this._getOriginal(), lineComp._prev_material = this, lineComp;
};
THREE.Material.prototype._pop = function() {
  var sources = this.__materialsQueue__;
  if (sources && sources.length) {
    for (; sources.length;) {
      sources[sources.length - 1].dispose();
      sources.splice(sources.length - 1, 1);
    }
    if (!sources.length) {
      delete this.__materialsQueue__;
    }
  }
};
var Yp = THREE.Material.prototype.copy;
THREE.Material.prototype.copy = function(value) {
  return Yp.call(this, value), this.defines = void 0 !== value.defines ? JSON.parse(JSON.stringify(value.defines)) : void 0, this.isMeshStandardMaterial || this.defines && "" == this.defines.STANDARD && delete this.defines.STANDARD, this.__texture = value.__texture, this._replace_map = value._replace_map, this._replace_alphaMap = value._replace_alphaMap, this._origin_material = value._origin_material, this;
};
THREE.Material.prototype.getTextures = function() {
  var e = new Set;
  var j;
  for (j in this) {
    var txt = this[j];
    if (txt && txt.isTexture) {
      e.add(txt);
    }
  }
  return Array.from(e);
};
THREE.Box3.prototype.getIntersection = function(d) {
  var global_aabb = new THREE.Box3;
  return this.intersectsBox(d) && (global_aabb.min.x = Math.max(this.min.x, d.min.x), global_aabb.max.x = Math.min(this.max.x, d.max.x), global_aabb.min.y = Math.max(this.min.y, d.min.y), global_aabb.max.y = Math.min(this.max.y, d.max.y), global_aabb.min.z = Math.max(this.min.z, d.min.z), global_aabb.max.z = Math.min(this.max.z, d.max.z)), global_aabb;
};
THREE.Box3.prototype.expandByGeometry = function(obj, count) {
  return obj.boundingBox || obj.computeBoundingBox(), Pp.copy(obj.boundingBox), count && Pp.applyMatrix4(count), this.union(Pp), this;
};
THREE.Box3.prototype._setFromObject = function(obj, def, path) {
  var r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
  if (r) {
    this.makeEmpty();
  }
  obj.updateWorldMatrix(true, true);
  var matrix = this;
  obj.getWorldPosition(wp);
  var o = false;
  obj.traverse(function(object) {
    if (!def || false !== def(object)) {
      if (object.userData.forceBoundingBox) {
        object.getWorldPosition(Tp);
        if (path) {
          Tp.applyMatrix4(path);
        }
        matrix.expandByPoint(Tp);
        o = true;
      }
      var segment = object.userData.boundingBoxSize;
      if (segment) {
        var data = THING.Math.scaleVector(segment, .5);
        Tp.fromArray(THING.Math.negVector(data));
        Mp.fromArray(data);
        Pp.set(Tp, Mp);
        var a = {
          x : 0,
          y : 0,
          z : 0
        };
        var l = object.userData.boundingBoxPivot;
        if (l) {
          a.x = segment[0] * (l[0] - .5);
          a.y = segment[1] * (l[1] - .5);
          a.z = segment[2] * (l[2] - .5);
        }
        Pp.getBoundingPositions().forEach(function(vector) {
          vector.add(a);
          vector.applyMatrix4(object.matrixWorld);
          if (path) {
            vector.applyMatrix4(path);
          }
          matrix.expandByPoint(vector);
          o = true;
        });
      }
      var pos = object.geometry;
      if (pos) {
        if (path) {
          bp.multiplyMatrices(path, object.matrixWorld);
          matrix.expandByGeometry(pos, bp);
        } else {
          matrix.expandByGeometry(pos, object.matrixWorld);
        }
        o = true;
      }
    }
  });
  if (!o) {
    if (def && !def(obj)) {
      o = true;
    }
  }
  if (!o) {
    if (path) {
      wp.applyMatrix4(path);
    }
    this.expandByPoint(wp);
  }
  this.getSize(Cp);
  var delta = 1e-8;
  return 0 == Cp.x && (this.min.x -= delta, this.max.x += delta), 0 == Cp.y && (this.min.y -= delta, this.max.y += delta), 0 == Cp.z && (this.min.z -= delta, this.max.z += delta), this;
};
THREE.Box3.prototype.getBoundingPositions = function() {
  var a = this.min;
  var max = this.max;
  return [new THREE.Vector3(a.x, a.y, a.z), new THREE.Vector3(max.x, a.y, a.z), new THREE.Vector3(a.x, a.y, max.z), new THREE.Vector3(max.x, a.y, max.z), new THREE.Vector3(a.x, max.y, a.z), new THREE.Vector3(max.x, max.y, a.z), new THREE.Vector3(a.x, max.y, max.z), new THREE.Vector3(max.x, max.y, max.z)];
};
THREE.OrbitControls.prototype.setObject = function(object) {
  this.object = object;
};
THREE.OrbitControls.prototype.getObject = function() {
  return this.object;
};
THREE.OrbitControls.prototype.getPosition = function() {
  return this.object.position;
};
THREE.OrbitControls.prototype.setPosition = function(position) {
  this.object.position.copy(position);
};
THREE.OrbitControls.prototype.setTarget = function(value) {
  this.target.copy(value);
};
THREE.OrbitControls.prototype.getTarget = function() {
  return this.target;
};
THREE.OrbitControls.prototype.clone = function() {
  var scope = new THREE.OrbitControls(this.object, this.domElement);
  return scope.enabled = this.enabled, scope.target = this.target.clone(), scope.minDistance = this.minDistance, scope.maxDistance = this.maxDistance, scope.minZoom = this.minZoom, scope.maxZoom = this.maxZoom, scope.minPolarAngle = this.minPolarAngle, scope.maxPolarAngle = this.maxPolarAngle, scope.minAzimuthAngle = this.minAzimuthAngle, scope.maxAzimuthAngle = this.maxAzimuthAngle, scope.enableDamping = this.enableDamping, scope.dampingFactor = this.dampingFactor, scope.enableZoom = this.enableZoom, 
  scope.zoomSpeed = this.zoomSpeed, scope.zoomFactor = this.zoomFactor, scope.enableRotate = this.enableRotate, scope.rotateSpeed = this.rotateSpeed, scope.enablePan = this.enablePan, scope.panSpeed = this.panSpeed, scope.screenSpacePanning = this.screenSpacePanning, scope.keyPanSpeed = this.keyPanSpeed, scope.autoRotate = this.autoRotate, scope.autoRotateSpeed = this.autoRotateSpeed, scope.enableKeys = this.enableKeys, scope.target0 = this.target0.clone(), scope.position0 = this.position0.clone(), 
  scope.zoom0 = this.zoom0, scope;
};
THREE.EarthOrbitControls.prototype.setObject = function(object) {
  this.object = object;
};
THREE.EarthOrbitControls.prototype.getObject = function() {
  return this.object;
};
THREE.EarthOrbitControls.prototype.getPosition = function() {
  return this.object.position;
};
THREE.EarthOrbitControls.prototype.setPosition = function(position) {
  this.object.position.copy(position);
};
THREE.EarthOrbitControls.prototype.setTarget = function(value) {
  this.target.copy(value);
};
THREE.EarthOrbitControls.prototype.getTarget = function() {
  return this.target;
};
THREE.EarthOrbitControls.prototype.clone = function() {
  var scope = new THREE.EarthOrbitControls(this.object, this.domElement);
  return scope.enabled = this.enabled, scope.isEarth = this.isEarth, scope.target = this.target.clone(), scope.minDistance = this.minDistance, scope.maxDistance = this.maxDistance, scope.minZoom = this.minZoom, scope.maxZoom = this.maxZoom, scope.minPolarAngle = this.minPolarAngle, scope.maxPolarAngle = this.maxPolarAngle, scope.minAzimuthAngle = this.minAzimuthAngle, scope.maxAzimuthAngle = this.maxAzimuthAngle, scope.enableDamping = this.enableDamping, scope.dampingFactor = this.dampingFactor, 
  scope.enableZoom = this.enableZoom, scope.zoomSpeed = this.zoomSpeed, scope.zoomFactor = this.zoomFactor, scope.enableRotate = this.enableRotate, scope.rotateSpeed = this.rotateSpeed, scope.enablePan = this.enablePan, scope.panSpeed = this.panSpeed, scope.screenSpacePanning = this.screenSpacePanning, scope.keyPanSpeed = this.keyPanSpeed, scope.autoRotate = this.autoRotate, scope.autoRotateSpeed = this.autoRotateSpeed, scope.enableKeys = this.enableKeys, scope.target0 = this.target0.clone(), scope.position0 = 
  this.position0.clone(), scope.zoom0 = this.zoom0, scope._leftInteractive = this._leftInteractive, scope._keepTarget = this._keepTarget, scope.maxPitchAngle = this.maxPitchAngle, scope._minPolarAngle = this._minPolarAngle, scope._maxPolarAngle = this._maxPolarAngle, scope.standardRadius = this.standardRadius, scope.targetMaxOffset = this.targetMaxOffset, scope.panStander = this.panStander, scope.isDispatchEvent = this.isDispatchEvent, scope.enableZoomOnTarget = this.enableZoomOnTarget, scope._isCameraStatic = 
  this._isCameraStatic, Utils.mergeObject(scope.options, this.options), scope;
};
THREE.WebGLRenderer.prototype.getContext = function(parentActivityId) {
  return this.context;
};
THREE.ShaderChunk.map_fragment = ["", "#ifdef USE_MAP", "#ifdef USE_DIFFUSE_UV2", "vec4 texelColor = texture2D( map, vUv2 );", "#else", "vec4 texelColor = texture2D( map, vUv );", "#endif", "texelColor = mapTexelToLinear( texelColor );", "diffuseColor *= texelColor;", "#endif", ""].join("\n"), THREE.ShaderChunk.alphamap_fragment = ["", "#ifdef USE_ALPHAMAP", "#ifdef USE_ALPHAMAP_REVERSE", "diffuseColor.a *= 1.0 - texture2D( alphaMap, vAlphaUV).g;", "#else", "diffuseColor.a *= texture2D( alphaMap, vAlphaUV).g;", 
"#endif", "#endif", ""].join("\n"), THREE.ShaderChunk.uv2_pars_fragment = ["", "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP ) || defined (USE_DIFFUSE_UV2)", "varying vec2 vUv2;", "#endif", "#ifdef USE_ALPHAMAP", "varying vec2 vAlphaUV;", "#endif", "#ifdef USE_EMISSIVEMAP", "varying vec2 vEmissiveUV;", "#endif", ""].join("\n"), THREE.ShaderChunk.uv2_pars_vertex = ["", "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP ) || defined( USE_ALPHA_UV2 ) || defined (USE_DIFFUSE_UV2)", "attribute vec2 uv2;", 
"#endif", "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP ) || defined (USE_DIFFUSE_UV2)", "varying vec2 vUv2;", "#endif", "#ifdef USE_ALPHA_UV3", "#if defined(USE_ALPHAMAP) || defined(USE_EMISSIVEMAP)", "attribute vec2 uv3;", "#endif", "#endif", "#ifdef USE_ALPHA_UV4", "#if defined(USE_ALPHAMAP) || defined(USE_EMISSIVEMAP)", "attribute vec2 uv4;", "#endif", "#endif", "#ifdef USE_ALPHAMAP", "varying vec2 vAlphaUV;", "uniform mat3 uvTransform1;", "#endif", "#ifdef USE_EMISSIVEMAP", "varying vec2 vEmissiveUV;", 
"uniform mat3 uvTransform2;", "#ifdef USE_EMISSIVE_AROUND_UV", "attribute vec2 uv8;", "#endif", "#endif", ""].join("\n"), THREE.ShaderChunk.uv2_vertex = ["#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP ) || defined (USE_DIFFUSE_UV2)", "#if defined(USE_DIFFUSE_UV2) && defined(USE_MAP)", "vUv2 = (uvTransform * vec3(uv2, 1.0)).xy;", "#else", "vUv2 = uv2;", "#endif", "#endif", "#ifdef USE_ALPHAMAP", "vAlphaUV = (uvTransform1 * vec3(uv, 1.0)).xy;", "#ifdef USE_ALPHA_UV2", "vAlphaUV = (uvTransform1 * vec3(uv2, 1.0)).xy;", 
"#endif", "#ifdef USE_ALPHA_UV3", "vAlphaUV = (uvTransform1 * vec3(uv3, 1.0)).xy;", "#endif", "#ifdef USE_ALPHA_UV4", "vAlphaUV = (uvTransform1 * vec3(uv4, 1.0)).xy;", "#endif", "#endif", "#ifdef USE_EMISSIVEMAP", "#ifndef USE_EMISSIVETRANSFORM", "mat3 emissiveTransform = uvTransform;", "#else", "mat3 emissiveTransform = uvTransform2;", "#endif", "vEmissiveUV = (emissiveTransform * vec3(uv, 1.0)).xy;", "#ifdef USE_EMISSIVE_AROUND_UV", "vEmissiveUV = (emissiveTransform * vec3(uv8, 1.0)).xy;", "#endif", 
"#ifdef USE_ALPHA_UV2", "vEmissiveUV = (emissiveTransform * vec3(uv2, 1.0)).xy;", "#endif", "#ifdef USE_ALPHA_UV3", "vEmissiveUV = (emissiveTransform * vec3(uv3, 1.0)).xy;", "#endif", "#ifdef USE_ALPHA_UV4", "vEmissiveUV = (emissiveTransform * vec3(uv4, 1.0)).xy;", "#endif", "#endif", ""].join("\n");
["sprite", "basic"].forEach(function(type) {
  var parser = THREE.ShaderLib[type];
  parser.vertexShader = parser.vertexShader.replace("#include <clipping_planes_pars_vertex>", "\n\t#include <clipping_planes_pars_vertex>\n\t#ifdef USE_GPUPICKER\n\t\tuniform float baseId;\n\t\tvarying vec4 worldId;\n\t#endif\n\t");
  parser.vertexShader = parser.vertexShader.replace("#include <fog_vertex>", "\n\t#include <fog_vertex>\n\t#ifdef USE_GPUPICKER\n\t\tvec3 a = fract(vec3(1.0/255.0, 1.0/(255.0*255.0), 1.0/(255.0*255.0*255.0)) * baseId);\n\t\ta -= a.xxy * vec3(0.0, 1.0/255.0, 1.0/255.0);\n\t\tworldId = vec4(a,1);\n\t#endif\n\t");
  parser.fragmentShader = parser.fragmentShader.replace("#include <clipping_planes_pars_fragment>", "\n\t#include <clipping_planes_pars_fragment>\n\t#ifdef USE_GPUPICKER\n\t\tvarying vec4 worldId;\n\t#endif\n\t");
  parser.fragmentShader = parser.fragmentShader.replace("gl_FragColor.rgb = gl_FragColor.rgb * ( 1.0 - highlightIntensity ) + highlightColor * highlightIntensity;", "\n\tgl_FragColor.rgb = gl_FragColor.rgb * ( 1.0 - highlightIntensity ) + highlightColor * highlightIntensity;\n\t\n\t#ifdef USE_GPUPICKER\n\t\tgl_FragColor = worldId;\n\t#endif\n\t");
  parser.fragmentShader = parser.fragmentShader.replace("#include <clipping_planes_fragment>", "\n\t#ifdef USE_MAP\n\t\t#ifdef USE_UV_DISCARD\n\t\t\tif (vUv.x < 0. || vUv.x > 1. || vUv.y < 0. || vUv.y > 1.) discard;\n\t\t#endif\n\t#endif\n\t#include <clipping_planes_fragment>\n\t");
}), THREE.ShaderChunk.aomap_fragment = "\n\t#ifdef USE_AOMAP\n\t\t#ifdef WALL_AO\n\t\t\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity * 0.5 + 1.5;\n\t\t#else\n\t\t\t#ifdef FLOOR_AO\n\t\t\t\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.25;\n\t\t\t#else\n\t\t\t\t#ifdef USE_RGBAOMAP\n\t\t\t\t\tvec3 ambientOcclusion = ( texture2D( aoMap, vUv2 ).rgb - 1.0 ) * aoMapIntensity * 1.6 + 1.7;\n\t\t\t\t#else\n\t\t\t\t\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity * 1.6 + 1.7;\n\t\t\t\t#endif\n\t\t\t#endif\n\t\t#endif\n\t\t// reflectedLight.indirectDiffuse *= ambientOcclusion;\n\t\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t\t#endif\n\t#else\n\t\tfloat ambientOcclusion = 1.4;\n\t#endif\n", 
THREE.ShaderChunk.emissivemap_fragment = "\n\t#ifdef USE_EMISSIVEMAP\n\n\t\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveUV );\n\n\t\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\n\t\ttotalEmissiveRadiance *= emissiveColor.rgb;\n\n\t#endif\n\n\t#ifdef STANDARD\n\t\ttotalEmissiveRadiance = vec3(0.0,0.0,0.0);\n\t\tvec3 newEmissiveColor = emissive;\n\t\t#ifdef USE_EMISSIVEMAP\n\t\t\tnewEmissiveColor = emissive * emissiveColor.rgb;\n\t\t\t#ifdef USE_SIDE_EMISSIVE\n\t\t\t\tvec3 emissiveUp = vec3(0., 1., 0.);\n\t\t\t\t#ifdef ENV_QUATERNION\n\t\t\t\t\tvec4 emissiveQuat = vec4(0., 0., 0., 1.);\n\t\t\t\t\temissiveQuat.x = -envQuaternion.x;\n\t\t\t\t\temissiveQuat.y = -envQuaternion.y;\n\t\t\t\t\temissiveQuat.z = -envQuaternion.z;\n\t\t\t\t\temissiveQuat.w = envQuaternion.w;\n\t\t\t\t\temissiveUp = applyQuaternion(emissiveUp, emissiveQuat);\n\t\t\t\t#endif\n\t\t\t\tnewEmissiveColor *= newEmissiveColor * (1. - abs(dot( inverseTransformDirection( normal, viewMatrix ), emissiveUp )));\n\t\t\t#endif\n\t\t#endif\n\t#endif\n", 
THREE.ShaderChunk.encodings_fragment = ["gl_FragColor = linearToOutputTexel( gl_FragColor );", "#if defined(STANDARD) || defined(USE_AOMAP)", "gl_FragColor.rgb *= ambientOcclusion;", "#elif defined(FLOOR_AO)", "gl_FragColor.rgb *= 1.2;", "#endif", "#ifdef STANDARD", "gl_FragColor.rgb += newEmissiveColor;", "#endif"].join("\n"), THREE.ShaderChunk.tonemapping_fragment = ["#if defined( TONE_MAPPING ) && defined(STANDARD)", "gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );", "#endif"].join("\n");
["basic", "physical"].forEach(function(type) {
  var parser = THREE.ShaderLib[type];
  parser.vertexShader = parser.vertexShader.replace("#include <fog_pars_vertex>", "\n\t#include <fog_pars_vertex>\n\t#ifdef USE_VISIBLE\n\t\tattribute float vis;\n\t#endif\n\t#ifdef USE_3DTILESEXTENT\n\t\tattribute float id;\n\t\tuniform sampler2D batchTexture;\n\t\tuniform vec2 batchTextureStep;\n\t\tvarying vec4 tile_featureColor;\n\t#endif\n\t");
  parser.vertexShader = parser.vertexShader.replace("#include <fog_vertex>", "\n\t#include <fog_vertex>\n\t#ifdef USE_VISIBLE\n\t\tgl_Position *= vis;\n\t#endif\n\t#ifdef USE_3DTILESEXTENT\n\t\tfloat stepX = batchTextureStep.x; \n\t\tfloat centerX = batchTextureStep.y; \n\t\tvec2 st = vec2(centerX + (id * stepX), 0.5); \n\t\tvec4 featureProperties = texture2D(batchTexture, st);\n\t\tfloat show = ceil(featureProperties.a); \n\t\tgl_Position *= show;\n\t\ttile_featureColor = featureProperties; \n\t#endif\n\t");
  parser.fragmentShader = parser.fragmentShader.replace("#include <clipping_planes_pars_fragment>", "\n\t#include <clipping_planes_pars_fragment>\n\t#ifdef USE_3DTILESEXTENT\n\t\tvarying vec4 tile_featureColor;\n\t#endif\n\t");
  parser.fragmentShader = parser.fragmentShader.replace("#include <dithering_fragment>", "\n\t#include <dithering_fragment>\n\t#ifdef USE_3DTILESEXTENT\n\t\tgl_FragColor = vec4( gl_FragColor.r * tile_featureColor.r, gl_FragColor.g * tile_featureColor.g, gl_FragColor.b * tile_featureColor.b, gl_FragColor.a * tile_featureColor.a );\n\t#endif\n\t");
}), THREE.BufferGeometry.prototype.getVerticesCount = function() {
  return this.attributes.position.count;
};
THREE.BufferGeometry.prototype.addAttribute = function(name, index) {
  return index && index.isBufferAttribute || index && index.isInterleavedBufferAttribute ? "index" === name ? (THING.Utils.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(index), this) : this.setAttribute(name, index) : (THING.Utils.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2])));
};
THREE.BufferAttribute.prototype.setDynamic = function(fn) {
  return this.setUsage(true === fn ? THREE.DynamicDrawUsage : THREE.StaticDrawUsage), this;
};
THREE.BufferGeometry.prototype.computeBoundingBox = function() {
  if (null === this.boundingBox) {
    this.boundingBox = new THREE.Box3;
  } else {
    this.boundingBox.makeEmpty();
  }
  var attribute = this.attributes.position;
  if (void 0 !== attribute) {
    var l = this.index ? this.index.array : null;
    var i = this.drawRange.start;
    var cell_amount = this.drawRange.count != 1 / 0 ? this.drawRange.count : l ? l.length : attribute.count;
    for (; i < cell_amount; i++) {
      if (l) {
        _p.fromBufferAttribute(attribute, l[i]);
      } else {
        _p.fromBufferAttribute(attribute, i);
      }
      this.boundingBox.expandByPoint(_p);
    }
  }
};
THREE.WebGLRenderer.prototype.saveInfo = function() {
  var options = {};
  return options.memory = {
    geometries : this.info.memory.geometries,
    textures : this.info.memory.textures
  }, options.render = {
    frame : this.info.render.frame,
    calls : this.info.render.calls,
    triangles : this.info.render.triangles,
    points : this.info.render.points,
    lines : this.info.render.lines
  }, options.programs = this.info.programs.slice(0), options.autoReset = this.info.autoReset, this.info.external && (options.external = {
    byteLengths : {
      textures : this.info.external.byteLengths.textures,
      buffers : this.info.external.byteLengths.buffers
    }
  }), options;
};
THREE.WebGLRenderer.prototype.loadInfo = function(self) {
  try {
    this.info.memory = {
      geometries : self.memory.geometries,
      textures : self.memory.textures
    };
    this.info.render = {
      frame : self.render.frame,
      calls : self.render.calls,
      triangles : self.render.triangles,
      points : self.render.points,
      lines : self.render.lines
    };
    this.info.programs = self.programs.slice(0);
    this.info.autoReset = self.autoReset;
    this.info.external = {
      byteLengths : {
        textures : self.external.byteLengths.textures,
        buffers : self.external.byteLengths.buffers
      }
    };
  } catch (ChangeSetName) {
    console.error("WebGLInfo error in fromJSON, content =", ChangeSetName);
  }
};
HTMLElement.prototype._getStyleTransform = function() {
  var t = this.style.transform;
  return t || "none" != (t = getComputedStyle(this, false).transform) ? t : "";
};
HTMLDivElement.prototype._setVisible = function(el) {
  var style = this.style;
  if (el) {
    if ("visible" != style.visibility) {
      style.visibility = "visible";
    }
    if ("block" != style.display) {
      style.display = "block";
    }
  } else {
    if ("hidden" != style.visibility) {
      style.visibility = "hidden";
    }
    if ("none" != style.display) {
      style.display = "none";
    }
  }
};
HTMLDivElement.prototype._isVisible = function() {
  return "hidden" != this.style.visibility && "none" != this.style.display;
};
HTMLDivElement.prototype._getWorldScale = function() {
  var lineage = [];
  var parent = this;
  for (; parent; parent = parent.parentElement) {
    lineage.push(parent);
  }
  lineage = lineage.reverse();
  var redu = [1, 1];
  return lineage.forEach(function(canCreateDiscussions) {
    var self = canCreateDiscussions._getStyleTransform();
    if (self) {
      var iterSpace;
      if (self.includes("scale")) {
        var left = self.indexOf("scale");
        iterSpace = function(input) {
          if (input.includes(",")) {
            var values = Utils.scanf(input, "scale(%f, %f)");
            return isNaN(values[0]) ? null : [Utils.parseNumber(values[0], 1), Utils.parseNumber(values[1], 1)];
          }
          if (values = Utils.scanf(input, "scale(%f)"), isNaN(values)) {
            return null;
          }
          var middleband = Utils.parseNumber(values, 1);
          return [middleband, middleband];
        }(self.substring(left));
      } else {
        if (self.includes("matrix")) {
          var r = self.indexOf("matrix");
          iterSpace = function(resource) {
            var values = Utils.scanf(resource, "matrix(%f, 0, 0, %f, 0, 0)");
            return isNaN(values[0]) || isNaN(values[1]) ? null : [Utils.parseNumber(values[0], 1), Utils.parseNumber(values[1], 1)];
          }(self.substring(r));
        }
      }
      if (iterSpace) {
        redu[0] *= iterSpace[0];
        redu[1] *= iterSpace[1];
      }
    }
  }), redu;
};
var Qp = function() {
  function self(name) {
    r(this, self);
  }
  return self.prototype.init = function() {
    this.eyeTween = null;
    this.targetTween = null;
    this.upTween = null;
    this._flying = false;
  }, self.prototype._lookAt = function(name) {
    var pos = Utils.parseVector3(name);
    if (pos) {
      this.controller.target.set(pos.x, pos.y, pos.z);
      this.controller.object.lookAt(this.controller.target);
    }
  }, self.prototype.updateFollowingObject = function() {
    var ToolClass = this;
    var state = this.followingObject;
    var self = state.params;
    var _oldStartWalking = self.flyStop;
    var _pastWalkAnim = self.flying;
    var parentHear = self.flyComplete;
    var obj = state.object;
    if (obj instanceof BaseObject) {
      if (!obj.visible || obj.destroyed) {
        return _oldStartWalking && _oldStartWalking(), void this.app.camera.stopFollowingObject();
      }
      obj = state.centerPos || obj.boundingBox.center;
    }
    obj = Utils.parseVector3(obj);
    var a = state.dir.clone();
    if ("earth" === this.app.camera.mode) {
      a = state.object.selfToWorld(a);
      a = THING.Utils.parseVector3(a);
    } else {
      a.add(obj);
    }
    var p = Utils.parseVector3(this.camera.target);
    var position = Utils.parseVector3(this.camera.position);
    var duration = state.speed;
    p = p.lerp(obj, duration / 10);
    position = position.lerp(a, duration / 10);
    this.object.node.position.copy(position);
    this._lookAt(p, function() {
      return ToolClass.static;
    });
    if (_pastWalkAnim) {
      _pastWalkAnim();
    }
    var diff = p.distanceTo(obj);
    var target = position.distanceTo(a);
    if (diff < 1e-4 && target < 1e-4) {
      if (parentHear) {
        parentHear();
      }
      if (self.once) {
        this.app.camera.stopFollowingObject();
      }
    }
    this.app.needUpdate = true;
  }, self.prototype.updateLookingObject = function() {
    var child = this.lookingObject;
    if (child instanceof BaseObject) {
      if (child.destroyed) {
        return void this.app.camera.lookAt(null);
      }
      child = child.boundingBox.center;
    }
    var startGrayscale = Utils.parseVector3(child);
    var grayscale = Utils.parseVector3(this.camera.target).lerp(startGrayscale, .1);
    this.camera.target = grayscale.toArray();
  }, self.prototype.getBoundingBox = function(obj, o) {
    var points = o.boundingBox;
    return points || (points = obj.visible ? obj.boundingBox : obj.getBoundingBox(false, false)), points;
  }, self.prototype.getFlyPos = function(options) {
    var meta;
    var state = this.object;
    var pos = Utils.parseNumber3(options.position);
    var data = null;
    var i = [0, 0, 0];
    var index = options.target || options.object;
    if (index) {
      var end = options.offset;
      var len = options.worldOffset;
      var text = options.xAngle;
      var value = options.yAngle;
      var params = options.distance || options.radius;
      var readOnlyFn = options.radiusFactor;
      if (index.isBaseObject || index.isGroup) {
        var node;
        data = index;
        var min = options.center;
        if (i = min ? (min = Utils.parseVector3(min)).toArray() : (node = this.getBoundingBox(data, options)).center || i, Utils.isNull(text) && Utils.isNull(value)) {
          if (end) {
            marker = data.worldToSelf(i);
            end = THING.Math.addVector(marker, end);
            end = data.selfToWorld(end, true);
          } else {
            if (len) {
              end = THING.Math.addVector(i, len);
            } else {
              var m = options.time || 1;
              var g = false;
              if (params) {
                g = true;
              }
              var message = [];
              node = node || options.boundingBox || this.getBoundingBox(data, options);
              message.push(node.getWorldPosition({
                yAngle : 45,
                xAngle : 45,
                radius : node.radius,
                distance : params,
                radiusFactor : readOnlyFn,
                ignoreScale : g,
                boundingBox : node
              }));
              if (m > 1) {
                message.push(node.getWorldPosition({
                  yAngle : 45,
                  xAngle : 135,
                  radius : node.radius,
                  distance : params,
                  radiusFactor : readOnlyFn,
                  ignoreScale : g,
                  boundingBox : node
                }));
                message.push(node.getWorldPosition({
                  yAngle : 45,
                  xAngle : 225,
                  radius : node.radius,
                  distance : params,
                  radiusFactor : readOnlyFn,
                  ignoreScale : g,
                  boundingBox : node
                }));
                message.push(node.getWorldPosition({
                  yAngle : 45,
                  xAngle : 315,
                  radius : node.radius,
                  distance : params,
                  radiusFactor : readOnlyFn,
                  ignoreScale : g,
                  boundingBox : node
                }));
              }
              var offset = 0;
              var c1 = Utils.parseVector3(state.position);
              var wMin = c1.distanceTo(Utils.parseVector3(message[offset]));
              var i = offset + 1;
              for (; i < message.length; i++) {
                var c2 = Utils.parseVector3(message[i]);
                var w = c1.distanceTo(c2);
                if (w < wMin) {
                  wMin = w;
                  offset = i;
                }
              }
              pos = message[offset];
              end = [0, 0, 0];
            }
          }
        } else {
          end = end || data.getOffsetPosition({
            yAngle : text,
            xAngle : value,
            distance : params,
            radiusFactor : readOnlyFn
          });
          var marker = data.worldToSelf(i);
          end = THING.Math.addVector(marker, end);
          end = data.selfToWorld(end, true);
        }
        pos = pos || [0, 0, 0];
        if (state.projectionType == kkkk.Perspective) {
          pos[0] += end[0];
          pos[1] += end[1];
          pos[2] += end[2];
        } else {
          pos[1] += end[1];
        }
      } else {
        if (Utils.isArray(index)) {
          if (i = index, !pos) {
            if (end = end || len, Utils.isArray(end) || Utils.isNumber(end)) {
              pos = THING.Math.addVector(index, end);
            } else {
              params = params || 10;
              var self = Utils.parseVector3(index);
              if (self) {
                if (value || text) {
                  value = Utils.parseValue(value, 0);
                  text = Utils.parseValue(text, 0);
                  pos = self.getDirectionFromAngles(text, value, params).toArray();
                } else {
                  pos = self.getDirectionFromPosition(state.node.position, params).toArray();
                }
              }
            }
          }
          pos = pos || state.position;
        } else {
          THING.Utils.error("getFlyPos() failed, due to object or target is neither BaseObject type nor position");
        }
      }
    }
    if (options.autoFixUp) {
      var up = options.up;
      if (up) {
        up = THING.Math.normalizeVector(up);
      } else {
        var system = this;
        var targetVec = new THREE.Vector3(0, 1, 0);
        var P = (meta = data || system.app.level.current) ? meta.isCampus ? meta : meta.parents.query(".Campus")[0] : null;
        if (P) {
          targetVec.applyQuaternion(THING.Utils.parseQuaternion(P.worldAngles));
          targetVec.normalize();
          up = targetVec.toArray();
        }
      }
    }
    return {
      obj : data,
      eyePos : pos,
      lookAtPos : i,
      up : up
    };
  }, self.prototype.flyTo = function(options) {
    if ((options = options || {}).isBaseObject) {
      options = {
        object : options,
        time : 2e3
      };
    }
    var time = Utils.parseValue(options.time, 2e3);
    var value = Utils.parseValue(options.lerp || options.lerpType, TWEEN.Easing.Linear.None);
    var step = Utils.parseValue(options.upLerp, value);
    var easing = Utils.parseValue(options.positionLerp, value);
    var i = Utils.parseValue(options.targetLerp, value);
    var to = options.flyStart;
    var w = options.flyStop;
    var u = options.flying;
    var start = options.flyComplete;
    if (Utils.parseValue(options.keepDirection, false)) {
      var object = options.cameraTarget || options.target;
      if (object) {
        return options.object = object, options.radius = options.radius || 2 * object.boundingBox.radius, options.speed = time / 1e3, options.enableRotate = true, options.enableZoom = true, options.once = true, void this.followObject(options);
      }
    }
    var pg = this.getFlyPos(options);
    var p = pg.eyePos;
    var vCameraPos = pg.lookAtPos;
    if (!this._stopping) {
      if (this.stopFlying(), p && vCameraPos) {
        this._flying = true;
        if (to) {
          to();
        }
        var position = {
          x : this.object.node.position.x,
          y : this.object.node.position.y,
          z : this.object.node.position.z
        };
        var target = {
          x : p[0],
          y : p[1],
          z : p[2]
        };
        var obj = {
          x : this.controller.target.x,
          y : this.controller.target.y,
          z : this.controller.target.z
        };
        var imageStart = {
          x : vCameraPos[0],
          y : vCameraPos[1],
          z : vCameraPos[2]
        };
        var self = this;
        var defaultValue = options.customFlying;
        if (defaultValue && Utils.isFunction(defaultValue)) {
          defaultValue({
            object : options.object,
            forward : self.direction,
            from : position,
            to : target,
            lookatFrom : obj,
            lookatTo : imageStart,
            time : time,
            complete : function() {
              self._flying = false;
              if (start) {
                start();
              }
            }
          });
        } else {
          if (this.eyeTween = (new TWEEN.Tween(position)).to(target, time).easing(easing).onUpdate(function() {
            self.object.position = [this._object.x, this._object.y, this._object.z];
          }).start(), this.targetTween = (new TWEEN.Tween(obj)).to(imageStart, time).easing(i).onUpdate(function() {
            self.object.target = [this._object.x, this._object.y, this._object.z];
            if (u) {
              u();
            }
          }).onStop(function() {
            if (w) {
              w();
            }
          }).onComplete(function() {
            self._flying = false;
            if (start) {
              start();
            }
          }).start(), pg.up) {
            var obj = {
              x : this.object.node.up.x,
              y : this.object.node.up.y,
              z : this.object.node.up.z
            };
            var imageStart = {
              x : pg.up[0],
              y : pg.up[1],
              z : pg.up[2]
            };
            this.upTween = (new TWEEN.Tween(obj)).to(imageStart, time).easing(step).onStop(function() {
              self.object.up = pg.up;
            }).onUpdate(function() {
              self.object.up = [this._object.x, this._object.y, this._object.z];
            }).start();
          }
        }
      } else {
        if (start) {
          start();
        }
      }
    }
  }, self.prototype.stopRotating = function() {
    this.object._stopRotating();
  }, self.prototype.stopFlying = function() {
    this._flying = false;
    this._stopping = true;
    this.object.stopRotating();
    this.stopFollowingObject();
    if (this.eyeTween) {
      this.eyeTween.stop();
      this.eyeTween = null;
    }
    if (this.targetTween) {
      this.targetTween.stop();
      this.targetTween = null;
    }
    if (this.upTween) {
      this.upTween.stop();
      this.upTween = null;
    }
    this._stopping = false;
  }, self.prototype.movePath = function(source) {
    var _this = this;
    this.stopFlying();
    var complete = source.complete;
    source.complete = function() {
      _this._flying = false;
      var resultsSubject = _this.camera.cameraObject.node.getForwardPosition(_this.camera.distance);
      _this.camera.target = resultsSubject.toArray();
      if (complete) {
        complete();
      }
    };
    this._flying = true;
    if (source.start) {
      source.start.call(_this, ev);
    }
    BaseObject.prototype.movePath.call(this.object, source);
  }, self.prototype.rotateAround = function(options) {
    var _this = this;
    var target = (options = options || {}).target || options.object;
    options.target = target || this.camera.target;
    this.stopFlying();
    if (options.rotateStart) {
      options.rotateStart();
    }
    this.lookAt(options.target);
    var complete = options.complete;
    options.complete = function(t) {
      options.stop();
      if (complete) {
        complete();
      }
      if (options.rotateComplete) {
        options.rotateComplete();
      }
    };
    options.stop = function(num) {
      _this.lookAt(null);
      _this.camera.curOrbit.enabled = true;
      _this.camera.resume({
        rotate : true,
        pan : true,
        zoom : true
      });
      if (options.rotateComplete) {
        options.rotateComplete();
      }
    };
    options.update = function(type) {
      _this.camera.curOrbit.update();
    };
    this.camera.curOrbit.enabled = false;
    this.camera.disable({
      rotate : true,
      pan : true,
      zoom : true
    });
    BaseObject.prototype.rotateAround.call(this.object, options);
  }, self.prototype.rotate = function(args) {
    var y = this.camera.distance;
    var targetVec = Utils.parseVector3(this.camera.direction);
    var invLinkQ = Utils.parseQuaternion(args);
    targetVec.applyQuaternion(invLinkQ);
    targetVec.normalize();
    var vector = targetVec.clone();
    vector.multiplyScalar(y);
    vector.add(Utils.parseVector3(this.camera.position));
    this.camera.target = vector.toArray();
  }, self.prototype.followObject = function(options) {
    if ((options = options || {}).isBaseObject) {
      options = {
        object : options
      };
    }
    var object = options.object;
    if (object) {
      this.stopFollowingObject();
      var v1;
      var alpha = options.alpha;
      var regex = options.beta;
      var u = options.distance || options.radius || this.camera.distance;
      var title = Utils.parseVector3(options.offset || [0, 0, 0]);
      var v0 = Utils.parseVector3(options.worldOffset);
      var catSpeed = options.speed || 1;
      var pagesToDisplay = options.centerPos;
      if (v0) {
        v1 = v0;
      } else {
        if (v1 = new THREE.Vector3, alpha || regex) {
          alpha = alpha || 0;
          regex = regex || 0;
          v1 = Utils.parseVector3(THING.Math.directionFromAlphaBeta(alpha, regex));
        } else {
          var atomC = Utils.parseVector3(this.camera.target);
          var v3 = Utils.parseVector3(this.camera.position);
          v1.subVectors(v3, atomC);
        }
        v1.normalize();
        v1.multiplyScalar(u);
        v1.add(title);
      }
      var readOnlyFn = options.flyStart;
      if (readOnlyFn) {
        readOnlyFn();
      }
      this.followingObject = {
        object : object,
        dir : v1,
        speed : catSpeed,
        params : options,
        centerPos : pagesToDisplay
      };
    }
  }, self.prototype.stopFollowingObject = function() {
    if (this.followingObject) {
      var def = this.followingObject.params;
      this.followingObject = null;
      var extendWidget = def.flyStop;
      if (extendWidget) {
        extendWidget();
      }
    }
  }, self.prototype.lookAt = function(obj) {
    return obj && (Utils.isArray(obj) || obj.isBaseObject) ? (this.lookingObject = obj, true) : (this.lookingObject = null, false);
  }, self.prototype.setTarget = function(name) {
    var anno = this;
    this._lookAt(name, function() {
      return anno.object.static;
    });
  }, self.prototype.isFlying = function() {
    return !!this._flying || !!this.followingObject;
  }, self.prototype.onAdd = function(data) {
    this.object = data;
    this.app = this.object.app;
    this.init();
  }, self.prototype.onRemove = function() {
  }, self.prototype.onUpdate = function() {
    if (this.followingObject) {
      this.updateFollowingObject();
    } else {
      if (this.lookingObject) {
        this.updateLookingObject();
      }
    }
  }, n(self, [{
    key : "controller",
    get : function() {
      return this.object.controller;
    }
  }, {
    key : "camera",
    get : function() {
      return this.object.app.camera;
    }
  }]), self;
}();
Zp = function() {
  function init(options) {
    r(this, init);
    var i = new THREE.TextureLoader;
    var data = options.image;
    var url = options.backgroundImage;
    var completeTitleOpacity = options.opacity || .8;
    var spriteMaterial = null;
    if (data) {
      spriteMaterial = new THREE.SpriteMaterial({
        map : i.load(data),
        opacity : completeTitleOpacity,
        transparent : true
      });
    }
    var image = null;
    this.spriteBg = null;
    if (url) {
      image = new THREE.SpriteMaterial({
        map : i.load(url),
        opacity : completeTitleOpacity,
        transparent : true
      });
    }
    this._position = null;
    this._uiPosition = [1, 1];
    Object.defineProperty(this, "position", {
      get : function() {
        return this._position;
      },
      set : function(value) {
        if (Utils.isNumber(value)) {
          switch(this._position = value, this._position) {
            case brightness0.LeftTop:
              this._uiPosition = [-1, -1];
              break;
            case brightness0.RightTop:
              this._uiPosition = [1, -1];
              break;
            case brightness0.LeftBottom:
              this._uiPosition = [-1, 1];
              break;
            case brightness0.RightBottom:
              this._uiPosition = [1, 1];
          }
        }
        return this._position;
      }
    });
    if (null != options.position) {
      this.position = options.position;
    } else {
      this.position = brightness0.RightBottom;
    }
    this.size = options.size || 50;
    this.offset = options.offset || [0, 0];
    if (spriteMaterial) {
      this.sprite = new THREE.Sprite(spriteMaterial);
      this.sprite.scale.set(this.size, this.size, 1);
    }
    if (null != image) {
      this.spriteBg = new THREE.Sprite(image);
      this.spriteBg.scale.set(this.size, this.size, 1);
    }
  }
  return init.prototype.getRotation = function() {
    var r = this.app.renderCamera.rotation;
    switch(r.order) {
      case "XYZ":
        return -r.z;
      case "YXZ":
        return -r.y;
    }
    return -r.z;
  }, init.prototype.onUpdate = function() {
    var startPt = this.app.mainUI.getRenderPosition(this._uiPosition, [this.size, this.size]);
    if (null != this.spriteBg) {
      this.spriteBg.position.set(startPt[0] + this.offset[0], startPt[1] + this.offset[1], -10);
    }
    if (this.sprite) {
      this.sprite.position.set(startPt[0] + this.offset[0], startPt[1] + this.offset[1], -10);
      this.sprite.material.rotation = this.getRotation();
    }
  }, init.prototype.onAdd = function(value) {
    this.app = value;
    if (null != this.spriteBg) {
      this.app.mainUI.scene2D.add(this.spriteBg);
    }
    if (this.sprite) {
      this.app.mainUI.scene2D.add(this.sprite);
    }
  }, init.prototype.onRemove = function() {
    if (null != this.spriteBg) {
      this.app.mainUI.scene2D.remove(this.spriteBg);
    }
    if (this.sprite) {
      this.app.mainUI.scene2D.remove(this.sprite);
    }
  }, init;
}();
Kp = function() {
  function self(val) {
    r(this, self);
    this._controls = null;
  }
  return self.prototype.onResize = function() {
  }, self.prototype.onUpdate = function() {
    if (this._controls) {
      this._controls.update(this.app._deltaTime);
      this.app.needUpdate = true;
    }
  }, self.prototype.onAdd = function(view) {
    this.app = view;
    view.camera.inputEnabled = false;
    if (!this._controls) {
      this._controls = new THREE.FreeMouseControls(view.renderCamera);
      this._controls.movementSpeed = .25;
    }
    this._controls.enabled = true;
  }, self.prototype.onRemove = function() {
    this.app.camera.inputEnabled = true;
    if (this._controls) {
      this._controls.dispose();
      this._controls.enabled = false;
      this._controls = null;
    }
  }, self;
}();
function $p(doc) {
  return doc instanceof xi ? doc.getNodes() : Array.isArray(doc) ? (THING.Utils.warn("[WalkControl/WalkButtronControl] please set collision objects by selector object, instead of object3D array."), doc) : doc;
}
var ed = new THREE.Vector3;
var WalkControl = function() {
  function render(options) {
    r(this, render);
    this._controls = null;
    options = options || {};
    this.walkSpeed = void 0 === options.walkSpeed ? .02 : options.walkSpeed;
    this.turnSpeed = void 0 === options.turnSpeed ? .25 : options.turnSpeed;
    this.jumpSpeed = void 0 === options.jumpSpeed ? 3 : options.jumpSpeed;
    this.enableKeyRotate = void 0 !== options.enableKeyRotate && options.enableKeyRotate;
    this.useGravity = void 0 === options.useGravity || options.useGravity;
    this.gravity = options.gravity ? options.gravity : 9.8;
    this.eyeHeight = void 0 === options.eyeHeight ? 1.6 : options.eyeHeight;
    this._groundObjects = void 0 === options.groundObjects ? void 0 : $p(options.groundObjects);
    this.useCollision = void 0 !== options.useCollision && options.useCollision;
    this._collisionObjects = void 0 === options.collisionObjects ? void 0 : $p(options.collisionObjects);
    this._downRaycaster = new THREE.Raycaster;
    this._downRaycaster.ray.direction.set(0, -1, 0);
    this._forwardRaycaster = new THREE.Raycaster;
    this._fallSpeed = 0;
    this._prevCameraAdjustNear = false;
    this._cameraChangeStarted = false;
    this._prevDistance = 10;
  }
  return render.prototype._notifyCameraEvent = function(type) {
    var options = this.app.camera;
    this.app.trigger(type, {
      position : options.position,
      target : options.target
    });
  }, render.prototype.onResize = function() {
  }, render.prototype.onUpdate = function() {
    var options = this.app.renderCamera;
    var t = false;
    if (this.useCollision) {
      this._forwardRaycaster.ray.origin.copy(options.position);
      this._forwardRaycaster.ray.origin.y -= this.eyeHeight / 2;
      var B = this._controls.getMoveDirection();
      this._forwardRaycaster.ray.direction.copy(B).normalize();
      var nodes = this._forwardRaycaster.intersectObjects(this._collisionObjects, true);
      if ((nodes = nodes.filter(function(typeStatement) {
        return typeStatement.object && !typeStatement.object.isSky && !typeStatement.object.isEdgeWireframe;
      })).length > 0 && nodes[0].distance < .5) {
        t = true;
      }
    }
    if (this._controls && (this._controls.movementSpeed = t ? 0 : this.walkSpeed, this._controls.rotateSpeed = this.turnSpeed, this._controls.enableKeyRotate = this.enableKeyRotate, this._controls.update() ? (this._cameraChangeStarted ? this._notifyCameraEvent("cameraChange") : (this._cameraChangeStarted = true, this._notifyCameraEvent("cameraChangeStart")), options.getWorldDirection(ed).multiplyScalar(this._prevDistance), ed.add(options.position), this.app.camera.target = ed.toArray([])) : this._cameraChangeStarted && 
    (this._cameraChangeStarted = false, this._notifyCameraEvent("cameraChangeEnd")), this.app.needUpdate = true), this.useGravity) {
      this._downRaycaster.ray.direction.copy(options.up).multiplyScalar(-1).normalize();
      this._downRaycaster.ray.origin.copy(options.position);
      var end = this._downRaycaster.ray.direction;
      var nodes = this._downRaycaster.intersectObjects(this._groundObjects, true);
      if ((nodes = nodes.filter(function(typeStatement) {
        return typeStatement.object && !typeStatement.object.isSky && !typeStatement.object.isEdgeWireframe;
      })).length < 1) {
        this._fallSpeed += .0166 * this.gravity;
        var s = ed.copy(end).multiplyScalar(Math.min(.0166 * this._fallSpeed, this.eyeHeight - .001));
        options.position.add(s);
      } else {
        var distance = nodes[0].distance;
        if (distance <= this.eyeHeight + .01 && this._fallSpeed >= 0) {
          this._fallSpeed = 0;
          var l = ed.copy(end).multiplyScalar(distance - this.eyeHeight);
          options.position.add(l);
        } else {
          this._fallSpeed += .0166 * this.gravity;
          var u = ed.copy(end).multiplyScalar(Math.min(.0166 * this._fallSpeed, this.eyeHeight - .001));
          options.position.add(u);
        }
      }
    }
  }, render.prototype.onAdd = function(options) {
    this.app = options;
    this._prevCameraAdjustNear = options.camera.autoAdjustNear;
    options.camera.autoAdjustNear = false;
    this._prevDistance = options.camera.distance;
    options.camera.inputEnabled = false;
    if (!this._controls) {
      this._controls = new THREE.FreeMouseControls(options.renderCamera, options.mainDomElement);
      this._controls.movementSpeed = this.walkSpeed;
      this._controls.rotateSpeed = this.turnSpeed;
      this._controls.enableFly = false;
    }
    this._controls.enabled = true;
    this._groundObjects = this._groundObjects || options.query(".Ground || .Floor").getNodes();
    this._collisionObjects = this._collisionObjects || [this.app.scene];
    this._jumpBind = function(event) {
      if (32 == event.keyCode) {
        this.jump();
      }
    }.bind(this);
    window.addEventListener("keydown", this._jumpBind, false);
  }, render.prototype.onRemove = function() {
    var view = this.app;
    view.camera.inputEnabled = true;
    if (this._controls) {
      this._controls.dispose();
      this._controls.enabled = false;
      this._controls = null;
    }
    this._groundObjects = null;
    this._collisionObjects = null;
    view.camera.autoAdjustNear = this._prevCameraAdjustNear;
    window.removeEventListener("keydown", this._jumpBind, false);
  }, render.prototype.jump = function() {
    if (0 == this._fallSpeed) {
      this._fallSpeed -= this.jumpSpeed;
    }
  }, n(render, [{
    key : "groundObjects",
    set : function(x) {
      this._groundObjects = void 0 !== x ? $p(x) : [];
    }
  }, {
    key : "collisionObject",
    set : function(x) {
      this._collisionObjects = void 0 !== x ? $p(x) : [];
    }
  }]), render;
}();
id = function(e) {
  function f(row) {
    return r(this, f), s(this, e.call(this, row));
  }
  return o(f, e), f.prototype.onResize = function() {
  }, f.prototype.onAdd = function(options) {
    this.app = options;
    this._prevCameraAdjustNear = options.camera.autoAdjustNear;
    options.camera.autoAdjustNear = false;
    options.camera.inputEnabled = false;
    if (!this._controls) {
      this._controls = new THREE.FreeControls(options.renderCamera, options.mainDomElement);
      this._controls.movementSpeed = this.walkSpeed;
      this._controls.rotateSpeed = this.turnSpeed;
      this._controls.enableFly = false;
      options.renderCamera.rotation.x = 0;
    }
    this._controls.enabled = true;
    this._groundObjects = this._groundObjects || options.query(".Ground || .Floor").getNodes();
    this._collisionObjects = this._collisionObjects || [this.app.scene];
    this._createWalkButton();
  }, f.prototype.onRemove = function() {
    var view = this.app;
    view.camera.inputEnabled = true;
    if (this._controls) {
      this._controls.enabled = false;
      this._controls = null;
    }
    this._groundObjects = null;
    this._collisionObjects = null;
    view.camera.autoAdjustNear = this._prevCameraAdjustNear;
    this._removeWalkButton();
  }, f.prototype._setMoveState = function(action, state) {
    if (this._controls) {
      this._controls.moveState[action] = state;
      this._controls.updateMovementVector();
    }
  }, f.prototype._setRotate = function(c, angle) {
    if (this._controls) {
      this._controls.rotateDelta.set(c, angle);
    }
  }, f.prototype._createWalkButton = function() {
    function move(event) {
      var px = event.changedTouches[0].pageX;
      var offset = event.changedTouches[0].pageY;
      var v1x = px - width;
      var start = offset - height;
      var dx = px - oldX;
      var x = offset - size;
      var w = parseFloat(self.width) / 2;
      if (self._getDistance(dx, x) <= w) {
        o.style.left = v1x + "px";
        o.style.top = start + "px";
      } else {
        var coords = self._getNewPos(w, self._getRadian(dx, x));
        o.style.left = coords[0] + oldX - width + "px";
        o.style.top = coords[1] + size - height + "px";
      }
      if ((expired = Math.abs(dx) > Math.abs(x) ? dx > 0 ? "right" : "left" : x > 0 ? "back" : "forward") !== self._moveState) {
        self._setMoveState(self._moveState, 0);
        self._setMoveState(expired, 1);
        self._moveState = expired;
      }
    }
    var _this = this.app;
    var self = this;
    if (!(_this.domElement.getElementsByClassName("walkbutton").length > 0)) {
      this._walkButtonDom = _this.domElement.appendChild(document.createElement("div"));
      this._walkButtonDom.className = "walkbutton";
      this._walkButtonDom.style.cssText = "position: absolute;right: 0;bottom: 0;width: 0;height: 0;border-radius: 50%;box-sizing: border-box;z-index: 1000;background: #f0f0f0;";
      var oldX;
      var size;
      var width;
      var height;
      var expired;
      var o = this._walkButtonDom.appendChild(document.createElement("div"));
      o.style.cssText = "width: 46%;height: 46%;border-radius: 50%;overflow: hidden;position: absolute;top: 27%;left: 27%;border-radius: 50%;background: #003A9E;";
      this._resizeWalkButton();
      self._moveState = "";
      this._walkButtonDom.addEventListener("touchstart", function(event) {
        event.preventDefault();
        oldX = event.changedTouches[0].pageX;
        size = event.changedTouches[0].pageY;
        width = event.changedTouches[0].pageX - o.offsetLeft;
        height = event.changedTouches[0].pageY - o.offsetTop;
        document.body.addEventListener("touchmove", move, false);
      });
      document.addEventListener("touchend", function() {
        document.body.removeEventListener("touchmove", move, false);
        o.style.left = "27%";
        o.style.top = "27%";
        self._setMoveState(self._moveState, 0);
        self._moveState = "";
      });
    }
  }, f.prototype._removeWalkButton = function() {
    var eiFrame = this.app.domElement.getElementsByClassName("walkbutton");
    if (eiFrame.length > 0) {
      eiFrame[0].parentNode.removeChild(eiFrame[0]);
    }
  }, f.prototype._getDistance = function(y, x) {
    return Math.sqrt(Math.pow(y, 2) + Math.pow(x, 2));
  }, f.prototype._getRadian = function(v, a) {
    return Math.atan2(a, v);
  }, f.prototype._getNewPos = function(a, x) {
    var b = [];
    return b.push(Math.cos(x) * a), b.push(Math.sin(x) * a), b;
  }, f.prototype._getwindowOrientation = function() {
    return 180 == window.orientation || 0 == window.orientation || 90 != window.orientation && -90 != window.orientation && void 0;
  }, f.prototype._resizeWalkButton = function() {
    this.width = this._getwindowOrientation() ? .2 * this.app.domElement.offsetWidth : .2 * this.app.domElement.offsetHeight;
    this._walkButtonDom.style.width = this.width + "px";
    this._walkButtonDom.style.height = this.width + "px";
    this._walkButtonDom.style.right = .5 * this.width + "px";
    this._walkButtonDom.style.bottom = .3 * this.width + "px";
  }, f;
}(WalkControl);
rd = function() {
  function init(params) {
    r(this, init);
    this.parseParam(params);
    this._enable = true;
    this.scene = new THREE.Scene;
    this.camera = null;
    this.sprite = null;
    this.raycaster = new THREE.Raycaster;
    this.mouse = new THREE.Vector2;
    this.ratio = 2;
    this.mainAspect = 1;
    this.miniDom = null;
    this.renderTarget = null;
    this.inited = false;
    this.create();
  }
  return init.prototype.parseParam = function(options) {
    this.app = options.app;
    this._opacity = options.opacity || .7;
    this._posIndex = options.position || options.posIndex || 0;
    this.bIcon = options.bIcon || true;
    this.width = options.width || 150;
    this.height = options.height || this.width;
    this._scale = options.scale || 1;
    this.closeBtnImg = options.closeBtnImg || "http://www.thingjs.com/static/images/minimap2.png";
    this.cameraViewImg = options.cameraViewImg || "http://www.thingjs.com/static/images/minimap1.png";
    this.cameraCenterImg = options.cameraCenterImg || "http://www.thingjs.com/static/images/minimap0.png";
    this.center = {};
    var global_aabb = this.app.root.boundingBox.toBox();
    var x = (global_aabb.max.x + global_aabb.min.x) / 2;
    var y = (global_aabb.max.z + global_aabb.min.z) / 2;
    if (options.sceneCenter ? (this.center.x = options.sceneCenter[0], this.center.y = options.sceneCenter[1]) : options.center ? (this.center.x = options.center[0], this.center.y = options.center[1]) : (this.center.x = x, this.center.y = y), this.angle = options.angle || 0, this.canMoushWheel = options.mousewheel, this.ground = options.ground, this.hasClose = options.hasClose, !this.ground) {
      var j = 0;
      for (; j < this.app.root.campuses.length; j++) {
        var nodeToRoot = this.app.root.campuses[j].ground;
        if (nodeToRoot) {
          this.ground = nodeToRoot.node.children;
          break;
        }
      }
    }
    this.bTranslate = options.bTranslate || false;
  }, init.prototype.init2d = function() {
    function update() {
      _this.raycaster.setFromCamera(_this.mouse, _this.camera);
      var wstones = _this.raycaster.intersectObjects(_this.ground[0].children, true);
      if (wstones.length > 0) {
        var end = wstones[0].point;
        if (_this.bTranslate) {
          var point = _this.app.camera.cameraObject.forward;
          point = new THREE.Vector3(point[0], 0, point[2]);
          var x = (new THREE.Vector3(end.x, 0, end.z)).normalize();
          var t = point.dot(x);
          var from = (new THREE.Vector3).crossVectors(point, x).y;
          var a = 0;
          a = t > 0 ? from < 0 ? 90 * -(from + 1) - 90 : 90 + 90 * (1 - from) : 90 * from;
          var observeMe = _this.app.create({
            type : "Thing",
            position : [end.x, _this.app.camera.position[1], end.z]
          });
          _this.app.camera.flyTo({
            time : 1e3,
            object : observeMe,
            xAngle : 45,
            yAngle : a,
            zAngle : 0
          });
        } else {
          _this.app.camera.flyTo({
            time : 1e3,
            position : [end.x, _this.app.camera.position[1], end.z],
            target : _this.app.camera.target
          });
        }
      }
    }
    if (this.miniDom = this.app.domElement.appendChild(document.createElement("div")), this.miniDom.className = "minimap", this.miniDom.style.position = "absolute", this.miniDom.style.cssText = "position: absolute;width:" + this.width + ";height:" + this.height + ";border: 5px solid rgba(255, 255, 255, 0.8);border-radius: 3px;display: block;box-sizing: border-box;overflow:hidden", this.miniDom.style.zIndex = 1e3, this.hasClose) {
      var e = this.miniDom.appendChild(document.createElement("img"));
      e.className = "minimap_closeBtn";
      e.style.position = "absolute";
      e.style.width = this.width / 5;
      e.style.right = "1px";
      e.style.top = "1px";
      e.src = this.closeBtnImg;
      var _this = this;
      e.addEventListener("click", function() {
        close = true;
        _this.enable = false;
      });
    }
    var i = this.miniDom.appendChild(document.createElement("img"));
    i.className = "minimap_cameraView";
    i.style.position = "absolute";
    i.src = this.cameraViewImg;
    var r = this.miniDom.appendChild(document.createElement("img"));
    r.className = "minimap_cameraCenter";
    r.src = this.cameraCenterImg;
    i.style.width = "40px";
    i.style.height = "30px";
    this.miniDom.onmousedown = function(e) {
      var ev = e || event;
      ev.cancelBubble = true;
      ev.stopPropagation();
    };
    this.miniDom.onmousemove = function(e) {
      var ev = e || event;
      ev.cancelBubble = true;
      ev.stopPropagation();
    };
    this.miniDom.onmousewheel = function(e) {
      var ev = e || event;
      ev.cancelBubble = true;
      ev.stopPropagation();
    };
    if (this.canMoushWheel) {
      this.miniDom.addEventListener("mousewheel", function(event) {
        _this.scale += event.wheelDelta > 0 ? .1 : -.1;
      }, false);
    }
    this.miniDom.addEventListener("mousedown", function(event) {
      if (0 === event.button) {
        _this.mouse.x = event.clientX / (_this.miniDom.clientWidth + 10) * 2 - 1;
        _this.mouse.y = -event.clientY / (_this.miniDom.clientWidth + 10) * 2 + 1;
        update();
        _this.miniDom.onmousemove = function(event) {
          _this.mouse.x = event.clientX / (_this.miniDom.clientWidth + 10) * 2 - 1;
          _this.mouse.y = -event.clientY / (_this.miniDom.clientWidth + 10) * 2 + 1;
          update();
        };
        _this.miniDom.onmouseup = function() {
          _this.miniDom.onmousemove = null;
          _this.miniDom.onmouseup = null;
        };
      }
    }, false);
    _this = this;
  }, init.prototype.init3d = function() {
    this.init2d();
    var global_aabb = this.app.root.boundingBox.toBox();
    var h = global_aabb.max.x > global_aabb.max.z ? global_aabb.max.x : global_aabb.max.z;
    var maxh = Math.abs(global_aabb.min.x) > Math.abs(global_aabb.min.z) ? Math.abs(global_aabb.min.x) : Math.abs(global_aabb.min.z);
    var s = h > maxh ? h : maxh;
    s = s * (1 / this.scale);
    this.camera = new THREE.OrthographicCamera(-s, s, s, -s, -1e4, 1e4);
    this.camera.position.set(this.center.x, 100, this.center.y);
    this.camera.up = (new THREE.Vector3(0, 0, -1)).applyEuler(new THREE.Euler(0, this.angle * Math.PI / 180, 0, "XYZ"));
    this.camera.lookAt(new THREE.Vector3(this.center.x, -1, this.center.y));
    var canvas = this.app.domElement;
    this.mainAspect = canvas.clientWidth / canvas.clientHeight;
    this.ratio = canvas.clientWidth / s;
    var s__3365 = s;
    var width = 8 * s__3365 < 256 ? 8 * s__3365 : 256;
    var height = 8 * (s * this.mainAspect) < 256 * this.mainAspect ? 8 * s__3365 : 256 * this.mainAspect;
    this.renderTarget = new THREE.WebGLRenderTarget(width, height, {
      minFilter : THREE.LinearFilter,
      magFilter : THREE.LinearFilter,
      generateMipmaps : false,
      format : THREE.RGBAFormat
    });
    var spriteMaterial = new THREE.SpriteMaterial({
      map : this.renderTarget.texture,
      transparent : true,
      opacity : this._opacity
    });
    this.sprite = new THREE.Sprite(spriteMaterial);
    this.setMiniRect();
    this.update();
    var viewer_size = this;
    window.onresize = function() {
      viewer_size.mainAspect = canvas.clientWidth / canvas.clientHeight;
      viewer_size.ratio = canvas.clientWidth / s;
      viewer_size.setMiniRect();
    };
    this.inited = true;
  }, init.prototype.create = function() {
    if (!this.inited) {
      this.init3d();
      this.scene.add(this.camera);
      this.camera.add(this.sprite);
    }
  }, init.prototype.setMiniRect = function() {
    function showResultNear(range, text, event, i) {
      highlighted_option.miniDom.style.top = range;
      highlighted_option.miniDom.style.left = text;
      highlighted_option.miniDom.style.bottom = event;
      highlighted_option.miniDom.style.right = i;
    }
    this.miniDom.style.width = this.width + "px";
    this.miniDom.style.height = this.height + "px";
    var highlighted_option = this;
    var r = this.width / (.5 * this.ratio);
    var w = r * this.mainAspect;
    this.sprite.scale.set(r, w, 1);
    var v;
    var y;
    var x = this.camera.right;
    var start = this.camera.left;
    switch(this._posIndex) {
      case 0:
        v = start + r / 2;
        y = start + w / 2;
        showResultNear("0px", "0px", null, null);
        break;
      case 2:
        v = start + r / 2;
        y = x - w / 2;
        showResultNear(null, "0px", "0px", null);
        break;
      case 1:
        v = x - r / 2;
        y = start + w / 2;
        showResultNear("0px", null, null, "0px");
        break;
      case 3:
        v = x - r / 2;
        y = x - w / 2;
        showResultNear(null, null, "0px", "0px");
    }
    this.sprite.position.set(v, -y, 0);
  }, init.prototype.update = function() {
    var config = this.app.lighting;
    var options = this.app.lighting;
    options.mainLight.intensity = 0;
    options.secondaryLight.intensity = 0;
    options.tertiaryLight.intensity = 0;
    this.app.lighting = options;
    var hex = this.app.scene.background;
    this.app.scene.background = null;
    this.app.renderer.setClearColor(0, 0);
    this.app.renderer.setRenderTarget(this.renderTarget);
    this.app.renderer.clear();
    this.app.renderer.render(this.app.scene, this.camera);
    this.app.lighting = config;
    this.app.scene.background = hex;
  }, init.prototype.destroy = function() {
    var patchLen = this.scene.children.length;
    if (0 != patchLen) {
      if (patchLen > 0) {
        var i = 0;
        for (; i < patchLen; i++) {
          this.scene.remove(this.scene.children[i]);
        }
      }
      this.camera = null;
      this.sprite = null;
      if (null != this.miniDom) {
        this.app.domElement.removeChild(this.miniDom);
        this.miniDom = null;
      }
    }
  }, init.prototype.render = function() {
    if (this.miniDom) {
      if (this._enable) {
        this.miniDom.style.display = "block";
        var oOverflow = this;
        if (this.miniDom.childNodes.forEach(function(builderID) {
          builderID.style.display = oOverflow.bIcon ? "block" : "none";
        }), null != this.camera && null != this.renderTarget) {
          var autoClear = this.app.renderer.autoClear;
          this.app.renderer.autoClear = false;
          this.app.renderer.setRenderTarget(null);
          this.app.renderer.render(this.scene, this.camera);
          this.app.renderer.autoClear = autoClear;
          var pos1 = this.app.camera.position;
          var p = new THREE.Vector3(pos1[0], pos1[1], pos1[2]);
          if (0 != this.angle) {
            var b = new THREE.Vector3(this.center.x, p.y, this.center.y);
            var offset = p.sub(b);
            offset.applyEuler(new THREE.Euler(0, -this.angle * Math.PI / 180, 0, "XYZ"));
            offset.add(b);
            p.copy(offset);
          }
          var source = this.transToMinimapCoord(p).x;
          var value = this.transToMinimapCoord(p).y;
          this.setImage(source, value, this.app.camera.position[1]);
          var r = this.app.camera.camera.rotation;
          var input = "YXZ" == r.order ? r.y : r.z;
          var mirror = (document.getElementsByClassName("minimap_cameraCenter")[0], document.getElementsByClassName("minimap_cameraView")[0]);
          var h = 0;
          h = input >= 0 ? input / Math.PI * 180 : 180 * (2 - Math.abs(input) / Math.PI);
          mirror.style.transform = "rotate(" + (-h + this.angle) + "deg)";
          mirror.style.transformOrigin = "50% 100%";
        }
      } else {
        this.miniDom.style.display = "none";
      }
    }
  }, init.prototype.transToMinimapCoord = function(p) {
    var height;
    var half;
    half = height = this.width / 2;
    var y;
    var step;
    var i = height / ((this.camera.right - this.camera.left) / 2);
    return p.hasOwnProperty("x") ? (y = p.x - this.center.x, step = p.z - this.center.y) : (y = p[0] - this.center.x, step = p[2] - this.center.y), {
      x : y >= 0 ? height - i * y : height + i * Math.abs(y),
      y : step >= 0 ? half - i * step : half + i * Math.abs(step)
    };
  }, init.prototype.setImage = function(x, width, pos) {
    var w = (pos > 80 ? pos - 80 : 0) * (1 / (220 / 30)) + 15;
    if (w > 30) {
      w = 30;
    }
    var slideCounter = document.getElementsByClassName("minimap_cameraCenter")[0];
    var $maskbottom = document.getElementsByClassName("minimap_cameraView")[0];
    var height = w;
    if (x >= w / 2 && x <= this.width - w / 2 && width >= w / 2) {
      this.width;
    }
    slideCounter.style.position = "absolute";
    slideCounter.style.width = w + "px";
    slideCounter.style.height = height + "px";
    slideCounter.style.right = x - w / 2 + "px";
    slideCounter.style.bottom = width - height + "px";
    $maskbottom.style.right = x - 20 + "px";
    $maskbottom.style.bottom = width - height / 2 + "px";
  }, n(init, [{
    key : "scale",
    set : function(v) {
      this._scale = v;
      this.destroy();
      this.inited = false;
      this.create();
    },
    get : function() {
      return this._scale;
    }
  }, {
    key : "opacity",
    set : function(value) {
      this._opacity = value;
      this.sprite.material.opacity = this._opacity;
    },
    get : function() {
      return this._opacity;
    }
  }, {
    key : "posIndex",
    set : function(v) {
      this._posIndex = v;
      this.setMiniRect();
    },
    get : function() {
      return this._posIndex;
    }
  }, {
    key : "enable",
    set : function(v) {
      this._enable = v;
    },
    get : function() {
      return this._enable;
    }
  }]), init;
}();
nd = function() {
  function f(param) {
    r(this, f);
    this.minimap = null;
    this.param = param;
  }
  return f.prototype.onAdd = function(name) {
    if (null != this.minimap) {
      this.onRemove();
    }
    if (!this.param.app) {
      this.param.app = name;
    }
    this.minimap = new rd(this.param);
  }, f.prototype.onRemove = function() {
    if (this.minimap) {
      this.minimap.destroy();
    }
  }, f.prototype.onUpdate = function() {
    if (this.minimap) {
      this.minimap.render();
    }
  }, f;
}();
LookAtControl = function() {
  function init() {
    r(this, init);
    this.app = null;
    this.object = null;
    this._targetObject = null;
    this._target = new THREE.Vector3;
  }
  return init.prototype.onAdd = function(options) {
    this.app = options.app;
    this.object = options;
  }, init.prototype.onRemove = function() {
    this.app = null;
    this.object = null;
    this._targetObject = null;
  }, init.prototype.onUpdate = function() {
    return this.object.node.updateWorldMatrix(true, false), this.object.node.lookAt(this._target), this._targetObject && this._target.fromArray(this._targetObject.position), true;
  }, n(init, [{
    key : "target",
    set : function(v) {
      if (v) {
        if (v.isBaseObject) {
          this._targetObject = v;
          this._target.fromArray(v.position);
        } else {
          this._targetObject = null;
          this._target.fromArray(v);
        }
      }
    },
    get : function() {
      return this._targetObject || this._target.toArray();
    }
  }]), init;
}();
sd = new THREE.Matrix4, ad = new THREE.Vector3(0, 0, 0);
ld = new THREE.Vector3(0, 1, 0);
ud = function() {
  function update(options) {
    r(this, update);
    this.app = null;
    this.object = null;
    this._targetObject = null;
    this._target = new THREE.Vector3;
    options = options || {};
    this._alpha = options.alpha || 45;
    this._beta = options.beta || 45;
    this._radius = options.radius || 30;
    this._dirty = true;
  }
  return update.prototype.onAdd = function(options) {
    this.app = options.app;
    this.object = options;
  }, update.prototype.onRemove = function() {
    this.app = null;
    this.object = null;
    this._targetObject = null;
  }, update.prototype.onUpdate = function() {
    return this._dirty && this._updateLocalTransform(), true;
  }, update.prototype._updateLocalTransform = function() {
    var vector = this.object.node.position;
    vector.fromArray(THING.Math.directionFromAlphaBeta(this._alpha, this._beta));
    vector.normalize().multiplyScalar(this._radius);
    var q = this.object.node.quaternion;
    var ret = sd.lookAt(ad, vector, ld);
    q.setFromRotationMatrix(ret);
    this._dirty = false;
  }, n(update, [{
    key : "alpha",
    set : function(v) {
      this._alpha = v;
      this._dirty = true;
    },
    get : function() {
      return this._alpha;
    }
  }, {
    key : "beta",
    set : function(v) {
      this._beta = v;
      this._dirty = true;
    },
    get : function() {
      return this._beta;
    }
  }, {
    key : "radius",
    set : function(value) {
      this._radius = value;
      this._dirty = true;
    },
    get : function() {
      return this._radius;
    }
  }]), update;
}();
cd = function() {
  function f(params) {
    r(this, f);
    this.params = params;
    this.draggable = true;
    if (params) {
      this.draggable = Utils.parseValue(params.draggable, true);
    }
  }
  return f.prototype.init = function() {
    function onMouseMove() {
      var songsHeaders = self.app.camera.screenToWorld(self.app.domElement.clientWidth / 2, self.app.domElement.clientHeight / 2);
      self.cameraTarget.position = songsHeaders;
    }
    var self = this;
    var vals = this.params;
    if (this.cameraTarget = function(that) {
      var validationVM = 2;
      var val = 1218267;
      var url = null;
      if (!that) {
        return null;
      }
      var v = that.size;
      var current = that.color;
      var m = that.url;
      if (null == m) {
        return null;
      }
      url = m;
      if (null != v) {
        validationVM = v;
      }
      if (null != current) {
        val = current;
      }
      var oRemind = app.create({
        type : "Marker",
        offset : [0, 8, 0],
        size : validationVM,
        keepSize : true,
        url : url,
        useSpriteMaterial : false,
        angles : [90, 0, 0]
      });
      return oRemind.style.alwaysOnTop = true, oRemind.style.color = val, oRemind;
    }(vals), this.cameraTarget) {
      onMouseMove();
      var i = false;
      var pos1 = null;
      var n = false;
      THINGdebounce(document).on("mousedown.ctctrl", function(event) {
        if (2 == event.button) {
          n = true;
        }
      });
      THINGdebounce(document).on("mouseup.ctctrl", function(event) {
        if (2 == event.button && (n = false), i = false, self.app.camera.enablePan = true, self.app.camera.enableRotate = true, self.cameraTarget.style.color = "#1296db", pos1) {
          var mouseRayEnd = new THREE.Vector3(pos1[0], pos1[1], pos1[2]);
          var globalBonePosition = (new THREE.Vector3(self.cameraTarget.position[0], self.cameraTarget.position[1], self.cameraTarget.position[2])).clone().sub(mouseRayEnd);
          self.app.camera.position = [self.app.camera.position[0] + globalBonePosition.x, self.app.camera.position[1] + globalBonePosition.y, self.app.camera.position[2] + globalBonePosition.z];
          self.app.camera.target = self.cameraTarget.position;
          pos1 = null;
        }
      });
      THINGdebounce(document).on("mousemove.ctctrl", function(event) {
        if (i) {
          self.cameraTarget.position = self.app.camera.screenToWorld(event.pageX, event.pageY);
        }
      });
      this.cameraTarget.on("mouseenter", function() {
        if (1 == self.draggable) {
          self.cameraTarget.style.color = "#FE7F0B";
        }
      });
      this.cameraTarget.on("mouseleave", function() {
        if (!(1 != self.draggable || i)) {
          self.cameraTarget.style.color = "#1296db";
        }
      });
      this.cameraTarget.on("mousedown", function() {
        if (1 == self.draggable) {
          i = true;
          self.app.camera.enablePan = false;
          self.app.camera.enableRotate = false;
          self.cameraTarget.style.color = "#FE7F0B";
          pos1 = self.cameraTarget.position;
        }
      });
      this.app.on("update", function(canCreateDiscussions) {
        if (n) {
          onMouseMove();
        }
      });
    }
  }, f.prototype.onAdd = function(value) {
    this.app = value;
    this.init();
  }, f.prototype.onRemove = function() {
    THINGdebounce(document).off(".ctctrl");
    if (this.cameraTarget) {
      this.cameraTarget.destroy();
    }
  }, f;
}();
hd = function() {
  function self(limit, options) {
    r(this, self);
    this._candidates = limit;
    this._options = options || {};
    this._app = null;
    this._objects = [];
    this._previousObjects = [];
    this._started = false;
  }
  return self.prototype.onAdd = function(text) {
    this._app = text;
    this._app.focus();
    this._objects = new xi(this._app, []);
    this._previousObjects = this._objects;
    this.start();
  }, self.prototype.onRemove = function() {
    this.end();
  }, self.prototype._start = function(n) {
    if (n) {
      this.candidates = this._candidates;
      var originalStart = this._options.start;
      if (originalStart) {
        originalStart.call(this, {
          candidates : this.candidates
        });
      }
      var self = this;
      this._app.camera.inputEnabled = false;
      this._app.picker.startAreaPicking({
        x : n.x,
        y : n.y
      });
      this._app.on("pick", ".Thing", function(e) {
        var error = self._options.select;
        if (error && error.call(self, e), !e._stopPropagation) {
          var outlineColor = self._options.outlineColor || "#FF8000";
          e.object.style.outlineColor = outlineColor;
        }
      }, "RectangleSelectControl_pick");
      this._app.on("unpick", ".Thing", function(e) {
        var _rl = self._options.deselect;
        if (_rl) {
          _rl.call(self, e);
        }
        if (!e._stopPropagation) {
          e.object.style.outlineColor = null;
        }
      }, "RectangleSelectControl_unpick");
      this._app.on(EventType.AreaPickEnd, function(canCreateDiscussions) {
        self._previousObjects = self._objects;
        self._objects = self._app.picker.objects.concat();
      }, "RectangleSelectControl_AreaPickEnd");
      this._started = true;
    }
  }, self.prototype._end = function() {
    if (this._started) {
      this._started = false;
      this._app.picker.endAreaPicking();
      this._app.off("pick", ".Thing", "RectangleSelectControl_pick");
      this._app.off("unpick", ".Thing", "RectangleSelectControl_unpick");
      this._app.off(EventType.AreaPickEnd, null, "RectangleSelectControl_AreaPickEnd");
      this._app.camera.inputEnabled = true;
      var __super__ = this._options.end;
      if (__super__) {
        __super__.call(this, {
          candidates : this.candidates
        });
      }
    }
  }, self.prototype.start = function() {
    var that = this;
    this._app.on("mousedown", function(e) {
      if (0 == e.button) {
        that._start(e);
      }
    }, "RectangleSelectControl_mousedown");
    this._app.on("mouseup", function(event) {
      if (0 == event.button) {
        that._end();
      }
    }, "RectangleSelectControl_mouseup");
  }, self.prototype.end = function() {
    this._end();
    this._app.off("mousedown", null, "RectangleSelectControl_mousedown");
    this._app.off("mouseup", null, "RectangleSelectControl_mouseup");
    this._app.off("pick", ".Thing", "RectangleSelectControl_pick");
    this._app.off("unpick", ".Thing", "RectangleSelectControl_unpick");
  }, self.prototype.clear = function() {
    if (this._objects.length) {
      var i = 0;
      for (; i < this._objects.length; i++) {
        var objects = this._objects;
        var screen = this._options.deselect;
        if (screen) {
          screen.call(objects, {
            object : objects
          });
        }
      }
      this._objects.clear();
    }
  }, n(self, [{
    key : "candidates",
    set : function(v) {
      this._app.picker.areaCandidates = v;
    },
    get : function() {
      return this._app.picker.areaCandidates;
    }
  }, {
    key : "options",
    set : function(v) {
      this._options = v;
    },
    get : function() {
      return this._options;
    }
  }, {
    key : "previousObjects",
    get : function() {
      return this._previousObjects;
    }
  }, {
    key : "objects",
    get : function() {
      return this._objects;
    }
  }]), self;
}();
MeasurementControl = function() {
  function o() {
    r(this, o);
    this.object = null;
    this.app = null;
    this._height = 0;
    this._box = null;
    this._pickResults = null;
  }
  return o.prototype._setupBox = function() {
    if (this._box) {
      this.app.resourceManager.remove(this._box);
      this._box = null;
    }
    var end = this.object.boundingBox.size;
    var geometry = new THREE.BoxGeometry(end[0], end[1], end[2]);
    var bufferedGeometry = new THREE.EdgesGeometry(geometry);
    this._box = new THREE.LineSegments(bufferedGeometry);
    this.object.node.add(this._box);
    var i = Utils.parseVector3(this.object.boundingBox.center);
    this._box._setWorldPosition(i, this.object.static);
    var colors = [16711680, 65280, 255, 0];
    var branchI = 0;
    for (; branchI < 4; branchI++) {
      (geometry = new THREE.Geometry).vertices.push(new THREE.Vector3);
      geometry.vertices.push(new THREE.Vector3);
      var material = new THREE.LineBasicMaterial({
        color : colors[branchI]
      });
      var text = new THREE.Line(geometry, material);
      text.visible = false;
      this._box.add(text);
    }
  }, o.prototype._useCenterMode = function() {
    var a = this.object.angles;
    var valueProgess = THING.Math.abs(a[1]);
    return valueProgess < 1e-5 || (!!THING.Math.isFloatEquals(valueProgess, 90) || (!!THING.Math.isFloatEquals(valueProgess, 180) || !!THING.Math.isFloatEquals(valueProgess, 270)));
  }, o.prototype._updatePickedResult = function() {
    var edgearray = [new THREE.Raycaster, new THREE.Raycaster, new THREE.Raycaster, new THREE.Raycaster];
    var vertices = [];
    var normals = this._box.geometry.attributes.position.array;
    var i = 0;
    for (; i < normals.length; i = i + 3) {
      var a = new THREE.Vector3(normals[i], normals[i + 1], normals[i + 2]);
      if (!(a.y < 0)) {
        var o = false;
        var j = 0;
        for (; j < vertices.length; j++) {
          if (vertices[j].equals(a)) {
            o = true;
          }
        }
        if (!o) {
          vertices.push(a);
        }
      }
    }
    var event;
    var options;
    var raycaster;
    var ray;
    if (this.object.node.updateMatrixWorld(), this._useCenterMode()) {
      var points = [];
      i = 0;
      for (; i < vertices.length; i++) {
        points.push(vertices[i].clone());
      }
      vertices[0].addVectors(points[0], points[1]).divideScalar(2);
      vertices[1].addVectors(points[1], points[2]).divideScalar(2);
      vertices[2].addVectors(points[2], points[3]).divideScalar(2);
      vertices[3].addVectors(points[3], points[0]).divideScalar(2);
    }
    i = 0;
    for (; i < vertices.length; i++) {
      var p = (e = edgearray[i]).ray.origin;
      p.set(vertices[i].x, this._height - this._box.position.y, vertices[i].z);
      p = this._box.localToWorld(p);
      if (!event || p.x < event.ray.origin.x) {
        event = e;
      }
      if (!raycaster || p.z < raycaster.ray.origin.z) {
        raycaster = e;
      }
      if (!options || p.x > options.ray.origin.x) {
        options = e;
      }
      if (!ray || p.z > ray.ray.origin.z) {
        ray = e;
      }
    }
    event.ray.direction.set(-1, 0, 0);
    raycaster.ray.direction.set(0, 0, -1);
    options.ray.direction.set(1, 0, 0);
    ray.ray.direction.set(0, 0, 1);
    this._pickResults = [];
    i = 0;
    for (; i < edgearray.length; i++) {
      var e;
      var arr = (e = edgearray[i]).intersectObject(this.app.scene, true);
      j = 0;
      for (; j < arr.length; j++) {
        if (!(data = arr[j]).object.isChildOf(this.object.node)) {
          break;
        }
        arr.splice(j--, 1);
      }
      this._pickResults.push({
        startPosition : e.ray.origin.toArray(),
        pickedPosition : null,
        pickedObject : null,
        distance : 100,
        direction : e.ray.direction.toArray()
      });
      var light = this._pickResults[i];
      if (arr.length) {
        var data = arr[0];
        light.pickedPosition = data.point.toArray();
        light.pickedObject = this.app.objectManager.getBaseObject(data.object);
        light.distance = data.distance;
      }
    }
    var emoticonCodes = this._pickResults;
    i = 0;
    for (; i < emoticonCodes.length; i++) {
      var point;
      var min;
      var key = emoticonCodes[i];
      var object = this._box.children[i];
      if (point = Utils.parseVector3(key.startPosition), key.pickedPosition) {
        min = Utils.parseVector3(key.pickedPosition);
      } else {
        var mp = new THREE.Vector3;
        var projY = Utils.parseVector3(key.direction);
        mp.addVectors(Utils.parseVector3(key.startPosition), projY.multiplyScalar(100));
        min = mp;
      }
      point = object.worldToLocal(point);
      min = object.worldToLocal(min);
      object.geometry.vertices[0].copy(point);
      object.geometry.vertices[1].copy(min);
      object.geometry.verticesNeedUpdate = true;
      object.geometry.elementsNeedUpdate = true;
      object.computeLineDistances();
    }
    return this._pickResults;
  }, o.prototype.onAdd = function(options) {
    this.object = options;
    this.app = options.app;
    this.height = this.object.boundingBox.size[1] / 2;
  }, o.prototype.onRemove = function() {
    if (this._box) {
      this.app.resourceManager.remove(this._box);
      this._box = null;
    }
  }, o.prototype.onUpdate = function(parentBindings) {
    return false;
  }, n(o, [{
    key : "height",
    set : function(v) {
      this._height = v;
    },
    get : function() {
      return this._height;
    }
  }, {
    key : "visible",
    set : function(v) {
      if (!this._box) {
        this._setupBox();
      }
      this._box.visible = v;
    },
    get : function() {
      return !!this._box && this._box.visible;
    }
  }, {
    key : "lineVisible",
    set : function(v) {
      if (!this._box) {
        this._setupBox();
      }
      this._box.children.forEach(function(valid) {
        valid.visible = v;
      });
    },
    get : function() {
      return !!this._box && this._box.children[0].visible;
    }
  }, {
    key : "pickResults",
    get : function() {
      return this._updatePickedResult(), this._pickResults;
    }
  }]), o;
}();
dd = function() {
  function o() {
    r(this, o);
    this._object = null;
    this._prevCameraInfo = {};
  }
  return o.prototype.onAdd = function(value) {
    this.app = value;
    var options = this.app.camera;
    this._prevCameraInfo = {
      enablePan : options.enablePan,
      autoAdjustTarget : options.autoAdjustTarget,
      enableUpdateTargetOnWheel : options.enableUpdateTargetOnWheel,
      distanceLimited : options.distanceLimited,
      dampingFactor : options.dampingFactor
    };
    options.enablePan = false;
    options.autoAdjustTarget = false;
    options.enableUpdateTargetOnWheel = false;
    options.dampingFactor = .05;
  }, o.prototype.onRemove = function() {
    var env = this.app.camera;
    var i;
    for (i in this._prevCameraInfo) {
      env[i] = this._prevCameraInfo[i];
    }
  }, o.prototype.onUpdate = function(parentBindings) {
  }, o.prototype._getObject = function(that) {
    var obj = that.target;
    if (obj) {
      return obj;
    }
    var daturl = that.url;
    if (daturl) {
      var $ = this;
      var BOUNCE_BACK = that.time || 1e3;
      var STUB_RESULTS_DISTANCE = that.distance || 10;
      var direction = that.direction;
      var complete = that.complete;
      this.app.create({
        type : "Thing",
        url : daturl,
        position : this.getNextObjectPosition(that),
        nodeReady : function(n) {
          setTimeout(function() {
            $.lookAt({
              target : n.object,
              time : BOUNCE_BACK,
              distance : STUB_RESULTS_DISTANCE,
              direction : direction,
              complete : complete
            });
          }, 10);
        }
      });
    }
    return null;
  }, o.prototype.getNextObjectPosition = function(filter) {
    if (filter = filter || {}, this._object) {
      var STUB_RESULTS_DISTANCE = filter.distance || 10;
      var state = this.app.camera.rightDirection;
      return -1 === filter.direction && (state = THING.Math.negVector(state)), this._object.getWorldPosition({
        direction : state,
        distance : STUB_RESULTS_DISTANCE
      });
    }
    return [0, 0, 0];
  }, o.prototype.lookAt = function(obj) {
    obj = obj || {};
    var result = this._getObject(obj);
    if (result) {
      var me = this;
      var time = obj.time || 1e3;
      var callback = obj.complete;
      var client = this.app.camera;
      var leftRadius = result.boundingBox.radius;
      if (this._object) {
        var STUB_RESULTS_DISTANCE = obj.distance || 10;
        var l = (time = obj.time || 1e3, obj.lerpType || THING.LerpType.Quartic.Out);
        var state = client.rightDirection;
        if (-1 === obj.direction) {
          state = THING.Math.negVector(state);
        }
        var position = result.getWorldPosition({
          direction : state,
          distance : STUB_RESULTS_DISTANCE
        });
        result.position = position;
        result.lerpTo({
          from : {
            position : position
          },
          to : {
            position : [0, 0, 0]
          },
          time : time,
          lerpType : l
        }, "modelViewControl_lerp_fadeIn");
        result.fadeIn({
          time : time
        });
        this._object.lerpTo({
          from : {
            position : this._object.position
          },
          to : {
            position : this._object.getWorldPosition({
              direction : THING.Math.negVector(state),
              distance : STUB_RESULTS_DISTANCE
            })
          },
          time : time,
          lerpType : l,
          stop : function(e) {
            e.object.destroy();
          },
          complete : function(e) {
            e.object.destroy();
            if (callback) {
              callback.call(me, {
                object : me._object
              });
            }
          }
        }, "modelViewControl_lerp_fadeOut");
        this._object.fadeOut({
          time : time / 2
        });
      } else {
        client.flyTo({
          target : result,
          xAngle : 0,
          yAngle : 0,
          time : time,
          complete : function() {
            if (callback) {
              callback.call(me, {});
            }
          }
        });
      }
      this._object = result;
      client.distanceLimited = [.5 * leftRadius, 4 * leftRadius];
    }
  }, n(o, [{
    key : "object",
    get : function() {
      return this._object;
    }
  }]), o;
}();
fd = function() {
  function f() {
    r(this, f);
    this._navigation = null;
  }
  return f.prototype.onAdd = function(store) {
    var mesh = store.node.getMeshes()[0];
    mesh.updateWorldMatrix(true);
    var intersectionPoint = (new THREE.Geometry).fromBufferGeometry(mesh.geometry);
    intersectionPoint.applyMatrix4(mesh.matrixWorld);
    this._navigation = new Gt((new THREE.BufferGeometry).fromGeometry(intersectionPoint));
  }, f.prototype.onRemove = function() {
    this._navigation = null;
  }, f.prototype.findPath = function(direction, v) {
    var tmph = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    var body = this._navigation.findPath((new THREE.Vector3).fromArray(direction), (new THREE.Vector3).fromArray(v), {
      includeStart : true,
      includeEnd : true,
      fixEnds : true,
      pathSmooth : {
        enable : true
      }
    });
    return body && Array.isArray(body) ? body.map(function(rect) {
      return [rect.x, rect.y + tmph, rect.z];
    }) : null;
  }, f;
}();
md = function(object) {
  return !object.isLight && !object.userData.skipBoundingBox;
};
function gd(e, id, data, res) {
  var lvp = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
  if (e) {
    var type = e.uuid;
    var filter = data[type];
    if (!(filter === processStrArr.Stop && lvp > 0) && (filter === processStrArr.Jump || (res[e.uuid] && THING.Utils.log("% :is existing"), e.uuid && (e.selections || (e.selections = {}), e.selections[this.name] = this, res[e.uuid] = e)), id && e.children.length > 0)) {
      var i = 0;
      for (; i < e.children.length; i++) {
        gd.call(this, e.children[i], id, data, res, lvp + 1);
      }
    }
  }
}
function vd(relays) {
  var i;
  for (i in relays) {
    var state = relays[i];
    if (state.selections) {
      state.selections[this.name];
      delete state.selections[this.name];
    }
    delete this._nodesResult[i];
  }
}
function SceneNodeSelection(name) {
  if (void 0 === name) {
    name = THREE.MathUtils.generateUUID();
  }
  this.name = name;
  this._nodesMark = {};
  this._nodesResult = {};
}
function bd(origins) {
  var i;
  for (i in origins) {
    var bmp = origins[i].material;
    if (bmp && !this._nodesMap[i]) {
      if (!origins[i].modifiers) {
        origins[i].modifiers = [];
      }
      origins[i].modifiers.push(this);
      this._nodesMap[i] = origins[i];
      var data = bmp;
      var id = data.uuid;
      var object = this._materialCopy[id];
      var material = object && object.material;
      if (!object) {
        material = (object = this._materialCopy[id] = {
          refrence : 0,
          material : bmp.clone()
        }).material;
        var i = -1 === this._trans ? data.opacity : this._trans;
        if (this.override) {
          material.opacity = i;
          if (this._colour.x + this._colour.y + this._colour.z > -1) {
            material.alphaColor = this._colour.clone();
            material.override_color = this._colour.clone();
          }
        } else {
          if (data.override_color) {
            material.opacity = data.opacity;
            material.alphaColor.clone(data.override_color);
            material.override_color.clone(data.override_color);
          } else {
            material.opacity = i;
            if (this._colour.x + this._colour.y + this._colour.z > -1) {
              material.color.setRGB(this._colour.x, this._colour.y, this._colour.z);
            }
          }
        }
        if (material.opacity < 1) {
          material.transparent = true;
          material.depthWrite = false;
        }
        if (this._isFlashing) {
          material.alphaColor.w = 0;
        }
        material.needsUpdate = true;
      }
      object.refrence++;
      origins[i][this.bak_name] = origins[i].material;
      origins[i].material = material;
    }
  }
}
function _d(s, d) {
  if (!Array.isArray(d)) {
    d = [];
  }
  var index = s.modifiers.indexOf(this);
  if (index < 0 || index == s.modifiers.length - 1) {
    return d;
  }
  (d = s.modifiers.splice(index + 1)).reverse();
  var i = 0;
  for (; i < d.length; i++) {
    var val = d[i];
    var a = {};
    a[s.name] = s;
    Ed.call(val, a);
  }
  return d;
}
function xd(url, body) {
  if (Array.isArray(body) && !(body.length < 1)) {
    var i = 0;
    for (; i < body.length; i++) {
      var value = body[i];
      var post = {};
      post[url.name] = url;
      bd.call(value, post);
    }
  }
}
function Ed(markers) {
  var id = this.bak_name;
  var i;
  for (i in markers) {
    if (this._nodesMap[i] && (delete this._nodesMap[i], markers[i].modifiers)) {
      var throw42 = _d.call(this, markers[i]);
      var n = markers[i].modifiers.pop();
      if (n == this) {
        if (markers[i].material && markers[i][id]) {
          var selectedMaterial = markers[i].material = markers[i][id];
          var uuid = (markers[i].material = selectedMaterial).uuid;
          delete markers[i][id];
          if (this._materialCopy[uuid]) {
            if ("number" == typeof this._materialCopy[uuid].refrence) {
              this._materialCopy[uuid].refrence--;
            } else {
              THING.Utils.log("[%s] didn't found", uuid);
            }
            if (this._materialCopy[uuid].refrence < 1) {
              delete this._materialCopy[uuid];
            }
          } else {
            THING.Utils.log("[%s] didn't found", uuid);
          }
        }
        xd.call(this, markers[i], throw42);
      } else {
        markers[i].modifiers.push(n);
      }
    }
  }
}
function MaterialModifier(name) {
  if (void 0 === name) {
    name = THREE.MathUtils.generateUUID();
  }
  this.name = name;
  this.bak_name = "t3d_material_bak_" + this.name;
  this._trans = -1;
  this._seletions = [];
  this._nodesMap = {};
  this.autoUpdate = false;
  this._autoUpdateID = null;
  this.fadeSpeed = 1;
  this.flashSpeed = 1;
  this._isFading = false;
  this._isFlashing = false;
  this.flashLoop = false;
  this._updateQueen = [];
  this._removeQueen = [];
  this.override = false;
  this._materialCopy = {};
  this._colour = new THREE.Vector4(-1, -1, -1, 0);
}
function Td(opts, parent, view) {
  var searchLength = opts.begin || (new Date).getTime();
  var alpha = isNaN(opts.from) ? 0 : opts.from;
  var baseShader = isNaN(opts.to) ? 1 : opts.to;
  var index = opts.during;
  var func = opts.func;
  return function(type) {
    if ("reset" === type) {
      searchLength = (new Date).getTime();
    }
    var start = (new Date).getTime() - searchLength;
    if (start <= index) {
      var result = func(start, 0, 1, index);
      return parent(alpha + (baseShader - alpha) * result), true;
    }
    if (start > index) {
      parent(baseShader);
      var vroot = view();
      return searchLength = (new Date).getTime(), vroot;
    }
  };
}
SceneNodeSelection.prototype.toString = function() {
  return this.name;
};
SceneNodeSelection.prototype.setAutoResetMark = function(canCreateDiscussions) {
};
SceneNodeSelection.prototype.getAutoResetMark = function() {
};
SceneNodeSelection.prototype.mark = function(task, count) {
  if (null != task) {
    this._nodesMark[task.uuid] = count;
  }
};
SceneNodeSelection.prototype.markSelection = function(win, color) {
  var i;
  for (i in win._nodesResult) {
    this._nodesMark[win._nodesResult[i].uuid] = color;
  }
};
SceneNodeSelection.prototype.getMark = function(tag) {
  var modifiers = processStrArr.None;
  return tag && (modifiers = (modifiers = this._nodesMark[tag.uuid]) || processStrArr.None), modifiers;
};
SceneNodeSelection.prototype.getAllNameString = function() {
  var FixedPerks = this._nodesResult;
  var closedPanels = [];
  var i;
  for (i in FixedPerks) {
    closedPanels.push(FixedPerks[i].name);
  }
  return closedPanels.join(";");
};
SceneNodeSelection.prototype.select = function(e, time) {
  var t = {};
  var j;
  for (j in gd.call(this, e, time, this._nodesMark, t), t) {
    this._nodesResult[j] = t[j];
  }
};
SceneNodeSelection.prototype.reselect = function(newValue, type) {
  vd.call(this, this._nodesResult);
  gd.call(this, newValue, type, this._nodesMark, this._nodesResult);
};
SceneNodeSelection.prototype.unselect = function(data, type) {
  var list = {};
  if (type) {
    gd.call(this, data, type, this._nodesMark, list);
  } else {
    list[data.uuid] = data;
  }
  vd.call(this, list);
};
SceneNodeSelection.prototype.deselect = function(value, tile) {
  var negotiateResponse = {};
  gd.call(this, value, tile, this._nodesMark, negotiateResponse);
  vd.call(this, negotiateResponse);
  this._nodesResult = negotiateResponse;
};
SceneNodeSelection.prototype.selectList = function(params, options) {
  if (params && Array.isArray(params)) {
    var i = 0;
    for (; i < params.length; i++) {
      this.select(params[i], options);
    }
  }
};
SceneNodeSelection.prototype.unselectList = function(selection, fallback) {
  if (selection && Array.isArray(selection)) {
    var i = 0;
    for (; i < selection.length; i++) {
      this.unselect(selection[i], fallback);
    }
  }
};
SceneNodeSelection.prototype.isEmpty = function() {
  var e;
  for (e in this._nodesResult) {
    return false;
  }
  return true;
};
SceneNodeSelection.prototype.merge = function(geometry, matrix) {
  var attributes = geometry._nodesResult;
  var changed = this._nodesResult;
  var attr;
  for (attr in attributes) {
    changed[attr] = attributes[attr];
  }
};
SceneNodeSelection.prototype.unmerge = function(td, oldIcon) {
  var tr = td._nodesResult;
  var copiedStyle = this._nodesResult;
  var prop;
  for (prop in tr) {
    delete copiedStyle[prop];
  }
};
SceneNodeSelection.prototype.getWorldAABB = function(canCreateDiscussions) {
  var data = this._nodesResult;
  var bounds = new THREE.Box3;
  var update = function(i) {
    return l = new THREE.Box3, data[i] ? ("Billboard" == data[i].typeName ? l.setFromObject(data[i]) : data[i] && ((postLi = new THREE.Box3)._setFromObject(data[i], function(val) {
      return val == data[i] && (!!md(val) && void 0);
    }), l = postLi.clone()), style = new THREE.Vector3, l.getSize(style), 0 === style.x && 0 === style.y && 0 === style.z ? "continue" : void bounds.union(l)) : "continue";
  };
  var i;
  for (i in data) {
    var l;
    var postLi;
    var style;
    update(i);
  }
  var coords = new THREE.Vector3;
  bounds.getCenter(coords);
  if (!(coords.x || coords.y || coords.z)) {
    coords.x = 0;
    coords.y = 0;
    coords.z = 0;
  }
  var params = new THREE.Vector3;
  return bounds.getSize(params), {
    center : [coords.x, coords.y, coords.z],
    radius : Math.sqrt(Math.pow(params.x, 2) + Math.pow(params.y, 2) + Math.pow(params.z, 2)) / 2,
    width : params.x,
    height : params.y,
    depth : params.z
  };
};
SceneNodeSelection.prototype.getWorldOBB = function(object) {
  var toolbar_buttons = this._nodesResult;
  object.updateWorldMatrix(true, true);
  var matrix = new THREE.Matrix4;
  matrix.getInverse(object.matrixWorld);
  var element = new THREE.Box3;
  var target = new THREE.Box3;
  var tb;
  for (tb in toolbar_buttons) {
    var button = toolbar_buttons[tb];
    if (button) {
      target._setFromObject(button, md, matrix);
      element.union(target);
    }
  }
  var result = [];
  element.getBoundingPositions().forEach(function(prefixTransliterations) {
    var vector = prefixTransliterations.clone();
    vector.applyMatrix4(object.matrixWorld);
    result.push(vector.toArray());
  });
  var obj = element;
  var vector = new THREE.Vector3;
  obj.getCenter(vector);
  vector.applyMatrix4(object.matrixWorld);
  if (!(vector.x || vector.y || vector.z)) {
    vector.x = 0;
    vector.y = 0;
    vector.z = 0;
  }
  var options = new THREE.Vector3;
  var max = new (Function.prototype.bind.apply(THREE.Vector3, [null].concat(result[7])));
  var start = new (Function.prototype.bind.apply(THREE.Vector3, [null].concat(result[0])));
  return options.subVectors(max, start), {
    points : result,
    center : [vector.x, vector.y, vector.z],
    radius : Math.sqrt(Math.pow(options.x, 2) + Math.pow(options.y, 2) + Math.pow(options.z, 2)) / 2,
    width : options.x,
    height : options.y,
    depth : options.z
  };
};
SceneNodeSelection.prototype.setQueryFlags = function(e) {
  var indexLookupKey;
  for (indexLookupKey in this._nodesResult) {
    this._nodesResult[indexLookupKey].setQueryFlags(e);
  }
};
SceneNodeSelection.prototype.addQueryFlags = function(e) {
  var indexLookupKey;
  for (indexLookupKey in this._nodesResult) {
    this._nodesResult[indexLookupKey].addQueryFlags(e);
  }
};
SceneNodeSelection.prototype.removeQueryFlags = function(e) {
  var indexLookupKey;
  for (indexLookupKey in this._nodesResult) {
    this._nodesResult[indexLookupKey].removeQueryFlags(e);
  }
};
SceneNodeSelection.prototype.setPickEnabled = function(e) {
  var indexLookupKey;
  for (indexLookupKey in this._nodesResult) {
    this._nodesResult[indexLookupKey].setPickEnabled(e);
  }
};
SceneNodeSelection.prototype.showBoundingBox = function(canCreateDiscussions) {
};
SceneNodeSelection.prototype.show = function() {
  var value = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
  var currentItemPage;
  for (currentItemPage in this._nodesResult) {
    this._nodesResult[currentItemPage].show(value);
  }
};
SceneNodeSelection.prototype.setDepthCheckEnabled = function(value) {
  var options_idx;
  for (options_idx in this._nodesResult) {
    var options = this._nodesResult[options_idx];
    if (options && options.material) {
      options.material.depthTest = value;
    }
  }
};
SceneNodeSelection.prototype.clone = function(element) {
  var c = new SceneNodeSelection(element);
  var pi;
  for (pi in this._nodesMark) {
    c._nodesMark[pi] = this._nodesMark[pi];
  }
  var buttonIndex;
  for (buttonIndex in this._nodesResult) {
    c._nodesResult[buttonIndex] = this._nodesResult[buttonIndex];
  }
  return c;
};
SceneNodeSelection.prototype.clear = function() {
  var indexLookupKey;
  for (indexLookupKey in this._nodesResult) {
    delete this._nodesResult[indexLookupKey];
  }
};
SceneNodeSelection.prototype.destroy = function() {
  var indexLookupKey;
  for (indexLookupKey in this._nodesMark) {
    delete this._nodesMark[indexLookupKey];
  }
  var signedTransactionsCounter;
  for (signedTransactionsCounter in this._nodesResult) {
    delete this._nodesResult[signedTransactionsCounter];
  }
};
SceneNodeSelection.prototype.updateBounds = function() {
};
SceneNodeSelection.prototype.setRenderQueueGroup = function(e) {
  var indexLookupKey;
  for (indexLookupKey in this._nodesResult) {
    this._nodesResult[indexLookupKey].setRenderQueueGroup(e);
  }
};
SceneNodeSelection.prototype.removeAllModifiers = function() {
  var duplexType;
  for (duplexType in this._nodesResult) {
    var data = this._nodesResult[duplexType];
    if (data && data.node && data.node.modifiers) {
      data.node.modifiers.length = 0;
    }
  }
};
SceneNodeSelection.prototype.setVisibilityFlags = function(bs) {
  var i;
  for (i in this._nodesResult) {
    this._nodesResult[i].setVisibilityFlags(bs);
  }
};
SceneNodeSelection.prototype.addVisibilityFlags = function(e) {
  var indexLookupKey;
  for (indexLookupKey in this._nodesResult) {
    this._nodesResult[indexLookupKey].addVisibilityFlags(e);
  }
};
SceneNodeSelection.prototype.removeVisibilityFlags = function(e) {
  var indexLookupKey;
  for (indexLookupKey in this._nodesResult) {
    this._nodesResult[indexLookupKey].removeVisibilityFlags(e);
  }
};
SceneNodeSelection.prototype.setCustomParameter = function(e, skipFrames) {
  var i;
  for (i in this._nodesResult) {
    this._nodesResult[i].setCustomParameter(e, skipFrames);
  }
};
MaterialModifier.prototype.toString = function() {
  return this.name;
};
MaterialModifier.prototype.getId = function() {
  THING.Utils.log("[%s] didn't ready", "MaterialModifier.getId");
};
MaterialModifier.prototype.setAutoUpdate = function(inAutoUpdate) {
  this.autoUpdate = inAutoUpdate;
  this.autoUpdateRunner();
};
MaterialModifier.prototype.getAutoUpdate = function() {
  return this.autoUpdate;
};
MaterialModifier.prototype.autoUpdateRunner = function() {
  if (this._autoUpdateID) {
    cancelAnimationFrame(this._autoUpdateID);
    this._autoUpdateID = false;
  }
  var me = this;
  if (me.autoUpdate) {
    (function update() {
      if (me._autoUpdateID) {
        cancelAnimationFrame(me._autoUpdateID);
        me._autoUpdateID = 0;
      }
      me.update();
      if (me.autoUpdate) {
        me._autoUpdateID = requestAnimationFrame(update);
      }
    })();
  }
};
MaterialModifier.prototype.setTransparency = function(s) {
  this._trans = s;
};
MaterialModifier.prototype.getTransparency = function() {
  return this._trans;
};
MaterialModifier.prototype.fade = function(value, opacity) {
  this._seletions.length;
  var during = 1e3 / this.fadeSpeed;
  var contextObj = this;
  this._isFading = true;
  var n = Td({
    from : value,
    to : opacity,
    during : during,
    func : TWEEN.Cubic.easeOut,
    begin : (new Date).getTime()
  }, function(i) {
    var j;
    for (j in contextObj._materialCopy) {
      var material = contextObj._materialCopy[j].material;
      if (material) {
        (material = material.getTechnique(0).getPass(0).material).transparent = true;
        material.opacity = i;
      }
    }
  }, function() {
    return contextObj._isFading = false, false;
  });
  contextObj._updateQueen.push(n);
};
MaterialModifier.prototype.fadeIn = function() {
  this._seletions.length;
  var elements = this._trans;
  this.fade(elements, 1);
};
MaterialModifier.prototype.fadeOut = function() {
  this._seletions.length;
  var elements = this._trans;
  this.fade(elements, 0);
};
MaterialModifier.prototype.setFadeSpeed = function(value) {
  if (0 !== value) {
    this.fadeSpeed = value;
  }
};
MaterialModifier.prototype.isFading = function() {
  return this._isFading;
};
MaterialModifier.prototype.setColour = function(r, g, b, a) {
  this._colour.x = r;
  this._colour.y = g;
  this._colour.z = b;
  this._colour.w = a;
};
MaterialModifier.prototype.flash = function(begin, end) {
  if (begin < end) {
    end = Math.min(this._trans, end);
    begin = Math.max(begin, .01);
  }
  var settings = this;
  this._isFlashing = true;
  var r = Td({
    from : 0,
    to : 1,
    during : 1e3,
    func : TWEEN.Linear,
    begin : (new Date).getTime()
  }, function(proportion) {
    var value = begin + (end - begin) * proportion;
    var i;
    for (i in settings._materialCopy) {
      var state = settings._materialCopy[i].material;
      if (state) {
        if ((state = state.getTechnique(0).getPass(0).material).override_color) {
          if (state.override_color && settings.override) {
            state.alphaColor.w = value;
          } else {
            state.alphaColor = state.backup_color;
          }
        } else {
          state.alphaColor.w = value;
        }
      }
    }
  }, function() {
    var i = begin;
    return begin = end, end = i, true;
  });
  settings._updateQueen.push(r);
  this.autoUpdateRunner();
};
MaterialModifier.prototype.setFlashSpeed = function(canCreateDiscussions) {
  this.flashSpeed = canCreateDiscussions;
};
MaterialModifier.prototype.setFlashLoop = function(canCreateDiscussions) {
  this.flashLoop = canCreateDiscussions;
};
MaterialModifier.prototype.isFlashing = function() {
  return this._isFlashing;
};
MaterialModifier.prototype.getFlashValue = function() {
  THING.Utils.log("[%s] didn't ready", "MaterialModifier.getFlashValue");
};
MaterialModifier.prototype.setOverride = function(nodelist) {
  this.override = nodelist;
};
MaterialModifier.prototype.getAllSceneNodeNames = function() {
  THING.Utils.log("[%s] didn't ready", "MaterialModifier.getAllSceneNodeNames");
};
MaterialModifier.prototype.getModifiedMaterialNameString = function() {
  THING.Utils.log("[%s] didn't ready", "MaterialModifier.getModifiedMaterialNameString");
};
MaterialModifier.prototype.addSceneNode = function(dep) {
  var cache = {};
  cache[dep.uuid] = dep;
  bd.call(this, cache);
};
MaterialModifier.prototype.removeSceneNode = function(dep) {
  var cache = {};
  cache[dep.uuid] = dep;
  Ed.call(this, cache);
};
MaterialModifier.prototype.addSceneNodeSelection = function(args) {
  this._seletions.push(args);
  var transactionId = args._nodesResult;
  bd.call(this, transactionId);
};
MaterialModifier.prototype.removeSceneNodeSelection = function(e) {
  var imgFile = e._nodesResult;
  Ed.call(this, imgFile);
  var i = this._seletions.indexOf(e);
  if (i > -1) {
    this._seletions.splice(i, 1);
  }
};
MaterialModifier.prototype.enable = function() {
  THING.Utils.log("[%s] didn't ready", "MaterialModifier.enable");
};
MaterialModifier.prototype.disable = function() {
  THING.Utils.log("[%s] didn't ready", "MaterialModifier.disable");
};
MaterialModifier.prototype.update = function(type) {
  var _i = 0;
  for (; _i < this._removeQueen.length; _i++) {
    var tr = this._removeQueen[_i];
    var r = this._updateQueen.indexOf(tr);
    if (r > -1) {
      this._updateQueen.splice(r, 1);
    }
  }
  this._removeQueen.length = 0;
  var i = 0;
  for (; i < this._updateQueen.length; i++) {
    var value = this._updateQueen[i];
    if ("function" == typeof value) {
      if (!value()) {
        this._removeQueen.push(value);
      }
    } else {
      this._removeQueen.push(value);
    }
  }
};
MaterialModifier.prototype.setOverrideDepthCheckEnabled = function(formatters, customFormatters) {
  THING.Utils.log("[%s] didn't ready", "MaterialModifier.setOverrideDepthCheckEnabled");
};
MaterialModifier.prototype.setOverrideDepthBias = function(branchData, beforeZero, afterZero) {
  THING.Utils.log("[%s] didn't ready", "MaterialModifier.setOverrideDepthBias");
};
MaterialModifier.prototype.setColourPassDepthWriteEnabled = function(canCreateDiscussions) {
  THING.Utils.warn("MaterialModifier.prototype.setColourPassDepthWriteEnabled");
};
var MaxConfigParse = {};
Object.defineProperties(MaxConfigParse, {
  enableCameraParse : {
    set : function(node) {
      ll.enableCameraParse = node;
    },
    get : function() {
      return ll.enableCameraParse;
    }
  },
  enableParse : {
    set : function(node) {
      ll.enableParse = node;
    },
    get : function() {
      return ll.enableParse;
    }
  },
  skipInDoorEnvMap : {
    set : function(node) {
      ll.skipInDoorEnvMap = node;
    },
    get : function() {
      return ll.skipInDoorEnvMap;
    }
  },
  config : {
    get : function() {
      return ll.config;
    }
  },
  indexJson : {
    get : function() {
      return ll.indexJson;
    }
  }
});
var CommonConfigParse = {};
Object.defineProperties(CommonConfigParse, {
  enableCameraParse : {
    set : function(node) {
      ll.enableCameraParse = node;
    },
    get : function() {
      return ll.enableCameraParse;
    }
  },
  enableParse : {
    set : function(node) {
      ll.enableParse = node;
    },
    get : function() {
      return ll.enableParse;
    }
  },
  skipInDoorEnvMap : {
    set : function(node) {
      ll.skipInDoorEnvMap = node;
    },
    get : function() {
      return ll.skipInDoorEnvMap;
    }
  },
  config : {
    get : function() {
      return ll.config;
    }
  },
  indexJson : {
    get : function() {
      return ll.indexJson;
    }
  }
});
var loadDebugger = function() {
  var options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
  options.devtools = void 0 !== options.devtools && options.devtools;
  var duration = void 0 !== options.isDebug && options.isDebug;
  var devMode = void 0 !== options.devMode && options.devMode;
  var path = void 0 === options.basePath ? "./js/debugger" : options.basePath;
  var chapterFlow = ["camera", "navigation", "event", "network"];
  var complete = options.complete;
  if (this.Utils.isFunction(duration)) {
    complete = duration;
    duration = true;
  }
  if (duration) {
    this.Debugger = {
      basePath : path,
      isDebug : true,
      devMode : devMode,
      enablePlugins : chapterFlow,
      options : options
    };
    this.Utils.dynamicLoad([path.appendPath("/debugger.js")], function() {
      if (complete) {
        complete();
      }
    }, false);
  } else {
    this.Debugger = {
      basePath : "https://www.3dmmd.cn/static/debugger",
      enablePlugins : chapterFlow,
      options : options
    };
    this.Utils.dynamicLoad(["https://www.3dmmd.cn/static/debugger/debugger.js"], function() {
      if (complete) {
        complete();
      }
    }, false);
  }
};
jd = {
  Math : Math
};
THING.ActionComposer = gp, THING.AllConfigParse = ll, THING.App = ThingApp, THING.AreaPickType = textureTransAndScale0, THING.AroundControl = ud, THING.AxisTransformControl = Hh, THING.BaseObject = BaseObject, THING.BaseStyle = Ml, THING.BatchObject = Tr, THING.BatchSubObject = Mr, THING.BlendingType = {
  No : "no",
  Normal : "normal",
  Additive : "add",
  Subtractive : "subtract",
  Multiply : "multiply"
}, THING.Boundary = Qu, THING.BoundingBoxControl = li, THING.Box = Pr, THING.Building = dl, THING.COMPILETIME = "Mon, 13 Feb 2023 01:47:57 GMT", THING.Camera = Dh, THING.CameraControl = Qp, THING.CameraController = Ah, THING.CameraProjectionType = kkkk, THING.CameraTargetControl = cd, THING.CameraView = CameraView, THING.Campus = Ki, THING.Circle = Rr, THING.CombinedObject = ts, THING.CommonConfigParse = CommonConfigParse, THING.CompassControl = Zp, THING.CornerType = brightness0, THING.Cylinder = Or, THING.DEFAULT_EXTENSIONS = 
[], THING.DistributionsType = {
  Box : 1,
  Sphere : 2,
  Disc : 3
}, THING.Door = Ir, THING.DragState = MAX_IMAGERY_LENGTH, THING.Element3DObjectControl = Ku, THING.Elevator = Hr, THING.ElevatorDoor = Nr, THING.EventTag = EventTag, THING.EventType = EventType, THING.Facade = pr, THING.Floor = is, THING.FlyControl = Kp, THING.Frustum = Fr, THING.Grid = kr, THING.Ground = Vr, THING.Group = ns, THING.GroupNavigation = ti, THING.Heatmap = Fl, THING.Helper = Ip, THING.IDWGPUMap = zl, THING.IDWMap = Ul, THING.ImageProxy = function init(t) {
  return r(this, init), function(value, element) {
    value[vp] = {};
    var exports = value[vp];
    THING.App.current;
    exports.init = function() {
      exports.handler = {
        set : function(e, a, v) {
          if ("src" === a) {
            var setElementTransformProperty = exports.proxy.onloadstart;
            if (setElementTransformProperty) {
              setElementTransformProperty(e, v);
            }
            var isNativeClickEvent = exports.proxy.onloadend;
            if (isNativeClickEvent) {
              e.addEventListener("load", function end() {
                isNativeClickEvent(e);
                e.removeEventListener("load", end);
              }, false);
              e.addEventListener("error", function end() {
                isNativeClickEvent(e);
                e.removeEventListener("error", end);
              }, false);
            }
          }
          return e[a] = v;
        },
        get : function(obj, action) {
          return "addEventListener" == action || "removeEventListener" == action ? function() {
            obj[action](arguments[0], arguments[1], arguments[2]);
          } : obj[action];
        }
      };
      exports.image = element.image || new Image(element.width, element.height);
    };
    exports.createProxy = function() {
      var proxy = new Proxy(exports.image, exports.handler);
      return proxy.getTarget = function() {
        return exports.image;
      }, exports.proxy = proxy, proxy;
    };
    exports.handler = null;
    exports.image = null;
    exports.proxy = null;
    exports.init();
  }(this, t), this[vp].createProxy();
};
THING.IndependentControlType = earthColor0, THING.KeyType = south1, THING.LayoutType = {
  Left : "Left",
  Right : "Right",
  Top : "Top",
  Bottom : "Bottom",
  Front : "Front",
  Back : "Back",
  Center : "Center"
}, THING.LerpType = alphaIndex0, THING.LevelType = {
  Unknown : "",
  Campus : "Campus",
  Building : "Building",
  Floor : "Floor",
  Room : "Room",
  Thing : "Thing"
}, THING.Line = Line, THING.LineBase = LineBase, THING.LogLevelType = P, THING.LookAtControl = LookAtControl, THING.LoopType = isAddEffect0, THING.Marker = tc, THING.MaterialModifier = MaterialModifier, THING.Math = K, THING.MaxConfigParse = MaxConfigParse, THING.MeasurementControl = MeasurementControl, THING.MeshNavigation = Gt, THING.MeshNavigationHelper = ni, THING.MiniMapControl = nd, THING.ModelViewControl = dd, THING.ModifierType = {
  Material : 513,
  TransparencyColour : 513,
  AutoRotation : 257,
  AutoScale : 258
};
THING.Navigation = Vh, THING.NavigationControl = fd, THING.Plane = Ar, THING.Points = ou, THING.PolygonLine = nu, THING.PolygonRegion = kl, THING.REVISION = "5ee9afc7726c8f8349ccfa28f3c923ae3d95e0acbuild", THING.RectangleSelectControl = hd, THING.Room = fl, THING.RouteLine = ru, THING.SceneEffectConfigParse = ul, THING.SceneNodeSelection = SceneNodeSelection, THING.SelectionMark = processStrArr, THING.Selector = xi, THING.Shape = Shape, THING.SizeAdjustmentControl = Ai, THING.SkyBox = {
  BlueSky : "BlueSky",
  MilkyWay : "MilkyWay",
  Night : "Night",
  SunCloud : "SunCloud"
}, THING.SpaceType = L, THING.Sphere = Dr, THING.Stair = zr, THING.StairDoor = Ur, THING.StyleManager = Rc, THING.SubObject = dp, THING.Tetrahedron = Br, THING.TextKeyEncoder = y, THING.TextRegion = Dl, THING.ThemeManager = wl, THING.Thing = fr, THING.TjsConfigParse = al, THING.UIAnchor = UIAnchor, THING.Utils = Utils, THING.VERSION = "1.4.8", THING.Version = Zi, THING.VideoSurvilance = VideoSurvilance, THING.WalkButtonControl = id, THING.WalkControl = WalkControl, THING.Water = Water, THING.WebView = 
ic, THING.WrapType = {
  Repeat : "repeat",
  ClampToEdge : "clamptoedge",
  MirroredRepeat : "mirroredrepeat"
}, THING.factory = hc, THING.loadDebugger = loadDebugger, THING.loadDebuggerInDevTool = function() {
  var delegate = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
  delegate.devtools = true;
  loadDebugger.call(this, delegate);
};
THING.onError = function(e) {
  jd.Utils.error(e);
};
