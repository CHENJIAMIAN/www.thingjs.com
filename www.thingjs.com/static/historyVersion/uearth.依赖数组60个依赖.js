/* 可以在浏览器执行！ */

// 开始
// Cesium1.52
// h337
// CHInstance
//MercatorProjection 百度墨卡托投影
// !function(t) {}([依赖1，依赖2，t3d.js]);//60个依赖
// 结束

/* 
t3d.js
  !*** ./lib/threejs/createBigBuildingByUearth.worker.js ***!
  !*** (webpack)/buildin/global.js ***!
  !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!
  !*** ./src/Initialization.js ***!
  !*** ./src/animation/AnimationManager.js ***!
  !*** ./src/animation/MaterialAnimationManager.js ***!
  !*** ./src/animation/MultiTexutureAnimation.js ***!
  !*** ./src/animation/RotationAnimation.js ***!
  !*** ./src/animation/ScaleAnimation.js ***!
  !*** ./src/animation/ScrollAnimation.js ***!
  !*** ./src/animation/TextureAnimation.js ***!
  !*** ./src/animation/animation.js ***!
  !*** ./src/animation/animationLodState.js ***!
  !*** ./src/animation/animationState.js ***!
  !*** ./src/billboard/BillboardType.js ***!
  !*** ./src/billboard/billboard.js ***!
  !*** ./src/camera/CameraControlMode.js ***!
  !*** ./src/camera/CameraController.js ***!
  !*** ./src/camera/camera.js ***!
  !*** ./src/camera/viewport.js ***!
  !*** ./src/canvas/Canvas.js ***!
  !*** ./src/canvas/canvasManager.js ***!
  !*** ./src/event/CursorType.js ***!
  !*** ./src/event/EventButton.js ***!
  !*** ./src/event/KeyCode.js ***!
  !*** ./src/event/MouseButtonID.js ***!
  !*** ./src/event/event.js ***!
  !*** ./src/event/eventManager.js ***!
  !*** ./src/event/input.js ***!
  !*** ./src/extra/BillboardMesh.js ***!
  !*** ./src/extra/BufferGeometryUtils.js ***!
  !*** ./src/extra/BuildingMaterial.js ***!
  !*** ./src/extra/FaceIDMeshLine.js ***!
  !*** ./src/extra/ForceEdgeBunding.js ***!
  !*** ./src/extra/GPUParticleSystem.js ***!
  !*** ./src/extra/MeshLine.js ***!
  !*** ./src/extra/SceneUtils.js ***!
  !*** ./src/extra/TGALoader.js ***!
  !*** ./src/extra/cansvg.js ***!
  !*** ./src/extra/json2mesh.js ***!
  !*** ./src/extra/simpleheat.js ***!
  !*** ./src/extra/three.path.js ***!
  !*** ./src/extra/tween.js ***!
  !*** ./src/geometry/GeometryManager.js ***!
  !*** ./src/geometry/ManualObject.js ***!
  !*** ./src/geometry/SynchroGeometryManager.js ***!
  !*** ./src/geometry/geometry.js ***!
  !*** ./src/interactive/picking.js ***!
  !*** ./src/light/defaultLight.js ***!
  !*** ./src/light/lightManager.js ***!
  !*** ./src/loader/DracoXLoader.js ***!
  !*** ./src/loader/GLTFDecoder.js ***!
  !*** ./src/loader/Loader.js ***!
  !*** ./src/loader/LoaderClosure.js ***!
  !*** ./src/loader/ResourceGroupName.js ***!
  !*** ./src/loader/Version.js ***!
  !*** ./src/loader/cache.js ***!
  !*** ./src/loader/gltfConstant.js ***!
  !*** ./src/loader/path.js ***!
  !*** ./src/loader/resourceGroupManager.js ***!
  !*** ./src/loader/sceneLoader.js ***!
  !*** ./src/loader/storage.js ***!
  !*** ./src/loader/storageItem.js ***!
  !*** ./src/main_uEarth.js ***!
  !*** ./src/material/CullingMode.js ***!
  !*** ./src/material/GpuProgramType.js ***!
  !*** ./src/material/Material.js ***!
  !*** ./src/material/Pass.js ***!
  !*** ./src/material/Technique.js ***!
  !*** ./src/material/TexUnit.js ***!
  !*** ./src/material/TextureAddressingMode.js ***!
  !*** ./src/material/materialCache.js ***!
  !*** ./src/material/materialFactory.js ***!
  !*** ./src/material/materialManager.js ***!
  !*** ./src/material/paramsDataType.js ***!
  !*** ./src/material/shaders/AtmosphereFromSpace.glsl ***!
  !*** ./src/material/shaders/alphamap_fragment.glsl ***!
  !*** ./src/material/shaders/alphamap_pars_fragment.glsl ***!
  !*** ./src/material/shaders/aomap_fragment.glsl ***!
  !*** ./src/material/shaders/atmosphere_vs.glsl ***!
  !*** ./src/material/shaders/bigpoint_fragment.glsl ***!
  !*** ./src/material/shaders/bigpoint_vertex.glsl ***!
  !*** ./src/material/shaders/color_fragment.glsl ***!
  !*** ./src/material/shaders/color_pars_fragment.glsl ***!
  !*** ./src/material/shaders/color_pars_vertex.glsl ***!
  !*** ./src/material/shaders/color_vertex.glsl ***!
  !*** ./src/material/shaders/emissivemap_fragment.glsl ***!
  !*** ./src/material/shaders/encodings_fragment.glsl ***!
  !*** ./src/material/shaders/frustum_fragment.glsl ***!
  !*** ./src/material/shaders/frustum_vertex.glsl ***!
  !*** ./src/material/shaders/gpu_fragment.glsl ***!
  !*** ./src/material/shaders/gpu_vertex.glsl ***!
  !*** ./src/material/shaders/interpolate_fs.glsl ***!
  !*** ./src/material/shaders/interpolate_vs.glsl ***!
  !*** ./src/material/shaders/map_fragment.glsl ***!
  !*** ./src/material/shaders/map_pars_fragment.glsl ***!
  !*** ./src/material/shaders/mult_texture1.glsl ***!
  !*** ./src/material/shaders/mult_texture10.glsl ***!
  !*** ./src/material/shaders/mult_texture11.glsl ***!
  !*** ./src/material/shaders/mult_texture12.glsl ***!
  !*** ./src/material/shaders/mult_texture2.glsl ***!
  !*** ./src/material/shaders/mult_texture2_vs.glsl ***!
  !*** ./src/material/shaders/mult_texture3.glsl ***!
  !*** ./src/material/shaders/mult_texture4.glsl ***!
  !*** ./src/material/shaders/mult_texture5.glsl ***!
  !*** ./src/material/shaders/mult_texture6.glsl ***!
  !*** ./src/material/shaders/mult_texture7.glsl ***!
  !*** ./src/material/shaders/mult_texture8.glsl ***!
  !*** ./src/material/shaders/mult_texture9.glsl ***!
  !*** ./src/material/shaders/projector_fragment.glsl ***!
  !*** ./src/material/shaders/projector_vertex.glsl ***!
  !*** ./src/material/shaders/scanning1_fragment.glsl ***!
  !*** ./src/material/shaders/scanning1_vertex.glsl ***!
  !*** ./src/material/shaders/scanningCity_vertex.glsl ***!
  !*** ./src/material/shaders/scanning_fragment.glsl ***!
  !*** ./src/material/shaders/scanning_vertex.glsl ***!
  !*** ./src/material/shaders/scannningCity_fragment.glsl ***!
  !*** ./src/material/shaders/shadow_pcss.glsl ***!
  !*** ./src/material/shaders/shadow_pcss_getShadow.glsl ***!
  !*** ./src/material/shaders/skinning_pars_vertex.glsl ***!
  !*** ./src/material/shaders/skinning_vertex.glsl ***!
  !*** ./src/material/shaders/standardScanning_fragment.glsl ***!
  !*** ./src/material/shaders/standardScanning_vertex.glsl ***!
  !*** ./src/material/shaders/test.glsl ***!
  !*** ./src/material/shaders/test1.glsl ***!
  !*** ./src/material/shaders/testFog.glsl ***!
  !*** ./src/material/shaders/testFog_vs.glsl ***!
  !*** ./src/material/shaders/test_vs.glsl ***!
  !*** ./src/material/shaders/tonemapping_fragment.glsl ***!
  !*** ./src/material/shaders/uv2_pars_fragment.glsl ***!
  !*** ./src/material/shaders/uv2_pars_vertex.glsl ***!
  !*** ./src/material/shaders/uv2_vertex.glsl ***!
  !*** ./src/material/shaders/uv_pars_vertex.glsl ***!
  !*** ./src/material/sideOptions.js ***!
  !*** ./src/material/sourceThreeFunction.js ***!
  !*** ./src/material/specialMaterial/multMaterial.js ***!
  !*** ./src/material/specialMaterial/scanningMaterial.js ***!
  !*** ./src/material/specialMaterial/specialMaterialManager.js ***!
  !*** ./src/material/specialMaterial/specialTextures.json ***!
  !*** ./src/material/specialMaterial/t3dMaterial.js ***!
  !*** ./src/material/specialMaterial/testMaterial.js ***!
  !*** ./src/material/specialMaterial/water.js ***!
  !*** ./src/material/specialMaterial/water/Reflector.js ***!
  !*** ./src/material/specialMaterial/water/Refractor.js ***!
  !*** ./src/material/specialMaterial/water/Water3.js ***!
  !*** ./src/material/specialMaterial/water/WaterMaterial3.js ***!
  !*** ./src/material/textureFilterOptions.js ***!
  !*** ./src/material/textureManager.js ***!
  !*** ./src/node/CombineBasicProvider.js ***!
  !*** ./src/node/CombineMeshProvider.js ***!
  !*** ./src/node/Object3D.Extend.js ***!
  !*** ./src/node/rootNode.js ***!
  !*** ./src/overlay/GuiConstant.js ***!
  !*** ./src/overlay/Overlay.js ***!
  !*** ./src/overlay/OverlayElementType.js ***!
  !*** ./src/overlay/PanelOverlayElement.js ***!
  !*** ./src/overlay/overlayManager.js ***!
  !*** ./src/renderer/FrameManager.js ***!
  !*** ./src/renderer/RenderConfig.json ***!
  !*** ./src/renderer/RenderManager.js ***!
  !*** ./src/scene/QueryFlags.js ***!
  !*** ./src/scene/RenderOperationType.js ***!
  !*** ./src/scene/RenderQueueGroupID.js ***!
  !*** ./src/scene/SceneBlendFactor.js ***!
  !*** ./src/scene/SceneBlendType.js ***!
  !*** ./src/scene/SceneLoadOptions.js ***!
  !*** ./src/scene/SceneQueryTypeMask.js ***!
  !*** ./src/scene/meshManager.js ***!
  !*** ./src/scene/renderWindow.js ***!
  !*** ./src/scene/sceneManager.js ***!
  !*** ./src/scene/viewport.js ***!
  !*** ./src/selection/MaterialModifier.js ***!
  !*** ./src/selection/SceneNodeSelection.js ***!
  !*** ./src/selection/SelectConstant.js ***!
  !*** ./src/selection/modifierManager.js ***!
  !*** ./src/util/GeoBuild.js ***!
  !*** ./src/util/InterpolationMode.js ***!
  !*** ./src/util/LayerOptions.js ***!
  !*** ./src/util/TextOptions.js ***!
  !*** ./src/util/TransformSpace.js ***!
  !*** ./src/util/arrayUtil.js ***!
  !*** ./src/util/base.js ***!
  !*** ./src/util/buffer.js ***!
  !*** ./src/util/constant.js ***!
  !*** ./src/util/game.js ***!
  !*** ./src/util/grid.js ***!
  !*** ./src/util/helper.js ***!
  !*** ./src/util/math.js ***!
  !*** ./src/util/util.js ***!
  !*** ./src/version.json ***!
  !*** ./src/volume/VolumeData.js ***!
  !*** ./src/volume/volumeDataManager.js ***!
*/
// cryptojs
// polygon-clipping
[function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var _EarthUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4)
      , _GeometryUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1)
      , _earth_DepthMode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7)
      , oldRenderFunction = null
      , perFunc = null;
    const defaultSpotLighting = {
        lightAngle: 20,
        intensity: 1,
        alpha: 45,
        beta: 45,
        lightColor: "#ffffff",
        distance: 1e4,
        penumbra: .5,
        helper: !1,
        height: 2e3
    };
    function updateProjectionMatrix() {
        var t = this.fov * Math.PI * 2 / 180
          , e = this.aspect <= 1 ? t : 2 * Math.atan(Math.tan(.5 * t) / this.aspect);
        THING.App.current.webViewManager.mixerContext.cssCamera && (THING.App.current.webViewManager.mixerContext.cssCamera.fov = THING.Math.radToDeg(e),
        THING.App.current.webViewManager.mixerContext.cssCamera.updateProjectionMatrix());
        var n = this.near
          , r = n * Math.tan(.5 * e)
          , a = 2 * r
          , i = this.aspect * a
          , o = -.5 * i
          , s = this.view;
        if (null !== this.view && this.view.enabled) {
            var l = s.fullWidth
              , u = s.fullHeight;
            o += s.offsetX * i / l,
            r -= s.offsetY * a / u,
            i *= s.width / l,
            a *= s.height / u
        }
        var c = this.filmOffset;
        0 !== c && (o += n * c / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(o, o + i, r, r - a, n, this.far),
        this.projectionMatrixInverse.getInverse(this.projectionMatrix)
    }
    var Util = {
        _halfTexture: void 0,
        defaultSpotLighting: defaultSpotLighting,
        app: void 0,
        map: void 0,
        _updateCurrentTileMaterialPass(t, e) {
            t3djs.earthAndAtmosphere.children[0].children.forEach(n=>{
                n.material.uniforms[t].value = e
            }
            )
        },
        _detectOS() {
            var t = navigator.platform;
            return 0 === t.indexOf("Win") ? "windows" : 0 === t.indexOf("Mac") ? "macos" : "X11" === t || 0 === t.indexOf("Linux") ? "linux" : void 0
        },
        _detectBrowser() {
            var t = navigator.userAgent
              , e = t.indexOf("Opera") > -1;
            return e ? "opera" : t.indexOf("compatible") > -1 && t.indexOf("MSIE") > -1 && !e ? "ie" : t.indexOf("Chrome") > -1 ? "chrome" : t.indexOf("Safari") > -1 ? "safari" : t.indexOf("Firefox") > -1 ? "firefox" : void 0
        },
        isArrayEqual: (t,e)=>t && e ? JSON.stringify(t) === JSON.stringify(e) : t === e,
        _multiplyHeightArrayFactor(t, e) {
            if (Array.isArray(t) && !Array.isArray(t[0]))
                for (let n = 0; n < t.length; n++)
                    t[n] *= e;
            else
                t.forEach(t=>{
                    this._multiplyHeightArrayFactor(t, e)
                }
                )
        },
        getJsonObject: t=>"string" == typeof t ? JSON.parse(t) : "object" == typeof t ? t : {},
        simpleData2Geojson: function(t) {
            let e = t.data
              , n = t.lonField
              , r = t.latField
              , a = {
                type: "FeatureCollection",
                name: "城市部件1",
                crs: {
                    type: "name",
                    properties: {
                        name: "urn:ogc:def:crs:OGC:1.3:CRS84"
                    }
                },
                features: []
            }
              , i = {
                type: "Feature",
                properties: {},
                geometry: {
                    type: "Point",
                    coordinates: []
                }
            };
            return e.forEach(t=>{
                let e = JSON.stringify(i);
                (e = JSON.parse(e)).geometry.coordinates = [t[n], t[r]],
                e.properties = t,
                a.features.push(e)
            }
            ),
            a
        },
        getModelAnimationNames: function(t) {
            this.app.create({
                type: "Thing",
                url: t.url,
                complete: function() {
                    t.cb(this.animationNames),
                    this.destroy()
                }
            })
        },
        geojson2SimpleData: function(t) {
            let e = t.data
              , n = [];
            return e.features.forEach((t,e)=>{
                if (t.geometry) {
                    var r = {
                        lon: t.geometry.coordinates[0],
                        lat: t.geometry.coordinates[1]
                    };
                    r = Object.assign(r, t.properties),
                    n.push(r)
                }
            }
            ),
            n
        },
        lonlat2World: function(t, e) {
            var n = t[0]
              , r = t[1];
            n < 0 && (n += 360);
            var a = n / 180 * Math.PI
              , i = r / 180 * Math.PI
              , o = e * Math.sin(i)
              , s = e * Math.cos(i);
            return [-s * Math.cos(a), o, s * Math.sin(a)]
        },
        lonlats2World: function(t, e) {
            return t.map(t=>this.lonlat2World(t, e))
        },
        world2Lonlat: function(t, e) {
            e || (e = [0, 0, 0]);
            var n = t3djs.math.subtractVectors(t, e)
              , r = n[1]
              , a = n[2]
              , i = [n[0], 0, n[2]];
            n = t3djs.math.normalizeVector(n),
            i = t3djs.math.normalizeVector(i);
            var o = 180 - t3djs.math.getAngleBetweenVectors(i, [1, 0, 0])
              , s = t3djs.math.getAngleBetweenVectors(i, n);
            return a < 0 && (o = -o),
            r < 0 && (s = -s),
            [o, s, t3djs.math.vectorDistance(t, e) - 6378e3]
        },
        mercator2Lonlat: function(t) {
            var e = t[0] / 20037508.34 * 180
              , n = t[1] / 20037508.34 * 180;
            return [e, n = 180 / Math.PI * (2 * Math.atan(Math.exp(n * Math.PI / 180)) - Math.PI / 2)]
        },
        lonlat2Mercator: function(t) {
            var e = 20037508.34 * t[0] / 180
              , n = Math.log(Math.tan((90 + t[1]) * Math.PI / 360)) / (Math.PI / 180);
            return (n = 20037508.34 * n / 180) > 20037508.34 && (n = 20037508.34),
            n < -20037508.34 && (n = -20037508.34),
            [e, n]
        },
        convertLonlat2World: function(t, e) {
            return void 0 === e && (e = 0),
            Util.lonlat2World(t, e + 6378e3)
        },
        convertLonlatToWorld: function(t, e) {
            return 3 === t.length && void 0 === e && (e = t[2]),
            this.convertLonlat2World(t, e)
        },
        convertWorldToLonlat: function(t) {
            return this.world2Lonlat(t)
        },
        convertLonlatToWebMercator: function(t) {
            return this.lonlat2Mercator(t)
        },
        convertWebMercatorToLonlat: function(t) {
            return this.mercator2Lonlat(t)
        },
        convertWgs84ToGcj02: function(t) {
            var e = 6378245
              , n = .006693421622965943
              , r = t[1]
              , a = t[0];
            if (this._outOfChina(a, r))
                return [a, r];
            var i = function(t, e) {
                var n = 2 * t - 100 + 3 * e + .2 * e * e + .1 * t * e + .2 * Math.sqrt(Math.abs(t));
                return n += 2 * (20 * Math.sin(6 * t * Math.PI) + 20 * Math.sin(2 * t * Math.PI)) / 3,
                n += 2 * (20 * Math.sin(e * Math.PI) + 40 * Math.sin(e / 3 * Math.PI)) / 3,
                n += 2 * (160 * Math.sin(e / 12 * Math.PI) + 320 * Math.sin(e * Math.PI / 30)) / 3
            }(a - 105, r - 35)
              , o = function(t, e) {
                var n = 300 + t + 2 * e + .1 * t * t + .1 * t * e + .1 * Math.sqrt(Math.abs(t));
                return n += 2 * (20 * Math.sin(6 * t * Math.PI) + 20 * Math.sin(2 * t * Math.PI)) / 3,
                n += 2 * (20 * Math.sin(t * Math.PI) + 40 * Math.sin(t / 3 * Math.PI)) / 3,
                n += 2 * (150 * Math.sin(t / 12 * Math.PI) + 300 * Math.sin(t / 30 * Math.PI)) / 3
            }(a - 105, r - 35)
              , s = r / 180 * Math.PI
              , l = Math.sin(s);
            l = 1 - n * l * l;
            var u = Math.sqrt(l);
            return i = 180 * i / (e * (1 - n) / (l * u) * Math.PI),
            [a + (o = 180 * o / (e / u * Math.cos(s) * Math.PI)), r + i]
        },
        convertGcj02ToWgs84: function(t) {
            var e = t[1]
              , n = t[0]
              , r = this.convertWgs84ToGcj02(t);
            return [2 * n - r[0], 2 * e - r[1]]
        },
        convertbd09ToGcj02(t) {
            var e = 52.35987755982988
              , n = +t[0] - .0065
              , r = +t[1] - .006
              , a = Math.sqrt(n * n + r * r) - 2e-5 * Math.sin(r * e)
              , i = Math.atan2(r, n) - 3e-6 * Math.cos(n * e);
            return [a * Math.cos(i), a * Math.sin(i)]
        },
        convertGcj02Tobd09(t) {
            var e = 52.35987755982988
              , n = t[0]
              , r = t[1]
              , a = Math.sqrt(n * n + r * r) + 2e-5 * Math.sin(r * e)
              , i = Math.atan2(r, n) + 3e-6 * Math.cos(n * e);
            return [a * Math.cos(i) + .0065, a * Math.sin(i) + .006]
        },
        _outOfChina: function(t, e) {
            return !(t > 73.66 && t < 135.05 && e > 3.86 && e < 53.55)
        },
        extend: function() {
            var t = arguments;
            if (!(t.length < 1)) {
                if (1 === t.length)
                    return t[0];
                for (var e = t[0], n = 1; n < t.length; n++)
                    for (var r in t[n])
                        e[r] = t[n][r];
                return e
            }
        },
        getUUID() {
            var t = (new Date).getTime();
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e) {
                var n = (t + 16 * Math.random()) % 16 | 0;
                return t = Math.floor(t / 16),
                ("x" === e ? n : 11 & n).toString(16)
            })
        },
        positionToQuaternion(t, e) {
            void 0 === e && (e = 0);
            var n = new THREE.Vector3(0,1,0)
              , r = new THREE.Vector3(t[0],t[1],t[2]).normalize()
              , a = new THREE.Quaternion;
            a = a.setFromUnitVectors(n, r);
            var i = new THREE.Quaternion;
            return i = (i = i.setFromAxisAngle(r, e / 180 * Math.PI)).multiply(a)
        },
        position2angles(t, e) {
            var n = Util.positionToQuaternion(t, e);
            return Util.quaternionToAngles(n)
        },
        anglesToQuaternion(t) {
            var e = t[0] * Math.PI / 180
              , n = t[1] * Math.PI / 180
              , r = t[2] * Math.PI / 180
              , a = new THREE.Euler(e,n,r)
              , i = new THREE.Quaternion;
            return i.setFromEuler(a),
            i
        },
        quaternionToAngles(t) {
            var e = (new THREE.Euler).setFromQuaternion(t, "XYZ");
            return [e._x / Math.PI * 180, e._y / Math.PI * 180, e._z / Math.PI * 180]
        },
        getDistance: function(t, e) {
            var n = e.x - t.x
              , r = e.y - t.y
              , a = e.z - t.z;
            return Math.sqrt(n * n + r * r + a * a)
        },
        getAnglesFromLonlat: function(t, e) {
            var n = this.convertLonlat2World(t)
              , r = t[0] - 0 + 90;
            return void 0 !== e && (r -= e),
            this.position2angles(n, r)
        },
        _getQuaternionFromPosition: function(t, e, n) {
            var r = t + 90;
            return void 0 !== n && (r -= n),
            this.positionToQuaternion(e, r)
        },
        getAnglesFromPosition: function(t, e) {
            var n = this.convertWorldToLonlat(t);
            return this.getAnglesFromLonlat(n, e)
        },
        _getAnglesFromPosition: function(t, e) {
            var n = this.convertWorldToLonlat(t)[0] + 90;
            return void 0 !== e && (n += e),
            this.position2angles(t, n)
        },
        getBezier: function(t, e) {
            for (var n = {
                0: {
                    x: e[0],
                    y: e[1]
                }
            }, r = [], a = 0; a < t.features.length; a++) {
                t.features[a].geometry.coordinates[0] < -30 && (t.features[a].geometry.coordinates[0] += 360);
                var i = {
                    x: t.features[a].geometry.coordinates[0],
                    y: t.features[a].geometry.coordinates[1]
                };
                n["" + (a + 1)] = i,
                r.push({
                    source: "" + (a + 1),
                    target: "0"
                })
            }
            var o = t3djs.ForceEdgeBundling().nodes(n).edges(r)()
              , s = [];
            for (var l in o) {
                var u = [];
                for (var c in u.push([]),
                o[l])
                    u[0].push([o[l][c].x, o[l][c].y]);
                s.push(u)
            }
            return s
        },
        repairCamera: function(t) {
            perFunc = t.camera.cameraP.updateProjectionMatrix,
            t.camera.cameraP.updateProjectionMatrix = updateProjectionMatrix
        },
        restoreCamera: function(t) {
            "function" == typeof perFunc && (t.camera.cameraP.updateProjectionMatrix = perFunc)
        },
        getCameraUpByPositionAndTarget: function(t, e) {
            var n = [e[0] - t[0], e[1] - t[1], e[2] - t[2]]
              , r = t3djs.math.vectorCrossProduct(t, n)
              , a = t3djs.math.vectorCrossProduct(n, r);
            return a = t3djs.math.normalizeVector(a)
        },
        getEuclideanDistance: function(t, e) {
            var n = CMAP.Util.convertLonlatToWorld(t)
              , r = CMAP.Util.convertLonlatToWorld(e);
            return THING.Math.getDistance(n, r)
        },
        getSphericalDistance: function(t, e) {
            var n = Math.PI / 180
              , r = t[1] * n
              , a = e[1] * n
              , i = Math.sin((e[1] - t[1]) * n / 2)
              , o = Math.sin((e[0] - t[0]) * n / 2)
              , s = i * i + Math.cos(r) * Math.cos(a) * o * o;
            return 6378e3 * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)))
        },
        getLineLength(t, e) {
            void 0 === e && (e = !0),
            Array.isArray(t[0]) && Array.isArray(t[0][0]) && (t = t[0]),
            Array.isArray(t[0]) && Array.isArray(t[0][0]) && (t = t[0]);
            for (var n, r = 0, a = t[0], i = t[0], o = 1; o < t.length; o++)
                i = t[o],
                r += e ? this.getSphericalDistance(a, i) : this.getEuclideanDistance(a, i),
                n = a,
                a = i,
                i = n;
            return r
        },
        getAzimuth: function(t, e) {
            var n = this.convertLonlatToWebMercator(t)
              , r = this.convertLonlatToWebMercator(e);
            if (r[1] === n[1])
                return r[0] > n[0] ? 90 : 270;
            if (r[0] === n[0])
                return r[1] > n[1] ? 0 : 180;
            var a = Math.atan(Math.abs((r[0] - n[0]) / (r[1] - n[1])))
              , i = 0;
            return r[0] - n[0] > 0 && r[1] - n[1] > 0 ? i = a : r[0] - n[0] > 0 && r[1] - n[1] < 0 ? i = Math.PI - a : r[0] - n[0] < 0 && r[1] - n[1] < 0 ? i = Math.PI + a : r[0] - n[0] < 0 && r[1] - n[1] > 0 && (i = 2 * Math.PI - a),
            THING.Math.radToDeg(i)
        },
        getLonLatIntervalByLatAndDistance: function(t, e) {
            var n = 12756e3 * Math.PI;
            return [e / (n * Math.cos(t * Math.PI / 180)) * 360, e / n * 360]
        },
        _getDistanceIntervalByLatAndDeltaLon: function(t, e) {
            return e * (12756e3 * Math.PI * Math.cos(t * Math.PI / 180)) / 360
        },
        _getDistanceIntervalByLatAndDeltaLat: function(t, e) {
            return e * (12756e3 * Math.PI) / 360
        },
        getSphericalArea: function(t) {
            var e = 0;
            if (t && t.length > 0) {
                e += Math.abs(this.ringArea(t[0]));
                for (var n = 1; n < t.length; n++)
                    e -= Math.abs(this.ringArea(t[n]))
            }
            return e
        },
        ringArea: function(t) {
            var e, n, r, a, i, o, s = 0, l = t.length;
            if (l > 2) {
                for (o = 0; o < l; o++)
                    o === l - 2 ? (r = l - 2,
                    a = l - 1,
                    i = 0) : o === l - 1 ? (r = l - 1,
                    a = 0,
                    i = 1) : (r = o,
                    a = o + 1,
                    i = o + 2),
                    e = t[r],
                    n = t[a],
                    s += (t[i][0] * Math.PI / 180 - e[0] * Math.PI / 180) * Math.sin(n[1] * Math.PI / 180);
                s = 6378e3 * s * 6378e3 / 2
            }
            return s
        },
        deepCopy: function(t) {
            return JSON.parse(JSON.stringify(t))
        },
        isClockWise: function(t) {
            return _GeometryUtil__WEBPACK_IMPORTED_MODULE_1__.a.isClockWise(t)
        },
        isObjectMeetCondition: function(t, e) {
            let n = e
              , r = ["&&", "||"]
              , a = null;
            for (let t in r)
                if ((n = e.split(r[t])).length > 1) {
                    a = r[t];
                    break
                }
            let i = [];
            for (let e in n) {
                let r = s(t, n[e]);
                i.push(r)
            }
            let o = !1;
            if (1 === i.length)
                o = i[0];
            else if (i.length > 1)
                if ("&&" === a) {
                    o = !0;
                    for (let t = 0; t < i.length; t++)
                        !1 === i[t] && (o = !1)
                } else if ("||" === a)
                    for (let t = 0; t < i.length; t++)
                        if (!0 === i[t])
                            return !0;
            return o;
            function s(t, e) {
                let n = e
                  , r = ["!=", ">=", "<=", "=", ">", "<"]
                  , a = null;
                for (let t in r)
                    if (2 === (n = e.split(r[t])).length) {
                        a = r[t];
                        break
                    }
                if (!a)
                    return !1;
                let i = n[0].split("[")[1].trim()
                  , o = n[1].split("]")[0].trim();
                if ("!=" === a) {
                    if (t[i] !== o)
                        return !0
                } else if (">=" === a) {
                    if (t[i] >= Number(o))
                        return !0
                } else if ("<=" === a) {
                    if (t[i] <= Number(o))
                        return !0
                } else if ("=" === a) {
                    if (t[i] === o)
                        return !0
                } else if (">" === a) {
                    if (t[i] > Number(o))
                        return !0
                } else {
                    if ("<" !== a)
                        return !1;
                    if (t[i] < Number(o))
                        return !0
                }
                return !1
            }
        },
        oldToNewRenderer: function(t) {
            var e = {};
            for (var n in t) {
                var r = t[n];
                if ("" !== r.condition)
                    for (var a in r)
                        "condition" !== a && (e.hasOwnProperty(a) || (e[a] = []),
                        e[a].push({
                            condition: r.condition,
                            value: r[a]
                        }))
            }
            for (var i in t) {
                var o = t[i];
                if ("" === o.condition)
                    for (var s in o)
                        "condition" !== s && (e.hasOwnProperty(s) ? e[s].unshift({
                            condition: "",
                            value: o[s]
                        }) : e[s] = o[s])
            }
            return e
        },
        getCenterOfGravityPoint: function(t) {
            var e, n, r, a, i, o, s, l, u = Util.getCenterCoordinates(t), c = 0, h = 0, d = 0, f = t.map(function(t) {
                return [t[0] - u[0], t[1] - u[1]]
            });
            for (e = 0; e < t.length - 1; e++)
                a = (n = f[e])[0],
                o = n[1],
                i = (r = f[e + 1])[0],
                d += l = a * (s = r[1]) - i * o,
                c += (a + i) * l,
                h += (o + s) * l;
            if (0 === d)
                return u;
            var p = 1 / (6 * (.5 * d));
            return [u[0] + p * c, u[1] + p * h]
        },
        _getPolygonCenterCoordinates: function(t) {
            var e = [0, 0];
            let n = 0;
            for (let r = 0; r < t.length; r++)
                for (let a = 0; a < t[r].length; a++) {
                    let i = CMAP.Util.getCenterCoordinates(t[r][a]);
                    e[0] += i[0],
                    e[1] += i[1],
                    n++
                }
            return n > 0 && (e[0] /= n,
            e[1] /= n),
            e
        },
        getCenterCoordinates: function(t) {
            var e = 0
              , n = 0;
            if (t.length > 0) {
                for (var r = 0; r < t.length; r++)
                    e += t[r][0],
                    n += t[r][1];
                e /= t.length,
                n /= t.length
            }
            return [e, n]
        },
        getPolygonExtent(t) {
            let e = []
              , n = _GeometryUtil__WEBPACK_IMPORTED_MODULE_1__.a._processGeojson(t, "POLYGON");
            for (let t = 0; t < n.length; t++)
                for (let r = 0; r < n[t].length; r++) {
                    let a = n[t][r];
                    e.push(CMAP.Util._getSinglePolygonExtent(a))
                }
            let r = Math.min.apply(Math, e.map(function(t) {
                return t.minX
            }))
              , a = Math.max.apply(Math, e.map(function(t) {
                return t.maxX
            }));
            return {
                minX: r,
                minY: Math.min.apply(Math, e.map(function(t) {
                    return t.minY
                })),
                maxX: a,
                maxY: Math.max.apply(Math, e.map(function(t) {
                    return t.maxY
                }))
            }
        },
        _getSinglePolygonExtent: function(t) {
            let e = {
                minX: 1 / 0,
                minY: 1 / 0,
                maxX: -1 / 0,
                maxY: -1 / 0
            };
            return JSON.stringify(t).startsWith("[[[[") ? t = t[0][0] : JSON.stringify(t).startsWith("[[[") && (t = t[0]),
            t.map(function(t) {
                t[0] < e.minX && (e.minX = t[0]),
                t[0] > e.maxX && (e.maxX = t[0]),
                t[1] < e.minY && (e.minY = t[1]),
                t[1] > e.maxY && (e.maxY = t[1])
            }),
            e
        },
        _parseJson(t) {
            let e = {};
            try {
                JSON.parse(t)
            } catch (e) {
                t = Util.decrypt(t)
            }
            return e = JSON.parse(t)
        },
        _parseMapConfig(t) {
            return "string" == typeof t ? this._parseJson(t) : (t.data && "string" == typeof t.data && (t.data = this._parseJson(t.data)),
            t)
        },
        getFeatureCollectionExtent: function(t) {
            var e = __webpack_require__(16).default(t);
            return {
                minX: e[0],
                minY: e[1],
                maxX: e[2],
                maxY: e[3]
            }
        },
        intersectPolygon: function(t, e) {
            const n = __webpack_require__(59)
              , r = __webpack_require__(17)
              , a = new r(t)
              , i = new r(e);
            return n.default(a, i)
        },
        clipPolygonToFourParts: function(t, e=1) {
            const n = __webpack_require__(17)
              , r = this;
            Array.isArray(t) || (t = t.geometry.coordinates),
            t = _GeometryUtil__WEBPACK_IMPORTED_MODULE_1__.a._processGeojson(t, "POLYGON");
            let a = [];
            function i(t) {
                return [[[t.minX, t.minY], [t.minX, t.maxY], [t.maxX, t.maxY], [t.maxX, t.minY], [t.minX, t.minY]]]
            }
            return function(t) {
                for (let e = 0; e < t.length; e++) {
                    const o = CMAP.Util.getPolygonExtent(t[e]);
                    if (Math.abs(o.maxX - o.minX) < 30 && Math.abs(o.maxY - o.minY) < 30) {
                        a.push(new n(t[e]));
                        continue
                    }
                    const s = o.minX
                      , l = o.minY
                      , u = o.maxX
                      , c = o.maxY
                      , h = {
                        minX: s,
                        minY: l,
                        maxX: s + (u - s) / 2,
                        maxY: l + (c - l) / 2
                    }
                      , d = {
                        minX: s,
                        minY: h.maxY,
                        maxX: h.maxX,
                        maxY: c
                    }
                      , f = {
                        minX: d.maxX,
                        minY: h.maxY,
                        maxX: u,
                        maxY: c
                    }
                      , p = {
                        minX: u,
                        minY: l,
                        maxX: h.maxX,
                        maxY: f.minY
                    }
                      , m = i(h)
                      , g = i(d)
                      , v = i(f)
                      , y = i(p)
                      , _ = r.intersectPolygon(t[e], m)
                      , x = r.intersectPolygon(t[e], g)
                      , b = r.intersectPolygon(t[e], v)
                      , w = r.intersectPolygon(t[e], y);
                    a.push(_),
                    a.push(x),
                    a.push(b),
                    a.push(w)
                }
            }(t),
            a
        },
        getSquareGrid: function(t, e, n) {
            return __webpack_require__(23).default(t, e, n)
        },
        colorFormatNewToOld: function(t, e=1) {
            if (Array.isArray(t) && t.length > 0 && void 0 !== t[0].condition)
                return t;
            if (/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(t)) {
                let r = t.toLowerCase();
                if (4 === r.length) {
                    var n = "#";
                    for (let t = 1; t < 4; t += 1)
                        n += r.slice(t, t + 1).concat(r.slice(t, t + 1));
                    r = n
                }
                let a = [];
                for (let t = 1; t < 7; t += 2)
                    a.push(parseInt("0x" + r.slice(t, t + 2)) / 255);
                return a.push(e),
                a
            }
            if ("number" == typeof t) {
                let n = t
                  , r = n % 256
                  , a = (n = (n - r) / 256) % 256
                  , i = n = (n - a) / 256;
                return [i /= 255, a /= 255, r /= 255, e]
            }
            if (Array.isArray(t)) {
                let n = t[0]
                  , r = t[1]
                  , a = t[2];
                return n /= 255,
                r /= 255,
                a /= 255,
                4 === t.length ? 1 !== e ? [n, r, a, e] : [n, r, a, t[3]] : [n, r, a, e]
            }
            if ("string" == typeof t) {
                if (-1 !== t.indexOf("rgba")) {
                    let n = t.split("rgba(")[1].split(")")[0].split(",")
                      , r = n[0].trim() - 0
                      , a = n[1].trim() - 0
                      , i = n[2].trim() - 0
                      , o = n[3].trim() - 0;
                    return 1 === e && (e = o - 0),
                    [r /= 255, a /= 255, i /= 255, e]
                }
                if (-1 !== t.indexOf("rgb")) {
                    let n = t.split("rgb(")[1].split(")")[0].split(",")
                      , r = n[0].trim() - 0
                      , a = n[1].trim() - 0
                      , i = n[2].trim() - 0;
                    return [r /= 255, a /= 255, i /= 255, e]
                }
            }
        },
        colorFormatOldToNew: function(t) {
            if (0 === t.length)
                return null;
            if (Array.isArray(t) && t.length > 0 && void 0 !== t[0].condition)
                return t;
            var e = t.map(function(t) {
                return 255 * t
            })
              , n = "#"
              , r = Math.round(e[0]).toString(16);
            1 === r.length && (r = "0" + r);
            var a = Math.round(e[1]).toString(16);
            1 === a.length && (a = "0" + a);
            var i = Math.round(e[2]).toString(16);
            return 1 === i.length && (i = "0" + i),
            n += r + a + i
        },
        _isClassifyItem: function(t) {
            return Array.isArray(t) && t.length > 0 && void 0 !== t[0].condition
        },
        convertWindowToWorld: function(t) {
            var e = t[0]
              , n = t[1];
            return _EarthUtil__WEBPACK_IMPORTED_MODULE_0__.a.pickEllipsoid3D(e, n)
        },
        convertGeojson: function(t) {
            var e = t;
            return this.multiarr(e) < 4 && (3 === this.multiarr(e) ? e = [e] : 2 === this.multiarr(e) && (e = [[e]])),
            e
        },
        _multiarr: function(t, e) {
            return void 0 === e && (e = 0),
            Array.isArray(t) && e++,
            Array.isArray(t[0]) && (e = this.multiarr(t[0], e)),
            e
        },
        _handleScanData(t, e, n) {
            "v1" === n && (t.maxDistance = this._getScanningMaxDistance(e)),
            t.uvMapUrl && !t.uvMapUrl.startsWith("http") && (t.uvMapUrl = t.resourcePrefix + t.uvMapUrl)
        },
        _queryHttpUrl(t) {
            var e = new XMLHttpRequest
              , n = void 0 === t.async || t.async
              , r = t.url
              , a = t.complete
              , i = t.error;
            if (e.onreadystatechange = function() {
                if (4 === e.readyState)
                    if (200 === e.status) {
                        if (a) {
                            let n = e.responseText;
                            t.url.endsWith("encrypt") && (n = Util.decrypt(n)),
                            a(n)
                        }
                    } else
                        THING.Utils.error("request error status:" + e.status + " message:" + e.statusText),
                        i && i()
            }
            ,
            e.open("GET", r, n),
            t.requestHeader)
                for (let n in t.requestHeader)
                    e.setRequestHeader(n, t.header[n]);
            e.send(null)
        },
        _addQuoteToObject(json_string) {
            json_string = json_string.replace(/(?:\s*['"]*)?([a-zA-Z0-9]+)(?:['"]*\s*)?:/g, "'$1':"),
            json_string.replace("\\\n", "");
            var json = eval("(" + json_string + ")");
            return json
        },
        _propertyIsCondition: t=>void 0 !== t && t.constructor === Array && t[0].constructor === Object && void 0 !== t[0].condition,
        _getBuildingGround(t, e, n, r, a=!1) {
            let i = t
              , o = r;
            if (!e) {
                let r;
                for (; Array.isArray(t[0]); )
                    r = t,
                    t = t[0];
                let a = this.getCenterOfGravityPoint(r);
                e = this.convertLonlatToWorld(a, n)
            }
            a && (i = (i = _GeometryUtil__WEBPACK_IMPORTED_MODULE_1__.a._processGeojson(i, "LINE")).map(t=>[t]),
            r && (o = _GeometryUtil__WEBPACK_IMPORTED_MODULE_1__.a._processGeojson(o, "LINEHEIGHT"),
            JSON.stringify(o).indexOf("[[") >= 0 && JSON.stringify(o).indexOf("[[[") < 0 && (o = o.map(t=>[t]))));
            let s = n;
            const l = _GeometryUtil__WEBPACK_IMPORTED_MODULE_1__.a.createBuilding(i, 0, e, "BOUNDARY", void 0, void 0, s, void 0, void 0, void 0, void 0, o)
              , u = l.geometryArray;
            return i = [],
            {
                referenceNode: l.referenceNode,
                geometryArray: u
            }
        },
        _generateGradientTexture() {
            const t = new Uint8Array(512);
            for (let e = 0; e < 128; e++)
                t[4 * e + 0] = 255,
                t[4 * e + 1] = 255 * (.8 - e / 200),
                t[4 * e + 2] = 255,
                t[4 * e + 3] = 255;
            const e = new THREE.DataTexture(t,128,1,THREE.RGBAFormat);
            return e.needsUpdate = !0,
            e
        },
        _parseSeparate(t, e) {
            let n = 0;
            for (let r = 0; r < e.length; r++) {
                let a = 0 === r ? 0 : 128 * e[r - 1]
                  , i = 128 * e[r];
                if (t >= a && t < i) {
                    n = r;
                    break
                }
            }
            return n
        },
        _parseColorArray(t) {
            let e = [];
            for (let n = 0, r = t.length; n < r; n++)
                e.push(this.colorFormatNewToOld(t[n]));
            return e
        },
        _generateInterpolantTextureByGray(t, e) {
            e = this._parseColorArray(e);
            const n = new Uint8Array(512);
            for (let r = 0; r < 128; r++) {
                let a = e[this._parseSeparate(r, t)] || [1, 1, 1, 1];
                n[4 * r + 0] = 255 * a[0],
                n[4 * r + 1] = 255 * a[1],
                n[4 * r + 2] = 255 * a[2],
                n[4 * r + 3] = void 0 === a[3] ? 255 : 255 * a[3]
            }
            const r = new THREE.DataTexture(n,128,1,THREE.RGBAFormat);
            return r.needsUpdate = !0,
            r
        },
        _generateGradientTextureByGray(t, e, n, r, a) {
            this._canvas = document.createElement("canvas"),
            this._canvas.width = 256,
            this._canvas.height = 256;
            const i = this._canvas.getContext("2d");
            let o, s;
            n = void 0 === n || n,
            o = (r = r || !1) ? i.createLinearGradient(0, 0, 0, 256) : i.createLinearGradient(0, 0, 256, 0);
            for (var l = 0; l < t.length; l++) {
                var u;
                u = e[l] ? n ? new THREE.Color(e[l][0],e[l][1],e[l][2]).toHexString() : e[l] : n ? new THREE.Color(1,1,1).toHexString() : "rgb(255,255,255)",
                o.addColorStop(+t[l], u)
            }
            return i.fillStyle = o,
            r ? i.fillRect(0, 0, 1, 256) : i.fillRect(0, 0, 256, 1),
            s = r ? new Uint8Array(i.getImageData(0, 0, 1, 256).data.buffer) : new Uint8Array(i.getImageData(0, 0, 256, 1).data.buffer),
            a ? a.image = r ? {
                data: s,
                width: 1,
                height: 256
            } : {
                data: s,
                width: 256,
                height: 1
            } : a = r ? new THREE.DataTexture(s,1,256) : new THREE.DataTexture(s,256,1),
            a.magFilter = a.minFilter = THREE.LinearFilter,
            a.needsUpdate = !0,
            a
        },
        _generateHalfTexture() {
            if (!this._halfTexture) {
                const t = new Uint8Array(512);
                for (let e = 0; e < 128; e++)
                    t[4 * e + 0] = 255,
                    t[4 * e + 1] = e < 64 ? 0 : 255,
                    t[4 * e + 2] = 255,
                    t[4 * e + 3] = 255;
                this._halfTexture = new THREE.DataTexture(t,128,1,THREE.RGBAFormat),
                this._halfTexture.needsUpdate = !0
            }
            return this._halfTexture
        },
        createBoundingBox(t) {
            var e, n, r = new THREE.Box3;
            e = t.center,
            n = t.radius instanceof Array ? t.radius : [t.radius, t.radius, t.radius],
            e = (new THREE.Vector3).fromArray(e);
            var a = (new THREE.Vector3).fromArray(n);
            return r.setFromCenterAndSize(e, a),
            r
        },
        _createGeoBoundary(t) {
            let e = this;
            var n = t.coordinates
              , r = void 0 === t.type ? "vertical" : t.type
              , a = THING.Utils.parseValue(t.uvRatio, [1, 1])
              , i = void 0 === t.lineCount ? 6 : t.lineCount
              , o = void 0 === t.blending || t.blending
              , s = void 0 === t.extrudeHeight ? 8e3 : t.extrudeHeight
              , l = void 0 === t.offsetHeight ? 0 : t.offsetHeight
              , u = t.wallImage
              , c = t.lineImage
              , h = void 0 === t.scrollSpeed ? [0, 0] : t.scrollSpeed
              , d = void 0 === t.alphaSpeed ? [0, 0] : t.alphaSpeed
              , f = void 0 === t.color ? [255, 255, 255] : t.color;
            f = CMAP.Util.colorFormatNewToOld(f);
            let p = THING.Utils.parseColor(f);
            var m = t.parentObj;
            n = _GeometryUtil__WEBPACK_IMPORTED_MODULE_1__.a._processGeojson(n, "LINE"),
            n = _GeometryUtil__WEBPACK_IMPORTED_MODULE_1__.a._processGeojson(n, "POLYGON");
            let g = this._getPolygonCenterCoordinates(n)
              , v = this.convertLonlatToWorld(g);
            m || (m = this.app.create({
                type: "BaseObject",
                independent: !0,
                name: "geoBoundary_" + Util.getUUID()
            }));
            for (let f = 0; f < n.length; f++) {
                let g = n[f];
                var y = this._getBuildingGround(g, v, l);
                0 === m.angles[0] && (m.position = v,
                m.angles = y.referenceNode.getAngles());
                var _ = this.getLineLength(g);
                Array.isArray(h) || (h = [h, 0]),
                Array.isArray(d) || (d = [d, 0]);
                var x = y.geometryArray;
                for (let n = 0; n < x.length; n++) {
                    let l = x[n];
                    var b = e.app.create({
                        type: "Boundary",
                        height: s,
                        scroll: !0,
                        image: u,
                        points: l,
                        independent: !0
                    });
                    if (b._material.blending = o ? THREE.AdditiveBlending : THREE.NormalBlending,
                    b._material.depthWrite = !1,
                    b._material.opacity = .7,
                    b._material.color = p,
                    b._material.map.wrapS = b._material.map.wrapT = THREE.RepeatWrapping,
                    b._material.map.repeat.set(s / _ * a[0], 1 * a[1]),
                    "vertical" === r && b.setScroll(h[0], -h[1]),
                    "horizontal" === r)
                        for (let t = 0; t < i; t++) {
                            let e = THING.App.current.create({
                                type: "Boundary",
                                height: s / i,
                                points: l,
                                independent: !0,
                                image: c
                            });
                            e._material.blending = THREE.AdditiveBlending,
                            e._material.depthWrite = !1,
                            e._material.map.wrapS = e._material.map.wrapT = THREE.ClampToEdgeWrapping,
                            e._material.map.repeat.set(s / _ * a[0], 1 * a[1]),
                            e._material.opacity = .8 - t * (.8 - .1) / i,
                            e._material.color = p,
                            m.add(e),
                            e.translate([0, t * s / i, 0])
                        }
                    if (m.add(b),
                    t.alphaImage) {
                        var w = new THREE.TextureLoader;
                        m.children.forEach(e=>{
                            e._material.alphaMap = w.load(t.alphaImage),
                            e._material.alphaMap.repeat.set(s / _, 1),
                            e._material.alphaMap.wrapS = e._material.alphaMap.wrapT = THREE.RepeatWrapping,
                            CMAP.Updater.add("updateAlphaMap" + e.queryID, function() {
                                e._material && e._material.alphaMap && (e._material.alphaMap.offset.x += .001 * d[0],
                                e._material.alphaMap.offset.y -= .001 * d[1])
                            })
                        }
                        )
                    }
                }
            }
            return m
        },
        _addObserver(t, e) {
            t._opacity = t.opacity,
            Object.defineProperty(t, "opacity", {
                configurable: !0,
                enumerable: !0,
                get: function() {
                    return t._opacity
                },
                set: function(n) {
                    e(n),
                    t._opacity = n
                }
            })
        },
        deleteGeometryAttribute(t, e) {
            let n = t.node
              , r = 0;
            return CMAP.getCurrentMap().pickIdBuffer.forEach(function(t) {
                t.node === n && (r = e + CMAP.pickIdStartNum + t.start)
            }),
            0 !== r ? this._deleteGeometryAttributeById(n, r) : (console.warn("invalid index,please check"),
            [])
        },
        _deleteGeometryAttributeById(t, e) {
            var n = []
              , r = t.getMeshes();
            for (let t = 0; t < r.length; t++) {
                var a = []
                  , i = r[t].geometry;
                if (i.attributes.id.array.indexOf(e) >= 0) {
                    var o, s, l = new THREE.BufferGeometry;
                    for (let t = 0; t < i.attributes.id.array.length; t++)
                        i.attributes.id.array[t] === e && (0 !== a.length && 2 !== a.length || a.push(t)),
                        i.attributes.id.array[t] !== e && (1 !== a.length && 3 !== a.length || a.push(t)),
                        t === i.attributes.id.array.length - 1 && 3 === a.length && i.attributes.id.array[t] === e && a.push(t + 1);
                    if (1 === a.length && 0 === a[0])
                        o = [0, 0],
                        s = [0, i.attributes.id.array.length];
                    else {
                        if (4 !== a.length)
                            return void THING.Utils.warn("根据geometryId删除geometry中的片段失败");
                        o = [a[0], a[1]],
                        s = [a[2], a[3]]
                    }
                    for (var u in i.attributes) {
                        var c = i.attributes[u]
                          , h = i.attributes[u].itemSize
                          , d = c.array.slice(0, o[0] * h)
                          , f = c.array.slice(o[0] * h, o[1] * h)
                          , p = c.array.slice(o[1] * h, s[0] * h)
                          , m = c.array.slice(s[0] * h, s[1] * h)
                          , g = c.array.slice(s[1] * h)
                          , v = this._float32Concat(d, p);
                        v = this._float32Concat(v, g);
                        var y = this._float32Concat(f, m);
                        i.addAttribute(u, new THREE.BufferAttribute(v,i.attributes[u].itemSize)),
                        l.addAttribute(u, new THREE.BufferAttribute(y,i.attributes[u].itemSize))
                    }
                    i.groups[0].count = i.groups[0].count - (a[1] - a[0]),
                    i.groups[1].start = i.groups[0].count,
                    i.groups[1].count = i.groups[1].count - (s[1] - s[0]),
                    l.addGroup(0, o[1] - o[0], 0),
                    l.addGroup(o[1] - o[0], s[1] - s[0], 1),
                    n.push(l)
                }
            }
            return n
        },
        _float32Concat(t, e) {
            var n = t.length
              , r = new Float32Array(n + e.length);
            return r.set(t),
            r.set(e, n),
            r
        },
        setLightGroup(t, e=0, n=null) {
            e += 180;
            let r = this.getAnglesFromPosition(t, e);
            this.app._lightGroup.position = t,
            this.app._lightGroup.angles = r
        },
        setLighting(t, e) {
            e = THING.Utils.parseValue(e, 2e3);
            let n = this.createBoundingBox({
                center: [0, 0, 0],
                radius: e
            });
            !t.ambientLight || !1 !== t.ambientLight.ambientFlag && !1 !== t.ambientLight.flag || (t.ambientLight.intensity = 0),
            !t.hemisphereLight || !1 !== t.hemisphereLight.hemisphereFlag && !1 !== t.hemisphereLight.flag || (t.hemisphereLight.intensity = 0),
            !t.mainLight || !1 !== t.mainLight.mainLightFlag && !1 !== t.mainLight.flag || (t.mainLight.intensity = 0),
            void 0 === t.secondaryLight && (t.secondaryLight = {
                shadow: !1,
                shadowQuality: "medium",
                intensity: 0,
                color: "#034bcf",
                alpha: 148.5,
                beta: 0
            }),
            !1 !== t.secondaryLight.secondaryFlag && !1 !== t.secondaryLight.flag || (t.secondaryLight.intensity = 0),
            void 0 === t.tertiaryLight && (t.tertiaryLight = {
                shadow: !1,
                shadowQuality: "medium",
                intensity: 0,
                color: "#034bcf",
                alpha: 148.5,
                beta: 0
            }),
            !1 !== t.tertiaryLight.tertiaryFlag && !1 !== t.tertiaryLight.flag || (t.tertiaryLight.intensity = 0),
            this.app._lightGroup.setConfig(t, n),
            t.mainLight.shadow ? CMAP.getCurrentMap()._updateEarthShadow || this._updateEarthShadow(!0) : THING.App.current.lighting.mainLight.shadow || this._updateEarthShadow(!1),
            this.app.renderer.shadowMap.needsUpdate = !0
        },
        _createSpotLight(t, e=null) {
            let n = this.app._lightGroup;
            e = e || n;
            let r = this.app.create({
                type: "SpotLight",
                parent: e,
                name: t
            })
              , a = new THING.AroundControl({
                radius: defaultSpotLighting.height
            });
            return r.addControl(a),
            r._control = a,
            this.setSpotLight(defaultSpotLighting, t),
            r
        },
        setSpotLight(t, e) {
            let n = window.t3djs.buffer.nodeBuffer.get("_lightGroup")
              , r = this.app.query(".SpotLight").query(e).objects;
            (!r || r.length <= 0) && ((r = []).push(this._createSpotLight(e)),
            r.push(this._createSpotLight(e, n))),
            r.map(e=>{
                this._setSpotLightConf(t, e)
            }
            )
        },
        _setSpotLightConf(t, e) {
            for (let n in defaultSpotLighting)
                if ("alpha" === n || "beta" === n || "height" === n) {
                    let r = e._control;
                    r && ("height" === n && void 0 !== t[n] ? r.radius = t[n] : void 0 !== t[n] && (r[n] = t[n]))
                } else
                    void 0 !== t[n] && (e[n] = t[n])
        },
        _checkUrlStatus(t) {
            var e = new XMLHttpRequest;
            return e.open("GET", t, !1),
            e.send(),
            200 === e.status
        },
        _getScanningMaxDistance(t) {
            var e = [t.extent.minX, t.extent.minY]
              , n = [t.extent.maxX, t.extent.maxY];
            return 1.2 * Util.getSphericalDistance(e, n)
        },
        _updateShadowNextFrame() {
            let t = this.app;
            setTimeout(()=>{
                t.renderer.shadowMap.needsUpdate = !0
            }
            , 10)
        },
        updateShadowBias(t) {
            this.app.query(".LightGroup")[0].mainLight.shadow.bias = t
        },
        decrypt: function(t) {
            var e = __webpack_require__(34);
            if ("object" == typeof t)
                return t;
            let n = e.enc.Utf8.parse("CityBuilder@2019")
              , r = e.AES.decrypt(t, n, {
                mode: e.mode.ECB,
                padding: e.pad.Pkcs7
            });
            return e.enc.Utf8.stringify(r).toString()
        },
        getQueryVariable(t) {
            for (var e = window.location.search.substring(1).split("&"), n = 0; n < e.length; n++) {
                var r = e[n].split("=");
                if (r[0] === t)
                    return r[1]
            }
        },
        getValue() {
            var t = document.getElementById("uearth").getAttribute("src")
              , e = {};
            if (-1 !== t.indexOf("?"))
                for (var n = t.substr(t.indexOf("?") + 1).split("&"), r = 0; r < n.length; r++)
                    e[n[r].split("=")[0]] = unescape(n[r].split("=")[1]);
            return e
        },
        _getUVRatio(t, e) {
            let n = this.getNewPolygonExtent(t)
              , r = this.convertLonlatToWebMercator([n.minX, n.minY])
              , a = this.convertLonlatToWebMercator([n.maxX, n.maxY])
              , i = (a[0] - r[0]) / 1e4
              , o = (a[1] - r[1]) / 1e4
              , s = [1, 1];
            return i > 0 && o > 0 && e && (s = [i * e, o * e]),
            s
        },
        _replaceSkyBox(t, e) {
            this.app.scene.background = t,
            this._rotateSkyBox(e)
        },
        _rotateSkyBox(t) {
            let e = THING.App.current.scene.background;
            e && (e.isCubeTexture || e.mapping === THREE.EquirectangularReflectionMapping) && (e.baseQuaternion = this.anglesToQuaternion(t))
        },
        _getMapConfigByParam(t, e) {
            let n = this._parseMapConfig(t);
            if (n && n.data && (n = n.data),
            "background" === e)
                return n[e]
        },
        correctSkyBox() {
            let t = THING.App.current.camera.target;
            if (THING.Math.getDistance([0, 0, 0], t) > 6377e3) {
                let e = Util.position2angles(t, 180);
                this._rotateSkyBox(e)
            }
        },
        _correctCampusBaseQuaternion(t) {
            let e = t.node.getWorldQuaternion(new THREE.Quaternion).inverse();
            t.node.getMaterials().map(t=>{
                t.baseQuaternion = e,
                t.needsUpdate = !0
            }
            )
        },
        createSkyAndSun(t) {
            let e = this.position2angles(t)
              , n = this.app.create({
                type: "Box",
                position: t,
                scale: [100, 100, 100],
                angles: e
            });
            return n.node.getMaterials()[0].colorWrite = !1,
            this.app.lighting = null,
            this.app.create({
                type: "SkyEffect",
                parent: n
            })
        },
        updateSkyAndSun(t, e) {
            if (t.setConfig(e),
            !(void 0 !== e.earthEffect && e.earthEffect))
                return;
            let n = t._config.time / 24 * 360 - 90
              , r = t._config.beta
              , a = THING.Utils.parseVector3(THING.Math.directionFromAlphaBeta(n, r));
            a.normalize();
            let i = THING.Math.dotVector(a.toArray(), [0, 1, 0])
              , o = THING.App.current.query(".TileLayer").objects;
            o.length > 0 && o.map(t=>{
                let e = .5 + i <= .2 ? .2 : .5 + i;
                e = e >= 1.2 ? 1.2 : e,
                t.style.brightness = e
            }
            )
        },
        objectAssign: function(t, e, n=!1) {
            if (!t || !e)
                throw new TypeError("Cannot convert argument to object");
            for (var r = Object.keys(t), a = 0, i = r.length; a < i; a++) {
                var o = r[a];
                Object.prototype.hasOwnProperty.call(t, o) && (Object.prototype.hasOwnProperty.call(e, o) && !n ? e[o + "_1"] = t[o] : e[o] = t[o])
            }
            return e
        },
        mergeRecursive: function(t, e) {
            for (var n in e)
                try {
                    e[n].constructor === Object ? t[n] = Util.mergeRecursive(t[n], e[n]) : t[n] = e[n]
                } catch (r) {
                    t[n] = e[n]
                }
            return t
        },
        _getLocalLightParam: function(t, e) {
            var n = this.app.query(".LightGroup")[0]
              , r = n[t].position.clone()
              , a = r.clone().transformDirection(n.node.matrixWorld)
              , i = new THREE.Group;
            i.applyMatrix(e.node.matrixWorld),
            i.translateY(1);
            var o = (new THREE.Vector3).subVectors(i.position.clone(), e.node.position.clone());
            i.translateY(-1),
            i.translateX(1);
            (new THREE.Vector3).subVectors(i.position.clone(), e.node.position.clone());
            i.translateX(-1),
            i.translateZ(1);
            var s = (new THREE.Vector3).subVectors(i.position.clone(), e.node.position.clone())
              , l = a.clone().projectOnPlane(o)
              , u = l.clone().angleTo(s)
              , c = new THREE.Matrix4;
            c.getInverse(e.node.matrix.clone()),
            l.clone().transformDirection(c).x < 0 && (u = -u);
            var h = a.clone().applyAxisAngle(o, -u).clone().angleTo(s);
            return r.y < 0 && (h = -h),
            u = Math.radToDeg(u),
            {
                alpha: h = Math.radToDeg(h),
                beta: u
            }
        },
        _getAxis(t, e) {
            var n = new THREE.Group;
            return n.applyMatrix4(e.node.matrixWorld),
            "x" === t.toLowerCase() ? n.translateX(1) : "y" === t.toLowerCase() ? n.translateY(1) : "z" === t.toLowerCase() && n.translateZ(1),
            (new THREE.Vector3).subVectors(n.position.clone(), e.node.position.clone())
        },
        caculateBezier(t, e, n, r) {
            r = void 0 === r ? 50 : r;
            var a = new THREE.Vector3(t[0],t[1],t[2])
              , i = new THREE.Vector3(e[0],e[1],e[2])
              , o = new THREE.Vector3(n[0],n[1],n[2])
              , s = new THREE.QuadraticBezierCurve3(a,i,o).getPoints(r)
              , l = [];
            return s.map(function(t) {
                l.push([t.x, t.y, t.z])
            }),
            l
        },
        caculateCubicBezier(t, e, n, r, a) {
            a = void 0 === a ? 50 : a;
            var i = new THREE.Vector3(t[0],t[1],t[2])
              , o = new THREE.Vector3(e[0],e[1],e[2])
              , s = new THREE.Vector3(n[0],n[1],n[2])
              , l = new THREE.Vector3(r[0],r[1],r[2])
              , u = new THREE.CubicBezierCurve3(i,o,s,l).getPoints(a)
              , c = [];
            return u.map(function(t) {
                c.push([t.x, t.y, t.z])
            }),
            c
        },
        _updateEarthShadow(t) {
            let e = this;
            this.app.renderer.shadowMap.autoUpdate = t;
            const n = this.app.query(".LightGroup")[0];
            function r(t) {
                t < 9 ? n.setDistance(1e3, void 0, void 0) : t > 14 ? n.setDistance(Math.max(1e3, 5 * e.app.camera.getEarthCameraInfo().height), void 0, void 0) : n.setDistance(Math.max(1e3, 3 * e.app.camera.getEarthCameraInfo().height), void 0, void 0)
            }
            t ? (r(this.map.currentLevel),
            this.app.on("update", t=>{
                r(this.map.currentLevel)
            }
            , "EarthShadowUpdater")) : this.app.off("update", "EarthShadowUpdater"),
            this.map._updateEarthShadow = t
        },
        _convertToCesiumCameraParam() {
            let t = this.app.camera.getCameInfo()
              , e = this.app.camera.position
              , n = this.convertWorldToLonlat(e);
            return "viewer.camera.flyTo({destination : Cesium.Cartesian3.fromDegrees(" + n[0] + "," + n[1] + "," + n[2] + "),orientation : { heading : Cesium.Math.toRadians(" + -t.heading + "),pitch : Cesium.Math.toRadians(" + -t.pitch + "),roll : 0.0}})"
        },
        _toObject(t) {
            var e;
            if (t)
                for (var n in e = {},
                CMAP.Util.objectAssign(t, e),
                e) {
                    if (n.startsWith("_"))
                        e[n.replace("_", "")] = e[n],
                        delete e[n]
                }
            return e
        },
        _toPrivate(t) {
            var e;
            if (t)
                for (var n in e = {},
                CMAP.Util.objectAssign(t, e),
                e) {
                    if (!n.startsWith("_"))
                        e["_" + n] = e[n],
                        delete e[n]
                }
            return e
        },
        _parseBlending: t=>t ? THREE.AdditiveBlending : THREE.NormalBlending,
        _updateCameraNearFar() {
            this.map._earthInstance.tileEarth._updateCameraNearFar()
        },
        getHeightByCoordinates(t, e=!1) {
            if (Array.isArray(t)) {
                let n = CMAP.Util.convertLonlatToWorld(t, 1e4)
                  , r = new THREE.Vector3(n[0],n[1],n[2]).negate().normalize()
                  , a = new THREE.Raycaster(new THREE.Vector3(n[0],n[1],n[2]),r)
                  , i = [];
                if (e) {
                    this.app.query(".Tile3dLayer").forEach(t=>{
                        i.push(t.node)
                    }
                    )
                } else
                    i.push(t3djs.buffer.nodeBuffer.get("tiles-root"));
                for (let t = 0; t < i.length; t++) {
                    const e = i[t];
                    if (e && e.ensureVisible()) {
                        let t = a.intersectObjects(e.children, !0);
                        if (t.length > 0) {
                            return CMAP.Util.convertWorldToLonlat(t[0].point.toArray())[2]
                        }
                    }
                }
            } else
                console.warn("array is needed");
            return 0
        },
        getEarthCampusIntersectPoint(t) {
            const e = t.boundingBox
              , n = t.getLocalBoundingBox().size[1]
              , r = (new THREE.Vector3).fromArray(e.center)
              , a = r.clone().normalize()
              , i = r.length() - n / 2;
            Util._campusTargetPlane || (Util._campusTargetPlane = new THREE.Plane(a,i),
            Util._planeHelper = new THREE.PlaneHelper(Util._campusTargetPlane,1e3,16711680),
            THING.App.current.scene.add(Util._planeHelper),
            Util._line3 = new THREE.Line3(new THREE.Vector3,new THREE.Vector3)),
            Util._campusTargetPlane.set(a.multiplyScalar(-1), i),
            Util._planeHelper.updateMatrixWorld();
            const o = THING.App.current
              , s = o.camera.position
              , l = o.camera.direction;
            return Util._line3.start.set(s[0], s[1], s[2]),
            Util._line3.end.set(s[0] + 1e7 * l[0], s[1] + 1e7 * l[1], s[2] + 1e7 * l[2]),
            Util._campusTargetPlane.intersectLine(Util._line3, new THREE.Vector3)
        },
        isNum: t=>null != t && "NaN" !== parseFloat(t).toString(),
        _needsUpdateExtrudeField(t) {
            if (!THING.Utils.isNull(t)) {
                if ("" === this._extrudeField) {
                    if ("" !== t || null == t)
                        return !1
                } else if (this._extrudeField === t)
                    return !1;
                return !0
            }
            return !1
        }
    };
    __webpack_exports__.a = Util
}
, function(t, e, n) {
    "use strict";
    var r = n(0)
      , a = {
        _defaultWindowTextureSize: [300, 300],
        _defaultLineTextureSize: 100,
        _defaultBuildingTextureSize: [3, 3],
        _processGeometry(t, e, n, r) {
            let a = t.attributes.position.array
              , i = t.attributes.position.count;
            for (let t = 0; t < i; t++) {
                let i = [a[3 * t], a[3 * t + 1] + r, a[3 * t + 2]]
                  , o = e.convertLocalToWorldPosition(i)
                  , s = n.convertWorldToLocalPosition(o);
                a[3 * t] = s[0],
                a[3 * t + 1] = s[1],
                a[3 * t + 2] = s[2]
            }
        },
        _setNodeAnglesByPosition(t, e) {
            let n = r.a._getAnglesFromPosition(e, 180);
            var a = r.a.anglesToQuaternion(n);
            t.setRotationFromQuaternion(a),
            t.updateMatrixWorld()
        },
        createBuilding: function(t, e, n, r, i, o, s, l, u, c, h, d) {
            void 0 === s && (s = 0);
            var f = new THREE.Group;
            f.setPosition(n),
            a._setNodeAnglesByPosition(f, n);
            var p = []
              , m = a.createBuildingGeometry(t, e, f, !0, r, i, o, s, l, u, c, h, d);
            if (!o) {
                for (var g = 0, v = m.length; g < v; g++)
                    p.push(m[g]);
                return {
                    referenceNode: f,
                    geometryArray: p
                }
            }
        },
        createBuildingGeometry: function(t, e, n, i, o, s, l, u, c, h, d, f, p) {
            void 0 === i && (i = !0),
            o = o || "BUILDING";
            for (var m = [], g = 0, v = (t = this._processGeojson(t, "Building")).length; g < v; g++) {
                var y;
                if ("BUILDING" === o && c) {
                    y = new THREE.Group;
                    let e = this.getReferencePosition(t[g]);
                    y.setPosition(e),
                    a._setNodeAnglesByPosition(y, e)
                } else
                    y = n;
                var _ = []
                  , x = []
                  , b = [];
                let v = u;
                Array.isArray(u) && (v = u[g]),
                isNaN(v) && (v = 0);
                for (let e = 0; e < t[g].length; e++) {
                    for (var w = [], C = t[g][e], E = 0, T = C.length; E < T; E++) {
                        let t, n = v;
                        i ? (p && (n += p[g][e][E]),
                        t = r.a.convertLonlatToWorld(C[E], n)) : t = C[E];
                        var M = y.convertWorldToLocalPosition(t);
                        let a = M[1];
                        "BUILDING" !== o || c || (a = 0),
                        0 === e ? (_.push(M[0]),
                        _.push(a),
                        _.push(M[2])) : (w.push(M[0]),
                        w.push(a),
                        w.push(M[2])),
                        b.push([M[0], M[1], M[2]])
                    }
                    w.length > 0 && x.push(w)
                }
                if ("BUILDING" === o) {
                    b = [];
                    var A = {
                        position: _,
                        holes: x
                    };
                    if (l)
                        l._referenceNodeList || (l._referenceNodeList = [],
                        l._offsetHeightList = []),
                        l._referenceNodeList.push(y.matrix.toArray()),
                        l._offsetHeightList.push(v),
                        t3djs.util.createGeometry("BUILDING", A, {
                            building: {
                                height: e,
                                id: d,
                                vis: f,
                                buildingTextureSize: s,
                                buildingMaskTextureSize: [30, 60],
                                buildingWindowTextureSize: h || this._defaultWindowTextureSize,
                                manager: l
                            }
                        });
                    else {
                        var P = t3djs.util.createGeometry("BUILDING", A, {
                            building: {
                                height: e,
                                buildingTextureSize: s,
                                buildingMaskTextureSize: [30, 60],
                                buildingWindowTextureSize: h || this._defaultWindowTextureSize
                            }
                        });
                        y === n || y.matrix.equals(n.matrix) || this._processGeometry(P, y, n, 0),
                        m.push(P)
                    }
                } else
                    "BOUNDARY" === o && (_ = [],
                    m.push(b))
            }
            return m
        },
        getReferencePosition(t, e) {
            for (; Array.isArray(t[0]); )
                t = t[0];
            return CMAP.Util.convertLonlatToWorld(t, e)
        },
        _processGeojson: function(t, e) {
            var n = JSON.stringify(t);
            const r = e.toUpperCase();
            if ("LINEHEIGHT" === r)
                0 === n.indexOf("[") && 0 !== n.indexOf("[[") && (t = [t]);
            else if (r.contains("POLYGON") || r.contains("BUILDING") || r.contains("BOUNDARYPOLYGON")) {
                if (0 === n.indexOf("[[") && 0 !== n.indexOf("[[[") && (t = [[t]]),
                0 === n.indexOf("[[[") && 0 !== n.indexOf("[[[[") && (t = [t]),
                "BOUNDARYPOLYGON" !== r) {
                    var i = [];
                    t.forEach(function(n) {
                        e.toUpperCase().contains("POLYGON") ? a.hasHole(n) ? i.push(n) : (n.forEach(function(t) {
                            i.push([t])
                        }),
                        t = i) : i.push(n)
                    })
                }
            } else
                r.contains("LINE") && 0 === n.indexOf("[[") && 0 !== n.indexOf("[[[") && (t = [t]);
            return t
        },
        _setUV(t, e) {
            "stretch" === t ? e.addAttribute("uv", e.attributes.uv2) : e.addAttribute("uv", e.attributes.uv1)
        },
        _processHeightArrayFromCoordinates(t, e) {
            if (t = a._processLineCoordinates(t, e),
            e) {
                const n = [];
                for (let e = 0; e < t.length; e++) {
                    const r = []
                      , a = t[e];
                    for (let t = 0; t < a.length; t++)
                        r.push(a[t][2]);
                    n.push(r)
                }
                e = n
            }
            return {
                lineData: t,
                heightArray: e
            }
        },
        createLine: function(t, e, n, r, i, o, s, l=!1, u) {
            s || (s = "stretch");
            var c = new THREE.Group;
            if (n)
                c.setPosition(n),
                this._setNodeAnglesByPosition(c, n);
            else {
                var h = this.getReferencePosition(t)
                  , d = CMAP.Util.convertLonlatToWorld(h);
                c.setPosition(d),
                this._setNodeAnglesByPosition(c, d)
            }
            let f = this._processGeojson(t, "Line");
            if (e && (e = this._processGeojson(e, "LineHeight")),
            l) {
                const t = a._processHeightArrayFromCoordinates(f, e);
                f = t.lineData,
                e = t.heightArray
            }
            let p = this.createUV(f, e);
            var m = a.createLineGeometry(f, c, r, i, e, !0, o, u);
            if ("Line" === r)
                for (let t = 0; t < m.length; t++) {
                    let e = m[t]
                      , n = p.segs[t];
                    e.addAttribute("uv", new THREE.Float32BufferAttribute(n,2));
                    let r = []
                      , i = p.totalLengthArray[t] / o;
                    for (let t = 0; t < e.attributes.uv.count; t += 1)
                        r[2 * t] = n[2 * t] * i,
                        r[2 * t + 1] = n[2 * t + 1];
                    e.addAttribute("uv2", new THREE.Float32BufferAttribute(n,2)),
                    e.addAttribute("uv1", new THREE.Float32BufferAttribute(r,2)),
                    a._setUV(s, e)
                }
            else if ("Plane" === r)
                for (let t = 0; t < m.length; t++) {
                    let e = m[t]
                      , n = p.segs[t]
                      , r = new Float32Array(2 * n.length)
                      , a = new Float32Array(2 * n.length);
                    for (let t = 0; t < n.length / 2; t += 1)
                        r[4 * t] = n[2 * t],
                        r[4 * t + 1] = 0,
                        r[4 * t + 2] = n[2 * t],
                        r[4 * t + 3] = 1;
                    for (let t = 0; t < n.length; t++)
                        a[2 * t] = n[t],
                        a[2 * t + 1] = n[t];
                    e.addAttribute("uv2", new THREE.BufferAttribute(r,2));
                    let i = e.attributes.uv.array;
                    e.addAttribute("uv1", new THREE.BufferAttribute(i,2)),
                    this._setUV(s, e)
                }
            else
                for (let t = 0; t < m.length; t++) {
                    let e = m[t];
                    e.addAttribute("uv1", e.attributes.uv),
                    this._setUV(s, e)
                }
            return {
                referenceNode: c,
                geometryArray: m,
                totalLengthArray: p.totalLengthArray,
                uvArray: p.uvObjectArray
            }
        },
        _processLineCoordinates(t, e) {
            const n = [];
            for (let o = 0; o < t.length; o++) {
                const s = t[o];
                let l;
                e && e.length === t.length && (l = e[o]);
                const u = []
                  , c = [];
                for (let t = 0; t < s.length; t++) {
                    let e = 0;
                    l && l.length === s.length && (e = l[t]);
                    const n = r.a.convertLonlatToWorld(s[t], e);
                    u.push(Cesium.Cartesian3.fromArray(n))
                }
                const h = new Cesium.SimplePolylineGeometry({
                    positions: u,
                    width: .001
                })
                  , d = Cesium.SimplePolylineGeometry.createGeometry(h);
                if (d.attributes) {
                    var a = d.attributes.position.values;
                    for (let t = 0; t < a.length; t += 3) {
                        var i = CMAP.Util.convertWorldToLonlat([a[t], a[t + 1], a[t + 2]]);
                        c.push(i)
                    }
                }
                n.push(c)
            }
            return n
        },
        createLineGeometry: function(t, e, n, a, i, o, s, l) {
            void 0 === o && (o = !0),
            void 0 === s && (s = this._defaultLineTextureSize);
            let u = this._processGeojson(t, "Line");
            var c = u.length
              , h = new Array(c)
              , d = !1;
            i && i.length === c && (d = !0);
            for (var f = 0; f < c; f++) {
                var p = []
                  , m = []
                  , g = u[f];
                d && i[f].length !== g.length && (d = !1);
                for (var v = 0; v < g.length; v++) {
                    var y;
                    if (o) {
                        let t = l;
                        null == l && (t = r.a.convertWorldToLonlat(e.position)[2]),
                        d && (t += i[f][v]),
                        y = r.a.convertLonlatToWorld(g[v], t)
                    } else
                        y = g[v];
                    var _ = e.convertWorldToLocalPosition(y);
                    p.push(_[0]),
                    p.push(_[1]),
                    p.push(_[2]),
                    v < g.length - 1 && (m.push(v),
                    m.push(v + 1))
                }
                var x = {
                    position: p,
                    index: m
                }
                  , b = this._getT3dLineType(n)
                  , w = t3djs.util.createGeometry(b, x, {
                    line: {
                        width: a,
                        up: [0, 1, 0],
                        uvRatio: 1,
                        uStep: s
                    }
                });
                h[f] = w
            }
            return h
        },
        createLineMesh: function(t, e, n) {
            var r;
            return e.techniques && (e = e.techniques[0].passes[0].material),
            r = "Line" === n.lineType ? new THREE.LineSegments(t,e) : new THREE.Mesh(t,e),
            this._updateEffect(r, "lineBloom", n.effect, n._glowStrength),
            r
        },
        _updateEffect(t, e, n, r) {
            n ? THING.App.current.effectManager.setEffect(t, e, r) : THING.App.current.effectManager.removeEffect(t, e)
        },
        createBuildingMesh: function(t, e, n) {
            var r = n.textureWrap;
            this._updateBuildingTextureWrap(t, r);
            var a = new THREE.Mesh(t,e);
            return a.castShadow = !0,
            a.receiveShadow = !0,
            a
        },
        _updateBuildingTextureWrap: (t,e)=>(e === CMAP.TextureWrapMode.RepeatY && t.attributes.uv1 ? t.addAttribute("uv", t.attributes.uv1, 2) : e === CMAP.TextureWrapMode.Stretch && t.attributes.uv2 ? t.addAttribute("uv", t.attributes.uv2, 2) : e === CMAP.TextureWrapMode.Repeat && t.attributes.uv3 && t.addAttribute("uv", t.attributes.uv3, 2),
        t.attributes.uv.needsUpdate = !0,
        t),
        createUV(t, e, n) {
            let r = []
              , i = []
              , o = [];
            for (let l = 0; l < t.length; l++) {
                let u = [];
                var s;
                s = e ? a._createLineTC(t[l], e[l], n) : a._createLineTC(t[l], void 0, n),
                i.push(s);
                for (let t = 0; t < s.segs.length; t++)
                    u.push(s.segs[t].endPoint.textureCoord[0]),
                    u.push(s.segs[t].endPoint.textureCoord[1]);
                o.push(s.totalLength),
                r.push(u)
            }
            return {
                uvArray: i,
                segs: r,
                totalLengthArray: o
            }
        },
        _createLineTC(t, e, n) {
            void 0 === n && (n = !0);
            var a, i = 0, o = [];
            a = n ? e ? r.a.convertLonlatToWorld(t[0], e[0]) : r.a.convertLonlatToWorld(t[0], 1) : t[0];
            for (var s = 0; s < t.length; s += 1) {
                var l;
                l = n ? e ? r.a.convertLonlatToWorld(t[s], e[s]) : r.a.convertLonlatToWorld(t[s], 1) : t[s];
                var u = t3djs.math.subtractVectors(l, a)
                  , c = t3djs.math.vectorLength(u);
                i += c,
                o.push({
                    startPoint: a,
                    endPoint: l,
                    length: c,
                    dir: t3djs.math.normalizeVector(u)
                }),
                a = l
            }
            for (var h = 0, d = 0; d < o.length; d += 1) {
                var f = o[d]
                  , p = h / i
                  , m = [p, p];
                f.startPoint.textureCoord = m;
                var g = (h += f.length) / i
                  , v = [g, g];
                f.endPoint.textureCoord = v
            }
            return {
                segs: o,
                totalLength: i
            }
        },
        _getT3dLineType(t) {
            var e = "";
            return "Line" === t ? e = "LINE_STRIP" : "Plane" === t ? e = "LINE_PLANE_SPRITE" : "Pipe" === t ? e = "LINE_LOFT" : "Route" === t && (e = "LINE_PLANE"),
            e
        },
        _isRectangle: t=>1 === t.length && 1 === t[0].length && 5 === t[0][0].length && t[0][0][0][0] === t[0][0][1][0] && t[0][0][0][1] === t[0][0][3][1] && -180 === t[0][0][0][0] && -90 === t[0][0][0][1],
        createRectangleGeometry(t, e, n, a, i, o) {
            i = THING.Utils.parseValue(i, 0),
            n = THING.Utils.parseValue(n, 0);
            let s = t.maxY
              , l = t.maxX
              , u = t.minX
              , c = t.minY;
            const h = {
                north: s * Math.PI / 180,
                east: l * Math.PI / 180,
                west: u * Math.PI / 180,
                south: c * Math.PI / 180
            };
            var d = r.a.convertLonlatToWebMercator([t.minX, t.minY])
              , f = r.a.convertLonlatToWebMercator([t.maxX, t.maxY]);
            const p = d[0]
              , m = f[0]
              , g = d[1]
              , v = f[1];
            h.north === Math.PI / 2 && (h.north -= .001),
            h.south === -Math.PI / 2 && (h.south += .001);
            const y = new Cesium.RectangleGeometry({
                rectangle: h,
                height: n + i,
                extrudedHeight: n
            })
              , _ = Cesium.RectangleGeometry.createGeometry(y)
              , x = _.attributes.normal.values
              , b = _.indices
              , w = _.attributes.position.values
              , C = _.attributes.st.values
              , E = new Float32Array(w.length);
            for (var T = new Float32Array(C.length), M = new Float32Array(C.length), A = 0; A < w.length / 3; A++) {
                if (E[3 * A] = -w[3 * A],
                E[3 * A + 1] = w[3 * A + 2],
                E[3 * A + 2] = w[3 * A + 1],
                a) {
                    const t = [E[3 * A], E[3 * A + 1], E[3 * A + 2]]
                      , e = a.convertWorldToLocalPosition(t)
                      , n = new THREE.Vector3(t[0],t[1],t[2])
                      , r = new THREE.Matrix4;
                    r.getInverse(a.matrix);
                    const i = n.transformDirection(r);
                    E[3 * A] = e[0],
                    E[3 * A + 1] = e[1],
                    E[3 * A + 2] = e[2],
                    x[3 * A] = i.x,
                    x[3 * A + 1] = i.y,
                    x[3 * A + 2] = i.z
                }
                const t = CMAP.Util.world2Lonlat([-w[3 * A], w[3 * A + 2], w[3 * A + 1]])
                  , e = CMAP.Util.convertLonlatToWebMercator(t);
                o = THING.Utils.parseValue(o, [m - p, v - g]);
                const n = (e[0] - p) / o[0]
                  , r = 1 - (v - e[1]) / o[1]
                  , i = (t[0] - u) / (l - u)
                  , h = 1 - (s - t[1]) / (s - c);
                T[2 * A] = n,
                T[2 * A + 1] = r,
                M[2 * A] = i,
                M[2 * A + 1] = h
            }
            var P = new THREE.BufferGeometry;
            P.setIndex(new THREE.BufferAttribute(b,1)),
            P.addAttribute("position", new THREE.BufferAttribute(E,3)),
            P.addAttribute("uv1", new THREE.BufferAttribute(T,2)),
            P.addAttribute("uv2", new THREE.BufferAttribute(M,2)),
            e ? P.addAttribute("uv", new THREE.BufferAttribute(T,2)) : P.addAttribute("uv", new THREE.BufferAttribute(M,2)),
            P.addAttribute("normal", new THREE.BufferAttribute(x,3));
            const S = b.length;
            return P.addGroup(0, S, 0),
            P
        },
        _updateAllUv: (t,e,n)=>0 === t || e.indexOf(n) >= 0,
        createPolygonGeometry(t, e, n, a, i, o, s, l, u, c) {
            o = THING.Utils.parseValue(o, !0),
            s = THING.Utils.parseValue(s, !0),
            i = THING.Utils.parseValue(i, CMAP.Util.getPolygonExtent(t)),
            u = THING.Utils.parseValue(u, !1),
            c = THING.Utils.parseValue(c, "Plane"),
            n = THING.Utils.parseValue(n, 0);
            const h = CMAP.Util.convertLonlatToWebMercator([i.minX, i.minY])
              , d = CMAP.Util.convertLonlatToWebMercator([i.maxX, i.maxY])
              , f = {
                minX: h[0],
                maxX: d[0],
                minY: h[1],
                maxY: d[1]
            };
            o && (i = f);
            const p = [f.maxX - f.minX, f.maxY - f.minY];
            l || (l = p);
            const m = []
              , g = [];
            let v = [];
            if (this._isRectangle(t)) {
                const r = {
                    minX: t[0][0][0][0],
                    minY: t[0][0][0][1],
                    maxX: t[0][0][2][0],
                    maxY: t[0][0][2][1]
                }
                  , i = this.createRectangleGeometry(r, o, n, e, a, l);
                m.push(i);
                const s = new Cesium.Rectangle(r.minX * Math.PI / 180,r.minY * Math.PI / 180,r.maxX * Math.PI / 180,r.maxY * Math.PI / 180);
                s.offsetHeight = n,
                g.push(s)
            } else
                for (let s = 0; s < t.length; s++) {
                    const c = []
                      , h = [];
                    let d = n;
                    Array.isArray(n) && (d = n[s]),
                    isNaN(d) && (d = 0);
                    for (let e = 0; e < t[s].length; e++) {
                        let n = t[s][e];
                        if (0 === e)
                            for (let t = 0; t < n.length; t++) {
                                const e = r.a.convertLonlatToWorld(n[t]);
                                c.push(Cesium.Cartesian3.fromArray(e))
                            }
                        else {
                            let t = [];
                            for (let e = 0; e < n.length; e++) {
                                let a = r.a.convertLonlatToWorld(n[e]);
                                t.push(Cesium.Cartesian3.fromArray(a))
                            }
                            let e = new Cesium.PolygonHierarchy(t);
                            e.offsetHeight = d,
                            h.push(e),
                            g.push(e)
                        }
                    }
                    const f = new Cesium.PolygonHierarchy(c,h)
                      , p = new Cesium.PolygonHierarchy(c);
                    p.offsetHeight = d,
                    g.push(p);
                    const v = new Cesium.PolygonGeometry({
                        polygonHierarchy: f,
                        extrudedHeight: d,
                        height: d + a,
                        closeBottom: u,
                        closeTop: !0,
                        wall: !0
                    })
                      , y = Cesium.PolygonGeometry.createGeometry(v);
                    if (y) {
                        const t = y.indices
                          , n = y.attributes.position.values
                          , r = y.attributes.normal.values
                          , s = new Float32Array(n.length)
                          , u = new Float32Array(r.length)
                          , c = new Float32Array(n.length)
                          , h = y.attributes.st.values
                          , d = new Float32Array(h.length)
                          , f = y.groups[0]
                          , p = y.indices.slice(f.start, f.count);
                        for (let t = 0; t < n.length / 3; t++) {
                            const r = [n[3 * t], n[3 * t + 1], n[3 * t + 2]];
                            if (this._updateAllUv(a, p, t)) {
                                let e = CMAP.Util.world2Lonlat(r);
                                o && (e = CMAP.Util.lonlat2Mercator(e));
                                let n = (e[0] - i.minX) / (i.maxX - i.minX)
                                  , a = 1 - (i.maxY - e[1]) / (i.maxY - i.minY);
                                n < 0 && (n = 0),
                                n > 1 && (n = 1),
                                a < 0 && (a = 0),
                                a > 1 && (a = 1),
                                d[2 * t] = n * (i.maxX - i.minX) / l[0],
                                d[2 * t + 1] = a * (i.maxY - i.minY) / l[1]
                            } else
                                d[2 * t] = h[2 * t],
                                d[2 * t + 1] = h[2 * t + 1];
                            const f = e.convertWorldToLocalPosition(r)
                              , m = new THREE.Vector3(r[0],r[1],r[2])
                              , g = new THREE.Matrix4;
                            g.getInverse(e.matrix);
                            const v = m.transformDirection(g);
                            s[3 * t] = f[0],
                            s[3 * t + 1] = f[1],
                            s[3 * t + 2] = f[2],
                            u[3 * t] = v.x,
                            u[3 * t + 1] = v.y,
                            u[3 * t + 2] = v.z;
                            const y = CMAP.Util.convertWorldToLonlat(r);
                            c[3 * t] = y[0],
                            c[3 * t + 1] = y[1],
                            c[3 * t + 2] = y[2]
                        }
                        const g = new THREE.BufferGeometry;
                        g.setIndex(new THREE.BufferAttribute(t,1)),
                        g.addAttribute("position", new THREE.BufferAttribute(s,3)),
                        g.addAttribute("coordinates", new THREE.BufferAttribute(c,3)),
                        g.addAttribute("uv", new THREE.BufferAttribute(d,2)),
                        g.addAttribute("uv2", new THREE.BufferAttribute(d,2)),
                        g.addAttribute("normal", new THREE.BufferAttribute(u,3)),
                        g.groups = y.groups,
                        m.push(g)
                    }
                }
            m.length > 0 && (v = t3djs.util.mergeBufferGeometry(m, 1e6, !0));
            let y = {
                polygonGeometry: v
            };
            return y.sizeInMeter = p,
            y.textureSize = l,
            y.outLinePolygonHierarchyArray = g,
            y
        },
        _createPolygonOutLineParam(t, e, n) {
            let r;
            if (e || (e = .1),
            t.__proto__ === Cesium.Rectangle.prototype) {
                const a = new Cesium.RectangleOutlineGeometry({
                    rectangle: t,
                    extrudedHeight: n,
                    height: n + e
                });
                r = Cesium.RectangleOutlineGeometry.createGeometry(a)
            } else {
                var a = new Cesium.PolygonOutlineGeometry({
                    polygonHierarchy: t,
                    extrudedHeight: n,
                    height: n + e
                });
                r = new Cesium.PolygonOutlineGeometry.createGeometry(a)
            }
            let i = []
              , o = [];
            if (r.attributes) {
                for (var s = r.attributes.position.values, l = [s[0], s[1], s[2]], u = 0; u < s.length; u += 3)
                    if (u < s.length / 2) {
                        var c = CMAP.Util.convertWorldToLonlat([s[u], s[u + 1], s[u + 2]]);
                        i.push(c)
                    }
                var h = CMAP.Util.convertWorldToLonlat(l);
                i.push(h),
                i.forEach(function(t) {
                    o.push(t[2])
                })
            }
            return {
                coordinates: i,
                heightArray: o
            }
        },
        createBoundaryGeometry(t, e, n, a, i) {
            var o = [];
            for (let l = 0; l < t.length; l++) {
                let u, c = t[l];
                i && (u = i[l]);
                let h = n;
                Array.isArray(n) && (h = n[l]),
                isNaN(h) && (h = 0);
                var s = r.a._getBuildingGround(c, a, h, u, !0).geometryArray;
                for (let t = 0; t < s.length; t++) {
                    let n = s[t];
                    let a = THING.App.current.create({
                        type: "Boundary",
                        height: e,
                        scroll: !0,
                        points: n,
                        independent: !0
                    }).node.getGeometries()[0]
                      , i = (new THREE.BufferGeometry).fromGeometry(a)
                      , l = i.attributes.uv.array
                      , u = []
                      , h = e / r.a.getLineLength(c);
                    for (let t = 0; t < i.attributes.uv.count; t += 1)
                        u[2 * t] = l[2 * t] * h,
                        u[2 * t + 1] = l[2 * t + 1];
                    i.addAttribute("uv", new THREE.Float32BufferAttribute(u,2)),
                    o.push(i)
                }
            }
            return o
        },
        processPolygon(t, e, n="POLYGON") {
            t = this._processGeojson(t, n);
            var a = r.a.getCenterOfGravityPoint(t[0][0])
              , i = r.a.getCenterCoordinates(t[0][0]);
            return {
                gravityCenter: a,
                gravityCenterWorld: r.a.convertLonlatToWorld(a, e),
                center: i,
                centerWorld: r.a.convertLonlatToWorld(a, e),
                coordinates: t
            }
        },
        isClockWise(t) {
            for (var e, n, r = 0, a = 1, i = t.length; a < i; )
                e = n || t[0],
                r += ((n = t[a])[0] - e[0]) * (n[1] + e[1]),
                a++;
            return r > 0
        },
        hasHole(t) {
            if (t.length < 2)
                return !1;
            for (var e = 0; e < t.length; e++)
                if (!a.isClockWise(t[e]))
                    return !0;
            return !1
        }
    };
    e.a = a
}
, function(t, e, n) {
    "use strict";
    e.a = {
        updateList: {},
        add: function(t, e) {
            this.updateList[t] = e
        },
        delete: function(t) {
            delete this.updateList[t]
        },
        get: function(t) {
            return this.updateList[t]
        },
        updateAll: function() {
            for (let t in this.updateList)
                this.updateList[t]()
        },
        getAll: function() {
            return this.updateList
        }
    }
}
, function(t, e, n) {
    var r;
    t.exports = (r = r || function(t, e) {
        var n = Object.create || function() {
            function t() {}
            return function(e) {
                var n;
                return t.prototype = e,
                n = new t,
                t.prototype = null,
                n
            }
        }()
          , r = {}
          , a = r.lib = {}
          , i = a.Base = {
            extend: function(t) {
                var e = n(this);
                return t && e.mixIn(t),
                e.hasOwnProperty("init") && this.init !== e.init || (e.init = function() {
                    e.$super.init.apply(this, arguments)
                }
                ),
                e.init.prototype = e,
                e.$super = this,
                e
            },
            create: function() {
                var t = this.extend();
                return t.init.apply(t, arguments),
                t
            },
            init: function() {},
            mixIn: function(t) {
                for (var e in t)
                    t.hasOwnProperty(e) && (this[e] = t[e]);
                t.hasOwnProperty("toString") && (this.toString = t.toString)
            },
            clone: function() {
                return this.init.prototype.extend(this)
            }
        }
          , o = a.WordArray = i.extend({
            init: function(t, e) {
                t = this.words = t || [],
                this.sigBytes = null != e ? e : 4 * t.length
            },
            toString: function(t) {
                return (t || l).stringify(this)
            },
            concat: function(t) {
                var e = this.words
                  , n = t.words
                  , r = this.sigBytes
                  , a = t.sigBytes;
                if (this.clamp(),
                r % 4)
                    for (var i = 0; i < a; i++) {
                        var o = n[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                        e[r + i >>> 2] |= o << 24 - (r + i) % 4 * 8
                    }
                else
                    for (var i = 0; i < a; i += 4)
                        e[r + i >>> 2] = n[i >>> 2];
                return this.sigBytes += a,
                this
            },
            clamp: function() {
                var e = this.words
                  , n = this.sigBytes;
                e[n >>> 2] &= 4294967295 << 32 - n % 4 * 8,
                e.length = t.ceil(n / 4)
            },
            clone: function() {
                var t = i.clone.call(this);
                return t.words = this.words.slice(0),
                t
            },
            random: function(e) {
                for (var n, r = [], a = function(e) {
                    var e = e
                      , n = 987654321
                      , r = 4294967295;
                    return function() {
                        var a = ((n = 36969 * (65535 & n) + (n >> 16) & r) << 16) + (e = 18e3 * (65535 & e) + (e >> 16) & r) & r;
                        return a /= 4294967296,
                        (a += .5) * (t.random() > .5 ? 1 : -1)
                    }
                }, i = 0; i < e; i += 4) {
                    var s = a(4294967296 * (n || t.random()));
                    n = 987654071 * s(),
                    r.push(4294967296 * s() | 0)
                }
                return new o.init(r,e)
            }
        })
          , s = r.enc = {}
          , l = s.Hex = {
            stringify: function(t) {
                for (var e = t.words, n = t.sigBytes, r = [], a = 0; a < n; a++) {
                    var i = e[a >>> 2] >>> 24 - a % 4 * 8 & 255;
                    r.push((i >>> 4).toString(16)),
                    r.push((15 & i).toString(16))
                }
                return r.join("")
            },
            parse: function(t) {
                for (var e = t.length, n = [], r = 0; r < e; r += 2)
                    n[r >>> 3] |= parseInt(t.substr(r, 2), 16) << 24 - r % 8 * 4;
                return new o.init(n,e / 2)
            }
        }
          , u = s.Latin1 = {
            stringify: function(t) {
                for (var e = t.words, n = t.sigBytes, r = [], a = 0; a < n; a++) {
                    var i = e[a >>> 2] >>> 24 - a % 4 * 8 & 255;
                    r.push(String.fromCharCode(i))
                }
                return r.join("")
            },
            parse: function(t) {
                for (var e = t.length, n = [], r = 0; r < e; r++)
                    n[r >>> 2] |= (255 & t.charCodeAt(r)) << 24 - r % 4 * 8;
                return new o.init(n,e)
            }
        }
          , c = s.Utf8 = {
            stringify: function(t) {
                try {
                    return decodeURIComponent(escape(u.stringify(t)))
                } catch (t) {
                    throw new Error("Malformed UTF-8 data")
                }
            },
            parse: function(t) {
                return u.parse(unescape(encodeURIComponent(t)))
            }
        }
          , h = a.BufferedBlockAlgorithm = i.extend({
            reset: function() {
                this._data = new o.init,
                this._nDataBytes = 0
            },
            _append: function(t) {
                "string" == typeof t && (t = c.parse(t)),
                this._data.concat(t),
                this._nDataBytes += t.sigBytes
            },
            _process: function(e) {
                var n = this._data
                  , r = n.words
                  , a = n.sigBytes
                  , i = this.blockSize
                  , s = 4 * i
                  , l = a / s
                  , u = (l = e ? t.ceil(l) : t.max((0 | l) - this._minBufferSize, 0)) * i
                  , c = t.min(4 * u, a);
                if (u) {
                    for (var h = 0; h < u; h += i)
                        this._doProcessBlock(r, h);
                    var d = r.splice(0, u);
                    n.sigBytes -= c
                }
                return new o.init(d,c)
            },
            clone: function() {
                var t = i.clone.call(this);
                return t._data = this._data.clone(),
                t
            },
            _minBufferSize: 0
        })
          , d = (a.Hasher = h.extend({
            cfg: i.extend(),
            init: function(t) {
                this.cfg = this.cfg.extend(t),
                this.reset()
            },
            reset: function() {
                h.reset.call(this),
                this._doReset()
            },
            update: function(t) {
                return this._append(t),
                this._process(),
                this
            },
            finalize: function(t) {
                t && this._append(t);
                var e = this._doFinalize();
                return e
            },
            blockSize: 16,
            _createHelper: function(t) {
                return function(e, n) {
                    return new t.init(n).finalize(e)
                }
            },
            _createHmacHelper: function(t) {
                return function(e, n) {
                    return new d.HMAC.init(t,n).finalize(e)
                }
            }
        }),
        r.algo = {});
        return r
    }(Math),
    r)
}
, function(t, e, n) {
    "use strict";
    var r = n(0)
      , a = n(2);
    const i = new THREE.Ray
      , o = new THREE.Sphere(new THREE.Vector3(0,0,0),6378e3)
      , s = 9019854.100815602;
    class l {
        static putObject(t, e) {
            t.position = r.a.lonlat2World(t.lonlat, t.height + 6378e3);
            var n = e.create({
                type: t.type,
                name: t.name,
                url: t.url,
                position: t.position,
                angle: t.angle,
                complete: function() {
                    n.angles = l.position2angles(t.position)
                }
            });
            return n
        }
        static position2azimuth(t, e, n) {
            var r = t.slice(0)
              , a = t3djs.math.vectorCrossProduct(e, n)
              , i = t3djs.math.normalizeVector(r)
              , o = t3djs.math.vectorDotProduct(a, i)
              , s = [i[0] * o, i[1] * o, i[2] * o]
              , l = [a[0] - s[0], a[1] - s[1], a[2] - s[2]]
              , u = t3djs.math.vectorDotProduct([0, 1, 0], i)
              , c = [i[0] * u, i[1] * u, i[2] * u]
              , h = [0 - c[0], 1 - c[1], 0 - c[2]]
              , d = t3djs.math.normalizeVector(l)
              , f = t3djs.math.normalizeVector(h)
              , p = t3djs.math.getAngleBetweenVectors(d, f)
              , m = t3djs.math.vectorCrossProduct(f, i)
              , g = t3djs.math.normalizeVector(m);
            return t3djs.math.getAngleBetweenVectors(d, g) < 90 && (p = -p),
            p
        }
        static rotateByVector(t, e, n) {
            let r = new THREE.Vector3(t[0],t[1],t[2])
              , a = new THREE.Vector3(e[0],e[1],e[2])
              , i = r.applyAxisAngle(a, n);
            return [i.x, i.y, i.z]
        }
        static correctUp() {
            THING.App.current.camera.up = THING.Math.normalizeVector(THING.App.current.camera.position)
        }
        static flyRotate(t) {
            var e = THING.App.current;
            0 === (t = t || {}).time && (t.time = .001),
            t.angle = THING.Utils.parseValue(t.angle, 360),
            THING.Utils.isNull(t.time) ? t.speed = THING.Utils.parseValue(t.speed, 72) : t.speed = t.angle / (t.time / 1e3);
            var n = [0, 1, 0]
              , i = e.camera.target
              , o = t.angle;
            t.speed * o < 0 && (o = -o);
            var s = e.camera.camera.getPosition()
              , u = l.rotateByVector(s, n, o / 180 * Math.PI)
              , c = l.rotateByVector(i, n, o / 180 * Math.PI)
              , h = 0;
            e.camera.inputEnabled = !1,
            e.camera.onStart(),
            e.setCurrentHTMLMarker && e.setCurrentHTMLMarker(null),
            a.a.add("rotateLoop", function() {
                var d = t.speed * e._delay / 1e3;
                if (h += d,
                Math.abs(h) < Math.abs(o)) {
                    var f = l.rotateByVector(s, n, h / 180 * Math.PI)
                      , p = l.rotateByVector(i, n, h / 180 * Math.PI);
                    e.camera.camera.setPosition(f);
                    let t = r.a.getCameraUpByPositionAndTarget(f, p);
                    e.camera.up = t,
                    e.camera.target = p,
                    e.camera.onChange()
                } else if (Math.abs(h) >= Math.abs(o)) {
                    a.a.delete("rotateLoop"),
                    e.camera.camera.setPosition(u);
                    let n = r.a.getCameraUpByPositionAndTarget(u, c);
                    e.camera.up = n,
                    e.camera.target = c,
                    e.camera.inputEnabled = !0,
                    e.camera.onChange(),
                    e.trigger("flyRotateEnd"),
                    e.camera.onEnd(),
                    t.complete && t.complete()
                }
            })
        }
        static getViewExtend(t) {
            let e = this._getIntersectPoint(t)
              , n = e.distanceTo(t.camera.camera.position) / s + .1
              , a = 70 * (n = n >= 1 ? 1 : n)
              , i = r.a.world2Lonlat([e.x, e.y, e.z])
              , o = i[0] + a;
            o > 180 && (o = -(180 - (o - 180)));
            let l = i[0] - a;
            return l < -180 && (l = 180 - Math.abs(l + 180)),
            [l, o, i[1], n]
        }
        static isPositionVisible(t, e) {
            var n = r.a.lonlat2World(e, 6378e3)
              , a = t.camera.position
              , s = new THREE.Vector3(n[0] - a[0],n[1] - a[1],n[2] - a[2]);
            s.normalize(),
            i.set(t.camera.curOrbit.object.position, s);
            var l = new THREE.Vector3;
            return i.intersectSphere(o, l),
            new THREE.Vector3(n[0],n[1],n[2]).distanceTo(l) < 100
        }
        static _getIntersectPoint(t) {
            var e = new THREE.Vector3;
            e.copy(t.camera.curOrbit.object.position),
            e.negate(),
            e.normalize(),
            i.set(t.camera.curOrbit.object.position, e);
            var n = new THREE.Vector3;
            return i.intersectSphere(o, n),
            n
        }
        static getEarthCameraInfoByPositionAndTarget(t, e) {
            let n = THING.App.current;
            var a = {};
            if (a.lonlat = r.a.convertWorldToLonlat(e),
            Math.abs(a.lonlat[2]) > .001) {
                const t = n.camera.curOrbit._getIntersectPoint(!0, !0);
                a.lonlat = r.a.convertWorldToLonlat(t.toArray())
            }
            a.height = t3djs.math.vectorDistance(t, [0, 0, 0]) - 6378e3;
            var i = t;
            if (0 === e[0] || 0 === e[1] || 0 === e[2])
                return a;
            var o = [i[0] - e[0], i[1] - e[1], i[2] - e[2]];
            o = t3djs.math.normalizeVector(o);
            var s = t3djs.math.normalizeVector([e[0], e[1], e[2]])
              , l = t3djs.math.getAngleBetweenVectors(o, s)
              , u = [i[0] - e[0], i[1] - e[1], i[2] - e[2]]
              , c = t3djs.math.vectorCrossProduct(s, u);
            c = t3djs.math.normalizeVector(c);
            var h = t3djs.math.vectorDotProduct([0, 1, 0], s)
              , d = [s[0] * h, s[1] * h, s[2] * h]
              , f = [0 - d[0], 1 - d[1], 0 - d[2]]
              , p = t3djs.math.normalizeVector(f)
              , m = t3djs.math.vectorCrossProduct(p, s)
              , g = t3djs.math.normalizeVector(m)
              , v = t3djs.math.getAngleBetweenVectors(c, g);
            return t3djs.math.getAngleBetweenVectors(c, p) < 90 && (v = -v),
            a.heading = -v,
            a.tilt = 90 - l,
            a.pitch = a.tilt,
            a
        }
        static getEarthCameraInfo() {
            let t = THING.App.current;
            var e = t.camera.target
              , n = t.camera.position;
            return l.getEarthCameraInfoByPositionAndTarget(n, e)
        }
        static earthCameraRotateByTime(t) {
            let e = THING.App.current;
            e.camera.stopEarthFly(),
            e.camera.inputEnabled = !1,
            e.camera.onStart();
            var n = t.time
              , r = t.angle
              , i = void 0 === t.disablePick || t.disablePick
              , o = THING.Math.normalizeVector(e.camera.position);
            o = new THREE.Vector3(o[0],o[1],o[2]);
            var s = (new Date).getTime()
              , u = 0;
            e.setCurrentHTMLMarker && e.setCurrentHTMLMarker(null),
            a.a.add("cameraRotate", function() {
                e.camera.onChange(),
                e.camera.cameraObject.controls[0].control._flying = !0,
                i && e.picker._enable(!1, "earthRotateParam", 1e3);
                var c = (new Date).getTime() - s;
                if (c > n && (a.a.delete("cameraRotate"),
                e.camera.onEnd(),
                e.camera.cameraObject.controls[0].control._flying = !1,
                l.correctUp(),
                e.camera.inputEnabled = !0,
                i && e.picker._enable(!0, "earthRotateParam", 0),
                t.complete && t.complete()),
                c <= n) {
                    var h = c / n * r / 180 * Math.PI;
                    t.clockwise || (h *= -1);
                    let a = e.camera.direction
                      , i = new THREE.Vector3(a[0],a[1],a[2]);
                    i.applyAxisAngle(o, h - u);
                    let s = e.camera.curOrbit.object.position.distanceTo(e.camera.curOrbit._getIntersectPoint())
                      , d = e.camera.position;
                    i.multiplyScalar(s);
                    let f = new THREE.Vector3(d[0],d[1],d[2]).add(i);
                    e.camera.target = f.toArray(),
                    u = h,
                    l.correctUp()
                }
            })
        }
        static earthCameraRotateBySpeed(t) {
            const e = THING.Utils.parseValue(t.speed, 1)
              , n = THING.Utils.parseValue(t.angle, 1e10)
              , r = 10 * n / e;
            t.time = r,
            t.angle = n,
            delete t.speed,
            this.earthCameraRotateByTime(t)
        }
        static earthFlyRotateBySpeed(t) {
            let e = THING.App.current;
            e.camera.stopEarthFly(),
            void 0 === (t = t || {}).speed && (t.speed = 1),
            void 0 === t.target && (t.target = e.camera.target);
            var n = {};
            n.target = t.target,
            n.angle = void 0 === t.angle ? 36e11 : t.angle,
            n.time = t.speed * n.angle * 10,
            n.clockwise = t.clockwise,
            n.complete = t.complete,
            n.loopType = t.loopType || THING.LoopType.No,
            this.flyRotatePoint(n)
        }
        static earthCameraRotateOnXAxis(t) {
            const e = THING.App.current
              , n = THING.Utils.parseValue(t.disablePick, !0)
              , r = THING.Utils.parseValue(t.angle, 10)
              , i = THING.Utils.parseValue(t.time, 1e3);
            function o(t) {
                let n = (new THREE.Vector3).subVectors((new THREE.Vector3).fromArray(e.camera.target), (new THREE.Vector3).fromArray(e.camera.position))
                  , r = (new THREE.Vector3).fromArray(e.camera.position);
                r.normalize();
                let a = n.clone().cross(r);
                a.normalize(),
                n.applyAxisAngle(a, t);
                let i = (new THREE.Vector3).fromArray(e.camera.target);
                return i.sub(n),
                i.toArray()
            }
            if (0 === i)
                return void (e.camera.position = o(r * Math.PI / 180));
            var s = (new Date).getTime();
            let l = 0;
            e.setCurrentHTMLMarker && e.setCurrentHTMLMarker(null),
            a.a.add("cameraRotateOnXAxis", ()=>{
                e.camera.onChange(),
                n && e.picker._enable(!1, "earthRotateParam", 1e3);
                var u = (new Date).getTime() - s;
                if (u > i && (e.camera.position = o(r * Math.PI / 180 - l),
                a.a.delete("cameraRotateOnXAxis"),
                e.camera.onEnd(),
                e.camera.cameraObject.controls[0].control._flying = !1,
                e.camera.inputEnabled = !0,
                n && e.picker._enable(!0, "earthRotateParam", 0),
                t.complete && t.complete()),
                u <= i) {
                    var c = r * u / i * Math.PI / 180 - l;
                    e.camera.position = o(c),
                    l += c
                }
            }
            )
        }
        static flyRotatePoint(t) {
            let e = THING.App.current;
            (t = t || {}).target = THING.Utils.parseValue(t.target, [0, 0, 0]),
            t.angle = THING.Utils.parseValue(t.angle, 0),
            t.time = THING.Utils.parseValue(t.time, 0),
            t.clockwise = void 0 === t.clockwise || t.clockwise,
            t.loopType = THING.Utils.parseValue(t.loopType, THING.LoopType.No);
            var n = void 0 === t.disablePick || t.disablePick
              , r = t.target;
            if (0 !== r[0] && 0 !== r[1] && 0 !== r[2]) {
                var i = t.angle
                  , o = e.camera.camera.getPosition()
                  , s = e.camera.target
                  , u = e.camera.up
                  , c = [r[0], r[1], r[2]]
                  , h = new THREE.Vector3(c[0],c[1],c[2]).normalize();
                h = [h.x, h.y, h.z];
                var d = l.rotateByVector(o, h, i / 180 * Math.PI)
                  , f = t.time
                  , p = (new Date).getTime();
                e.camera.inputEnabled = !1,
                e.camera.cameraObject.controls[0].control._flying = !0,
                n && e.picker._enable(!1, "earthRotateParam", 1e3),
                e.camera.onStart(),
                e.setCurrentHTMLMarker && e.setCurrentHTMLMarker(null),
                a.a.add("rotateLoop", function() {
                    var c = (new Date).getTime() - p;
                    if (c > f)
                        t.loopType === THING.LoopType.No ? (a.a.delete("rotateLoop"),
                        e.camera.cameraObject.controls[0].control._flying = !1,
                        e.camera.position = d,
                        e.camera.target = r,
                        l.correctUp(),
                        n && e.picker._enable(!0, "earthRotateParam", 0),
                        e.camera.inputEnabled = !0,
                        e.camera.onChange(),
                        e.camera.onEnd(),
                        t.complete && t.complete()) : t.loopType === THING.LoopType.Repeat ? (e.camera.position = o,
                        e.camera.target = s,
                        e.camera.up = u,
                        p = (new Date).getTime(),
                        e.camera.onChange()) : t.loopType === THING.LoopType.PingPong && (o = e.camera.position,
                        t.clockwise = !t.clockwise,
                        p = (new Date).getTime());
                    else {
                        var m = c / f * i / 180 * Math.PI;
                        t.clockwise || (m *= -1);
                        var g = l.rotateByVector(o, h, m);
                        e.camera.position = g,
                        e.camera.target = r,
                        l.correctUp(),
                        e.camera.onChange()
                    }
                })
            } else
                t.complete && t.complete()
        }
        static getSpeed(t, e) {
            return ((new THREE.Vector3).fromArray(THING.App.current.camera.position).length() - e + 10) / 10 * t
        }
        static parse90(t) {
            return 90 === t ? 89.99 : t
        }
        static directFlyTo(t) {
            let e = THING.App.current;
            (t = t || {}).speed = THING.Utils.parseValue(t.speed, 1),
            t.time = THING.Utils.parseValue(t.time, 3e3),
            t.heading = THING.Utils.parseValue(t.heading, 0),
            t.tilt = THING.Utils.parseValue(t.tilt, 45),
            t.lonlat = THING.Utils.parseValue(t.lonlat, [116.390834, 39.916353]),
            t.height = THING.Utils.parseValue(t.height, 1e4);
            let n = this.parse90(t.tilt);
            var i = void 0 === t.disablePick || t.disablePick;
            let o = t.uniformSpeed
              , s = this.getEarthCameraInfo();
            function l(t, e, n) {
                return Math.abs(t - e) < n
            }
            if (0 === t.time || l(s.lonlat[0], t.lonlat[0], 1e-4) && l(s.lonlat[1], t.lonlat[1], 1e-4) && l(s.height, t.height, 5) && l(s.tilt, n, 10) && l(s.heading, t.heading, 5))
                return void (t.complete && t.complete.call(this));
            var u = e.camera.position
              , c = e.camera.target
              , h = r.a.convertLonlatToWorld(t.lonlat, 0);
            let d;
            if (t.target && (h = t.target),
            t.position)
                d = t.position;
            else {
                var f = r.a.convertLonlatToWorld(t.lonlat, t.height)
                  , p = new THREE.Vector3(f[0],f[1],f[2]).normalize()
                  , m = new THREE.Vector3(0,1,0).projectOnPlane(p);
                m = (m = m.normalize()).multiplyScalar(-1);
                var g = t.height / Math.tan(n / 180 * Math.PI);
                d = [f[0] + g * m.x, f[1] + g * m.y, f[2] + g * m.z];
                var v = [p.x, p.y, p.z];
                d = this.rotateByVector(d, v, t.heading / 180 * Math.PI)
            }
            Math.abs(CMAP.Util.convertWorldToLonlat(h)[2]) > 1 && (h = CMAP.getCurrentMap().terrainLayer.url ? this._getPickedPosition(d, h, !0).toArray() : this._getPickedPosition(d, h, !1).toArray());
            var y = [d[0] - u[0], d[1] - u[1], d[2] - u[2]]
              , _ = [h[0] - c[0], h[1] - c[1], h[2] - c[2]]
              , x = (new THREE.Vector3).fromArray(y).length();
            if (x < .001)
                return void (t.complete && t.complete.call(this));
            var b = e.camera.up
              , w = r.a.getCameraUpByPositionAndTarget(d, h)
              , C = [w[0] - b[0], w[1] - b[1], w[2] - b[2]];
            function E(t) {
                var n = [u[0] + y[0] * t, u[1] + y[1] * t, u[2] + y[2] * t]
                  , r = [c[0] + _[0] * t, c[1] + _[1] * t, c[2] + _[2] * t]
                  , a = [b[0] + C[0] * t, b[1] + C[1] * t, b[2] + C[2] * t];
                e.camera.position = n,
                e.camera.up = a,
                e.camera.target = r;
                const i = e.camera.cameraObject.controller;
                i._correctCube(),
                i._correctSphericalRotation(new THREE.Vector3(n[0],n[1],n[2]))
            }
            var T = 0
              , M = 0;
            e.camera.inputEnabled = !1,
            e.camera.onStart();
            let A = (new Date).getTime();
            e.setCurrentHTMLMarker && e.setCurrentHTMLMarker(null);
            const P = r.a.convertWorldToLonlat(d);
            a.a.add("directFlyToGeoPositionLoop", function() {
                if (e.camera.cameraObject.controls[0].control._flying = !0,
                i && e.picker._enable(!1, "earthFlyParam", 1e3),
                o) {
                    let e = (new Date).getTime();
                    M = x * (e - A) / t.time
                } else {
                    let e, n = Math.abs(s.height);
                    if (n > 12e6)
                        e = 5;
                    else {
                        const t = Math.log(n);
                        e = Math.floor(Math.min(t, 2)),
                        e = Math.floor(Math.max(e, 1))
                    }
                    let r = 1
                      , a = x;
                    for (; r <= e; )
                        a /= Math.pow(t.time, 2),
                        r++;
                    const i = Math.min((new Date).getTime() - A, t.time);
                    M = P[2] < n ? x - a * Math.pow(Math.pow(t.time - i, 2), e) : a * Math.pow(Math.pow(i, 2), e)
                }
                (T = M / x) < x && (E(T),
                e.camera.onChange()),
                T >= .9999999999 && (e.camera.cameraObject.controls[0].control._flying = !1,
                E(1),
                e.camera.inputEnabled = !0,
                i && e.picker._enable(!0, "earthFlyParam", 0),
                a.a.delete("directFlyToGeoPositionLoop"),
                e.camera.curOrbit._setState(-1),
                e.camera.onChange(),
                e.camera.onEnd(),
                t.complete && t.complete())
            })
        }
        static _getPickedPosition(t, e, n) {
            let r = t3djs.math.subtractVectors(e, t)
              , a = t3djs.math.normalizeVector(r);
            var i = new THREE.Vector3;
            if (n) {
                let n = new THREE.Raycaster;
                n.set(new THREE.Vector3(t[0],t[1],t[2]), new THREE.Vector3(a[0],a[1],a[2]));
                var s = t3djs.buffer.nodeBuffer.get("tiles-root");
                if (s && s.ensureVisible()) {
                    let r = n.intersectObjects(s.children, !0);
                    i = r.length > 0 && !r[0].point.equals(new THREE.Vector3(0,0,0)) && CMAP.Util.convertWorldToLonlat(r[0].point.toArray())[2] >= 0 ? r[0].point : this._getPickedPosition(t, e, !1)
                }
            } else {
                let n = new THREE.Ray;
                n.set(new THREE.Vector3(t[0],t[1],t[2]), new THREE.Vector3(a[0],a[1],a[2])),
                n.intersectSphere(o, i),
                i.equals(new THREE.Vector3(0,0,0)) && (i = new THREE.Vector3(e[0],e[1],e[2]))
            }
            return i
        }
        static stopEarthFly() {
            let t = THING.App.current;
            var e = !1;
            t.picker._enable(!0, "earthFlyParam", 0),
            a.a.get("directFlyToGeoPositionLoop") && (e = !0,
            a.a.delete("directFlyToGeoPositionLoop")),
            a.a.get("earthFlyLoop") && (e = !0,
            a.a.delete("earthFlyLoop")),
            a.a.get("rotateLoop") && (e = !0,
            a.a.delete("rotateLoop"),
            t.picker._enable(!0, "earthRotateParam", 0)),
            a.a.get("cameraRotate") && (e = !0,
            a.a.delete("cameraRotate")),
            a.a.get("cameraRotateOnXAxis") && (e = !0,
            a.a.delete("cameraRotateOnXAxis"),
            t.picker._enable(!0, "earthRotateParam", 0)),
            t.camera.onEnd(),
            t.camera.cameraObject.controls[0].control._flying = !1,
            t.camera.inputEnabled = !0,
            e && t.trigger("stopEarthFlying")
        }
        static getCameraPositionAndTargetByLonlat(t, e, n, a) {
            var i = r.a.convertLonlatToWorld(t, e)
              , o = [i[0], i[1], i[2]]
              , s = new THREE.Vector3(o[0],o[1],o[2]).normalize()
              , l = new THREE.Vector3(0,1,0).projectOnPlane(s);
            l = (l = l.normalize()).multiplyScalar(-1);
            var u = e / Math.tan(a / 180 * Math.PI)
              , c = [i[0] + u * l.x, i[1] + u * l.y, i[2] + u * l.z]
              , h = [s.x, s.y, s.z];
            return c = this.rotateByVector(c, h, n / 180 * Math.PI)
        }
        static getRotateDistanceByHeight(t, e) {
            var n = THING.App.current.camera.target
              , a = r.a.lonlat2World(t, 6378e3)
              , i = (new THREE.Vector3).fromArray(n)
              , o = (new THREE.Vector3).fromArray(a);
            return i.angleTo(o) * (e + 6378e3)
        }
        static _getSpeedByHeight(t) {
            return t / 10
        }
        static earthFlyTo(t) {
            let e = THING.App.current;
            if (this.stopEarthFly(),
            (t = t || {}).stop && (e.off("stopEarthFlying"),
            e.on("stopEarthFlying", function(n) {
                t.stop(n),
                e.off("stopEarthFlying"),
                e.camera.cameraObject.controller.enabled = !1,
                setTimeout(()=>{
                    e.camera.cameraObject.controller.enabled = !0
                }
                , 50)
            })),
            Math.abs(CMAP.Util.convertWorldToLonlat(e.camera.target)[2]) > .001) {
                const t = e.camera.curOrbit._getIntersectPoint(!0, !0);
                e.camera.target = t.toArray()
            }
            if (t.uniformSpeed = THING.Utils.parseValue(t.uniformSpeed, !1),
            t.position && t.target) {
                let e = this.getEarthCameraInfoByPositionAndTarget(t.position, t.target);
                t = CMAP.Util.extend(t, e)
            }
            t.time = THING.Utils.parseValue(t.time, 2e3),
            t.speed && THING.Utils.warn("earthFlyTo: please use time instead of speed"),
            t.heading = THING.Utils.parseValue(t.heading, 0),
            void 0 !== t.pitch && (t.tilt = t.pitch),
            t.tilt = THING.Utils.parseValue(t.tilt, 45);
            let n = this.parse90(t.tilt);
            t.lonlat = THING.Utils.parseValue(t.lonlat, [116.390834, 39.916353]),
            t.directFly = THING.Utils.parseValue(t.directFly, !1);
            var a = t.height;
            t.object && t.object.boundingBox ? (t.lonlat = r.a.world2Lonlat(t.object.boundingBox.center),
            t.height = t.object.boundingBox.radius + t.lonlat[2]) : t.height = void 0 === t.height ? 1e4 : t.height,
            (a || 0 === t.height) && (t.height = a);
            let i = this.getEarthCameraInfo();
            var o = (new THREE.Vector3).fromArray(e.camera.position).length() - 6378e3
              , s = this.getCameraPositionAndTargetByLonlat(t.lonlat, t.height, t.heading, n)
              , u = r.a.convertLonlatToWorld(t.lonlat)
              , c = (new THREE.Vector3).fromArray(s).distanceTo((new THREE.Vector3).fromArray(e.camera.position))
              , h = (new THREE.Vector3).fromArray(u).distanceTo((new THREE.Vector3).fromArray(e.camera.target));
            var d = null
              , f = function() {
                let n = r.a.convertLonlatToWorld(t.lonlat);
                return (new THREE.Vector3).fromArray(e.camera.target).distanceTo((new THREE.Vector3).fromArray(n)) / 6378e3 * 2e6
            }();
            if (0 === t.time)
                return e.camera.position = s,
                e.camera.target = u,
                l.correctUp(),
                e.camera.onChange(),
                e.camera.onEnd(),
                void (t.complete && t.complete());
            if (c < .1 && h < .1)
                t.complete && t.complete();
            else if (function(t) {
                let e = THING.App.current;
                if (t.directFly || t.uniformSpeed)
                    return !0;
                var n = (new THREE.Vector3).fromArray(e.camera.direction)
                  , r = (new THREE.Vector3).subVectors((new THREE.Vector3).fromArray(e.camera.target), (new THREE.Vector3).fromArray(s));
                return n.angleTo(r) < .8 && p > .5 * m
            }(t))
                this.directFlyTo(t);
            else {
                var p = Math.abs(t.height - i.height)
                  , m = c
                  , g = 0
                  , v = 0
                  , y = 0;
                if (o < f) {
                    t.height < f ? (d = f,
                    g = Math.abs(d - o) / this._getSpeedByHeight((d + o) / 2),
                    v = this.getRotateDistanceByHeight(t.lonlat, d) / this._getSpeedByHeight(d),
                    y = Math.abs(d - t.height) / this._getSpeedByHeight((d + t.height) / 2)) : (d = t.height,
                    g = Math.abs(d - o) / this._getSpeedByHeight((d + o) / 2),
                    v = this.getRotateDistanceByHeight(t.lonlat, d) / this._getSpeedByHeight(d));
                    let e = g / (g + v + y)
                      , n = (v + y) / (g + v + y);
                    g = t.time * e,
                    v = t.time * n,
                    this.directFlyTo({
                        lonlat: i.lonlat,
                        height: d,
                        tilt: 45,
                        heading: i.heading,
                        speed: t.speed,
                        time: g,
                        complete: function() {
                            t.time = v,
                            l.rotateFlyTo(t)
                        }
                    })
                } else
                    this.rotateFlyTo(t)
            }
        }
        static _rotateToNorth(t=1) {
            const e = THING.App.current
              , n = e.camera.camera.getPosition();
            let a = e.camera.target;
            const i = [a[0], a[1], a[2]];
            if (r.a.isArrayEqual(a, [0, 0, 0])) {
                const t = r.a.world2Lonlat(n);
                a = r.a.lonlat2World(t, 6378e3)
            }
            const o = THING.Math.normalizeVector(a)
              , s = THING.Math.subVector(n, a);
            let l = THING.Math.crossVector(o, s);
            l = THING.Math.normalizeVector(l);
            const u = THING.Math.dotVector([0, 1, 0], o)
              , c = THING.Math.scaleVector(o, u)
              , h = THING.Math.subVector([0, 1, 0], c)
              , d = THING.Math.normalizeVector(h)
              , f = THING.Math.crossVector(d, o)
              , p = THING.Math.normalizeVector(f);
            let m = THING.Math.getAngleBetweenVectors(l, p);
            THING.Math.getAngleBetweenVectors(l, d) < 90 && (m = -m);
            const g = Math.abs(m) / 180 * 1e3 / t;
            e.camera.flyRotatePoint({
                target: i,
                angle: m,
                time: g
            })
        }
        static rotateFlyTo(t) {
            let e = THING.App.current;
            t.speed = THING.Utils.parseValue(t.speed, 1),
            t.time = THING.Utils.parseValue(t.time, 3e3);
            let n = e.camera.getCameInfo().height
              , i = this.getRotateDistanceByHeight(t.lonlat, n) / this._getSpeedByHeight(n)
              , o = Math.abs(n - t.height) / this._getSpeedByHeight((n + t.height) / 2)
              , s = 0
              , u = 0;
            if (0 === i && 0 === o || (s = t.time * i / (i + o),
            u = t.time * o / (i + o)),
            s > 0) {
                var c = e.camera.camera.getPosition()
                  , h = e.camera.target
                  , d = r.a.lonlat2World(t.lonlat, 6378e3)
                  , f = (new THREE.Vector3).fromArray(h)
                  , p = (new THREE.Vector3).fromArray(d)
                  , m = f.angleTo(p)
                  , g = (new THREE.Vector3).crossVectors(f, p).normalize().toArray()
                  , v = 0;
                e.camera.inputEnabled = !1,
                e.camera.onStart();
                var y = (new Date).getTime();
                e.setCurrentHTMLMarker && e.setCurrentHTMLMarker(null),
                a.a.add("earthFlyLoop", function() {
                    e.camera.cameraObject.controls[0].control._flying = !0;
                    var n = ((new Date).getTime() - y) / s * m / 180 * Math.PI;
                    if (v += n,
                    Math.abs(v) < Math.abs(m)) {
                        var i = l.rotateByVector(c, g, v)
                          , o = l.rotateByVector(h, g, v);
                        e.camera.position = i;
                        let t = r.a.getCameraUpByPositionAndTarget(i, o);
                        e.camera.up = t,
                        e.camera.target = o,
                        e.camera.onChange()
                    } else
                        Math.abs(v) >= Math.abs(m) && (a.a.delete("earthFlyLoop"),
                        e.camera.cameraObject.controls[0].control._flying = !1,
                        e.camera.target = d,
                        e.camera.inputEnabled = !0,
                        e.camera.onChange(),
                        e.camera.onEnd(),
                        t.time = u,
                        l.directFlyTo(t))
                })
            } else
                t.time = u,
                l.directFlyTo(t)
        }
        static flyToBoundingSphere(t) {
            let e = THING.App.current;
            var n = THING.Utils.parseValue(t.radius, 6378e3)
              , a = THING.Utils.parseValue(t.center, [0, 0, 0])
              , i = THING.Utils.parseValue(t.time, 3e3);
            if (l.calcCamInfo(45, 45, 1.2, n, a, 1).time = i,
            e.camera.inputEnabled = !1,
            t3djs.math.vectorDistance(a, [0, 0, 0]) < 1594500)
                e.camera.flyTo({
                    position: [4890109.86328125, 9295980.46875, 13943610.3515625],
                    target: [1786608.3209084966, 3396399.1672599176, 5094317.095954092],
                    up: [0, 1, 0],
                    time: i,
                    isUpdate: !0,
                    complete: function() {
                        e.camera.inputEnabled = !0,
                        t.complete && t.complete()
                    }
                });
            else {
                var o = r.a.world2Lonlat(a)
                  , s = o[2];
                let i = 45 / e.camera.fov;
                e.camera.earthFlyTo({
                    lonlat: o,
                    height: s + n * i,
                    complete: function() {
                        t.complete && t.complete()
                    }
                })
            }
        }
        static calcCamInfo(t, e, n, a, i, o) {
            let s = THING.App.current;
            var l = {}
              , u = i
              , c = (r.a.world2Lonlat(u),
            s.camera.fov)
              , h = new THREE.Object3D;
            h.setPosition(i),
            h.setDirection(i, 2, [0, 1, 0]),
            h.updateMatrixWorld();
            var d, f = a * n / Math.tan(c / 2 * o / 180 * Math.PI), p = h.convertLocalToWorldPosition([0, f, 0]), m = r.a.world2Lonlat(p), g = t3djs.math.vectorDistance(p, [0, 0, 0]) - 6378e3 - a, v = [m[0], m[1] + .01], y = r.a.convertLonlat2World(m), _ = r.a.convertLonlat2World(v), x = t3djs.math.subtractVectors(_, y);
            x = t3djs.math.normalizeVector(x),
            a < 1594500 ? d = [m[0], m[1] - a / 111e3 * 2] : (d = [m[0], m[1] - 1],
            g *= 1.05);
            var b = r.a.convertLonlat2World(d, g);
            return l.target = u,
            l.position = b,
            l.up = r.a.getCameraUpByPositionAndTarget(l.position, l.target),
            l
        }
        static setCameraFlyFunction(t) {
            t.camera.getEarthCameraInfo = t.camera.getCameInfo = function() {
                return l.getEarthCameraInfo()
            }
            ,
            CMAP.earthCameraRotateByTime = function(t) {
                l.earthCameraRotateByTime(t)
            }
            ,
            t.camera.earthCameraRotateByTime = function(t) {
                l.earthCameraRotateByTime(t)
            }
            ,
            t.camera.earthCameraRotateBySpeed = function(t) {
                l.earthCameraRotateBySpeed(t)
            }
            ,
            t.camera.earthCameraRotateOnXAxis = function(t) {
                l.earthCameraRotateOnXAxis(t)
            }
            ,
            t.camera.flyRotate = function(t) {
                l.earthFlyRotateBySpeed(t)
            }
            ,
            CMAP.earthFlyRotateBySpeed = function(t) {
                l.earthFlyRotateBySpeed(t)
            }
            ,
            t.camera.earthFlyRotateBySpeed = function(t) {
                l.earthFlyRotateBySpeed(t)
            }
            ,
            CMAP.earthFlyRotateByTime = function(t) {
                l.flyRotatePoint(t)
            }
            ,
            t.camera.flyRotatePoint = t.camera.earthFlyRotateByTime = function(t) {
                l.flyRotatePoint(t)
            }
            ,
            t.camera.flyToGeoPosition = function(t) {
                THING.Utils.warn("please use app.camera.earthFlyTo with same parameters insteadof app.camera.flyToGeoPosition"),
                l.earthFlyTo(t)
            }
            ,
            t.camera.directFlyToGeoPosition = function(t) {
                l.directFlyTo(t)
            }
            ,
            CMAP.stopEarthFly = function() {
                l.stopEarthFly()
            }
            ,
            t.camera.stopEarthFly = function() {
                l.stopEarthFly()
            }
            ,
            t.camera.rotateToNorth = function(t) {
                l._rotateToNorth(t)
            }
            ,
            CMAP.earthFlyTo = function(e) {
                t.camera.earthFlyTo(e)
            }
            ,
            t.camera.earthFlyTo = function(t) {
                l.earthFlyTo(t)
            }
            ,
            t.camera.rotateFlyTo = function(t) {
                l.rotateFlyTo(t)
            }
            ,
            t.camera.flyToBoundingSphere = function(t) {
                l.flyToBoundingSphere(t)
            }
        }
        static pickEllipsoid3D(t, e) {
            var n = new Cesium.Ray
              , r = Cesium.Ellipsoid.WGS84
              , a = l.getPickRay(t, e, n);
            if (a) {
                var i = Cesium.IntersectionTests.rayEllipsoid(a, r);
                if (i) {
                    var o = i.start > 0 ? i.start : i.stop
                      , s = new Cesium.Cartesian3;
                    return Cesium.Ray.getPoint(a, o, s),
                    [-s.x, s.z, s.y]
                }
            }
        }
        static getPickRay(t, e, n) {
            var r = CMAP.getCurrentMap()._earthInstance.tileEarth._frameState;
            return l.getPickRayPerspective(r, t, e, n)
        }
        static getPickRayPerspective(t, e, n, r) {
            var a = new Cesium.Cartesian3
              , i = new Cesium.Cartesian3
              , o = new Cesium.Cartesian3
              , s = THING.App.current.renderer.domElement
              , l = s.clientWidth
              , u = s.clientHeight
              , c = t.perspectiveOffCenterFrustum
              , h = Math.tan(.5 * t.fovy)
              , d = t.aspectRatio * h
              , f = c.near;
            e = 2 / l * e - 1,
            n = 2 / u * (u - n) - 1;
            var p = t.positionWC;
            if (p) {
                var m = t.upWC
                  , g = t.directionWC;
                Cesium.Cartesian3.clone(p, r.origin);
                var v = Cesium.Cartesian3.multiplyByScalar(g, f, a);
                Cesium.Cartesian3.add(p, v, v);
                var y = new Cesium.Cartesian3;
                Cesium.Cartesian3.cross(p, m, y),
                Cesium.Cartesian3.normalize(y, y),
                Cesium.Cartesian3.multiplyByScalar(y, -1, y);
                var _ = Cesium.Cartesian3.multiplyByScalar(y, e * f * d, i)
                  , x = Cesium.Cartesian3.multiplyByScalar(m, n * f * h, o);
                return g = Cesium.Cartesian3.add(v, _, r.direction),
                Cesium.Cartesian3.add(g, x, g),
                Cesium.Cartesian3.subtract(g, p, g),
                Cesium.Cartesian3.normalize(g, g),
                r
            }
        }
    }
    e.a = l
}
, function(t, e, n) {
    var r;
    t.exports = (r = n(3),
    n(8),
    void (r.lib.Cipher || function(t) {
        var e = r
          , n = e.lib
          , a = n.Base
          , i = n.WordArray
          , o = n.BufferedBlockAlgorithm
          , s = e.enc
          , l = (s.Utf8,
        s.Base64)
          , u = e.algo
          , c = u.EvpKDF
          , h = n.Cipher = o.extend({
            cfg: a.extend(),
            createEncryptor: function(t, e) {
                return this.create(this._ENC_XFORM_MODE, t, e)
            },
            createDecryptor: function(t, e) {
                return this.create(this._DEC_XFORM_MODE, t, e)
            },
            init: function(t, e, n) {
                this.cfg = this.cfg.extend(n),
                this._xformMode = t,
                this._key = e,
                this.reset()
            },
            reset: function() {
                o.reset.call(this),
                this._doReset()
            },
            process: function(t) {
                return this._append(t),
                this._process()
            },
            finalize: function(t) {
                t && this._append(t);
                var e = this._doFinalize();
                return e
            },
            keySize: 4,
            ivSize: 4,
            _ENC_XFORM_MODE: 1,
            _DEC_XFORM_MODE: 2,
            _createHelper: function() {
                function t(t) {
                    return "string" == typeof t ? C : x
                }
                return function(e) {
                    return {
                        encrypt: function(n, r, a) {
                            return t(r).encrypt(e, n, r, a)
                        },
                        decrypt: function(n, r, a) {
                            return t(r).decrypt(e, n, r, a)
                        }
                    }
                }
            }()
        })
          , d = (n.StreamCipher = h.extend({
            _doFinalize: function() {
                var t = this._process(!0);
                return t
            },
            blockSize: 1
        }),
        e.mode = {})
          , f = n.BlockCipherMode = a.extend({
            createEncryptor: function(t, e) {
                return this.Encryptor.create(t, e)
            },
            createDecryptor: function(t, e) {
                return this.Decryptor.create(t, e)
            },
            init: function(t, e) {
                this._cipher = t,
                this._iv = e
            }
        })
          , p = d.CBC = function() {
            var e = f.extend();
            function n(e, n, r) {
                var a = this._iv;
                if (a) {
                    var i = a;
                    this._iv = t
                } else
                    var i = this._prevBlock;
                for (var o = 0; o < r; o++)
                    e[n + o] ^= i[o]
            }
            return e.Encryptor = e.extend({
                processBlock: function(t, e) {
                    var r = this._cipher
                      , a = r.blockSize;
                    n.call(this, t, e, a),
                    r.encryptBlock(t, e),
                    this._prevBlock = t.slice(e, e + a)
                }
            }),
            e.Decryptor = e.extend({
                processBlock: function(t, e) {
                    var r = this._cipher
                      , a = r.blockSize
                      , i = t.slice(e, e + a);
                    r.decryptBlock(t, e),
                    n.call(this, t, e, a),
                    this._prevBlock = i
                }
            }),
            e
        }()
          , m = e.pad = {}
          , g = m.Pkcs7 = {
            pad: function(t, e) {
                for (var n = 4 * e, r = n - t.sigBytes % n, a = r << 24 | r << 16 | r << 8 | r, o = [], s = 0; s < r; s += 4)
                    o.push(a);
                var l = i.create(o, r);
                t.concat(l)
            },
            unpad: function(t) {
                var e = 255 & t.words[t.sigBytes - 1 >>> 2];
                t.sigBytes -= e
            }
        }
          , v = (n.BlockCipher = h.extend({
            cfg: h.cfg.extend({
                mode: p,
                padding: g
            }),
            reset: function() {
                h.reset.call(this);
                var t = this.cfg
                  , e = t.iv
                  , n = t.mode;
                if (this._xformMode == this._ENC_XFORM_MODE)
                    var r = n.createEncryptor;
                else {
                    var r = n.createDecryptor;
                    this._minBufferSize = 1
                }
                this._mode && this._mode.__creator == r ? this._mode.init(this, e && e.words) : (this._mode = r.call(n, this, e && e.words),
                this._mode.__creator = r)
            },
            _doProcessBlock: function(t, e) {
                this._mode.processBlock(t, e)
            },
            _doFinalize: function() {
                var t = this.cfg.padding;
                if (this._xformMode == this._ENC_XFORM_MODE) {
                    t.pad(this._data, this.blockSize);
                    var e = this._process(!0)
                } else {
                    var e = this._process(!0);
                    t.unpad(e)
                }
                return e
            },
            blockSize: 4
        }),
        n.CipherParams = a.extend({
            init: function(t) {
                this.mixIn(t)
            },
            toString: function(t) {
                return (t || this.formatter).stringify(this)
            }
        }))
          , y = e.format = {}
          , _ = y.OpenSSL = {
            stringify: function(t) {
                var e = t.ciphertext
                  , n = t.salt;
                if (n)
                    var r = i.create([1398893684, 1701076831]).concat(n).concat(e);
                else
                    var r = e;
                return r.toString(l)
            },
            parse: function(t) {
                var e = l.parse(t)
                  , n = e.words;
                if (1398893684 == n[0] && 1701076831 == n[1]) {
                    var r = i.create(n.slice(2, 4));
                    n.splice(0, 4),
                    e.sigBytes -= 16
                }
                return v.create({
                    ciphertext: e,
                    salt: r
                })
            }
        }
          , x = n.SerializableCipher = a.extend({
            cfg: a.extend({
                format: _
            }),
            encrypt: function(t, e, n, r) {
                r = this.cfg.extend(r);
                var a = t.createEncryptor(n, r)
                  , i = a.finalize(e)
                  , o = a.cfg;
                return v.create({
                    ciphertext: i,
                    key: n,
                    iv: o.iv,
                    algorithm: t,
                    mode: o.mode,
                    padding: o.padding,
                    blockSize: t.blockSize,
                    formatter: r.format
                })
            },
            decrypt: function(t, e, n, r) {
                r = this.cfg.extend(r),
                e = this._parse(e, r.format);
                var a = t.createDecryptor(n, r).finalize(e.ciphertext);
                return a
            },
            _parse: function(t, e) {
                return "string" == typeof t ? e.parse(t, this) : t
            }
        })
          , b = e.kdf = {}
          , w = b.OpenSSL = {
            execute: function(t, e, n, r) {
                r || (r = i.random(8));
                var a = c.create({
                    keySize: e + n
                }).compute(t, r)
                  , o = i.create(a.words.slice(e), 4 * n);
                return a.sigBytes = 4 * e,
                v.create({
                    key: a,
                    iv: o,
                    salt: r
                })
            }
        }
          , C = n.PasswordBasedCipher = x.extend({
            cfg: x.cfg.extend({
                kdf: w
            }),
            encrypt: function(t, e, n, r) {
                var a = (r = this.cfg.extend(r)).kdf.execute(n, t.keySize, t.ivSize);
                r.iv = a.iv;
                var i = x.encrypt.call(this, t, e, a.key, r);
                return i.mixIn(a),
                i
            },
            decrypt: function(t, e, n, r) {
                r = this.cfg.extend(r),
                e = this._parse(e, r.format);
                var a = r.kdf.execute(n, t.keySize, t.ivSize, e.salt);
                r.iv = a.iv;
                var i = x.decrypt.call(this, t, e, a.key, r);
                return i
            }
        })
    }()))
}
, function(t, e, n) {
    "use strict";
    function r(t, e, n) {
        void 0 === n && (n = {});
        var r = {
            type: "Feature"
        };
        return (0 === n.id || n.id) && (r.id = n.id),
        n.bbox && (r.bbox = n.bbox),
        r.properties = e || {},
        r.geometry = t,
        r
    }
    function a(t, e, n) {
        return void 0 === n && (n = {}),
        r({
            type: "Point",
            coordinates: t
        }, e, n)
    }
    function i(t, e, n) {
        void 0 === n && (n = {});
        for (var a = 0, i = t; a < i.length; a++) {
            var o = i[a];
            if (o.length < 4)
                throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
            for (var s = 0; s < o[o.length - 1].length; s++)
                if (o[o.length - 1][s] !== o[0][s])
                    throw new Error("First and last Position are not equivalent.")
        }
        return r({
            type: "Polygon",
            coordinates: t
        }, e, n)
    }
    function o(t, e, n) {
        if (void 0 === n && (n = {}),
        t.length < 2)
            throw new Error("coordinates must be an array of two or more positions");
        return r({
            type: "LineString",
            coordinates: t
        }, e, n)
    }
    function s(t, e) {
        void 0 === e && (e = {});
        var n = {
            type: "FeatureCollection"
        };
        return e.id && (n.id = e.id),
        e.bbox && (n.bbox = e.bbox),
        n.features = t,
        n
    }
    function l(t, e, n) {
        return void 0 === n && (n = {}),
        r({
            type: "MultiLineString",
            coordinates: t
        }, e, n)
    }
    function u(t, e, n) {
        return void 0 === n && (n = {}),
        r({
            type: "MultiPoint",
            coordinates: t
        }, e, n)
    }
    function c(t, e, n) {
        return void 0 === n && (n = {}),
        r({
            type: "MultiPolygon",
            coordinates: t
        }, e, n)
    }
    function h(t, n) {
        void 0 === n && (n = "kilometers");
        var r = e.factors[n];
        if (!r)
            throw new Error(n + " units is invalid");
        return t * r
    }
    function d(t, n) {
        void 0 === n && (n = "kilometers");
        var r = e.factors[n];
        if (!r)
            throw new Error(n + " units is invalid");
        return t / r
    }
    function f(t) {
        return 180 * (t % (2 * Math.PI)) / Math.PI
    }
    function p(t) {
        return !isNaN(t) && null !== t && !Array.isArray(t) && !/^\s*$/.test(t)
    }
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.earthRadius = 6371008.8,
    e.factors = {
        centimeters: 100 * e.earthRadius,
        centimetres: 100 * e.earthRadius,
        degrees: e.earthRadius / 111325,
        feet: 3.28084 * e.earthRadius,
        inches: 39.37 * e.earthRadius,
        kilometers: e.earthRadius / 1e3,
        kilometres: e.earthRadius / 1e3,
        meters: e.earthRadius,
        metres: e.earthRadius,
        miles: e.earthRadius / 1609.344,
        millimeters: 1e3 * e.earthRadius,
        millimetres: 1e3 * e.earthRadius,
        nauticalmiles: e.earthRadius / 1852,
        radians: 1,
        yards: e.earthRadius / 1.0936
    },
    e.unitsFactors = {
        centimeters: 100,
        centimetres: 100,
        degrees: 1 / 111325,
        feet: 3.28084,
        inches: 39.37,
        kilometers: .001,
        kilometres: .001,
        meters: 1,
        metres: 1,
        miles: 1 / 1609.344,
        millimeters: 1e3,
        millimetres: 1e3,
        nauticalmiles: 1 / 1852,
        radians: 1 / e.earthRadius,
        yards: 1 / 1.0936
    },
    e.areaFactors = {
        acres: 247105e-9,
        centimeters: 1e4,
        centimetres: 1e4,
        feet: 10.763910417,
        inches: 1550.003100006,
        kilometers: 1e-6,
        kilometres: 1e-6,
        meters: 1,
        metres: 1,
        miles: 3.86e-7,
        millimeters: 1e6,
        millimetres: 1e6,
        yards: 1.195990046
    },
    e.feature = r,
    e.geometry = function(t, e, n) {
        switch (void 0 === n && (n = {}),
        t) {
        case "Point":
            return a(e).geometry;
        case "LineString":
            return o(e).geometry;
        case "Polygon":
            return i(e).geometry;
        case "MultiPoint":
            return u(e).geometry;
        case "MultiLineString":
            return l(e).geometry;
        case "MultiPolygon":
            return c(e).geometry;
        default:
            throw new Error(t + " is invalid")
        }
    }
    ,
    e.point = a,
    e.points = function(t, e, n) {
        return void 0 === n && (n = {}),
        s(t.map(function(t) {
            return a(t, e)
        }), n)
    }
    ,
    e.polygon = i,
    e.polygons = function(t, e, n) {
        return void 0 === n && (n = {}),
        s(t.map(function(t) {
            return i(t, e)
        }), n)
    }
    ,
    e.lineString = o,
    e.lineStrings = function(t, e, n) {
        return void 0 === n && (n = {}),
        s(t.map(function(t) {
            return o(t, e)
        }), n)
    }
    ,
    e.featureCollection = s,
    e.multiLineString = l,
    e.multiPoint = u,
    e.multiPolygon = c,
    e.geometryCollection = function(t, e, n) {
        return void 0 === n && (n = {}),
        r({
            type: "GeometryCollection",
            geometries: t
        }, e, n)
    }
    ,
    e.round = function(t, e) {
        if (void 0 === e && (e = 0),
        e && !(e >= 0))
            throw new Error("precision must be a positive number");
        var n = Math.pow(10, e || 0);
        return Math.round(t * n) / n
    }
    ,
    e.radiansToLength = h,
    e.lengthToRadians = d,
    e.lengthToDegrees = function(t, e) {
        return f(d(t, e))
    }
    ,
    e.bearingToAzimuth = function(t) {
        var e = t % 360;
        return e < 0 && (e += 360),
        e
    }
    ,
    e.radiansToDegrees = f,
    e.degreesToRadians = function(t) {
        return t % 360 * Math.PI / 180
    }
    ,
    e.convertLength = function(t, e, n) {
        if (void 0 === e && (e = "kilometers"),
        void 0 === n && (n = "kilometers"),
        !(t >= 0))
            throw new Error("length must be a positive number");
        return h(d(t, e), n)
    }
    ,
    e.convertArea = function(t, n, r) {
        if (void 0 === n && (n = "meters"),
        void 0 === r && (r = "kilometers"),
        !(t >= 0))
            throw new Error("area must be a positive number");
        var a = e.areaFactors[n];
        if (!a)
            throw new Error("invalid original units");
        var i = e.areaFactors[r];
        if (!i)
            throw new Error("invalid final units");
        return t / a * i
    }
    ,
    e.isNumber = p,
    e.isObject = function(t) {
        return !!t && t.constructor === Object
    }
    ,
    e.validateBBox = function(t) {
        if (!t)
            throw new Error("bbox is required");
        if (!Array.isArray(t))
            throw new Error("bbox must be an Array");
        if (4 !== t.length && 6 !== t.length)
            throw new Error("bbox must be an Array of 4 or 6 numbers");
        t.forEach(function(t) {
            if (!p(t))
                throw new Error("bbox must only contain numbers")
        })
    }
    ,
    e.validateId = function(t) {
        if (!t)
            throw new Error("id is required");
        if (-1 === ["string", "number"].indexOf(typeof t))
            throw new Error("id must be a number or a string")
    }
    ,
    e.radians2degrees = function() {
        throw new Error("method has been renamed to `radiansToDegrees`")
    }
    ,
    e.degrees2radians = function() {
        throw new Error("method has been renamed to `degreesToRadians`")
    }
    ,
    e.distanceToDegrees = function() {
        throw new Error("method has been renamed to `lengthToDegrees`")
    }
    ,
    e.distanceToRadians = function() {
        throw new Error("method has been renamed to `lengthToRadians`")
    }
    ,
    e.radiansToDistance = function() {
        throw new Error("method has been renamed to `radiansToLength`")
    }
    ,
    e.bearingToAngle = function() {
        throw new Error("method has been renamed to `bearingToAzimuth`")
    }
    ,
    e.convertDistance = function() {
        throw new Error("method has been renamed to `convertLength`")
    }
}
, function(t, e, n) {
    "use strict";
    e.a = {
        None: 0,
        DepthGlobe: 1,
        Earth: 2
    }
}
, function(t, e, n) {
    var r, a, i, o, s, l, u, c;
    t.exports = (r = n(3),
    n(14),
    n(15),
    i = (a = r).lib,
    o = i.Base,
    s = i.WordArray,
    l = a.algo,
    u = l.MD5,
    c = l.EvpKDF = o.extend({
        cfg: o.extend({
            keySize: 4,
            hasher: u,
            iterations: 1
        }),
        init: function(t) {
            this.cfg = this.cfg.extend(t)
        },
        compute: function(t, e) {
            for (var n = this.cfg, r = n.hasher.create(), a = s.create(), i = a.words, o = n.keySize, l = n.iterations; i.length < o; ) {
                u && r.update(u);
                var u = r.update(t).finalize(e);
                r.reset();
                for (var c = 1; c < l; c++)
                    u = r.finalize(u),
                    r.reset();
                a.concat(u)
            }
            return a.sigBytes = 4 * o,
            a
        }
    }),
    a.EvpKDF = function(t, e, n) {
        return c.create(n).compute(t, e)
    }
    ,
    r.EvpKDF)
}
, function(t, e, n) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = n(6);
    function a(t, e, n) {
        if (null !== t)
            for (var r, i, o, s, l, u, c, h, d = 0, f = 0, p = t.type, m = "FeatureCollection" === p, g = "Feature" === p, v = m ? t.features.length : 1, y = 0; y < v; y++) {
                l = (h = !!(c = m ? t.features[y].geometry : g ? t.geometry : t) && "GeometryCollection" === c.type) ? c.geometries.length : 1;
                for (var _ = 0; _ < l; _++) {
                    var x = 0
                      , b = 0;
                    if (null !== (s = h ? c.geometries[_] : c)) {
                        u = s.coordinates;
                        var w = s.type;
                        switch (d = !n || "Polygon" !== w && "MultiPolygon" !== w ? 0 : 1,
                        w) {
                        case null:
                            break;
                        case "Point":
                            if (!1 === e(u, f, y, x, b))
                                return !1;
                            f++,
                            x++;
                            break;
                        case "LineString":
                        case "MultiPoint":
                            for (r = 0; r < u.length; r++) {
                                if (!1 === e(u[r], f, y, x, b))
                                    return !1;
                                f++,
                                "MultiPoint" === w && x++
                            }
                            "LineString" === w && x++;
                            break;
                        case "Polygon":
                        case "MultiLineString":
                            for (r = 0; r < u.length; r++) {
                                for (i = 0; i < u[r].length - d; i++) {
                                    if (!1 === e(u[r][i], f, y, x, b))
                                        return !1;
                                    f++
                                }
                                "MultiLineString" === w && x++,
                                "Polygon" === w && b++
                            }
                            "Polygon" === w && x++;
                            break;
                        case "MultiPolygon":
                            for (r = 0; r < u.length; r++) {
                                for (b = 0,
                                i = 0; i < u[r].length; i++) {
                                    for (o = 0; o < u[r][i].length - d; o++) {
                                        if (!1 === e(u[r][i][o], f, y, x, b))
                                            return !1;
                                        f++
                                    }
                                    b++
                                }
                                x++
                            }
                            break;
                        case "GeometryCollection":
                            for (r = 0; r < s.geometries.length; r++)
                                if (!1 === a(s.geometries[r], e, n))
                                    return !1;
                            break;
                        default:
                            throw new Error("Unknown Geometry Type")
                        }
                    }
                }
            }
    }
    function i(t, e) {
        var n;
        switch (t.type) {
        case "FeatureCollection":
            for (n = 0; n < t.features.length && !1 !== e(t.features[n].properties, n); n++)
                ;
            break;
        case "Feature":
            e(t.properties, 0)
        }
    }
    function o(t, e) {
        if ("Feature" === t.type)
            e(t, 0);
        else if ("FeatureCollection" === t.type)
            for (var n = 0; n < t.features.length && !1 !== e(t.features[n], n); n++)
                ;
    }
    function s(t, e) {
        var n, r, a, i, o, s, l, u, c, h, d = 0, f = "FeatureCollection" === t.type, p = "Feature" === t.type, m = f ? t.features.length : 1;
        for (n = 0; n < m; n++) {
            for (s = f ? t.features[n].geometry : p ? t.geometry : t,
            u = f ? t.features[n].properties : p ? t.properties : {},
            c = f ? t.features[n].bbox : p ? t.bbox : void 0,
            h = f ? t.features[n].id : p ? t.id : void 0,
            o = (l = !!s && "GeometryCollection" === s.type) ? s.geometries.length : 1,
            a = 0; a < o; a++)
                if (null !== (i = l ? s.geometries[a] : s))
                    switch (i.type) {
                    case "Point":
                    case "LineString":
                    case "MultiPoint":
                    case "Polygon":
                    case "MultiLineString":
                    case "MultiPolygon":
                        if (!1 === e(i, d, u, c, h))
                            return !1;
                        break;
                    case "GeometryCollection":
                        for (r = 0; r < i.geometries.length; r++)
                            if (!1 === e(i.geometries[r], d, u, c, h))
                                return !1;
                        break;
                    default:
                        throw new Error("Unknown Geometry Type")
                    }
                else if (!1 === e(null, d, u, c, h))
                    return !1;
            d++
        }
    }
    function l(t, e) {
        s(t, function(t, n, a, i, o) {
            var s, l = null === t ? null : t.type;
            switch (l) {
            case null:
            case "Point":
            case "LineString":
            case "Polygon":
                return !1 !== e(r.feature(t, a, {
                    bbox: i,
                    id: o
                }), n, 0) && void 0
            }
            switch (l) {
            case "MultiPoint":
                s = "Point";
                break;
            case "MultiLineString":
                s = "LineString";
                break;
            case "MultiPolygon":
                s = "Polygon"
            }
            for (var u = 0; u < t.coordinates.length; u++) {
                var c = {
                    type: s,
                    coordinates: t.coordinates[u]
                };
                if (!1 === e(r.feature(c, a), n, u))
                    return !1
            }
        })
    }
    function u(t, e) {
        l(t, function(t, n, i) {
            var o = 0;
            if (t.geometry) {
                var s = t.geometry.type;
                if ("Point" !== s && "MultiPoint" !== s) {
                    var l, u = 0, c = 0, h = 0;
                    return !1 !== a(t, function(a, s, d, f, p) {
                        if (void 0 === l || n > u || f > c || p > h)
                            return l = a,
                            u = n,
                            c = f,
                            h = p,
                            void (o = 0);
                        var m = r.lineString([l, a], t.properties);
                        if (!1 === e(m, n, i, p, o))
                            return !1;
                        o++,
                        l = a
                    }) && void 0
                }
            }
        })
    }
    function c(t, e) {
        if (!t)
            throw new Error("geojson is required");
        l(t, function(t, n, a) {
            if (null !== t.geometry) {
                var i = t.geometry.type
                  , o = t.geometry.coordinates;
                switch (i) {
                case "LineString":
                    if (!1 === e(t, n, a, 0, 0))
                        return !1;
                    break;
                case "Polygon":
                    for (var s = 0; s < o.length; s++)
                        if (!1 === e(r.lineString(o[s], t.properties), n, a, s))
                            return !1
                }
            }
        })
    }
    e.coordEach = a,
    e.coordReduce = function(t, e, n, r) {
        var i = n;
        return a(t, function(t, r, a, o, s) {
            i = 0 === r && void 0 === n ? t : e(i, t, r, a, o, s)
        }, r),
        i
    }
    ,
    e.propEach = i,
    e.propReduce = function(t, e, n) {
        var r = n;
        return i(t, function(t, a) {
            r = 0 === a && void 0 === n ? t : e(r, t, a)
        }),
        r
    }
    ,
    e.featureEach = o,
    e.featureReduce = function(t, e, n) {
        var r = n;
        return o(t, function(t, a) {
            r = 0 === a && void 0 === n ? t : e(r, t, a)
        }),
        r
    }
    ,
    e.coordAll = function(t) {
        var e = [];
        return a(t, function(t) {
            e.push(t)
        }),
        e
    }
    ,
    e.geomEach = s,
    e.geomReduce = function(t, e, n) {
        var r = n;
        return s(t, function(t, a, i, o, s) {
            r = 0 === a && void 0 === n ? t : e(r, t, a, i, o, s)
        }),
        r
    }
    ,
    e.flattenEach = l,
    e.flattenReduce = function(t, e, n) {
        var r = n;
        return l(t, function(t, a, i) {
            r = 0 === a && 0 === i && void 0 === n ? t : e(r, t, a, i)
        }),
        r
    }
    ,
    e.segmentEach = u,
    e.segmentReduce = function(t, e, n) {
        var r = n
          , a = !1;
        return u(t, function(t, i, o, s, l) {
            r = !1 === a && void 0 === n ? t : e(r, t, i, o, s, l),
            a = !0
        }),
        r
    }
    ,
    e.lineEach = c,
    e.lineReduce = function(t, e, n) {
        var r = n;
        return c(t, function(t, a, i, o) {
            r = 0 === a && void 0 === n ? t : e(r, t, a, i, o)
        }),
        r
    }
    ,
    e.findSegment = function(t, e) {
        if (e = e || {},
        !r.isObject(e))
            throw new Error("options is invalid");
        var n, a = e.featureIndex || 0, i = e.multiFeatureIndex || 0, o = e.geometryIndex || 0, s = e.segmentIndex || 0, l = e.properties;
        switch (t.type) {
        case "FeatureCollection":
            a < 0 && (a = t.features.length + a),
            l = l || t.features[a].properties,
            n = t.features[a].geometry;
            break;
        case "Feature":
            l = l || t.properties,
            n = t.geometry;
            break;
        case "Point":
        case "MultiPoint":
            return null;
        case "LineString":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon":
            n = t;
            break;
        default:
            throw new Error("geojson is invalid")
        }
        if (null === n)
            return null;
        var u = n.coordinates;
        switch (n.type) {
        case "Point":
        case "MultiPoint":
            return null;
        case "LineString":
            return s < 0 && (s = u.length + s - 1),
            r.lineString([u[s], u[s + 1]], l, e);
        case "Polygon":
            return o < 0 && (o = u.length + o),
            s < 0 && (s = u[o].length + s - 1),
            r.lineString([u[o][s], u[o][s + 1]], l, e);
        case "MultiLineString":
            return i < 0 && (i = u.length + i),
            s < 0 && (s = u[i].length + s - 1),
            r.lineString([u[i][s], u[i][s + 1]], l, e);
        case "MultiPolygon":
            return i < 0 && (i = u.length + i),
            o < 0 && (o = u[i].length + o),
            s < 0 && (s = u[i][o].length - s - 1),
            r.lineString([u[i][o][s], u[i][o][s + 1]], l, e)
        }
        throw new Error("geojson is invalid")
    }
    ,
    e.findPoint = function(t, e) {
        if (e = e || {},
        !r.isObject(e))
            throw new Error("options is invalid");
        var n, a = e.featureIndex || 0, i = e.multiFeatureIndex || 0, o = e.geometryIndex || 0, s = e.coordIndex || 0, l = e.properties;
        switch (t.type) {
        case "FeatureCollection":
            a < 0 && (a = t.features.length + a),
            l = l || t.features[a].properties,
            n = t.features[a].geometry;
            break;
        case "Feature":
            l = l || t.properties,
            n = t.geometry;
            break;
        case "Point":
        case "MultiPoint":
            return null;
        case "LineString":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon":
            n = t;
            break;
        default:
            throw new Error("geojson is invalid")
        }
        if (null === n)
            return null;
        var u = n.coordinates;
        switch (n.type) {
        case "Point":
            return r.point(u, l, e);
        case "MultiPoint":
            return i < 0 && (i = u.length + i),
            r.point(u[i], l, e);
        case "LineString":
            return s < 0 && (s = u.length + s),
            r.point(u[s], l, e);
        case "Polygon":
            return o < 0 && (o = u.length + o),
            s < 0 && (s = u[o].length + s),
            r.point(u[o][s], l, e);
        case "MultiLineString":
            return i < 0 && (i = u.length + i),
            s < 0 && (s = u[i].length + s),
            r.point(u[i][s], l, e);
        case "MultiPolygon":
            return i < 0 && (i = u.length + i),
            o < 0 && (o = u[i].length + o),
            s < 0 && (s = u[i][o].length - s),
            r.point(u[i][o][s], l, e)
        }
        throw new Error("geojson is invalid")
    }
}
, function(t, e, n) {
    var r, a, i;
    t.exports = (r = n(3),
    i = (a = r).lib.WordArray,
    a.enc.Base64 = {
        stringify: function(t) {
            var e = t.words
              , n = t.sigBytes
              , r = this._map;
            t.clamp();
            for (var a = [], i = 0; i < n; i += 3)
                for (var o = (e[i >>> 2] >>> 24 - i % 4 * 8 & 255) << 16 | (e[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255) << 8 | e[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255, s = 0; s < 4 && i + .75 * s < n; s++)
                    a.push(r.charAt(o >>> 6 * (3 - s) & 63));
            var l = r.charAt(64);
            if (l)
                for (; a.length % 4; )
                    a.push(l);
            return a.join("")
        },
        parse: function(t) {
            var e = t.length
              , n = this._map
              , r = this._reverseMap;
            if (!r) {
                r = this._reverseMap = [];
                for (var a = 0; a < n.length; a++)
                    r[n.charCodeAt(a)] = a
            }
            var o = n.charAt(64);
            if (o) {
                var s = t.indexOf(o);
                -1 !== s && (e = s)
            }
            return function(t, e, n) {
                for (var r = [], a = 0, o = 0; o < e; o++)
                    if (o % 4) {
                        var s = n[t.charCodeAt(o - 1)] << o % 4 * 2
                          , l = n[t.charCodeAt(o)] >>> 6 - o % 4 * 2;
                        r[a >>> 2] |= (s | l) << 24 - a % 4 * 8,
                        a++
                    }
                return i.create(r, a)
            }(t, e, r)
        },
        _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
    },
    r.enc.Base64)
}
, function(t, e, n) {
    var r;
    t.exports = (r = n(3),
    function(t) {
        var e = r
          , n = e.lib
          , a = n.WordArray
          , i = n.Hasher
          , o = e.algo
          , s = [];
        !function() {
            for (var e = 0; e < 64; e++)
                s[e] = 4294967296 * t.abs(t.sin(e + 1)) | 0
        }();
        var l = o.MD5 = i.extend({
            _doReset: function() {
                this._hash = new a.init([1732584193, 4023233417, 2562383102, 271733878])
            },
            _doProcessBlock: function(t, e) {
                for (var n = 0; n < 16; n++) {
                    var r = e + n
                      , a = t[r];
                    t[r] = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8)
                }
                var i = this._hash.words
                  , o = t[e + 0]
                  , l = t[e + 1]
                  , f = t[e + 2]
                  , p = t[e + 3]
                  , m = t[e + 4]
                  , g = t[e + 5]
                  , v = t[e + 6]
                  , y = t[e + 7]
                  , _ = t[e + 8]
                  , x = t[e + 9]
                  , b = t[e + 10]
                  , w = t[e + 11]
                  , C = t[e + 12]
                  , E = t[e + 13]
                  , T = t[e + 14]
                  , M = t[e + 15]
                  , A = i[0]
                  , P = i[1]
                  , S = i[2]
                  , R = i[3];
                A = u(A, P, S, R, o, 7, s[0]),
                R = u(R, A, P, S, l, 12, s[1]),
                S = u(S, R, A, P, f, 17, s[2]),
                P = u(P, S, R, A, p, 22, s[3]),
                A = u(A, P, S, R, m, 7, s[4]),
                R = u(R, A, P, S, g, 12, s[5]),
                S = u(S, R, A, P, v, 17, s[6]),
                P = u(P, S, R, A, y, 22, s[7]),
                A = u(A, P, S, R, _, 7, s[8]),
                R = u(R, A, P, S, x, 12, s[9]),
                S = u(S, R, A, P, b, 17, s[10]),
                P = u(P, S, R, A, w, 22, s[11]),
                A = u(A, P, S, R, C, 7, s[12]),
                R = u(R, A, P, S, E, 12, s[13]),
                S = u(S, R, A, P, T, 17, s[14]),
                A = c(A, P = u(P, S, R, A, M, 22, s[15]), S, R, l, 5, s[16]),
                R = c(R, A, P, S, v, 9, s[17]),
                S = c(S, R, A, P, w, 14, s[18]),
                P = c(P, S, R, A, o, 20, s[19]),
                A = c(A, P, S, R, g, 5, s[20]),
                R = c(R, A, P, S, b, 9, s[21]),
                S = c(S, R, A, P, M, 14, s[22]),
                P = c(P, S, R, A, m, 20, s[23]),
                A = c(A, P, S, R, x, 5, s[24]),
                R = c(R, A, P, S, T, 9, s[25]),
                S = c(S, R, A, P, p, 14, s[26]),
                P = c(P, S, R, A, _, 20, s[27]),
                A = c(A, P, S, R, E, 5, s[28]),
                R = c(R, A, P, S, f, 9, s[29]),
                S = c(S, R, A, P, y, 14, s[30]),
                A = h(A, P = c(P, S, R, A, C, 20, s[31]), S, R, g, 4, s[32]),
                R = h(R, A, P, S, _, 11, s[33]),
                S = h(S, R, A, P, w, 16, s[34]),
                P = h(P, S, R, A, T, 23, s[35]),
                A = h(A, P, S, R, l, 4, s[36]),
                R = h(R, A, P, S, m, 11, s[37]),
                S = h(S, R, A, P, y, 16, s[38]),
                P = h(P, S, R, A, b, 23, s[39]),
                A = h(A, P, S, R, E, 4, s[40]),
                R = h(R, A, P, S, o, 11, s[41]),
                S = h(S, R, A, P, p, 16, s[42]),
                P = h(P, S, R, A, v, 23, s[43]),
                A = h(A, P, S, R, x, 4, s[44]),
                R = h(R, A, P, S, C, 11, s[45]),
                S = h(S, R, A, P, M, 16, s[46]),
                A = d(A, P = h(P, S, R, A, f, 23, s[47]), S, R, o, 6, s[48]),
                R = d(R, A, P, S, y, 10, s[49]),
                S = d(S, R, A, P, T, 15, s[50]),
                P = d(P, S, R, A, g, 21, s[51]),
                A = d(A, P, S, R, C, 6, s[52]),
                R = d(R, A, P, S, p, 10, s[53]),
                S = d(S, R, A, P, b, 15, s[54]),
                P = d(P, S, R, A, l, 21, s[55]),
                A = d(A, P, S, R, _, 6, s[56]),
                R = d(R, A, P, S, M, 10, s[57]),
                S = d(S, R, A, P, v, 15, s[58]),
                P = d(P, S, R, A, E, 21, s[59]),
                A = d(A, P, S, R, m, 6, s[60]),
                R = d(R, A, P, S, w, 10, s[61]),
                S = d(S, R, A, P, f, 15, s[62]),
                P = d(P, S, R, A, x, 21, s[63]),
                i[0] = i[0] + A | 0,
                i[1] = i[1] + P | 0,
                i[2] = i[2] + S | 0,
                i[3] = i[3] + R | 0
            },
            _doFinalize: function() {
                var e = this._data
                  , n = e.words
                  , r = 8 * this._nDataBytes
                  , a = 8 * e.sigBytes;
                n[a >>> 5] |= 128 << 24 - a % 32;
                var i = t.floor(r / 4294967296)
                  , o = r;
                n[15 + (a + 64 >>> 9 << 4)] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8),
                n[14 + (a + 64 >>> 9 << 4)] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8),
                e.sigBytes = 4 * (n.length + 1),
                this._process();
                for (var s = this._hash, l = s.words, u = 0; u < 4; u++) {
                    var c = l[u];
                    l[u] = 16711935 & (c << 8 | c >>> 24) | 4278255360 & (c << 24 | c >>> 8)
                }
                return s
            },
            clone: function() {
                var t = i.clone.call(this);
                return t._hash = this._hash.clone(),
                t
            }
        });
        function u(t, e, n, r, a, i, o) {
            var s = t + (e & n | ~e & r) + a + o;
            return (s << i | s >>> 32 - i) + e
        }
        function c(t, e, n, r, a, i, o) {
            var s = t + (e & r | n & ~r) + a + o;
            return (s << i | s >>> 32 - i) + e
        }
        function h(t, e, n, r, a, i, o) {
            var s = t + (e ^ n ^ r) + a + o;
            return (s << i | s >>> 32 - i) + e
        }
        function d(t, e, n, r, a, i, o) {
            var s = t + (n ^ (e | ~r)) + a + o;
            return (s << i | s >>> 32 - i) + e
        }
        e.MD5 = i._createHelper(l),
        e.HmacMD5 = i._createHmacHelper(l)
    }(Math),
    r.MD5)
}
, function(t, e, n) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = n(6);
    e.getCoord = function(t) {
        if (!t)
            throw new Error("coord is required");
        if (!Array.isArray(t)) {
            if ("Feature" === t.type && null !== t.geometry && "Point" === t.geometry.type)
                return t.geometry.coordinates;
            if ("Point" === t.type)
                return t.coordinates
        }
        if (Array.isArray(t) && t.length >= 2 && !Array.isArray(t[0]) && !Array.isArray(t[1]))
            return t;
        throw new Error("coord must be GeoJSON Point or an Array of numbers")
    }
    ,
    e.getCoords = function(t) {
        if (Array.isArray(t))
            return t;
        if ("Feature" === t.type) {
            if (null !== t.geometry)
                return t.geometry.coordinates
        } else if (t.coordinates)
            return t.coordinates;
        throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")
    }
    ,
    e.containsNumber = function t(e) {
        if (e.length > 1 && r.isNumber(e[0]) && r.isNumber(e[1]))
            return !0;
        if (Array.isArray(e[0]) && e[0].length)
            return t(e[0]);
        throw new Error("coordinates must only contain numbers")
    }
    ,
    e.geojsonType = function(t, e, n) {
        if (!e || !n)
            throw new Error("type and name required");
        if (!t || t.type !== e)
            throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + t.type)
    }
    ,
    e.featureOf = function(t, e, n) {
        if (!t)
            throw new Error("No feature passed");
        if (!n)
            throw new Error(".featureOf() requires a name");
        if (!t || "Feature" !== t.type || !t.geometry)
            throw new Error("Invalid input to " + n + ", Feature with geometry required");
        if (!t.geometry || t.geometry.type !== e)
            throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + t.geometry.type)
    }
    ,
    e.collectionOf = function(t, e, n) {
        if (!t)
            throw new Error("No featureCollection passed");
        if (!n)
            throw new Error(".collectionOf() requires a name");
        if (!t || "FeatureCollection" !== t.type)
            throw new Error("Invalid input to " + n + ", FeatureCollection required");
        for (var r = 0, a = t.features; r < a.length; r++) {
            var i = a[r];
            if (!i || "Feature" !== i.type || !i.geometry)
                throw new Error("Invalid input to " + n + ", Feature with geometry required");
            if (!i.geometry || i.geometry.type !== e)
                throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + i.geometry.type)
        }
    }
    ,
    e.getGeom = function(t) {
        return "Feature" === t.type ? t.geometry : t
    }
    ,
    e.getType = function(t, e) {
        return "FeatureCollection" === t.type ? "FeatureCollection" : "GeometryCollection" === t.type ? "GeometryCollection" : "Feature" === t.type && null !== t.geometry ? t.geometry.type : t.type
    }
}
, function(t, e, n) {
    var r, a, i, o, s, l;
    t.exports = (r = n(3),
    i = (a = r).lib,
    o = i.Base,
    s = i.WordArray,
    (l = a.x64 = {}).Word = o.extend({
        init: function(t, e) {
            this.high = t,
            this.low = e
        }
    }),
    l.WordArray = o.extend({
        init: function(t, e) {
            t = this.words = t || [],
            this.sigBytes = null != e ? e : 8 * t.length
        },
        toX32: function() {
            for (var t = this.words, e = t.length, n = [], r = 0; r < e; r++) {
                var a = t[r];
                n.push(a.high),
                n.push(a.low)
            }
            return s.create(n, this.sigBytes)
        },
        clone: function() {
            for (var t = o.clone.call(this), e = t.words = this.words.slice(0), n = e.length, r = 0; r < n; r++)
                e[r] = e[r].clone();
            return t
        }
    }),
    r)
}
, function(t, e, n) {
    var r, a, i, o, s, l, u, c;
    t.exports = (r = n(3),
    i = (a = r).lib,
    o = i.WordArray,
    s = i.Hasher,
    l = a.algo,
    u = [],
    c = l.SHA1 = s.extend({
        _doReset: function() {
            this._hash = new o.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
        },
        _doProcessBlock: function(t, e) {
            for (var n = this._hash.words, r = n[0], a = n[1], i = n[2], o = n[3], s = n[4], l = 0; l < 80; l++) {
                if (l < 16)
                    u[l] = 0 | t[e + l];
                else {
                    var c = u[l - 3] ^ u[l - 8] ^ u[l - 14] ^ u[l - 16];
                    u[l] = c << 1 | c >>> 31
                }
                var h = (r << 5 | r >>> 27) + s + u[l];
                h += l < 20 ? 1518500249 + (a & i | ~a & o) : l < 40 ? 1859775393 + (a ^ i ^ o) : l < 60 ? (a & i | a & o | i & o) - 1894007588 : (a ^ i ^ o) - 899497514,
                s = o,
                o = i,
                i = a << 30 | a >>> 2,
                a = r,
                r = h
            }
            n[0] = n[0] + r | 0,
            n[1] = n[1] + a | 0,
            n[2] = n[2] + i | 0,
            n[3] = n[3] + o | 0,
            n[4] = n[4] + s | 0
        },
        _doFinalize: function() {
            var t = this._data
              , e = t.words
              , n = 8 * this._nDataBytes
              , r = 8 * t.sigBytes;
            return e[r >>> 5] |= 128 << 24 - r % 32,
            e[14 + (r + 64 >>> 9 << 4)] = Math.floor(n / 4294967296),
            e[15 + (r + 64 >>> 9 << 4)] = n,
            t.sigBytes = 4 * e.length,
            this._process(),
            this._hash
        },
        clone: function() {
            var t = s.clone.call(this);
            return t._hash = this._hash.clone(),
            t
        }
    }),
    a.SHA1 = s._createHelper(c),
    a.HmacSHA1 = s._createHmacHelper(c),
    r.SHA1)
}
, function(t, e, n) {
    var r, a, i, o, s, l, u;
    t.exports = (r = n(3),
    i = (a = r).lib,
    o = i.Base,
    s = a.enc,
    l = s.Utf8,
    u = a.algo,
    void (u.HMAC = o.extend({
        init: function(t, e) {
            t = this._hasher = new t.init,
            "string" == typeof e && (e = l.parse(e));
            var n = t.blockSize
              , r = 4 * n;
            e.sigBytes > r && (e = t.finalize(e)),
            e.clamp();
            for (var a = this._oKey = e.clone(), i = this._iKey = e.clone(), o = a.words, s = i.words, u = 0; u < n; u++)
                o[u] ^= 1549556828,
                s[u] ^= 909522486;
            a.sigBytes = i.sigBytes = r,
            this.reset()
        },
        reset: function() {
            var t = this._hasher;
            t.reset(),
            t.update(this._iKey)
        },
        update: function(t) {
            return this._hasher.update(t),
            this
        },
        finalize: function(t) {
            var e = this._hasher
              , n = e.finalize(t);
            e.reset();
            var r = e.finalize(this._oKey.clone().concat(n));
            return r
        }
    })))
}
, function(t, e, n) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = n(9);
    e.default = function(t) {
        var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        return r.coordEach(t, function(t) {
            e[0] > t[0] && (e[0] = t[0]),
            e[1] > t[1] && (e[1] = t[1]),
            e[2] < t[0] && (e[2] = t[0]),
            e[3] < t[1] && (e[3] = t[1])
        }),
        e
    }
}
, function(t, e) {
    t.exports = function(t, e) {
        if (null === t)
            throw new Error("No coordinates passed");
        for (var n = 0; n < t.length; n++)
            for (var r = t[n], a = 0; a < r[r.length - 1].length; a++) {
                if (r.length < 4)
                    throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
                if (r[r.length - 1][a] !== r[0][a])
                    throw new Error("First and last Position are not equivalent.")
            }
        var i = {
            type: "Feature",
            geometry: {
                type: "Polygon",
                coordinates: t
            },
            properties: e
        };
        return i.properties || (i.properties = {}),
        i
    }
}
, function(t, e, n) {
    var r;
    t.exports = (r = n(3),
    function(t) {
        var e = r
          , n = e.lib
          , a = n.WordArray
          , i = n.Hasher
          , o = e.algo
          , s = []
          , l = [];
        !function() {
            function e(e) {
                for (var n = t.sqrt(e), r = 2; r <= n; r++)
                    if (!(e % r))
                        return !1;
                return !0
            }
            function n(t) {
                return 4294967296 * (t - (0 | t)) | 0
            }
            for (var r = 2, a = 0; a < 64; )
                e(r) && (a < 8 && (s[a] = n(t.pow(r, .5))),
                l[a] = n(t.pow(r, 1 / 3)),
                a++),
                r++
        }();
        var u = []
          , c = o.SHA256 = i.extend({
            _doReset: function() {
                this._hash = new a.init(s.slice(0))
            },
            _doProcessBlock: function(t, e) {
                for (var n = this._hash.words, r = n[0], a = n[1], i = n[2], o = n[3], s = n[4], c = n[5], h = n[6], d = n[7], f = 0; f < 64; f++) {
                    if (f < 16)
                        u[f] = 0 | t[e + f];
                    else {
                        var p = u[f - 15]
                          , m = (p << 25 | p >>> 7) ^ (p << 14 | p >>> 18) ^ p >>> 3
                          , g = u[f - 2]
                          , v = (g << 15 | g >>> 17) ^ (g << 13 | g >>> 19) ^ g >>> 10;
                        u[f] = m + u[f - 7] + v + u[f - 16]
                    }
                    var y = r & a ^ r & i ^ a & i
                      , _ = (r << 30 | r >>> 2) ^ (r << 19 | r >>> 13) ^ (r << 10 | r >>> 22)
                      , x = d + ((s << 26 | s >>> 6) ^ (s << 21 | s >>> 11) ^ (s << 7 | s >>> 25)) + (s & c ^ ~s & h) + l[f] + u[f];
                    d = h,
                    h = c,
                    c = s,
                    s = o + x | 0,
                    o = i,
                    i = a,
                    a = r,
                    r = x + (_ + y) | 0
                }
                n[0] = n[0] + r | 0,
                n[1] = n[1] + a | 0,
                n[2] = n[2] + i | 0,
                n[3] = n[3] + o | 0,
                n[4] = n[4] + s | 0,
                n[5] = n[5] + c | 0,
                n[6] = n[6] + h | 0,
                n[7] = n[7] + d | 0
            },
            _doFinalize: function() {
                var e = this._data
                  , n = e.words
                  , r = 8 * this._nDataBytes
                  , a = 8 * e.sigBytes;
                return n[a >>> 5] |= 128 << 24 - a % 32,
                n[14 + (a + 64 >>> 9 << 4)] = t.floor(r / 4294967296),
                n[15 + (a + 64 >>> 9 << 4)] = r,
                e.sigBytes = 4 * n.length,
                this._process(),
                this._hash
            },
            clone: function() {
                var t = i.clone.call(this);
                return t._hash = this._hash.clone(),
                t
            }
        });
        e.SHA256 = i._createHelper(c),
        e.HmacSHA256 = i._createHmacHelper(c)
    }(Math),
    r.SHA256)
}
, function(t, e, n) {
    var r;
    t.exports = (r = n(3),
    n(13),
    function() {
        var t = r
          , e = t.lib.Hasher
          , n = t.x64
          , a = n.Word
          , i = n.WordArray
          , o = t.algo;
        function s() {
            return a.create.apply(a, arguments)
        }
        var l = [s(1116352408, 3609767458), s(1899447441, 602891725), s(3049323471, 3964484399), s(3921009573, 2173295548), s(961987163, 4081628472), s(1508970993, 3053834265), s(2453635748, 2937671579), s(2870763221, 3664609560), s(3624381080, 2734883394), s(310598401, 1164996542), s(607225278, 1323610764), s(1426881987, 3590304994), s(1925078388, 4068182383), s(2162078206, 991336113), s(2614888103, 633803317), s(3248222580, 3479774868), s(3835390401, 2666613458), s(4022224774, 944711139), s(264347078, 2341262773), s(604807628, 2007800933), s(770255983, 1495990901), s(1249150122, 1856431235), s(1555081692, 3175218132), s(1996064986, 2198950837), s(2554220882, 3999719339), s(2821834349, 766784016), s(2952996808, 2566594879), s(3210313671, 3203337956), s(3336571891, 1034457026), s(3584528711, 2466948901), s(113926993, 3758326383), s(338241895, 168717936), s(666307205, 1188179964), s(773529912, 1546045734), s(1294757372, 1522805485), s(1396182291, 2643833823), s(1695183700, 2343527390), s(1986661051, 1014477480), s(2177026350, 1206759142), s(2456956037, 344077627), s(2730485921, 1290863460), s(2820302411, 3158454273), s(3259730800, 3505952657), s(3345764771, 106217008), s(3516065817, 3606008344), s(3600352804, 1432725776), s(4094571909, 1467031594), s(275423344, 851169720), s(430227734, 3100823752), s(506948616, 1363258195), s(659060556, 3750685593), s(883997877, 3785050280), s(958139571, 3318307427), s(1322822218, 3812723403), s(1537002063, 2003034995), s(1747873779, 3602036899), s(1955562222, 1575990012), s(2024104815, 1125592928), s(2227730452, 2716904306), s(2361852424, 442776044), s(2428436474, 593698344), s(2756734187, 3733110249), s(3204031479, 2999351573), s(3329325298, 3815920427), s(3391569614, 3928383900), s(3515267271, 566280711), s(3940187606, 3454069534), s(4118630271, 4000239992), s(116418474, 1914138554), s(174292421, 2731055270), s(289380356, 3203993006), s(460393269, 320620315), s(685471733, 587496836), s(852142971, 1086792851), s(1017036298, 365543100), s(1126000580, 2618297676), s(1288033470, 3409855158), s(1501505948, 4234509866), s(1607167915, 987167468), s(1816402316, 1246189591)]
          , u = [];
        !function() {
            for (var t = 0; t < 80; t++)
                u[t] = s()
        }();
        var c = o.SHA512 = e.extend({
            _doReset: function() {
                this._hash = new i.init([new a.init(1779033703,4089235720), new a.init(3144134277,2227873595), new a.init(1013904242,4271175723), new a.init(2773480762,1595750129), new a.init(1359893119,2917565137), new a.init(2600822924,725511199), new a.init(528734635,4215389547), new a.init(1541459225,327033209)])
            },
            _doProcessBlock: function(t, e) {
                for (var n = this._hash.words, r = n[0], a = n[1], i = n[2], o = n[3], s = n[4], c = n[5], h = n[6], d = n[7], f = r.high, p = r.low, m = a.high, g = a.low, v = i.high, y = i.low, _ = o.high, x = o.low, b = s.high, w = s.low, C = c.high, E = c.low, T = h.high, M = h.low, A = d.high, P = d.low, S = f, R = p, D = m, j = g, L = v, I = y, O = _, k = x, H = b, F = w, B = C, U = E, N = T, z = M, q = A, V = P, W = 0; W < 80; W++) {
                    var G = u[W];
                    if (W < 16)
                        var Y = G.high = 0 | t[e + 2 * W]
                          , K = G.low = 0 | t[e + 2 * W + 1];
                    else {
                        var $ = u[W - 15]
                          , X = $.high
                          , J = $.low
                          , Q = (X >>> 1 | J << 31) ^ (X >>> 8 | J << 24) ^ X >>> 7
                          , Z = (J >>> 1 | X << 31) ^ (J >>> 8 | X << 24) ^ (J >>> 7 | X << 25)
                          , tt = u[W - 2]
                          , et = tt.high
                          , nt = tt.low
                          , rt = (et >>> 19 | nt << 13) ^ (et << 3 | nt >>> 29) ^ et >>> 6
                          , at = (nt >>> 19 | et << 13) ^ (nt << 3 | et >>> 29) ^ (nt >>> 6 | et << 26)
                          , it = u[W - 7]
                          , ot = it.high
                          , st = it.low
                          , lt = u[W - 16]
                          , ut = lt.high
                          , ct = lt.low;
                        Y = (Y = (Y = Q + ot + ((K = Z + st) >>> 0 < Z >>> 0 ? 1 : 0)) + rt + ((K += at) >>> 0 < at >>> 0 ? 1 : 0)) + ut + ((K += ct) >>> 0 < ct >>> 0 ? 1 : 0),
                        G.high = Y,
                        G.low = K
                    }
                    var ht, dt = H & B ^ ~H & N, ft = F & U ^ ~F & z, pt = S & D ^ S & L ^ D & L, mt = R & j ^ R & I ^ j & I, gt = (S >>> 28 | R << 4) ^ (S << 30 | R >>> 2) ^ (S << 25 | R >>> 7), vt = (R >>> 28 | S << 4) ^ (R << 30 | S >>> 2) ^ (R << 25 | S >>> 7), yt = (H >>> 14 | F << 18) ^ (H >>> 18 | F << 14) ^ (H << 23 | F >>> 9), _t = (F >>> 14 | H << 18) ^ (F >>> 18 | H << 14) ^ (F << 23 | H >>> 9), xt = l[W], bt = xt.high, wt = xt.low, Ct = q + yt + ((ht = V + _t) >>> 0 < V >>> 0 ? 1 : 0), Et = vt + mt;
                    q = N,
                    V = z,
                    N = B,
                    z = U,
                    B = H,
                    U = F,
                    H = O + (Ct = (Ct = (Ct = Ct + dt + ((ht += ft) >>> 0 < ft >>> 0 ? 1 : 0)) + bt + ((ht += wt) >>> 0 < wt >>> 0 ? 1 : 0)) + Y + ((ht += K) >>> 0 < K >>> 0 ? 1 : 0)) + ((F = k + ht | 0) >>> 0 < k >>> 0 ? 1 : 0) | 0,
                    O = L,
                    k = I,
                    L = D,
                    I = j,
                    D = S,
                    j = R,
                    S = Ct + (gt + pt + (Et >>> 0 < vt >>> 0 ? 1 : 0)) + ((R = ht + Et | 0) >>> 0 < ht >>> 0 ? 1 : 0) | 0
                }
                p = r.low = p + R,
                r.high = f + S + (p >>> 0 < R >>> 0 ? 1 : 0),
                g = a.low = g + j,
                a.high = m + D + (g >>> 0 < j >>> 0 ? 1 : 0),
                y = i.low = y + I,
                i.high = v + L + (y >>> 0 < I >>> 0 ? 1 : 0),
                x = o.low = x + k,
                o.high = _ + O + (x >>> 0 < k >>> 0 ? 1 : 0),
                w = s.low = w + F,
                s.high = b + H + (w >>> 0 < F >>> 0 ? 1 : 0),
                E = c.low = E + U,
                c.high = C + B + (E >>> 0 < U >>> 0 ? 1 : 0),
                M = h.low = M + z,
                h.high = T + N + (M >>> 0 < z >>> 0 ? 1 : 0),
                P = d.low = P + V,
                d.high = A + q + (P >>> 0 < V >>> 0 ? 1 : 0)
            },
            _doFinalize: function() {
                var t = this._data
                  , e = t.words
                  , n = 8 * this._nDataBytes
                  , r = 8 * t.sigBytes;
                return e[r >>> 5] |= 128 << 24 - r % 32,
                e[30 + (r + 128 >>> 10 << 5)] = Math.floor(n / 4294967296),
                e[31 + (r + 128 >>> 10 << 5)] = n,
                t.sigBytes = 4 * e.length,
                this._process(),
                this._hash.toX32()
            },
            clone: function() {
                var t = e.clone.call(this);
                return t._hash = this._hash.clone(),
                t
            },
            blockSize: 32
        });
        t.SHA512 = e._createHelper(c),
        t.HmacSHA512 = e._createHmacHelper(c)
    }(),
    r.SHA512)
}
, function(t, e, n) {
    (function(e) {
        t.exports = function() {
            "use strict";
            function t(t, e) {
                if (!(t instanceof e))
                    throw new TypeError("Cannot call a class as a function")
            }
            function n(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var r = e[n];
                    r.enumerable = r.enumerable || !1,
                    r.configurable = !0,
                    "value"in r && (r.writable = !0),
                    Object.defineProperty(t, r.key, r)
                }
            }
            function r(t, e, r) {
                return e && n(t.prototype, e),
                r && n(t, r),
                t
            }
            /**
   * splaytree v3.1.0
   * Fast Splay tree for Node and browser
   *
   * @author Alexander Milevski <info@w8r.name>
   * @license MIT
   * @preserve
   */
            var a = function(t, e) {
                this.next = null,
                this.key = t,
                this.data = e,
                this.left = null,
                this.right = null
            };
            function i(t, e) {
                return t > e ? 1 : t < e ? -1 : 0
            }
            function o(t, e, n) {
                for (var r = new a(null,null), i = r, o = r; ; ) {
                    var s = n(t, e.key);
                    if (s < 0) {
                        if (null === e.left)
                            break;
                        if (n(t, e.left.key) < 0) {
                            var l = e.left;
                            if (e.left = l.right,
                            l.right = e,
                            null === (e = l).left)
                                break
                        }
                        o.left = e,
                        o = e,
                        e = e.left
                    } else {
                        if (!(s > 0))
                            break;
                        if (null === e.right)
                            break;
                        if (n(t, e.right.key) > 0) {
                            var l = e.right;
                            if (e.right = l.left,
                            l.left = e,
                            null === (e = l).right)
                                break
                        }
                        i.right = e,
                        i = e,
                        e = e.right
                    }
                }
                return i.right = e.left,
                o.left = e.right,
                e.left = r.right,
                e.right = r.left,
                e
            }
            function s(t, e, n, r) {
                var i = new a(t,e);
                if (null === n)
                    return i.left = i.right = null,
                    i;
                n = o(t, n, r);
                var s = r(t, n.key);
                return s < 0 ? (i.left = n.left,
                i.right = n,
                n.left = null) : s >= 0 && (i.right = n.right,
                i.left = n,
                n.right = null),
                i
            }
            function l(t, e, n) {
                var r = null
                  , a = null;
                if (e) {
                    e = o(t, e, n);
                    var i = n(e.key, t);
                    0 === i ? (r = e.left,
                    a = e.right) : i < 0 ? (a = e.right,
                    e.right = null,
                    r = e) : (r = e.left,
                    e.left = null,
                    a = e)
                }
                return {
                    left: r,
                    right: a
                }
            }
            var u = function() {
                function t(t) {
                    void 0 === t && (t = i),
                    this._root = null,
                    this._size = 0,
                    this._comparator = t
                }
                return t.prototype.insert = function(t, e) {
                    return this._size++,
                    this._root = s(t, e, this._root, this._comparator)
                }
                ,
                t.prototype.add = function(t, e) {
                    var n = new a(t,e);
                    null === this._root && (n.left = n.right = null,
                    this._size++,
                    this._root = n);
                    var r = this._comparator
                      , i = o(t, this._root, r)
                      , s = r(t, i.key);
                    return 0 === s ? this._root = i : (s < 0 ? (n.left = i.left,
                    n.right = i,
                    i.left = null) : s > 0 && (n.right = i.right,
                    n.left = i,
                    i.right = null),
                    this._size++,
                    this._root = n),
                    this._root
                }
                ,
                t.prototype.remove = function(t) {
                    this._root = this._remove(t, this._root, this._comparator)
                }
                ,
                t.prototype._remove = function(t, e, n) {
                    var r;
                    if (null === e)
                        return null;
                    e = o(t, e, n);
                    var a = n(t, e.key);
                    return 0 === a ? (null === e.left ? r = e.right : (r = o(t, e.left, n)).right = e.right,
                    this._size--,
                    r) : e
                }
                ,
                t.prototype.pop = function() {
                    var t = this._root;
                    if (t) {
                        for (; t.left; )
                            t = t.left;
                        return this._root = o(t.key, this._root, this._comparator),
                        this._root = this._remove(t.key, this._root, this._comparator),
                        {
                            key: t.key,
                            data: t.data
                        }
                    }
                    return null
                }
                ,
                t.prototype.findStatic = function(t) {
                    for (var e = this._root, n = this._comparator; e; ) {
                        var r = n(t, e.key);
                        if (0 === r)
                            return e;
                        e = r < 0 ? e.left : e.right
                    }
                    return null
                }
                ,
                t.prototype.find = function(t) {
                    return this._root && (this._root = o(t, this._root, this._comparator),
                    0 !== this._comparator(t, this._root.key)) ? null : this._root
                }
                ,
                t.prototype.contains = function(t) {
                    for (var e = this._root, n = this._comparator; e; ) {
                        var r = n(t, e.key);
                        if (0 === r)
                            return !0;
                        e = r < 0 ? e.left : e.right
                    }
                    return !1
                }
                ,
                t.prototype.forEach = function(t, e) {
                    for (var n = this._root, r = [], a = !1; !a; )
                        null !== n ? (r.push(n),
                        n = n.left) : 0 !== r.length ? (n = r.pop(),
                        t.call(e, n),
                        n = n.right) : a = !0;
                    return this
                }
                ,
                t.prototype.range = function(t, e, n, r) {
                    for (var a = [], i = this._comparator, o = this._root; 0 !== a.length || o; )
                        if (o)
                            a.push(o),
                            o = o.left;
                        else {
                            if (o = a.pop(),
                            i(o.key, e) > 0)
                                break;
                            if (i(o.key, t) >= 0 && n.call(r, o))
                                return this;
                            o = o.right
                        }
                    return this
                }
                ,
                t.prototype.keys = function() {
                    var t = [];
                    return this.forEach(function(e) {
                        var n = e.key;
                        return t.push(n)
                    }),
                    t
                }
                ,
                t.prototype.values = function() {
                    var t = [];
                    return this.forEach(function(e) {
                        var n = e.data;
                        return t.push(n)
                    }),
                    t
                }
                ,
                t.prototype.min = function() {
                    return this._root ? this.minNode(this._root).key : null
                }
                ,
                t.prototype.max = function() {
                    return this._root ? this.maxNode(this._root).key : null
                }
                ,
                t.prototype.minNode = function(t) {
                    if (void 0 === t && (t = this._root),
                    t)
                        for (; t.left; )
                            t = t.left;
                    return t
                }
                ,
                t.prototype.maxNode = function(t) {
                    if (void 0 === t && (t = this._root),
                    t)
                        for (; t.right; )
                            t = t.right;
                    return t
                }
                ,
                t.prototype.at = function(t) {
                    for (var e = this._root, n = !1, r = 0, a = []; !n; )
                        if (e)
                            a.push(e),
                            e = e.left;
                        else if (a.length > 0) {
                            if (e = a.pop(),
                            r === t)
                                return e;
                            r++,
                            e = e.right
                        } else
                            n = !0;
                    return null
                }
                ,
                t.prototype.next = function(t) {
                    var e = this._root
                      , n = null;
                    if (t.right) {
                        for (n = t.right; n.left; )
                            n = n.left;
                        return n
                    }
                    for (var r = this._comparator; e; ) {
                        var a = r(t.key, e.key);
                        if (0 === a)
                            break;
                        a < 0 ? (n = e,
                        e = e.left) : e = e.right
                    }
                    return n
                }
                ,
                t.prototype.prev = function(t) {
                    var e = this._root
                      , n = null;
                    if (null !== t.left) {
                        for (n = t.left; n.right; )
                            n = n.right;
                        return n
                    }
                    for (var r = this._comparator; e; ) {
                        var a = r(t.key, e.key);
                        if (0 === a)
                            break;
                        a < 0 ? e = e.left : (n = e,
                        e = e.right)
                    }
                    return n
                }
                ,
                t.prototype.clear = function() {
                    return this._root = null,
                    this._size = 0,
                    this
                }
                ,
                t.prototype.toList = function() {
                    return function(t) {
                        for (var e = t, n = [], r = !1, i = new a(null,null), o = i; !r; )
                            e ? (n.push(e),
                            e = e.left) : n.length > 0 ? e = (e = o = o.next = n.pop()).right : r = !0;
                        return o.next = null,
                        i.next
                    }(this._root)
                }
                ,
                t.prototype.load = function(t, e, n) {
                    void 0 === e && (e = []),
                    void 0 === n && (n = !1);
                    var r = t.length
                      , i = this._comparator;
                    if (n && function t(e, n, r, a, i) {
                        if (!(r >= a)) {
                            for (var o = e[r + a >> 1], s = r - 1, l = a + 1; ; ) {
                                do {
                                    s++
                                } while (i(e[s], o) < 0);
                                do {
                                    l--
                                } while (i(e[l], o) > 0);
                                if (s >= l)
                                    break;
                                var u = e[s];
                                e[s] = e[l],
                                e[l] = u,
                                u = n[s],
                                n[s] = n[l],
                                n[l] = u
                            }
                            t(e, n, r, l, i),
                            t(e, n, l + 1, a, i)
                        }
                    }(t, e, 0, r - 1, i),
                    null === this._root)
                        this._root = function t(e, n, r, i) {
                            var o = i - r;
                            if (o > 0) {
                                var s = r + Math.floor(o / 2)
                                  , l = e[s]
                                  , u = n[s]
                                  , c = new a(l,u);
                                return c.left = t(e, n, r, s),
                                c.right = t(e, n, s + 1, i),
                                c
                            }
                            return null
                        }(t, e, 0, r),
                        this._size = r;
                    else {
                        var o = function(t, e, n) {
                            for (var r = new a(null,null), i = r, o = t, s = e; null !== o && null !== s; )
                                n(o.key, s.key) < 0 ? (i.next = o,
                                o = o.next) : (i.next = s,
                                s = s.next),
                                i = i.next;
                            return null !== o ? i.next = o : null !== s && (i.next = s),
                            r.next
                        }(this.toList(), function(t, e) {
                            for (var n = new a(null,null), r = n, i = 0; i < t.length; i++)
                                r = r.next = new a(t[i],e[i]);
                            return r.next = null,
                            n.next
                        }(t, e), i);
                        r = this._size + r,
                        this._root = function t(e, n, r) {
                            var a = r - n;
                            if (a > 0) {
                                var i = n + Math.floor(a / 2)
                                  , o = t(e, n, i)
                                  , s = e.head;
                                return s.left = o,
                                e.head = e.head.next,
                                s.right = t(e, i + 1, r),
                                s
                            }
                            return null
                        }({
                            head: o
                        }, 0, r)
                    }
                    return this
                }
                ,
                t.prototype.isEmpty = function() {
                    return null === this._root
                }
                ,
                Object.defineProperty(t.prototype, "size", {
                    get: function() {
                        return this._size
                    },
                    enumerable: !0,
                    configurable: !0
                }),
                Object.defineProperty(t.prototype, "root", {
                    get: function() {
                        return this._root
                    },
                    enumerable: !0,
                    configurable: !0
                }),
                t.prototype.toString = function(t) {
                    void 0 === t && (t = function(t) {
                        return String(t.key)
                    }
                    );
                    var e = [];
                    return function t(e, n, r, a, i) {
                        if (e) {
                            a(n + (r ? "└── " : "├── ") + i(e) + "\n");
                            var o = n + (r ? "    " : "│   ");
                            e.left && t(e.left, o, !1, a, i),
                            e.right && t(e.right, o, !0, a, i)
                        }
                    }(this._root, "", !0, function(t) {
                        return e.push(t)
                    }, t),
                    e.join("")
                }
                ,
                t.prototype.update = function(t, e, n) {
                    var r = this._comparator
                      , a = l(t, this._root, r)
                      , i = a.left
                      , u = a.right;
                    r(t, e) < 0 ? u = s(e, n, u, r) : i = s(e, n, i, r),
                    this._root = function(t, e, n) {
                        return null === e ? t : null === t ? e : ((e = o(t.key, e, n)).left = t,
                        e)
                    }(i, u, r)
                }
                ,
                t.prototype.split = function(t) {
                    return l(t, this._root, this._comparator)
                }
                ,
                t
            }()
              , c = function(t, e) {
                return t.ll.x <= e.x && e.x <= t.ur.x && t.ll.y <= e.y && e.y <= t.ur.y
            }
              , h = function(t, e) {
                if (e.ur.x < t.ll.x || t.ur.x < e.ll.x || e.ur.y < t.ll.y || t.ur.y < e.ll.y)
                    return null;
                var n = t.ll.x < e.ll.x ? e.ll.x : t.ll.x
                  , r = t.ur.x < e.ur.x ? t.ur.x : e.ur.x
                  , a = t.ll.y < e.ll.y ? e.ll.y : t.ll.y
                  , i = t.ur.y < e.ur.y ? t.ur.y : e.ur.y;
                return {
                    ll: {
                        x: n,
                        y: a
                    },
                    ur: {
                        x: r,
                        y: i
                    }
                }
            }
              , d = Number.EPSILON;
            void 0 === d && (d = Math.pow(2, -52));
            var f = d * d
              , p = function(t, e) {
                if (-d < t && t < d && -d < e && e < d)
                    return 0;
                var n = t - e;
                return n * n < f * t * e ? 0 : t < e ? -1 : 1
            }
              , m = function() {
                function e() {
                    t(this, e),
                    this.reset()
                }
                return r(e, [{
                    key: "reset",
                    value: function() {
                        this.xRounder = new g,
                        this.yRounder = new g
                    }
                }, {
                    key: "round",
                    value: function(t, e) {
                        return {
                            x: this.xRounder.round(t),
                            y: this.yRounder.round(e)
                        }
                    }
                }]),
                e
            }()
              , g = function() {
                function e() {
                    t(this, e),
                    this.tree = new u,
                    this.round(0)
                }
                return r(e, [{
                    key: "round",
                    value: function(t) {
                        var e = this.tree.add(t)
                          , n = this.tree.prev(e);
                        if (null !== n && 0 === p(e.key, n.key))
                            return this.tree.remove(t),
                            n.key;
                        var r = this.tree.next(e);
                        return null !== r && 0 === p(e.key, r.key) ? (this.tree.remove(t),
                        r.key) : t
                    }
                }]),
                e
            }()
              , v = new m
              , y = function(t, e) {
                return t.x * e.y - t.y * e.x
            }
              , _ = function(t, e) {
                return t.x * e.x + t.y * e.y
            }
              , x = function(t, e, n) {
                var r = {
                    x: e.x - t.x,
                    y: e.y - t.y
                }
                  , a = {
                    x: n.x - t.x,
                    y: n.y - t.y
                }
                  , i = y(r, a);
                return p(i, 0)
            }
              , b = function(t) {
                return Math.sqrt(_(t, t))
            }
              , w = function(t, e, n) {
                var r = {
                    x: e.x - t.x,
                    y: e.y - t.y
                }
                  , a = {
                    x: n.x - t.x,
                    y: n.y - t.y
                };
                return _(a, r) / b(a) / b(r)
            }
              , C = function(t, e, n) {
                return 0 === e.y ? null : {
                    x: t.x + e.x / e.y * (n - t.y),
                    y: n
                }
            }
              , E = function(t, e, n) {
                return 0 === e.x ? null : {
                    x: n,
                    y: t.y + e.y / e.x * (n - t.x)
                }
            }
              , T = function() {
                function e(n, r) {
                    t(this, e),
                    void 0 === n.events ? n.events = [this] : n.events.push(this),
                    this.point = n,
                    this.isLeft = r
                }
                return r(e, null, [{
                    key: "compare",
                    value: function(t, n) {
                        var r = e.comparePoints(t.point, n.point);
                        return 0 !== r ? r : (t.point !== n.point && t.link(n),
                        t.isLeft !== n.isLeft ? t.isLeft ? 1 : -1 : A.compare(t.segment, n.segment))
                    }
                }, {
                    key: "comparePoints",
                    value: function(t, e) {
                        return t.x < e.x ? -1 : t.x > e.x ? 1 : t.y < e.y ? -1 : t.y > e.y ? 1 : 0
                    }
                }]),
                r(e, [{
                    key: "link",
                    value: function(t) {
                        if (t.point === this.point)
                            throw new Error("Tried to link already linked events");
                        for (var e = t.point.events, n = 0, r = e.length; n < r; n++) {
                            var a = e[n];
                            this.point.events.push(a),
                            a.point = this.point
                        }
                        this.checkForConsuming()
                    }
                }, {
                    key: "checkForConsuming",
                    value: function() {
                        for (var t = this.point.events.length, e = 0; e < t; e++) {
                            var n = this.point.events[e];
                            if (void 0 === n.segment.consumedBy)
                                for (var r = e + 1; r < t; r++) {
                                    var a = this.point.events[r];
                                    void 0 === a.consumedBy && n.otherSE.point.events === a.otherSE.point.events && n.segment.consume(a.segment)
                                }
                        }
                    }
                }, {
                    key: "getAvailableLinkedEvents",
                    value: function() {
                        for (var t = [], e = 0, n = this.point.events.length; e < n; e++) {
                            var r = this.point.events[e];
                            r !== this && !r.segment.ringOut && r.segment.isInResult() && t.push(r)
                        }
                        return t
                    }
                }, {
                    key: "getLeftmostComparator",
                    value: function(t) {
                        var e = this
                          , n = new Map
                          , r = function(r) {
                            var a, i, o, s, l, u = r.otherSE;
                            n.set(r, {
                                sine: (a = e.point,
                                i = t.point,
                                o = u.point,
                                s = {
                                    x: i.x - a.x,
                                    y: i.y - a.y
                                },
                                l = {
                                    x: o.x - a.x,
                                    y: o.y - a.y
                                },
                                y(l, s) / b(l) / b(s)),
                                cosine: w(e.point, t.point, u.point)
                            })
                        };
                        return function(t, e) {
                            n.has(t) || r(t),
                            n.has(e) || r(e);
                            var a = n.get(t)
                              , i = a.sine
                              , o = a.cosine
                              , s = n.get(e)
                              , l = s.sine
                              , u = s.cosine;
                            return i >= 0 && l >= 0 ? o < u ? 1 : o > u ? -1 : 0 : i < 0 && l < 0 ? o < u ? -1 : o > u ? 1 : 0 : l < i ? -1 : l > i ? 1 : 0
                        }
                    }
                }]),
                e
            }()
              , M = 0
              , A = function() {
                function e(n, r, a, i) {
                    t(this, e),
                    this.id = ++M,
                    this.leftSE = n,
                    n.segment = this,
                    n.otherSE = r,
                    this.rightSE = r,
                    r.segment = this,
                    r.otherSE = n,
                    this.rings = a,
                    this.windings = i
                }
                return r(e, null, [{
                    key: "compare",
                    value: function(t, e) {
                        var n = t.leftSE.point.x
                          , r = e.leftSE.point.x
                          , a = t.rightSE.point.x
                          , i = e.rightSE.point.x;
                        if (i < n)
                            return 1;
                        if (a < r)
                            return -1;
                        var o = t.leftSE.point.y
                          , s = e.leftSE.point.y
                          , l = t.rightSE.point.y
                          , u = e.rightSE.point.y;
                        if (n < r) {
                            if (s < o && s < l)
                                return 1;
                            if (s > o && s > l)
                                return -1;
                            var c = t.comparePoint(e.leftSE.point);
                            if (c < 0)
                                return 1;
                            if (c > 0)
                                return -1;
                            var h = e.comparePoint(t.rightSE.point);
                            return 0 !== h ? h : -1
                        }
                        if (n > r) {
                            if (o < s && o < u)
                                return -1;
                            if (o > s && o > u)
                                return 1;
                            var d = e.comparePoint(t.leftSE.point);
                            if (0 !== d)
                                return d;
                            var f = t.comparePoint(e.rightSE.point);
                            return f < 0 ? 1 : f > 0 ? -1 : 1
                        }
                        if (o < s)
                            return -1;
                        if (o > s)
                            return 1;
                        if (a < i) {
                            var p = e.comparePoint(t.rightSE.point);
                            if (0 !== p)
                                return p
                        }
                        if (a > i) {
                            var m = t.comparePoint(e.rightSE.point);
                            if (m < 0)
                                return 1;
                            if (m > 0)
                                return -1
                        }
                        if (a !== i) {
                            var g = l - o
                              , v = a - n
                              , y = u - s
                              , _ = i - r;
                            if (g > v && y < _)
                                return 1;
                            if (g < v && y > _)
                                return -1
                        }
                        return a > i ? 1 : a < i ? -1 : l < u ? -1 : l > u ? 1 : t.id < e.id ? -1 : t.id > e.id ? 1 : 0
                    }
                }]),
                r(e, [{
                    key: "replaceRightSE",
                    value: function(t) {
                        this.rightSE = t,
                        this.rightSE.segment = this,
                        this.rightSE.otherSE = this.leftSE,
                        this.leftSE.otherSE = this.rightSE
                    }
                }, {
                    key: "bbox",
                    value: function() {
                        var t = this.leftSE.point.y
                          , e = this.rightSE.point.y;
                        return {
                            ll: {
                                x: this.leftSE.point.x,
                                y: t < e ? t : e
                            },
                            ur: {
                                x: this.rightSE.point.x,
                                y: t > e ? t : e
                            }
                        }
                    }
                }, {
                    key: "vector",
                    value: function() {
                        return {
                            x: this.rightSE.point.x - this.leftSE.point.x,
                            y: this.rightSE.point.y - this.leftSE.point.y
                        }
                    }
                }, {
                    key: "isAnEndpoint",
                    value: function(t) {
                        return t.x === this.leftSE.point.x && t.y === this.leftSE.point.y || t.x === this.rightSE.point.x && t.y === this.rightSE.point.y
                    }
                }, {
                    key: "comparePoint",
                    value: function(t) {
                        if (this.isAnEndpoint(t))
                            return 0;
                        var e = this.leftSE.point
                          , n = this.rightSE.point
                          , r = this.vector();
                        if (e.x === n.x)
                            return t.x === e.x ? 0 : t.x < e.x ? 1 : -1;
                        var a = (t.y - e.y) / r.y
                          , i = e.x + a * r.x;
                        if (t.x === i)
                            return 0;
                        var o = (t.x - e.x) / r.x
                          , s = e.y + o * r.y;
                        return t.y === s ? 0 : t.y < s ? -1 : 1
                    }
                }, {
                    key: "getIntersection",
                    value: function(t) {
                        var e = this.bbox()
                          , n = t.bbox()
                          , r = h(e, n);
                        if (null === r)
                            return null;
                        var a = this.leftSE.point
                          , i = this.rightSE.point
                          , o = t.leftSE.point
                          , s = t.rightSE.point
                          , l = c(e, o) && 0 === this.comparePoint(o)
                          , u = c(n, a) && 0 === t.comparePoint(a)
                          , d = c(e, s) && 0 === this.comparePoint(s)
                          , f = c(n, i) && 0 === t.comparePoint(i);
                        if (u && l)
                            return f && !d ? i : !f && d ? s : null;
                        if (u)
                            return d && a.x === s.x && a.y === s.y ? null : a;
                        if (l)
                            return f && i.x === o.x && i.y === o.y ? null : o;
                        if (f && d)
                            return null;
                        if (f)
                            return i;
                        if (d)
                            return s;
                        var p = function(t, e, n, r) {
                            if (0 === e.x)
                                return E(n, r, t.x);
                            if (0 === r.x)
                                return E(t, e, n.x);
                            if (0 === e.y)
                                return C(n, r, t.y);
                            if (0 === r.y)
                                return C(t, e, n.y);
                            var a = y(e, r);
                            if (0 == a)
                                return null;
                            var i = {
                                x: n.x - t.x,
                                y: n.y - t.y
                            }
                              , o = y(i, e) / a
                              , s = y(i, r) / a
                              , l = t.x + s * e.x
                              , u = n.x + o * r.x
                              , c = t.y + s * e.y
                              , h = n.y + o * r.y;
                            return {
                                x: (l + u) / 2,
                                y: (c + h) / 2
                            }
                        }(a, this.vector(), o, t.vector());
                        return null === p ? null : c(r, p) ? v.round(p.x, p.y) : null
                    }
                }, {
                    key: "split",
                    value: function(t) {
                        var n = []
                          , r = void 0 !== t.events
                          , a = new T(t,!0)
                          , i = new T(t,!1)
                          , o = this.rightSE;
                        this.replaceRightSE(i),
                        n.push(i),
                        n.push(a);
                        var s = new e(a,o,this.rings.slice(),this.windings.slice());
                        return T.comparePoints(s.leftSE.point, s.rightSE.point) > 0 && s.swapEvents(),
                        T.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(),
                        r && (a.checkForConsuming(),
                        i.checkForConsuming()),
                        n
                    }
                }, {
                    key: "swapEvents",
                    value: function() {
                        var t = this.rightSE;
                        this.rightSE = this.leftSE,
                        this.leftSE = t,
                        this.leftSE.isLeft = !0,
                        this.rightSE.isLeft = !1;
                        for (var e = 0, n = this.windings.length; e < n; e++)
                            this.windings[e] *= -1
                    }
                }, {
                    key: "consume",
                    value: function(t) {
                        for (var n = this, r = t; n.consumedBy; )
                            n = n.consumedBy;
                        for (; r.consumedBy; )
                            r = r.consumedBy;
                        var a = e.compare(n, r);
                        if (0 !== a) {
                            if (a > 0) {
                                var i = n;
                                n = r,
                                r = i
                            }
                            if (n.prev === r) {
                                var o = n;
                                n = r,
                                r = o
                            }
                            for (var s = 0, l = r.rings.length; s < l; s++) {
                                var u = r.rings[s]
                                  , c = r.windings[s]
                                  , h = n.rings.indexOf(u);
                                -1 === h ? (n.rings.push(u),
                                n.windings.push(c)) : n.windings[h] += c
                            }
                            r.rings = null,
                            r.windings = null,
                            r.consumedBy = n,
                            r.leftSE.consumedBy = n.leftSE,
                            r.rightSE.consumedBy = n.rightSE
                        }
                    }
                }, {
                    key: "prevInResult",
                    value: function() {
                        return void 0 !== this._prevInResult ? this._prevInResult : (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null,
                        this._prevInResult)
                    }
                }, {
                    key: "beforeState",
                    value: function() {
                        if (void 0 !== this._beforeState)
                            return this._beforeState;
                        if (this.prev) {
                            var t = this.prev.consumedBy || this.prev;
                            this._beforeState = t.afterState()
                        } else
                            this._beforeState = {
                                rings: [],
                                windings: [],
                                multiPolys: []
                            };
                        return this._beforeState
                    }
                }, {
                    key: "afterState",
                    value: function() {
                        if (void 0 !== this._afterState)
                            return this._afterState;
                        var t = this.beforeState();
                        this._afterState = {
                            rings: t.rings.slice(0),
                            windings: t.windings.slice(0),
                            multiPolys: []
                        };
                        for (var e = this._afterState.rings, n = this._afterState.windings, r = this._afterState.multiPolys, a = 0, i = this.rings.length; a < i; a++) {
                            var o = this.rings[a]
                              , s = this.windings[a]
                              , l = e.indexOf(o);
                            -1 === l ? (e.push(o),
                            n.push(s)) : n[l] += s
                        }
                        for (var u = [], c = [], h = 0, d = e.length; h < d; h++)
                            if (0 !== n[h]) {
                                var f = e[h]
                                  , p = f.poly;
                                if (-1 === c.indexOf(p))
                                    if (f.isExterior)
                                        u.push(p);
                                    else {
                                        -1 === c.indexOf(p) && c.push(p);
                                        var m = u.indexOf(f.poly);
                                        -1 !== m && u.splice(m, 1)
                                    }
                            }
                        for (var g = 0, v = u.length; g < v; g++) {
                            var y = u[g].multiPoly;
                            -1 === r.indexOf(y) && r.push(y)
                        }
                        return this._afterState
                    }
                }, {
                    key: "isInResult",
                    value: function() {
                        if (this.consumedBy)
                            return !1;
                        if (void 0 !== this._isInResult)
                            return this._isInResult;
                        var t = this.beforeState().multiPolys
                          , e = this.afterState().multiPolys;
                        switch (H.type) {
                        case "union":
                            var n = 0 === t.length
                              , r = 0 === e.length;
                            this._isInResult = n !== r;
                            break;
                        case "intersection":
                            var a, i;
                            t.length < e.length ? (a = t.length,
                            i = e.length) : (a = e.length,
                            i = t.length),
                            this._isInResult = i === H.numMultiPolys && a < i;
                            break;
                        case "xor":
                            var o = Math.abs(t.length - e.length);
                            this._isInResult = o % 2 == 1;
                            break;
                        case "difference":
                            var s = function(t) {
                                return 1 === t.length && t[0].isSubject
                            };
                            this._isInResult = s(t) !== s(e);
                            break;
                        default:
                            throw new Error("Unrecognized operation type found ".concat(H.type))
                        }
                        return this._isInResult
                    }
                }], [{
                    key: "fromRing",
                    value: function(t, n, r) {
                        var a, i, o, s = T.comparePoints(t, n);
                        if (s < 0)
                            a = t,
                            i = n,
                            o = 1;
                        else {
                            if (!(s > 0))
                                throw new Error("Tried to create degenerate segment at [".concat(t.x, ", ").concat(t.y, "]"));
                            a = n,
                            i = t,
                            o = -1
                        }
                        var l = new T(a,!0)
                          , u = new T(i,!1);
                        return new e(l,u,[r],[o])
                    }
                }]),
                e
            }()
              , P = function() {
                function e(n, r, a) {
                    if (t(this, e),
                    !Array.isArray(n) || 0 === n.length)
                        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
                    if (this.poly = r,
                    this.isExterior = a,
                    this.segments = [],
                    "number" != typeof n[0][0] || "number" != typeof n[0][1])
                        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
                    var i = v.round(n[0][0], n[0][1]);
                    this.bbox = {
                        ll: {
                            x: i.x,
                            y: i.y
                        },
                        ur: {
                            x: i.x,
                            y: i.y
                        }
                    };
                    for (var o = i, s = 1, l = n.length; s < l; s++) {
                        if ("number" != typeof n[s][0] || "number" != typeof n[s][1])
                            throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
                        var u = v.round(n[s][0], n[s][1]);
                        u.x === o.x && u.y === o.y || (this.segments.push(A.fromRing(o, u, this)),
                        u.x < this.bbox.ll.x && (this.bbox.ll.x = u.x),
                        u.y < this.bbox.ll.y && (this.bbox.ll.y = u.y),
                        u.x > this.bbox.ur.x && (this.bbox.ur.x = u.x),
                        u.y > this.bbox.ur.y && (this.bbox.ur.y = u.y),
                        o = u)
                    }
                    i.x === o.x && i.y === o.y || this.segments.push(A.fromRing(o, i, this))
                }
                return r(e, [{
                    key: "getSweepEvents",
                    value: function() {
                        for (var t = [], e = 0, n = this.segments.length; e < n; e++) {
                            var r = this.segments[e];
                            t.push(r.leftSE),
                            t.push(r.rightSE)
                        }
                        return t
                    }
                }]),
                e
            }()
              , S = function() {
                function e(n, r) {
                    if (t(this, e),
                    !Array.isArray(n))
                        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
                    this.exteriorRing = new P(n[0],this,!0),
                    this.bbox = {
                        ll: {
                            x: this.exteriorRing.bbox.ll.x,
                            y: this.exteriorRing.bbox.ll.y
                        },
                        ur: {
                            x: this.exteriorRing.bbox.ur.x,
                            y: this.exteriorRing.bbox.ur.y
                        }
                    },
                    this.interiorRings = [];
                    for (var a = 1, i = n.length; a < i; a++) {
                        var o = new P(n[a],this,!1);
                        o.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = o.bbox.ll.x),
                        o.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = o.bbox.ll.y),
                        o.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = o.bbox.ur.x),
                        o.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = o.bbox.ur.y),
                        this.interiorRings.push(o)
                    }
                    this.multiPoly = r
                }
                return r(e, [{
                    key: "getSweepEvents",
                    value: function() {
                        for (var t = this.exteriorRing.getSweepEvents(), e = 0, n = this.interiorRings.length; e < n; e++)
                            for (var r = this.interiorRings[e].getSweepEvents(), a = 0, i = r.length; a < i; a++)
                                t.push(r[a]);
                        return t
                    }
                }]),
                e
            }()
              , R = function() {
                function e(n, r) {
                    if (t(this, e),
                    !Array.isArray(n))
                        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
                    try {
                        "number" == typeof n[0][0][0] && (n = [n])
                    } catch (t) {}
                    this.polys = [],
                    this.bbox = {
                        ll: {
                            x: Number.POSITIVE_INFINITY,
                            y: Number.POSITIVE_INFINITY
                        },
                        ur: {
                            x: Number.NEGATIVE_INFINITY,
                            y: Number.NEGATIVE_INFINITY
                        }
                    };
                    for (var a = 0, i = n.length; a < i; a++) {
                        var o = new S(n[a],this);
                        o.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = o.bbox.ll.x),
                        o.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = o.bbox.ll.y),
                        o.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = o.bbox.ur.x),
                        o.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = o.bbox.ur.y),
                        this.polys.push(o)
                    }
                    this.isSubject = r
                }
                return r(e, [{
                    key: "getSweepEvents",
                    value: function() {
                        for (var t = [], e = 0, n = this.polys.length; e < n; e++)
                            for (var r = this.polys[e].getSweepEvents(), a = 0, i = r.length; a < i; a++)
                                t.push(r[a]);
                        return t
                    }
                }]),
                e
            }()
              , D = function() {
                function e(n) {
                    t(this, e),
                    this.events = n;
                    for (var r = 0, a = n.length; r < a; r++)
                        n[r].segment.ringOut = this;
                    this.poly = null
                }
                return r(e, null, [{
                    key: "factory",
                    value: function(t) {
                        for (var n = [], r = 0, a = t.length; r < a; r++) {
                            var i = t[r];
                            if (i.isInResult() && !i.ringOut) {
                                for (var o = null, s = i.leftSE, l = i.rightSE, u = [s], c = s.point, h = []; o = s,
                                s = l,
                                u.push(s),
                                s.point !== c; )
                                    for (; ; ) {
                                        var d = s.getAvailableLinkedEvents();
                                        if (0 === d.length) {
                                            var f = u[0].point
                                              , p = u[u.length - 1].point;
                                            throw new Error("Unable to complete output ring starting at [".concat(f.x, ",") + " ".concat(f.y, "]. Last matching segment found ends at") + " [".concat(p.x, ", ").concat(p.y, "]."))
                                        }
                                        if (1 === d.length) {
                                            l = d[0].otherSE;
                                            break
                                        }
                                        for (var m = null, g = 0, v = h.length; g < v; g++)
                                            if (h[g].point === s.point) {
                                                m = g;
                                                break
                                            }
                                        if (null === m) {
                                            h.push({
                                                index: u.length,
                                                point: s.point
                                            });
                                            var y = s.getLeftmostComparator(o);
                                            l = d.sort(y)[0].otherSE;
                                            break
                                        }
                                        var _ = h.splice(m)[0]
                                          , x = u.splice(_.index);
                                        x.unshift(x[0].otherSE),
                                        n.push(new e(x.reverse()))
                                    }
                                n.push(new e(u))
                            }
                        }
                        return n
                    }
                }]),
                r(e, [{
                    key: "getGeom",
                    value: function() {
                        for (var t = this.events[0].point, e = [t], n = 1, r = this.events.length - 1; n < r; n++) {
                            var a = this.events[n].point
                              , i = this.events[n + 1].point;
                            0 !== x(a, t, i) && (e.push(a),
                            t = a)
                        }
                        if (1 === e.length)
                            return null;
                        var o = e[0]
                          , s = e[1];
                        0 === x(o, t, s) && e.shift(),
                        e.push(e[0]);
                        for (var l = this.isExteriorRing() ? 1 : -1, u = this.isExteriorRing() ? 0 : e.length - 1, c = this.isExteriorRing() ? e.length : -1, h = [], d = u; d != c; d += l)
                            h.push([e[d].x, e[d].y]);
                        return h
                    }
                }, {
                    key: "isExteriorRing",
                    value: function() {
                        if (void 0 === this._isExteriorRing) {
                            var t = this.enclosingRing();
                            this._isExteriorRing = !t || !t.isExteriorRing()
                        }
                        return this._isExteriorRing
                    }
                }, {
                    key: "enclosingRing",
                    value: function() {
                        return void 0 === this._enclosingRing && (this._enclosingRing = this._calcEnclosingRing()),
                        this._enclosingRing
                    }
                }, {
                    key: "_calcEnclosingRing",
                    value: function() {
                        for (var t = this.events[0], e = 1, n = this.events.length; e < n; e++) {
                            var r = this.events[e];
                            T.compare(t, r) > 0 && (t = r)
                        }
                        for (var a = t.segment.prevInResult(), i = a ? a.prevInResult() : null; ; ) {
                            if (!a)
                                return null;
                            if (!i)
                                return a.ringOut;
                            if (i.ringOut !== a.ringOut)
                                return i.ringOut.enclosingRing() !== a.ringOut ? a.ringOut : a.ringOut.enclosingRing();
                            a = i.prevInResult(),
                            i = a ? a.prevInResult() : null
                        }
                    }
                }]),
                e
            }()
              , j = function() {
                function e(n) {
                    t(this, e),
                    this.exteriorRing = n,
                    n.poly = this,
                    this.interiorRings = []
                }
                return r(e, [{
                    key: "addInterior",
                    value: function(t) {
                        this.interiorRings.push(t),
                        t.poly = this
                    }
                }, {
                    key: "getGeom",
                    value: function() {
                        var t = [this.exteriorRing.getGeom()];
                        if (null === t[0])
                            return null;
                        for (var e = 0, n = this.interiorRings.length; e < n; e++) {
                            var r = this.interiorRings[e].getGeom();
                            null !== r && t.push(r)
                        }
                        return t
                    }
                }]),
                e
            }()
              , L = function() {
                function e(n) {
                    t(this, e),
                    this.rings = n,
                    this.polys = this._composePolys(n)
                }
                return r(e, [{
                    key: "getGeom",
                    value: function() {
                        for (var t = [], e = 0, n = this.polys.length; e < n; e++) {
                            var r = this.polys[e].getGeom();
                            null !== r && t.push(r)
                        }
                        return t
                    }
                }, {
                    key: "_composePolys",
                    value: function(t) {
                        for (var e = [], n = 0, r = t.length; n < r; n++) {
                            var a = t[n];
                            if (!a.poly)
                                if (a.isExteriorRing())
                                    e.push(new j(a));
                                else {
                                    var i = a.enclosingRing();
                                    i.poly || e.push(new j(i)),
                                    i.poly.addInterior(a)
                                }
                        }
                        return e
                    }
                }]),
                e
            }()
              , I = function() {
                function e(n) {
                    var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : A.compare;
                    t(this, e),
                    this.queue = n,
                    this.tree = new u(r),
                    this.segments = []
                }
                return r(e, [{
                    key: "process",
                    value: function(t) {
                        var e = t.segment
                          , n = [];
                        if (t.consumedBy)
                            return t.isLeft ? this.queue.remove(t.otherSE) : this.tree.remove(e),
                            n;
                        var r = t.isLeft ? this.tree.insert(e) : this.tree.find(e);
                        if (!r)
                            throw new Error("Unable to find segment #".concat(e.id, " ") + "[".concat(e.leftSE.point.x, ", ").concat(e.leftSE.point.y, "] -> ") + "[".concat(e.rightSE.point.x, ", ").concat(e.rightSE.point.y, "] ") + "in SweepLine tree. Please submit a bug report.");
                        for (var a = r, i = r, o = void 0, s = void 0; void 0 === o; )
                            null === (a = this.tree.prev(a)) ? o = null : void 0 === a.key.consumedBy && (o = a.key);
                        for (; void 0 === s; )
                            null === (i = this.tree.next(i)) ? s = null : void 0 === i.key.consumedBy && (s = i.key);
                        if (t.isLeft) {
                            var l = null;
                            if (o) {
                                var u = o.getIntersection(e);
                                if (null !== u && (e.isAnEndpoint(u) || (l = u),
                                !o.isAnEndpoint(u)))
                                    for (var c = this._splitSafely(o, u), h = 0, d = c.length; h < d; h++)
                                        n.push(c[h])
                            }
                            var f = null;
                            if (s) {
                                var p = s.getIntersection(e);
                                if (null !== p && (e.isAnEndpoint(p) || (f = p),
                                !s.isAnEndpoint(p)))
                                    for (var m = this._splitSafely(s, p), g = 0, v = m.length; g < v; g++)
                                        n.push(m[g])
                            }
                            if (null !== l || null !== f) {
                                var y = null;
                                if (null === l)
                                    y = f;
                                else if (null === f)
                                    y = l;
                                else {
                                    var _ = T.comparePoints(l, f);
                                    y = _ <= 0 ? l : f
                                }
                                this.queue.remove(e.rightSE),
                                n.push(e.rightSE);
                                for (var x = e.split(y), b = 0, w = x.length; b < w; b++)
                                    n.push(x[b])
                            }
                            n.length > 0 ? (this.tree.remove(e),
                            n.push(t)) : (this.segments.push(e),
                            e.prev = o)
                        } else {
                            if (o && s) {
                                var C = o.getIntersection(s);
                                if (null !== C) {
                                    if (!o.isAnEndpoint(C))
                                        for (var E = this._splitSafely(o, C), M = 0, A = E.length; M < A; M++)
                                            n.push(E[M]);
                                    if (!s.isAnEndpoint(C))
                                        for (var P = this._splitSafely(s, C), S = 0, R = P.length; S < R; S++)
                                            n.push(P[S])
                                }
                            }
                            this.tree.remove(e)
                        }
                        return n
                    }
                }, {
                    key: "_splitSafely",
                    value: function(t, e) {
                        this.tree.remove(t);
                        var n = t.rightSE;
                        this.queue.remove(n);
                        var r = t.split(e);
                        return r.push(n),
                        void 0 === t.consumedBy && this.tree.insert(t),
                        r
                    }
                }]),
                e
            }()
              , O = void 0 !== e && e.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6
              , k = void 0 !== e && e.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6
              , H = new (function() {
                function e() {
                    t(this, e)
                }
                return r(e, [{
                    key: "run",
                    value: function(t, e, n) {
                        H.type = t,
                        v.reset();
                        for (var r = [new R(e,!0)], a = 0, i = n.length; a < i; a++)
                            r.push(new R(n[a],!1));
                        if (H.numMultiPolys = r.length,
                        "difference" === H.type)
                            for (var o = r[0], s = 1; s < r.length; )
                                null !== h(r[s].bbox, o.bbox) ? s++ : r.splice(s, 1);
                        if ("intersection" === H.type)
                            for (var l = 0, c = r.length; l < c; l++)
                                for (var d = r[l], f = l + 1, p = r.length; f < p; f++)
                                    if (null === h(d.bbox, r[f].bbox))
                                        return [];
                        for (var m = new u(T.compare), g = 0, y = r.length; g < y; g++)
                            for (var _ = r[g].getSweepEvents(), x = 0, b = _.length; x < b; x++)
                                if (m.insert(_[x]),
                                m.size > O)
                                    throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report.");
                        for (var w = new I(m), C = m.size, E = m.pop(); E; ) {
                            var M = E.key;
                            if (m.size === C) {
                                var A = M.segment;
                                throw new Error("Unable to pop() ".concat(M.isLeft ? "left" : "right", " SweepEvent ") + "[".concat(M.point.x, ", ").concat(M.point.y, "] from segment #").concat(A.id, " ") + "[".concat(A.leftSE.point.x, ", ").concat(A.leftSE.point.y, "] -> ") + "[".concat(A.rightSE.point.x, ", ").concat(A.rightSE.point.y, "] from queue. ") + "Please file a bug report.")
                            }
                            if (m.size > O)
                                throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report.");
                            if (w.segments.length > k)
                                throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report.");
                            for (var P = w.process(M), S = 0, j = P.length; S < j; S++) {
                                var F = P[S];
                                void 0 === F.consumedBy && m.insert(F)
                            }
                            C = m.size,
                            E = m.pop()
                        }
                        v.reset();
                        var B = D.factory(w.segments)
                          , U = new L(B);
                        return U.getGeom()
                    }
                }]),
                e
            }());
            return {
                union: function(t) {
                    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
                        n[r - 1] = arguments[r];
                    return H.run("union", t, n)
                },
                intersection: function(t) {
                    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
                        n[r - 1] = arguments[r];
                    return H.run("intersection", t, n)
                },
                xor: function(t) {
                    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
                        n[r - 1] = arguments[r];
                    return H.run("xor", t, n)
                },
                difference: function(t) {
                    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
                        n[r - 1] = arguments[r];
                    return H.run("difference", t, n)
                }
            }
        }()
    }
    ).call(this, n(22))
}
, function(module, exports) {
    !function(t) {
        var e = {};
        function n(r) {
            if (e[r])
                return e[r].exports;
            var a = e[r] = {
                i: r,
                l: !1,
                exports: {}
            };
            return t[r].call(a.exports, a, a.exports, n),
            a.l = !0,
            a.exports
        }
        n.m = t,
        n.c = e,
        n.d = function(t, e, r) {
            n.o(t, e) || Object.defineProperty(t, e, {
                enumerable: !0,
                get: r
            })
        }
        ,
        n.r = function(t) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                value: "Module"
            }),
            Object.defineProperty(t, "__esModule", {
                value: !0
            })
        }
        ,
        n.t = function(t, e) {
            if (1 & e && (t = n(t)),
            8 & e)
                return t;
            if (4 & e && "object" == typeof t && t && t.__esModule)
                return t;
            var r = Object.create(null);
            if (n.r(r),
            Object.defineProperty(r, "default", {
                enumerable: !0,
                value: t
            }),
            2 & e && "string" != typeof t)
                for (var a in t)
                    n.d(r, a, function(e) {
                        return t[e]
                    }
                    .bind(null, a));
            return r
        }
        ,
        n.n = function(t) {
            var e = t && t.__esModule ? function() {
                return t.default
            }
            : function() {
                return t
            }
            ;
            return n.d(e, "a", e),
            e
        }
        ,
        n.o = function(t, e) {
            return Object.prototype.hasOwnProperty.call(t, e)
        }
        ,
        n.p = "../dist/",
        n(n.s = "./src/main_uEarth.js")
    }({
        "./lib/threejs/createBigBuildingByUearth.worker.js": /*!*********************************************************!*\
  !*** ./lib/threejs/createBigBuildingByUearth.worker.js ***!
  \*********************************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            eval("module.exports = function() {\n  return __webpack_require__(/*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */ \"./node_modules/worker-loader/dist/workers/InlineWorker.js\")(\"/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// define __esModule on exports\\n/******/ \\t__webpack_require__.r = function(exports) {\\n/******/ \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n/******/ \\t\\t}\\n/******/ \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n/******/ \\t};\\n/******/\\n/******/ \\t// create a fake namespace object\\n/******/ \\t// mode & 1: value is a module id, require it\\n/******/ \\t// mode & 2: merge all properties of value into the ns\\n/******/ \\t// mode & 4: return value when already ns object\\n/******/ \\t// mode & 8|1: behave like require\\n/******/ \\t__webpack_require__.t = function(value, mode) {\\n/******/ \\t\\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \\t\\tif(mode & 8) return value;\\n/******/ \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n/******/ \\t\\tvar ns = Object.create(null);\\n/******/ \\t\\t__webpack_require__.r(ns);\\n/******/ \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n/******/ \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \\t\\treturn ns;\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"../dist/\\\";\\n/******/\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = \\\"./node_modules/babel-loader/lib/index.js?!./lib/threejs/createBigBuildingByUearth.worker.js\\\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \\\"./lib/threejs/BufferGeometryUtils.js\\\":\\n/*!********************************************!*\\\\\\n  !*** ./lib/threejs/BufferGeometryUtils.js ***!\\n  \\\\********************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"\\\\n\\\\n/**\\\\r\\\\n * @author mrdoob / http://mrdoob.com/\\\\r\\\\n * changed by zhgu\\\\r\\\\n */\\\\nvar THREE = __webpack_require__(/*! ./extrudeAndBufferAttribute.js */ \\\\\\\"./lib/threejs/extrudeAndBufferAttribute.js\\\\\\\");\\\\nTHREE.BufferGeometryUtils1 = {\\\\n    /**\\\\r\\\\n     * @param  {Array<THREE.BufferGeometry>} geometries\\\\r\\\\n     * @param  {Boolean} useGroups\\\\r\\\\n     * maxCount 最大顶点数量默认 50000 added by zhgu\\\\r\\\\n     * @return {THREE.BufferGeometry}\\\\r\\\\n     */\\\\n    mergeBufferGeometries1: function mergeBufferGeometries1(geometries, maxCount, useGroups) {\\\\n        maxCount = maxCount || 50000;\\\\n        // maxCount *= 3;\\\\n        var curCount = 0;\\\\n        var index = 0;\\\\n        var resultGeo = [[]];\\\\n        for (var i = 0; i < geometries.length; i++) {\\\\n            var geometry = geometries[i];\\\\n            if (geometry.attributes.position) {\\\\n                var positionCount = geometry.attributes.position.count;\\\\n                curCount += positionCount;\\\\n                if (curCount < maxCount) {\\\\n                    if (!(resultGeo[index] instanceof Array)) {\\\\n                        resultGeo[index] = [];\\\\n                    }\\\\n                    resultGeo[index].push(geometry);\\\\n                } else {\\\\n                    curCount = 0;\\\\n                    if (!(resultGeo[index] instanceof Array)) {\\\\n                        resultGeo[index] = [];\\\\n                    }\\\\n                    resultGeo[index].push(geometry);\\\\n                    index++;\\\\n                }\\\\n            } else {\\\\n                console.warn('该geometry' + geometry.id + '无position，请检查是否存在问题');\\\\n            }\\\\n        }\\\\n        var mergedResult = [];\\\\n        for (var k = 0; k < resultGeo.length; k++) {\\\\n            var mergedGeometry = this.mergeBufferGeometries(resultGeo[k], useGroups);\\\\n            //继续合并groups\\\\n            if (useGroups) {\\\\n                this.mergeGroups(mergedGeometry);\\\\n            }\\\\n            mergedResult.push(mergedGeometry);\\\\n        }\\\\n        return mergedResult;\\\\n    },\\\\n    /**\\\\r\\\\n     * @param  {Array<THREE.BufferGeometry>} geometries\\\\r\\\\n     * @param  {Boolean} useGroups\\\\r\\\\n     * maxCount 最大顶点数量默认 50000 added by zhgu\\\\r\\\\n     * @return {THREE.BufferGeometry}\\\\r\\\\n     */\\\\n    mergeBufferGeometries: function mergeBufferGeometries(geometries, useGroups) {\\\\n\\\\n        var isIndexed = geometries[0].index !== null;\\\\n\\\\n        var attributesUsed = new Set(Object.keys(geometries[0].attributes));\\\\n        var morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\\\\n\\\\n        var attributes = {};\\\\n        var morphAttributes = {};\\\\n\\\\n        var mergedGeometry = new THREE.BufferGeometry();\\\\n\\\\n        var offset = 0;\\\\n\\\\n        for (var i = 0; i < geometries.length; ++i) {\\\\n\\\\n            var geometry = geometries[i];\\\\n\\\\n            // ensure that all geometries are indexed, or none\\\\n\\\\n            if (isIndexed !== (geometry.index !== null)) return null;\\\\n\\\\n            // gather attributes, exit early if they're different\\\\n\\\\n            for (var name in geometry.attributes) {\\\\n\\\\n                if (!attributesUsed.has(name)) return null;\\\\n\\\\n                if (attributes[name] === undefined) attributes[name] = [];\\\\n\\\\n                attributes[name].push(geometry.attributes[name]);\\\\n            }\\\\n\\\\n            // gather morph attributes, exit early if they're different\\\\n\\\\n            for (var _name in geometry.morphAttributes) {\\\\n\\\\n                if (!morphAttributesUsed.has(_name)) return null;\\\\n\\\\n                if (morphAttributes[_name] === undefined) morphAttributes[_name] = [];\\\\n\\\\n                morphAttributes[_name].push(geometry.morphAttributes[_name]);\\\\n            }\\\\n\\\\n            // gather .userData\\\\n\\\\n            mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\\\\n            mergedGeometry.userData.mergedUserData.push(geometry.userData);\\\\n\\\\n            if (useGroups) {\\\\n\\\\n                var count;\\\\n\\\\n                if (isIndexed) {\\\\n\\\\n                    count = geometry.index.count;\\\\n                } else if (geometry.attributes.position !== undefined) {\\\\n\\\\n                    count = geometry.attributes.position.count;\\\\n                } else {\\\\n\\\\n                    return null;\\\\n                }\\\\n\\\\n                // mergedGeometry.addGroup( offset, count, i );\\\\n                //changed by zhgu\\\\n                if (geometry.groups) {\\\\n                    geometry.groups.map(function (v) {\\\\n                        var start = v.start;\\\\n                        var nums = v.count;\\\\n                        var materialIndex = v.materialIndex;\\\\n                        mergedGeometry.addGroup(offset + start, nums, materialIndex);\\\\n                    });\\\\n                }\\\\n                offset += count;\\\\n            }\\\\n\\\\n            //needMerge\\\\n            if (geometry._needMerge) {\\\\n                for (var key in geometry._needMerge) {\\\\n                    if (!mergedGeometry._needMerge) {\\\\n                        mergedGeometry._needMerge = {};\\\\n                    }\\\\n                    if (!mergedGeometry._needMerge[key]) {\\\\n                        mergedGeometry._needMerge[key] = [];\\\\n                    }\\\\n                    mergedGeometry._needMerge[key].push(geometry._needMerge[key]);\\\\n                }\\\\n            }\\\\n        }\\\\n\\\\n        // merge indices\\\\n\\\\n        if (isIndexed) {\\\\n\\\\n            var indexOffset = 0;\\\\n            var mergedIndex = [];\\\\n\\\\n            for (var _i = 0; _i < geometries.length; ++_i) {\\\\n\\\\n                var index = geometries[_i].index;\\\\n\\\\n                for (var j = 0; j < index.count; ++j) {\\\\n\\\\n                    mergedIndex.push(index.getX(j) + indexOffset);\\\\n                }\\\\n\\\\n                indexOffset += geometries[_i].attributes.position.count;\\\\n            }\\\\n\\\\n            mergedGeometry.setIndex(mergedIndex);\\\\n        }\\\\n\\\\n        // merge attributes\\\\n\\\\n        for (var _name2 in attributes) {\\\\n\\\\n            var mergedAttribute = this.mergeBufferAttributes(attributes[_name2]);\\\\n\\\\n            if (!mergedAttribute) return null;\\\\n\\\\n            mergedGeometry.addAttribute(_name2, mergedAttribute);\\\\n        }\\\\n\\\\n        // merge morph attributes\\\\n\\\\n        for (var _name3 in morphAttributes) {\\\\n\\\\n            var numMorphTargets = morphAttributes[_name3][0].length;\\\\n\\\\n            if (numMorphTargets === 0) break;\\\\n\\\\n            mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\\\\n            mergedGeometry.morphAttributes[_name3] = [];\\\\n\\\\n            for (var _i2 = 0; _i2 < numMorphTargets; ++_i2) {\\\\n\\\\n                var morphAttributesToMerge = [];\\\\n\\\\n                for (var _j = 0; _j < morphAttributes[_name3].length; ++_j) {\\\\n\\\\n                    morphAttributesToMerge.push(morphAttributes[_name3][_j][_i2]);\\\\n                }\\\\n\\\\n                var mergedMorphAttribute = this.mergeBufferAttributes(morphAttributesToMerge);\\\\n\\\\n                if (!mergedMorphAttribute) return null;\\\\n\\\\n                mergedGeometry.morphAttributes[_name3].push(mergedMorphAttribute);\\\\n            }\\\\n        }\\\\n\\\\n        return mergedGeometry;\\\\n    },\\\\n\\\\n    /**\\\\r\\\\n     *@author zhuguang <zhuguang@uinnova.com>\\\\r\\\\n     *@descripition 为了极限增加性能，需要对geometry的groups进行二次merge\\\\r\\\\n     *@type {String}\\\\r\\\\n     */\\\\n    mergeGroups: function mergeGroups(geometry) {\\\\n        var groups = geometry.groups;\\\\n        var indexArr = {};\\\\n        //目前只考虑attribute的合并\\\\n        //收集index\\\\n        for (var i = 0, len = groups.length; i < len; i++) {\\\\n            var group = groups[i];\\\\n            var materialIndex = group.materialIndex;\\\\n            if (!indexArr[materialIndex]) {\\\\n                indexArr[materialIndex] = [];\\\\n            }\\\\n            indexArr[materialIndex].push(group);\\\\n        }\\\\n        //遍历attribute\\\\n        for (var name in geometry.attributes) {\\\\n            //var attr = geometry.attributes(name);\\\\n            if (name.indexOf('position') !== -1) {\\\\n                geometry.addAttribute('position', new THREE.BufferAttribute(this._recombinationArr(geometry, name, indexArr, true), 3));\\\\n            } else if (name.indexOf('uv') !== -1) {\\\\n                geometry.addAttribute(name, new THREE.BufferAttribute(this._recombinationArr(geometry, name, indexArr), 2));\\\\n            } else if (name.indexOf('normal') !== -1) {\\\\n                geometry.addAttribute(name, new THREE.BufferAttribute(this._recombinationArr(geometry, name, indexArr), 3));\\\\n            } else if (name.indexOf('id') !== -1 || name.indexOf('vis') !== -1) {\\\\n                geometry.addAttribute(name, new THREE.BufferAttribute(this._recombinationArr(geometry, name, indexArr), 1));\\\\n            }\\\\n        }\\\\n    },\\\\n    _recombinationArr: function _recombinationArr(geometry, name, indexArr, updateGroups) {\\\\n        var arr = geometry.attributes[name].array;\\\\n        var res = new Float32Array(arr.length);\\\\n        var IndexMap = {};\\\\n        var resIndex = 0;\\\\n        // arr = arr.join(',');\\\\n        var interval = geometry.attributes[name].itemSize;\\\\n        for (var k in indexArr) {\\\\n            IndexMap[k] = { start: resIndex / interval };\\\\n            var index = indexArr[k];\\\\n            var end = 0;\\\\n            for (var i = 0, len = index.length; i < len; i++) {\\\\n                var group = index[i];\\\\n                var start = group.start * interval;\\\\n                var size = group.count * interval;\\\\n                this._getNewArrayFromArr(res, resIndex, arr, start, size);\\\\n                resIndex += size;\\\\n                end += size;\\\\n            }\\\\n            IndexMap[k].count = end / interval;\\\\n        }\\\\n        //处理groups,先清空\\\\n        if (updateGroups) {\\\\n            geometry.groups = [];\\\\n            for (var nums in IndexMap) {\\\\n                var indexMap0 = IndexMap[nums];\\\\n                geometry.addGroup(indexMap0.start, indexMap0.count, parseInt(nums));\\\\n            }\\\\n        }\\\\n\\\\n        return res;\\\\n        //\\\\n        // for(var t in res){\\\\n        //     final = final.concat(res[t]);\\\\n        // }\\\\n        //\\\\n        // return final;\\\\n    },\\\\n\\\\n    _getNewArrayFromArr: function _getNewArrayFromArr(res, resIndex, arr, start, count) {\\\\n        for (var i = start; i < start + count; i++) {\\\\n            res[resIndex] = arr[i];\\\\n            resIndex++;\\\\n        }\\\\n    },\\\\n\\\\n    /**\\\\r\\\\n     * @param {Array<THREE.BufferAttribute>} attributes\\\\r\\\\n     * @return {THREE.BufferAttribute}\\\\r\\\\n     */\\\\n    mergeBufferAttributes: function mergeBufferAttributes(attributes) {\\\\n\\\\n        var TypedArray;\\\\n        var itemSize;\\\\n        var normalized;\\\\n        var arrayLength = 0;\\\\n\\\\n        for (var i = 0; i < attributes.length; ++i) {\\\\n\\\\n            var attribute = attributes[i];\\\\n\\\\n            if (attribute.isInterleavedBufferAttribute) return null;\\\\n\\\\n            if (TypedArray === undefined) TypedArray = attribute.array.constructor;\\\\n            if (TypedArray !== attribute.array.constructor) return null;\\\\n\\\\n            if (itemSize === undefined) itemSize = attribute.itemSize;\\\\n            if (itemSize !== attribute.itemSize) return null;\\\\n\\\\n            if (normalized === undefined) normalized = attribute.normalized;\\\\n            if (normalized !== attribute.normalized) return null;\\\\n\\\\n            arrayLength += attribute.array.length;\\\\n        }\\\\n\\\\n        var array = new TypedArray(arrayLength);\\\\n        var offset = 0;\\\\n\\\\n        for (var i = 0; i < attributes.length; ++i) {\\\\n\\\\n            array.set(attributes[i].array, offset);\\\\n\\\\n            offset += attributes[i].array.length;\\\\n        }\\\\n\\\\n        return new THREE.BufferAttribute(array, itemSize, normalized);\\\\n    }\\\\n\\\\n};\\\\n\\\\n//# sourceURL=webpack:///./lib/threejs/BufferGeometryUtils.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./lib/threejs/extrudeAndBufferAttribute.js\\\":\\n/*!**************************************************!*\\\\\\n  !*** ./lib/threejs/extrudeAndBufferAttribute.js ***!\\n  \\\\**************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\\\\n\\\\nvar _typeof = typeof Symbol === \\\\\\\"function\\\\\\\" && typeof Symbol.iterator === \\\\\\\"symbol\\\\\\\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \\\\\\\"function\\\\\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\\\\\"symbol\\\\\\\" : typeof obj; };\\\\n\\\\n(function (global, factory) {\\\\n\\\\t\\\\t\\\\t( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\\\\n\\\\t\\\\t\\\\t\\\\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\\\\n\\\\t\\\\t\\\\t\\\\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\\\\n\\\\t\\\\t\\\\t\\\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);\\\\n})(undefined, function (exports) {\\\\n\\\\t\\\\t\\\\t'use strict';\\\\n\\\\n\\\\t\\\\t\\\\t// Polyfills\\\\n\\\\n\\\\t\\\\t\\\\tif (Number.EPSILON === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tNumber.EPSILON = Math.pow(2, -52);\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tif (Number.isInteger === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Missing in IE\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tNumber.isInteger = function (value) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t//\\\\n\\\\n\\\\t\\\\t\\\\tif (Math.sign === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tMath.sign = function (x) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn x < 0 ? -1 : x > 0 ? 1 : +x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tif ('name' in Function.prototype === false) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Missing in IE\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tObject.defineProperty(Function.prototype, 'name', {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tget: function get() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.toString().match(/^\\\\\\\\s*function\\\\\\\\s*([^\\\\\\\\(\\\\\\\\s]*)/)[1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t});\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tif (Object.assign === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Missing in IE\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t(function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tObject.assign = function (target) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (target === undefined || target === null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthrow new TypeError('Cannot convert undefined or null to object');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar output = Object(target);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var index = 1; index < arguments.length; index++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar source = arguments[index];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (source !== undefined && source !== null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var nextKey in source) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Object.prototype.hasOwnProperty.call(source, nextKey)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\toutput[nextKey] = source[nextKey];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn output;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t})();\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * https://github.com/mrdoob/eventdispatcher.js/\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\tfunction EventDispatcher() {}\\\\n\\\\n\\\\t\\\\t\\\\tObject.assign(EventDispatcher.prototype, {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddEventListener: function addEventListener(type, listener) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this._listeners === undefined) this._listeners = {};\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar listeners = this._listeners;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (listeners[type] === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlisteners[type] = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (listeners[type].indexOf(listener) === -1) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlisteners[type].push(listener);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\thasEventListener: function hasEventListener(type, listener) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this._listeners === undefined) return false;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar listeners = this._listeners;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tremoveEventListener: function removeEventListener(type, listener) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this._listeners === undefined) return;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar listeners = this._listeners;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar listenerArray = listeners[type];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (listenerArray !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar index = listenerArray.indexOf(listener);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (index !== -1) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlistenerArray.splice(index, 1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdispatchEvent: function dispatchEvent(event) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this._listeners === undefined) return;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar listeners = this._listeners;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar listenerArray = listeners[event.type];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (listenerArray !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tevent.target = this;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar array = listenerArray.slice(0);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = array.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[i].call(this, event);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author alteredq / http://alteredqualia.com/\\\\r\\\\n    * @author mrdoob / http://mrdoob.com/\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\tvar _Math = {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tDEG2RAD: Math.PI / 180,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tRAD2DEG: 180 / Math.PI,\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgenerateUUID: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar lut = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < 256; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlut[i] = (i < 16 ? '0' : '') + i.toString(16);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function generateUUID() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar d0 = Math.random() * 0xffffffff | 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar d1 = Math.random() * 0xffffffff | 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar d2 = Math.random() * 0xffffffff | 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar d3 = Math.random() * 0xffffffff | 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar uuid = lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// .toUpperCase() here flattens concatenated strings to save heap memory space.\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn uuid.toUpperCase();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclamp: function clamp(value, min, max) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn Math.max(min, Math.min(max, value));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// compute euclidian modulo of m % n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// https://en.wikipedia.org/wiki/Modulo_operation\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\teuclideanModulo: function euclideanModulo(n, m) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn (n % m + m) % m;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Linear mapping from range <a1, a2> to range <b1, b2>\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmapLinear: function mapLinear(x, a1, a2, b1, b2) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn b1 + (x - a1) * (b2 - b1) / (a2 - a1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// https://en.wikipedia.org/wiki/Linear_interpolation\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlerp: function lerp(x, y, t) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn (1 - t) * x + t * y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// http://en.wikipedia.org/wiki/Smoothstep\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsmoothstep: function smoothstep(x, min, max) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (x <= min) return 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (x >= max) return 1;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tx = (x - min) / (max - min);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn x * x * (3 - 2 * x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsmootherstep: function smootherstep(x, min, max) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (x <= min) return 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (x >= max) return 1;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tx = (x - min) / (max - min);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn x * x * x * (x * (x * 6 - 15) + 10);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Random integer from <low, high> interval\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\trandInt: function randInt(low, high) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn low + Math.floor(Math.random() * (high - low + 1));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Random float from <low, high> interval\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\trandFloat: function randFloat(low, high) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn low + Math.random() * (high - low);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Random float from <-range/2, range/2> interval\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\trandFloatSpread: function randFloatSpread(range) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn range * (0.5 - Math.random());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdegToRad: function degToRad(degrees) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn degrees * _Math.DEG2RAD;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tradToDeg: function radToDeg(radians) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn radians * _Math.RAD2DEG;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tisPowerOfTwo: function isPowerOfTwo(value) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn (value & value - 1) === 0 && value !== 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tceilPowerOfTwo: function ceilPowerOfTwo(value) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfloorPowerOfTwo: function floorPowerOfTwo(value) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn Math.pow(2, Math.floor(Math.log(value) / Math.LN2));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author mrdoob / http://mrdoob.com/\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\tvar ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\\\\n\\\\n\\\\t\\\\t\\\\tfunction Color(r, g, b) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (g === undefined && b === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// r is THREE.Color, hex or string\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.set(r);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.setRGB(r, g, b);\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tObject.assign(Color.prototype, {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tisColor: true,\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tr: 1, g: 1, b: 1,\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tset: function set(value) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (value && value.isColor) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.copy(value);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (typeof value === 'number') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.setHex(value);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (typeof value === 'string') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.setStyle(value);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetScalar: function setScalar(scalar) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.r = scalar;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.g = scalar;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.b = scalar;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetHex: function setHex(hex) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\thex = Math.floor(hex);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.r = (hex >> 16 & 255) / 255;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.g = (hex >> 8 & 255) / 255;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.b = (hex & 255) / 255;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetRGB: function setRGB(r, g, b) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.r = r;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.g = g;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.b = b;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetHSL: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction hue2rgb(p, q, t) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (t < 0) t += 1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (t > 1) t -= 1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (t < 1 / 6) return p + (q - p) * 6 * t;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (t < 1 / 2) return q;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn p;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function setHSL(h, s, l) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// h,s,l ranges are in 0.0 - 1.0\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\th = _Math.euclideanModulo(h, 1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ts = _Math.clamp(s, 0, 1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tl = _Math.clamp(l, 0, 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (s === 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.r = this.g = this.b = l;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar q = 2 * l - p;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.r = hue2rgb(q, p, h + 1 / 3);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.g = hue2rgb(q, p, h);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.b = hue2rgb(q, p, h - 1 / 3);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetStyle: function setStyle(style) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction handleAlpha(string) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (string === undefined) return;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (parseFloat(string) < 1) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar m;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (m = /^((?:rgb|hsl)a?)\\\\\\\\(\\\\\\\\s*([^\\\\\\\\)]*)\\\\\\\\)/.exec(style)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// rgb / hsl\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar color;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar name = m[1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar components = m[2];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tswitch (name) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase 'rgb':\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase 'rgba':\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (color = /^(\\\\\\\\d+)\\\\\\\\s*,\\\\\\\\s*(\\\\\\\\d+)\\\\\\\\s*,\\\\\\\\s*(\\\\\\\\d+)\\\\\\\\s*(,\\\\\\\\s*([0-9]*\\\\\\\\.?[0-9]+)\\\\\\\\s*)?$/.exec(components)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// rgb(255,0,0) rgba(255,0,0,0.5)\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.r = Math.min(255, parseInt(color[1], 10)) / 255;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.g = Math.min(255, parseInt(color[2], 10)) / 255;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.b = Math.min(255, parseInt(color[3], 10)) / 255;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\thandleAlpha(color[5]);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (color = /^(\\\\\\\\d+)\\\\\\\\%\\\\\\\\s*,\\\\\\\\s*(\\\\\\\\d+)\\\\\\\\%\\\\\\\\s*,\\\\\\\\s*(\\\\\\\\d+)\\\\\\\\%\\\\\\\\s*(,\\\\\\\\s*([0-9]*\\\\\\\\.?[0-9]+)\\\\\\\\s*)?$/.exec(components)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.r = Math.min(100, parseInt(color[1], 10)) / 100;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.g = Math.min(100, parseInt(color[2], 10)) / 100;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.b = Math.min(100, parseInt(color[3], 10)) / 100;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\thandleAlpha(color[5]);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbreak;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase 'hsl':\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase 'hsla':\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (color = /^([0-9]*\\\\\\\\.?[0-9]+)\\\\\\\\s*,\\\\\\\\s*(\\\\\\\\d+)\\\\\\\\%\\\\\\\\s*,\\\\\\\\s*(\\\\\\\\d+)\\\\\\\\%\\\\\\\\s*(,\\\\\\\\s*([0-9]*\\\\\\\\.?[0-9]+)\\\\\\\\s*)?$/.exec(components)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar h = parseFloat(color[1]) / 360;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar s = parseInt(color[2], 10) / 100;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar l = parseInt(color[3], 10) / 100;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\thandleAlpha(color[5]);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.setHSL(h, s, l);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbreak;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (m = /^\\\\\\\\#([A-Fa-f0-9]+)$/.exec(style)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// hex color\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hex = m[1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar size = hex.length;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (size === 3) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// #ff0\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (size === 6) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// #ff0000\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (style && style.length > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// color keywords\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hex = ColorKeywords[style];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (hex !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// red\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.setHex(hex);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// unknown color\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Color: Unknown color ' + style);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclone: function clone() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn new this.constructor(this.r, this.g, this.b);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopy: function copy(color) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.r = color.r;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.g = color.g;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.b = color.b;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopyGammaToLinear: function copyGammaToLinear(color, gammaFactor) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (gammaFactor === undefined) gammaFactor = 2.0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.r = Math.pow(color.r, gammaFactor);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.g = Math.pow(color.g, gammaFactor);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.b = Math.pow(color.b, gammaFactor);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopyLinearToGamma: function copyLinearToGamma(color, gammaFactor) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (gammaFactor === undefined) gammaFactor = 2.0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.r = Math.pow(color.r, safeInverse);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.g = Math.pow(color.g, safeInverse);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.b = Math.pow(color.b, safeInverse);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconvertGammaToLinear: function convertGammaToLinear(gammaFactor) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.copyGammaToLinear(this, gammaFactor);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconvertLinearToGamma: function convertLinearToGamma(gammaFactor) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.copyLinearToGamma(this, gammaFactor);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopySRGBToLinear: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction SRGBToLinear(c) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function copySRGBToLinear(color) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.r = SRGBToLinear(color.r);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.g = SRGBToLinear(color.g);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.b = SRGBToLinear(color.b);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopyLinearToSRGB: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction LinearToSRGB(c) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function copyLinearToSRGB(color) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.r = LinearToSRGB(color.r);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.g = LinearToSRGB(color.g);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.b = LinearToSRGB(color.b);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconvertSRGBToLinear: function convertSRGBToLinear() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.copySRGBToLinear(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconvertLinearToSRGB: function convertLinearToSRGB() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.copyLinearToSRGB(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetHex: function getHex() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetHexString: function getHexString() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn ('000000' + this.getHex().toString(16)).slice(-6);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetHSL: function getHSL(target) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// h,s,l ranges are in 0.0 - 1.0\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (target === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Color: .getHSL() target is now required');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttarget = { h: 0, s: 0, l: 0 };\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar r = this.r,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    g = this.g,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b = this.b;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar max = Math.max(r, g, b);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar min = Math.min(r, g, b);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hue, saturation;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar lightness = (min + max) / 2.0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (min === max) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\thue = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsaturation = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar delta = max - min;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsaturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tswitch (max) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase r:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\thue = (g - b) / delta + (g < b ? 6 : 0);break;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase g:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\thue = (b - r) / delta + 2;break;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase b:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\thue = (r - g) / delta + 4;break;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\thue /= 6;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttarget.h = hue;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttarget.s = saturation;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttarget.l = lightness;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn target;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetStyle: function getStyle() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\toffsetHSL: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hsl = {};\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function (h, s, l) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.getHSL(hsl);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\thsl.h += h;hsl.s += s;hsl.l += l;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.setHSL(hsl.h, hsl.s, hsl.l);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tadd: function add(color) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.r += color.r;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.g += color.g;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.b += color.b;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddColors: function addColors(color1, color2) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.r = color1.r + color2.r;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.g = color1.g + color2.g;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.b = color1.b + color2.b;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddScalar: function addScalar(s) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.r += s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.g += s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.b += s;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsub: function sub(color) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.r = Math.max(0, this.r - color.r);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.g = Math.max(0, this.g - color.g);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.b = Math.max(0, this.b - color.b);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmultiply: function multiply(color) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.r *= color.r;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.g *= color.g;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.b *= color.b;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmultiplyScalar: function multiplyScalar(s) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.r *= s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.g *= s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.b *= s;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlerp: function lerp(color, alpha) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.r += (color.r - this.r) * alpha;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.g += (color.g - this.g) * alpha;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.b += (color.b - this.b) * alpha;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlerpHSL: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hslA = { h: 0, s: 0, l: 0 };\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hslB = { h: 0, s: 0, l: 0 };\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function lerpHSL(color, alpha) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.getHSL(hslA);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcolor.getHSL(hslB);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar h = _Math.lerp(hslA.h, hslB.h, alpha);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar s = _Math.lerp(hslA.s, hslB.s, alpha);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar l = _Math.lerp(hslA.l, hslB.l, alpha);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.setHSL(h, s, l);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tequals: function equals(c) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn c.r === this.r && c.g === this.g && c.b === this.b;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfromArray: function fromArray(array, offset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (offset === undefined) offset = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.r = array[offset];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.g = array[offset + 1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.b = array[offset + 2];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttoArray: function toArray(array, offset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (array === undefined) array = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (offset === undefined) offset = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset] = this.r;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 1] = this.g;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 2] = this.b;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn array;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttoJSON: function toJSON() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.getHex();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetColorKeyword: function getColorKeyword() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn ColorKeywords;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author mrdoob / http://mrdoob.com/\\\\r\\\\n    * @author supereggbert / http://www.paulbrunt.co.uk/\\\\r\\\\n    * @author philogb / http://blog.thejit.org/\\\\r\\\\n    * @author jordi_ros / http://plattsoft.com\\\\r\\\\n    * @author D1plo1d / http://github.com/D1plo1d\\\\r\\\\n    * @author alteredq / http://alteredqualia.com/\\\\r\\\\n    * @author mikael emtinger / http://gomo.se/\\\\r\\\\n    * @author timknip / http://www.floorplanner.com/\\\\r\\\\n    * @author bhouston / http://clara.io\\\\r\\\\n    * @author WestLangley / http://github.com/WestLangley\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\tfunction Matrix4() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (arguments.length > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tObject.assign(Matrix4.prototype, {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tisMatrix4: true,\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tset: function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] = n11;te[4] = n12;te[8] = n13;te[12] = n14;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[1] = n21;te[5] = n22;te[9] = n23;te[13] = n24;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[2] = n31;te[6] = n32;te[10] = n33;te[14] = n34;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[3] = n41;te[7] = n42;te[11] = n43;te[15] = n44;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tidentity: function identity() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclone: function clone() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn new Matrix4().fromArray(this.elements);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopy: function copy(m) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar me = m.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] = me[0];te[1] = me[1];te[2] = me[2];te[3] = me[3];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[4] = me[4];te[5] = me[5];te[6] = me[6];te[7] = me[7];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[8] = me[8];te[9] = me[9];te[10] = me[10];te[11] = me[11];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[12] = me[12];te[13] = me[13];te[14] = me[14];te[15] = me[15];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopyPosition: function copyPosition(m) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    me = m.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[12] = me[12];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[13] = me[13];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[14] = me[14];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\textractBasis: function extractBasis(xAxis, yAxis, zAxis) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\txAxis.setFromMatrixColumn(this, 0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tyAxis.setFromMatrixColumn(this, 1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tzAxis.setFromMatrixColumn(this, 2);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmakeBasis: function makeBasis(xAxis, yAxis, zAxis) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\textractRotation: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v1 = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function extractRotation(m) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// this method does not support reflection matrices\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar me = m.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] = me[0] * scaleX;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[1] = me[1] * scaleX;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[2] = me[2] * scaleX;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[3] = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[4] = me[4] * scaleY;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[5] = me[5] * scaleY;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[6] = me[6] * scaleY;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[7] = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[8] = me[8] * scaleZ;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[9] = me[9] * scaleZ;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[10] = me[10] * scaleZ;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[11] = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[12] = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[13] = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[14] = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[15] = 1;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmakeRotationFromEuler: function makeRotationFromEuler(euler) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!(euler && euler.isEuler)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x = euler.x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    y = euler.y,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    z = euler.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a = Math.cos(x),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b = Math.sin(x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar c = Math.cos(y),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    d = Math.sin(y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar e = Math.cos(z),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    f = Math.sin(z);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (euler.order === 'XYZ') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar ae = a * e,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    af = a * f,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    be = b * e,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    bf = b * f;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] = c * e;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[4] = -c * f;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[8] = d;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[1] = af + be * d;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[5] = ae - bf * d;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[9] = -b * c;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[2] = bf - ae * d;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[6] = be + af * d;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[10] = a * c;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (euler.order === 'YXZ') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar ce = c * e,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    cf = c * f,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    de = d * e,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    df = d * f;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] = ce + df * b;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[4] = de * b - cf;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[8] = a * d;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[1] = a * f;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[5] = a * e;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[9] = -b;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[2] = cf * b - de;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[6] = df + ce * b;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[10] = a * c;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (euler.order === 'ZXY') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar ce = c * e,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    cf = c * f,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    de = d * e,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    df = d * f;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] = ce - df * b;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[4] = -a * f;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[8] = de + cf * b;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[1] = cf + de * b;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[5] = a * e;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[9] = df - ce * b;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[2] = -a * d;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[6] = b;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[10] = a * c;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (euler.order === 'ZYX') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar ae = a * e,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    af = a * f,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    be = b * e,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    bf = b * f;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] = c * e;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[4] = be * d - af;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[8] = ae * d + bf;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[1] = c * f;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[5] = bf * d + ae;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[9] = af * d - be;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[2] = -d;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[6] = b * c;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[10] = a * c;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (euler.order === 'YZX') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar ac = a * c,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    ad = a * d,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    bc = b * c,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    bd = b * d;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] = c * e;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[4] = bd - ac * f;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[8] = bc * f + ad;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[1] = f;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[5] = a * e;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[9] = -b * e;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[2] = -d * e;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[6] = ad * f + bc;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[10] = ac - bd * f;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (euler.order === 'XZY') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar ac = a * c,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    ad = a * d,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    bc = b * c,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    bd = b * d;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] = c * e;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[4] = -f;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[8] = d * e;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[1] = ac * f + bd;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[5] = a * e;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[9] = ad * f - bc;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[2] = bc * f - ad;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[6] = b * e;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[10] = bd * f + ac;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// bottom row\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[3] = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[7] = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[11] = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// last column\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[12] = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[13] = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[14] = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[15] = 1;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmakeRotationFromQuaternion: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar zero = new Vector3(0, 0, 0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar one = new Vector3(1, 1, 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function makeRotationFromQuaternion(q) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.compose(zero, q, one);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlookAt: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar y = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar z = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function lookAt(eye, target, up) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tz.subVectors(eye, target);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (z.lengthSq() === 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// eye and target are in the same position\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tz.z = 1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tz.normalize();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tx.crossVectors(up, z);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (x.lengthSq() === 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// up and z are parallel\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Math.abs(up.z) === 1) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tz.x += 0.0001;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tz.z += 0.0001;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tz.normalize();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tx.crossVectors(up, z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tx.normalize();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ty.crossVectors(z, x);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] = x.x;te[4] = y.x;te[8] = z.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[1] = x.y;te[5] = y.y;te[9] = z.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[2] = x.z;te[6] = y.z;te[10] = z.z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmultiply: function multiply(m, n) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (n !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.multiplyMatrices(m, n);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.multiplyMatrices(this, m);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpremultiply: function premultiply(m) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.multiplyMatrices(m, this);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmultiplyMatrices: function multiplyMatrices(a, b) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar ae = a.elements;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar be = b.elements;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a11 = ae[0],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    a12 = ae[4],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    a13 = ae[8],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    a14 = ae[12];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a21 = ae[1],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    a22 = ae[5],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    a23 = ae[9],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    a24 = ae[13];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a31 = ae[2],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    a32 = ae[6],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    a33 = ae[10],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    a34 = ae[14];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a41 = ae[3],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    a42 = ae[7],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    a43 = ae[11],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    a44 = ae[15];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar b11 = be[0],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b12 = be[4],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b13 = be[8],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b14 = be[12];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar b21 = be[1],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b22 = be[5],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b23 = be[9],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b24 = be[13];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar b31 = be[2],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b32 = be[6],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b33 = be[10],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b34 = be[14];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar b41 = be[3],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b42 = be[7],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b43 = be[11],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b44 = be[15];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmultiplyScalar: function multiplyScalar(s) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] *= s;te[4] *= s;te[8] *= s;te[12] *= s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[1] *= s;te[5] *= s;te[9] *= s;te[13] *= s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[2] *= s;te[6] *= s;te[10] *= s;te[14] *= s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[3] *= s;te[7] *= s;te[11] *= s;te[15] *= s;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tapplyToBufferAttribute: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v1 = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function applyToBufferAttribute(attribute) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = attribute.count; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv1.x = attribute.getX(i);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv1.y = attribute.getY(i);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv1.z = attribute.getZ(i);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv1.applyMatrix4(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tattribute.setXYZ(i, v1.x, v1.y, v1.z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn attribute;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdeterminant: function determinant() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar n11 = te[0],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n12 = te[4],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n13 = te[8],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n14 = te[12];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar n21 = te[1],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n22 = te[5],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n23 = te[9],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n24 = te[13];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar n31 = te[2],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n32 = te[6],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n33 = te[10],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n34 = te[14];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar n41 = te[3],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n42 = te[7],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n43 = te[11],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n44 = te[15];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//TODO: make this more efficient\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttranspose: function transpose() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar tmp;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttmp = te[1];te[1] = te[4];te[4] = tmp;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttmp = te[2];te[2] = te[8];te[8] = tmp;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttmp = te[6];te[6] = te[9];te[9] = tmp;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttmp = te[3];te[3] = te[12];te[12] = tmp;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttmp = te[7];te[7] = te[13];te[13] = tmp;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttmp = te[11];te[11] = te[14];te[14] = tmp;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetPosition: function setPosition(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[12] = v.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[13] = v.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[14] = v.z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetInverse: function getInverse(m, throwOnDegenerate) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    me = m.elements,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n11 = me[0],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n21 = me[1],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n31 = me[2],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n41 = me[3],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n12 = me[4],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n22 = me[5],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n32 = me[6],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n42 = me[7],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n13 = me[8],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n23 = me[9],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n33 = me[10],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n43 = me[11],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n14 = me[12],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n24 = me[13],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n34 = me[14],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n44 = me[15],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (det === 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar msg = 'THREE.Matrix4: .getInverse() can\\\\\\\\'t invert matrix, determinant is 0';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (throwOnDegenerate === true) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthrow new Error(msg);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn(msg);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.identity();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar detInv = 1 / det;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] = t11 * detInv;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[4] = t12 * detInv;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[8] = t13 * detInv;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[12] = t14 * detInv;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tscale: function scale(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x = v.x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    y = v.y,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    z = v.z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] *= x;te[4] *= y;te[8] *= z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[1] *= x;te[5] *= y;te[9] *= z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[2] *= x;te[6] *= y;te[10] *= z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[3] *= x;te[7] *= y;te[11] *= z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetMaxScaleOnAxis: function getMaxScaleOnAxis() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmakeTranslation: function makeTranslation(x, y, z) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmakeRotationX: function makeRotationX(theta) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar c = Math.cos(theta),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    s = Math.sin(theta);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmakeRotationY: function makeRotationY(theta) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar c = Math.cos(theta),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    s = Math.sin(theta);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmakeRotationZ: function makeRotationZ(theta) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar c = Math.cos(theta),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    s = Math.sin(theta);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmakeRotationAxis: function makeRotationAxis(axis, angle) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar c = Math.cos(angle);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar s = Math.sin(angle);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar t = 1 - c;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x = axis.x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    y = axis.y,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    z = axis.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar tx = t * x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    ty = t * y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmakeScale: function makeScale(x, y, z) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmakeShear: function makeShear(x, y, z) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcompose: function compose(position, quaternion, scale) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x = quaternion._x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    y = quaternion._y,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    z = quaternion._z,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    w = quaternion._w;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x2 = x + x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    y2 = y + y,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    z2 = z + z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar xx = x * x2,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    xy = x * y2,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    xz = x * z2;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar yy = y * y2,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    yz = y * z2,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    zz = z * z2;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar wx = w * x2,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    wy = w * y2,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    wz = w * z2;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar sx = scale.x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    sy = scale.y,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    sz = scale.z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] = (1 - (yy + zz)) * sx;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[1] = (xy + wz) * sx;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[2] = (xz - wy) * sx;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[3] = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[4] = (xy - wz) * sy;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[5] = (1 - (xx + zz)) * sy;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[6] = (yz + wx) * sy;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[7] = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[8] = (xz + wy) * sz;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[9] = (yz - wx) * sz;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[10] = (1 - (xx + yy)) * sz;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[11] = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[12] = position.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[13] = position.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[14] = position.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[15] = 1;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdecompose: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vector = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar matrix = new Matrix4();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function decompose(position, quaternion, scale) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar sx = vector.set(te[0], te[1], te[2]).length();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar sy = vector.set(te[4], te[5], te[6]).length();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar sz = vector.set(te[8], te[9], te[10]).length();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// if determine is negative, we need to invert one scale\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar det = this.determinant();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (det < 0) sx = -sx;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tposition.x = te[12];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tposition.y = te[13];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tposition.z = te[14];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// scale the rotation part\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmatrix.copy(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar invSX = 1 / sx;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar invSY = 1 / sy;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar invSZ = 1 / sz;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmatrix.elements[0] *= invSX;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmatrix.elements[1] *= invSX;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmatrix.elements[2] *= invSX;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmatrix.elements[4] *= invSY;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmatrix.elements[5] *= invSY;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmatrix.elements[6] *= invSY;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmatrix.elements[8] *= invSZ;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmatrix.elements[9] *= invSZ;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmatrix.elements[10] *= invSZ;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tquaternion.setFromRotationMatrix(matrix);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tscale.x = sx;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tscale.y = sy;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tscale.z = sz;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmakePerspective: function makePerspective(left, right, top, bottom, near, far) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (far === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x = 2 * near / (right - left);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar y = 2 * near / (top - bottom);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a = (right + left) / (right - left);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar b = (top + bottom) / (top - bottom);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar c = -(far + near) / (far - near);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar d = -2 * far * near / (far - near);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] = x;te[4] = 0;te[8] = a;te[12] = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[1] = 0;te[5] = y;te[9] = b;te[13] = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[2] = 0;te[6] = 0;te[10] = c;te[14] = d;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[3] = 0;te[7] = 0;te[11] = -1;te[15] = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmakeOrthographic: function makeOrthographic(left, right, top, bottom, near, far) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar w = 1.0 / (right - left);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar h = 1.0 / (top - bottom);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar p = 1.0 / (far - near);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x = (right + left) * w;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar y = (top + bottom) * h;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar z = (far + near) * p;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] = 2 * w;te[4] = 0;te[8] = 0;te[12] = -x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[1] = 0;te[5] = 2 * h;te[9] = 0;te[13] = -y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[2] = 0;te[6] = 0;te[10] = -2 * p;te[14] = -z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[3] = 0;te[7] = 0;te[11] = 0;te[15] = 1;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tequals: function equals(matrix) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar me = matrix.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < 16; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (te[i] !== me[i]) return false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfromArray: function fromArray(array, offset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (offset === undefined) offset = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < 16; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.elements[i] = array[i + offset];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttoArray: function toArray(array, offset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (array === undefined) array = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (offset === undefined) offset = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset] = te[0];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 1] = te[1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 2] = te[2];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 3] = te[3];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 4] = te[4];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 5] = te[5];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 6] = te[6];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 7] = te[7];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 8] = te[8];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 9] = te[9];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 10] = te[10];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 11] = te[11];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 12] = te[12];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 13] = te[13];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 14] = te[14];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 15] = te[15];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn array;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author mikael emtinger / http://gomo.se/\\\\r\\\\n    * @author alteredq / http://alteredqualia.com/\\\\r\\\\n    * @author WestLangley / http://github.com/WestLangley\\\\r\\\\n    * @author bhouston / http://clara.io\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\tfunction Quaternion(x, y, z, w) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = x || 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = y || 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = z || 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = w !== undefined ? w : 1;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tObject.assign(Quaternion, {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tslerp: function slerp(qa, qb, qm, t) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn qm.copy(qa).slerp(qb, t);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tslerpFlat: function slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// fuzz-free, array-based Quaternion SLERP operation\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x0 = src0[srcOffset0 + 0],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    y0 = src0[srcOffset0 + 1],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    z0 = src0[srcOffset0 + 2],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    w0 = src0[srcOffset0 + 3],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    x1 = src1[srcOffset1 + 0],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    y1 = src1[srcOffset1 + 1],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    z1 = src1[srcOffset1 + 2],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    w1 = src1[srcOffset1 + 3];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar s = 1 - t,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    dir = cos >= 0 ? 1 : -1,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    sqrSin = 1 - cos * cos;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Skip the Slerp for tiny steps to avoid numeric problems:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (sqrSin > Number.EPSILON) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar sin = Math.sqrt(sqrSin),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    len = Math.atan2(sin, cos * dir);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ts = Math.sin(s * len) / sin;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tt = Math.sin(t * len) / sin;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar tDir = t * dir;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tx0 = x0 * s + x1 * tDir;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ty0 = y0 * s + y1 * tDir;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tz0 = z0 * s + z1 * tDir;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tw0 = w0 * s + w1 * tDir;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Normalize in case we just did a lerp:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (s === 1 - t) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tx0 *= f;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ty0 *= f;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tz0 *= f;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tw0 *= f;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdst[dstOffset] = x0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdst[dstOffset + 1] = y0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdst[dstOffset + 2] = z0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdst[dstOffset + 3] = w0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\tObject.defineProperties(Quaternion.prototype, {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tx: {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tget: function get() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this._x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tset: function set(value) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = value;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.onChangeCallback();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ty: {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tget: function get() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this._y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tset: function set(value) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = value;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.onChangeCallback();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tz: {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tget: function get() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this._z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tset: function set(value) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = value;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.onChangeCallback();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tw: {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tget: function get() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this._w;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tset: function set(value) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = value;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.onChangeCallback();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\tObject.assign(Quaternion.prototype, {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tisQuaternion: true,\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tset: function set(x, y, z, w) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = w;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.onChangeCallback();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclone: function clone() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn new this.constructor(this._x, this._y, this._z, this._w);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopy: function copy(quaternion) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = quaternion.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = quaternion.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = quaternion.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = quaternion.w;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.onChangeCallback();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromEuler: function setFromEuler(euler, update) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!(euler && euler.isEuler)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthrow new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x = euler._x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    y = euler._y,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    z = euler._z,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    order = euler.order;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// http://www.mathworks.com/matlabcentral/fileexchange/\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// \\\\t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//\\\\tcontent/SpinCalc.m\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar cos = Math.cos;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar sin = Math.sin;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar c1 = cos(x / 2);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar c2 = cos(y / 2);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar c3 = cos(z / 2);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar s1 = sin(x / 2);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar s2 = sin(y / 2);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar s3 = sin(z / 2);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (order === 'XYZ') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (order === 'YXZ') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (order === 'ZXY') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (order === 'ZYX') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (order === 'YZX') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (order === 'XZY') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (update !== false) this.onChangeCallback();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromAxisAngle: function setFromAxisAngle(axis, angle) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// assumes axis is normalized\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar halfAngle = angle / 2,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    s = Math.sin(halfAngle);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = axis.x * s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = axis.y * s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = axis.z * s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = Math.cos(halfAngle);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.onChangeCallback();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromRotationMatrix: function setFromRotationMatrix(m) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = m.elements,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m11 = te[0],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m12 = te[4],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m13 = te[8],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m21 = te[1],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m22 = te[5],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m23 = te[9],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m31 = te[2],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m32 = te[6],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m33 = te[10],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    trace = m11 + m22 + m33,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    s;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (trace > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ts = 0.5 / Math.sqrt(trace + 1.0);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = 0.25 / s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = (m32 - m23) * s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = (m13 - m31) * s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = (m21 - m12) * s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (m11 > m22 && m11 > m33) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ts = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = (m32 - m23) / s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = 0.25 * s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = (m12 + m21) / s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = (m13 + m31) / s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (m22 > m33) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ts = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = (m13 - m31) / s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = (m12 + m21) / s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = 0.25 * s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = (m23 + m32) / s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ts = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = (m21 - m12) / s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = (m13 + m31) / s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = (m23 + m32) / s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = 0.25 * s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.onChangeCallback();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromUnitVectors: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// assumes direction vectors vFrom and vTo are normalized\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v1 = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar r;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar EPS = 0.000001;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function setFromUnitVectors(vFrom, vTo) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (v1 === undefined) v1 = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tr = vFrom.dot(vTo) + 1;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (r < EPS) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tr = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv1.set(-vFrom.y, vFrom.x, 0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv1.set(0, -vFrom.z, vFrom.y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv1.crossVectors(vFrom, vTo);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = v1.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = v1.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = v1.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = r;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.normalize();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tangleTo: function angleTo(q) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn 2 * Math.acos(Math.abs(_Math.clamp(this.dot(q), -1, 1)));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\trotateTowards: function rotateTowards(q, step) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar angle = this.angleTo(q);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (angle === 0) return this;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar t = Math.min(1, step / angle);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.slerp(q, t);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tinverse: function inverse() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// quaternion is assumed to have unit length\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.conjugate();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconjugate: function conjugate() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x *= -1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y *= -1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z *= -1;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.onChangeCallback();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdot: function dot(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlengthSq: function lengthSq() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlength: function length() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormalize: function normalize() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar l = this.length();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (l === 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = 1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tl = 1 / l;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = this._x * l;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = this._y * l;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = this._z * l;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = this._w * l;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.onChangeCallback();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmultiply: function multiply(q, p) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (p !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.multiplyQuaternions(q, p);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.multiplyQuaternions(this, q);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpremultiply: function premultiply(q) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.multiplyQuaternions(q, this);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmultiplyQuaternions: function multiplyQuaternions(a, b) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar qax = a._x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    qay = a._y,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    qaz = a._z,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    qaw = a._w;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar qbx = b._x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    qby = b._y,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    qbz = b._z,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    qbw = b._w;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.onChangeCallback();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tslerp: function slerp(qb, t) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (t === 0) return this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (t === 1) return this.copy(qb);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x = this._x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    y = this._y,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    z = this._z,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    w = this._w;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (cosHalfTheta < 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = -qb._w;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = -qb._x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = -qb._y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = -qb._z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcosHalfTheta = -cosHalfTheta;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.copy(qb);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (cosHalfTheta >= 1.0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = w;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (sqrSinHalfTheta <= Number.EPSILON) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar s = 1 - t;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = s * w + t * this._w;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = s * x + t * this._x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = s * y + t * this._y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = s * z + t * this._z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.normalize();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = w * ratioA + this._w * ratioB;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = x * ratioA + this._x * ratioB;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = y * ratioA + this._y * ratioB;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = z * ratioA + this._z * ratioB;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.onChangeCallback();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tequals: function equals(quaternion) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfromArray: function fromArray(array, offset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (offset === undefined) offset = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = array[offset];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = array[offset + 1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = array[offset + 2];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._w = array[offset + 3];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.onChangeCallback();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttoArray: function toArray(array, offset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (array === undefined) array = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (offset === undefined) offset = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset] = this._x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 1] = this._y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 2] = this._z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 3] = this._w;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn array;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tonChange: function onChange(callback) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.onChangeCallback = callback;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tonChangeCallback: function onChangeCallback() {}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author mrdoob / http://mrdoob.com/\\\\r\\\\n    * @author kile / http://kile.stravaganza.org/\\\\r\\\\n    * @author philogb / http://blog.thejit.org/\\\\r\\\\n    * @author mikael emtinger / http://gomo.se/\\\\r\\\\n    * @author egraether / http://egraether.com/\\\\r\\\\n    * @author WestLangley / http://github.com/WestLangley\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\tfunction Vector3(x, y, z) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = x || 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = y || 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = z || 0;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tObject.assign(Vector3.prototype, {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tisVector3: true,\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tset: function set(x, y, z) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetScalar: function setScalar(scalar) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = scalar;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = scalar;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = scalar;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetX: function setX(x) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = x;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetY: function setY(y) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetZ: function setZ(z) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetComponent: function setComponent(index, value) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tswitch (index) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase 0:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = value;break;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase 1:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = value;break;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase 2:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = value;break;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdefault:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthrow new Error('index is out of range: ' + index);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetComponent: function getComponent(index) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tswitch (index) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase 0:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase 1:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase 2:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdefault:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthrow new Error('index is out of range: ' + index);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclone: function clone() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn new this.constructor(this.x, this.y, this.z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopy: function copy(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = v.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = v.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = v.z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tadd: function add(v, w) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (w !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.addVectors(v, w);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x += v.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y += v.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z += v.z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddScalar: function addScalar(s) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x += s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y += s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z += s;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddVectors: function addVectors(a, b) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = a.x + b.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = a.y + b.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = a.z + b.z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddScaledVector: function addScaledVector(v, s) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x += v.x * s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y += v.y * s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z += v.z * s;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsub: function sub(v, w) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (w !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.subVectors(v, w);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x -= v.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y -= v.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z -= v.z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsubScalar: function subScalar(s) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x -= s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y -= s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z -= s;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsubVectors: function subVectors(a, b) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = a.x - b.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = a.y - b.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = a.z - b.z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmultiply: function multiply(v, w) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (w !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.multiplyVectors(v, w);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x *= v.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y *= v.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z *= v.z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmultiplyScalar: function multiplyScalar(scalar) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x *= scalar;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y *= scalar;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z *= scalar;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmultiplyVectors: function multiplyVectors(a, b) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = a.x * b.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = a.y * b.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = a.z * b.z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tapplyEuler: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar quaternion = new Quaternion();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function applyEuler(euler) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!(euler && euler.isEuler)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.applyQuaternion(quaternion.setFromEuler(euler));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tapplyAxisAngle: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar quaternion = new Quaternion();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function applyAxisAngle(axis, angle) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tapplyMatrix3: function applyMatrix3(m) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x = this.x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    y = this.y,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    z = this.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar e = m.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = e[0] * x + e[3] * y + e[6] * z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = e[1] * x + e[4] * y + e[7] * z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = e[2] * x + e[5] * y + e[8] * z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tapplyMatrix4: function applyMatrix4(m) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x = this.x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    y = this.y,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    z = this.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar e = m.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tapplyQuaternion: function applyQuaternion(q) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x = this.x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    y = this.y,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    z = this.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar qx = q.x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    qy = q.y,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    qz = q.z,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    qw = q.w;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// calculate quat * vector\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar ix = qw * x + qy * z - qz * y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar iy = qw * y + qz * x - qx * z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar iz = qw * z + qx * y - qy * x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar iw = -qx * x - qy * y - qz * z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// calculate result * inverse quat\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tproject: function project(camera) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tunproject: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar matrix = new Matrix4();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function unproject(camera) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.applyMatrix4(matrix.getInverse(camera.projectionMatrix)).applyMatrix4(camera.matrixWorld);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttransformDirection: function transformDirection(m) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// input: THREE.Matrix4 affine matrix\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// vector interpreted as a direction\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x = this.x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    y = this.y,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    z = this.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar e = m.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = e[0] * x + e[4] * y + e[8] * z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = e[1] * x + e[5] * y + e[9] * z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = e[2] * x + e[6] * y + e[10] * z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.normalize();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdivide: function divide(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x /= v.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y /= v.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z /= v.z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdivideScalar: function divideScalar(scalar) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.multiplyScalar(1 / scalar);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmin: function min(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = Math.min(this.x, v.x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = Math.min(this.y, v.y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = Math.min(this.z, v.z);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmax: function max(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = Math.max(this.x, v.x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = Math.max(this.y, v.y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = Math.max(this.z, v.z);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclamp: function clamp(min, max) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// assumes min < max, componentwise\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = Math.max(min.z, Math.min(max.z, this.z));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclampScalar: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar min = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar max = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function clampScalar(minVal, maxVal) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmin.set(minVal, minVal, minVal);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmax.set(maxVal, maxVal, maxVal);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.clamp(min, max);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclampLength: function clampLength(min, max) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar length = this.length();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfloor: function floor() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = Math.floor(this.x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = Math.floor(this.y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = Math.floor(this.z);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tceil: function ceil() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = Math.ceil(this.x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = Math.ceil(this.y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = Math.ceil(this.z);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tround: function round() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = Math.round(this.x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = Math.round(this.y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = Math.round(this.z);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\troundToZero: function roundToZero() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnegate: function negate() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = -this.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = -this.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = -this.z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdot: function dot(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.x * v.x + this.y * v.y + this.z * v.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// TODO lengthSquared?\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlengthSq: function lengthSq() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.x * this.x + this.y * this.y + this.z * this.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlength: function length() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmanhattanLength: function manhattanLength() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormalize: function normalize() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.divideScalar(this.length() || 1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetLength: function setLength(length) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.normalize().multiplyScalar(length);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlerp: function lerp(v, alpha) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x += (v.x - this.x) * alpha;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y += (v.y - this.y) * alpha;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z += (v.z - this.z) * alpha;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlerpVectors: function lerpVectors(v1, v2, alpha) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcross: function cross(v, w) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (w !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.crossVectors(v, w);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.crossVectors(this, v);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcrossVectors: function crossVectors(a, b) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar ax = a.x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    ay = a.y,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    az = a.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar bx = b.x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    by = b.y,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    bz = b.z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = ay * bz - az * by;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = az * bx - ax * bz;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = ax * by - ay * bx;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tprojectOnVector: function projectOnVector(vector) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar scalar = vector.dot(this) / vector.lengthSq();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.copy(vector).multiplyScalar(scalar);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tprojectOnPlane: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v1 = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function projectOnPlane(planeNormal) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv1.copy(this).projectOnVector(planeNormal);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.sub(v1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treflect: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// reflect incident vector off plane orthogonal to normal\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// normal is assumed to have unit length\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v1 = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function reflect(normal) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tangleTo: function angleTo(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// clamp, to handle numerical problems\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn Math.acos(_Math.clamp(theta, -1, 1));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdistanceTo: function distanceTo(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn Math.sqrt(this.distanceToSquared(v));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdistanceToSquared: function distanceToSquared(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar dx = this.x - v.x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    dy = this.y - v.y,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    dz = this.z - v.z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn dx * dx + dy * dy + dz * dz;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmanhattanDistanceTo: function manhattanDistanceTo(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromSpherical: function setFromSpherical(s) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.setFromSphericalCoords(s.radius, s.phi, s.theta);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromSphericalCoords: function setFromSphericalCoords(radius, phi, theta) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar sinPhiRadius = Math.sin(phi) * radius;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = sinPhiRadius * Math.sin(theta);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = Math.cos(phi) * radius;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = sinPhiRadius * Math.cos(theta);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromCylindrical: function setFromCylindrical(c) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.setFromCylindricalCoords(c.radius, c.theta, c.y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromCylindricalCoords: function setFromCylindricalCoords(radius, theta, y) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = radius * Math.sin(theta);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = radius * Math.cos(theta);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromMatrixPosition: function setFromMatrixPosition(m) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar e = m.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = e[12];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = e[13];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = e[14];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromMatrixScale: function setFromMatrixScale(m) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar sx = this.setFromMatrixColumn(m, 0).length();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar sy = this.setFromMatrixColumn(m, 1).length();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar sz = this.setFromMatrixColumn(m, 2).length();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = sx;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = sy;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = sz;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromMatrixColumn: function setFromMatrixColumn(m, index) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.fromArray(m.elements, index * 4);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tequals: function equals(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn v.x === this.x && v.y === this.y && v.z === this.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfromArray: function fromArray(array, offset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (offset === undefined) offset = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = array[offset];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = array[offset + 1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = array[offset + 2];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttoArray: function toArray(array, offset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (array === undefined) array = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (offset === undefined) offset = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset] = this.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 1] = this.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 2] = this.z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn array;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfromBufferAttribute: function fromBufferAttribute(attribute, index, offset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (offset !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = attribute.getX(index);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = attribute.getY(index);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = attribute.getZ(index);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author mrdoob / http://mrdoob.com/\\\\r\\\\n    * @author alteredq / http://alteredqualia.com/\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\tfunction Face3(a, b, c, normal, color, materialIndex) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.a = a;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.b = b;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.c = c;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.normal = normal && normal.isVector3 ? normal : new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.vertexNormals = Array.isArray(normal) ? normal : [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.color = color && color.isColor ? color : new Color();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.vertexColors = Array.isArray(color) ? color : [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tObject.assign(Face3.prototype, {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclone: function clone() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn new this.constructor().copy(this);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopy: function copy(source) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.a = source.a;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.b = source.b;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.c = source.c;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.normal.copy(source.normal);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.color.copy(source.color);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.materialIndex = source.materialIndex;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, il = source.vertexNormals.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.vertexNormals[i] = source.vertexNormals[i].clone();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, il = source.vertexColors.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.vertexColors[i] = source.vertexColors[i].clone();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author alteredq / http://alteredqualia.com/\\\\r\\\\n    * @author WestLangley / http://github.com/WestLangley\\\\r\\\\n    * @author bhouston / http://clara.io\\\\r\\\\n    * @author tschw\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\tfunction Matrix3() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (arguments.length > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tObject.assign(Matrix3.prototype, {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tisMatrix3: true,\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tset: function set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] = n11;te[1] = n21;te[2] = n31;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[3] = n12;te[4] = n22;te[5] = n32;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[6] = n13;te[7] = n23;te[8] = n33;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tidentity: function identity() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.set(1, 0, 0, 0, 1, 0, 0, 0, 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclone: function clone() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn new this.constructor().fromArray(this.elements);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopy: function copy(m) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar me = m.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] = me[0];te[1] = me[1];te[2] = me[2];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[3] = me[3];te[4] = me[4];te[5] = me[5];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[6] = me[6];te[7] = me[7];te[8] = me[8];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromMatrix4: function setFromMatrix4(m) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar me = m.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tapplyToBufferAttribute: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v1 = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function applyToBufferAttribute(attribute) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = attribute.count; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv1.x = attribute.getX(i);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv1.y = attribute.getY(i);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv1.z = attribute.getZ(i);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv1.applyMatrix3(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tattribute.setXYZ(i, v1.x, v1.y, v1.z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn attribute;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmultiply: function multiply(m) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.multiplyMatrices(this, m);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpremultiply: function premultiply(m) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.multiplyMatrices(m, this);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmultiplyMatrices: function multiplyMatrices(a, b) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar ae = a.elements;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar be = b.elements;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a11 = ae[0],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    a12 = ae[3],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    a13 = ae[6];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a21 = ae[1],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    a22 = ae[4],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    a23 = ae[7];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a31 = ae[2],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    a32 = ae[5],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    a33 = ae[8];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar b11 = be[0],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b12 = be[3],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b13 = be[6];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar b21 = be[1],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b22 = be[4],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b23 = be[7];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar b31 = be[2],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b32 = be[5],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b33 = be[8];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] = a11 * b11 + a12 * b21 + a13 * b31;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[3] = a11 * b12 + a12 * b22 + a13 * b32;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[6] = a11 * b13 + a12 * b23 + a13 * b33;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[1] = a21 * b11 + a22 * b21 + a23 * b31;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[4] = a21 * b12 + a22 * b22 + a23 * b32;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[7] = a21 * b13 + a22 * b23 + a23 * b33;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[2] = a31 * b11 + a32 * b21 + a33 * b31;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[5] = a31 * b12 + a32 * b22 + a33 * b32;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[8] = a31 * b13 + a32 * b23 + a33 * b33;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmultiplyScalar: function multiplyScalar(s) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] *= s;te[3] *= s;te[6] *= s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[1] *= s;te[4] *= s;te[7] *= s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[2] *= s;te[5] *= s;te[8] *= s;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdeterminant: function determinant() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a = te[0],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b = te[1],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    c = te[2],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    d = te[3],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    e = te[4],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    f = te[5],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    g = te[6],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    h = te[7],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    i = te[8];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetInverse: function getInverse(matrix, throwOnDegenerate) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (matrix && matrix.isMatrix4) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.error('THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar me = matrix.elements,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    te = this.elements,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n11 = me[0],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n21 = me[1],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n31 = me[2],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n12 = me[3],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n22 = me[4],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n32 = me[5],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n13 = me[6],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n23 = me[7],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    n33 = me[8],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    t11 = n33 * n22 - n32 * n23,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    t12 = n32 * n13 - n33 * n12,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    t13 = n23 * n12 - n22 * n13,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    det = n11 * t11 + n21 * t12 + n31 * t13;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (det === 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar msg = 'THREE.Matrix3: .getInverse() can\\\\\\\\'t invert matrix, determinant is 0';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (throwOnDegenerate === true) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthrow new Error(msg);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn(msg);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.identity();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar detInv = 1 / det;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] = t11 * detInv;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[1] = (n31 * n23 - n33 * n21) * detInv;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[2] = (n32 * n21 - n31 * n22) * detInv;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[3] = t12 * detInv;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[4] = (n33 * n11 - n31 * n13) * detInv;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[5] = (n31 * n12 - n32 * n11) * detInv;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[6] = t13 * detInv;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[7] = (n21 * n13 - n23 * n11) * detInv;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[8] = (n22 * n11 - n21 * n12) * detInv;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttranspose: function transpose() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar tmp,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m = this.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttmp = m[1];m[1] = m[3];m[3] = tmp;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttmp = m[2];m[2] = m[6];m[6] = tmp;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttmp = m[5];m[5] = m[7];m[7] = tmp;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetNormalMatrix: function getNormalMatrix(matrix4) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.setFromMatrix4(matrix4).getInverse(this).transpose();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttransposeIntoArray: function transposeIntoArray(r) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar m = this.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tr[0] = m[0];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tr[1] = m[3];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tr[2] = m[6];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tr[3] = m[1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tr[4] = m[4];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tr[5] = m[7];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tr[6] = m[2];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tr[7] = m[5];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tr[8] = m[8];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetUvTransform: function setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar c = Math.cos(rotation);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar s = Math.sin(rotation);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tscale: function scale(sx, sy) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] *= sx;te[3] *= sx;te[6] *= sx;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[1] *= sy;te[4] *= sy;te[7] *= sy;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\trotate: function rotate(theta) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar c = Math.cos(theta);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar s = Math.sin(theta);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a11 = te[0],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    a12 = te[3],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    a13 = te[6];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a21 = te[1],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    a22 = te[4],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    a23 = te[7];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] = c * a11 + s * a21;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[3] = c * a12 + s * a22;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[6] = c * a13 + s * a23;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[1] = -s * a11 + c * a21;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[4] = -s * a12 + c * a22;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[7] = -s * a13 + c * a23;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttranslate: function translate(tx, ty) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[0] += tx * te[2];te[3] += tx * te[5];te[6] += tx * te[8];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte[1] += ty * te[2];te[4] += ty * te[5];te[7] += ty * te[8];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tequals: function equals(matrix) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar me = matrix.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < 9; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (te[i] !== me[i]) return false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfromArray: function fromArray(array, offset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (offset === undefined) offset = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < 9; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.elements[i] = array[i + offset];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttoArray: function toArray(array, offset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (array === undefined) array = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (offset === undefined) offset = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = this.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset] = te[0];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 1] = te[1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 2] = te[2];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 3] = te[3];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 4] = te[4];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 5] = te[5];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 6] = te[6];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 7] = te[7];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 8] = te[8];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn array;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author bhouston / http://clara.io\\\\r\\\\n    * @author WestLangley / http://github.com/WestLangley\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\tfunction Box3(min, max) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.min = min !== undefined ? min : new Vector3(+Infinity, +Infinity, +Infinity);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.max = max !== undefined ? max : new Vector3(-Infinity, -Infinity, -Infinity);\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tObject.assign(Box3.prototype, {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tisBox3: true,\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tset: function set(min, max) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.min.copy(min);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.max.copy(max);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromArray: function setFromArray(array) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar minX = +Infinity;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar minY = +Infinity;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar minZ = +Infinity;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar maxX = -Infinity;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar maxY = -Infinity;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar maxZ = -Infinity;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = array.length; i < l; i += 3) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x = array[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar y = array[i + 1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar z = array[i + 2];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (x < minX) minX = x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (y < minY) minY = y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (z < minZ) minZ = z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (x > maxX) maxX = x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (y > maxY) maxY = y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (z > maxZ) maxZ = z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.min.set(minX, minY, minZ);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.max.set(maxX, maxY, maxZ);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromBufferAttribute: function setFromBufferAttribute(attribute) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar minX = +Infinity;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar minY = +Infinity;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar minZ = +Infinity;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar maxX = -Infinity;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar maxY = -Infinity;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar maxZ = -Infinity;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = attribute.count; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x = attribute.getX(i);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar y = attribute.getY(i);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar z = attribute.getZ(i);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (x < minX) minX = x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (y < minY) minY = y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (z < minZ) minZ = z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (x > maxX) maxX = x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (y > maxY) maxY = y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (z > maxZ) maxZ = z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.min.set(minX, minY, minZ);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.max.set(maxX, maxY, maxZ);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromPoints: function setFromPoints(points) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.makeEmpty();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, il = points.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.expandByPoint(points[i]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromCenterAndSize: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v1 = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function setFromCenterAndSize(center, size) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar halfSize = v1.copy(size).multiplyScalar(0.5);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.min.copy(center).sub(halfSize);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.max.copy(center).add(halfSize);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromObject: function setFromObject(object) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.makeEmpty();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.expandByObject(object);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclone: function clone() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn new this.constructor().copy(this);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopy: function copy(box) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.min.copy(box.min);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.max.copy(box.max);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmakeEmpty: function makeEmpty() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.min.x = this.min.y = this.min.z = +Infinity;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.max.x = this.max.y = this.max.z = -Infinity;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tisEmpty: function isEmpty() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetCenter: function getCenter(target) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (target === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Box3: .getCenter() target is now required');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttarget = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetSize: function getSize(target) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (target === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Box3: .getSize() target is now required');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttarget = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\texpandByPoint: function expandByPoint(point) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.min.min(point);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.max.max(point);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\texpandByVector: function expandByVector(vector) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.min.sub(vector);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.max.add(vector);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\texpandByScalar: function expandByScalar(scalar) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.min.addScalar(-scalar);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.max.addScalar(scalar);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\texpandByObject: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Computes the world-axis-aligned bounding box of an object (including its children),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// accounting for both the object's, and children's, world transforms\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar scope, i, l;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v1 = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction traverse(node) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar geometry = node.geometry;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry.isGeometry) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vertices = geometry.vertices;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, l = vertices.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv1.copy(vertices[i]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv1.applyMatrix4(node.matrixWorld);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tscope.expandByPoint(v1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (geometry.isBufferGeometry) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar attribute = geometry.attributes.position;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (attribute !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, l = attribute.count; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tscope.expandByPoint(v1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function expandByObject(object) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tscope = this;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tobject.updateMatrixWorld(true);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tobject.traverse(traverse);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcontainsPoint: function containsPoint(point) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcontainsBox: function containsBox(box) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetParameter: function getParameter(point, target) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// This can potentially have a divide by zero if the box\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// has a size dimension of 0.\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (target === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Box3: .getParameter() target is now required');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttarget = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tintersectsBox: function intersectsBox(box) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// using 6 splitting planes to rule out intersections.\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tintersectsSphere: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar closestPoint = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function intersectsSphere(sphere) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Find the point on the AABB closest to the sphere center.\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.clampPoint(sphere.center, closestPoint);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// If that point is inside the sphere, the AABB and sphere intersect.\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tintersectsPlane: function intersectsPlane(plane) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// We compute the minimum and maximum dot product values. If those values\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// are on the same side (back or front) of the plane, then there is no intersection.\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar min, max;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (plane.normal.x > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmin = plane.normal.x * this.min.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmax = plane.normal.x * this.max.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmin = plane.normal.x * this.max.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmax = plane.normal.x * this.min.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (plane.normal.y > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmin += plane.normal.y * this.min.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmax += plane.normal.y * this.max.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmin += plane.normal.y * this.max.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmax += plane.normal.y * this.min.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (plane.normal.z > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmin += plane.normal.z * this.min.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmax += plane.normal.z * this.max.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmin += plane.normal.z * this.max.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmax += plane.normal.z * this.min.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn min <= -plane.constant && max >= -plane.constant;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tintersectsTriangle: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// triangle centered vertices\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v0 = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v1 = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v2 = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// triangle edge vectors\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar f0 = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar f1 = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar f2 = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar testAxis = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar center = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar extents = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar triangleNormal = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction satForAxes(axes) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar i, j;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, j = axes.length - 3; i <= j; i += 3) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttestAxis.fromArray(axes, i);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// project the aabb onto the seperating axis\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar r = extents.x * Math.abs(testAxis.x) + extents.y * Math.abs(testAxis.y) + extents.z * Math.abs(testAxis.z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// project all 3 vertices of the triangle onto the seperating axis\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar p0 = v0.dot(testAxis);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar p1 = v1.dot(testAxis);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar p2 = v2.dot(testAxis);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// actual test, basically see if either of the most extreme of the triangle points intersects r\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// points of the projected triangle are outside the projected half-length of the aabb\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// the axis is seperating and we can exit\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function intersectsTriangle(triangle) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.isEmpty()) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// compute box center and extents\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.getCenter(center);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\textents.subVectors(this.max, center);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// translate triangle to aabb origin\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv0.subVectors(triangle.a, center);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv1.subVectors(triangle.b, center);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv2.subVectors(triangle.c, center);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// compute edge vectors for triangle\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tf0.subVectors(v1, v0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tf1.subVectors(v2, v1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tf2.subVectors(v0, v2);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar axes = [0, -f0.z, f0.y, 0, -f1.z, f1.y, 0, -f2.z, f2.y, f0.z, 0, -f0.x, f1.z, 0, -f1.x, f2.z, 0, -f2.x, -f0.y, f0.x, 0, -f1.y, f1.x, 0, -f2.y, f2.x, 0];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!satForAxes(axes)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// test 3 face normals from the aabb\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taxes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!satForAxes(axes)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// finally testing the face normal of the triangle\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// use already existing triangle edge vectors here\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttriangleNormal.crossVectors(f0, f1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taxes = [triangleNormal.x, triangleNormal.y, triangleNormal.z];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn satForAxes(axes);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclampPoint: function clampPoint(point, target) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (target === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Box3: .clampPoint() target is now required');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttarget = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn target.copy(point).clamp(this.min, this.max);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdistanceToPoint: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v1 = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function distanceToPoint(point) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar clampedPoint = v1.copy(point).clamp(this.min, this.max);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn clampedPoint.sub(point).length();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetBoundingSphere: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v1 = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function getBoundingSphere(target) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (target === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Box3: .getBoundingSphere() target is now required');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttarget = new Sphere();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.getCenter(target.center);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttarget.radius = this.getSize(v1).length() * 0.5;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn target;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tintersect: function intersect(box) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.min.max(box.min);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.max.min(box.max);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.isEmpty()) this.makeEmpty();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tunion: function union(box) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.min.min(box.min);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.max.max(box.max);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tapplyMatrix4: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar points = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function applyMatrix4(matrix) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// transform of empty box is an empty box.\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.isEmpty()) return this;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoints[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoints[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoints[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoints[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoints[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoints[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoints[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoints[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.setFromPoints(points);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttranslate: function translate(offset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.min.add(offset);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.max.add(offset);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tequals: function equals(box) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn box.min.equals(this.min) && box.max.equals(this.max);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author bhouston / http://clara.io\\\\r\\\\n    * @author mrdoob / http://mrdoob.com/\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\tfunction Sphere(center, radius) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.center = center !== undefined ? center : new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.radius = radius !== undefined ? radius : 0;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tObject.assign(Sphere.prototype, {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tset: function set(center, radius) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.center.copy(center);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.radius = radius;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromPoints: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar box = new Box3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function setFromPoints(points, optionalCenter) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar center = this.center;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (optionalCenter !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcenter.copy(optionalCenter);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbox.setFromPoints(points).getCenter(center);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar maxRadiusSq = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, il = points.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmaxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.radius = Math.sqrt(maxRadiusSq);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclone: function clone() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn new this.constructor().copy(this);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopy: function copy(sphere) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.center.copy(sphere.center);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.radius = sphere.radius;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tempty: function empty() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.radius <= 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcontainsPoint: function containsPoint(point) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn point.distanceToSquared(this.center) <= this.radius * this.radius;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdistanceToPoint: function distanceToPoint(point) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn point.distanceTo(this.center) - this.radius;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tintersectsSphere: function intersectsSphere(sphere) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar radiusSum = this.radius + sphere.radius;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tintersectsBox: function intersectsBox(box) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn box.intersectsSphere(this);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tintersectsPlane: function intersectsPlane(plane) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclampPoint: function clampPoint(point, target) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar deltaLengthSq = this.center.distanceToSquared(point);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (target === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Sphere: .clampPoint() target is now required');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttarget = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttarget.copy(point);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (deltaLengthSq > this.radius * this.radius) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttarget.sub(this.center).normalize();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttarget.multiplyScalar(this.radius).add(this.center);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn target;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetBoundingBox: function getBoundingBox(target) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (target === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Sphere: .getBoundingBox() target is now required');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttarget = new Box3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttarget.set(this.center, this.center);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttarget.expandByScalar(this.radius);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn target;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tapplyMatrix4: function applyMatrix4(matrix) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.center.applyMatrix4(matrix);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttranslate: function translate(offset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.center.add(offset);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tequals: function equals(sphere) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn sphere.center.equals(this.center) && sphere.radius === this.radius;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author mrdoob / http://mrdoob.com/\\\\r\\\\n    * @author philogb / http://blog.thejit.org/\\\\r\\\\n    * @author egraether / http://egraether.com/\\\\r\\\\n    * @author zz85 / http://www.lab4games.net/zz85/blog\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\tfunction Vector2(x, y) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = x || 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = y || 0;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tObject.defineProperties(Vector2.prototype, {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'width': {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tget: function get() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tset: function set(value) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = value;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t'height': {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tget: function get() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tset: function set(value) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = value;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\tObject.assign(Vector2.prototype, {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tisVector2: true,\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tset: function set(x, y) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetScalar: function setScalar(scalar) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = scalar;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = scalar;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetX: function setX(x) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = x;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetY: function setY(y) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetComponent: function setComponent(index, value) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tswitch (index) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase 0:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = value;break;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase 1:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = value;break;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdefault:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthrow new Error('index is out of range: ' + index);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetComponent: function getComponent(index) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tswitch (index) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase 0:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase 1:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdefault:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthrow new Error('index is out of range: ' + index);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclone: function clone() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn new this.constructor(this.x, this.y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopy: function copy(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = v.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = v.y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tadd: function add(v, w) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (w !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.addVectors(v, w);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x += v.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y += v.y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddScalar: function addScalar(s) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x += s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y += s;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddVectors: function addVectors(a, b) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = a.x + b.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = a.y + b.y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddScaledVector: function addScaledVector(v, s) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x += v.x * s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y += v.y * s;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsub: function sub(v, w) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (w !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.subVectors(v, w);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x -= v.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y -= v.y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsubScalar: function subScalar(s) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x -= s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y -= s;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsubVectors: function subVectors(a, b) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = a.x - b.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = a.y - b.y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmultiply: function multiply(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x *= v.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y *= v.y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmultiplyScalar: function multiplyScalar(scalar) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x *= scalar;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y *= scalar;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdivide: function divide(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x /= v.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y /= v.y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdivideScalar: function divideScalar(scalar) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.multiplyScalar(1 / scalar);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tapplyMatrix3: function applyMatrix3(m) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x = this.x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    y = this.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar e = m.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = e[0] * x + e[3] * y + e[6];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = e[1] * x + e[4] * y + e[7];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmin: function min(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = Math.min(this.x, v.x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = Math.min(this.y, v.y);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmax: function max(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = Math.max(this.x, v.x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = Math.max(this.y, v.y);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclamp: function clamp(min, max) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// assumes min < max, componentwise\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclampScalar: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar min = new Vector2();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar max = new Vector2();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function clampScalar(minVal, maxVal) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmin.set(minVal, minVal);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmax.set(maxVal, maxVal);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.clamp(min, max);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclampLength: function clampLength(min, max) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar length = this.length();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfloor: function floor() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = Math.floor(this.x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = Math.floor(this.y);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tceil: function ceil() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = Math.ceil(this.x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = Math.ceil(this.y);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tround: function round() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = Math.round(this.x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = Math.round(this.y);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\troundToZero: function roundToZero() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnegate: function negate() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = -this.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = -this.y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdot: function dot(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.x * v.x + this.y * v.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcross: function cross(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.x * v.y - this.y * v.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlengthSq: function lengthSq() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.x * this.x + this.y * this.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlength: function length() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn Math.sqrt(this.x * this.x + this.y * this.y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmanhattanLength: function manhattanLength() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn Math.abs(this.x) + Math.abs(this.y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormalize: function normalize() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.divideScalar(this.length() || 1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tangle: function angle() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// computes the angle in radians with respect to the positive x-axis\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar angle = Math.atan2(this.y, this.x);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (angle < 0) angle += 2 * Math.PI;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn angle;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdistanceTo: function distanceTo(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn Math.sqrt(this.distanceToSquared(v));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdistanceToSquared: function distanceToSquared(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar dx = this.x - v.x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    dy = this.y - v.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn dx * dx + dy * dy;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmanhattanDistanceTo: function manhattanDistanceTo(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetLength: function setLength(length) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.normalize().multiplyScalar(length);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlerp: function lerp(v, alpha) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x += (v.x - this.x) * alpha;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y += (v.y - this.y) * alpha;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlerpVectors: function lerpVectors(v1, v2, alpha) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tequals: function equals(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn v.x === this.x && v.y === this.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfromArray: function fromArray(array, offset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (offset === undefined) offset = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = array[offset];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = array[offset + 1];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttoArray: function toArray(array, offset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (array === undefined) array = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (offset === undefined) offset = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset] = this.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 1] = this.y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn array;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfromBufferAttribute: function fromBufferAttribute(attribute, index, offset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (offset !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = attribute.getX(index);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = attribute.getY(index);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\trotateAround: function rotateAround(center, angle) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar c = Math.cos(angle),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    s = Math.sin(angle);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x = this.x - center.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar y = this.y - center.y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = x * c - y * s + center.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = x * s + y * c + center.y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author mrdoob / http://mrdoob.com/\\\\r\\\\n    * @author WestLangley / http://github.com/WestLangley\\\\r\\\\n    * @author bhouston / http://clara.io\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\tfunction Euler(x, y, z, order) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = x || 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = y || 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = z || 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._order = order || Euler.DefaultOrder;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tEuler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];\\\\n\\\\n\\\\t\\\\t\\\\tEuler.DefaultOrder = 'XYZ';\\\\n\\\\n\\\\t\\\\t\\\\tObject.defineProperties(Euler.prototype, {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tx: {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tget: function get() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this._x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tset: function set(value) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = value;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.onChangeCallback();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ty: {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tget: function get() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this._y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tset: function set(value) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = value;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.onChangeCallback();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tz: {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tget: function get() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this._z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tset: function set(value) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = value;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.onChangeCallback();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\torder: {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tget: function get() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this._order;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tset: function set(value) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._order = value;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.onChangeCallback();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\tObject.assign(Euler.prototype, {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tisEuler: true,\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tset: function set(x, y, z, order) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._order = order || this._order;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.onChangeCallback();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclone: function clone() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn new this.constructor(this._x, this._y, this._z, this._order);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopy: function copy(euler) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = euler._x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = euler._y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = euler._z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._order = euler._order;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.onChangeCallback();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromRotationMatrix: function setFromRotationMatrix(m, order, update) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar clamp = _Math.clamp;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar te = m.elements;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar m11 = te[0],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m12 = te[4],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m13 = te[8];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar m21 = te[1],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m22 = te[5],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m23 = te[9];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar m31 = te[2],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m32 = te[6],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m33 = te[10];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\torder = order || this._order;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (order === 'XYZ') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = Math.asin(clamp(m13, -1, 1));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Math.abs(m13) < 0.99999) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = Math.atan2(-m23, m33);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = Math.atan2(-m12, m11);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = Math.atan2(m32, m22);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (order === 'YXZ') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = Math.asin(-clamp(m23, -1, 1));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Math.abs(m23) < 0.99999) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = Math.atan2(m13, m33);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = Math.atan2(m21, m22);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = Math.atan2(-m31, m11);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (order === 'ZXY') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = Math.asin(clamp(m32, -1, 1));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Math.abs(m32) < 0.99999) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = Math.atan2(-m31, m33);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = Math.atan2(-m12, m22);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = Math.atan2(m21, m11);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (order === 'ZYX') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = Math.asin(-clamp(m31, -1, 1));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Math.abs(m31) < 0.99999) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = Math.atan2(m32, m33);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = Math.atan2(m21, m11);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = Math.atan2(-m12, m22);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (order === 'YZX') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = Math.asin(clamp(m21, -1, 1));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Math.abs(m21) < 0.99999) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = Math.atan2(-m23, m22);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = Math.atan2(-m31, m11);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = Math.atan2(m13, m33);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (order === 'XZY') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = Math.asin(-clamp(m12, -1, 1));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Math.abs(m12) < 0.99999) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = Math.atan2(m32, m22);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = Math.atan2(m13, m11);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = Math.atan2(-m23, m33);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._order = order;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (update !== false) this.onChangeCallback();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromQuaternion: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar matrix = new Matrix4();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function setFromQuaternion(q, order, update) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmatrix.makeRotationFromQuaternion(q);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.setFromRotationMatrix(matrix, order, update);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromVector3: function setFromVector3(v, order) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.set(v.x, v.y, v.z, order || this._order);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treorder: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// WARNING: this discards revolution information -bhouston\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar q = new Quaternion();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function reorder(newOrder) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tq.setFromEuler(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.setFromQuaternion(q, newOrder);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tequals: function equals(euler) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfromArray: function fromArray(array) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._x = array[0];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._y = array[1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis._z = array[2];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (array[3] !== undefined) this._order = array[3];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.onChangeCallback();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttoArray: function toArray(array, offset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (array === undefined) array = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (offset === undefined) offset = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset] = this._x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 1] = this._y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 2] = this._z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 3] = this._order;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn array;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttoVector3: function toVector3(optionalResult) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (optionalResult) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn optionalResult.set(this._x, this._y, this._z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn new Vector3(this._x, this._y, this._z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tonChange: function onChange(callback) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.onChangeCallback = callback;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tonChangeCallback: function onChangeCallback() {}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author mrdoob / http://mrdoob.com/\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\tfunction Layers() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.mask = 1 | 0;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tObject.assign(Layers.prototype, {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tset: function set(channel) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.mask = 1 << channel | 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tenable: function enable(channel) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.mask |= 1 << channel | 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttoggle: function toggle(channel) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.mask ^= 1 << channel | 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdisable: function disable(channel) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.mask &= ~(1 << channel | 0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttest: function test(layers) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn (this.mask & layers.mask) !== 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\tvar TrianglesDrawMode = 0;\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author mrdoob / http://mrdoob.com/\\\\r\\\\n    * @author mikael emtinger / http://gomo.se/\\\\r\\\\n    * @author alteredq / http://alteredqualia.com/\\\\r\\\\n    * @author WestLangley / http://github.com/WestLangley\\\\r\\\\n    * @author elephantatwork / www.elephantatwork.ch\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\tvar object3DId = 0;\\\\n\\\\n\\\\t\\\\t\\\\tfunction Object3D() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tObject.defineProperty(this, 'id', { value: object3DId++ });\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.uuid = _Math.generateUUID();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.name = '';\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.type = 'Object3D';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.parent = null;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.children = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.up = Object3D.DefaultUp.clone();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar position = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar rotation = new Euler();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar quaternion = new Quaternion();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar scale = new Vector3(1, 1, 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction onRotationChange() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tquaternion.setFromEuler(rotation, false);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction onQuaternionChange() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\trotation.setFromQuaternion(quaternion, undefined, false);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\trotation.onChange(onRotationChange);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tquaternion.onChange(onQuaternionChange);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tObject.defineProperties(this, {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tposition: {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconfigurable: true,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tenumerable: true,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvalue: position\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\trotation: {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconfigurable: true,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tenumerable: true,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvalue: rotation\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tquaternion: {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconfigurable: true,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tenumerable: true,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvalue: quaternion\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tscale: {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconfigurable: true,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tenumerable: true,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvalue: scale\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmodelViewMatrix: {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvalue: new Matrix4()\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormalMatrix: {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvalue: new Matrix3()\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.matrix = new Matrix4();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.matrixWorld = new Matrix4();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.matrixWorldNeedsUpdate = false;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.layers = new Layers();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.visible = true;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.castShadow = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.receiveShadow = false;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.frustumCulled = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.renderOrder = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.userData = {};\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tObject3D.DefaultUp = new Vector3(0, 1, 0);\\\\n\\\\t\\\\t\\\\tObject3D.DefaultMatrixAutoUpdate = true;\\\\n\\\\n\\\\t\\\\t\\\\tObject3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconstructor: Object3D,\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tisObject3D: true,\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tonBeforeRender: function onBeforeRender() {},\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tonAfterRender: function onAfterRender() {},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tapplyMatrix: function applyMatrix(matrix) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.matrix.multiplyMatrices(matrix, this.matrix);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.matrix.decompose(this.position, this.quaternion, this.scale);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tapplyQuaternion: function applyQuaternion(q) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.quaternion.premultiply(q);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetRotationFromAxisAngle: function setRotationFromAxisAngle(axis, angle) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// assumes axis is normalized\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.quaternion.setFromAxisAngle(axis, angle);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetRotationFromEuler: function setRotationFromEuler(euler) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.quaternion.setFromEuler(euler, true);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetRotationFromMatrix: function setRotationFromMatrix(m) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.quaternion.setFromRotationMatrix(m);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetRotationFromQuaternion: function setRotationFromQuaternion(q) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// assumes q is normalized\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.quaternion.copy(q);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\trotateOnAxis: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// rotate object on axis in object space\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// axis is assumed to be normalized\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar q1 = new Quaternion();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function rotateOnAxis(axis, angle) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tq1.setFromAxisAngle(axis, angle);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.quaternion.multiply(q1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\trotateOnWorldAxis: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// rotate object on axis in world space\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// axis is assumed to be normalized\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// method assumes no rotated parent\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar q1 = new Quaternion();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function rotateOnWorldAxis(axis, angle) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tq1.setFromAxisAngle(axis, angle);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.quaternion.premultiply(q1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\trotateX: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v1 = new Vector3(1, 0, 0);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function rotateX(angle) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.rotateOnAxis(v1, angle);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\trotateY: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v1 = new Vector3(0, 1, 0);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function rotateY(angle) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.rotateOnAxis(v1, angle);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\trotateZ: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v1 = new Vector3(0, 0, 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function rotateZ(angle) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.rotateOnAxis(v1, angle);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttranslateOnAxis: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// translate object by distance along axis in object space\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// axis is assumed to be normalized\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v1 = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function translateOnAxis(axis, distance) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv1.copy(axis).applyQuaternion(this.quaternion);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.position.add(v1.multiplyScalar(distance));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttranslateX: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v1 = new Vector3(1, 0, 0);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function translateX(distance) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.translateOnAxis(v1, distance);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttranslateY: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v1 = new Vector3(0, 1, 0);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function translateY(distance) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.translateOnAxis(v1, distance);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttranslateZ: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v1 = new Vector3(0, 0, 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function translateZ(distance) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.translateOnAxis(v1, distance);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlocalToWorld: function localToWorld(vector) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn vector.applyMatrix4(this.matrixWorld);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tworldToLocal: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar m1 = new Matrix4();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function worldToLocal(vector) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn vector.applyMatrix4(m1.getInverse(this.matrixWorld));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlookAt: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// This method does not support objects having non-uniformly-scaled parent(s)\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar q1 = new Quaternion();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar m1 = new Matrix4();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar target = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar position = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function lookAt(x, y, z) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (x.isVector3) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttarget.copy(x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttarget.set(x, y, z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar parent = this.parent;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.updateWorldMatrix(true, false);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tposition.setFromMatrixPosition(this.matrixWorld);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.isCamera || this.isLight) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tm1.lookAt(position, target, this.up);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tm1.lookAt(target, position, this.up);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.quaternion.setFromRotationMatrix(m1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (parent) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tm1.extractRotation(parent.matrixWorld);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tq1.setFromRotationMatrix(m1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.quaternion.premultiply(q1.inverse());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tadd: function add(object) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (arguments.length > 1) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < arguments.length; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.add(arguments[i]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (object === this) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.error('THREE.Object3D.add: object can\\\\\\\\'t be added as a child of itself.', object);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (object && object.isObject3D) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (object.parent !== null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tobject.parent.remove(object);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tobject.parent = this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tobject.dispatchEvent({ type: 'added' });\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.children.push(object);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.dispatchEvent({ type: 'addedChild', object: object });\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tremove: function remove(object) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (arguments.length > 1) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < arguments.length; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.remove(arguments[i]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar index = this.children.indexOf(object);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (index !== -1) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tobject.parent = null;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tobject.dispatchEvent({ type: 'removed' });\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.children.splice(index, 1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetObjectById: function getObjectById(id) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.getObjectByProperty('id', id);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetObjectByName: function getObjectByName(name) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.getObjectByProperty('name', name);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetObjectByProperty: function getObjectByProperty(name, value) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this[name] === value) return this;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = this.children.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar child = this.children[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar object = child.getObjectByProperty(name, value);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (object !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn object;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn undefined;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetWorldPosition: function getWorldPosition(target) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (target === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Object3D: .getWorldPosition() target is now required');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttarget = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.updateMatrixWorld(true);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn target.setFromMatrixPosition(this.matrixWorld);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetWorldQuaternion: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar position = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar scale = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function getWorldQuaternion(target) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (target === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Object3D: .getWorldQuaternion() target is now required');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttarget = new Quaternion();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.updateMatrixWorld(true);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.matrixWorld.decompose(position, target, scale);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn target;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetWorldScale: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar position = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar quaternion = new Quaternion();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function getWorldScale(target) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (target === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Object3D: .getWorldScale() target is now required');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttarget = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.updateMatrixWorld(true);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.matrixWorld.decompose(position, quaternion, target);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn target;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetWorldDirection: function getWorldDirection(target) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (target === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Object3D: .getWorldDirection() target is now required');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttarget = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.updateMatrixWorld(true);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar e = this.matrixWorld.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn target.set(e[8], e[9], e[10]).normalize();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\traycast: function raycast() {},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttraverse: function traverse(callback) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcallback(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar children = this.children;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = children.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tchildren[i].traverse(callback);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttraverseVisible: function traverseVisible(callback) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.visible === false) return;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcallback(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar children = this.children;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = children.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tchildren[i].traverseVisible(callback);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttraverseAncestors: function traverseAncestors(callback) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar parent = this.parent;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (parent !== null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcallback(parent);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tparent.traverseAncestors(callback);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tupdateMatrix: function updateMatrix() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.matrix.compose(this.position, this.quaternion, this.scale);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.matrixWorldNeedsUpdate = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tupdateMatrixWorld: function updateMatrixWorld(force) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.matrixAutoUpdate) this.updateMatrix();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.matrixWorldNeedsUpdate || force) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.parent === null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.matrixWorld.copy(this.matrix);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.matrixWorldNeedsUpdate = false;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tforce = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// update children\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar children = this.children;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = children.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tchildren[i].updateMatrixWorld(force);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tupdateWorldMatrix: function updateWorldMatrix(updateParents, updateChildren) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar parent = this.parent;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (updateParents === true && parent !== null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tparent.updateWorldMatrix(true, false);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.matrixAutoUpdate) this.updateMatrix();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.parent === null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.matrixWorld.copy(this.matrix);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// update children\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (updateChildren === true) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar children = this.children;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = children.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tchildren[i].updateWorldMatrix(false, true);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttoJSON: function toJSON(meta) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// meta is a string when called from JSON.stringify\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar isRootObject = meta === undefined || typeof meta === 'string';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar output = {};\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// meta is a hash used to collect geometries, materials.\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// not providing it implies that this is the root object\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// being serialized.\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (isRootObject) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// initialize meta obj\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmeta = {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgeometries: {},\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmaterials: {},\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttextures: {},\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\timages: {},\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tshapes: {}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\toutput.metadata = {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tversion: 4.5,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttype: 'Object',\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgenerator: 'Object3D.toJSON'\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// standard Object3D serialization\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar object = {};\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tobject.uuid = this.uuid;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tobject.type = this.type;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.name !== '') object.name = this.name;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.castShadow === true) object.castShadow = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.receiveShadow === true) object.receiveShadow = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.visible === false) object.visible = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.frustumCulled === false) object.frustumCulled = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.renderOrder !== 0) object.renderOrder = this.renderOrder;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tobject.layers = this.layers.mask;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tobject.matrix = this.matrix.toArray();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// object specific properties\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.isMesh && this.drawMode !== TrianglesDrawMode) object.drawMode = this.drawMode;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction serialize(library, element) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (library[element.uuid] === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlibrary[element.uuid] = element.toJSON(meta);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn element.uuid;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.isMesh || this.isLine || this.isPoints) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tobject.geometry = serialize(meta.geometries, this.geometry);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar parameters = this.geometry.parameters;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (parameters !== undefined && parameters.shapes !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar shapes = parameters.shapes;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Array.isArray(shapes)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = shapes.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar shape = shapes[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tserialize(meta.shapes, shape);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tserialize(meta.shapes, shapes);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.material !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Array.isArray(this.material)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar uuids = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = this.material.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tuuids.push(serialize(meta.materials, this.material[i]));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tobject.material = uuids;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tobject.material = serialize(meta.materials, this.material);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.children.length > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tobject.children = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < this.children.length; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tobject.children.push(this.children[i].toJSON(meta).object);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (isRootObject) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar geometries = extractFromCache(meta.geometries);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar materials = extractFromCache(meta.materials);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar textures = extractFromCache(meta.textures);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar images = extractFromCache(meta.images);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar shapes = extractFromCache(meta.shapes);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometries.length > 0) output.geometries = geometries;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (materials.length > 0) output.materials = materials;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (textures.length > 0) output.textures = textures;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (images.length > 0) output.images = images;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (shapes.length > 0) output.shapes = shapes;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\toutput.object = object;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn output;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// extract data from the cache hash\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// remove metadata on each item\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// and return as array\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction extractFromCache(cache) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar values = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var key in cache) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar data = cache[key];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdelete data.metadata;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvalues.push(data);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn values;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclone: function clone(recursive) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn new this.constructor().copy(this, recursive);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopy: function copy(source, recursive) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (recursive === undefined) recursive = true;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.name = source.name;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.up.copy(source.up);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.position.copy(source.position);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.quaternion.copy(source.quaternion);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.scale.copy(source.scale);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.matrix.copy(source.matrix);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.matrixWorld.copy(source.matrixWorld);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.layers.mask = source.layers.mask;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.visible = source.visible;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.castShadow = source.castShadow;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.receiveShadow = source.receiveShadow;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.frustumCulled = source.frustumCulled;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.renderOrder = source.renderOrder;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.userData = JSON.parse(JSON.stringify(source.userData));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (recursive === true) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < source.children.length; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar child = source.children[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.add(child.clone());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author mrdoob / http://mrdoob.com/\\\\r\\\\n    * @author kile / http://kile.stravaganza.org/\\\\r\\\\n    * @author alteredq / http://alteredqualia.com/\\\\r\\\\n    * @author mikael emtinger / http://gomo.se/\\\\r\\\\n    * @author zz85 / http://www.lab4games.net/zz85/blog\\\\r\\\\n    * @author bhouston / http://clara.io\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\tvar geometryId = 0; // Geometry uses even numbers as Id\\\\n\\\\n\\\\t\\\\t\\\\tfunction Geometry() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tObject.defineProperty(this, 'id', { value: geometryId += 2 });\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.uuid = _Math.generateUUID();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.name = '';\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.type = 'Geometry';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.vertices = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.colors = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.faces = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.faceVertexUvs = [[]];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.morphTargets = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.morphNormals = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.skinWeights = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.skinIndices = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.lineDistances = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingBox = null;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingSphere = null;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// update flags\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.elementsNeedUpdate = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.verticesNeedUpdate = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.uvsNeedUpdate = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.normalsNeedUpdate = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.colorsNeedUpdate = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.lineDistancesNeedUpdate = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.groupsNeedUpdate = false;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconstructor: Geometry,\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tisGeometry: true,\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tapplyMatrix: function applyMatrix(matrix) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar normalMatrix = new Matrix3().getNormalMatrix(matrix);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, il = this.vertices.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vertex = this.vertices[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertex.applyMatrix4(matrix);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, il = this.faces.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar face = this.faces[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface.normal.applyMatrix3(normalMatrix).normalize();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.boundingBox !== null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.computeBoundingBox();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.boundingSphere !== null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.computeBoundingSphere();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.verticesNeedUpdate = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.normalsNeedUpdate = true;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\trotateX: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// rotate geometry around world x-axis\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar m1 = new Matrix4();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function rotateX(angle) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tm1.makeRotationX(angle);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.applyMatrix(m1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\trotateY: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// rotate geometry around world y-axis\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar m1 = new Matrix4();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function rotateY(angle) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tm1.makeRotationY(angle);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.applyMatrix(m1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\trotateZ: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// rotate geometry around world z-axis\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar m1 = new Matrix4();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function rotateZ(angle) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tm1.makeRotationZ(angle);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.applyMatrix(m1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttranslate: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// translate geometry\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar m1 = new Matrix4();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function translate(x, y, z) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tm1.makeTranslation(x, y, z);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.applyMatrix(m1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tscale: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// scale geometry\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar m1 = new Matrix4();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function scale(x, y, z) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tm1.makeScale(x, y, z);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.applyMatrix(m1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlookAt: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar obj = new Object3D();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function lookAt(vector) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tobj.lookAt(vector);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tobj.updateMatrix();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.applyMatrix(obj.matrix);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfromBufferGeometry: function fromBufferGeometry(geometry) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar scope = this;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar attributes = geometry.attributes;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar positions = attributes.position.array;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (uvs2 !== undefined) this.faceVertexUvs[1] = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tscope.vertices.push(new Vector3().fromArray(positions, i));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (colors !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tscope.colors.push(new Color().fromArray(colors, i));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction addFace(a, b, c, materialIndex) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vertexColors = colors === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vertexNormals = normals === undefined ? [] : [new Vector3().fromArray(normals, a * 3), new Vector3().fromArray(normals, b * 3), new Vector3().fromArray(normals, c * 3)];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tscope.faces.push(face);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (uvs !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tscope.faceVertexUvs[0].push([new Vector2().fromArray(uvs, a * 2), new Vector2().fromArray(uvs, b * 2), new Vector2().fromArray(uvs, c * 2)]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (uvs2 !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tscope.faceVertexUvs[1].push([new Vector2().fromArray(uvs2, a * 2), new Vector2().fromArray(uvs2, b * 2), new Vector2().fromArray(uvs2, c * 2)]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar groups = geometry.groups;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (groups.length > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < groups.length; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar group = groups[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar start = group.start;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar count = group.count;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var j = start, jl = start + count; j < jl; j += 3) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (indices !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddFace(j, j + 1, j + 2, group.materialIndex);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (indices !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < indices.length; i += 3) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddFace(indices[i], indices[i + 1], indices[i + 2]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < positions.length / 3; i += 3) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddFace(i, i + 1, i + 2);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.computeFaceNormals();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry.boundingBox !== null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingBox = geometry.boundingBox.clone();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry.boundingSphere !== null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingSphere = geometry.boundingSphere.clone();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcenter: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar offset = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function center() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.computeBoundingBox();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingBox.getCenter(offset).negate();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.translate(offset.x, offset.y, offset.z);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormalize: function normalize() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.computeBoundingSphere();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar center = this.boundingSphere.center;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar radius = this.boundingSphere.radius;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar s = radius === 0 ? 1 : 1.0 / radius;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar matrix = new Matrix4();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmatrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.applyMatrix(matrix);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcomputeFaceNormals: function computeFaceNormals() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar cb = new Vector3(),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    ab = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var f = 0, fl = this.faces.length; f < fl; f++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar face = this.faces[f];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vA = this.vertices[face.a];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vB = this.vertices[face.b];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vC = this.vertices[face.c];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcb.subVectors(vC, vB);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tab.subVectors(vA, vB);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcb.cross(ab);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcb.normalize();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface.normal.copy(cb);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcomputeVertexNormals: function computeVertexNormals(areaWeighted) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (areaWeighted === undefined) areaWeighted = true;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v, vl, f, fl, face, vertices;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertices = new Array(this.vertices.length);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (v = 0, vl = this.vertices.length; v < vl; v++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertices[v] = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (areaWeighted) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// vertex normals weighted by triangle areas\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// http://www.iquilezles.org/www/articles/normals/normals.htm\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vA, vB, vC;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar cb = new Vector3(),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    ab = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (f = 0, fl = this.faces.length; f < fl; f++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface = this.faces[f];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvA = this.vertices[face.a];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvB = this.vertices[face.b];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvC = this.vertices[face.c];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcb.subVectors(vC, vB);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tab.subVectors(vA, vB);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcb.cross(ab);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertices[face.a].add(cb);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertices[face.b].add(cb);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertices[face.c].add(cb);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.computeFaceNormals();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (f = 0, fl = this.faces.length; f < fl; f++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface = this.faces[f];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertices[face.a].add(face.normal);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertices[face.b].add(face.normal);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertices[face.c].add(face.normal);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (v = 0, vl = this.vertices.length; v < vl; v++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertices[v].normalize();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (f = 0, fl = this.faces.length; f < fl; f++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface = this.faces[f];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vertexNormals = face.vertexNormals;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (vertexNormals.length === 3) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertexNormals[0].copy(vertices[face.a]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertexNormals[1].copy(vertices[face.b]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertexNormals[2].copy(vertices[face.c]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertexNormals[0] = vertices[face.a].clone();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertexNormals[1] = vertices[face.b].clone();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertexNormals[2] = vertices[face.c].clone();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.faces.length > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.normalsNeedUpdate = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcomputeFlatVertexNormals: function computeFlatVertexNormals() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar f, fl, face;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.computeFaceNormals();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (f = 0, fl = this.faces.length; f < fl; f++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface = this.faces[f];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vertexNormals = face.vertexNormals;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (vertexNormals.length === 3) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertexNormals[0].copy(face.normal);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertexNormals[1].copy(face.normal);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertexNormals[2].copy(face.normal);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertexNormals[0] = face.normal.clone();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertexNormals[1] = face.normal.clone();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertexNormals[2] = face.normal.clone();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.faces.length > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.normalsNeedUpdate = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcomputeMorphNormals: function computeMorphNormals() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar i, il, f, fl, face;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// save original normals\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// - create temp variables on first access\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//   otherwise just copy (for faster repeated calls)\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (f = 0, fl = this.faces.length; f < fl; f++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface = this.faces[f];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!face.__originalFaceNormal) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface.__originalFaceNormal = face.normal.clone();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface.__originalFaceNormal.copy(face.normal);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!face.__originalVertexNormals) face.__originalVertexNormals = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, il = face.vertexNormals.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!face.__originalVertexNormals[i]) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface.__originalVertexNormals[i] = face.vertexNormals[i].clone();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface.__originalVertexNormals[i].copy(face.vertexNormals[i]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// use temp geometry to compute face and vertex normals for each morph\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar tmpGeo = new Geometry();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttmpGeo.faces = this.faces;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, il = this.morphTargets.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// create on first access\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!this.morphNormals[i]) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.morphNormals[i] = {};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.morphNormals[i].faceNormals = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.morphNormals[i].vertexNormals = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar dstNormalsFace = this.morphNormals[i].faceNormals;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar dstNormalsVertex = this.morphNormals[i].vertexNormals;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar faceNormal, vertexNormals;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (f = 0, fl = this.faces.length; f < fl; f++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaceNormal = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdstNormalsFace.push(faceNormal);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdstNormalsVertex.push(vertexNormals);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar morphNormals = this.morphNormals[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// set vertices to morph target\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttmpGeo.vertices = this.morphTargets[i].vertices;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// compute morph normals\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttmpGeo.computeFaceNormals();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttmpGeo.computeVertexNormals();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// store morph normals\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar faceNormal, vertexNormals;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (f = 0, fl = this.faces.length; f < fl; f++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface = this.faces[f];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaceNormal = morphNormals.faceNormals[f];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertexNormals = morphNormals.vertexNormals[f];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaceNormal.copy(face.normal);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertexNormals.a.copy(face.vertexNormals[0]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertexNormals.b.copy(face.vertexNormals[1]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertexNormals.c.copy(face.vertexNormals[2]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// restore original normals\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (f = 0, fl = this.faces.length; f < fl; f++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface = this.faces[f];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface.normal = face.__originalFaceNormal;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface.vertexNormals = face.__originalVertexNormals;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcomputeBoundingBox: function computeBoundingBox() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.boundingBox === null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingBox = new Box3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingBox.setFromPoints(this.vertices);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcomputeBoundingSphere: function computeBoundingSphere() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.boundingSphere === null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingSphere = new Sphere();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingSphere.setFromPoints(this.vertices);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmerge: function merge(geometry, matrix, materialIndexOffset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!(geometry && geometry.isGeometry)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar normalMatrix,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    vertexOffset = this.vertices.length,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    vertices1 = this.vertices,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    vertices2 = geometry.vertices,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    faces1 = this.faces,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    faces2 = geometry.faces,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    uvs1 = this.faceVertexUvs[0],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    uvs2 = geometry.faceVertexUvs[0],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    colors1 = this.colors,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    colors2 = geometry.colors;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (materialIndexOffset === undefined) materialIndexOffset = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (matrix !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormalMatrix = new Matrix3().getNormalMatrix(matrix);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// vertices\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, il = vertices2.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vertex = vertices2[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vertexCopy = vertex.clone();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (matrix !== undefined) vertexCopy.applyMatrix4(matrix);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertices1.push(vertexCopy);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// colors\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, il = colors2.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcolors1.push(colors2[i].clone());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// faces\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, il = faces2.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar face = faces2[i],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    faceCopy,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    normal,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    color,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    faceVertexNormals = face.vertexNormals,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    faceVertexColors = face.vertexColors;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaceCopy.normal.copy(face.normal);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (normalMatrix !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaceCopy.normal.applyMatrix3(normalMatrix).normalize();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormal = faceVertexNormals[j].clone();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (normalMatrix !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormal.applyMatrix3(normalMatrix).normalize();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaceCopy.vertexNormals.push(normal);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaceCopy.color.copy(face.color);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var j = 0, jl = faceVertexColors.length; j < jl; j++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcolor = faceVertexColors[j];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaceCopy.vertexColors.push(color.clone());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaces1.push(faceCopy);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// uvs\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, il = uvs2.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar uv = uvs2[i],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    uvCopy = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (uv === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcontinue;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var j = 0, jl = uv.length; j < jl; j++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tuvCopy.push(uv[j].clone());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tuvs1.push(uvCopy);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmergeMesh: function mergeMesh(mesh) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!(mesh && mesh.isMesh)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (mesh.matrixAutoUpdate) mesh.updateMatrix();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.merge(mesh.geometry, mesh.matrix);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t/*\\\\r\\\\n       * Checks for duplicate vertices with hashmap.\\\\r\\\\n       * Duplicated vertices are removed\\\\r\\\\n       * and faces' vertices are updated.\\\\r\\\\n       */\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmergeVertices: function mergeVertices() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar unique = [],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    changes = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v, key;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar precision = Math.pow(10, precisionPoints);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar i, il, face;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar indices, j, jl;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, il = this.vertices.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv = this.vertices[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tkey = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (verticesMap[key] === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tverticesMap[key] = i;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tunique.push(this.vertices[i]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tchanges[i] = unique.length - 1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tchanges[i] = changes[verticesMap[key]];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// if faces are completely degenerate after merging vertices, we\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// have to remove them from the geometry.\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar faceIndicesToRemove = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, il = this.faces.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface = this.faces[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface.a = changes[face.a];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface.b = changes[face.b];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface.c = changes[face.c];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tindices = [face.a, face.b, face.c];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// if any duplicate vertices are found in a Face3\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// we have to remove the face as nothing can be saved\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var n = 0; n < 3; n++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (indices[n] === indices[(n + 1) % 3]) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaceIndicesToRemove.push(i);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbreak;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = faceIndicesToRemove.length - 1; i >= 0; i--) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar idx = faceIndicesToRemove[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.faces.splice(idx, 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.faceVertexUvs[j].splice(idx, 1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Use unique set of vertices\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar diff = this.vertices.length - unique.length;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.vertices = unique;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn diff;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromPoints: function setFromPoints(points) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.vertices = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = points.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar point = points[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.vertices.push(new Vector3(point.x, point.y, point.z || 0));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsortFacesByMaterialIndex: function sortFacesByMaterialIndex() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar faces = this.faces;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar length = faces.length;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// tag faces\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < length; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaces[i]._id = i;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// sort faces\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction materialIndexSort(a, b) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn a.materialIndex - b.materialIndex;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaces.sort(materialIndexSort);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// sort uvs\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar uvs1 = this.faceVertexUvs[0];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar uvs2 = this.faceVertexUvs[1];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar newUvs1, newUvs2;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (uvs1 && uvs1.length === length) newUvs1 = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (uvs2 && uvs2.length === length) newUvs2 = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < length; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar id = faces[i]._id;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (newUvs1) newUvs1.push(uvs1[id]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (newUvs2) newUvs2.push(uvs2[id]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (newUvs1) this.faceVertexUvs[0] = newUvs1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (newUvs2) this.faceVertexUvs[1] = newUvs2;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttoJSON: function toJSON() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar data = {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmetadata: {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tversion: 4.5,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttype: 'Geometry',\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgenerator: 'Geometry.toJSON'\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// standard Geometry serialization\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.uuid = this.uuid;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.type = this.type;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.name !== '') data.name = this.name;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.parameters !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar parameters = this.parameters;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var key in parameters) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (parameters[key] !== undefined) data[key] = parameters[key];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn data;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vertices = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < this.vertices.length; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vertex = this.vertices[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertices.push(vertex.x, vertex.y, vertex.z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar faces = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar normals = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar normalsHash = {};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar colors = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar colorsHash = {};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar uvs = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar uvsHash = {};\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < this.faces.length; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar face = this.faces[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hasMaterial = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hasFaceUv = false; // deprecated\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hasFaceNormal = face.normal.length() > 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hasFaceVertexColor = face.vertexColors.length > 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar faceType = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaceType = setBit(faceType, 0, 0); // isQuad\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaceType = setBit(faceType, 1, hasMaterial);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaceType = setBit(faceType, 2, hasFaceUv);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaceType = setBit(faceType, 3, hasFaceVertexUv);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaceType = setBit(faceType, 4, hasFaceNormal);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaceType = setBit(faceType, 5, hasFaceVertexNormal);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaceType = setBit(faceType, 6, hasFaceColor);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaceType = setBit(faceType, 7, hasFaceVertexColor);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaces.push(faceType);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaces.push(face.a, face.b, face.c);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaces.push(face.materialIndex);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (hasFaceVertexUv) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar faceVertexUvs = this.faceVertexUvs[0][i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (hasFaceNormal) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaces.push(getNormalIndex(face.normal));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (hasFaceVertexNormal) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vertexNormals = face.vertexNormals;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (hasFaceColor) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaces.push(getColorIndex(face.color));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (hasFaceVertexColor) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vertexColors = face.vertexColors;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction setBit(value, position, enabled) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn enabled ? value | 1 << position : value & ~(1 << position);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction getNormalIndex(normal) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (normalsHash[hash] !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn normalsHash[hash];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormalsHash[hash] = normals.length / 3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals.push(normal.x, normal.y, normal.z);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn normalsHash[hash];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction getColorIndex(color) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (colorsHash[hash] !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn colorsHash[hash];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcolorsHash[hash] = colors.length;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcolors.push(color.getHex());\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn colorsHash[hash];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction getUvIndex(uv) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hash = uv.x.toString() + uv.y.toString();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (uvsHash[hash] !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn uvsHash[hash];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tuvsHash[hash] = uvs.length / 2;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tuvs.push(uv.x, uv.y);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn uvsHash[hash];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.data = {};\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.data.vertices = vertices;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.data.normals = normals;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (colors.length > 0) data.data.colors = colors;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.data.faces = faces;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn data;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclone: function clone() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t/*\\\\r\\\\n          // Handle primitives\\\\r\\\\n         \\\\t\\\\t var parameters = this.parameters;\\\\r\\\\n         \\\\t\\\\t if ( parameters !== undefined ) {\\\\r\\\\n         \\\\t\\\\t var values = [];\\\\r\\\\n         \\\\t\\\\t for ( var key in parameters ) {\\\\r\\\\n         \\\\t\\\\t values.push( parameters[ key ] );\\\\r\\\\n         \\\\t\\\\t }\\\\r\\\\n         \\\\t\\\\t var geometry = Object.create( this.constructor.prototype );\\\\r\\\\n          this.constructor.apply( geometry, values );\\\\r\\\\n          return geometry;\\\\r\\\\n         \\\\t\\\\t }\\\\r\\\\n         \\\\t\\\\t return new this.constructor().copy( this );\\\\r\\\\n          */\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn new Geometry().copy(this);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopy: function copy(source) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar i, il, j, jl, k, kl;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// reset\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.vertices = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.colors = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.faces = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.faceVertexUvs = [[]];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.morphTargets = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.morphNormals = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.skinWeights = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.skinIndices = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.lineDistances = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingBox = null;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingSphere = null;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// name\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.name = source.name;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// vertices\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vertices = source.vertices;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, il = vertices.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.vertices.push(vertices[i].clone());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// colors\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar colors = source.colors;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, il = colors.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.colors.push(colors[i].clone());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// faces\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar faces = source.faces;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, il = faces.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.faces.push(faces[i].clone());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// face vertex uvs\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, il = source.faceVertexUvs.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar faceVertexUvs = source.faceVertexUvs[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.faceVertexUvs[i] === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.faceVertexUvs[i] = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (j = 0, jl = faceVertexUvs.length; j < jl; j++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar uvs = faceVertexUvs[j],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    uvsCopy = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (k = 0, kl = uvs.length; k < kl; k++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar uv = uvs[k];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tuvsCopy.push(uv.clone());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.faceVertexUvs[i].push(uvsCopy);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// morph targets\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar morphTargets = source.morphTargets;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, il = morphTargets.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar morphTarget = {};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmorphTarget.name = morphTargets[i].name;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// vertices\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (morphTargets[i].vertices !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmorphTarget.vertices = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmorphTarget.vertices.push(morphTargets[i].vertices[j].clone());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// normals\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (morphTargets[i].normals !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmorphTarget.normals = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmorphTarget.normals.push(morphTargets[i].normals[j].clone());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.morphTargets.push(morphTarget);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// morph normals\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar morphNormals = source.morphNormals;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, il = morphNormals.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar morphNormal = {};\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// vertex normals\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (morphNormals[i].vertexNormals !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmorphNormal.vertexNormals = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar srcVertexNormal = morphNormals[i].vertexNormals[j];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar destVertexNormal = {};\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdestVertexNormal.a = srcVertexNormal.a.clone();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdestVertexNormal.b = srcVertexNormal.b.clone();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdestVertexNormal.c = srcVertexNormal.c.clone();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmorphNormal.vertexNormals.push(destVertexNormal);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// face normals\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (morphNormals[i].faceNormals !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmorphNormal.faceNormals = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmorphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.morphNormals.push(morphNormal);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// skin weights\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar skinWeights = source.skinWeights;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, il = skinWeights.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.skinWeights.push(skinWeights[i].clone());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// skin indices\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar skinIndices = source.skinIndices;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, il = skinIndices.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.skinIndices.push(skinIndices[i].clone());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// line distances\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar lineDistances = source.lineDistances;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, il = lineDistances.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.lineDistances.push(lineDistances[i]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// bounding box\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar boundingBox = source.boundingBox;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (boundingBox !== null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingBox = boundingBox.clone();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// bounding sphere\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar boundingSphere = source.boundingSphere;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (boundingSphere !== null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingSphere = boundingSphere.clone();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// update flags\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.elementsNeedUpdate = source.elementsNeedUpdate;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.verticesNeedUpdate = source.verticesNeedUpdate;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.uvsNeedUpdate = source.uvsNeedUpdate;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.normalsNeedUpdate = source.normalsNeedUpdate;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.colorsNeedUpdate = source.colorsNeedUpdate;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.groupsNeedUpdate = source.groupsNeedUpdate;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdispose: function dispose() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.dispatchEvent({ type: 'dispose' });\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author supereggbert / http://www.paulbrunt.co.uk/\\\\r\\\\n    * @author philogb / http://blog.thejit.org/\\\\r\\\\n    * @author mikael emtinger / http://gomo.se/\\\\r\\\\n    * @author egraether / http://egraether.com/\\\\r\\\\n    * @author WestLangley / http://github.com/WestLangley\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\tfunction Vector4(x, y, z, w) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = x || 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = y || 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = z || 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w = w !== undefined ? w : 1;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tObject.assign(Vector4.prototype, {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tisVector4: true,\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tset: function set(x, y, z, w) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w = w;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetScalar: function setScalar(scalar) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = scalar;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = scalar;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = scalar;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w = scalar;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetX: function setX(x) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = x;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetY: function setY(y) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetZ: function setZ(z) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetW: function setW(w) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w = w;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetComponent: function setComponent(index, value) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tswitch (index) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase 0:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = value;break;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase 1:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = value;break;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase 2:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = value;break;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase 3:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w = value;break;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdefault:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthrow new Error('index is out of range: ' + index);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetComponent: function getComponent(index) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tswitch (index) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase 0:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase 1:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase 2:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcase 3:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.w;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdefault:\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthrow new Error('index is out of range: ' + index);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclone: function clone() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn new this.constructor(this.x, this.y, this.z, this.w);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopy: function copy(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = v.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = v.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = v.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w = v.w !== undefined ? v.w : 1;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tadd: function add(v, w) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (w !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.addVectors(v, w);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x += v.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y += v.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z += v.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w += v.w;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddScalar: function addScalar(s) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x += s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y += s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z += s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w += s;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddVectors: function addVectors(a, b) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = a.x + b.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = a.y + b.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = a.z + b.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w = a.w + b.w;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddScaledVector: function addScaledVector(v, s) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x += v.x * s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y += v.y * s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z += v.z * s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w += v.w * s;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsub: function sub(v, w) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (w !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.subVectors(v, w);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x -= v.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y -= v.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z -= v.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w -= v.w;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsubScalar: function subScalar(s) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x -= s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y -= s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z -= s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w -= s;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsubVectors: function subVectors(a, b) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = a.x - b.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = a.y - b.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = a.z - b.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w = a.w - b.w;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmultiplyScalar: function multiplyScalar(scalar) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x *= scalar;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y *= scalar;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z *= scalar;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w *= scalar;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tapplyMatrix4: function applyMatrix4(m) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x = this.x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    y = this.y,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    z = this.z,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    w = this.w;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar e = m.elements;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdivideScalar: function divideScalar(scalar) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.multiplyScalar(1 / scalar);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetAxisAngleFromQuaternion: function setAxisAngleFromQuaternion(q) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// q is assumed to be normalized\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w = 2 * Math.acos(q.w);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar s = Math.sqrt(1 - q.w * q.w);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (s < 0.0001) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = 1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = q.x / s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = q.y / s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = q.z / s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetAxisAngleFromRotationMatrix: function setAxisAngleFromRotationMatrix(m) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar angle,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    y,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    z,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    // variables for result\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tepsilon = 0.01,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    // margin to allow for rounding errors\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tepsilon2 = 0.1,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    // margin to distinguish between 0 and 180 degrees\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tte = m.elements,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m11 = te[0],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m12 = te[4],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m13 = te[8],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m21 = te[1],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m22 = te[5],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m23 = te[9],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m31 = te[2],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m32 = te[6],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m33 = te[10];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// singularity found\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// first check for identity matrix which must have +1 for all terms\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// in leading diagonal and zero in other terms\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// this singularity is identity matrix so angle = 0\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.set(1, 0, 0, 0);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this; // zero angle, arbitrary axis\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// otherwise this singularity is angle = 180\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tangle = Math.PI;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar xx = (m11 + 1) / 2;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar yy = (m22 + 1) / 2;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar zz = (m33 + 1) / 2;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar xy = (m12 + m21) / 4;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar xz = (m13 + m31) / 4;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar yz = (m23 + m32) / 4;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (xx > yy && xx > zz) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// m11 is the largest diagonal term\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (xx < epsilon) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tx = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ty = 0.707106781;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tz = 0.707106781;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tx = Math.sqrt(xx);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ty = xy / x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tz = xz / x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (yy > zz) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// m22 is the largest diagonal term\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (yy < epsilon) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tx = 0.707106781;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ty = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tz = 0.707106781;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ty = Math.sqrt(yy);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tx = xy / y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tz = yz / y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// m33 is the largest diagonal term so base result on this\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (zz < epsilon) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tx = 0.707106781;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ty = 0.707106781;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tz = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tz = Math.sqrt(zz);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tx = xz / z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ty = yz / z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.set(x, y, z, angle);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this; // return 180 deg rotation\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// as we have reached here there are no singularities so we can handle normally\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Math.abs(s) < 0.001) s = 1;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// caught by singularity test above, but I've left it in just in case\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = (m32 - m23) / s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = (m13 - m31) / s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = (m21 - m12) / s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w = Math.acos((m11 + m22 + m33 - 1) / 2);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmin: function min(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = Math.min(this.x, v.x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = Math.min(this.y, v.y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = Math.min(this.z, v.z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w = Math.min(this.w, v.w);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmax: function max(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = Math.max(this.x, v.x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = Math.max(this.y, v.y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = Math.max(this.z, v.z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w = Math.max(this.w, v.w);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclamp: function clamp(min, max) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// assumes min < max, componentwise\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = Math.max(min.z, Math.min(max.z, this.z));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w = Math.max(min.w, Math.min(max.w, this.w));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclampScalar: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar min, max;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function clampScalar(minVal, maxVal) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (min === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmin = new Vector4();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmax = new Vector4();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmin.set(minVal, minVal, minVal, minVal);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmax.set(maxVal, maxVal, maxVal, maxVal);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.clamp(min, max);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclampLength: function clampLength(min, max) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar length = this.length();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfloor: function floor() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = Math.floor(this.x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = Math.floor(this.y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = Math.floor(this.z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w = Math.floor(this.w);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tceil: function ceil() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = Math.ceil(this.x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = Math.ceil(this.y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = Math.ceil(this.z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w = Math.ceil(this.w);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tround: function round() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = Math.round(this.x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = Math.round(this.y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = Math.round(this.z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w = Math.round(this.w);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\troundToZero: function roundToZero() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnegate: function negate() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = -this.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = -this.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = -this.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w = -this.w;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdot: function dot(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlengthSq: function lengthSq() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlength: function length() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmanhattanLength: function manhattanLength() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormalize: function normalize() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.divideScalar(this.length() || 1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetLength: function setLength(length) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.normalize().multiplyScalar(length);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlerp: function lerp(v, alpha) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x += (v.x - this.x) * alpha;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y += (v.y - this.y) * alpha;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z += (v.z - this.z) * alpha;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w += (v.w - this.w) * alpha;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlerpVectors: function lerpVectors(v1, v2, alpha) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tequals: function equals(v) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfromArray: function fromArray(array, offset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (offset === undefined) offset = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = array[offset];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = array[offset + 1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = array[offset + 2];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w = array[offset + 3];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttoArray: function toArray(array, offset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (array === undefined) array = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (offset === undefined) offset = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset] = this.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 1] = this.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 2] = this.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset + 3] = this.w;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn array;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfromBufferAttribute: function fromBufferAttribute(attribute, index, offset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (offset !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = attribute.getX(index);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = attribute.getY(index);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = attribute.getZ(index);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.w = attribute.getW(index);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author mrdoob / http://mrdoob.com/\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\tfunction BufferAttribute(array, itemSize, normalized) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Array.isArray(array)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthrow new TypeError('THREE.BufferAttribute: array should be a Typed Array.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.name = '';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.array = array;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.itemSize = itemSize;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.count = array !== undefined ? array.length / itemSize : 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.normalized = normalized === true;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.dynamic = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.updateRange = { offset: 0, count: -1 };\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.version = 0;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tObject.defineProperty(BufferAttribute.prototype, 'needsUpdate', {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tset: function set(value) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (value === true) this.version++;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\tObject.assign(BufferAttribute.prototype, {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tisBufferAttribute: true,\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tonUploadCallback: function onUploadCallback() {},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetArray: function setArray(array) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Array.isArray(array)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthrow new TypeError('THREE.BufferAttribute: array should be a Typed Array.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.count = array !== undefined ? array.length / this.itemSize : 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.array = array;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetDynamic: function setDynamic(value) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.dynamic = value;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopy: function copy(source) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.name = source.name;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.array = new source.array.constructor(source.array);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.itemSize = source.itemSize;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.count = source.count;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.normalized = source.normalized;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.dynamic = source.dynamic;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopyAt: function copyAt(index1, attribute, index2) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tindex1 *= this.itemSize;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tindex2 *= attribute.itemSize;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = this.itemSize; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.array[index1 + i] = attribute.array[index2 + i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopyArray: function copyArray(array) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.array.set(array);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopyColorsArray: function copyColorsArray(colors) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar array = this.array,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    offset = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = colors.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar color = colors[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (color === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcolor = new Color();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset++] = color.r;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset++] = color.g;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset++] = color.b;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopyVector2sArray: function copyVector2sArray(vectors) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar array = this.array,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    offset = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = vectors.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vector = vectors[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (vector === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvector = new Vector2();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset++] = vector.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset++] = vector.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopyVector3sArray: function copyVector3sArray(vectors) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar array = this.array,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    offset = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = vectors.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vector = vectors[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (vector === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvector = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset++] = vector.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset++] = vector.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset++] = vector.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopyVector4sArray: function copyVector4sArray(vectors) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar array = this.array,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    offset = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = vectors.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vector = vectors[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (vector === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvector = new Vector4();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset++] = vector.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset++] = vector.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset++] = vector.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[offset++] = vector.w;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tset: function set(value, offset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (offset === undefined) offset = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.array.set(value, offset);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetX: function getX(index) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.array[index * this.itemSize];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetX: function setX(index, x) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.array[index * this.itemSize] = x;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetY: function getY(index) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.array[index * this.itemSize + 1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetY: function setY(index, y) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.array[index * this.itemSize + 1] = y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetZ: function getZ(index) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.array[index * this.itemSize + 2];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetZ: function setZ(index, z) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.array[index * this.itemSize + 2] = z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetW: function getW(index) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.array[index * this.itemSize + 3];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetW: function setW(index, w) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.array[index * this.itemSize + 3] = w;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetXY: function setXY(index, x, y) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tindex *= this.itemSize;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.array[index + 0] = x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.array[index + 1] = y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetXYZ: function setXYZ(index, x, y, z) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tindex *= this.itemSize;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.array[index + 0] = x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.array[index + 1] = y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.array[index + 2] = z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetXYZW: function setXYZW(index, x, y, z, w) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tindex *= this.itemSize;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.array[index + 0] = x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.array[index + 1] = y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.array[index + 2] = z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.array[index + 3] = w;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tonUpload: function onUpload(callback) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.onUploadCallback = callback;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclone: function clone() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn new this.constructor(this.array, this.itemSize).copy(this);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\t//\\\\n\\\\n\\\\t\\\\t\\\\tfunction Int8BufferAttribute(array, itemSize, normalized) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tBufferAttribute.call(this, new Int8Array(array), itemSize, normalized);\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tInt8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\\\\n\\\\t\\\\t\\\\tInt8BufferAttribute.prototype.constructor = Int8BufferAttribute;\\\\n\\\\n\\\\t\\\\t\\\\tfunction Uint8BufferAttribute(array, itemSize, normalized) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tBufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tUint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\\\\n\\\\t\\\\t\\\\tUint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;\\\\n\\\\n\\\\t\\\\t\\\\tfunction Uint8ClampedBufferAttribute(array, itemSize, normalized) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tBufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tUint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);\\\\n\\\\t\\\\t\\\\tUint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;\\\\n\\\\n\\\\t\\\\t\\\\tfunction Int16BufferAttribute(array, itemSize, normalized) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tBufferAttribute.call(this, new Int16Array(array), itemSize, normalized);\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tInt16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\\\\n\\\\t\\\\t\\\\tInt16BufferAttribute.prototype.constructor = Int16BufferAttribute;\\\\n\\\\n\\\\t\\\\t\\\\tfunction Uint16BufferAttribute(array, itemSize, normalized) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tBufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tUint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\\\\n\\\\t\\\\t\\\\tUint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;\\\\n\\\\n\\\\t\\\\t\\\\tfunction Int32BufferAttribute(array, itemSize, normalized) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tBufferAttribute.call(this, new Int32Array(array), itemSize, normalized);\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tInt32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\\\\n\\\\t\\\\t\\\\tInt32BufferAttribute.prototype.constructor = Int32BufferAttribute;\\\\n\\\\n\\\\t\\\\t\\\\tfunction Uint32BufferAttribute(array, itemSize, normalized) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tBufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tUint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\\\\n\\\\t\\\\t\\\\tUint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;\\\\n\\\\n\\\\t\\\\t\\\\tfunction Float32BufferAttribute(array, itemSize, normalized) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tBufferAttribute.call(this, new Float32Array(array), itemSize, normalized);\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tFloat32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\\\\n\\\\t\\\\t\\\\tFloat32BufferAttribute.prototype.constructor = Float32BufferAttribute;\\\\n\\\\n\\\\t\\\\t\\\\tfunction Float64BufferAttribute(array, itemSize, normalized) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tBufferAttribute.call(this, new Float64Array(array), itemSize, normalized);\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tFloat64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);\\\\n\\\\t\\\\t\\\\tFloat64BufferAttribute.prototype.constructor = Float64BufferAttribute;\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author mrdoob / http://mrdoob.com/\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\tfunction DirectGeometry() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.vertices = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.normals = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.colors = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.uvs = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.uvs2 = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.groups = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.morphTargets = {};\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.skinWeights = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.skinIndices = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// this.lineDistances = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingBox = null;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingSphere = null;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// update flags\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.verticesNeedUpdate = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.normalsNeedUpdate = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.colorsNeedUpdate = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.uvsNeedUpdate = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.groupsNeedUpdate = false;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tObject.assign(DirectGeometry.prototype, {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcomputeGroups: function computeGroups(geometry) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar group;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar groups = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar materialIndex = undefined;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar faces = geometry.faces;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < faces.length; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar face = faces[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// materials\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (face.materialIndex !== materialIndex) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmaterialIndex = face.materialIndex;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (group !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgroup.count = i * 3 - group.start;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgroups.push(group);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgroup = {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tstart: i * 3,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmaterialIndex: materialIndex\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (group !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgroup.count = i * 3 - group.start;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgroups.push(group);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.groups = groups;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfromGeometry: function fromGeometry(geometry) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar faces = geometry.faces;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vertices = geometry.vertices;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar faceVertexUvs = geometry.faceVertexUvs;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// morphs\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar morphTargets = geometry.morphTargets;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar morphTargetsLength = morphTargets.length;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar morphTargetsPosition;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (morphTargetsLength > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmorphTargetsPosition = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < morphTargetsLength; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmorphTargetsPosition[i] = {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tname: morphTargets[i].name,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata: []\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.morphTargets.position = morphTargetsPosition;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar morphNormals = geometry.morphNormals;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar morphNormalsLength = morphNormals.length;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar morphTargetsNormal;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (morphNormalsLength > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmorphTargetsNormal = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < morphNormalsLength; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmorphTargetsNormal[i] = {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tname: morphNormals[i].name,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata: []\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.morphTargets.normal = morphTargetsNormal;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// skins\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar skinIndices = geometry.skinIndices;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar skinWeights = geometry.skinWeights;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hasSkinIndices = skinIndices.length === vertices.length;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hasSkinWeights = skinWeights.length === vertices.length;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (vertices.length > 0 && faces.length === 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.error('THREE.DirectGeometry: Faceless geometries are not supported.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < faces.length; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar face = faces[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vertexNormals = face.vertexNormals;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (vertexNormals.length === 3) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar normal = face.normal;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.normals.push(normal, normal, normal);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vertexColors = face.vertexColors;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (vertexColors.length === 3) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar color = face.color;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.colors.push(color, color, color);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (hasFaceVertexUv === true) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vertexUvs = faceVertexUvs[0][i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (vertexUvs !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.uvs.push(new Vector2(), new Vector2(), new Vector2());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (hasFaceVertexUv2 === true) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vertexUvs = faceVertexUvs[1][i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (vertexUvs !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.uvs2.push(new Vector2(), new Vector2(), new Vector2());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// morphs\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var j = 0; j < morphTargetsLength; j++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar morphTarget = morphTargets[j].vertices;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmorphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var j = 0; j < morphNormalsLength; j++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar morphNormal = morphNormals[j].vertexNormals[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmorphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// skins\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (hasSkinIndices) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (hasSkinWeights) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.computeGroups(geometry);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author mrdoob / http://mrdoob.com/\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\tfunction arrayMax(array) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (array.length === 0) return -Infinity;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar max = array[0];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 1, l = array.length; i < l; ++i) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (array[i] > max) max = array[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn max;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author alteredq / http://alteredqualia.com/\\\\r\\\\n    * @author mrdoob / http://mrdoob.com/\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\tvar bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id\\\\n\\\\n\\\\t\\\\t\\\\tfunction BufferGeometry() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tObject.defineProperty(this, 'id', { value: bufferGeometryId += 2 });\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.uuid = _Math.generateUUID();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.name = '';\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.type = 'BufferGeometry';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.index = null;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.attributes = {};\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.morphAttributes = {};\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.groups = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingBox = null;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingSphere = null;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.drawRange = { start: 0, count: Infinity };\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.userData = {};\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tBufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconstructor: BufferGeometry,\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tisBufferGeometry: true,\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetIndex: function getIndex() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.index;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetIndex: function setIndex(index) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Array.isArray(index)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.index = index;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddAttribute: function addAttribute(name, attribute) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2]));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (name === 'index') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.setIndex(attribute);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.attributes[name] = attribute;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetAttribute: function getAttribute(name) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.attributes[name];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tremoveAttribute: function removeAttribute(name) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdelete this.attributes[name];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddGroup: function addGroup(start, count, materialIndex) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.groups.push({\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tstart: start,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcount: count,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t});\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclearGroups: function clearGroups() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.groups = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetDrawRange: function setDrawRange(start, count) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.drawRange.start = start;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.drawRange.count = count;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tapplyMatrix: function applyMatrix(matrix) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar position = this.attributes.position;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (position !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmatrix.applyToBufferAttribute(position);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tposition.needsUpdate = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar normal = this.attributes.normal;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (normal !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar normalMatrix = new Matrix3().getNormalMatrix(matrix);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormalMatrix.applyToBufferAttribute(normal);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormal.needsUpdate = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.boundingBox !== null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.computeBoundingBox();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.boundingSphere !== null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.computeBoundingSphere();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\trotateX: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// rotate geometry around world x-axis\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar m1 = new Matrix4();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function rotateX(angle) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tm1.makeRotationX(angle);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.applyMatrix(m1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\trotateY: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// rotate geometry around world y-axis\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar m1 = new Matrix4();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function rotateY(angle) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tm1.makeRotationY(angle);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.applyMatrix(m1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\trotateZ: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// rotate geometry around world z-axis\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar m1 = new Matrix4();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function rotateZ(angle) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tm1.makeRotationZ(angle);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.applyMatrix(m1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttranslate: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// translate geometry\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar m1 = new Matrix4();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function translate(x, y, z) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tm1.makeTranslation(x, y, z);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.applyMatrix(m1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tscale: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// scale geometry\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar m1 = new Matrix4();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function scale(x, y, z) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tm1.makeScale(x, y, z);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.applyMatrix(m1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlookAt: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar obj = new Object3D();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function lookAt(vector) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tobj.lookAt(vector);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tobj.updateMatrix();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.applyMatrix(obj.matrix);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcenter: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar offset = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function center() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.computeBoundingBox();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingBox.getCenter(offset).negate();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.translate(offset.x, offset.y, offset.z);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromObject: function setFromObject(object) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar geometry = object.geometry;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (object.isPoints || object.isLine) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.addAttribute('position', positions.copyVector3sArray(geometry.vertices));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.addAttribute('color', colors.copyColorsArray(geometry.colors));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry.boundingSphere !== null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingSphere = geometry.boundingSphere.clone();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry.boundingBox !== null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingBox = geometry.boundingBox.clone();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (object.isMesh) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry && geometry.isGeometry) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.fromGeometry(geometry);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromPoints: function setFromPoints(points) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar position = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = points.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar point = points[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tposition.push(point.x, point.y, point.z || 0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.addAttribute('position', new Float32BufferAttribute(position, 3));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tupdateFromObject: function updateFromObject(object) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar geometry = object.geometry;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (object.isMesh) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar direct = geometry.__directGeometry;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry.elementsNeedUpdate === true) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdirect = undefined;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgeometry.elementsNeedUpdate = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (direct === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.fromGeometry(geometry);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgeometry.verticesNeedUpdate = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgeometry.normalsNeedUpdate = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgeometry.colorsNeedUpdate = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgeometry.uvsNeedUpdate = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgeometry.groupsNeedUpdate = false;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgeometry = direct;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar attribute;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry.verticesNeedUpdate === true) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tattribute = this.attributes.position;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (attribute !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tattribute.copyVector3sArray(geometry.vertices);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tattribute.needsUpdate = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgeometry.verticesNeedUpdate = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry.normalsNeedUpdate === true) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tattribute = this.attributes.normal;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (attribute !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tattribute.copyVector3sArray(geometry.normals);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tattribute.needsUpdate = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgeometry.normalsNeedUpdate = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry.colorsNeedUpdate === true) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tattribute = this.attributes.color;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (attribute !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tattribute.copyColorsArray(geometry.colors);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tattribute.needsUpdate = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgeometry.colorsNeedUpdate = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry.uvsNeedUpdate) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tattribute = this.attributes.uv;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (attribute !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tattribute.copyVector2sArray(geometry.uvs);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tattribute.needsUpdate = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgeometry.uvsNeedUpdate = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry.lineDistancesNeedUpdate) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tattribute = this.attributes.lineDistance;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (attribute !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tattribute.copyArray(geometry.lineDistances);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tattribute.needsUpdate = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgeometry.lineDistancesNeedUpdate = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry.groupsNeedUpdate) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgeometry.computeGroups(object.geometry);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.groups = geometry.groups;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgeometry.groupsNeedUpdate = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfromGeometry: function fromGeometry(geometry) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgeometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.fromDirectGeometry(geometry.__directGeometry);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfromDirectGeometry: function fromDirectGeometry(geometry) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar positions = new Float32Array(geometry.vertices.length * 3);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.addAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry.normals.length > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar normals = new Float32Array(geometry.normals.length * 3);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.addAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry.colors.length > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar colors = new Float32Array(geometry.colors.length * 3);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.addAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry.uvs.length > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar uvs = new Float32Array(geometry.uvs.length * 2);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.addAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry.uvs2.length > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar uvs2 = new Float32Array(geometry.uvs2.length * 2);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.addAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// groups\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.groups = geometry.groups;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// morphs\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var name in geometry.morphTargets) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar array = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar morphTargets = geometry.morphTargets[name];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = morphTargets.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar morphTarget = morphTargets[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tattribute.name = morphTarget.name;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray.push(attribute.copyVector3sArray(morphTarget.data));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.morphAttributes[name] = array;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// skinning\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry.skinIndices.length > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry.skinWeights.length > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry.boundingSphere !== null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingSphere = geometry.boundingSphere.clone();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry.boundingBox !== null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingBox = geometry.boundingBox.clone();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcomputeBoundingBox: function computeBoundingBox() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.boundingBox === null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingBox = new Box3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar position = this.attributes.position;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (position !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingBox.setFromBufferAttribute(position);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingBox.makeEmpty();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \\\\\\\"position\\\\\\\" attribute is likely to have NaN values.', this);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcomputeBoundingSphere: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar box = new Box3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vector = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function computeBoundingSphere() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.boundingSphere === null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingSphere = new Sphere();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar position = this.attributes.position;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (position) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar center = this.boundingSphere.center;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbox.setFromBufferAttribute(position);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbox.getCenter(center);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// hoping to find a boundingSphere with a radius smaller than the\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar maxRadiusSq = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, il = position.count; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvector.x = position.getX(i);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvector.y = position.getY(i);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvector.z = position.getZ(i);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmaxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingSphere.radius = Math.sqrt(maxRadiusSq);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (isNaN(this.boundingSphere.radius)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \\\\\\\"position\\\\\\\" attribute is likely to have NaN values.', this);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcomputeFaceNormals: function computeFaceNormals() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// backwards compatibility\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcomputeVertexNormals: function computeVertexNormals() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar index = this.index;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar attributes = this.attributes;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (attributes.position) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar positions = attributes.position.array;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (attributes.normal === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.addAttribute('normal', new BufferAttribute(new Float32Array(positions.length), 3));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// reset existing normals to zero\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar array = attributes.normal.array;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, il = array.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray[i] = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar normals = attributes.normal.array;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vA, vB, vC;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar pA = new Vector3(),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    pB = new Vector3(),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    pC = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar cb = new Vector3(),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    ab = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// indexed elements\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (index) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar indices = index.array;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, il = index.count; i < il; i += 3) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvA = indices[i + 0] * 3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvB = indices[i + 1] * 3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvC = indices[i + 2] * 3;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpA.fromArray(positions, vA);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpB.fromArray(positions, vB);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpC.fromArray(positions, vC);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcb.subVectors(pC, pB);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tab.subVectors(pA, pB);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcb.cross(ab);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals[vA] += cb.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals[vA + 1] += cb.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals[vA + 2] += cb.z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals[vB] += cb.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals[vB + 1] += cb.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals[vB + 2] += cb.z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals[vC] += cb.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals[vC + 1] += cb.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals[vC + 2] += cb.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// non-indexed elements (unconnected triangle soup)\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, il = positions.length; i < il; i += 9) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpA.fromArray(positions, i);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpB.fromArray(positions, i + 3);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpC.fromArray(positions, i + 6);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcb.subVectors(pC, pB);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tab.subVectors(pA, pB);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcb.cross(ab);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals[i] = cb.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals[i + 1] = cb.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals[i + 2] = cb.z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals[i + 3] = cb.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals[i + 4] = cb.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals[i + 5] = cb.z;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals[i + 6] = cb.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals[i + 7] = cb.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals[i + 8] = cb.z;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.normalizeNormals();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tattributes.normal.needsUpdate = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmerge: function merge(geometry, offset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!(geometry && geometry.isBufferGeometry)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (offset === undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\toffset = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar attributes = this.attributes;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var key in attributes) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (geometry.attributes[key] === undefined) continue;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar attribute1 = attributes[key];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar attributeArray1 = attribute1.array;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar attribute2 = geometry.attributes[key];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar attributeArray2 = attribute2.array;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar attributeSize = attribute2.itemSize;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tattributeArray1[j] = attributeArray2[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormalizeNormals: function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vector = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn function normalizeNormals() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar normals = this.attributes.normal;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, il = normals.count; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvector.x = normals.getX(i);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvector.y = normals.getY(i);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvector.z = normals.getZ(i);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvector.normalize();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals.setXYZ(i, vector.x, vector.y, vector.z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}(),\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttoNonIndexed: function toNonIndexed() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction convertBufferAttribute(attribute, indices) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar array = attribute.array;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar itemSize = attribute.itemSize;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar array2 = new array.constructor(indices.length * itemSize);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar index = 0,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    index2 = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = indices.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tindex = indices[i] * itemSize;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var j = 0; j < itemSize; j++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray2[index2++] = array[index++];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn new BufferAttribute(array2, itemSize);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.index === null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar geometry2 = new BufferGeometry();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar indices = this.index.array;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar attributes = this.attributes;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// attributes\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var name in attributes) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar attribute = attributes[name];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar newAttribute = convertBufferAttribute(attribute, indices);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgeometry2.addAttribute(name, newAttribute);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// morph attributes\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar morphAttributes = this.morphAttributes;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (name in morphAttributes) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar morphArray = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, il = morphAttribute.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar attribute = morphAttribute[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar newAttribute = convertBufferAttribute(attribute, indices);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmorphArray.push(newAttribute);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgeometry2.morphAttributes[name] = morphArray;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// groups\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar groups = this.groups;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = groups.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar group = groups[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgeometry2.addGroup(group.start, group.count, group.materialIndex);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn geometry2;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttoJSON: function toJSON() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar data = {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmetadata: {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tversion: 4.5,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttype: 'BufferGeometry',\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgenerator: 'BufferGeometry.toJSON'\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// standard BufferGeometry serialization\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.uuid = this.uuid;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.type = this.type;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.name !== '') data.name = this.name;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Object.keys(this.userData).length > 0) data.userData = this.userData;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.parameters !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar parameters = this.parameters;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var key in parameters) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (parameters[key] !== undefined) data[key] = parameters[key];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn data;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.data = { attributes: {} };\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar index = this.index;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (index !== null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar array = Array.prototype.slice.call(index.array);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.data.index = {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttype: index.array.constructor.name,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray: array\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar attributes = this.attributes;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var key in attributes) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar attribute = attributes[key];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar array = Array.prototype.slice.call(attribute.array);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.data.attributes[key] = {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\titemSize: attribute.itemSize,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttype: attribute.array.constructor.name,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray: array,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormalized: attribute.normalized\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar groups = this.groups;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (groups.length > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.data.groups = JSON.parse(JSON.stringify(groups));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar boundingSphere = this.boundingSphere;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (boundingSphere !== null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.data.boundingSphere = {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcenter: boundingSphere.center.toArray(),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tradius: boundingSphere.radius\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn data;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclone: function clone() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t/*\\\\r\\\\n          // Handle primitives\\\\r\\\\n         \\\\t\\\\t var parameters = this.parameters;\\\\r\\\\n         \\\\t\\\\t if ( parameters !== undefined ) {\\\\r\\\\n         \\\\t\\\\t var values = [];\\\\r\\\\n         \\\\t\\\\t for ( var key in parameters ) {\\\\r\\\\n         \\\\t\\\\t values.push( parameters[ key ] );\\\\r\\\\n         \\\\t\\\\t }\\\\r\\\\n         \\\\t\\\\t var geometry = Object.create( this.constructor.prototype );\\\\r\\\\n          this.constructor.apply( geometry, values );\\\\r\\\\n          return geometry;\\\\r\\\\n         \\\\t\\\\t }\\\\r\\\\n         \\\\t\\\\t return new this.constructor().copy( this );\\\\r\\\\n          */\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn new BufferGeometry().copy(this);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopy: function copy(source) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar name, i, l;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// reset\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.index = null;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.attributes = {};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.morphAttributes = {};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.groups = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingBox = null;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingSphere = null;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// name\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.name = source.name;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// index\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar index = source.index;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (index !== null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.setIndex(index.clone());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// attributes\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar attributes = source.attributes;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (name in attributes) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar attribute = attributes[name];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.addAttribute(name, attribute.clone());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// morph attributes\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar morphAttributes = source.morphAttributes;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (name in morphAttributes) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar array = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, l = morphAttribute.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarray.push(morphAttribute[i].clone());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.morphAttributes[name] = array;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// groups\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar groups = source.groups;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, l = groups.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar group = groups[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.addGroup(group.start, group.count, group.materialIndex);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// bounding box\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar boundingBox = source.boundingBox;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (boundingBox !== null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingBox = boundingBox.clone();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// bounding sphere\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar boundingSphere = source.boundingSphere;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (boundingSphere !== null) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.boundingSphere = boundingSphere.clone();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// draw range\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.drawRange.start = source.drawRange.start;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.drawRange.count = source.drawRange.count;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// user data\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.userData = source.userData;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdispose: function dispose() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.dispatchEvent({ type: 'dispose' });\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author Mugen87 / https://github.com/Mugen87\\\\r\\\\n    * Port from https://github.com/mapbox/earcut (v2.1.2)\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\tvar Earcut = {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttriangulate: function triangulate(data, holeIndices, dim) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdim = dim || 2;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hasHoles = holeIndices && holeIndices.length,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    outerLen = hasHoles ? holeIndices[0] * dim : data.length,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    outerNode = linkedList(data, 0, outerLen, dim, true),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    triangles = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!outerNode) return triangles;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar minX, minY, maxX, maxY, x, y, invSize;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (data.length > 80 * dim) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tminX = maxX = data[0];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tminY = maxY = data[1];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = dim; i < outerLen; i += dim) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tx = data[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ty = data[i + 1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (x < minX) minX = x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (y < minY) minY = y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (x > maxX) maxX = x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (y > maxY) maxY = y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// minX, minY and invSize are later used to transform coords into integers for z-order calculation\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tinvSize = Math.max(maxX - minX, maxY - minY);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tinvSize = invSize !== 0 ? 1 / invSize : 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tearcutLinked(outerNode, triangles, dim, minX, minY, invSize);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn triangles;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\t// create a circular doubly linked list from polygon points in the specified winding order\\\\n\\\\n\\\\t\\\\t\\\\tfunction linkedList(data, start, end, dim, clockwise) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar i, last;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (clockwise === signedArea(data, start, end, dim) > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = start; i < end; i += dim) {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlast = insertNode(i, data[i], data[i + 1], last);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = end - dim; i >= start; i -= dim) {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlast = insertNode(i, data[i], data[i + 1], last);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (last && equals(last, last.next)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tremoveNode(last);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlast = last.next;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn last;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// eliminate colinear or duplicate points\\\\n\\\\n\\\\t\\\\t\\\\tfunction filterPoints(start, end) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!start) return start;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!end) end = start;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar p = start,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    again;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdo {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tagain = false;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tremoveNode(p);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp = end = p.prev;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (p === p.next) break;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tagain = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp = p.next;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} while (again || p !== end);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn end;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// main ear slicing loop which triangulates a polygon (given as a linked list)\\\\n\\\\n\\\\t\\\\t\\\\tfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!ear) return;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// interlink polygon nodes in z-order\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!pass && invSize) indexCurve(ear, minX, minY, invSize);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar stop = ear,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    prev,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    next;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// iterate through ears, slicing them one by one\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\twhile (ear.prev !== ear.next) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tprev = ear.prev;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnext = ear.next;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// cut off the triangle\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttriangles.push(prev.i / dim);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttriangles.push(ear.i / dim);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttriangles.push(next.i / dim);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tremoveNode(ear);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// skipping the next vertice leads to less sliver triangles\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tear = next.next;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tstop = next.next;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcontinue;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tear = next;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// if we looped through the whole remaining polygon and can't find any more ears\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (ear === stop) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// try filtering points and slicing again\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!pass) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tearcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// if this didn't work, try curing all small self-intersections locally\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (pass === 1) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tear = cureLocalIntersections(ear, triangles, dim);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tearcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// as a last resort, try splitting the remaining polygon into two\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (pass === 2) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsplitEarcut(ear, triangles, dim, minX, minY, invSize);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbreak;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// check whether a polygon node forms a valid ear with adjacent nodes\\\\n\\\\n\\\\t\\\\t\\\\tfunction isEar(ear) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a = ear.prev,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b = ear,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    c = ear.next;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (area(a, b, c) >= 0) return false; // reflex, can't be an ear\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// now make sure we don't have other points inside the potential ear\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar p = ear.next.next;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\twhile (p !== ear.prev) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp = p.next;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn true;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tfunction isEarHashed(ear, minX, minY, invSize) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a = ear.prev,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b = ear,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    c = ear.next;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (area(a, b, c) >= 0) return false; // reflex, can't be an ear\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// triangle bbox; min & max are calculated like this for speed\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// z-order range for the current triangle bbox;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar minZ = zOrder(minTX, minTY, minX, minY, invSize),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// first look for points inside the triangle in increasing z-order\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar p = ear.nextZ;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\twhile (p && p.z <= maxZ) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp = p.nextZ;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// then look for points in decreasing z-order\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp = ear.prevZ;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\twhile (p && p.z >= minZ) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp = p.prevZ;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn true;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// go through all polygon nodes and cure small local self-intersections\\\\n\\\\n\\\\t\\\\t\\\\tfunction cureLocalIntersections(start, triangles, dim) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar p = start;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdo {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a = p.prev,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b = p.next.next;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttriangles.push(a.i / dim);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttriangles.push(p.i / dim);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttriangles.push(b.i / dim);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// remove two nodes involved\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tremoveNode(p);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tremoveNode(p.next);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp = start = b;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp = p.next;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} while (p !== start);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn p;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// try splitting polygon into two and triangulate them independently\\\\n\\\\n\\\\t\\\\t\\\\tfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// look for a valid diagonal that divides the polygon into two\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a = start;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdo {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar b = a.next.next;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\twhile (b !== a.prev) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (a.i !== b.i && isValidDiagonal(a, b)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// split the polygon in two by the diagonal\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar c = splitPolygon(a, b);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// filter colinear points around the cuts\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ta = filterPoints(a, a.next);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tc = filterPoints(c, c.next);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// run earcut on each half\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tearcutLinked(a, triangles, dim, minX, minY, invSize);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tearcutLinked(c, triangles, dim, minX, minY, invSize);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tb = b.next;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ta = a.next;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} while (a !== start);\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// link every hole into the outer loop, producing a single-ring polygon without holes\\\\n\\\\n\\\\t\\\\t\\\\tfunction eliminateHoles(data, holeIndices, outerNode, dim) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar queue = [],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    i,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    len,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    start,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    end,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    list;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, len = holeIndices.length; i < len; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tstart = holeIndices[i] * dim;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tend = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlist = linkedList(data, start, end, dim, false);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (list === list.next) list.steiner = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tqueue.push(getLeftmost(list));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tqueue.sort(compareX);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// process holes from left to right\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0; i < queue.length; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\teliminateHole(queue[i], outerNode);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\touterNode = filterPoints(outerNode, outerNode.next);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn outerNode;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tfunction compareX(a, b) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn a.x - b.x;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// find a bridge between vertices that connects hole with an outer ring and and link it\\\\n\\\\n\\\\t\\\\t\\\\tfunction eliminateHole(hole, outerNode) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\touterNode = findHoleBridge(hole, outerNode);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (outerNode) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar b = splitPolygon(outerNode, hole);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfilterPoints(b, b.next);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// David Eberly's algorithm for finding a bridge between hole and outer polygon\\\\n\\\\n\\\\t\\\\t\\\\tfunction findHoleBridge(hole, outerNode) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar p = outerNode,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    hx = hole.x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    hy = hole.y,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    qx = -Infinity,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    m;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// find a segment intersected by a ray from the hole's leftmost point to the left;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// segment's endpoint with lesser x will be potential connection point\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdo {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (x <= hx && x > qx) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tqx = x;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (x === hx) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (hy === p.y) return p;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (hy === p.next.y) return p.next;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tm = p.x < p.next.x ? p : p.next;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp = p.next;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} while (p !== outerNode);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!m) return null;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// look for points inside the triangle of hole point, segment intersection and endpoint;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// if there are no points found, we have a valid connection;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// otherwise choose the point of the minimum angle with the ray as connection point\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar stop = m,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    mx = m.x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    my = m.y,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    tanMin = Infinity,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    tan;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp = m.next;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\twhile (p !== stop) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttan = Math.abs(hy - p.y) / (hx - p.x); // tangential\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tm = p;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttanMin = tan;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp = p.next;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn m;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// interlink polygon nodes in z-order\\\\n\\\\n\\\\t\\\\t\\\\tfunction indexCurve(start, minX, minY, invSize) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar p = start;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdo {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp.prevZ = p.prev;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp.nextZ = p.next;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp = p.next;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} while (p !== start);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp.prevZ.nextZ = null;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp.prevZ = null;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsortLinked(p);\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// Simon Tatham's linked list merge sort algorithm\\\\n\\\\t\\\\t\\\\t// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\\\\n\\\\n\\\\t\\\\t\\\\tfunction sortLinked(list) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar i,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    p,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    q,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    e,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    tail,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    numMerges,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    pSize,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    qSize,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    inSize = 1;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdo {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp = list;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlist = null;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttail = null;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnumMerges = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\twhile (p) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnumMerges++;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tq = p;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpSize = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0; i < inSize; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpSize++;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tq = q.nextZ;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!q) break;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tqSize = inSize;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\twhile (pSize > 0 || qSize > 0 && q) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\te = p;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp = p.nextZ;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpSize--;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\te = q;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tq = q.nextZ;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tqSize--;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (tail) tail.nextZ = e;else list = e;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\te.prevZ = tail;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttail = e;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp = q;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttail.nextZ = null;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tinSize *= 2;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} while (numMerges > 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn list;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// z-order of a point given coords and inverse of the longer side of data bbox\\\\n\\\\n\\\\t\\\\t\\\\tfunction zOrder(x, y, minX, minY, invSize) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// coords are transformed into non-negative 15-bit integer range\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tx = 32767 * (x - minX) * invSize;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ty = 32767 * (y - minY) * invSize;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tx = (x | x << 8) & 0x00FF00FF;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tx = (x | x << 4) & 0x0F0F0F0F;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tx = (x | x << 2) & 0x33333333;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tx = (x | x << 1) & 0x55555555;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ty = (y | y << 8) & 0x00FF00FF;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ty = (y | y << 4) & 0x0F0F0F0F;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ty = (y | y << 2) & 0x33333333;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ty = (y | y << 1) & 0x55555555;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn x | y << 1;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// find the leftmost node of a polygon ring\\\\n\\\\n\\\\t\\\\t\\\\tfunction getLeftmost(start) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar p = start,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    leftmost = start;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdo {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (p.x < leftmost.x) leftmost = p;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp = p.next;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} while (p !== start);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn leftmost;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// check if a point lies within a convex triangle\\\\n\\\\n\\\\t\\\\t\\\\tfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\\\\n\\\\n\\\\t\\\\t\\\\tfunction isValidDiagonal(a, b) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// signed area of a triangle\\\\n\\\\n\\\\t\\\\t\\\\tfunction area(p, q, r) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// check if two points are equal\\\\n\\\\n\\\\t\\\\t\\\\tfunction equals(p1, p2) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn p1.x === p2.x && p1.y === p2.y;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// check if two segments intersect\\\\n\\\\n\\\\t\\\\t\\\\tfunction intersects(p1, q1, p2, q2) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1)) return true;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// check if a polygon diagonal intersects any polygon segments\\\\n\\\\n\\\\t\\\\t\\\\tfunction intersectsPolygon(a, b) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar p = a;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdo {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp = p.next;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} while (p !== a);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn false;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// check if a polygon diagonal is locally inside the polygon\\\\n\\\\n\\\\t\\\\t\\\\tfunction locallyInside(a, b) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// check if the middle point of a polygon diagonal is inside the polygon\\\\n\\\\n\\\\t\\\\t\\\\tfunction middleInside(a, b) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar p = a,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    inside = false,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    px = (a.x + b.x) / 2,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    py = (a.y + b.y) / 2;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdo {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tinside = !inside;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp = p.next;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} while (p !== a);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn inside;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\\\\n\\\\t\\\\t\\\\t// if one belongs to the outer ring and another to a hole, it merges it into a single ring\\\\n\\\\n\\\\t\\\\t\\\\tfunction splitPolygon(a, b) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a2 = new Node(a.i, a.x, a.y),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b2 = new Node(b.i, b.x, b.y),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    an = a.next,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    bp = b.prev;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ta.next = b;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tb.prev = a;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ta2.next = an;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tan.prev = a2;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tb2.next = a2;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ta2.prev = b2;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbp.next = b2;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tb2.prev = bp;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn b2;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t// create a node and optionally link it with previous one (in a circular doubly linked list)\\\\n\\\\n\\\\t\\\\t\\\\tfunction insertNode(i, x, y, last) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar p = new Node(i, x, y);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!last) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp.prev = p;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp.next = p;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp.next = last.next;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp.prev = last;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlast.next.prev = p;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlast.next = p;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn p;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tfunction removeNode(p) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp.next.prev = p.prev;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp.prev.next = p.next;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (p.prevZ) p.prevZ.nextZ = p.nextZ;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (p.nextZ) p.nextZ.prevZ = p.prevZ;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tfunction Node(i, x, y) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// vertice index in coordinates array\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.i = i;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// vertex coordinates\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.x = x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.y = y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// previous and next vertice nodes in a polygon ring\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.prev = null;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.next = null;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// z-order curve value\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.z = null;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// previous and next nodes in z-order\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.prevZ = null;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.nextZ = null;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// indicates whether this is a steiner point\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.steiner = false;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tfunction signedArea(data, start, end, dim) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar sum = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = start, j = end - dim; i < end; i += dim) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tj = i;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn sum;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author zz85 / http://www.lab4games.net/zz85/blog\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\tvar ShapeUtils = {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// calculate area of the contour polygon\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarea: function area(contour) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar n = contour.length;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a = 0.0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var p = n - 1, q = 0; q < n; p = q++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ta += contour[p].x * contour[q].y - contour[q].x * contour[p].y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn a * 0.5;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tisClockWise: function isClockWise(pts) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn ShapeUtils.area(pts) < 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttriangulateShape: function triangulateShape(contour, holes) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar holeIndices = []; // array of hole indices\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tremoveDupEndPts(contour);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddContour(vertices, contour);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar holeIndex = contour.length;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tholes.forEach(removeDupEndPts);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < holes.length; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tholeIndices.push(holeIndex);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tholeIndex += holes[i].length;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddContour(vertices, holes[i]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar triangles = Earcut.triangulate(vertices, holeIndices);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < triangles.length; i += 3) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfaces.push(triangles.slice(i, i + 3));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn faces;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tfunction removeDupEndPts(points) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar l = points.length;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (l > 2 && points[l - 1].equals(points[0])) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoints.pop();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tfunction addContour(vertices, contour) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < contour.length; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertices.push(contour[i].x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertices.push(contour[i].y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author jonobr1 / http://jonobr1.com\\\\r\\\\n    * @author Mugen87 / https://github.com/Mugen87\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\t// ShapeGeometry\\\\n\\\\n\\\\t\\\\t\\\\tfunction ShapeGeometry(shapes, curveSegments) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tGeometry.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.type = 'ShapeGeometry';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif ((typeof curveSegments === 'undefined' ? 'undefined' : _typeof(curveSegments)) === 'object') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.ShapeGeometry: Options parameter has been removed.');\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcurveSegments = curveSegments.curveSegments;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.parameters = {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tshapes: shapes,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcurveSegments: curveSegments\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.mergeVertices();\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tShapeGeometry.prototype = Object.create(Geometry.prototype);\\\\n\\\\t\\\\t\\\\tShapeGeometry.prototype.constructor = ShapeGeometry;\\\\n\\\\n\\\\t\\\\t\\\\tShapeGeometry.prototype.toJSON = function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar data = Geometry.prototype.toJSON.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar shapes = this.parameters.shapes;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn toJSON(shapes, data);\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\t// ShapeBufferGeometry\\\\n\\\\n\\\\t\\\\t\\\\tfunction ShapeBufferGeometry(shapes, curveSegments) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tBufferGeometry.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.type = 'ShapeBufferGeometry';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.parameters = {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tshapes: shapes,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcurveSegments: curveSegments\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcurveSegments = curveSegments || 12;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// buffers\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar indices = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vertices = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar normals = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar uvs = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// helper variables\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar groupStart = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar groupCount = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// allow single and array values for \\\\\\\"shapes\\\\\\\" parameter\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Array.isArray(shapes) === false) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddShape(shapes);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i < shapes.length; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddShape(shapes[i]);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.addGroup(groupStart, groupCount, i); // enables MultiMaterial support\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgroupStart += groupCount;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgroupCount = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// build geometry\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.setIndex(indices);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.addAttribute('position', new Float32BufferAttribute(vertices, 3));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.addAttribute('normal', new Float32BufferAttribute(normals, 3));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.addAttribute('uv', new Float32BufferAttribute(uvs, 2));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// helper functions\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction addShape(shape) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar i, l, shapeHole;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar indexOffset = vertices.length / 3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar points = shape.extractPoints(curveSegments);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar shapeVertices = points.shape;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar shapeHoles = points.holes;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// check direction of vertices\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (ShapeUtils.isClockWise(shapeVertices) === false) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tshapeVertices = shapeVertices.reverse();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, l = shapeHoles.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tshapeHole = shapeHoles[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (ShapeUtils.isClockWise(shapeHole) === true) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tshapeHoles[i] = shapeHole.reverse();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// join vertices of inner and outer paths to a single array\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, l = shapeHoles.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tshapeHole = shapeHoles[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tshapeVertices = shapeVertices.concat(shapeHole);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// vertices, normals, uvs\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, l = shapeVertices.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vertex = shapeVertices[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertices.push(vertex.x, vertex.y, 0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals.push(0, 0, 1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tuvs.push(vertex.x, vertex.y); // world uvs\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// incides\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, l = faces.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar face = faces[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a = face[0] + indexOffset;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar b = face[1] + indexOffset;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar c = face[2] + indexOffset;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tindices.push(a, b, c);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgroupCount += 3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);\\\\n\\\\t\\\\t\\\\tShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;\\\\n\\\\n\\\\t\\\\t\\\\tShapeBufferGeometry.prototype.toJSON = function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar data = BufferGeometry.prototype.toJSON.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar shapes = this.parameters.shapes;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn toJSON(shapes, data);\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\t//\\\\n\\\\n\\\\t\\\\t\\\\tfunction toJSON(shapes, data) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.shapes = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Array.isArray(shapes)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = shapes.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar shape = shapes[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.shapes.push(shape.uuid);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.shapes.push(shapes.uuid);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn data;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author zz85 / http://www.lab4games.net/zz85/blog\\\\r\\\\n    *\\\\r\\\\n    * Creates extruded geometry from a path shape.\\\\r\\\\n    *\\\\r\\\\n    * parameters = {\\\\r\\\\n    *\\\\r\\\\n    *  curveSegments: <int>, // number of points on the curves\\\\r\\\\n    *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\\\\r\\\\n    *  depth: <float>, // Depth to extrude the shape\\\\r\\\\n    *\\\\r\\\\n    *  bevelEnabled: <bool>, // turn on bevel\\\\r\\\\n    *  bevelThickness: <float>, // how deep into the original shape bevel goes\\\\r\\\\n    *  bevelSize: <float>, // how far from shape outline is bevel\\\\r\\\\n    *  bevelSegments: <int>, // number of bevel layers\\\\r\\\\n    *\\\\r\\\\n    *  extrudePath: <THREE.Curve> // curve to extrude shape along\\\\r\\\\n    *\\\\r\\\\n    *  UVGenerator: <Object> // object that provides UV generator functions\\\\r\\\\n    *\\\\r\\\\n    * }\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\t// ExtrudeGeometry\\\\n\\\\n\\\\t\\\\t\\\\tfunction ExtrudeGeometry(shapes, options) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tGeometry.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.type = 'ExtrudeGeometry';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.parameters = {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tshapes: shapes,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\toptions: options\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.mergeVertices();\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tExtrudeGeometry.prototype = Object.create(Geometry.prototype);\\\\n\\\\t\\\\t\\\\tExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\\\\n\\\\n\\\\t\\\\t\\\\tExtrudeGeometry.prototype.toJSON = function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar data = Geometry.prototype.toJSON.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar shapes = this.parameters.shapes;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar options = this.parameters.options;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn toJSON$1(shapes, options, data);\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\t// ExtrudeBufferGeometry\\\\n\\\\n\\\\t\\\\t\\\\tfunction ExtrudeBufferGeometry(shapes, options) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tBufferGeometry.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.type = 'ExtrudeBufferGeometry';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.parameters = {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tshapes: shapes,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\toptions: options\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tshapes = Array.isArray(shapes) ? shapes : [shapes];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar scope = this;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar verticesArray = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar uvArray = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = shapes.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar shape = shapes[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddShape(shape);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// build geometry\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.addAttribute('position', new Float32BufferAttribute(verticesArray, 3));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.addAttribute('uv', new Float32BufferAttribute(uvArray, 2));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.computeVertexNormals();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// functions\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction addShape(shape) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar placeholder = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// options\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar steps = options.steps !== undefined ? options.steps : 1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar depth = options.depth !== undefined ? options.depth : 100;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar extrudePath = options.extrudePath;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// deprecated options\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (options.amount !== undefined) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdepth = options.amount;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar extrudePts,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    extrudeByPath = false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar splineTube, binormal, normal, position2;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (extrudePath) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\textrudePts = extrudePath.getSpacedPoints(steps);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\textrudeByPath = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbevelEnabled = false; // bevels not supported for path extrusion\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// SETUP TNB variables\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// TODO1 - have a .isClosed in spline?\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsplineTube = extrudePath.computeFrenetFrames(steps, false);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbinormal = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormal = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tposition2 = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Safeguards if bevels are not enabled\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!bevelEnabled) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbevelSegments = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbevelThickness = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbevelSize = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Variables initialization\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar ahole, h, hl; // looping of holes\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar shapePoints = shape.extractPoints(curveSegments);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vertices = shapePoints.shape;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar holes = shapePoints.holes;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar reverse = !ShapeUtils.isClockWise(vertices);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (reverse) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertices = vertices.reverse();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (h = 0, hl = holes.length; h < hl; h++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tahole = holes[h];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (ShapeUtils.isClockWise(ahole)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tholes[h] = ahole.reverse();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar faces = ShapeUtils.triangulateShape(vertices, holes);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t/* Vertices */\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar contour = vertices; // vertices has all points but contour has only points of circumference\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (h = 0, hl = holes.length; h < hl; h++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tahole = holes[h];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvertices = vertices.concat(ahole);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction scalePt2(pt, vec, size) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn vec.clone().multiplyScalar(size).add(pt);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar b,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    bs,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    t,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    z,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    vert,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    vlen = vertices.length,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    face,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    flen = faces.length;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Find directions for point movement\\\\n\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction getBevelVec(inPt, inPrev, inNext) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// computes for inPt the corresponding point inPt' on a new contour\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//   shifted by 1 unit (length of normalized vector) to the left\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// if we walk along contour clockwise, this new contour is outside the old one\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// inPt' is the intersection of the two lines parallel to the two\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// good reading for geometry algorithms (here: line-line intersection)\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// http://geomalgorithms.com/a05-_intersect-1.html\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v_prev_x = inPt.x - inPrev.x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    v_prev_y = inPt.y - inPrev.y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v_next_x = inNext.x - inPt.x,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    v_next_y = inNext.y - inPt.y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// check for collinear edges\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Math.abs(collinear0) > Number.EPSILON) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// not collinear\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// length of vectors for normalizing\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v_prev_len = Math.sqrt(v_prev_lensq);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// shift adjacent points by unit vectors to the left\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar ptNextShift_x = inNext.x - v_next_y / v_next_len;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar ptNextShift_y = inNext.y + v_next_x / v_next_len;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// scaling factor for v_prev to intersection point\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// vector from inPt to intersection point\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Don't normalize!, otherwise sharp corners become ugly\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//  but prevent crazy spikes\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (v_trans_lensq <= 2) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn new Vector2(v_trans_x, v_trans_y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tshrink_by = Math.sqrt(v_trans_lensq / 2);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// handle special case of collinear edges\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar direction_eq = false; // assumes: opposite\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (v_prev_x > Number.EPSILON) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (v_next_x > Number.EPSILON) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdirection_eq = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (v_prev_x < -Number.EPSILON) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (v_next_x < -Number.EPSILON) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdirection_eq = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Math.sign(v_prev_y) === Math.sign(v_next_y)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdirection_eq = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (direction_eq) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// console.log(\\\\\\\"Warning: lines are a straight sequence\\\\\\\");\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv_trans_x = -v_prev_y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv_trans_y = v_prev_x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tshrink_by = Math.sqrt(v_prev_lensq);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// console.log(\\\\\\\"Warning: lines are a straight spike\\\\\\\");\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv_trans_x = v_prev_x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv_trans_y = v_prev_y;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tshrink_by = Math.sqrt(v_prev_lensq / 2);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar contourMovements = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (j === il) j = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (k === il) k = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//  (j)---(i)---(k)\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// console.log('i,j,k', i, j , k)\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcontourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar holesMovements = [],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    oneHoleMovements,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    verticesMovements = contourMovements.concat();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (h = 0, hl = holes.length; h < hl; h++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tahole = holes[h];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\toneHoleMovements = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (j === il) j = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (k === il) k = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//  (j)---(i)---(k)\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\toneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tholesMovements.push(oneHoleMovements);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tverticesMovements = verticesMovements.concat(oneHoleMovements);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Loop bevelSegments, 1 for the front, 1 for the back\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (b = 0; b < bevelSegments; b++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//for ( b = bevelSegments; b > 0; b -- ) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tt = b / bevelSegments;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tz = bevelThickness * Math.cos(t * Math.PI / 2);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbs = bevelSize * Math.sin(t * Math.PI / 2);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// contract shape\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, il = contour.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvert = scalePt2(contour[i], contourMovements[i], bs);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv(vert.x, vert.y, -z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// expand holes\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (h = 0, hl = holes.length; h < hl; h++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tahole = holes[h];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\toneHoleMovements = holesMovements[h];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, il = ahole.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvert = scalePt2(ahole[i], oneHoleMovements[i], bs);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv(vert.x, vert.y, -z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbs = bevelSize;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Back facing vertices\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0; i < vlen; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!extrudeByPath) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv(vert.x, vert.y, 0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormal.copy(splineTube.normals[0]).multiplyScalar(vert.x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbinormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tposition2.copy(extrudePts[0]).add(normal).add(binormal);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv(position2.x, position2.y, position2.z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Add stepped vertices...\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Including front facing vertices\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar s;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (s = 1; s <= steps; s++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0; i < vlen; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!extrudeByPath) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv(vert.x, vert.y, depth / steps * s);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormal.copy(splineTube.normals[s]).multiplyScalar(vert.x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbinormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tposition2.copy(extrudePts[s]).add(normal).add(binormal);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv(position2.x, position2.y, position2.z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Add bevel segments planes\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//for ( b = 1; b <= bevelSegments; b ++ ) {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (b = bevelSegments - 1; b >= 0; b--) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tt = b / bevelSegments;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tz = bevelThickness * Math.cos(t * Math.PI / 2);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbs = bevelSize * Math.sin(t * Math.PI / 2);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// contract shape\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, il = contour.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvert = scalePt2(contour[i], contourMovements[i], bs);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv(vert.x, vert.y, depth + z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// expand holes\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (h = 0, hl = holes.length; h < hl; h++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tahole = holes[h];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\toneHoleMovements = holesMovements[h];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0, il = ahole.length; i < il; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvert = scalePt2(ahole[i], oneHoleMovements[i], bs);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!extrudeByPath) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv(vert.x, vert.y, depth + z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tv(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t/* Faces */\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Top and bottom faces\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbuildLidFaces();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Sides faces\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbuildSideFaces();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t/////  Internal functions\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction buildLidFaces() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar start = verticesArray.length / 3;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (bevelEnabled) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar layer = 0; // steps + 1\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar offset = vlen * layer;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Bottom faces\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0; i < flen; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface = faces[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tf3(face[2] + offset, face[1] + offset, face[0] + offset);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlayer = steps + bevelSegments * 2;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\toffset = vlen * layer;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Top faces\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0; i < flen; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface = faces[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tf3(face[0] + offset, face[1] + offset, face[2] + offset);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Bottom faces\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0; i < flen; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface = faces[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tf3(face[2], face[1], face[0]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Top faces\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0; i < flen; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tface = faces[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tf3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tscope.addGroup(start, verticesArray.length / 3 - start, 0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Create faces for the z-sides of the shape\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction buildSideFaces() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar start = verticesArray.length / 3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar layeroffset = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsidewalls(contour, layeroffset);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlayeroffset += contour.length;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (h = 0, hl = holes.length; h < hl; h++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tahole = holes[h];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsidewalls(ahole, layeroffset);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//, true\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlayeroffset += ahole.length;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tscope.addGroup(start, verticesArray.length / 3 - start, 1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction sidewalls(contour, layeroffset) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar j, k;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ti = contour.length;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\twhile (--i >= 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tj = i;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tk = i - 1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (k < 0) k = contour.length - 1;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//console.log('b', i,j, i-1, k,vertices.length);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar s = 0,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    sl = steps + bevelSegments * 2;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (s = 0; s < sl; s++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar slen1 = vlen * s;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar slen2 = vlen * (s + 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a = layeroffset + j + slen1,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    b = layeroffset + k + slen1,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    c = layeroffset + k + slen2,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    d = layeroffset + j + slen2;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tf4(a, b, c, d);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction v(x, y, z) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tplaceholder.push(x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tplaceholder.push(y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tplaceholder.push(z);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction f3(a, b, c) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddVertex(a);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddVertex(b);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddVertex(c);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar nextIndex = verticesArray.length / 3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddUV(uvs[0]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddUV(uvs[1]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddUV(uvs[2]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction f4(a, b, c, d) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddVertex(a);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddVertex(b);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddVertex(d);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddVertex(b);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddVertex(c);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddVertex(d);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar nextIndex = verticesArray.length / 3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddUV(uvs[0]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddUV(uvs[1]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddUV(uvs[3]);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddUV(uvs[1]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddUV(uvs[2]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\taddUV(uvs[3]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction addVertex(index) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tverticesArray.push(placeholder[index * 3 + 0]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tverticesArray.push(placeholder[index * 3 + 1]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tverticesArray.push(placeholder[index * 3 + 2]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction addUV(vector2) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tuvArray.push(vector2.x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tuvArray.push(vector2.y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);\\\\n\\\\t\\\\t\\\\tExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;\\\\n\\\\n\\\\t\\\\t\\\\tExtrudeBufferGeometry.prototype.toJSON = function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar data = BufferGeometry.prototype.toJSON.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar shapes = this.parameters.shapes;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar options = this.parameters.options;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn toJSON$1(shapes, options, data);\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\t//\\\\n\\\\n\\\\t\\\\t\\\\tvar WorldUVGenerator = {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgenerateTopUV: function generateTopUV(geometry, vertices, indexA, indexB, indexC) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a_x = vertices[indexA * 3];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a_y = vertices[indexA * 3 + 1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar b_x = vertices[indexB * 3];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar b_y = vertices[indexB * 3 + 1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar c_x = vertices[indexC * 3];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar c_y = vertices[indexC * 3 + 1];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgenerateSideWallUV: function generateSideWallUV(geometry, vertices, indexA, indexB, indexC, indexD) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a_x = vertices[indexA * 3];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a_y = vertices[indexA * 3 + 1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar a_z = vertices[indexA * 3 + 2];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar b_x = vertices[indexB * 3];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar b_y = vertices[indexB * 3 + 1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar b_z = vertices[indexB * 3 + 2];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar c_x = vertices[indexC * 3];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar c_y = vertices[indexC * 3 + 1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar c_z = vertices[indexC * 3 + 2];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar d_x = vertices[indexD * 3];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar d_y = vertices[indexD * 3 + 1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar d_z = vertices[indexD * 3 + 2];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Math.abs(a_y - b_y) < 0.01) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tfunction toJSON$1(shapes, options, data) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.shapes = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (Array.isArray(shapes)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = shapes.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar shape = shapes[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.shapes.push(shape.uuid);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.shapes.push(shapes.uuid);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn data;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author zz85 / http://www.lab4games.net/zz85/blog\\\\r\\\\n    * Extensible curve object\\\\r\\\\n    *\\\\r\\\\n    * Some common of curve methods:\\\\r\\\\n    * .getPoint( t, optionalTarget ), .getTangent( t )\\\\r\\\\n    * .getPointAt( u, optionalTarget ), .getTangentAt( u )\\\\r\\\\n    * .getPoints(), .getSpacedPoints()\\\\r\\\\n    * .getLength()\\\\r\\\\n    * .updateArcLengths()\\\\r\\\\n    *\\\\r\\\\n    * This following curves inherit from THREE.Curve:\\\\r\\\\n    *\\\\r\\\\n    * -- 2D curves --\\\\r\\\\n    * THREE.ArcCurve\\\\r\\\\n    * THREE.CubicBezierCurve\\\\r\\\\n    * THREE.EllipseCurve\\\\r\\\\n    * THREE.LineCurve\\\\r\\\\n    * THREE.QuadraticBezierCurve\\\\r\\\\n    * THREE.SplineCurve\\\\r\\\\n    *\\\\r\\\\n    * -- 3D curves --\\\\r\\\\n    * THREE.CatmullRomCurve3\\\\r\\\\n    * THREE.CubicBezierCurve3\\\\r\\\\n    * THREE.LineCurve3\\\\r\\\\n    * THREE.QuadraticBezierCurve3\\\\r\\\\n    *\\\\r\\\\n    * A series of curves can be represented as a THREE.CurvePath.\\\\r\\\\n    *\\\\r\\\\n    **/\\\\n\\\\n\\\\t\\\\t\\\\t/**************************************************************\\\\r\\\\n    *\\\\tAbstract Curve base class\\\\r\\\\n    **************************************************************/\\\\n\\\\n\\\\t\\\\t\\\\tfunction Curve() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.type = 'Curve';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.arcLengthDivisions = 200;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tObject.assign(Curve.prototype, {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Virtual base class method to overwrite and implement in subclasses\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t//\\\\t- t [0 .. 1]\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetPoint: function getPoint() /* t, optionalTarget */{\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconsole.warn('THREE.Curve: .getPoint() not implemented.');\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn null;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Get point at relative position in curve according to arc length\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// - u [0 .. 1]\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetPointAt: function getPointAt(u, optionalTarget) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar t = this.getUtoTmapping(u);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.getPoint(t, optionalTarget);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Get sequence of points using getPoint( t )\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetPoints: function getPoints(divisions) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (divisions === undefined) divisions = 5;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar points = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var d = 0; d <= divisions; d++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoints.push(this.getPoint(d / divisions));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn points;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Get sequence of points using getPointAt( u )\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetSpacedPoints: function getSpacedPoints(divisions) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (divisions === undefined) divisions = 5;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar points = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var d = 0; d <= divisions; d++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoints.push(this.getPointAt(d / divisions));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn points;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Get total curve arc length\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetLength: function getLength() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar lengths = this.getLengths();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn lengths[lengths.length - 1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Get list of cumulative segment lengths\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetLengths: function getLengths(divisions) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (divisions === undefined) divisions = this.arcLengthDivisions;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.cacheArcLengths;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.needsUpdate = false;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar cache = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar current,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    last = this.getPoint(0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar p,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    sum = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcache.push(0);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (p = 1; p <= divisions; p++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcurrent = this.getPoint(p / divisions);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsum += current.distanceTo(last);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcache.push(sum);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlast = current;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.cacheArcLengths = cache;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tupdateArcLengths: function updateArcLengths() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.needsUpdate = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.getLengths();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetUtoTmapping: function getUtoTmapping(u, distance) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar arcLengths = this.getLengths();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar i = 0,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    il = arcLengths.length;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar targetArcLength; // The targeted u distance value to get\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (distance) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttargetArcLength = distance;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttargetArcLength = u * arcLengths[il - 1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// binary search for the index with largest value smaller than target u distance\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar low = 0,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    high = il - 1,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    comparison;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\twhile (low <= high) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ti = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcomparison = arcLengths[i] - targetArcLength;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (comparison < 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlow = i + 1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (comparison > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\thigh = i - 1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\thigh = i;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbreak;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// DONE\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ti = high;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (arcLengths[i] === targetArcLength) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn i / (il - 1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// we could get finer grain at lengths, or use simple interpolation between two points\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar lengthBefore = arcLengths[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar lengthAfter = arcLengths[i + 1];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar segmentLength = lengthAfter - lengthBefore;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// determine where we are between the 'before' and 'after' points\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar segmentFraction = (targetArcLength - lengthBefore) / segmentLength;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// add that fractional amount to t\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar t = (i + segmentFraction) / (il - 1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn t;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Returns a unit vector tangent at t\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// In case any sub curve does not implement its tangent derivation,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// 2 points a small delta apart will be used to find its gradient\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// which seems to give a reasonable approximation\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetTangent: function getTangent(t) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar delta = 0.0001;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar t1 = t - delta;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar t2 = t + delta;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Capping in case of danger\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (t1 < 0) t1 = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (t2 > 1) t2 = 1;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar pt1 = this.getPoint(t1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar pt2 = this.getPoint(t2);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vec = pt2.clone().sub(pt1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn vec.normalize();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetTangentAt: function getTangentAt(u) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar t = this.getUtoTmapping(u);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.getTangent(t);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcomputeFrenetFrames: function computeFrenetFrames(segments, closed) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar normal = new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar tangents = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar normals = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar binormals = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar vec = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar mat = new Matrix4();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar i, u, theta;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// compute the tangent vectors for each segment on the curve\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 0; i <= segments; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tu = i / segments;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttangents[i] = this.getTangentAt(u);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttangents[i].normalize();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// select an initial normal vector perpendicular to the first tangent vector,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// and in the direction of the minimum tangent xyz component\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals[0] = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbinormals[0] = new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar min = Number.MAX_VALUE;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar tx = Math.abs(tangents[0].x);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar ty = Math.abs(tangents[0].y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar tz = Math.abs(tangents[0].z);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (tx <= min) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmin = tx;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormal.set(1, 0, 0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (ty <= min) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmin = ty;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormal.set(0, 1, 0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (tz <= min) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormal.set(0, 0, 1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvec.crossVectors(tangents[0], normal).normalize();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals[0].crossVectors(tangents[0], vec);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbinormals[0].crossVectors(tangents[0], normals[0]);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 1; i <= segments; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals[i] = normals[i - 1].clone();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbinormals[i] = binormals[i - 1].clone();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvec.crossVectors(tangents[i - 1], tangents[i]);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (vec.length() > Number.EPSILON) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvec.normalize();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttheta = Math.acos(_Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbinormals[i].crossVectors(tangents[i], normals[i]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (closed === true) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttheta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttheta /= segments;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttheta = -theta;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (i = 1; i <= segments; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// twist a little...\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbinormals[i].crossVectors(tangents[i], normals[i]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttangents: tangents,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tnormals: normals,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbinormals: binormals\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclone: function clone() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn new this.constructor().copy(this);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopy: function copy(source) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.arcLengthDivisions = source.arcLengthDivisions;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttoJSON: function toJSON() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar data = {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmetadata: {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tversion: 4.5,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttype: 'Curve',\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgenerator: 'Curve.toJSON'\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.arcLengthDivisions = this.arcLengthDivisions;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.type = this.type;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn data;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfromJSON: function fromJSON(json) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.arcLengthDivisions = json.arcLengthDivisions;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\tfunction EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.type = 'EllipseCurve';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.aX = aX || 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.aY = aY || 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.xRadius = xRadius || 1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.yRadius = yRadius || 1;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.aStartAngle = aStartAngle || 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.aEndAngle = aEndAngle || 2 * Math.PI;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.aClockwise = aClockwise || false;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.aRotation = aRotation || 0;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tEllipseCurve.prototype = Object.create(Curve.prototype);\\\\n\\\\t\\\\t\\\\tEllipseCurve.prototype.constructor = EllipseCurve;\\\\n\\\\n\\\\t\\\\t\\\\tEllipseCurve.prototype.isEllipseCurve = true;\\\\n\\\\n\\\\t\\\\t\\\\tEllipseCurve.prototype.getPoint = function (t, optionalTarget) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar point = optionalTarget || new Vector2();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar twoPi = Math.PI * 2;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar samePoints = Math.abs(deltaAngle) < Number.EPSILON;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// ensures that deltaAngle is 0 .. 2 PI\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\twhile (deltaAngle < 0) {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdeltaAngle += twoPi;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}while (deltaAngle > twoPi) {\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdeltaAngle -= twoPi;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}if (deltaAngle < Number.EPSILON) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (samePoints) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdeltaAngle = 0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdeltaAngle = twoPi;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.aClockwise === true && !samePoints) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (deltaAngle === twoPi) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdeltaAngle = -twoPi;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdeltaAngle = deltaAngle - twoPi;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar angle = this.aStartAngle + t * deltaAngle;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x = this.aX + this.xRadius * Math.cos(angle);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar y = this.aY + this.yRadius * Math.sin(angle);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.aRotation !== 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar cos = Math.cos(this.aRotation);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar sin = Math.sin(this.aRotation);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar tx = x - this.aX;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar ty = y - this.aY;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Rotate the point about the center of the ellipse.\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tx = tx * cos - ty * sin + this.aX;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ty = tx * sin + ty * cos + this.aY;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn point.set(x, y);\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tEllipseCurve.prototype.copy = function (source) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.prototype.copy.call(this, source);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.aX = source.aX;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.aY = source.aY;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.xRadius = source.xRadius;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.yRadius = source.yRadius;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.aStartAngle = source.aStartAngle;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.aEndAngle = source.aEndAngle;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.aClockwise = source.aClockwise;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.aRotation = source.aRotation;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tEllipseCurve.prototype.toJSON = function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar data = Curve.prototype.toJSON.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.aX = this.aX;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.aY = this.aY;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.xRadius = this.xRadius;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.yRadius = this.yRadius;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.aStartAngle = this.aStartAngle;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.aEndAngle = this.aEndAngle;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.aClockwise = this.aClockwise;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.aRotation = this.aRotation;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn data;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tEllipseCurve.prototype.fromJSON = function (json) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.prototype.fromJSON.call(this, json);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.aX = json.aX;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.aY = json.aY;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.xRadius = json.xRadius;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.yRadius = json.yRadius;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.aStartAngle = json.aStartAngle;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.aEndAngle = json.aEndAngle;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.aClockwise = json.aClockwise;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.aRotation = json.aRotation;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tfunction ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tEllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.type = 'ArcCurve';\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tArcCurve.prototype = Object.create(EllipseCurve.prototype);\\\\n\\\\t\\\\t\\\\tArcCurve.prototype.constructor = ArcCurve;\\\\n\\\\n\\\\t\\\\t\\\\tArcCurve.prototype.isArcCurve = true;\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author zz85 https://github.com/zz85\\\\r\\\\n    *\\\\r\\\\n    * Centripetal CatmullRom Curve - which is useful for avoiding\\\\r\\\\n    * cusps and self-intersections in non-uniform catmull rom curves.\\\\r\\\\n    * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\\\\r\\\\n    *\\\\r\\\\n    * curve.type accepts centripetal(default), chordal and catmullrom\\\\r\\\\n    * curve.tension is used for catmullrom which defaults to 0.5\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\t/*\\\\r\\\\n   Based on an optimized c++ solution in\\\\r\\\\n    - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\\\\r\\\\n    - http://ideone.com/NoEbVM\\\\r\\\\n   \\\\n   This CubicPoly class could be used for reusing some variables and calculations,\\\\r\\\\n   but for three.js curve use, it could be possible inlined and flatten into a single function call\\\\r\\\\n   which can be placed in CurveUtils.\\\\r\\\\n   */\\\\n\\\\n\\\\t\\\\t\\\\tfunction CubicPoly() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar c0 = 0,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    c1 = 0,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    c2 = 0,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    c3 = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t/*\\\\r\\\\n       * Compute coefficients for a cubic polynomial\\\\r\\\\n       *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\\\\r\\\\n       * such that\\\\r\\\\n       *   p(0) = x0, p(1) = x1\\\\r\\\\n       *  and\\\\r\\\\n       *   p'(0) = t0, p'(1) = t1.\\\\r\\\\n       */\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfunction init(x0, x1, t0, t1) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tc0 = x0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tc1 = t0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tc2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tinitCatmullRom: function initCatmullRom(x0, x1, x2, x3, tension) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tinit(x1, x2, tension * (x2 - x0), tension * (x3 - x1));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tinitNonuniformCatmullRom: function initNonuniformCatmullRom(x0, x1, x2, x3, dt0, dt1, dt2) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// compute tangents when parameterized in [t1,t2]\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// rescale tangents for parametrization in [0,1]\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tt1 *= dt1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tt2 *= dt1;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tinit(x1, x2, t1, t2);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcalc: function calc(t) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar t2 = t * t;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar t3 = t2 * t;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t//\\\\n\\\\n\\\\t\\\\t\\\\tvar tmp = new Vector3();\\\\n\\\\t\\\\t\\\\tvar px = new CubicPoly(),\\\\n\\\\t\\\\t\\\\t    py = new CubicPoly(),\\\\n\\\\t\\\\t\\\\t    pz = new CubicPoly();\\\\n\\\\n\\\\t\\\\t\\\\tfunction CatmullRomCurve3(points, closed, curveType, tension) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.type = 'CatmullRomCurve3';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.points = points || [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.closed = closed || false;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.curveType = curveType || 'centripetal';\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.tension = tension || 0.5;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tCatmullRomCurve3.prototype = Object.create(Curve.prototype);\\\\n\\\\t\\\\t\\\\tCatmullRomCurve3.prototype.constructor = CatmullRomCurve3;\\\\n\\\\n\\\\t\\\\t\\\\tCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\\\\n\\\\n\\\\t\\\\t\\\\tCatmullRomCurve3.prototype.getPoint = function (t, optionalTarget) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar point = optionalTarget || new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar points = this.points;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar l = points.length;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar p = (l - (this.closed ? 0 : 1)) * t;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar intPoint = Math.floor(p);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar weight = p - intPoint;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.closed) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tintPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (weight === 0 && intPoint === l - 1) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tintPoint = l - 2;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tweight = 1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar p0, p1, p2, p3; // 4 points\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.closed || intPoint > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp0 = points[(intPoint - 1) % l];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// extrapolate first point\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttmp.subVectors(points[0], points[1]).add(points[0]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp0 = tmp;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp1 = points[intPoint % l];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp2 = points[(intPoint + 1) % l];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.closed || intPoint + 2 < l) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp3 = points[(intPoint + 2) % l];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// extrapolate last point\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tp3 = tmp;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.curveType === 'centripetal' || this.curveType === 'chordal') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// init Centripetal / Chordal Catmull-Rom\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar pow = this.curveType === 'chordal' ? 0.5 : 0.25;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar dt0 = Math.pow(p0.distanceToSquared(p1), pow);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar dt1 = Math.pow(p1.distanceToSquared(p2), pow);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar dt2 = Math.pow(p2.distanceToSquared(p3), pow);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// safety check for repeated points\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (dt1 < 1e-4) dt1 = 1.0;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (dt0 < 1e-4) dt0 = dt1;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (dt2 < 1e-4) dt2 = dt1;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpx.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpy.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else if (this.curveType === 'catmullrom') {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpx.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpy.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoint.set(px.calc(weight), py.calc(weight), pz.calc(weight));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn point;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tCatmullRomCurve3.prototype.copy = function (source) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.prototype.copy.call(this, source);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.points = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = source.points.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar point = source.points[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.points.push(point.clone());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.closed = source.closed;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.curveType = source.curveType;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.tension = source.tension;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tCatmullRomCurve3.prototype.toJSON = function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar data = Curve.prototype.toJSON.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.points = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = this.points.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar point = this.points[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.points.push(point.toArray());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.closed = this.closed;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.curveType = this.curveType;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.tension = this.tension;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn data;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tCatmullRomCurve3.prototype.fromJSON = function (json) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.prototype.fromJSON.call(this, json);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.points = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = json.points.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar point = json.points[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.points.push(new Vector3().fromArray(point));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.closed = json.closed;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.curveType = json.curveType;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.tension = json.tension;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author zz85 / http://www.lab4games.net/zz85/blog\\\\r\\\\n    *\\\\r\\\\n    * Bezier Curves formulas obtained from\\\\r\\\\n    * http://en.wikipedia.org/wiki/Bézier_curve\\\\r\\\\n    */\\\\n\\\\n\\\\t\\\\t\\\\tfunction CatmullRom(t, p0, p1, p2, p3) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v0 = (p2 - p0) * 0.5;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v1 = (p3 - p1) * 0.5;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar t2 = t * t;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar t3 = t * t2;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t//\\\\n\\\\n\\\\t\\\\t\\\\tfunction QuadraticBezierP0(t, p) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar k = 1 - t;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn k * k * p;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tfunction QuadraticBezierP1(t, p) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn 2 * (1 - t) * t * p;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tfunction QuadraticBezierP2(t, p) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn t * t * p;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tfunction QuadraticBezier(t, p0, p1, p2) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t//\\\\n\\\\n\\\\t\\\\t\\\\tfunction CubicBezierP0(t, p) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar k = 1 - t;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn k * k * k * p;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tfunction CubicBezierP1(t, p) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar k = 1 - t;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn 3 * k * k * t * p;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tfunction CubicBezierP2(t, p) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn 3 * (1 - t) * t * t * p;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tfunction CubicBezierP3(t, p) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn t * t * t * p;\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tfunction CubicBezier(t, p0, p1, p2, p3) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tfunction CubicBezierCurve(v0, v1, v2, v3) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.type = 'CubicBezierCurve';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v0 = v0 || new Vector2();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v1 = v1 || new Vector2();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v2 = v2 || new Vector2();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v3 = v3 || new Vector2();\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tCubicBezierCurve.prototype = Object.create(Curve.prototype);\\\\n\\\\t\\\\t\\\\tCubicBezierCurve.prototype.constructor = CubicBezierCurve;\\\\n\\\\n\\\\t\\\\t\\\\tCubicBezierCurve.prototype.isCubicBezierCurve = true;\\\\n\\\\n\\\\t\\\\t\\\\tCubicBezierCurve.prototype.getPoint = function (t, optionalTarget) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar point = optionalTarget || new Vector2();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v0 = this.v0,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    v1 = this.v1,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    v2 = this.v2,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    v3 = this.v3;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoint.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn point;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tCubicBezierCurve.prototype.copy = function (source) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.prototype.copy.call(this, source);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v0.copy(source.v0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v1.copy(source.v1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v2.copy(source.v2);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v3.copy(source.v3);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tCubicBezierCurve.prototype.toJSON = function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar data = Curve.prototype.toJSON.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.v0 = this.v0.toArray();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.v1 = this.v1.toArray();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.v2 = this.v2.toArray();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.v3 = this.v3.toArray();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn data;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tCubicBezierCurve.prototype.fromJSON = function (json) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.prototype.fromJSON.call(this, json);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v0.fromArray(json.v0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v1.fromArray(json.v1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v2.fromArray(json.v2);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v3.fromArray(json.v3);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tfunction CubicBezierCurve3(v0, v1, v2, v3) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.type = 'CubicBezierCurve3';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v0 = v0 || new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v1 = v1 || new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v2 = v2 || new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v3 = v3 || new Vector3();\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tCubicBezierCurve3.prototype = Object.create(Curve.prototype);\\\\n\\\\t\\\\t\\\\tCubicBezierCurve3.prototype.constructor = CubicBezierCurve3;\\\\n\\\\n\\\\t\\\\t\\\\tCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\\\\n\\\\n\\\\t\\\\t\\\\tCubicBezierCurve3.prototype.getPoint = function (t, optionalTarget) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar point = optionalTarget || new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v0 = this.v0,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    v1 = this.v1,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    v2 = this.v2,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    v3 = this.v3;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoint.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn point;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tCubicBezierCurve3.prototype.copy = function (source) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.prototype.copy.call(this, source);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v0.copy(source.v0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v1.copy(source.v1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v2.copy(source.v2);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v3.copy(source.v3);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tCubicBezierCurve3.prototype.toJSON = function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar data = Curve.prototype.toJSON.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.v0 = this.v0.toArray();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.v1 = this.v1.toArray();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.v2 = this.v2.toArray();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.v3 = this.v3.toArray();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn data;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tCubicBezierCurve3.prototype.fromJSON = function (json) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.prototype.fromJSON.call(this, json);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v0.fromArray(json.v0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v1.fromArray(json.v1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v2.fromArray(json.v2);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v3.fromArray(json.v3);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tfunction LineCurve(v1, v2) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.type = 'LineCurve';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v1 = v1 || new Vector2();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v2 = v2 || new Vector2();\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tLineCurve.prototype = Object.create(Curve.prototype);\\\\n\\\\t\\\\t\\\\tLineCurve.prototype.constructor = LineCurve;\\\\n\\\\n\\\\t\\\\t\\\\tLineCurve.prototype.isLineCurve = true;\\\\n\\\\n\\\\t\\\\t\\\\tLineCurve.prototype.getPoint = function (t, optionalTarget) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar point = optionalTarget || new Vector2();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (t === 1) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoint.copy(this.v2);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoint.copy(this.v2).sub(this.v1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoint.multiplyScalar(t).add(this.v1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn point;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\t// Line curve is linear, so we can overwrite default getPointAt\\\\n\\\\n\\\\t\\\\t\\\\tLineCurve.prototype.getPointAt = function (u, optionalTarget) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.getPoint(u, optionalTarget);\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tLineCurve.prototype.getTangent = function () /* t */{\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar tangent = this.v2.clone().sub(this.v1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn tangent.normalize();\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tLineCurve.prototype.copy = function (source) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.prototype.copy.call(this, source);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v1.copy(source.v1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v2.copy(source.v2);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tLineCurve.prototype.toJSON = function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar data = Curve.prototype.toJSON.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.v1 = this.v1.toArray();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.v2 = this.v2.toArray();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn data;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tLineCurve.prototype.fromJSON = function (json) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.prototype.fromJSON.call(this, json);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v1.fromArray(json.v1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v2.fromArray(json.v2);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tfunction LineCurve3(v1, v2) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.type = 'LineCurve3';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v1 = v1 || new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v2 = v2 || new Vector3();\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tLineCurve3.prototype = Object.create(Curve.prototype);\\\\n\\\\t\\\\t\\\\tLineCurve3.prototype.constructor = LineCurve3;\\\\n\\\\n\\\\t\\\\t\\\\tLineCurve3.prototype.isLineCurve3 = true;\\\\n\\\\n\\\\t\\\\t\\\\tLineCurve3.prototype.getPoint = function (t, optionalTarget) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar point = optionalTarget || new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (t === 1) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoint.copy(this.v2);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t} else {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoint.copy(this.v2).sub(this.v1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoint.multiplyScalar(t).add(this.v1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn point;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\t// Line curve is linear, so we can overwrite default getPointAt\\\\n\\\\n\\\\t\\\\t\\\\tLineCurve3.prototype.getPointAt = function (u, optionalTarget) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.getPoint(u, optionalTarget);\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tLineCurve3.prototype.copy = function (source) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.prototype.copy.call(this, source);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v1.copy(source.v1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v2.copy(source.v2);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tLineCurve3.prototype.toJSON = function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar data = Curve.prototype.toJSON.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.v1 = this.v1.toArray();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.v2 = this.v2.toArray();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn data;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tLineCurve3.prototype.fromJSON = function (json) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.prototype.fromJSON.call(this, json);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v1.fromArray(json.v1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v2.fromArray(json.v2);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tfunction QuadraticBezierCurve(v0, v1, v2) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.type = 'QuadraticBezierCurve';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v0 = v0 || new Vector2();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v1 = v1 || new Vector2();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v2 = v2 || new Vector2();\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tQuadraticBezierCurve.prototype = Object.create(Curve.prototype);\\\\n\\\\t\\\\t\\\\tQuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\\\\n\\\\n\\\\t\\\\t\\\\tQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\\\\n\\\\n\\\\t\\\\t\\\\tQuadraticBezierCurve.prototype.getPoint = function (t, optionalTarget) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar point = optionalTarget || new Vector2();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v0 = this.v0,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    v1 = this.v1,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    v2 = this.v2;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoint.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn point;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tQuadraticBezierCurve.prototype.copy = function (source) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.prototype.copy.call(this, source);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v0.copy(source.v0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v1.copy(source.v1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v2.copy(source.v2);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tQuadraticBezierCurve.prototype.toJSON = function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar data = Curve.prototype.toJSON.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.v0 = this.v0.toArray();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.v1 = this.v1.toArray();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.v2 = this.v2.toArray();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn data;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tQuadraticBezierCurve.prototype.fromJSON = function (json) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.prototype.fromJSON.call(this, json);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v0.fromArray(json.v0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v1.fromArray(json.v1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v2.fromArray(json.v2);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tfunction QuadraticBezierCurve3(v0, v1, v2) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.type = 'QuadraticBezierCurve3';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v0 = v0 || new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v1 = v1 || new Vector3();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v2 = v2 || new Vector3();\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tQuadraticBezierCurve3.prototype = Object.create(Curve.prototype);\\\\n\\\\t\\\\t\\\\tQuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;\\\\n\\\\n\\\\t\\\\t\\\\tQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\\\\n\\\\n\\\\t\\\\t\\\\tQuadraticBezierCurve3.prototype.getPoint = function (t, optionalTarget) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar point = optionalTarget || new Vector3();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar v0 = this.v0,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    v1 = this.v1,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    v2 = this.v2;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoint.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn point;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tQuadraticBezierCurve3.prototype.copy = function (source) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.prototype.copy.call(this, source);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v0.copy(source.v0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v1.copy(source.v1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v2.copy(source.v2);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tQuadraticBezierCurve3.prototype.toJSON = function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar data = Curve.prototype.toJSON.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.v0 = this.v0.toArray();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.v1 = this.v1.toArray();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.v2 = this.v2.toArray();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn data;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tQuadraticBezierCurve3.prototype.fromJSON = function (json) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.prototype.fromJSON.call(this, json);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v0.fromArray(json.v0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v1.fromArray(json.v1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.v2.fromArray(json.v2);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tfunction SplineCurve(points /* array of Vector2 */) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.type = 'SplineCurve';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.points = points || [];\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tSplineCurve.prototype = Object.create(Curve.prototype);\\\\n\\\\t\\\\t\\\\tSplineCurve.prototype.constructor = SplineCurve;\\\\n\\\\n\\\\t\\\\t\\\\tSplineCurve.prototype.isSplineCurve = true;\\\\n\\\\n\\\\t\\\\t\\\\tSplineCurve.prototype.getPoint = function (t, optionalTarget) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar point = optionalTarget || new Vector2();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar points = this.points;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar p = (points.length - 1) * t;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar intPoint = Math.floor(p);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar weight = p - intPoint;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar p0 = points[intPoint === 0 ? intPoint : intPoint - 1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar p1 = points[intPoint];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoint.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn point;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tSplineCurve.prototype.copy = function (source) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.prototype.copy.call(this, source);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.points = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = source.points.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar point = source.points[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.points.push(point.clone());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tSplineCurve.prototype.toJSON = function () {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar data = Curve.prototype.toJSON.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.points = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = this.points.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar point = this.points[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.points.push(point.toArray());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn data;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tSplineCurve.prototype.fromJSON = function (json) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.prototype.fromJSON.call(this, json);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.points = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = json.points.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar point = json.points[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.points.push(new Vector2().fromArray(point));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t};\\\\n\\\\n\\\\t\\\\t\\\\tvar Curves = /*#__PURE__*/Object.freeze({\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tArcCurve: ArcCurve,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCatmullRomCurve3: CatmullRomCurve3,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCubicBezierCurve: CubicBezierCurve,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCubicBezierCurve3: CubicBezierCurve3,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tEllipseCurve: EllipseCurve,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tLineCurve: LineCurve,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tLineCurve3: LineCurve3,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tQuadraticBezierCurve: QuadraticBezierCurve,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tQuadraticBezierCurve3: QuadraticBezierCurve3,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tSplineCurve: SplineCurve\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author zz85 / http://www.lab4games.net/zz85/blog\\\\r\\\\n    *\\\\r\\\\n    **/\\\\n\\\\n\\\\t\\\\t\\\\t/**************************************************************\\\\r\\\\n    *\\\\tCurved Path - a curve path is simply a array of connected\\\\r\\\\n    *  curves, but retains the api of a curve\\\\r\\\\n    **************************************************************/\\\\n\\\\n\\\\t\\\\t\\\\tfunction CurvePath() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.type = 'CurvePath';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.curves = [];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.autoClose = false; // Automatically closes the path\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tCurvePath.prototype = Object.assign(Object.create(Curve.prototype), {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconstructor: CurvePath,\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tadd: function add(curve) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.curves.push(curve);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tclosePath: function closePath() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Add a line curve if start and end of lines are not connected\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar startPoint = this.curves[0].getPoint(0);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar endPoint = this.curves[this.curves.length - 1].getPoint(1);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!startPoint.equals(endPoint)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.curves.push(new LineCurve(endPoint, startPoint));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// To get accurate point with reference to\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// entire path distance at time t,\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// following has to be done:\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// 1. Length of each sub path have to be known\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// 2. Locate and identify type of curve\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// 3. Get t for the curve\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// 4. Return curve.getPointAt(t')\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetPoint: function getPoint(t) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar d = t * this.getLength();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar curveLengths = this.getCurveLengths();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar i = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// To think about boundaries points.\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\twhile (i < curveLengths.length) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (curveLengths[i] >= d) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar diff = curveLengths[i] - d;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar curve = this.curves[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar segmentLength = curve.getLength();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn curve.getPointAt(u);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ti++;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn null;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// loop where sum != 0, sum > d , sum+1 <d\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// getPoint() depends on getLength\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetLength: function getLength() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar lens = this.getCurveLengths();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn lens[lens.length - 1];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// cacheLengths must be recalculated.\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tupdateArcLengths: function updateArcLengths() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.needsUpdate = true;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.cacheLengths = null;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.getCurveLengths();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Compute lengths and cache them\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// We cannot overwrite getLengths() because UtoT mapping uses it.\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetCurveLengths: function getCurveLengths() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// We use cache values if curves and cache array are same length\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.cacheLengths && this.cacheLengths.length === this.curves.length) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this.cacheLengths;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Get length of sub-curve\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// Push sums into cached array\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar lengths = [],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    sums = 0;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = this.curves.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsums += this.curves[i].getLength();\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlengths.push(sums);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.cacheLengths = lengths;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn lengths;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetSpacedPoints: function getSpacedPoints(divisions) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (divisions === undefined) divisions = 40;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar points = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0; i <= divisions; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoints.push(this.getPoint(i / divisions));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.autoClose) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoints.push(points[0]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn points;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetPoints: function getPoints(divisions) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdivisions = divisions || 12;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar points = [],\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t    last;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, curves = this.curves; i < curves.length; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar curve = curves[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar pts = curve.getPoints(resolution);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var j = 0; j < pts.length; j++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar point = pts[j];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (last && last.equals(point)) continue; // ensures no consecutive points are duplicates\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoints.push(point);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlast = point;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tpoints.push(points[0]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn points;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopy: function copy(source) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.prototype.copy.call(this, source);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.curves = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = source.curves.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar curve = source.curves[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.curves.push(curve.clone());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.autoClose = source.autoClose;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttoJSON: function toJSON() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar data = Curve.prototype.toJSON.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.autoClose = this.autoClose;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.curves = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = this.curves.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar curve = this.curves[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.curves.push(curve.toJSON());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn data;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfromJSON: function fromJSON(json) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurve.prototype.fromJSON.call(this, json);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.autoClose = json.autoClose;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.curves = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = json.curves.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar curve = json.curves[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.curves.push(new Curves[curve.type]().fromJSON(curve));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author zz85 / http://www.lab4games.net/zz85/blog\\\\r\\\\n    * Creates free form 2d path using series of points, lines or curves.\\\\r\\\\n    **/\\\\n\\\\n\\\\t\\\\t\\\\tfunction Path(points) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurvePath.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.type = 'Path';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.currentPoint = new Vector2();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (points) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.setFromPoints(points);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tPath.prototype = Object.assign(Object.create(CurvePath.prototype), {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconstructor: Path,\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsetFromPoints: function setFromPoints(points) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.moveTo(points[0].x, points[0].y);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 1, l = points.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.lineTo(points[i].x, points[i].y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tmoveTo: function moveTo(x, y) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tlineTo: function lineTo(x, y) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.curves.push(curve);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.currentPoint.set(x, y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tquadraticCurveTo: function quadraticCurveTo(aCPx, aCPy, aX, aY) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.curves.push(curve);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.currentPoint.set(aX, aY);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tbezierCurveTo: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.curves.push(curve);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.currentPoint.set(aX, aY);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tsplineThru: function splineThru(pts /*Array of Vector*/) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar npts = [this.currentPoint.clone()].concat(pts);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar curve = new SplineCurve(npts);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.curves.push(curve);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.currentPoint.copy(pts[pts.length - 1]);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tarc: function arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x0 = this.currentPoint.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar y0 = this.currentPoint.y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tabsarc: function absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tellipse: function ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar x0 = this.currentPoint.x;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar y0 = this.currentPoint.y;\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tabsellipse: function absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (this.curves.length > 0) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// if a previous curve is present, attempt to join\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar firstPoint = curve.getPoint(0);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tif (!firstPoint.equals(this.currentPoint)) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.lineTo(firstPoint.x, firstPoint.y);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.curves.push(curve);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar lastPoint = curve.getPoint(1);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.currentPoint.copy(lastPoint);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopy: function copy(source) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurvePath.prototype.copy.call(this, source);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.currentPoint.copy(source.currentPoint);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttoJSON: function toJSON() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar data = CurvePath.prototype.toJSON.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.currentPoint = this.currentPoint.toArray();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn data;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfromJSON: function fromJSON(json) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tCurvePath.prototype.fromJSON.call(this, json);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.currentPoint.fromArray(json.currentPoint);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\t/**\\\\r\\\\n    * @author zz85 / http://www.lab4games.net/zz85/blog\\\\r\\\\n    * Defines a 2d shape plane using paths.\\\\r\\\\n    **/\\\\n\\\\n\\\\t\\\\t\\\\t// STEP 1 Create a path.\\\\n\\\\t\\\\t\\\\t// STEP 2 Turn path into shape.\\\\n\\\\t\\\\t\\\\t// STEP 3 ExtrudeGeometry takes in Shape/Shapes\\\\n\\\\t\\\\t\\\\t// STEP 3a - Extract points from each shape, turn to vertices\\\\n\\\\t\\\\t\\\\t// STEP 3b - Triangulate each shape, add faces.\\\\n\\\\n\\\\t\\\\t\\\\tfunction Shape(points) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tPath.call(this, points);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.uuid = _Math.generateUUID();\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.type = 'Shape';\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.holes = [];\\\\n\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\tShape.prototype = Object.assign(Object.create(Path.prototype), {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tconstructor: Shape,\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tgetPointsHoles: function getPointsHoles(divisions) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar holesPts = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = this.holes.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tholesPts[i] = this.holes[i].getPoints(divisions);\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn holesPts;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t// get points of shape and holes (keypoints based on segments parameter)\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\textractPoints: function extractPoints(divisions) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tshape: this.getPoints(divisions),\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tholes: this.getPointsHoles(divisions)\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t};\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tcopy: function copy(source) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tPath.prototype.copy.call(this, source);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.holes = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = source.holes.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hole = source.holes[i];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.holes.push(hole.clone());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\ttoJSON: function toJSON() {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar data = Path.prototype.toJSON.call(this);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.uuid = this.uuid;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.holes = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = this.holes.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hole = this.holes[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tdata.holes.push(hole.toJSON());\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn data;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t},\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfromJSON: function fromJSON(json) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tPath.prototype.fromJSON.call(this, json);\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.uuid = json.uuid;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.holes = [];\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tfor (var i = 0, l = json.holes.length; i < l; i++) {\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tvar hole = json.holes[i];\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\tthis.holes.push(new Path().fromJSON(hole));\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t\\\\treturn this;\\\\n\\\\t\\\\t\\\\t\\\\t\\\\t\\\\t}\\\\n\\\\n\\\\t\\\\t\\\\t});\\\\n\\\\n\\\\t\\\\t\\\\texports.Box3 = Box3;\\\\n\\\\t\\\\t\\\\texports.BufferAttribute = BufferAttribute;\\\\n\\\\t\\\\t\\\\texports.BufferGeometry = BufferGeometry;\\\\n\\\\t\\\\t\\\\texports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;\\\\n\\\\t\\\\t\\\\texports.ExtrudeGeometry = ExtrudeGeometry;\\\\n\\\\t\\\\t\\\\texports.Float32BufferAttribute = Float32BufferAttribute;\\\\n\\\\t\\\\t\\\\texports.Float64BufferAttribute = Float64BufferAttribute;\\\\n\\\\t\\\\t\\\\texports.Int16BufferAttribute = Int16BufferAttribute;\\\\n\\\\t\\\\t\\\\texports.Int32BufferAttribute = Int32BufferAttribute;\\\\n\\\\t\\\\t\\\\texports.Int8BufferAttribute = Int8BufferAttribute;\\\\n\\\\t\\\\t\\\\texports.Shape = Shape;\\\\n\\\\t\\\\t\\\\texports.Path = Path;\\\\n\\\\t\\\\t\\\\texports.ShapeBufferGeometry = ShapeBufferGeometry;\\\\n\\\\t\\\\t\\\\texports.ShapeGeometry = ShapeGeometry;\\\\n\\\\t\\\\t\\\\texports.Uint16BufferAttribute = Uint16BufferAttribute;\\\\n\\\\t\\\\t\\\\texports.Uint32BufferAttribute = Uint32BufferAttribute;\\\\n\\\\t\\\\t\\\\texports.Uint8BufferAttribute = Uint8BufferAttribute;\\\\n\\\\t\\\\t\\\\texports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;\\\\n\\\\t\\\\t\\\\texports.Vector2 = Vector2;\\\\n\\\\t\\\\t\\\\texports.Vector3 = Vector3;\\\\n\\\\t\\\\t\\\\texports.Matrix4 = Matrix4;\\\\n\\\\n\\\\t\\\\t\\\\tObject.defineProperty(exports, '__esModule', { value: true });\\\\n});\\\\n\\\\n//# sourceURL=webpack:///./lib/threejs/extrudeAndBufferAttribute.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/babel-loader/lib/index.js?!./lib/threejs/createBigBuildingByUearth.worker.js\\\":\\n/*!*************************************************************************************************!*\\\\\\n  !*** ./node_modules/babel-loader/lib??ref--5!./lib/threejs/createBigBuildingByUearth.worker.js ***!\\n  \\\\*************************************************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"\\\\n\\\\nvar THREE = __webpack_require__(/*! ./extrudeAndBufferAttribute.js */ \\\\\\\"./lib/threejs/extrudeAndBufferAttribute.js\\\\\\\");\\\\n__webpack_require__(/*! ./BufferGeometryUtils.js */ \\\\\\\"./lib/threejs/BufferGeometryUtils.js\\\\\\\");\\\\nself.addEventListener('message', function (event) {\\\\n    return processData(event.data);\\\\n});\\\\nvar pickIdStartNum = 0x000C0000;\\\\nfunction processData(e) {\\\\n    var data = e.data;\\\\n    // e.matrix是最终建筑的父节点的matrix\\\\n    var geoArray = createGeometryArr(data, e.matrix, e.useAroundUV);\\\\n    //合并geometry\\\\n    var res = THREE.BufferGeometryUtils1.mergeBufferGeometries1(geoArray, 10000000, true);\\\\n    for (var i = 0, len = res.length; i < len; i++) {\\\\n        var geometry = res[i];\\\\n        var resPos = geometry.attributes.position.array;\\\\n        var nums = resPos.length / 3;\\\\n        var resNormal = geometry.attributes.normal.array;\\\\n        var uv = geometry.attributes.uv.array;\\\\n        var uv2 = geometry.attributes.uv2.array;\\\\n        var uv3 = geometry.attributes.uv3.array;\\\\n        var id = geometry.attributes.id ? geometry.attributes.id.array : new Float32Array(nums);\\\\n        var vis = geometry.attributes.vis ? geometry.attributes.vis.array : new Float32Array(nums);\\\\n        var _needMerge = geometry._needMerge || {};\\\\n        var groups = geometry.groups;\\\\n        var messageKeys = { position: resPos, normal: resNormal, uv: uv, uv2: uv2, uv3: uv3, groups: groups, id: id, vis: vis, _needMerge: _needMerge };\\\\n        var messageValues = [resPos.buffer, resNormal.buffer, uv.buffer, uv2.buffer, uv3.buffer, id.buffer, vis.buffer];\\\\n        if (geometry.attributes.uv8) {\\\\n            var uv8 = geometry.attributes.uv8.array;\\\\n            messageKeys.uv8 = uv8;\\\\n            messageValues.push(uv8.buffer);\\\\n        }\\\\n        self.postMessage(messageKeys, messageValues);\\\\n    }\\\\n}\\\\n//基于一个matrix的相对坐标转换为基于另一个matrix的相对坐标\\\\nfunction _processGeometry(geometry, oldMatrix, newMatrix, offsetHeight) {\\\\n    var posArr = geometry.attributes.position.array;\\\\n    var count = geometry.attributes.position.count;\\\\n    for (var i = 0; i < count; i++) {\\\\n        var worldPos = new THREE.Vector3(posArr[i * 3], posArr[i * 3 + 1] + offsetHeight, posArr[i * 3 + 2]).applyMatrix4(oldMatrix);\\\\n        var newLocalPos = worldPos.applyMatrix4(new THREE.Matrix4().getInverse(newMatrix));\\\\n        posArr[i * 3] = newLocalPos.x;\\\\n        posArr[i * 3 + 1] = newLocalPos.y;\\\\n        posArr[i * 3 + 2] = newLocalPos.z;\\\\n    }\\\\n}\\\\nfunction createGeometryArr(data, matrix, useAroundUV) {\\\\n    var geoArray = [];\\\\n    for (var i = 0, len = data.length; i < len; i++) {\\\\n        var positions = data[i].positions;\\\\n        var holes = data[i].holes;\\\\n        var height = data[i].height;\\\\n        var id = data[i].id;\\\\n        var vis = data[i].vis;\\\\n        // var offsetHeight = data[i].offsetHeight;\\\\n        var buildingTextureSize = data[i].buildingTextureSize;\\\\n        var buildingMaskTextureSize = data[i].buildingMaskTextureSize;\\\\n        var buildingWindowTextureSize = data[i].buildingWindowTextureSize;\\\\n        var referenceNodeMatrix = data[i].refenenceNode;\\\\n        id = pickIdStartNum + id;\\\\n        var geometry = createBuilding(positions, holes, height, buildingTextureSize, buildingMaskTextureSize, buildingWindowTextureSize, id, useAroundUV, vis);\\\\n        //referenceNodeMatrix 拔楼时的自身参考点 matrix 建筑合并后要放到的节点的matrix 需要从前一个参考点下的相对坐标转为后一个参考点下的相对坐标\\\\n        _processGeometry(geometry, new THREE.Matrix4().fromArray(referenceNodeMatrix), new THREE.Matrix4().fromArray(matrix), 0);\\\\n        geoArray.push(geometry);\\\\n    }\\\\n    return geoArray;\\\\n}\\\\n\\\\nfunction createBuilding(positions, holes, height, buildingTextureSize, buildingMaskTextureSize, buildingWindowTextureSize, id, useAroundUV) {\\\\n    var vis = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;\\\\n\\\\n    var vertices = [];\\\\n    //存放y轴的值\\\\n    var yValue = 0;\\\\n    for (var i = 0; i < positions.length / 3; i++) {\\\\n        if (yValue === 0) {\\\\n            yValue = positions[3 * i + 1];\\\\n        }\\\\n        //设置y为0\\\\n        var v = new THREE.Vector3(positions[3 * i], positions[3 * i + 2], 0);\\\\n        vertices.push(v);\\\\n    }\\\\n    var shape = new THREE.Shape(vertices);\\\\n    if (holes) {\\\\n        for (var j = 0; j < holes.length; j++) {\\\\n            var hv = [];\\\\n            var hole = holes[j];\\\\n            for (var k = 0; k < hole.length / 3; k++) {\\\\n                var _v = new THREE.Vector3(hole[3 * k], hole[3 * k + 2], 0);\\\\n                hv.push(_v);\\\\n            }\\\\n            var holePath = new THREE.Path(hv);\\\\n            shape.holes.push(holePath);\\\\n        }\\\\n    }\\\\n\\\\n    var geo = new THREE.BufferGeometry();\\\\n    geo.topUV = []; //top始终是不变的,目前通过包围盒计算\\\\n    geo.sideUV1 = []; //u:0-1,v:0-1;\\\\n    geo.sideUV2 = []; //u:0-1,v:0-y;\\\\n    geo.sideUV3 = []; //u:0-x,v:0-1;\\\\n    geo.sideUV4 = []; //u:0-x,v:0-y;\\\\n    //mask\\\\n    geo.sideUV5 = []; //u:0-1,v:0-y;\\\\n    geo.sideUV6 = []; //u:0-x,v:0-1;\\\\n    geo.sideUV7 = []; //u:0-x,v:0-y;\\\\n    // 环绕纹理使用的UV，暂时用法\\\\n    geo.sideUV8 = [];\\\\n    // geo.sidePerimeter = shape.getLength();// 几何体侧边周长\\\\n    var geometry = new THREE.ExtrudeBufferGeometry(shape, {\\\\n        // extrudePath: path,\\\\n        steps: 1,\\\\n        depth: height,\\\\n        material: 0,\\\\n        extrudeMaterial: 1,\\\\n        bevelEnabled: false,\\\\n        UVGenerator: _uvgenerator(geo, height, vertices, buildingTextureSize, buildingMaskTextureSize, buildingWindowTextureSize, useAroundUV)\\\\n    });\\\\n\\\\n    //继续转换顶点，这里确实有点绕, 获取真正的底面数组\\\\n    var normalArray = geometry.attributes.normal.array;\\\\n    for (var _i = 0, array = geometry.attributes.position.array, length = array.length; _i < length; _i += 3) {\\\\n        //从xy平面转换到xz平面\\\\n        var y = array[_i + 1];\\\\n        array[_i + 1] = array[_i + 2] + yValue; //垂直方向;\\\\n        array[_i + 2] = y;\\\\n        //继续转换法线，这里threejs会进行内部转换,所以必须转回来\\\\n        normalArray[_i] = -normalArray[_i];\\\\n        normalArray[_i + 1] = -normalArray[_i + 1];\\\\n        normalArray[_i + 2] = -normalArray[_i + 2];\\\\n        var y1 = normalArray[_i + 1];\\\\n        normalArray[_i + 1] = normalArray[_i + 2];\\\\n        normalArray[_i + 2] = y1;\\\\n    }\\\\n    geometry.addAttribute('uv', new THREE.BufferAttribute(arrayToFloat32Array(geo.topUV.concat(geo.sideUV2)), 2));\\\\n    geometry.addAttribute('uv2', new THREE.BufferAttribute(arrayToFloat32Array(geo.topUV.concat(geo.sideUV1)), 2));\\\\n    geometry.addAttribute('uv3', new THREE.BufferAttribute(arrayToFloat32Array(geo.topUV.concat(geo.sideUV4)), 2));\\\\n    if (useAroundUV) {\\\\n        geometry.addAttribute('uv8', new THREE.BufferAttribute(arrayToFloat32Array(geo.topUV.concat(geo.sideUV8)), 2));\\\\n    }\\\\n    if (id !== undefined) {\\\\n        var idArray = new Float32Array(geometry.attributes.position.count);\\\\n        idArray.fill(id);\\\\n        geometry.addAttribute('id', new THREE.BufferAttribute(idArray, 1));\\\\n    }\\\\n    var visArray = new Float32Array(geometry.attributes.position.count);\\\\n    visArray.fill(vis);\\\\n    geometry.addAttribute('vis', new THREE.BufferAttribute(visArray, 1));\\\\n    return geometry;\\\\n}\\\\n\\\\n//为building计算uv\\\\nfunction _uvgenerator(geo, height, vertices, buildingTextureSize, buildingMaskTextureSize, buildingWindowTextureSize, useAroundUV) {\\\\n    //计算包围盒\\\\n    if (geo.boundingBox === null) {\\\\n        geo.boundingBox = new THREE.Box3();\\\\n    }\\\\n    geo.boundingBox.setFromPoints(vertices);\\\\n    var minX = geo.boundingBox.min.x,\\\\n        maxX = geo.boundingBox.max.x,\\\\n        minY = geo.boundingBox.min.y,\\\\n        maxY = geo.boundingBox.max.y,\\\\n        minZ = 0,\\\\n        maxZ = height;\\\\n    var dx = buildingTextureSize[0];\\\\n    var dy = buildingTextureSize[1];\\\\n    var dx1 = buildingMaskTextureSize[0];\\\\n    var dy1 = buildingMaskTextureSize[1];\\\\n\\\\n    var windowDx = buildingWindowTextureSize[0];\\\\n    var windowDy = buildingWindowTextureSize[1];\\\\n\\\\n    var ratio = 0.0;\\\\n\\\\n    var UVGenerator = {\\\\n\\\\n        generateTopUV: function generateTopUV(geometry, vertices, indexA, indexB, indexC) {\\\\n\\\\n            var a_x = (vertices[indexA * 3] - minX) / (maxX - minX);\\\\n            var a_y = 1 - (vertices[indexA * 3 + 1] - minY) / (maxY - minY);\\\\n            var b_x = (vertices[indexB * 3] - minX) / (maxX - minX);\\\\n            var b_y = 1 - (vertices[indexB * 3 + 1] - minY) / (maxY - minY);\\\\n            var c_x = (vertices[indexC * 3] - minX) / (maxX - minX);\\\\n            var c_y = 1 - (vertices[indexC * 3 + 1] - minY) / (maxY - minY);\\\\n\\\\n            var result = [new THREE.Vector2(a_x, a_y), new THREE.Vector2(b_x, b_y), new THREE.Vector2(c_x, c_y)];\\\\n            geo.topUV.push.call(geo.topUV, result[0].x, result[0].y, result[1].x, result[1].y, result[2].x, result[2].y);\\\\n            return result;\\\\n        },\\\\n\\\\n        generateSideWallUV: function generateSideWallUV(geometry, vertices, indexA, indexB, indexC, indexD) {\\\\n            var a = [vertices[indexA * 3], vertices[indexA * 3 + 1]];\\\\n            var b = [vertices[indexB * 3], vertices[indexB * 3 + 1]];\\\\n\\\\n            var x = getDistanceFromArray(a, b) / dx;\\\\n            var y = height / dy;\\\\n\\\\n            var x1 = getDistanceFromArray(a, b) / dx1;\\\\n            var y1 = height / dy1;\\\\n\\\\n            function setSideUV(x, y, uv) {\\\\n                var res = [new THREE.Vector2(0, 0), new THREE.Vector2(x, 0), new THREE.Vector2(x, y), new THREE.Vector2(0, y)];\\\\n                uv.push.call(uv, res[0].x, res[0].y, res[1].x, res[1].y, res[3].x, res[3].y);\\\\n                uv.push.call(uv, res[1].x, res[1].y, res[2].x, res[2].y, res[3].x, res[3].y);\\\\n            }\\\\n            function setSideUV_Arround(x, y, uv) {\\\\n                var res = [new THREE.Vector2(ratio, 0), new THREE.Vector2(ratio + faceLength / windowDx, 0), new THREE.Vector2(ratio + faceLength / windowDx, height / windowDy), new THREE.Vector2(ratio, height / windowDy)];\\\\n                uv.push.call(uv, res[0].x, res[0].y, res[1].x, res[1].y, res[3].x, res[3].y);\\\\n                uv.push.call(uv, res[1].x, res[1].y, res[2].x, res[2].y, res[3].x, res[3].y);\\\\n            }\\\\n\\\\n            var sideUV1 = [new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0, 1)];\\\\n\\\\n            setSideUV(-1, 1, geo.sideUV1);\\\\n            setSideUV(-1, y, geo.sideUV2);\\\\n            setSideUV(-x, 1, geo.sideUV3);\\\\n            setSideUV(-x, y, geo.sideUV4);\\\\n\\\\n            setSideUV(-1, y1, geo.sideUV5);\\\\n            setSideUV(-x1, 1, geo.sideUV6);\\\\n            setSideUV(-x1, y1, geo.sideUV7);\\\\n            if (useAroundUV) {\\\\n                // 计算窗户环绕UV\\\\n                var a_x = vertices[indexA * 3];\\\\n                var a_y = vertices[indexA * 3 + 1];\\\\n                var a_z = vertices[indexA * 3 + 2];\\\\n                var b_x = vertices[indexB * 3];\\\\n                var b_y = vertices[indexB * 3 + 1];\\\\n                var b_z = vertices[indexB * 3 + 2];\\\\n\\\\n                var a_p = new THREE.Vector3(a_x, a_y, a_z);\\\\n                var b_p = new THREE.Vector3(b_x, b_y, b_z);\\\\n\\\\n                // 面宽度\\\\n                var faceLength = a_p.distanceTo(b_p);\\\\n\\\\n                setSideUV_Arround(-1, 1, geo.sideUV8);\\\\n\\\\n                ratio += faceLength / windowDx;\\\\n            }\\\\n            // ratio += faceLength / geo.sidePerimeter;\\\\n\\\\n            return sideUV1;\\\\n        }\\\\n    };\\\\n    return UVGenerator;\\\\n}\\\\n\\\\nfunction getDistanceFromArray(a, b) {\\\\n    return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]));\\\\n}\\\\nfunction arrayToFloat32Array(arr) {\\\\n    var len = arr.length;\\\\n    var res = new Float32Array(len);\\\\n    for (var i = 0; i < len; i++) {\\\\n        res[i] = arr[i];\\\\n    }\\\\n    return res;\\\\n}\\\\n\\\\n//# sourceURL=webpack:///./lib/threejs/createBigBuildingByUearth.worker.js?./node_modules/babel-loader/lib??ref--5\\\");\\n\\n/***/ })\\n\\n/******/ });\", null);\n};\n\n//# sourceURL=webpack:///./lib/threejs/createBigBuildingByUearth.worker.js?")
        },
        "./node_modules/webpack/buildin/global.js": /*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
        /*! no static exports found */
        function(module, exports) {
            eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?')
        },
        "./node_modules/worker-loader/dist/workers/InlineWorker.js": /*!*****************************************************************!*\
  !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!
  \*****************************************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\n// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string\n\nvar URL = window.URL || window.webkitURL;\n\nmodule.exports = function (content, url) {\n  try {\n    try {\n      var blob;\n\n      try {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\n        blob = new BlobBuilder();\n\n        blob.append(content);\n\n        blob = blob.getBlob();\n      } catch (e) {\n        // The proposed API\n        blob = new Blob([content]);\n      }\n\n      return new Worker(URL.createObjectURL(blob));\n    } catch (e) {\n      return new Worker('data:application/javascript,' + encodeURIComponent(content));\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error('Inline worker is not supported');\n    }\n\n    return new Worker(url);\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/worker-loader/dist/workers/InlineWorker.js?")
        },
        "./src/Initialization.js": /*!*******************************!*\
  !*** ./src/Initialization.js ***!
  \*******************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _buffer = __webpack_require__(/*! ./util/buffer.js */ \"./src/util/buffer.js\");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _t3dMaterial = __webpack_require__(/*! ./material/specialMaterial/t3dMaterial.js */ \"./src/material/specialMaterial/t3dMaterial.js\");\n\nvar _t3dMaterial2 = _interopRequireDefault(_t3dMaterial);\n\nvar _RenderManager = __webpack_require__(/*! ./renderer/RenderManager.js */ \"./src/renderer/RenderManager.js\");\n\nvar _RenderManager2 = _interopRequireDefault(_RenderManager);\n\nvar _RenderConfig = __webpack_require__(/*! ./renderer/RenderConfig */ \"./src/renderer/RenderConfig.json\");\n\nvar _RenderConfig2 = _interopRequireDefault(_RenderConfig);\n\nvar _FrameManager = __webpack_require__(/*! ./renderer/FrameManager.js */ \"./src/renderer/FrameManager.js\");\n\nvar _event = __webpack_require__(/*! ./event/event.js */ \"./src/event/event.js\");\n\nvar _event2 = _interopRequireDefault(_event);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar shadow_pcss = __webpack_require__(/*! ./material/shaders/shadow_pcss.glsl */ \"./src/material/shaders/shadow_pcss.glsl\");\nvar shadow_pcss_getShadow = __webpack_require__(/*! ./material/shaders/shadow_pcss_getShadow.glsl */ \"./src/material/shaders/shadow_pcss_getShadow.glsl\");\n\n/**\r\n *\r\n * 初始化场景\r\n * 1. 的确是存在很多不合理的地方\r\n * 2. 由于时间关系没有办法想清楚所有的事情\r\n */\n\nexports.default = {\n    init: function init(options) {\n        this.t3djs = options.t3djs;\n        this.dom = options.dom;\n\n        _buffer2.default.dom = options.dom;\n\n        // this.width = options.dom.offsetWidth || document.body.clientWidth;\n        // this.height = options.dom.offsetHeight || document.body.clientHeight;\n\n        this.width = options.dom.offsetWidth || window.innerWidth;\n        this.height = options.dom.offsetHeight || window.innerHeight;\n\n        // this.windowHeight = window.innerHeight;\n        // this.windowWidth = window.innerWidth;\n\n        this.onWindowResize = this.onWindowResize(this);\n    },\n\n    _getPCSSShadow: function _getPCSSShadow() {\n        var shader = THREE.ShaderChunk.shadowmap_pars_fragment;\n\n        shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP' + shadow_pcss);\n\n        shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', shadow_pcss_getShadow + '#if defined( SHADOWMAP_TYPE_PCF )');\n\n        THREE.ShaderChunk.shadowmap_pars_fragment = shader;\n    },\n    onWindowResize: function onWindowResize(that) {\n\n        function resizeHandler() {\n\n            var width = that.width = that.dom.offsetWidth;\n            var height = that.height = that.dom.offsetHeight;\n\n            if (that.dom.resizeCallBack) {\n                that.dom.resizeCallBack(width, height);\n            }\n\n            console.log('页面宽度是:' + width);\n            console.log('页面高度是:' + height);\n\n            that.renderer.setSize(width, height);\n\n            that.myCamera.aspect = width / height;\n            that.myCamera.updateProjectionMatrix();\n\n            that.cameraOrtho.left = -width / 2;\n            that.cameraOrtho.right = width / 2;\n            that.cameraOrtho.top = height / 2;\n            that.cameraOrtho.bottom = -height / 2;\n            that.cameraOrtho.updateProjectionMatrix();\n\n            that.t3djs.camera.width = width;\n            that.t3djs.camera.height = height;\n\n            that.t3djs.overlayManager.width = width;\n            that.t3djs.overlayManager.height = height;\n\n            that.t3djs.picking.width = width;\n            that.t3djs.picking.height = height;\n\n            that.renderer.clear();\n            _RenderManager2.default.render();\n        }\n\n        return function () {\n            //为什么要这样写，因为resize的时候页面render的时候确实还是存在滞后的感觉，预先刘个处理的口\n            resizeHandler();\n        };\n    },\n    //增加config配置参数\n    initEnvironment: function initEnvironment(app, config) {\n        config = Object.assign({}, _RenderConfig2.default, config);\n        var scene,\n            renderer,\n            sceneOrtho,\n            myCamera,\n            context,\n            that = this;\n        //这里先初始化使用pcss阴影吧后续再实现Cascaded阴影吧\n        //this._getPCSSShadow();\n        if (app) {\n            scene = this.t3djs.scene = app.scene;\n            renderer = app.renderer;\n            myCamera = app.renderCamera;\n            THREE._t3dCamera = myCamera;\n            //初始化renderList\n            _RenderManager2.default.init(renderer);\n\n            //如果有app，证明我们用的是Thing 则不控制窗口缩放问题\n            this.onWindowResize = function () {};\n            // RenderManager.add(renderer, scene, myCamera);\n        } else {\n            var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');\n            //TODO webgl2不需要开启canvas的抗锯齿,但是目前很多浏览器不支持webgl2，先暂时开启\n            //context，这里需要注意context无法切换，默认启用webgl2\n            if (config.isWebGL2) {\n                context = canvas.getContext('webgl2', { antialias: true, preserveDrawingBuffer: true, alpha: true });\n                _buffer2.default.isWebGL2 = true;\n            } else {\n                context = canvas.getContext('webgl', { antialias: true, preserveDrawingBuffer: true, alpha: true });\n                _buffer2.default.isWebGL2 = false;\n            }\n            if (!context) {\n                context = canvas.getContext('webgl', { antialias: true, preserveDrawingBuffer: true, alpha: true });\n                console.warn('The browser doesnot supports WebGL2, we must use WebGL1');\n                _buffer2.default.isWebGL2 = false;\n            }\n            //创建渲染器\n            _buffer2.default.logDepth = config.logDepth;\n            renderer = new THREE.WebGLRenderer({\n                canvas: canvas,\n                context: context,\n                //logDepth策略\n                logarithmicDepthBuffer: config.logDepth\n            });\n            //TODO 屏幕太牛逼可能会性能不好\n            renderer.setPixelRatio(window.devicePixelRatio);\n            // renderer.setPixelRatio(window.devicePixelRatio > 1 ? 1.5 : 1); // retina屏幕强制使用1.5倍分辨率以提高性能\n            scene = this.t3djs.scene = new THREE.Scene();\n            //static 策略\n            _buffer2.default.static = config.static;\n            if (config.static) {\n                scene.autoUpdate = false;\n                this.frameManager = new _FrameManager.FrameManager(scene);\n                _buffer2.default.frameManager = this.frameManager;\n            }\n            //TODO transparent策略,目前只有depthIgnore策略，oit暂未实现\n            _buffer2.default.transparentOption = config.transparentOption;\n            _buffer2.default.sceneBuffer.add('_3DScene', scene);\n            //开启gamma\n            renderer.gammaFactor = config.gammaFactor;\n            renderer.gammaOutput = config.gammaOutput;\n            renderer.gammaInput = config.gammaInput;\n            renderer.toneMapping = config.toneMapping;\n            // renderer.toneMappingWhitePoint = 2.0;\n            //是否使用shadow\n            if (config.shadow) {\n                renderer.shadowMap.enabled = true;\n                renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n            }\n            renderer.setClearColor(0xffffff, 0);\n            //设置视区大小\n            renderer.autoClear = false;\n            renderer.setSize(this.width, this.height);\n\n            sceneOrtho = new THREE.Scene();\n            _buffer2.default.sceneBuffer.add('_2DScene', sceneOrtho);\n            myCamera = new THREE.PerspectiveCamera(45, this.width / this.height, 0.1, 5000);\n            THREE._t3dCamera = myCamera;\n\n            var cameraOrtho = new THREE.OrthographicCamera(-this.width / 2, this.width / 2, this.height / 2, -this.height / 2, 1, 10);\n            cameraOrtho.position.z = 10;\n\n            this.dom.appendChild(renderer.domElement);\n\n            _RenderManager2.default.init(renderer, config);\n            _RenderManager2.default.add(renderer, scene, myCamera);\n            _RenderManager2.default.add(renderer, sceneOrtho, cameraOrtho);\n\n            //初始化一些配置\n            _t3dMaterial2.default.initT3dMaterial(config);\n        }\n        //为什么要有个Group因为要作为我们的根节点\n        var group = new THREE.Group();\n        group.name = 'rootNode';\n        //为什么要有个Clock因为每帧刷新的时候要获得时间的deta值\n        var clock = new THREE.Clock();\n        //为什么util要单独声明一下，因为每帧刷新的时候要用util里面的东西，所以要必包进去\n        var util = this.t3djs.util;\n        //添加到Buffer里面是为了日后需要获取根的时候使用\n        scene.add(group);\n        //下面就是各种初始化\n        this.t3djs.rootNode = this.t3djs.rootNode.init(group);\n        _buffer2.default.nodeBuffer.add('rootNode', this.t3djs.rootNode);\n        this.t3djs.viewport.init(scene, renderer);\n        this.t3djs.grid.init(scene);\n        this.t3djs.util.init(this.dom, scene);\n        this.t3djs.input.init(this.dom);\n        //注意了，这里用的是windowHeight\n        this.t3djs.overlayManager.init(sceneOrtho, this.width, this.height);\n        this.t3djs.volumeDataManager.init(scene);\n        this.t3djs.camera.init(myCamera, this.dom);\n\n        //单独初始化一下Cameracontroller，因为CameraContorller中涉及到几个需要闭包的变量\n        var cameraController = this.t3djs.CameraController.init(myCamera, this.dom);\n        this.t3djs.CameraController = cameraController;\n\n        this.t3djs.materialManager.loadCache();\n        var loader = this.t3djs.Loader.init(scene);\n        this.t3djs.Loader = loader;\n\n        _buffer2.default.aoMapIntensity = config.aoMapIntensity;\n        _buffer2.default.envMapIntensity = config.envMapIntensity;\n        // scene.add(myCamera);\n        //好，这里为什么要传camera进去，因为在构建Billboard的时候要用。\n        //哇吼吼！\n        var mySceneManager;\n        if (app) {\n            mySceneManager = this.t3djs.sceneManager.init(scene, myCamera, true);\n        } else {\n            mySceneManager = this.t3djs.sceneManager.init(scene, myCamera);\n            this.t3djs.selection = this.t3djs.sceneManager.createSceneNodeSelection('GeneralInNode');\n        }\n        // var axes = new THREE.AxisHelper(100);\n        // scene.add(axes);\n\n        _buffer2.default.maxAnisotropy = renderer.capabilities.getMaxAnisotropy();\n        // renderer.setSize(this.width, this.height);\n\n        //设置web页面的初始化\n        // this.t3djs.webManager.init(renderer, group, myCamera, this.dom, this.width, this.height)\n\n        this.t3djs.picking.init(scene, myCamera, this.width, this.height);\n        this.t3djs.renderWindow.init(renderer);\n\n        _event2.default.init();\n\n        //构建compositor缓存\n        // CompositorCache.createCompositorCache();\n        // 性能工具\n        // var stats = new Stats();\n        // this.dom.appendChild(stats.dom);\n        var animate = function animate(frameTime) {\n            //当前系统运行帧数\n            _buffer2.default.frameTime++;\n            if ((that.height != that.dom.offsetHeight || that.width != that.dom.offsetWidth) && that.dom.offsetHeight != 0 && that.dom.offsetWidth != 0) {\n                that.onWindowResize();\n                that.t3djs.util.resizeCallbacks.forEach(function (item) {\n                    item();\n                });\n            }\n\n            var interval = clock.getDelta();\n\n            //华为需求,帧率检测\n            if (_buffer2.default.isListenFPS) {\n                _buffer2.default.fpsRecorder.push(1 / interval);\n            }\n            //检测摄影机的变化\n            _buffer2.default.cameraState = false;\n            var curCameraMat = JSON.stringify(myCamera.matrixWorld);\n            if (that.lastCameraMat !== curCameraMat) {\n                _buffer2.default.cameraState = true;\n                // buffer.dirty = true;\n                that.lastCameraMat = curCameraMat;\n                //需要更新所有的静帧特效,包括TAA\n                //if(buffer.dirty) {\n                _RenderManager2.default.dirty();\n                //}\n                //TAA除了这里还有别的通知\n            }\n            //帧率管理器更新操作\n            if (that.frameManager && _buffer2.default.static) {\n                that.frameManager.update(interval);\n            }\n            //所有其他更新\n            _buffer2.default._renderList.updateAll(interval);\n            _buffer2.default._animationManager.updateAll(interval);\n\n            //TODO dirtybig还是有些问题，后面再进行改进\n            if (_buffer2.default.bigDirty) {\n                _RenderManager2.default.dirty();\n            }\n            _RenderManager2.default.render();\n            _buffer2.default.bigDirty = false;\n            //计算出每一帧的时间\n            requestAnimationFrame(animate);\n            if (util.callback) {\n                util.callback(interval);\n            }\n        };\n        animate();\n\n        // this.dom.addEventListener('resize', this.onWindowResize, false);\n        // this.dom.addEventListener('onresize', this.onWindowResize, false);\n        // window.addEventListener('resize', this.onWindowResize, false);\n        // window.addEventListener('onresize', this.onWindowResize, false);\n\n        //for resize window \n        this.renderer = renderer;\n        this.myCamera = myCamera;\n        this.cameraOrtho = cameraOrtho;\n        this.scene = scene;\n        this.sceneOrtho = sceneOrtho;\n    }\n};\n\n//# sourceURL=webpack:///./src/Initialization.js?")
        },
        "./src/animation/AnimationManager.js": /*!*******************************************!*\
  !*** ./src/animation/AnimationManager.js ***!
  \*******************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _helper = __webpack_require__(/*! ../util/helper.js */ \"./src/util/helper.js\");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nvar _event = __webpack_require__(/*! ../event/event.js */ \"./src/event/event.js\");\n\nvar _event2 = _interopRequireDefault(_event);\n\nvar _TextureAnimation = __webpack_require__(/*! ./TextureAnimation.js */ \"./src/animation/TextureAnimation.js\");\n\nvar _TextureAnimation2 = _interopRequireDefault(_TextureAnimation);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * 管理所有动画,用于穿插出一个连贯的材质动画\r\n */\nvar AnimationManager = function () {\n    function AnimationManager(name) {\n        _classCallCheck(this, AnimationManager);\n\n        this.frameTime = 0;\n        //材质动画\n        this._textureAnimation = [];\n        this.playTextureAnimation = null;\n        this.name = name || _helper2.default.getUUID();\n        //buffer._animationManager.add(this.name, this);\n    }\n\n    _createClass(AnimationManager, [{\n        key: 'update',\n        value: function update(interval) {\n            this.frameTime++;\n            if (this.playTextureAnimation) {\n                this.playTextureAnimation.update();\n            }\n        }\n    }, {\n        key: 'add',\n        value: function add(animation, tex) {\n            var textureAnim = tex ? this.get(tex.uuid) : this.get(animation.tex.uuid);\n            if (!textureAnim) {\n                textureAnim = new _TextureAnimation2.default(animation.tex.uuid);\n                textureAnim.add(animation);\n                this._textureAnimation.push(textureAnim);\n            } else {\n                textureAnim.add(animation);\n            }\n        }\n    }, {\n        key: 'get',\n        value: function get(name) {\n            for (var i = 0; i < this._textureAnimation.length; i++) {\n                if (this._textureAnimation[i].name === name) {\n                    return this._textureAnimation[i];\n                }\n            }\n            return null;\n        }\n\n        //开启动画控制\n\n    }, {\n        key: 'start',\n        value: function start() {\n            var i = 0;\n            var that = this;\n            that.playTextureAnimation = that._textureAnimation[i];\n            if (!that.playTextureAnimation) return;\n            that.playTextureAnimation.start();\n            var eventManager = _event2.default.getEventManager();\n            eventManager.addEventListener('textureAnimationFinished', function (event) {\n                if (event.obj.name === that.playTextureAnimation.name) {\n                    i++;\n                    if (i < that._textureAnimation.length) {\n                        that.playTextureAnimation = that._textureAnimation[i];\n                        that.playTextureAnimation.start();\n                    } else {\n                        eventManager.dispatchEvent({ type: 'animationManagerFinished', obj: that });\n                    }\n                }\n            });\n        }\n    }, {\n        key: 'stop',\n        value: function stop() {}\n    }]);\n\n    return AnimationManager;\n}();\n\nexports.default = AnimationManager;\n\n//# sourceURL=webpack:///./src/animation/AnimationManager.js?")
        },
        "./src/animation/MaterialAnimationManager.js": /*!***************************************************!*\
  !*** ./src/animation/MaterialAnimationManager.js ***!
  \***************************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n/**\r\n * 管理所有动画,用于穿插出一个连贯的材质动画\r\n */\n\n\nvar _buffer = __webpack_require__(/*! ../util/buffer.js */ \"./src/util/buffer.js\");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _helper = __webpack_require__(/*! ../util/helper.js */ \"./src/util/helper.js\");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nvar _AnimationManager = __webpack_require__(/*! ./AnimationManager.js */ \"./src/animation/AnimationManager.js\");\n\nvar _AnimationManager2 = _interopRequireDefault(_AnimationManager);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar key = {\n    'baseColorTexture': 'map',\n    'emissiveTexture': 'emissiveMap',\n    'normalTexture': 'normalMap',\n    'maskTexture': 'alphaMap1'\n};\n\nvar MaterialAnimationManager = function () {\n    function MaterialAnimationManager(name) {\n        _classCallCheck(this, MaterialAnimationManager);\n\n        this.frameTime = 0;\n        //材质动画\n        this.name = name || _helper2.default.getUUID();\n        this._textureAnimation = {\n            'map': new _AnimationManager2.default(),\n            'emissiveMap': new _AnimationManager2.default(),\n            'normalMap': new _AnimationManager2.default(),\n            'alphaMap1': new _AnimationManager2.default()\n        };\n        _buffer2.default._animationManager.add(this.name, this);\n    }\n\n    _createClass(MaterialAnimationManager, [{\n        key: 'update',\n        value: function update(interval) {\n            this.frameTime++;\n            for (var k in this._textureAnimation) {\n                this._textureAnimation[k].update();\n            }\n        }\n    }, {\n        key: 'add',\n        value: function add(animation, type) {\n            this._textureAnimation[key[type]].add(animation);\n        }\n        //开启动画控制\n\n    }, {\n        key: 'start',\n        value: function start() {\n            for (var k in this._textureAnimation) {\n                this._textureAnimation[k].start();\n            }\n        }\n    }, {\n        key: 'stop',\n        value: function stop() {}\n    }, {\n        key: 'get',\n        value: function get(name) {\n            return this._textureAnimation[name];\n        }\n    }]);\n\n    return MaterialAnimationManager;\n}();\n\nexports.default = MaterialAnimationManager;\n\n//# sourceURL=webpack:///./src/animation/MaterialAnimationManager.js?")
        },
        "./src/animation/MultiTexutureAnimation.js": /*!*************************************************!*\
  !*** ./src/animation/MultiTexutureAnimation.js ***!
  \*************************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _event = __webpack_require__(/*! ../event/event.js */ "./src/event/event.js");\n\nvar _event2 = _interopRequireDefault(_event);\n\nvar _ScrollAnimation2 = __webpack_require__(/*! ./ScrollAnimation.js */ "./src/animation/ScrollAnimation.js");\n\nvar _ScrollAnimation3 = _interopRequireDefault(_ScrollAnimation2);\n\nvar _math = __webpack_require__(/*! ../util/math.js */ "./src/util/math.js");\n\nvar _math2 = _interopRequireDefault(_math);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar MultiTexutureAnimation = function (_ScrollAnimation) {\n    _inherits(MultiTexutureAnimation, _ScrollAnimation);\n\n    function MultiTexutureAnimation(material, texture, tilesHoriz, tilesVert, numTiles, tileDispDuration) {\n        _classCallCheck(this, MultiTexutureAnimation);\n\n        var _this = _possibleConstructorReturn(this, (MultiTexutureAnimation.__proto__ || Object.getPrototypeOf(MultiTexutureAnimation)).call(this, material, texture));\n\n        _this.type = \'MultiTexutureAnimation\';\n        _this.tilesHoriz = tilesHoriz || 1;\n        _this.tilesVert = tilesVert || 1;\n        _this.numTiles = numTiles || 1;\n        _this.tileDispDuration = tileDispDuration || 0.02;\n        //this.tileDispDuration = this.tileDispDuration/numTiles;\n        _this.currentTile = 0;\n        _this.originalRepeat = [_this.tex.repeat.x, _this.tex.repeat.y];\n        _this.originalOffset = [_this.tex.offset.x, _this.tex.offset.y];\n        //this.tex.center.set(0.5,0.5);\n        _this.random = false;\n        _this.curImageInterval = Math.round(1 / _this.tileDispDuration);\n        _this.randomTime = 0;\n        _this.currentColumn = 0;\n        _this.currentRow = 0;\n\n        //this.tex.wrapS = this.tex.wrapT = THREE.RepeatWrapping;\n        return _this;\n    }\n\n    _createClass(MultiTexutureAnimation, [{\n        key: \'update\',\n        value: function update(frameTime) {\n            if (this.stop) return;\n            this._keepInteval();\n            if (this.pause) return;\n            var anim = this._updateAnim();\n            this.record = _math2.default.precisionAdd(this.record, Math.abs(this.tileDispDuration * anim[0]));\n            if (this.record < 1.0 * this.numTiles) {\n                this._begin();\n                this.tex.repeat.set(this.originalRepeat[0] / this.tilesHoriz, this.originalRepeat[1] / this.tilesVert);\n                if (this.random) {\n                    if (this.randomTime >= this.curImageInterval) {\n                        this.currentColumn = Math.floor(this.tilesHoriz * Math.random());\n                        this.currentRow = Math.floor(this.tilesVert * Math.random());\n                        this.randomTime = 0;\n                    }\n                    this.randomTime += Math.abs(anim[0]);\n                } else {\n                    this.currentTile = _math2.default.precisionAdd(this.currentTile, this.tileDispDuration * anim[0]);\n                    if (this.currentTile >= this.numTiles) {\n                        this.currentTile = 0;\n                    }\n                    this.currentColumn = this.currentTile % this.tilesHoriz;\n                    this.currentColumn = Math.floor(this.currentColumn);\n                    this.currentRow = Math.floor(this.currentTile / this.tilesHoriz);\n                }\n                this.tex.offset.x = this.currentColumn / this.tilesHoriz;\n                this.tex.offset.y = this.currentRow / this.tilesVert;\n            } else {\n                this._keepFinish();\n            }\n            this.frameTime++;\n        }\n    }, {\n        key: \'_begin\',\n        value: function _begin() {\n            if (this.curPlayTexture) {\n                var curTexture = this.curPlayTexture.texture;\n                var curName = this.curPlayTexture.texName;\n                if (this.material[curName] && this.material[curName].uuid !== curTexture.uuid) {\n                    this.material[curName] = curTexture;\n                    this.tex = curTexture;\n                    this.originalRepeat = [this.tex.repeat.x, this.tex.repeat.y];\n                }\n            }\n        }\n    }, {\n        key: \'setRandom\',\n        value: function setRandom(random) {\n            this.random = random;\n        }\n    }]);\n\n    return MultiTexutureAnimation;\n}(_ScrollAnimation3.default);\n\nexports.default = MultiTexutureAnimation;\n\n//# sourceURL=webpack:///./src/animation/MultiTexutureAnimation.js?')
        },
        "./src/animation/RotationAnimation.js": /*!********************************************!*\
  !*** ./src/animation/RotationAnimation.js ***!
  \********************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _event = __webpack_require__(/*! ../event/event.js */ "./src/event/event.js");\n\nvar _event2 = _interopRequireDefault(_event);\n\nvar _ScrollAnimation2 = __webpack_require__(/*! ./ScrollAnimation.js */ "./src/animation/ScrollAnimation.js");\n\nvar _ScrollAnimation3 = _interopRequireDefault(_ScrollAnimation2);\n\nvar _math = __webpack_require__(/*! ../util/math */ "./src/util/math.js");\n\nvar _math2 = _interopRequireDefault(_math);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n//此速度为角度\nvar RotationAnimation = function (_ScrollAnimation) {\n    _inherits(RotationAnimation, _ScrollAnimation);\n\n    function RotationAnimation(material, texture, rotation) {\n        _classCallCheck(this, RotationAnimation);\n\n        var _this = _possibleConstructorReturn(this, (RotationAnimation.__proto__ || Object.getPrototypeOf(RotationAnimation)).call(this, material, texture));\n\n        _this.rotation = rotation || 0.01;\n        _this.originalRotation = texture.rotation;\n        _this.type = \'RotationAnimation\';\n        return _this;\n    }\n\n    _createClass(RotationAnimation, [{\n        key: \'update\',\n        value: function update(frameTime) {\n            if (this.stop) return;\n            this._keepInteval();\n            if (this.pause) return;\n            var anim = this._updateAnim();\n            var nums = Math.abs(this.rotation * anim[0]);\n            this.record = _math2.default.precisionAdd(this.record, nums);\n            if (this.record <= 360) {\n                //为角度，360为一圈\n                this._begin();\n                this.tex.rotation += this.rotation * anim[0] * Math.PI / 180;\n            } else {\n                this.tex.rotation = this.originalRotation;\n                this._keepFinish();\n            }\n        }\n    }]);\n\n    return RotationAnimation;\n}(_ScrollAnimation3.default);\n\nexports.default = RotationAnimation;\n\n//# sourceURL=webpack:///./src/animation/RotationAnimation.js?')
        },
        "./src/animation/ScaleAnimation.js": /*!*****************************************!*\
  !*** ./src/animation/ScaleAnimation.js ***!
  \*****************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _event = __webpack_require__(/*! ../event/event.js */ "./src/event/event.js");\n\nvar _event2 = _interopRequireDefault(_event);\n\nvar _ScrollAnimation2 = __webpack_require__(/*! ./ScrollAnimation.js */ "./src/animation/ScrollAnimation.js");\n\nvar _ScrollAnimation3 = _interopRequireDefault(_ScrollAnimation2);\n\nvar _math = __webpack_require__(/*! ../util/math */ "./src/util/math.js");\n\nvar _math2 = _interopRequireDefault(_math);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ScaleAnimation = function (_ScrollAnimation) {\n    _inherits(ScaleAnimation, _ScrollAnimation);\n\n    function ScaleAnimation(material, texture, scale) {\n        _classCallCheck(this, ScaleAnimation);\n\n        //texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n        var _this = _possibleConstructorReturn(this, (ScaleAnimation.__proto__ || Object.getPrototypeOf(ScaleAnimation)).call(this, material, texture));\n\n        _this.scale = scale || 0.01;\n        _this.nums = _this.scaleSpeed = Math.round(1 / _this.scale);\n        _this.nums = Math.abs(_this.nums);\n        _this.reverseScale = false;\n        if (_this.scaleSpeed < 0) {\n            _this.scaleSpeed = 1;\n            _this.reverseScale = true;\n        }\n        _this.type = \'ScaleAnimation\';\n        _this.originRepeat = [texture.repeat.x, texture.repeat.y];\n        _this.tex.center.set(0.5, 0.5);\n        return _this;\n    }\n\n    _createClass(ScaleAnimation, [{\n        key: \'update\',\n        value: function update(frameTime) {\n            if (this.stop) return;\n            this._keepInteval();\n            if (this.pause) return;\n            this.record = _math2.default.precisionAdd(this.record, this.scale);\n            if (this.record <= 1) {\n                this._begin();\n                var anim = this._updateAnim();\n                var deltScale = this.scaleSpeed;\n                this.tex.repeat.set(deltScale, deltScale);\n                if (this.reverseScale) {\n                    this.scaleSpeed += anim[0];\n                    if (this.scaleSpeed >= this.nums) {\n                        this.scaleSpeed = 1;\n                    }\n                } else {\n                    this.scaleSpeed -= anim[0];\n                    if (this.scaleSpeed <= 0) {\n                        this.scaleSpeed = this.nums;\n                    }\n                }\n            } else {\n                this.tex.repeat.set(this.originRepeat[0], this.originRepeat[1]);\n                this._keepFinish();\n            }\n        }\n    }]);\n\n    return ScaleAnimation;\n}(_ScrollAnimation3.default);\n\nexports.default = ScaleAnimation;\n\n//# sourceURL=webpack:///./src/animation/ScaleAnimation.js?')
        },
        "./src/animation/ScrollAnimation.js": /*!******************************************!*\
  !*** ./src/animation/ScrollAnimation.js ***!
  \******************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _buffer = __webpack_require__(/*! ../util/buffer.js */ \"./src/util/buffer.js\");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _event = __webpack_require__(/*! ../event/event.js */ \"./src/event/event.js\");\n\nvar _event2 = _interopRequireDefault(_event);\n\nvar _math = __webpack_require__(/*! ../util/math.js */ \"./src/util/math.js\");\n\nvar _math2 = _interopRequireDefault(_math);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ScrollAnimation = function () {\n    function ScrollAnimation(material, texture, scroll) {\n        _classCallCheck(this, ScrollAnimation);\n\n        this.type = 'ScrollAnimation';\n        this.tex = texture;\n        this.material = material;\n        this.enabled = true;\n        this.scroll = scroll || [0.01, 0];\n        this.finish = false;\n        this.circulation = Number.POSITIVE_INFINITY; //默认播几次,0为无限循环\n        this.curCirculation = 0; //当前播放的圈数\n        // this.name = texture.name + '_scroll_' + this.scroll.toString();\n        this.name = texture.name + '_scroll_' + this.scroll.toString() + '-' + texture.uuid;\n        this.record = 0; //为了记录一个循环,目前只记录x\n        this.frameTime = 0;\n        this.interval = this.originInterval = 0; //播放完暂停间隔\n        this.curPlayTexture = null;\n        this.precision = 0.0001;\n        this.originScroll = [this.tex.offset.x, this.tex.offset.y];\n        this.pause = false;\n        this.stop = false; //直接停止\n        this.eventManager = new THREE.EventDispatcher();\n        _buffer2.default._textureAnimation.add(this.name, this);\n    }\n\n    _createClass(ScrollAnimation, [{\n        key: 'update',\n        value: function update(frameTime) {\n            if (this.stop) return;\n            this._keepInteval();\n            if (this.pause) return;\n            var anim = this._updateAnim();\n            var nums = Math.abs((this.scroll[0] === 0 ? this.scroll[1] : this.scroll[0]) * anim[0]);\n            this.record = _math2.default.precisionAdd(this.record, nums);\n            if (this.record <= 1) {\n                this._begin();\n                this.tex.offset.x += this.scroll[0] * anim[0];\n                this.tex.offset.y += this.scroll[1] * anim[1];\n            } else {\n                //还原,因为如果有振幅会存在误差\n                this.tex.offset.x = this.originScroll[0];\n                this.tex.offset.y = this.originScroll[1];\n                this._keepFinish();\n            }\n        }\n    }, {\n        key: '_begin',\n        value: function _begin() {\n            if (this.curPlayTexture) {\n                var curTexture = this.curPlayTexture.texture;\n                var curName = this.curPlayTexture.texName;\n                if (this.material[curName] && this.material[curName].uuid !== curTexture.uuid) {\n                    this.material[curName] = curTexture;\n                    this.tex = curTexture;\n                    // this.name = curTexture.name + '_scroll_' + this.scroll.toString() + '-' + curTexture.uuid;\n                }\n            }\n        }\n    }, {\n        key: 'setAnimationOption',\n        value: function setAnimationOption(AnimAmplitude, AnimCycle) {\n            if (!AnimAmplitude) return;\n            if (!AnimCycle) return;\n            this.AnimAmplitude = AnimAmplitude instanceof Array ? AnimAmplitude : [AnimAmplitude, AnimAmplitude];\n            this.AnimCycle = AnimCycle instanceof Array ? AnimCycle : [AnimCycle, AnimCycle];\n        }\n    }, {\n        key: 'setCirculation',\n        value: function setCirculation(nums) {\n            if (!nums) nums = Number.POSITIVE_INFINITY;\n            this.circulation = nums;\n            var eventManager = this.eventManager;\n            eventManager.addEventListener('loopFinished', function (ev) {\n                if (ev.obj.curCirculation <= nums - 1) {\n                    ev.obj.record = 0;\n                } else {\n                    ev.obj.finish = true;\n                    if (ev.obj.interval) {\n                        //如果有时间间隔，延迟触发动画完成，如果没有则立即触发\n                        var time = ev.obj.interval * 1000 / 50;\n                        setTimeout(function () {\n                            _event2.default.getEventManager().dispatchEvent({ type: 'animationFinished', obj: ev.obj });\n                        }, time);\n                    } else {\n                        _event2.default.getEventManager().dispatchEvent({ type: 'animationFinished', obj: ev.obj });\n                    }\n                }\n            });\n        }\n    }, {\n        key: '_keepInteval',\n        value: function _keepInteval() {\n            if (this.pause) {\n                if (this.interval > 0) {\n                    this.interval--;\n                } else {\n                    this.pause = false;\n                }\n            }\n        }\n    }, {\n        key: '_keepFinish',\n        value: function _keepFinish() {\n            if (!this.finish) {\n                this.curCirculation++;\n                this.pause = true;\n                this.interval = this.originInterval;\n                this.eventManager.dispatchEvent({ type: 'loopFinished', obj: this });\n            } else {\n                this.finish = true;\n            }\n        }\n    }, {\n        key: 'setInterval',\n        value: function setInterval(nums) {\n            if (!nums) return;\n            this.interval = this.originInterval = nums;\n        }\n    }, {\n        key: 'changeTexture',\n        value: function changeTexture(texName, texture) {\n            this.curPlayTexture = {\n                texName: texName,\n                texture: texture\n            };\n            //this.name = texture.name + '_scroll_' + this.scroll.toString() + '-' + texture.uuid;\n        }\n    }, {\n        key: '_updateAnim',\n        value: function _updateAnim() {\n            if (this.AnimAmplitude && this.AnimCycle) {\n                if (this.AnimCycle[0] === 0 || this.AnimCycle[1] === 0) {\n                    return [1, 1];\n                } else {\n                    var signal = Math.random() > 0.5 ? 1 : -1;\n                    var ux = 1 + signal * Math.random() * this.AnimAmplitude[0] / this.AnimCycle[0];\n                    var uy = 1 + signal * Math.random() * this.AnimAmplitude[1] / this.AnimCycle[1];\n                    return [ux, uy];\n                }\n            } else {\n                return [1, 1];\n            }\n        }\n    }]);\n\n    return ScrollAnimation;\n}();\n\nexports.default = ScrollAnimation;\n\n//# sourceURL=webpack:///./src/animation/ScrollAnimation.js?")
        },
        "./src/animation/TextureAnimation.js": /*!*******************************************!*\
  !*** ./src/animation/TextureAnimation.js ***!
  \*******************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _helper = __webpack_require__(/*! ../util/helper.js */ \"./src/util/helper.js\");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nvar _event = __webpack_require__(/*! ../event/event.js */ \"./src/event/event.js\");\n\nvar _event2 = _interopRequireDefault(_event);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * 管理贴图动画，目前里面的贴图动画同时更新，只要第一个停止全部就结束\r\n */\nvar TextureAnimation = function () {\n    function TextureAnimation(name) {\n        _classCallCheck(this, TextureAnimation);\n\n        this.frameTime = 0;\n        //材质动画\n        this._textureAnimation = [];\n        this.name = name || _helper2.default.getUUID();\n    }\n\n    _createClass(TextureAnimation, [{\n        key: 'update',\n        value: function update(interval) {\n            this.frameTime++;\n            if (this._textureAnimation.length > 0) {\n                this._textureAnimation.map(function (v) {\n                    v.update();\n                });\n            }\n        }\n    }, {\n        key: 'add',\n        value: function add(animation) {\n            this._textureAnimation.push(animation);\n        }\n\n        //开启刷新\n\n    }, {\n        key: 'start',\n        value: function start() {\n            var _textureAnimation = this._textureAnimation;\n            var that = this;\n            if (_textureAnimation.length > 0) {\n                var eventManager = _event2.default.getEventManager();\n                eventManager.addEventListener('animationFinished', function (event) {\n                    var curObj = event.obj;\n                    for (var i = 0; i < _textureAnimation.length; i++) {\n                        if (curObj.name === _textureAnimation[i].name) {\n                            that.stop();\n                            eventManager.dispatchEvent({ type: 'textureAnimationFinished', obj: that });\n                            return;\n                        }\n                    }\n                });\n            }\n        }\n        //停止\n\n    }, {\n        key: 'stop',\n        value: function stop() {\n            this._textureAnimation.map(function (v) {\n                v.stop = true;\n            });\n        }\n    }]);\n\n    return TextureAnimation;\n}();\n\nexports.default = TextureAnimation;\n\n//# sourceURL=webpack:///./src/animation/TextureAnimation.js?")
        },
        "./src/animation/animation.js": /*!************************************!*\
  !*** ./src/animation/animation.js ***!
  \************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _buffer = __webpack_require__(/*! ../util/buffer.js */ \"./src/util/buffer.js\");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _InterpolationMode = __webpack_require__(/*! ../util/InterpolationMode.js */ \"./src/util/InterpolationMode.js\");\n\nvar _InterpolationMode2 = _interopRequireDefault(_InterpolationMode);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar animation = function () {\n  function animation(name, time) {\n    _classCallCheck(this, animation);\n\n    this.name = name;\n    this.time = time;\n    this.interpolation = THREE.InterpolateLinear;\n    _buffer2.default.animationBuffer.add(name, this);\n  }\n\n  _createClass(animation, [{\n    key: 'setInterpolationMode',\n    value: function setInterpolationMode(interpolation) {\n      if (interpolation == _InterpolationMode2.default.SPLINE || interpolation == 'spline') this.interpolation = THREE.InterpolateSmooth;else if (interpolation == _InterpolationMode2.default.LINEAR || interpolation == 'linear') this.interpolation = THREE.InterpolateLinear;\n    }\n    //第二个参数默认为true,需要将t3d的动画脚本转化为threejs的动画脚本,如果为false,则不需要转化直接使用\n\n  }, {\n    key: 'createNodeTrackList',\n    value: function createNodeTrackList(aniData) {\n      var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (b) {\n        if (typeof aniData === 'string') aniData = JSON.parse(aniData);\n        var interpolation = aniData.interpolation;\n        var tracks = aniData.tracks;\n        var KFArray = [];\n        for (var i = 0; i < tracks.length; i += 1) {\n          var track = tracks[i];\n          var nodeName = track.node;\n          var keyframes = track.keyframes;\n          var positionKeys = '';\n          var scaleKeys = '';\n          var rotationKeys = '';\n          var positionTimeArray = [];\n          var scaleTimeArray = [];\n          var rotationTimeArray = [];\n          for (var j = 0; j < keyframes.length; j += 1) {\n            var keyframe = keyframes[j];\n            if (keyframe.pos) {\n              positionKeys += ' ' + keyframe.pos;\n              positionTimeArray.push(keyframe.time - 0);\n            }\n            if (keyframe.scale) {\n              scaleKeys += ' ' + keyframe.scale;\n              scaleTimeArray.push(keyframe.time - 0);\n            }\n            if (keyframe.rot) {\n              rotationKeys += ' ' + keyframe.rot;\n              rotationTimeArray.push(keyframe.time - 0);\n            }\n          }\n          if (positionKeys !== '') {\n            positionKeys = positionKeys.substr(1);\n            var positionKF = new THREE.VectorKeyframeTrack(nodeName + '.position', positionTimeArray, positionKeys.split(' '));\n            if (interpolation) positionKF.setInterpolation(interpolation);else positionKF.setInterpolation(this.interpolation);\n            KFArray.push(positionKF);\n          }\n          if (scaleKeys !== '') {\n            scaleKeys = scaleKeys.substr(1);\n            var scaleKF = new THREE.VectorKeyframeTrack(nodeName + '.scale', scaleTimeArray, scaleKeys.split(' '));\n            if (interpolation) scaleKF.setInterpolation(interpolation);else scaleKF.setInterpolation(this.interpolation);\n            KFArray.push(scaleKF);\n          }\n          if (rotationKeys !== '') {\n            rotationKeys = rotationKeys.substr(1);\n            var rotationKF = new THREE.QuaternionKeyframeTrack(nodeName + '.quaternion', rotationTimeArray, rotationKeys.split(' '));\n            if (interpolation) rotationKF.setInterpolation(interpolation);else rotationKF.setInterpolation(this.interpolation);\n            KFArray.push(rotationKF);\n          }\n        }\n        var clip = new THREE.AnimationClip(this.name, this.time, KFArray);\n        this.clip = clip;\n      } else {\n        this.clip = aniData;\n      }\n    }\n  }]);\n\n  return animation;\n}();\n\nexports.default = animation;\n\n//# sourceURL=webpack:///./src/animation/animation.js?")
        },
        "./src/animation/animationLodState.js": /*!********************************************!*\
  !*** ./src/animation/animationLodState.js ***!
  \********************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar animationLodState = function () {\n    function animationLodState(arr) {\n        _classCallCheck(this, animationLodState);\n\n        this.animationArr = arr;\n    }\n\n    _createClass(animationLodState, [{\n        key: "setEnabled",\n        value: function setEnabled(bool, isreset) {\n            this.animationArr.map(function (v) {\n                v.setEnabled(bool, isreset);\n            });\n        }\n    }, {\n        key: "addTime",\n        value: function addTime(frameTime) {\n            this.animationArr.map(function (v) {\n                v.addTime(frameTime);\n            });\n        }\n    }, {\n        key: "setLoop",\n        value: function setLoop() {\n            var bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n            this.animationArr.map(function (v) {\n                v.setLoop(bool);\n            });\n        }\n    }, {\n        key: "setTimePosition",\n        value: function setTimePosition(value) {\n            this.animationArr.map(function (v) {\n                v.setTimePosition(value);\n            });\n        }\n    }, {\n        key: "getTimePosition",\n        value: function getTimePosition() {\n            if (this.animationArr.length) {\n                return this.animationArr[0].getTimePosition();\n            }\n        }\n    }, {\n        key: "hasEnded",\n        value: function hasEnded() {\n            if (this.animationArr.length) {\n                return this.animationArr[0].hasEnded();\n            }\n        }\n    }, {\n        key: "releaseMemory",\n        value: function releaseMemory() {\n            this.animationArr.map(function (v) {\n                v.releaseMemory();\n            });\n        }\n    }, {\n        key: "push",\n        value: function push(animationState) {\n            this.animationArr.push(animationState);\n        }\n    }]);\n\n    return animationLodState;\n}();\n\nexports.default = animationLodState;\n\n//# sourceURL=webpack:///./src/animation/animationLodState.js?')
        },
        "./src/animation/animationState.js": /*!*****************************************!*\
  !*** ./src/animation/animationState.js ***!
  \*****************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _buffer = __webpack_require__(/*! ../util/buffer.js */ \"./src/util/buffer.js\");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _sceneManager = __webpack_require__(/*! ../scene/sceneManager.js */ \"./src/scene/sceneManager.js\");\n\nvar _sceneManager2 = _interopRequireDefault(_sceneManager);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar animationState = function () {\n    function animationState(myName, myAnimation) {\n        _classCallCheck(this, animationState);\n\n        this.name = myName;\n        this.mixer = new THREE.AnimationMixer(_sceneManager2.default.scene);\n        this.animation = _sceneManager2.default.getAnimation(myName);\n        if (!myAnimation) {\n            this.animationAction = this.mixer.clipAction(this.animation.clip);\n        } else {\n            this.animationAction = this.mixer.clipAction(myAnimation);\n        }\n        this.animationAction.clampWhenFinished = true;\n        this.animationAction.zeroSlopeAtEnd = false;\n        this.animationAction.zeroSlopeAtStart = false;\n        this.animationAction.enabled = false;\n        this.costTime = 0;\n        _buffer2.default.animationStateBuffer.add(myName, this);\n    }\n\n    _createClass(animationState, [{\n        key: 'setEnabled',\n        value: function setEnabled(bool, isreset) {\n            if (bool) {\n                this.animationAction.enabled = true;\n                this.animationAction.play();\n            } else {\n                this.animationAction.enabled = false;\n                if (isreset) this.animationAction.stop();\n            }\n        }\n    }, {\n        key: 'addTime',\n        value: function addTime(frameTime) {\n            this.costTime += frameTime;\n            if (frameTime < 0) {\n                this.animationAction.timeScale = -1;\n                this.animationAction.stop();\n            } else {\n                this.animationAction.timeScale = 1;\n            }\n            // // this.time = frameTime;\n            frameTime = Math.abs(frameTime);\n            this.mixer.update(frameTime);\n\n            var bindings = this.mixer._bindings;\n            var needUpdateObjs = [];\n            for (var i = 0; i < bindings.length; i++) {\n                needUpdateObjs.push(bindings[i].binding.node);\n            }\n            //动画这里为了性能的极致还是有必要优化的\n            if (THREE.EventCenter !== undefined) {\n                THREE.EventCenter.dispatchEvent({ type: 'immediateChanged', obj: needUpdateObjs });\n            }\n        }\n    }, {\n        key: 'setLoop',\n        value: function setLoop() {\n            var bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n            if (bool) {\n                this.animationAction.loop = THREE.LoopRepeat;\n            } else {\n                this.animationAction.loop = THREE.LoopOnce;\n            }\n        }\n    }, {\n        key: 'setTimePosition',\n        value: function setTimePosition(value) {\n            if (value === 0) {\n                this.animationAction.reset();\n            }\n            // this.mixer.clipAction(this.animate).time = value;\n            // this.animationAction.setDuration(value);\n            this.costTime = value;\n        }\n    }, {\n        key: 'getTimePosition',\n        value: function getTimePosition() {\n            return this.costTime;\n            // return 0;\n        }\n    }, {\n        key: 'hasEnded',\n        value: function hasEnded() {\n            if (this.animationAction.isRunning() || this.costTime < this.animation.time) {\n                return false;\n            } else {\n                // this.mixer.clipAction(this.animate).stop();\n                return true;\n            }\n        }\n    }, {\n        key: 'releaseMemory',\n        value: function releaseMemory() {\n            if (this.animation.clip) this.mixer.uncacheClip(this.animation.clip);\n            this.mixer.uncacheRoot(_sceneManager2.default.scene);\n            this.mixer.uncacheAction(this.animation.clip, _sceneManager2.default.scene);\n        }\n    }]);\n\n    return animationState;\n}();\n\nexports.default = animationState;\n\n//# sourceURL=webpack:///./src/animation/animationState.js?")
        },
        "./src/billboard/BillboardType.js": /*!****************************************!*\
  !*** ./src/billboard/BillboardType.js ***!
  \****************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.default = {\n  /** Standard point billboard (default), always faces the camera completely and is always upright */\n  POINT: 0,\n  /** Billboards are oriented around a shared direction vector (used as Y axis) and only rotate around this to face the camera */\n  ORIENTED_COMMON: 1,\n  /** Billboards are oriented around their own direction vector (their own Y axis) and only rotate around this to face the camera */\n  ORIENTED_SELF: 2,\n  /** Billboards are perpendicular to a shared direction vector (used as Z axis, the facing direction) and X, Y axis are determined by a shared up-vertor */\n  PERPENDICULAR_COMMON: 3,\n  /** Billboards are perpendicular to their own direction vector (their own Z axis, the facing direction) and X, Y axis are determined by a shared up-vertor */\n  PERPENDICULAR_SELF: 4,\n\n  MESH: 97,\n\n  ORIENTED_NOT: 99,\n\n  SPRITE: 98\n};\n\n//# sourceURL=webpack:///./src/billboard/BillboardType.js?')
        },
        "./src/billboard/billboard.js": /*!************************************!*\
  !*** ./src/billboard/billboard.js ***!
  \************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(/*! ../extra/BillboardMesh.js */ \"./src/extra/BillboardMesh.js\");\n\nvar _buffer = __webpack_require__(/*! ../util/buffer.js */ \"./src/util/buffer.js\");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _helper = __webpack_require__(/*! ../util/helper.js */ \"./src/util/helper.js\");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nvar _sourceThreeFunction = __webpack_require__(/*! ../material/sourceThreeFunction.js */ \"./src/material/sourceThreeFunction.js\");\n\nvar _sourceThreeFunction2 = _interopRequireDefault(_sourceThreeFunction);\n\nvar _BillboardType = __webpack_require__(/*! ./BillboardType.js */ \"./src/billboard/BillboardType.js\");\n\nvar _BillboardType2 = _interopRequireDefault(_BillboardType);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar billboard = function () {\n    function billboard(camera) {\n        _classCallCheck(this, billboard);\n\n        this.camera = camera;\n    }\n\n    _createClass(billboard, [{\n        key: 'setDefaultDimensions',\n        value: function setDefaultDimensions(width, height) {\n            this.dimesions = [width, height];\n        }\n    }, {\n        key: 'setMaterialName',\n        value: function setMaterialName(name) {\n            this.materialName = name;\n        }\n    }, {\n        key: 'setBillboardType',\n        value: function setBillboardType(type) {\n            this.type = type;\n        }\n    }, {\n        key: 'setSortingEnabled',\n        value: function setSortingEnabled() {}\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return this.name;\n        }\n    }, {\n        key: 'setCommonDirection',\n        value: function setCommonDirection(vec) {\n            this.axis = new THREE.Vector3(vec[0], vec[1], vec[2]);\n        }\n    }, {\n        key: 'createBillboard',\n        value: function createBillboard(pos, color) {\n            var myBillboard,\n                materialArray = [];\n            var mat = _buffer2.default.materialBuffer.get(this.materialName);\n            // temMat = temMat.getTechnique(0).getPass(0).material;\n            if (mat) {\n                var tech = mat.getTechnique();\n                if (tech.length <= 1) {\n                    var pass = tech[0].getPass();\n                    //tech[0].getPass().reverse();\n                    for (var i = 0; i < pass.length; i++) {\n                        var param = _sourceThreeFunction2.default.copyParams(pass[i].material);\n                        var tmpMaterial = new THREE.SpriteMaterial(param);\n                        tmpMaterial.name = tmpMaterial.uuid;\n                        pass[i].setMaterial(tmpMaterial);\n                    }\n                } //todo many techniques\n                else {\n                        console.log('no elae');\n                    }\n            }\n\n            // debugger;\n\n\n            //设置背景透明欧耶\n            // mat.transparent = true;\n            // if (color) {\n            //     mat.color = new THREE.Color(color[0], color[1], color[2]);\n            // }\n\n            // var planeGeometry = new THREE.PlaneGeometry(this.dimesions[0], this.dimesions[1], 1, 1);\n            // this.material = temMat;\n            // myBillboard = new THREE.BillboardMesh(planeGeometry, mat, this.camera.position);\n\n            // function updateInstance(obj, pos) {\n            //     return function() {\n            //         obj.lookAt(pos);\n            //     };\n            // }\n\n\n            // function createMultiMaterialObject(materials, scale) {\n            //     console.log(scale);\n            //     var group = new THREE.Group();\n            //     //解决先后绘制的问题\n            //     materials = materials.reverse();\n\n            //     var orginMat = mat.getTechnique(0).getPass();\n            //     for (var i = 0, l = materials.length; i < l; i++) {\n\n            //         let param = sourceThreeFunction.copyParams(materials[i]);\n            //         let tmpMaterial = new THREE.SpriteMaterial(param);\n            //         orginMat[i].material = tmpMaterial;\n            //         var mySprite = new THREE.Sprite(tmpMaterial);\n            //         mySprite.scale.set(scale[0], scale[1], 1);\n            //         group.add(mySprite);\n\n            //     }\n            //     orginMat = orginMat.reverse();\n            //     return group;\n\n            // }\n\n            if (this.type == _BillboardType2.default.POINT) {\n                myBillboard = new THREE.Sprite();\n                if (mat) {\n                    myBillboard.setMaterial(mat);\n                }\n            } else if (this.type == _BillboardType2.default.ORIENTED_COMMON) {\n                myBillboard = new THREE.Sprite();\n                if (mat) {\n                    myBillboard.setMaterial(mat);\n                }\n            } else if (this.type == _BillboardType2.default.ORIENTED_SELF) {\n                console.log('billboardType.ORIENTED_SELF功能暂时没有开发完成');\n            }\n\n            if (pos) {\n                myBillboard.position.x = pos[0];\n                myBillboard.position.y = pos[1];\n                myBillboard.position.z = pos[2];\n            }\n\n            myBillboard.typeName = 'Billboard';\n            myBillboard.name = _helper2.default.getUUID();\n            this.name = myBillboard.name;\n            myBillboard.isCabinetRoot = false;\n            this.billboard = myBillboard;\n            myBillboard.setDimensions = function (width, height) {\n                this.setScale(width, height, 1);\n            };\n            //buffer.debuggerList.push(myBillboard);\n            _buffer2.default.entityBuffer.add(myBillboard.name, myBillboard);\n            _buffer2.default.nodeBuffer.add(myBillboard.name, myBillboard);\n            // buffer._renderList.add(myBillboard.name, myBillboard);\n            return myBillboard;\n        }\n    }]);\n\n    return billboard;\n}();\n\nexports.default = billboard;\n\n//# sourceURL=webpack:///./src/billboard/billboard.js?")
        },
        "./src/camera/CameraControlMode.js": /*!*****************************************!*\
  !*** ./src/camera/CameraControlMode.js ***!
  \*****************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = {\n\n\t/** first person*/\n\tFree: 'Free',\n\t/** orbit */\n\tOrbit: 'Orbit',\n\t/** goto */\n\tGoto: 'Goto'\n\n};\n\n//# sourceURL=webpack:///./src/camera/CameraControlMode.js?")
        },
        "./src/camera/CameraController.js": /*!****************************************!*\
  !*** ./src/camera/CameraController.js ***!
  \****************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _CameraControlMode = __webpack_require__(/*! ./CameraControlMode.js */ \"./src/camera/CameraControlMode.js\");\n\nvar _CameraControlMode2 = _interopRequireDefault(_CameraControlMode);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar CameraControllerFunc = {\n\tinit: function init(camera, domElement) {\n\t\tvar myCamera = camera,\n\t\t    dom = domElement;\n\t\tvar CameraController = function CameraController(opt_cams) {};\n\n\t\tCameraController.prototype = {\n\t\t\tchangeMode: function changeMode(name, param) {\n\t\t\t\tvar control;\n\t\t\t\tthis.control = control;\n\t\t\t\tif (name == _CameraControlMode2.default.Orbit) {\n\t\t\t\t\tcontrol = new THREE.OrbitControls(myCamera, dom);\n\t\t\t\t}\n\n\t\t\t\tif (param && param.center.length == 3) {\n\t\t\t\t\tmyCamera.position.set(param.center[0], param.center[1], param.center[2]);\n\t\t\t\t\tmyCamera.lookAt(0, 0, 0);\n\t\t\t\t\tmyCamera.updateMatrix();\n\t\t\t\t\tmyCamera.updateMatrixWorld();\n\t\t\t\t}\n\t\t\t\treturn control;\n\t\t\t},\n\t\t\tupdate: function update() {\n\t\t\t\t// this.control.update();\n\t\t\t}\n\t\t};\n\t\treturn CameraController;\n\t}\n}; /**\r\n    * Class Camera Controller.\r\n    * @class t3djs.CameraController\r\n    */\n// import '../extra/OrbitControls.js';\nexports.default = CameraControllerFunc;\n\n// t3djs.CameraController = function(opt_cams) {\n//   opt_cam = opt_cam || t3djs.camera;\n\n//   this.camera = opt_cam;\n//   this.modes = {};\n//   this.curMode = null;\n\n//   this.registerMode(t3djs.CameraControlMode.Free, new t3djs.FreeCameraMode());\n//   this.registerMode(t3djs.CameraControlMode.Orbit, new t3djs.OrbitCameraMode());\n//   this.registerMode(t3djs.CameraControlMode.Goto, new t3djs.GotoCameraMode());\n// };\n\n// t3djs.CameraController.prototype.registerMode = function(name, mode) {\n//   mode.name = name;\n//   mode.controller = this;\n//   this.modes[name] = mode;\n// };\n\n// t3djs.CameraController.prototype.changeMode = function(name, param) {\n//   if (this.curMode) {\n//     this.curMode.onLeave();\n//     this.curMode = null;\n//   }\n\n//   if (!name || name.length === 0 || !this.modes[name]) {\n//     return false;\n//   }\n\n//   this.curMode = this.modes[name];\n\n//   var rt = this.curMode.onEnter(this.camera, param);\n//   return rt;\n// };\n\n// t3djs.CameraController.prototype.update = function(frameTime) {\n//   if (this.curMode) {\n//     this.curMode.onUpdate(frameTime);\n//   }\n// };\n\n// t3djs.CameraController.prototype.getHelpString = function() {\n//   var str = '';\n//   if (this.curMode) {\n//     var pos = this.curMode.camera.getDerivedPosition();\n//     var center = this.curMode.center;\n//     str += 'var pos = [';\n//     str += pos[0].toFixed(2) + ', ' + pos[1].toFixed(2) + ', ' + pos[2].toFixed(2) + ']; ';\n//     str += 'var center = [';\n//     str += center[0].toFixed(2) + ', ' + center[1].toFixed(2) + ', ' + center[2].toFixed(2) + '];';\n//   }\n//   return str;\n// };\n\n//# sourceURL=webpack:///./src/camera/CameraController.js?")
        },
        "./src/camera/camera.js": /*!******************************!*\
  !*** ./src/camera/camera.js ***!
  \******************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _viewport = __webpack_require__(/*! ./viewport.js */ \"./src/camera/viewport.js\");\n\nvar _viewport2 = _interopRequireDefault(_viewport);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n  init: function init(camera, dom) {\n\n    this.raycaster = new THREE.Raycaster();\n    this.width = window.innerWidth;\n    this.height = window.innerHeight;\n    this.camera = camera;\n    this.lookAtArr = [0, 0, 0];\n    this.dom = dom;\n    this.lookAtArr = [0, 0, 0];\n\n    this.lastPos = [];\n    this.lastRay = {};\n  },\n  getFOV: function getFOV() {\n    return this.camera.fov;\n  },\n  setPosition: function setPosition(inX, inY, inZ) {\n    var x, y, z;\n    if (Array.isArray(arguments[0])) {\n      x = inX[0];\n      y = inX[1];\n      z = inX[2];\n    } else {\n      x = inX;\n      y = inY;\n      z = inZ;\n    }\n\n    var cameraPos = new THREE.Vector3(x, y, z);\n    this.camera.position.copy(cameraPos);\n  },\n  getPosition: function getPosition() {\n    var position = new THREE.Vector3();\n    position.copy(this.camera.position);\n    var result = [position.x, position.y, position.z];\n    return result;\n  },\n  getLookAt: function getLookAt() {\n\n    return this.lookAtArr;\n  },\n  setLookAt: function setLookAt(inX, inY, inZ) {\n\n    this.lookAt(inX, inY, inZ);\n  },\n  lookAt: function lookAt(inX, inY, inZ) {\n    var x, y, z;\n    if (Array.isArray(arguments[0])) {\n      x = inX[0];\n      y = inX[1];\n      z = inX[2];\n    } else {\n      x = inX;\n      y = inY;\n      z = inZ;\n    }\n\n    this.lookAtArr = [x, y, z];\n    var la = new THREE.Vector3(x, y, z);\n    this.camera.lookAt(la);\n  },\n  getSceneManager: function getSceneManager() {},\n  setAutoTracking: function setAutoTracking() {},\n  getDerivedPosition: function getDerivedPosition() {\n    var pos = this.camera.position;\n    return [pos.x, pos.y, pos.z];\n  },\n  getDerivedDirection: function getDerivedDirection() {\n    var direction = new THREE.Vector3();\n    this.camera.getWorldDirection(direction);\n    return [direction.x, direction.y, direction.z];\n  },\n  getCameraToViewportRay: function getCameraToViewportRay(pos) {\n\n    // var mouse = new THREE.Vector2(Number(pos[0]), Number(pos[1]));\n    // \n    if (this.lastPos.toString() == pos.toString()) {\n      return this.lastRay;\n    }\n    var x = pos[0];\n    var y = pos[1];\n    var myMouse = new THREE.Vector2();\n    myMouse.x = x / this.width * 2 - 1;\n    myMouse.y = -(y / this.height) * 2 + 1;\n\n    this.raycaster.setFromCamera(myMouse, this.camera);\n    var ray = {\n      ori: [this.raycaster.ray.origin.x, this.raycaster.ray.origin.y, this.raycaster.ray.origin.z],\n      dir: [this.raycaster.ray.direction.x, this.raycaster.ray.direction.y, this.raycaster.ray.direction.z]\n    };\n    this.lastRay = ray;\n    return ray;\n  },\n  getViewport: function getViewport() {\n    return new _viewport2.default(this.camera, this.dom);\n  },\n  isGoing: function isGoing() {\n    return true;\n  },\n  stopGoing: function stopGoing() {},\n  moveRelative: function moveRelative(inX, inY, inZ) {\n\n    var x, y, z;\n    if (Array.isArray(arguments[0])) {\n      x = inX[0];\n      y = inX[1];\n      z = inX[2];\n    } else {\n      x = inX;\n      y = inY;\n      z = inZ;\n    }\n\n    var pos = this.camera;\n    pos.translateX(x);\n    pos.translateY(y);\n    pos.translateZ(z);\n    /*\r\n    var old = this.getPosition();\r\n    var nx = old[0] + dx;\r\n    var ny = old[1] + dy;\r\n    var nz = old[2] + dz;\r\n    this.setPosition(nx, ny, nz);*/\n  },\n  getScreenCoords: function getScreenCoords(pos) {\n    var vector = new THREE.Vector3(pos[0], pos[1], pos[2]);\n    vector.project(this.camera);\n\n    var width = this.width,\n        height = this.height;\n    var widthHalf = width / 2,\n        heightHalf = height / 2;\n    vector.x = vector.x * widthHalf + widthHalf;\n    vector.y = -(vector.y * heightHalf) + heightHalf;\n    return [vector.x, vector.y];\n  },\n  getSpriteScreenCoords: function getSpriteScreenCoords(pos) {\n    var vector = new THREE.Vector3(pos[0], pos[1], pos[2]);\n    vector.project(this.camera);\n\n    var width = this.width,\n        height = this.height;\n    var widthHalf = width / 2,\n        heightHalf = height / 2;\n    vector.x = vector.x * widthHalf;\n    vector.y = vector.y * heightHalf;\n    return [vector.x, vector.y];\n  },\n  //TODO 临时添加\n  getDirection: function getDirection() {\n    var direction = new THREE.Vector3();\n    this.camera.getWorldDirection(direction);\n    return [direction.x, direction.y, direction.z];\n  },\n  //TODO 临时添加\n  getUp: function getUp() {\n    var p1 = this.camera.convertLocalToWorldPosition([0, 1, 0]);\n    var p2 = this.camera.convertLocalToWorldPosition([0, 0, 0]);\n    var result = [p1[0] - p2[0], p1[1] - p2[1], p1[2] - p2[2]];\n    return result;\n  },\n  setNear: function setNear(dis) {\n    if (this.camera.type == 'PerspectiveCamera') {\n      this.camera.near = dis;\n    } else {\n      this.camera.setNear(dis);\n    }\n    if (this.camera.updateProjectionMatrix) {\n      this.camera.updateProjectionMatrix();\n    }\n  },\n  setFar: function setFar(dis) {\n    if (this.camera.type == 'PerspectiveCamera') {\n      this.camera.far = dis;\n    } else {\n      this.camera.setFar(dis);\n    }\n    if (this.camera.updateProjectionMatrix) {\n      this.camera.updateProjectionMatrix();\n    }\n  },\n  setNearClipDistance: function setNearClipDistance(dis) {\n    if (this.camera.type == 'PerspectiveCamera') {\n      this.camera.near = dis;\n    } else {\n      this.camera.setNear(dis);\n    }\n    if (this.camera.updateProjectionMatrix) {\n      this.camera.updateProjectionMatrix();\n    }\n  },\n  setFarClipDistance: function setFarClipDistance(dis) {\n    if (this.camera.type == 'PerspectiveCamera') {\n      this.camera.far = dis;\n    } else {\n      this.camera.setFar(dis);\n    }\n    if (this.camera.updateProjectionMatrix) {\n      this.camera.updateProjectionMatrix();\n    }\n  },\n  setFixedYawAxis: function setFixedYawAxis(useFixed, fixedAxis) {\n    if (useFixed) {\n      this.camera.up.set(fixedAxis[0], fixedAxis[1], fixedAxis[2]);\n    } else {\n      this.camera.up.set(0, 1, 0);\n    }\n  },\n  //新增的最新接口，主要是为了兼容虚拟位置\n  getCameraInfo: function getCameraInfo() {\n    var pos = this.camera._getWorldPosition();\n    var cameraPos = [pos.x, pos.y, pos.z];\n\n    var viewPort = this.getViewport();\n    var fov = this.getFOV();\n    var matrixWorld = this.camera._getMatrixWorld();\n    //cameraDirection\n    var direction = new THREE.Vector3();\n    var e = matrixWorld.elements;\n    direction.set(e[8], e[9], e[10]).normalize();\n    var dir = [-direction.x, -direction.y, -direction.z];\n    //up\n    var v1 = new THREE.Vector3(0, 1, 0);\n    var v2 = new THREE.Vector3(0, 0, 0);\n    var p1 = v1.applyMatrix4(matrixWorld);\n    var p2 = v2.applyMatrix4(matrixWorld);\n    var cameraUp = [p1.x - p2.x, p1.y - p2.y, p1.z - p2.z];\n    //cameraInfo\n    var cameraInfo = {\n      cameraPos: cameraPos,\n      viewPort: viewPort,\n      fov: fov,\n      cameraDirection: dir,\n      cameraUp: cameraUp\n    };\n    return cameraInfo;\n  }\n};\n\n//# sourceURL=webpack:///./src/camera/camera.js?")
        },
        "./src/camera/viewport.js": /*!********************************!*\
  !*** ./src/camera/viewport.js ***!
  \********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\n\nfunction viewport(camera, dom) {\n    this._camera = camera;\n    this.name = '0';\n    var _dom = dom;\n    var top = this.top = _dom.clientTop;\n    var left = this.left = _dom.clientLeft;\n    var width = _dom.clientWidth;\n    var height = _dom.clientHeight;\n    this.bottom = top + height;\n    this.right = left + width;\n    this.actualHeight = height;\n    this.actualWidth = width;\n}\n\nviewport.prototype.isPointInside = function (point2d) {\n    var result = this.left <= point2d[0] && this.right >= point2d[0] && this.top <= point2d[1] && this.bottom >= point2d[1];\n    return result;\n    /*var vec = new THREE.Vector3(0, 0, -10); //in front of camera\r\n    var camera = this._camera;\r\n    //check if within camera's view:\r\n    camera.updateMatrix(); // make sure camera's local matrix is updated\r\n    camera.updateMatrixWorld(); // make sure camera's world matrix is updated\r\n    camera.matrixWorldInverse.getInverse(camera.matrixWorld);\r\n      var frustum = new THREE.Frustum();\r\n    frustum.setFromMatrix(new THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));\r\n      if (frustum.containsPoint(vec)) {\r\n        //console.log('within camera view');\r\n        return true;\r\n    } else {\r\n        //console.log('outside camera view');\r\n        return false;\r\n    }*/\n};\n\nexports.default = viewport;\n\n//# sourceURL=webpack:///./src/camera/viewport.js?")
        },
        "./src/canvas/Canvas.js": /*!******************************!*\
  !*** ./src/canvas/Canvas.js ***!
  \******************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _buffer = __webpack_require__(/*! ../util/buffer.js */ \"./src/util/buffer.js\");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _helper = __webpack_require__(/*! ../util/helper.js */ \"./src/util/helper.js\");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nvar _constant = __webpack_require__(/*! ../util/constant.js */ \"./src/util/constant.js\");\n\nvar _constant2 = _interopRequireDefault(_constant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction didNotReady(func) {\n  throw new Error(func + ' 方法没有实现');\n}\n\nvar FontStyle = _constant2.default.FontStyle;\nvar TextAlignment = _constant2.default.TextAlignment;\n/*var fontStyles = {\r\n    \"0\": \"\",\r\n    \"1\": \"Bold \",\r\n    \"2\": \"Italic \",\r\n    \"3\": \"Bold Italic \",\r\n    \"4\": \"\",\r\n    \"8\": \"\"\r\n};*/\n\nvar Canvas = function Canvas(name) {\n  this.name = name;\n  this._canvas = document.createElement('canvas');\n  this._context = this._canvas.getContext('2d');\n  this._image = document.createElement('img');\n  this._shadowBlur = 0;\n  this._fontShadowEnable = false;\n};\n\nCanvas.DEFAULT_FONT_HEIGHT = 4;\nCanvas.DEFAULT_FONT_FAMILY = 'Arial';\nCanvas.DEFAULT_FONT_SIZE = 14;\nCanvas.DEFAULT_FONT_STYLE = '';\n\nCanvas.ALING_H = ['left', 'center', 'right'];\nCanvas.ALING_V = ['top', 'middle', 'alphabetic'];\n\nCanvas.prototype.toString = function () {\n  return this.name;\n};\n\nCanvas.prototype.getWidth = function () {\n  var result = this._canvas.width;\n  return result;\n};\n\nCanvas.prototype.getHeight = function () {\n  var result = this._canvas.height;\n  return result;\n};\n\nCanvas.prototype.setSolidPen = function (clr, width) {\n  this._context.fillStyle = 'rgb(&r,&g,&b)'.replace('&r', clr[0]).replace('&g', clr[1]).replace('&b', clr[2]);\n  this._context.lineWidth = width;\n};\n\nCanvas.prototype.setGradientPen = function (p1, p2, clr1, clr2) {\n  //TODO 这个接口似乎没用过，优先级低\n  var style = this._context.createLinearGradient(p1[0], p1[1], p2[0], p2[1]);\n  var color1 = 'rgb(&r,&g,&b)'.replace('&r', clr1[0]).replace('&g', clr1[1]).replace('&b', clr1[2]);\n  var color2 = 'rgb(&r,&g,&b)'.replace('&r', clr2[0]).replace('&g', clr2[1]).replace('&b', clr2[2]);\n  style.addColorStop(0.0, color1);\n  style.addColorStop(1.0, color2);\n  this._context.strokeStyle = style;\n};\n\nCanvas.prototype.setPenColour = function (r, g, b, a) {\n  this._context.strokeStyle = 'rgba(&r,&g,&b,&a)'.replace('&r', r).replace('&g', g).replace('&b', b).replace('&a', a);\n};\n\nCanvas.prototype.setPenWidth = function (width) {\n  this._context.lineWidth = width;\n};\n\nCanvas.prototype.setPenAlignment = function (align) {\n  //doCommand(33542, this.name, align);\n};\n\nCanvas.prototype.setPenStartCap = function (cap) {\n  return didNotReady('setPenStartCap');\n};\n\nCanvas.prototype.setPenEndCap = function (cap) {\n  return didNotReady('setPenEndCap');\n};\n\nCanvas.prototype.setPenLineJoin = function (join) {\n  return didNotReady('setPenLineJoin');\n};\n\nCanvas.prototype.setPenDashStyle = function (style) {\n  return didNotReady('setPenDashStyle');\n};\n\nCanvas.prototype.setPenDashCap = function (cap) {\n  return didNotReady('setPenDashCap');\n};\n\nCanvas.prototype.setPenDashOffset = function (offset) {\n  return didNotReady('setPenDashOffset');\n};\n\nCanvas.prototype.setSolidBrush = function (r, g, b, a) {\n  r = r * 255 | 0;\n  g = g * 255 | 0;\n  b = b * 255 | 0;\n  this._context.fillStyle = 'rgba(&r,&g,&b,&a)'.replace('&r', r).replace('&g', g).replace('&b', b).replace('&a', a);\n};\n\nCanvas.prototype.setGradientBrush = function (p1, p2, clr1, clr2) {\n  var style = this._context.createLinearGradient(p1[0], p1[1], p2[0], p2[1]);\n  var color1 = 'rgb(&r,&g,&b)'.replace('&r', clr1[0]).replace('&g', clr1[1]).replace('&b', clr1[2]);\n  var color2 = 'rgb(&r,&g,&b)'.replace('&r', clr2[0]).replace('&g', clr2[1]).replace('&b', clr2[2]);\n  style.addColorStop(0.0, color1);\n  style.addColorStop(1.0, color2);\n  this._context.fillStyle = style;\n};\n\nCanvas.prototype.drawLine = function (p1, p2) {\n  this._context.moveTo(p1[0], p1[1]);\n  this._context.lineTo(p2[0], p2[1]);\n  this._context.stroke();\n};\n\nCanvas.prototype.drawLines = function (data) {\n  //TODO 参数结构没查到，猜一个\n  if (data.length > 1) {\n    this._context.moveTo(data[0][0], data[0][1]);\n    for (var i = 0; i < data.length; i++) {\n      this._context.lineTo(data[i][0], data[i][1]);\n    }\n    this._context.stroke();\n  }\n};\n\nCanvas.prototype.drawRectangle = function (x, y, width, height) {\n  //避免虚框\n  // this._context.rect((x | 0) + 0.5, (y | 0) + 0.5, width | 0, height | 0);\n  this._context.rect(x, y, width, height);\n  this._context.stroke();\n};\n\nCanvas.prototype.drawEllipse = function (x, y, width, height) {\n  //TODO 这个也没用到\n  this._context.moveTo(100, 200);\n  this._context.ellipse(300, 200, 100, 60, 0, 0, Math.PI, true);\n  this._context.stroke();\n};\n\nCanvas.prototype.drawArc = function (x, y, width, height, startAngle, endAngle, sweepAngle) {\n  //TODO 没用到\n  this._context.save();\n  this._context.fillStyle = '#ff0000';\n  this._context.beginPath();\n  this._context.arc(x, y, 2, startAngle, endAngle, sweepAngle);\n  this._context.closePath();\n  this._context.fill();\n  this._context.restore();\n};\n\nCanvas.prototype.fillRectangle = function (x, y, width, height) {\n  //console.log(\"fillRectangle %d %d\", width, height);\n  this._context.fillRect(x, y, width, height);\n};\n\nCanvas.prototype.fillEllipse = function (x, y, width, height) {\n  return didNotReady('fillEllipse');\n};\n\nCanvas.prototype.fillPie = function (x, y, width, height, startAngle, sweepAngle) {\n  return didNotReady('fillPie');\n};\n\nCanvas.prototype.setFont = function () {\n  var fontFamily = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Canvas.DEFAULT_FONT_FAMILY;\n  var fontSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Canvas.DEFAULT_FONT_SIZE;\n  var fontStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n\n  this._context._fontStyle = fontStyle;\n  this._context._fontSize = fontSize;\n  this._context._fontFamily = fontFamily;\n  this._context.font = fontStyle + fontSize + 'px ' + fontFamily;\n};\n\nCanvas.prototype.setFontShadow = function (enabled, thickness, clr, offset) {\n  this._fontShadowEnable = enabled;\n  this._shadowBlur = 0;\n  this._context.shadowOffsetX = 3;\n  this._context.shadowOffsetY = 3;\n  this._context.shadowColor = 'rgba(0,0,0,0)';\n  this._context.shadowBlur = 0;\n};\n\nCanvas.prototype.measureText = function (text, fontFamily, fontSize, fontStyle, penWidth) {\n  var w = 0;\n  var h = 0;\n  if (!isNaN(text)) text = text + '';\n  var rows = text.split('\\n');\n\n  if (arguments.length === 1) {\n\n    for (var i = 0; i < rows.length; i++) {\n      w = Math.max(this._context.measureText(text).width, w);\n      h += fontSize;\n    }\n    return w;\n  }\n\n  this._context.save();\n  if (fontFamily && fontSize) this.setFont(fontFamily, fontSize, fontStyle);\n  for (var _i = 0; _i < rows.length; _i++) {\n    w = Math.max(this._context.measureText(rows[_i]).width, w);\n    h += fontSize + Canvas.DEFAULT_FONT_HEIGHT;\n  }\n  this._context.restore();\n  w += 15;\n  h += Canvas.DEFAULT_FONT_HEIGHT;\n  return [w, h];\n};\n\nCanvas.prototype.drawText = function (text, clr, pos) {\n  if (text === undefined || text === null) return;\n  if (typeof text !== 'string') text = text + '';\n\n  var texth = this._context._textH > -1 ? this._context._textH : TextAlignment.Center;\n  var textv = this._context._textV > -1 ? this._context._textV : TextAlignment.Center;\n\n  var alignH = Canvas.ALING_H[texth] || Canvas.ALING_H[1];\n  var alignV = Canvas.ALING_V[textv] || Canvas.ALING_V[1];\n  if (!isNaN(text)) text = text + '';\n  var rows = text.split('\\n');\n\n  /*this._context.save();\r\n  this._context.fillStyle = '#999900';\r\n  this._context.fillRect(0, 0, this._canvas.width, this._canvas.height);\r\n  this._context.restore();*/\n\n  this._context.save();\n  var r = clr[0] * 255 | 0;\n  var g = clr[1] * 255 | 0;\n  var b = clr[2] * 255 | 0;\n  this._context.textAlign = alignH;\n  this._context.textBaseline = alignV;\n  this._context.fillStyle = 'rgb(&r,&g,&b)'.replace('&r', r).replace('&g', g).replace('&b', b);\n\n  var offset = 0;\n  if (textv === TextAlignment.TOP) {\n    offset = 1;\n  } else if (text === TextAlignment.BOTTOM) {\n    offset = -1;\n  }\n\n  for (var i = 0; i < rows.length; i++) {\n    var p1 = pos[1] + 1 + i * (this._context._fontSize + Canvas.DEFAULT_FONT_HEIGHT) - (rows.length - 1) * (this._context._fontSize + Canvas.DEFAULT_FONT_HEIGHT) / 2;\n    this._context.fillText(rows[i], pos[0], p1);\n  }\n  this._context.restore();\n};\n\nCanvas.prototype.drawOutlineText = function (text, thickness, clr, outlineClr, pos) {\n  if (typeof text !== 'string') return;\n\n  var texth = this._context._textH > -1 ? this._context._textH : TextAlignment.Center;\n  var textv = this._context._textV > -1 ? this._context._textV : TextAlignment.Center;\n\n  var alignH = Canvas.ALING_H[texth] || Canvas.ALING_H[1];\n  var alignV = Canvas.ALING_V[textv] || Canvas.ALING_V[1];\n\n  if (thickness === undefined) thickness = 2;\n  if (outlineClr === undefined) outlineClr = [0, 0, 0];\n\n  /*this._context.save();\r\n  this._context.fillStyle = '#999900';\r\n  this._context.fillRect(0, 0, this._canvas.width, this._canvas.height);\r\n  this._context.restore();*/\n\n  this._context.save();\n\n  this._context.shadowBlur = thickness;\n  var r = outlineClr[0] * 255 | 0;\n  var g = outlineClr[1] * 255 | 0;\n  var b = outlineClr[2] * 255 | 0;\n  this._context.shadowColor = 'rgb(&r,&g,&b)'.replace('&r', r).replace('&g', g).replace('&b', b);\n  this._context.shadowOffsetX = 0;\n  this._context.shadowOffsetY = 0;\n  r = clr[0] * 255 | 0;\n  g = clr[1] * 255 | 0;\n  b = clr[2] * 255 | 0;\n  this._context.fillStyle = 'rgb(&r,&g,&b)'.replace('&r', r).replace('&g', g).replace('&b', b);\n  this._context.textAlign = alignH;\n  this._context.textBaseline = alignV;\n  if (!isNaN(text)) text = text + '';\n  var rows = text.split('\\n');\n  for (var i = 0; i < rows.length; i++) {\n    var p1 = pos[1] + i * (this._context._fontSize + Canvas.DEFAULT_FONT_HEIGHT) - (rows.length - 1) * (this._context._fontSize + Canvas.DEFAULT_FONT_HEIGHT) / 2;\n    this._context.fillText(rows[i], pos[0], p1);\n  }\n  this._context.restore();\n};\n\nCanvas.prototype.setTextAlignment = function (h, v) {\n  this._context._textH = h;\n  this._context._textV = v;\n};\n\nCanvas.prototype.updateTexture = function () {\n  //TODO 只有一处调用\n  //doCommand(33564, this.name);\n  //console.warn('setTextAlignment didNotReady');\n};\n\nCanvas.prototype.getTexture = function () {\n  //TODO 优化一下,这里可能有问题\n  var image = new Image();\n  // var image = this._image;\n  if (!image.src) {\n    image.width = this._canvas.width;\n    image.height = this._canvas.height;\n  }\n  image.src = this._canvas.toDataURL('image/png');\n  return image;\n};\n\nCanvas.prototype.createTexture = function (name) {\n  name = name ? name : _helper2.default.getUUID();\n  var texture = _buffer2.default.textureBuffer.get(name);\n  if (!texture) {\n    texture = new THREE.Texture();\n    texture.name = name;\n    _buffer2.default.textureBuffer.add(name, texture);\n  }\n  var image = texture.image;\n  if (!image) {\n    image = document.createElement('img');\n    texture.image = image;\n  }\n  image.width = this._canvas.width;\n  image.height = this._canvas.height;\n  image.src = this._canvas.toDataURL('image/png');\n  texture.anisotropy = 16;\n  texture.needsUpdate = true;\n  return texture;\n};\n\nCanvas.prototype.drawTexture = function (tex) {\n  tex.image.src = this._canvas.toDataURL('image/png');\n  tex.needsUpdate = true;\n};\n\nCanvas.prototype.clear = function (r, g, b, a) {\n  r = r || 0;\n  g = g || 0;\n  b = b || 0;\n  a = a || 0;\n  var color = 'rgba(&r,&g,&b,&a)'.replace('&r', r).replace('&g', g).replace('&b', b).replace('&a', a);\n  this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);\n  this._context.save();\n  this._context.fillStyle = color;\n  this._context.fillRect(0, 0, this._canvas.width, this._context.height);\n  this._context.restore();\n};\n\nCanvas.prototype.destroy = function () {\n  //doCommand(33569, this.name);\n};\n\n/**\r\n *@description 增加canvas接口，用于矢量图标的canvas计算\r\n *@author zhuguang <zhuguang@uinnova.com>\r\n *@param {Object} param参数列表\r\n *@param {String}\r\n *@date 2018/10/15 16:24:58\r\n */\nCanvas.prototype.createSymbol = function (symbol) {\n  var _max = symbol.maxRatio === undefined ? 0.1 : symbol.maxRatio;\n  var lineWidth = symbol.lineWidth === undefined ? 1 : symbol.lineWidth;\n  var width = symbol.width || 256;\n  var height = symbol.height || 256;\n  var color = symbol.color ? _colorToRgba(symbol.color) : 'rgba(255,0,0,1)';\n  var lineColor = symbol.lineColor ? _colorToRgba(symbol.lineColor) : 'rgba(0,0,255,1)';\n  var type = symbol.type || 'circle';\n  var mapCanvas = this._canvas;\n  mapCanvas.width = width;\n  mapCanvas.height = height;\n  mapCanvas.style.position = 'absolute';\n  mapCanvas.style.left = '0px';\n  mapCanvas.style.top = '0px';\n  //首先先清空canvas\n  this._context.clearRect(0, 0, mapCanvas.width, mapCanvas.height);\n  if (type === 'circle') {\n    this.createCircle(width, height, color, lineColor, lineWidth, _max);\n  } else if (type === 'rectangle') {\n    this.createRectangle(width, height, color, lineColor, lineWidth, _max);\n  } else if (type === 'cross') {\n    this.createCross(width, height, color, lineColor, lineWidth, _max);\n  } else if (type === 'triangle') {\n    this.createTriangle(width, height, color, lineColor, lineWidth, _max);\n  }\n};\n\nCanvas.prototype.createCircle = function (width, height, color, lineColor, lineWidth, max) {\n  var ctx = this._context;\n  lineWidth = lineWidth / width > max ? max * width : lineWidth;\n  ctx.beginPath();\n  var centerX = width / 2;\n  var centerY = height / 2;\n  var radius = height / 2 - 2 * max * width;\n  ctx.arc(centerX, centerY, radius, 0, Math.PI * 2, false);\n  ctx.fillStyle = color; //半透明的红色\n  ctx.fill();\n  if (lineWidth) {\n    ctx.strokeStyle = lineColor;\n    ctx.lineWidth = lineWidth;\n    ctx.stroke();\n  }\n};\nCanvas.prototype.createRectangle = function (width, height, color, lineColor, lineWidth, max) {\n  var ctx = this._context;\n  lineWidth = lineWidth / width > max ? max * width : lineWidth;\n  ctx.beginPath();\n  var x0 = max * width;\n  var y0 = max * height;\n  var width0 = width * (1 - 2 * max);\n  var height0 = height * (1 - 2 * max);\n  ctx.rect(x0, y0, width0, height0);\n  ctx.fillStyle = color; //半透明的红色\n  ctx.fill();\n  if (lineWidth) {\n    ctx.strokeStyle = lineColor;\n    ctx.lineWidth = lineWidth;\n    ctx.stroke();\n  }\n};\n\nCanvas.prototype.createCross = function (width, height, color, lineColor, lineWidth, max) {\n  var ctx = this._context;\n  lineWidth = lineWidth / width > max ? max * width : lineWidth;\n  ctx.beginPath();\n  ctx.strokeStyle = lineColor;\n  ctx.lineWidth = lineWidth;\n  ctx.moveTo(width / 2, height * max);\n  ctx.lineTo(width / 2, height - height * max);\n  ctx.moveTo(width * max, height / 2);\n  ctx.lineTo(width - width * max, height / 2);\n  if (lineWidth) {\n    ctx.stroke();\n  }\n};\nCanvas.prototype.createTriangle = function (width, height, color, lineColor, lineWidth, max) {\n  var ctx = this._context;\n  lineWidth = lineWidth / width > max ? max * width : lineWidth;\n  ctx.beginPath();\n  ctx.fillStyle = color; //半透明的红色\n  ctx.strokeStyle = lineColor;\n  ctx.lineWidth = lineWidth;\n  ctx.moveTo(width / 2, height * max);\n  ctx.lineTo(width * max, height - height * max);\n  ctx.lineTo(width - width * max, height - height * max);\n  ctx.lineTo(width / 2, height * max);\n  ctx.fill();\n  if (lineWidth) {\n    ctx.stroke();\n  }\n};\nCanvas.prototype.getCanvas = function () {\n  return this._canvas;\n};\nfunction _colorToRgba(color) {\n  var vColor = color;\n  var alpha = 1;\n  if (color.length && color.length === 4) {\n    vColor = [color[0], color[1], color[2]];\n    alpha = color[3];\n  }\n  return 'rgba(' + vColor.map(function (v) {\n    return v * 255;\n  }).toString() + ',' + alpha + ')';\n}\n// function  _rbgaToColor (rColor){\n//     let arr = rColor.split('rgba(')[1].split(',');\n//     return [arr[0]/255, arr[1]/255, arr[2]/255];\n// }\n\nexports.default = Canvas;\n\n//# sourceURL=webpack:///./src/canvas/Canvas.js?")
        },
        "./src/canvas/canvasManager.js": /*!*************************************!*\
  !*** ./src/canvas/canvasManager.js ***!
  \*************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _Canvas = __webpack_require__(/*! ./Canvas.js */ "./src/canvas/Canvas.js");\n\nvar _Canvas2 = _interopRequireDefault(_Canvas);\n\nvar _helper = __webpack_require__(/*! ../util/helper.js */ "./src/util/helper.js");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar canvasQueen = {};\nvar measureCanvas = new _Canvas2.default(\'measure\');\n\nexports.default = {\n    getCanvas: function getCanvas(name) {\n        return canvasQueen[name];\n    },\n    //TODO 测试使用接口\n    getAllCanvas: function getAllCanvas() {\n        var result = [];\n        for (var pro in canvasQueen) {\n            result.push(canvasQueen[pro]);\n        }\n        return result;\n    },\n    createCanvas: function createCanvas(name, width, height) {\n        name = name ? name : _helper2.default.getUUID();\n        var canvas = new _Canvas2.default(name);\n        canvas._canvas.width = width;\n        canvas._canvas.height = height;\n        canvasQueen[name] = canvas;\n        return canvas;\n    },\n    destroyCanvas: function destroyCanvas(name) {\n        canvasQueen[name] = null;\n        delete canvasQueen[name];\n    },\n    destroyAllCanvases: function destroyAllCanvases() {\n        for (var pro in canvasQueen) {\n            canvasQueen[pro] = null;\n            delete canvasQueen[pro];\n        }\n    },\n    getTextBounds: function getTextBounds(text, fontFamily, fontSize, fontStyle, penWidth) {\n        return measureCanvas.measureText(text, fontFamily, fontSize, fontStyle, penWidth);\n    },\n    /**\r\n     *@description 通过canvas实现矢量标记绘制\r\n     *@author zhuguang <zhuguang@uinnova.com>\r\n     *@param {Object} param参数列表\r\n     *@param {String}\r\n     *@date 2018/10/15 16:34:08\r\n     */\n    createSymbol: function createSymbol(symbol, name) {\n        name = name ? name : _helper2.default.getUUID();\n        var canvas;\n        if (canvasQueen[name]) {\n            canvas = canvasQueen[name];\n            canvas.createSymbol(symbol);\n        } else {\n            canvas = new _Canvas2.default(name);\n            canvasQueen[name] = canvas;\n            canvas.createSymbol(symbol);\n        }\n\n        return canvas;\n    }\n};\n\n//# sourceURL=webpack:///./src/canvas/canvasManager.js?')
        },
        "./src/event/CursorType.js": /*!*********************************!*\
  !*** ./src/event/CursorType.js ***!
  \*********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.default = {\n    POINTER: 0,\n    CROSS: 1,\n    HAND: 2,\n    IBEAM: 3,\n    WAIT: 4,\n    HELP: 5\n};\n\n//# sourceURL=webpack:///./src/event/CursorType.js?')
        },
        "./src/event/EventButton.js": /*!**********************************!*\
  !*** ./src/event/EventButton.js ***!
  \**********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = { 'Left': 0, 'Right': 1, 'Middle': 2, 'LEFT': 0, 'RIGHT': 1, 'MIDDLE': 2 };\n\n//# sourceURL=webpack:///./src/event/EventButton.js?")
        },
        "./src/event/KeyCode.js": /*!******************************!*\
  !*** ./src/event/KeyCode.js ***!
  \******************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n//直接从t3djs里面搞过来的\nexports.default = {\n\t/** ESCAPE */\n\tKC_ESCAPE: 0x01,\n\t/** Keyboard '1'~ */\n\tKC_1: 0x02,\n\tKC_2: 0x03,\n\tKC_3: 0x04,\n\tKC_4: 0x05,\n\tKC_5: 0x06,\n\tKC_6: 0x07,\n\tKC_7: 0x08,\n\tKC_8: 0x09,\n\tKC_9: 0x0A,\n\t/** Keyboard ~'0'*/\n\tKC_0: 0x0B,\n\t/** - on main keyboard */\n\tKC_MINUS: 0x0C,\n\tKC_EQUALS: 0x0D,\n\t/** backspace */\n\tKC_BACK: 0x0E,\n\t/** tab */\n\tKC_TAB: 0x0F,\n\tKC_Q: 0x10,\n\tKC_W: 87,\n\tKC_E: 0x12,\n\tKC_R: 0x13,\n\tKC_T: 0x14,\n\tKC_Y: 0x15,\n\tKC_U: 0x16,\n\tKC_I: 0x17,\n\tKC_O: 0x18,\n\tKC_P: 0x19,\n\tKC_LBRACKET: 0x1A,\n\tKC_RBRACKET: 0x1B,\n\t/** Enter on main keyboard */\n\tKC_RETURN: 0x1C,\n\t/** Left control */\n\tKC_LCONTROL: 0x1D,\n\t/** Keyboard 'A'~*/\n\tKC_A: 65,\n\tKC_S: 83,\n\tKC_D: 68,\n\tKC_F: 0x21,\n\tKC_G: 0x22,\n\tKC_H: 0x23,\n\tKC_J: 0x24,\n\tKC_K: 0x25,\n\tKC_L: 0x26,\n\tKC_SEMICOLON: 0x27,\n\tKC_APOSTROPHE: 0x28,\n\t/** accent grave */\n\tKC_GRAVE: 0x29,\n\tKC_LSHIFT: 0x2A,\n\tKC_BACKSLASH: 0x2B,\n\tKC_Z: 0x2C,\n\tKC_X: 0x2D,\n\tKC_C: 0x2E,\n\tKC_V: 0x2F,\n\tKC_B: 0x30,\n\tKC_N: 0x31,\n\tKC_M: 0x32,\n\tKC_COMMA: 0x33,\n\t/** . on main keyboard */\n\tKC_PERIOD: 0x34,\n\t/** '/' on main keyboard */\n\tKC_SLASH: 0x35,\n\tKC_RSHIFT: 0x36,\n\t/** * on numeric keypad */\n\tKC_MULTIPLY: 0x37,\n\t/** left Alt */\n\tKC_LMENU: 0x38,\n\tKC_SPACE: 0x39,\n\tKC_CAPITAL: 0x3A,\n\tKC_F1: 0x3B,\n\tKC_F2: 0x3C,\n\tKC_F3: 0x3D,\n\tKC_F4: 0x3E,\n\tKC_F5: 0x3F,\n\tKC_F6: 0x40,\n\t// KC_F7: 0x41,\n\tKC_F8: 0x42,\n\tKC_F9: 0x43,\n\t// KC_F10: 0x44,\n\tKC_NUMLOCK: 0x45,\n\t/** Scroll Lock */\n\tKC_SCROLL: 0x46,\n\tKC_NUMPAD7: 0x47,\n\tKC_NUMPAD8: 0x48,\n\tKC_NUMPAD9: 0x49,\n\t/** - on numeric keypad */\n\tKC_SUBTRACT: 0x4A,\n\tKC_NUMPAD4: 0x4B,\n\tKC_NUMPAD5: 0x4C,\n\tKC_NUMPAD6: 0x4D,\n\t/** + on numeric keypad */\n\tKC_ADD: 0x4E,\n\tKC_NUMPAD1: 0x4F,\n\tKC_NUMPAD2: 0x50,\n\tKC_NUMPAD3: 0x51,\n\tKC_NUMPAD0: 0x52,\n\t/** . on numeric keypad */\n\t// KC_DECIMAL: 0x53,\n\t/** < > | on UK/Germany keyboards */\n\tKC_OEM_102: 0x56,\n\t// KC_F11: 0x57,\n\tKC_F12: 0x58,\n\t/** (NEC PC98) */\n\tKC_F13: 0x64,\n\t/** (NEC PC98) */\n\tKC_F14: 0x65,\n\t/** (NEC PC98) */\n\tKC_F15: 0x66,\n\t/** (Japanese keyboard) */\n\tKC_KANA: 0x70,\n\t/** / ? on Portugese (Brazilian) keyboards */\n\tKC_ABNT_C1: 0x73,\n\t/** (Japanese keyboard) */\n\tKC_CONVERT: 0x79,\n\t/** (Japanese keyboard) */\n\tKC_NOCONVERT: 0x7B,\n\t/** (Japanese keyboard) */\n\tKC_YEN: 0x7D,\n\t/** Numpad . on Portugese (Brazilian) keyboards */\n\tKC_ABNT_C2: 0x7E,\n\t/** : on numeric keypad (NEC PC98) */\n\tKC_NUMPADEQUALS: 0x8D,\n\t/** Previous Track (KC_CIRCUMFLEX on Japanese keyboard) */\n\tKC_PREVTRACK: 0x90,\n\t/** (NEC PC98) */\n\tKC_AT: 0x91,\n\t/** (NEC PC98) */\n\tKC_COLON: 0x92,\n\t/** (NEC PC98) */\n\tKC_UNDERLINE: 0x93,\n\t/** (Japanese keyboard) */\n\tKC_KANJI: 0x94,\n\t/** (NEC PC98) */\n\tKC_STOP: 0x95,\n\t/** (Japan AX) */\n\tKC_AX: 0x96,\n\t/**    (J3100) */\n\tKC_UNLABELED: 0x97,\n\t/** Next Track */\n\tKC_NEXTTRACK: 0x99,\n\t/** Enter on numeric keypad */\n\tKC_NUMPADENTER: 0x9C,\n\t/** */\n\tKC_RCONTROL: 0x9D,\n\t/** Mute */\n\tKC_MUTE: 0xA0,\n\t/** Calculator */\n\tKC_CALCULATOR: 0xA1,\n\t/** Play / Pause */\n\tKC_PLAYPAUSE: 0xA2,\n\t/** Media Stop */\n\tKC_MEDIASTOP: 0xA4,\n\t/** Volume - */\n\tKC_VOLUMEDOWN: 0xAE,\n\t/** Volume + */\n\tKC_VOLUMEUP: 0xB0,\n\t/** Web home */\n\tKC_WEBHOME: 0xB2,\n\t/** , on numeric keypad (NEC PC98) */\n\tKC_NUMPADCOMMA: 0xB3,\n\t/** / on numeric keypad */\n\tKC_DIVIDE: 0xB5,\n\t/** */\n\tKC_SYSRQ: 0xB7,\n\t/** right Alt */\n\tKC_RMENU: 0xB8,\n\t/** Pause */\n\tKC_PAUSE: 0xC5,\n\t/** Home on arrow keypad */\n\tKC_HOME: 0xC7,\n\t/** UpArrow on arrow keypad */\n\tKC_UP: 0xC8,\n\t/** PgUp on arrow keypad */\n\tKC_PGUP: 0xC9,\n\t/** LeftArrow on arrow keypad */\n\tKC_LEFT: 0xCB,\n\t/** RightArrow on arrow keypad */\n\tKC_RIGHT: 0xCD,\n\t/** End on arrow keypad */\n\tKC_END: 0xCF,\n\t/** DownArrow on arrow keypad */\n\tKC_DOWN: 0xD0,\n\t/** PgDn on arrow keypad */\n\tKC_PGDOWN: 0xD1,\n\t/** Insert on arrow keypad */\n\tKC_INSERT: 0xD2,\n\t/** Delete on arrow keypad */\n\tKC_DELETE: 0xD3,\n\t/** Left Windows key */\n\tKC_LWIN: 0xDB,\n\t/** Right Windows key */\n\tKC_RWIN: 0xDC,\n\t/** AppMenu key */\n\tKC_APPS: 0xDD,\n\t/** System Power */\n\tKC_POWER: 0xDE,\n\t/** System Sleep */\n\tKC_SLEEP: 0xDF,\n\t/** System Wake */\n\tKC_WAKE: 0xE3,\n\t/** Web Search */\n\tKC_WEBSEARCH: 0xE5,\n\t/** Web Favorites */\n\tKC_WEBFAVORITES: 0xE6,\n\t/** Web Refresh */\n\tKC_WEBREFRESH: 0xE7,\n\t/** Web Stop */\n\tKC_WEBSTOP: 0xE8,\n\t/** Web Forward */\n\tKC_WEBFORWARD: 0xE9,\n\t/** Web Back */\n\tKC_WEBBACK: 0xEA,\n\t/** My Computer */\n\tKC_MYCOMPUTER: 0xEB,\n\t/** Mail */\n\tKC_MAIL: 0xEC,\n\t/** Media Select */\n\tKC_MEDIASELECT: 0xED\n};\n\n//# sourceURL=webpack:///./src/event/KeyCode.js?")
        },
        "./src/event/MouseButtonID.js": /*!************************************!*\
  !*** ./src/event/MouseButtonID.js ***!
  \************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n\tvalue: true\n});\nexports.default = {\n\t/** Left button */\n\tLeft: 0,\n\t/** Right button */\n\tRight: 1,\n\t/** Middle button */\n\tMiddle: 2,\n\t/** Left button */\n\tLEFT: 0,\n\t/** Right button */\n\tRIGHT: 1,\n\t/** Middle button */\n\tMIDDLE: 2\n};\n\n//# sourceURL=webpack:///./src/event/MouseButtonID.js?')
        },
        "./src/event/event.js": /*!****************************!*\
  !*** ./src/event/event.js ***!
  \****************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.default = {\n    init: function init() {\n        var eventManager = new THREE.EventDispatcher();\n        this.eventManager = eventManager;\n    },\n    getEventManager: function getEventManager() {\n        return this.eventManager;\n    }\n};\n\n//# sourceURL=webpack:///./src/event/event.js?')
        },
        "./src/event/eventManager.js": /*!***********************************!*\
  !*** ./src/event/eventManager.js ***!
  \***********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar eventManager = function () {\n    function eventManager(dom) {\n        _classCallCheck(this, eventManager);\n\n        this.dom = dom;\n        document.addEventListener('keydown', function (e) {\n            if (e.code == 'ControlLeft' || e.code == 'ControlRight' || e.code == 'ShiftLeft' || e.code == 'ShiftRight') {\n                e.stopImmediatePropagation();\n            }\n        });\n    }\n\n    _createClass(eventManager, [{\n        key: 'addListener',\n        value: function addListener(name, func) {\n            this.func = func;\n\n            function callback(e) {\n                var flag = e.button;\n                //t3djs中的button表示和浏览器中的不一样\n                func(e.layerX, e.layerY, flag);\n            }\n\n            function mouseDownCallback(e) {\n                e.preventDefault();\n                var flag = e.button;\n                func(e.layerX, e.layerY, flag);\n            }\n\n            function mouseUpCallback(e) {\n                e.preventDefault();\n                var flag = e.button;\n                func(e.layerX, e.layerY, flag);\n            }\n\n            function dbCallback(e) {\n                e.preventDefault();\n                func(e.layerX, e.layerY, 0);\n            }\n\n            function moveCallback(e) {\n                e.preventDefault();\n                var flag = e.button;\n                func(e.offsetX, e.offsetY, flag);\n            }\n\n            function keyback(e) {\n                func(e.keyCode, 0);\n            }\n\n            function wheelBack(e) {\n                func(-e.deltaY, 0);\n            }\n\n            if (name == 'keydown' || name == 'keypress') {\n                document.addEventListener(name, keyback);\n            } else if (name == 'wheel') {\n                this.dom.addEventListener(name, wheelBack);\n            } else if (name == 'click') {\n                this.dom.addEventListener('click', callback);\n                this.dom.addEventListener('contextmenu', callback);\n            } else if (name == 'mousedown') {\n                this.dom.addEventListener(name, mouseDownCallback);\n            } else if (name == 'mouseup') {\n                this.dom.addEventListener(name, mouseUpCallback);\n            } else if (name == 'mousemove') {\n                this.dom.addEventListener(name, moveCallback);\n            } else if (name == 'dblclick') {\n                this.dom.addEventListener('dblclick', dbCallback);\n            } else {\n                this.dom.addEventListener(name, callback);\n            }\n        }\n    }, {\n        key: 'reomveListener',\n        value: function reomveListener(name) {\n            this.dom.removeEventListener(name);\n        }\n    }, {\n        key: 'onceListener',\n        value: function onceListener(name, func) {\n            this.func = func;\n            this.dom.addEventListener(name, this.cancleCallback);\n        }\n    }, {\n        key: 'cancleCallback',\n        value: function cancleCallback(e) {\n            this.reomveListener();\n        }\n    }]);\n\n    return eventManager;\n}();\n\nexports.default = eventManager;\n\n//# sourceURL=webpack:///./src/event/eventManager.js?")
        },
        "./src/event/input.js": /*!****************************!*\
  !*** ./src/event/input.js ***!
  \****************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _MouseButtonID = __webpack_require__(/*! ./MouseButtonID.js */ \"./src/event/MouseButtonID.js\");\n\nvar _MouseButtonID2 = _interopRequireDefault(_MouseButtonID);\n\nvar _KeyCode = __webpack_require__(/*! ./KeyCode.js */ \"./src/event/KeyCode.js\");\n\nvar _KeyCode2 = _interopRequireDefault(_KeyCode);\n\nvar _CursorType = __webpack_require__(/*! ./CursorType.js */ \"./src/event/CursorType.js\");\n\nvar _CursorType2 = _interopRequireDefault(_CursorType);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n  cur: {},\n  keyValue: '',\n  mouseState: {},\n  keyState: {},\n  mouseRel: {},\n  enable: true,\n  init: function init(dom) {\n    var cur = this.cur;\n    this.dom = dom;\n    var mouseRel = this.mouseRel;\n    dom.addEventListener('mousemove', function (e) {\n      mouseRel.x = e.offsetX - cur.posX;\n      cur.posX = e.offsetX;\n      mouseRel.y = e.offsetY - cur.posY;\n      cur.posY = e.offsetY;\n    });\n    var mouseState = this.mouseState;\n\n    var stateToReleased = function (state) {\n      var myFlag = 0;\n      return {\n        changeState: function changeState() {\n          state[myFlag] = 'released';\n        },\n        setFlag: function setFlag(flag) {\n          myFlag = flag;\n        }\n      };\n    }(mouseState);\n\n    document.oncontextmenu = function (e) {\n      return false;\n    };\n    dom.addEventListener('mousedown', function (e) {\n      // console.log(e.button);\n      var flag = e.button;\n      //t3djs中的button表示和浏览器中的不一样\n      if (e.button == 2) {\n        flag = 1;\n      } else if (e.button == 1) {\n        flag = 2;\n      }\n      mouseState[flag] = 'down';\n    });\n\n    //鼠标弹起时触发的方法\n    var mouseUpFunc = function mouseUpFunc(e) {\n      var flag = e.button;\n      //t3djs中的button表示和浏览器中的不一样\n      if (e.button == 2) {\n        flag = 1;\n      } else if (e.button == 1) {\n        flag = 2;\n      }\n      mouseState[flag] = 'up';\n\n      stateToReleased.setFlag(flag);\n      setTimeout(stateToReleased.changeState, 10);\n    };\n    dom.addEventListener('mouseup', mouseUpFunc);\n    var keyState = this.keyState;\n    var keyValue = this.keyValue;\n    window.addEventListener('keydown', function (e) {\n      keyValue = e.keyCode;\n      keyState[e.keyCode] = 'down';\n    });\n\n    window.addEventListener('keyup', function (e) {\n      keyValue = e.keyCode;\n      keyState[e.keyCode] = 'up';\n    });\n\n    this.dom.addEventListener('mouseleave', function () {\n      for (var pro in mouseState) {\n        mouseState[pro] = 'released';\n        mouseUpFunc({\n          button: Number(pro)\n        });\n      }\n    });\n\n    (function careateState(that) {\n      for (var mKey in _MouseButtonID2.default) {\n        that.mouseState[_MouseButtonID2.default[mKey]] = 'released';\n      }\n      for (var kKey in _KeyCode2.default) {\n        that.keyState[_KeyCode2.default[kKey]] = 'released';\n      }\n    })(this);\n  },\n  isShowCursor: function isShowCursor() {},\n  setEnabled: function setEnabled(enable) {\n    this.enable = enable;\n  },\n  setCursor: function setCursor(type, url) {\n    switch (type) {\n      case _CursorType2.default.POINTER:\n        this.dom.style.cursor = 'default';\n        break;\n      case _CursorType2.default.CROSS:\n        this.dom.style.cursor = 'crosshair';\n        break;\n      case _CursorType2.default.HAND:\n        this.dom.style.cursor = 'pointer';\n        break;\n      case _CursorType2.default.IBEAM:\n        this.dom.style.cursor = 'text';\n        break;\n      case _CursorType2.default.WAIT:\n        this.dom.style.cursor = 'wait';\n        break;\n      case _CursorType2.default.HELP:\n        this.dom.style.cursor = 'help';\n        break;\n      case _CursorType2.default.INITIAL:\n        if (url) {\n          this.dom.style = 'cursor:url(\"' + url + '\"),pointer';\n        } else {\n          this.dom.style.cursor = 'pointer';\n        }\n        break;\n      default:\n        this.dom.style.cursor = 'default';\n        break;\n    }\n    //TODO: 还没有实现\n  },\n  showCursor: function showCursor(flag) {\n    if (flag) {\n      this.dom.style.cursor = 'default';\n    } else {\n      this.dom.style.cursor = 'none';\n    }\n  },\n  getCursorPos: function getCursorPos() {\n    // if (!this.enable) {\n    //   return\n    // }\n    var x = isNaN(this.cur.posX) ? -1 : this.cur.posX;\n    var y = isNaN(this.cur.posY) ? -1 : this.cur.posY;\n    return [x, y];\n  },\n  isButtonDown: function isButtonDown(code) {\n    if (!this.enable) {\n      return;\n    }\n    return this.mouseState[code] == 'down' ? true : false;\n  },\n  isButtonPressed: function isButtonPressed(code) {\n    if (!this.enable) {\n      return;\n    }\n    return this.mouseState[code] == 'down' ? true : false;\n  },\n  isButtonReleased: function isButtonReleased(code) {\n    if (!this.enable) {\n      return;\n    }\n    return this.mouseState[code] == 'up' ? true : false;\n  },\n  getMouseRelX: function getMouseRelX() {\n    if (!this.enable) {\n      return;\n    }\n    return this.mouseRel.x;\n  },\n  getMouseRelY: function getMouseRelY() {\n    if (!this.enable) {\n      return;\n    }\n    return this.mouseRel.y;\n  },\n  getMouseRelZ: function getMouseRelZ() {\n    if (!this.enable) {\n      return;\n    }\n    return 0;\n  },\n  isKeyDown: function isKeyDown(code) {\n    if (!this.enable) {\n      return;\n    }\n    return this.keyState[code] == 'down' ? true : false;\n  },\n  isKeyReleased: function isKeyReleased(code) {\n    if (!this.enable) {\n      return;\n    }\n    return this.keyState[code] == 'up' ? true : false;\n  },\n  isKeyPressed: function isKeyPressed(code) {\n    if (!this.enable) {\n      return;\n    }\n    return this.keyState[code] == 'down' ? true : false;\n  }\n};\n\n//# sourceURL=webpack:///./src/event/input.js?")
        },
        "./src/extra/BillboardMesh.js": /*!************************************!*\
  !*** ./src/extra/BillboardMesh.js ***!
  \************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\n/**\r\n * @author Max Strater, Autodesk, Inc. / http://www.autodesk.com/\r\n *\r\n * A mesh that always faces a specified point (usually a camera).\r\n * Optionally, the mesh can be constrained to a specified axis.\r\n * If so, it will face the specified point as much as possible while remaining aligned with the axis.\r\n * If not constrained, the axis can be used as a custom up vector for the mesh.\r\n * Requires a call to the update method after each change.\r\n * Based on http://nehe.gamedev.net/article/billboarding_how_to/18011/\r\n */\n\n// expects a normalized axis\n// \n\nTHREE.BillboardMesh = function (geometry, material, point, axis, constrainedToAxis) {\n\n\tTHREE.Mesh.call(this, geometry, material);\n\n\tthis.point = point;\n\tthis.axis = axis || this.up;\n\tthis.constrained = constrainedToAxis || false;\n};\n\nTHREE.BillboardMesh.prototype = Object.create(THREE.Mesh.prototype);\nTHREE.BillboardMesh.prototype.constructor = THREE.BillboardMesh;\nTHREE.BillboardMesh.prototype.toString = function () {\n\treturn this.name;\n};\nTHREE.BillboardMesh.prototype.setDirection = function (vector) {\n\tthis.up.copy(vector);\n};\nTHREE.BillboardMesh.prototype.setRotation = function (rotate) {};\n\nTHREE.BillboardMesh.prototype.update = function () {\n\n\tfunction rotateMesh(mesh, towardPoint, up) {\n\n\t\tmesh.up = up;\n\t\tmesh.lookAt(towardPoint);\n\t}\n\n\tvar look = new THREE.Vector3();\n\tvar right = new THREE.Vector3();\n\n\tfunction rotateAxialConstrainedMesh(mesh, towardPoint, axis) {\n\n\t\tvar meshPosition = mesh.position.clone();\n\t\tlook.subVectors(towardPoint, meshPosition);\n\t\tright.crossVectors(axis, look).normalize();\n\t\tlook.crossVectors(right, axis).normalize();\n\t\tmesh.matrix.set(right.x, axis.x, look.x, meshPosition.x, right.y, axis.y, look.y, meshPosition.y, right.z, axis.z, look.z, meshPosition.z, 0, 0, 0, 1);\n\t\tmesh.matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);\n\t}\n\n\treturn function () {\n\n\t\tif (this.constrained) {\n\n\t\t\trotateAxialConstrainedMesh(this, this.point, this.axis);\n\t\t} else {\n\n\t\t\trotateMesh(this, this.point, this.axis);\n\t\t}\n\t};\n}();\n\n//# sourceURL=webpack:///./src/extra/BillboardMesh.js?")
        },
        "./src/extra/BufferGeometryUtils.js": /*!******************************************!*\
  !*** ./src/extra/BufferGeometryUtils.js ***!
  \******************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * changed by zhgu\r\n */\n\nTHREE.BufferGeometryUtils1 = {\n\n            computeTangents: function computeTangents(geometry) {\n\n                        var index = geometry.index;\n                        var attributes = geometry.attributes;\n\n                        // based on http://www.terathon.com/code/tangent.html\n                        // (per vertex tangents)\n\n                        if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {\n\n                                    console.warn('THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()');\n                                    return;\n                        }\n\n                        var indices = index.array;\n                        var positions = attributes.position.array;\n                        var normals = attributes.normal.array;\n                        var uvs = attributes.uv.array;\n\n                        var nVertices = positions.length / 3;\n\n                        if (attributes.tangent === undefined) {\n\n                                    geometry.addAttribute('tangent', new THREE.BufferAttribute(new Float32Array(4 * nVertices), 4));\n                        }\n\n                        var tangents = attributes.tangent.array;\n\n                        var tan1 = [],\n                            tan2 = [];\n\n                        for (var i = 0; i < nVertices; i++) {\n\n                                    tan1[i] = new THREE.Vector3();\n                                    tan2[i] = new THREE.Vector3();\n                        }\n\n                        var vA = new THREE.Vector3(),\n                            vB = new THREE.Vector3(),\n                            vC = new THREE.Vector3(),\n                            uvA = new THREE.Vector2(),\n                            uvB = new THREE.Vector2(),\n                            uvC = new THREE.Vector2(),\n                            sdir = new THREE.Vector3(),\n                            tdir = new THREE.Vector3();\n\n                        function handleTriangle(a, b, c) {\n\n                                    vA.fromArray(positions, a * 3);\n                                    vB.fromArray(positions, b * 3);\n                                    vC.fromArray(positions, c * 3);\n\n                                    uvA.fromArray(uvs, a * 2);\n                                    uvB.fromArray(uvs, b * 2);\n                                    uvC.fromArray(uvs, c * 2);\n\n                                    var x1 = vB.x - vA.x;\n                                    var x2 = vC.x - vA.x;\n\n                                    var y1 = vB.y - vA.y;\n                                    var y2 = vC.y - vA.y;\n\n                                    var z1 = vB.z - vA.z;\n                                    var z2 = vC.z - vA.z;\n\n                                    var s1 = uvB.x - uvA.x;\n                                    var s2 = uvC.x - uvA.x;\n\n                                    var t1 = uvB.y - uvA.y;\n                                    var t2 = uvC.y - uvA.y;\n\n                                    var r = 1.0 / (s1 * t2 - s2 * t1);\n\n                                    sdir.set((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);\n\n                                    tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);\n\n                                    tan1[a].add(sdir);\n                                    tan1[b].add(sdir);\n                                    tan1[c].add(sdir);\n\n                                    tan2[a].add(tdir);\n                                    tan2[b].add(tdir);\n                                    tan2[c].add(tdir);\n                        }\n\n                        var groups = geometry.groups;\n\n                        if (groups.length === 0) {\n\n                                    groups = [{\n                                                start: 0,\n                                                count: indices.length\n                                    }];\n                        }\n\n                        for (var i = 0, il = groups.length; i < il; ++i) {\n\n                                    var group = groups[i];\n\n                                    var start = group.start;\n                                    var count = group.count;\n\n                                    for (var j = start, jl = start + count; j < jl; j += 3) {\n\n                                                handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);\n                                    }\n                        }\n\n                        var tmp = new THREE.Vector3(),\n                            tmp2 = new THREE.Vector3();\n                        var n = new THREE.Vector3(),\n                            n2 = new THREE.Vector3();\n                        var w, t, test;\n\n                        function handleVertex(v) {\n\n                                    n.fromArray(normals, v * 3);\n                                    n2.copy(n);\n\n                                    t = tan1[v];\n\n                                    // Gram-Schmidt orthogonalize\n\n                                    tmp.copy(t);\n                                    tmp.sub(n.multiplyScalar(n.dot(t))).normalize();\n\n                                    // Calculate handedness\n\n                                    tmp2.crossVectors(n2, t);\n                                    test = tmp2.dot(tan2[v]);\n                                    w = test < 0.0 ? -1.0 : 1.0;\n\n                                    tangents[v * 4] = tmp.x;\n                                    tangents[v * 4 + 1] = tmp.y;\n                                    tangents[v * 4 + 2] = tmp.z;\n                                    tangents[v * 4 + 3] = w;\n                        }\n\n                        for (var i = 0, il = groups.length; i < il; ++i) {\n\n                                    var group = groups[i];\n\n                                    var start = group.start;\n                                    var count = group.count;\n\n                                    for (var j = start, jl = start + count; j < jl; j += 3) {\n\n                                                handleVertex(indices[j + 0]);\n                                                handleVertex(indices[j + 1]);\n                                                handleVertex(indices[j + 2]);\n                                    }\n                        }\n            },\n\n            /**\r\n             * @param  {Array<THREE.BufferGeometry>} geometries\r\n             * @param  {Boolean} useGroups\r\n             * maxCount 最大顶点数量默认 50000 added by zhgu\r\n             * @return {THREE.BufferGeometry}\r\n             */\n            mergeBufferGeometries1: function mergeBufferGeometries1(geometries, maxCount, useGroups) {\n                        maxCount = maxCount || 50000;\n                        // maxCount *= 3;\n                        var curCount = 0;\n                        var index = 0;\n                        var resultGeo = [[]];\n                        for (var i = 0; i < geometries.length; i++) {\n                                    var geometry = geometries[i];\n                                    if (geometry.attributes.position) {\n                                                var positionCount = geometry.attributes.position.count;\n                                                curCount += positionCount;\n                                                if (curCount < maxCount) {\n                                                            if (!(resultGeo[index] instanceof Array)) {\n                                                                        resultGeo[index] = [];\n                                                            }\n                                                            resultGeo[index].push(geometry);\n                                                } else {\n                                                            curCount = 0;\n                                                            if (!(resultGeo[index] instanceof Array)) {\n                                                                        resultGeo[index] = [];\n                                                            }\n                                                            resultGeo[index].push(geometry);\n                                                            index++;\n                                                }\n                                    } else {\n                                                console.warn('该geometry' + geometry.id + '无position，请检查是否存在问题');\n                                    }\n                        }\n                        var mergedResult = [];\n                        for (var k = 0; k < resultGeo.length; k++) {\n                                    var mergedGeometry = this.mergeBufferGeometries(resultGeo[k], useGroups);\n                                    //继续合并groups\n                                    if (useGroups) {\n                                                this.mergeGroups(mergedGeometry);\n                                    }\n                                    mergedResult.push(mergedGeometry);\n                        }\n                        return mergedResult;\n            },\n            /**\r\n             * @param  {Array<THREE.BufferGeometry>} geometries\r\n             * @param  {Boolean} useGroups\r\n             * maxCount 最大顶点数量默认 50000 added by zhgu\r\n             * @return {THREE.BufferGeometry}\r\n             */\n            mergeBufferGeometries: function mergeBufferGeometries(geometries, useGroups) {\n\n                        var isIndexed = geometries[0].index !== null;\n\n                        var attributesUsed = new Set(Object.keys(geometries[0].attributes));\n                        var morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n\n                        var attributes = {};\n                        var morphAttributes = {};\n\n                        var mergedGeometry = new THREE.BufferGeometry();\n\n                        var offset = 0;\n\n                        for (var i = 0; i < geometries.length; ++i) {\n\n                                    var geometry = geometries[i];\n\n                                    // ensure that all geometries are indexed, or none\n\n                                    if (isIndexed !== (geometry.index !== null)) return null;\n\n                                    // gather attributes, exit early if they're different\n\n                                    for (var name in geometry.attributes) {\n\n                                                if (!attributesUsed.has(name)) return null;\n\n                                                if (attributes[name] === undefined) attributes[name] = [];\n\n                                                attributes[name].push(geometry.attributes[name]);\n                                    }\n\n                                    // gather morph attributes, exit early if they're different\n\n                                    for (var name in geometry.morphAttributes) {\n\n                                                if (!morphAttributesUsed.has(name)) return null;\n\n                                                if (morphAttributes[name] === undefined) morphAttributes[name] = [];\n\n                                                morphAttributes[name].push(geometry.morphAttributes[name]);\n                                    }\n\n                                    // gather .userData\n\n                                    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n                                    mergedGeometry.userData.mergedUserData.push(geometry.userData);\n\n                                    if (useGroups) {\n\n                                                var count;\n\n                                                if (isIndexed) {\n\n                                                            count = geometry.index.count;\n                                                } else if (geometry.attributes.position !== undefined) {\n\n                                                            count = geometry.attributes.position.count;\n                                                } else {\n\n                                                            return null;\n                                                }\n\n                                                // mergedGeometry.addGroup( offset, count, i );\n                                                //changed by zhgu\n                                                if (geometry.groups) {\n                                                            for (var _i in geometry.groups) {\n                                                                        var start = geometry.groups[_i].start;\n                                                                        var nums = geometry.groups[_i].count;\n                                                                        var materialIndex = geometry.groups[_i].materialIndex;\n                                                                        mergedGeometry.addGroup(offset + start, nums, materialIndex);\n                                                            }\n                                                }\n                                                offset += count;\n                                    }\n\n                                    //needMerge\n                                    if (geometry._needMerge) {\n                                                for (var key in geometry._needMerge) {\n                                                            if (!mergedGeometry._needMerge) {\n                                                                        mergedGeometry._needMerge = {};\n                                                            }\n                                                            if (!mergedGeometry._needMerge[key]) {\n                                                                        mergedGeometry._needMerge[key] = [];\n                                                            }\n                                                            mergedGeometry._needMerge[key].push(geometry._needMerge[key]);\n                                                }\n                                    }\n                        }\n\n                        // merge indices\n\n                        if (isIndexed) {\n\n                                    var indexOffset = 0;\n                                    var mergedIndex = [];\n\n                                    for (var i = 0; i < geometries.length; ++i) {\n\n                                                var index = geometries[i].index;\n\n                                                for (var j = 0; j < index.count; ++j) {\n\n                                                            mergedIndex.push(index.getX(j) + indexOffset);\n                                                }\n\n                                                indexOffset += geometries[i].attributes.position.count;\n                                    }\n\n                                    mergedGeometry.setIndex(mergedIndex);\n                        }\n\n                        // merge attributes\n\n                        for (var name in attributes) {\n\n                                    var mergedAttribute = this.mergeBufferAttributes(attributes[name]);\n\n                                    if (!mergedAttribute) return null;\n\n                                    mergedGeometry.addAttribute(name, mergedAttribute);\n                        }\n\n                        // merge morph attributes\n\n                        for (var name in morphAttributes) {\n\n                                    var numMorphTargets = morphAttributes[name][0].length;\n\n                                    if (numMorphTargets === 0) break;\n\n                                    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n                                    mergedGeometry.morphAttributes[name] = [];\n\n                                    for (var i = 0; i < numMorphTargets; ++i) {\n\n                                                var morphAttributesToMerge = [];\n\n                                                for (var j = 0; j < morphAttributes[name].length; ++j) {\n\n                                                            morphAttributesToMerge.push(morphAttributes[name][j][i]);\n                                                }\n\n                                                var mergedMorphAttribute = this.mergeBufferAttributes(morphAttributesToMerge);\n\n                                                if (!mergedMorphAttribute) return null;\n\n                                                mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n                                    }\n                        }\n\n                        return mergedGeometry;\n            },\n\n            /**\r\n             *@author zhuguang <zhuguang@uinnova.com>\r\n             *@descripition 为了极限增加性能，需要对geometry的groups进行二次merge\r\n             *@type {String}\r\n             */\n            mergeGroups: function mergeGroups(geometry) {\n                        var groups = geometry.groups;\n                        var indexArr = {};\n                        //目前只考虑attribute的合并\n                        //收集index\n                        for (var i = 0, len = groups.length; i < len; i++) {\n                                    var group = groups[i];\n                                    var materialIndex = group.materialIndex;\n                                    if (!indexArr[materialIndex]) {\n                                                indexArr[materialIndex] = [];\n                                    }\n                                    indexArr[materialIndex].push(group);\n                        }\n                        var index = geometry.index;\n                        if (index) {\n                                    geometry.setIndex(new THREE.BufferAttribute(this._recombinationArr(geometry, 'index', indexArr, true), 1));\n                        } else {\n                                    //遍历attribute\n                                    for (var name in geometry.attributes) {\n                                                //var attr = geometry.attributes(name);\n                                                if (name.indexOf('position') !== -1) {\n                                                            geometry.addAttribute('position', new THREE.BufferAttribute(this._recombinationArr(geometry, name, indexArr, true), 3));\n                                                } else if (name.indexOf('uv') !== -1) {\n                                                            geometry.addAttribute(name, new THREE.BufferAttribute(this._recombinationArr(geometry, name, indexArr), 2));\n                                                } else if (name.indexOf('normal') !== -1) {\n                                                            geometry.addAttribute(name, new THREE.BufferAttribute(this._recombinationArr(geometry, name, indexArr), 3));\n                                                } else if (name.indexOf('id') !== -1 || name.indexOf('vis') !== -1) {\n                                                            geometry.addAttribute(name, new THREE.BufferAttribute(this._recombinationArr(geometry, name, indexArr), 1));\n                                                }\n                                    }\n                        }\n            },\n            _recombinationArr: function _recombinationArr(geometry, name, indexArr, updateGroups) {\n                        var attribute;\n                        var isIndex = false;\n                        var res;\n                        if (name === 'index') {\n                                    attribute = geometry.index;\n                        } else {\n                                    attribute = geometry.attributes[name];\n                        }\n                        var arr = attribute.array;\n                        // if(isIndex){\n                        //     res = new Uint16Array(arr.length);\n                        // }else{\n                        //     res = new Float32Array(arr.length);\n                        // }\n                        res = this._getArrayType(arr);\n\n                        var IndexMap = {};\n                        var resIndex = 0;\n                        // arr = arr.join(',');\n                        var interval = attribute.itemSize;\n                        for (var k in indexArr) {\n                                    IndexMap[k] = { start: resIndex / interval };\n                                    var index = indexArr[k];\n                                    var end = 0;\n                                    for (var i = 0, len = index.length; i < len; i++) {\n                                                var group = index[i];\n                                                var start = group.start * interval;\n                                                var size = group.count * interval;\n                                                this._getNewArrayFromArr(res, resIndex, arr, start, size);\n                                                resIndex += size;\n                                                end += size;\n                                    }\n                                    IndexMap[k].count = end / interval;\n                        }\n                        //处理groups,先清空\n                        if (updateGroups) {\n                                    geometry.groups = [];\n                                    for (var nums in IndexMap) {\n                                                var indexMap0 = IndexMap[nums];\n                                                geometry.addGroup(indexMap0.start, indexMap0.count, parseInt(nums));\n                                    }\n                        }\n\n                        return res;\n                        //\n                        // for(var t in res){\n                        //     final = final.concat(res[t]);\n                        // }\n                        //\n                        // return final;\n            },\n\n            _getArrayType: function _getArrayType(arr) {\n                        var result = arr.map(function (v) {\n                                    return 0;\n                        });\n                        return result;\n            },\n\n            _getNewArrayFromArr: function _getNewArrayFromArr(res, resIndex, arr, start, count) {\n                        for (var i = start; i < start + count; i++) {\n                                    res[resIndex] = arr[i];\n                                    resIndex++;\n                        }\n            },\n\n            /**\r\n             * @param {Array<THREE.BufferAttribute>} attributes\r\n             * @return {THREE.BufferAttribute}\r\n             */\n            mergeBufferAttributes: function mergeBufferAttributes(attributes) {\n\n                        var TypedArray;\n                        var itemSize;\n                        var normalized;\n                        var arrayLength = 0;\n\n                        for (var i = 0; i < attributes.length; ++i) {\n\n                                    var attribute = attributes[i];\n\n                                    if (attribute.isInterleavedBufferAttribute) return null;\n\n                                    if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n                                    if (TypedArray !== attribute.array.constructor) return null;\n\n                                    if (itemSize === undefined) itemSize = attribute.itemSize;\n                                    if (itemSize !== attribute.itemSize) return null;\n\n                                    if (normalized === undefined) normalized = attribute.normalized;\n                                    if (normalized !== attribute.normalized) return null;\n\n                                    arrayLength += attribute.array.length;\n                        }\n\n                        var array = new TypedArray(arrayLength);\n                        var offset = 0;\n\n                        for (var i = 0; i < attributes.length; ++i) {\n\n                                    array.set(attributes[i].array, offset);\n\n                                    offset += attributes[i].array.length;\n                        }\n\n                        return new THREE.BufferAttribute(array, itemSize, normalized);\n            }\n\n};\n\n//# sourceURL=webpack:///./src/extra/BufferGeometryUtils.js?")
        },
        "./src/extra/BuildingMaterial.js": /*!***************************************!*\
  !*** ./src/extra/BuildingMaterial.js ***!
  \***************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\n(function () {\n\n            'use strict';\n\n            var root = this;\n\n            if (!THREE) throw new Error('BuildingMaterial requires three.min.js');\n\n            function BuildingMaterial(parameters) {\n\n                        var vertexShaderSource = ['uniform vec3 color;', 'uniform float opacity;', 'uniform float near;', 'uniform float far;', 'varying vec2 vUV;', 'varying vec4 vColor;', 'varying float lightWeight;', 'varying float lightWeight2;', 'float getV3Size( vec3 v3 ) {', '    return sqrt(v3.x*v3.x + v3.y*v3.y + v3.z*v3.z);', '}', 'float getLightWeight( vec3 light ) {',\n                        // '    return (light.x*normal.x + light.y*normal.y + light.z*normal.z)/(getV3Size(light)*getV3Size(normal));',\n                        '    vec3 normalFix = normalize(vec3(normal));', '    vec3 lightFix = normalize(vec3(light));', '    return max(dot(light, normalFix), 0.0);', '}', 'void main() {', '    vColor = vec4( color, opacity );', '    vUV = uv;',\n                        // '    vec3 lig = vec3(0.3415, 0.2415, 0.5867);',\n\n                        //不知为何GeoBuilding的法线被旋转了90度，[0,0,1]表示上！\n                        '    vec3 lig = vec3(0.3, 0.6, 1);', '    vec3 lig2 = lig * (-1.0);', '    lightWeight = getLightWeight(lig);', '    lightWeight2 = getLightWeight(lig2);', '',\n                        // '    mat4 m = projectionMatrix * modelViewMatrix;',\n                        '    vec4 finalPosition = projectionMatrix * ( modelViewMatrix * vec4( position, 1.0 ));', '    gl_Position = finalPosition;', '}'];\n\n                        var fragmentShaderSource = ['', 'uniform sampler2D map;', 'uniform sampler2D alphaMap;', 'uniform float useMap;', 'uniform float useAlphaMap;', 'uniform vec2 dashArray;', 'uniform float visibility;', 'uniform float alphaTest;', 'uniform vec2 repeat;', 'uniform vec2 offset;', 'varying vec2 vUV;', 'varying vec4 vColor;', 'varying float vCounters;', 'varying float lightWeight;', 'varying float lightWeight2;', 'void main() {', '    vec4 c = vColor;', '    if( useMap == 1. ) c *= texture2D( map, vUV * repeat + offset);', '    if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUV * repeat ).a;', '\t if( c.a < alphaTest ) discard;', '\t vec3 oldColor = vec3(c.r, c.g, c.b);', '    vec3 dirLight = vec3(oldColor);', '    dirLight = vec3 (dirLight.r * lightWeight, dirLight.g * lightWeight, dirLight.b * lightWeight);', '    vec3 dirLight2 = vec3(oldColor);', '    dirLight2 = vec3 (dirLight2.r * lightWeight2, dirLight2.g * lightWeight2, dirLight2.b * lightWeight2);', '    float envLightIntensity = 1.0;', '\t vec3 envLightColor = vec3(1, 1, 1);', '    vec3 envLight = envLightColor * envLightIntensity;', '    envLight = vec3(envLight.r * oldColor.r, envLight.g * oldColor.g, envLight.b * oldColor.b);',\n\n                        // '    vec3 finalColor = vec3(dirLight.r*0.8 + dirLight2.r*0.2, dirLight.g*0.8 + dirLight2.g*0.2, dirLight.b*0.8 + dirLight2.b*0.2);',\n                        '    vec3 finalColor = dirLight + dirLight2*0.3;', '    c = vec4( finalColor, c.a );', '    gl_FragColor = c;', '}'];\n\n                        function check(v, d) {\n                                    if (v === undefined) return d;\n                                    return v;\n                        }\n\n                        THREE.Material.call(this);\n\n                        parameters = parameters || {};\n\n                        this.growPer = check(parameters.growPer, 1.0);\n                        this.lineWidth = check(parameters.lineWidth, 1);\n                        this.map = check(parameters.map, null);\n                        this.useMap = check(parameters.useMap, 0);\n                        this.alphaMap = check(parameters.alphaMap, null);\n                        this.useAlphaMap = check(parameters.useAlphaMap, 0);\n                        this.color = check(parameters.color, new THREE.Color(0xffffff));\n                        this.opacity = check(parameters.opacity, 1);\n                        this.resolution = check(parameters.resolution, new THREE.Vector2(1, 1));\n                        this.sizeAttenuation = check(parameters.sizeAttenuation, 1);\n                        this.near = check(parameters.near, 1);\n                        this.far = check(parameters.far, 1);\n                        this.dashArray = check(parameters.dashArray, []);\n                        this.useDash = this.dashArray !== [] ? 1 : 0;\n                        this.visibility = check(parameters.visibility, 1);\n                        this.alphaTest = check(parameters.alphaTest, 0);\n                        this.repeat = check(parameters.repeat, new THREE.Vector2(1, 1));\n                        this.offset = check(parameters.offset, new THREE.Vector2(0, 0));\n\n                        var material = new THREE.ShaderMaterial({\n                                    uniforms: {\n\n                                                color: { type: 'c', value: this.color },\n                                                opacity: { type: 'f', value: this.opacity },\n\n                                                near: { type: 'f', value: this.near },\n                                                far: { type: 'f', value: this.far }\n\n                                    },\n                                    vertexShader: vertexShaderSource.join('\\r\\n'),\n                                    fragmentShader: fragmentShaderSource.join('\\r\\n')\n                        });\n\n                        // material.depthTest = false;\n                        material.transparent = true;\n                        // material.side = THREE.BackSide;\n\n\n                        material.type = 'BuildingMaterial';\n\n                        // material.setValues( parameters );\n\n                        return material;\n            }\n\n            BuildingMaterial.prototype = Object.create(THREE.Material.prototype);\n            BuildingMaterial.prototype.constructor = BuildingMaterial;\n\n            BuildingMaterial.prototype.copy = function (source) {\n\n                        THREE.Material.prototype.copy.call(this, source);\n\n                        this.growPer = source.growPer;\n                        this.lineWidth = source.lineWidth;\n                        this.map = source.map;\n                        this.useMap = source.useMap;\n                        this.alphaMap = source.alphaMap;\n                        this.useAlphaMap = source.useAlphaMap;\n                        this.color.copy(source.color);\n                        this.opacity = source.opacity;\n                        this.resolution.copy(source.resolution);\n                        this.sizeAttenuation = source.sizeAttenuation;\n                        this.near = source.near;\n                        this.far = source.far;\n                        this.dashArray.copy(source.dashArray);\n                        this.useDash = source.useDash;\n                        this.visibility = source.visibility;\n                        this.alphaTest = source.alphaTest;\n                        this.repeat.copy(source.repeat);\n\n                        return this;\n            };\n\n            if (true) {\n                        if ( true && module.exports) {\n                                    exports = module.exports = { BuildingMaterial: BuildingMaterial };\n                        }\n                        exports.BuildingMaterial = BuildingMaterial;\n            } else {}\n}).call(undefined);\n\n//# sourceURL=webpack:///./src/extra/BuildingMaterial.js?")
        },
        "./src/extra/FaceIDMeshLine.js": /*!*************************************!*\
  !*** ./src/extra/FaceIDMeshLine.js ***!
  \*************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\n//changed by zhgu,这个meshLine的实现太不完美了，以后有时间一定要重写\n//feat:增加贴图移动接口，当然还是不太完美\n(function () {\n\n    'use strict';\n\n    var root = this;\n\n    //var has_require = typeof require !== 'undefined'\n\n    //var THREE = root.THREE || has_require && require('three')\n    if (!THREE) throw new Error('MeshLine requires three.min.js');\n\n    function MeshLine() {\n\n        this.positions = [];\n\n        this.previous = [];\n        this.next = [];\n        this.side = [];\n        this.width = [];\n        this.indices_array = [];\n        this.uvs = [];\n        this.counters = [];\n        this.geometry = new THREE.BufferGeometry();\n\n        this.widthCallback = null;\n    }\n\n    MeshLine.prototype.setGeometry = function (g, c) {\n\n        this.widthCallback = c;\n\n        this.positions = [];\n        this.counters = [];\n\n        this.textureCoord = g.textureCoord;\n\n        if (g instanceof THREE.Geometry) {\n            for (var j = 0; j < g.vertices.length; j++) {\n                var v = g.vertices[j];\n                var c = j / g.vertices.length;\n                this.positions.push(v.x, v.y, v.z);\n                this.positions.push(v.x, v.y, v.z);\n                this.counters.push(c);\n                this.counters.push(c);\n            }\n        }\n\n        if (g instanceof THREE.BufferGeometry) {\n            // read attribute positions ?\n        }\n\n        if (g instanceof Float32Array || g instanceof Array) {\n            for (var j = 0; j < g.length; j += 3) {\n                var c = j / g.length;\n                this.positions.push(g[j], g[j + 1], g[j + 2]);\n                this.positions.push(g[j], g[j + 1], g[j + 2]);\n                this.counters.push(c);\n                this.counters.push(c);\n            }\n        }\n\n        this.process();\n    };\n\n    MeshLine.prototype.compareV3 = function (a, b) {\n\n        var aa = a * 6;\n        var ab = b * 6;\n        return this.positions[aa] === this.positions[ab] && this.positions[aa + 1] === this.positions[ab + 1] && this.positions[aa + 2] === this.positions[ab + 2];\n    };\n\n    MeshLine.prototype.copyV3 = function (a) {\n\n        var aa = a * 6;\n        return [this.positions[aa], this.positions[aa + 1], this.positions[aa + 2]];\n    };\n\n    MeshLine.prototype.process = function () {\n\n        var l = this.positions.length / 6;\n\n        this.previous = [];\n        this.next = [];\n        this.side = [];\n        this.width = [];\n        this.indices_array = [];\n        this.uvs = [];\n\n        for (var j = 0; j < l; j++) {\n            this.side.push(1);\n            this.side.push(-1);\n        }\n\n        var w;\n        for (var j = 0; j < l; j++) {\n            if (this.widthCallback) w = this.widthCallback(j / (l - 1));else w = 1;\n            this.width.push(w);\n            this.width.push(w);\n        }\n\n        for (var j = 0; j < l; j++) {\n            if (this.textureCoord) {\n                var tc = this.textureCoord[j];\n                this.uvs.push(tc.x, 0);\n                this.uvs.push(tc.x, 1);\n            } else {\n                this.uvs.push(j / (l - 1), 0);\n                this.uvs.push(j / (l - 1), 1);\n            }\n        }\n\n        var v;\n\n        if (this.compareV3(0, l - 1)) {\n            v = this.copyV3(l - 2);\n        } else {\n            v = this.copyV3(0);\n        }\n        this.previous.push(v[0], v[1], v[2]);\n        this.previous.push(v[0], v[1], v[2]);\n        for (var j = 0; j < l - 1; j++) {\n            v = this.copyV3(j);\n            this.previous.push(v[0], v[1], v[2]);\n            this.previous.push(v[0], v[1], v[2]);\n        }\n\n        for (var j = 1; j < l; j++) {\n            v = this.copyV3(j);\n            this.next.push(v[0], v[1], v[2]);\n            this.next.push(v[0], v[1], v[2]);\n        }\n\n        if (this.compareV3(l - 1, 0)) {\n            v = this.copyV3(1);\n        } else {\n            v = this.copyV3(l - 1);\n        }\n        this.next.push(v[0], v[1], v[2]);\n        this.next.push(v[0], v[1], v[2]);\n\n        for (var j = 0; j < l - 1; j++) {\n            var n = j * 2;\n            this.indices_array.push(n, n + 1, n + 2);\n            this.indices_array.push(n + 2, n + 1, n + 3);\n        }\n\n        if (!this.attributes) {\n            this.attributes = {\n                position: new THREE.BufferAttribute(new Float32Array(this.positions), 3),\n                previous: new THREE.BufferAttribute(new Float32Array(this.previous), 3),\n                next: new THREE.BufferAttribute(new Float32Array(this.next), 3),\n                side: new THREE.BufferAttribute(new Float32Array(this.side), 1),\n                width: new THREE.BufferAttribute(new Float32Array(this.width), 1),\n                uv: new THREE.BufferAttribute(new Float32Array(this.uvs), 2),\n                index: new THREE.BufferAttribute(new Uint16Array(this.indices_array), 1),\n                counters: new THREE.BufferAttribute(new Float32Array(this.counters), 1)\n            };\n        } else {\n            this.attributes.position.copyArray(new Float32Array(this.positions));\n            this.attributes.position.needsUpdate = true;\n            this.attributes.previous.copyArray(new Float32Array(this.previous));\n            this.attributes.previous.needsUpdate = true;\n            this.attributes.next.copyArray(new Float32Array(this.next));\n            this.attributes.next.needsUpdate = true;\n            this.attributes.side.copyArray(new Float32Array(this.side));\n            this.attributes.side.needsUpdate = true;\n            this.attributes.width.copyArray(new Float32Array(this.width));\n            this.attributes.width.needsUpdate = true;\n            this.attributes.uv.copyArray(new Float32Array(this.uvs));\n            this.attributes.uv.needsUpdate = true;\n            this.attributes.index.copyArray(new Uint16Array(this.indices_array));\n            this.attributes.index.needsUpdate = true;\n        }\n\n        this.geometry.addAttribute('position', this.attributes.position);\n        this.geometry.addAttribute('previous', this.attributes.previous);\n        this.geometry.addAttribute('next', this.attributes.next);\n        this.geometry.addAttribute('side', this.attributes.side);\n        this.geometry.addAttribute('width', this.attributes.width);\n        this.geometry.addAttribute('uv', this.attributes.uv);\n        this.geometry.addAttribute('counters', this.attributes.counters);\n\n        this.geometry.setIndex(this.attributes.index);\n    };\n\n    function memcpy(src, srcOffset, dst, dstOffset, length) {\n        var i;\n\n        src = src.subarray || src.slice ? src : src.buffer;\n        dst = dst.subarray || dst.slice ? dst : dst.buffer;\n\n        src = srcOffset ? src.subarray ? src.subarray(srcOffset, length && srcOffset + length) : src.slice(srcOffset, length && srcOffset + length) : src;\n\n        if (dst.set) {\n            dst.set(src, dstOffset);\n        } else {\n            for (i = 0; i < src.length; i++) {\n                dst[i + dstOffset] = src[i];\n            }\n        }\n\n        return dst;\n    }\n\n    /**\r\n     * Fast method to advance the line by one position.  The oldest position is removed.\r\n     * @param position\r\n     */\n    MeshLine.prototype.advance = function (position) {\n\n        var positions = this.attributes.position.array;\n        var previous = this.attributes.previous.array;\n        var next = this.attributes.next.array;\n        var l = positions.length;\n\n        // PREVIOUS\n        memcpy(positions, 0, previous, 0, l);\n\n        // POSITIONS\n        memcpy(positions, 6, positions, 0, l - 6);\n\n        positions[l - 6] = position.x;\n        positions[l - 5] = position.y;\n        positions[l - 4] = position.z;\n        positions[l - 3] = position.x;\n        positions[l - 2] = position.y;\n        positions[l - 1] = position.z;\n\n        // NEXT\n        memcpy(positions, 6, next, 0, l - 6);\n\n        next[l - 6] = position.x;\n        next[l - 5] = position.y;\n        next[l - 4] = position.z;\n        next[l - 3] = position.x;\n        next[l - 2] = position.y;\n        next[l - 1] = position.z;\n\n        this.attributes.position.needsUpdate = true;\n        this.attributes.previous.needsUpdate = true;\n        this.attributes.next.needsUpdate = true;\n    };\n\n    function FaceIDMeshLineMaterial(parameters) {\n\n        var vertexShaderSource = ['precision highp float;', '', 'attribute vec3 position;', 'attribute vec3 previous;', 'attribute vec3 next;', 'attribute float side;', 'attribute float width;', 'attribute vec2 uv;', 'attribute float counters;', '', 'uniform mat4 projectionMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform vec2 resolution;', 'uniform float lineWidth;', 'uniform float near;', 'uniform float far;', 'uniform float sizeAttenuation;', '', 'varying vec2 vUV;', 'varying vec4 vColor;', 'varying float vCounters;', \"uniform float baseId;\", \"\", \"varying vec4 worldId;\", '', 'vec2 fix( vec4 i, float aspect ) {', '', '    vec2 res = i.xy / i.w;', '    res.x *= aspect;', '\t vCounters = counters;', '    return res;', '', '}', '', 'void main() {', '', '    float aspect = resolution.x / resolution.y;', '\t float pixelWidthRatio = 1. / (resolution.x * projectionMatrix[0][0]);', '', '    vUV = uv;', '', '    mat4 m = projectionMatrix * modelViewMatrix;', '    vec4 finalPosition = m * vec4( position, 1.0 );', '    vec4 prevPos = m * vec4( previous, 1.0 );', '    vec4 nextPos = m * vec4( next, 1.0 );', '', '    vec2 currentP = fix( finalPosition, aspect );', '    vec2 prevP = fix( prevPos, aspect );', '    vec2 nextP = fix( nextPos, aspect );', '', '\t float pixelWidth = finalPosition.w * pixelWidthRatio;', '    float w = 1.8 * pixelWidth * lineWidth * width;', '', '    if( sizeAttenuation == 1. ) {', '        w = 1.8 * lineWidth * width;', '    }', '', '    vec2 dir;', '    if( nextP == currentP ) dir = normalize( currentP - prevP );', '    else if( prevP == currentP ) dir = normalize( nextP - currentP );', '    else {', '        vec2 dir1 = normalize( currentP - prevP );', '        vec2 dir2 = normalize( nextP - currentP );', '        dir = normalize( dir1 + dir2 );', '', '        vec2 perp = vec2( -dir1.y, dir1.x );', '        vec2 miter = vec2( -dir.y, dir.x );', '        //w = clamp( w / dot( miter, perp ), 0., 4. * lineWidth * width );', '        w = w / max(dot( miter, perp ), 0.2);', '', '    }', '', '    //vec2 normal = ( cross( vec3( dir, 0. ), vec3( 0., 0., 1. ) ) ).xy;', '    vec2 normal = vec2( -dir.y, dir.x );', '    normal.x /= aspect;', '    normal *= .5 * w;', '', '    vec4 offset = vec4( normal * side, 0.0, 1.0 );', '    finalPosition.xy += offset.xy;', \"  vec3 a = fract(vec3(1.0/255.0, 1.0/(255.0*255.0), 1.0/(255.0*255.0*255.0)) * baseId);\", \"  a -= a.xxy * vec3(0.0, 1.0/255.0, 1.0/255.0);\", \"  worldId = vec4(a,1);\", '', '    gl_Position = finalPosition;', '', '}'];\n\n        var fragmentShaderSource = ['#extension GL_OES_standard_derivatives : enable', 'precision mediump float;', 'varying float vCounters;', '', 'uniform float growPer;', '', 'varying vec2 vUV;', \"varying vec4 worldId;\", '', 'void main() {', '', '    if( vUV.x > growPer ) discard;', \"  gl_FragColor = worldId;\", '}'];\n\n        function check(v, d) {\n            if (v === undefined) return d;\n            return v;\n        }\n\n        THREE.Material.call(this);\n\n        parameters = parameters || {};\n\n        this.growPer = check(parameters.growPer, 1.0);\n        this.lineWidth = check(parameters.lineWidth, 1);\n        this.map = check(parameters.map, null);\n        this.useMap = check(parameters.useMap, 0);\n        this.alphaMap = check(parameters.alphaMap, null);\n        this.useAlphaMap = check(parameters.useAlphaMap, 0);\n        this.color = check(parameters.color, new THREE.Color(0xffffff));\n        this.opacity = check(parameters.opacity, 1);\n        this.resolution = check(parameters.resolution, new THREE.Vector2(1, 1));\n        this.sizeAttenuation = check(parameters.sizeAttenuation, 1);\n        this.near = check(parameters.near, 1);\n        this.far = check(parameters.far, 1);\n        this.dashArray = check(parameters.dashArray, []);\n        this.useDash = this.dashArray !== [] ? 1 : 0;\n        this.visibility = check(parameters.visibility, 1);\n        this.alphaTest = check(parameters.alphaTest, 0);\n        this.repeat = check(parameters.repeat, new THREE.Vector2(1, 1));\n        this.offset = check(parameters.offset, new THREE.Vector2(0, 0));\n        this.baseId = check(parameters.baseId, 0.0);\n\n        var material = new THREE.RawShaderMaterial({\n            uniforms: {\n                growPer: { type: 'f', value: this.growPer },\n                lineWidth: { type: 'f', value: this.lineWidth },\n                map: { type: 't', value: this.map },\n                useMap: { type: 'f', value: this.useMap },\n                alphaMap: { type: 't', value: this.alphaMap },\n                useAlphaMap: { type: 'f', value: this.useAlphaMap },\n                color: { type: 'c', value: this.color },\n                opacity: { type: 'f', value: this.opacity },\n                resolution: { type: 'v2', value: this.resolution },\n                sizeAttenuation: { type: 'f', value: this.sizeAttenuation },\n                near: { type: 'f', value: this.near },\n                far: { type: 'f', value: this.far },\n                dashArray: { type: 'v2', value: new THREE.Vector2(this.dashArray[0], this.dashArray[1]) },\n                useDash: { type: 'f', value: this.useDash },\n                visibility: { type: 'f', value: this.visibility },\n                alphaTest: { type: 'f', value: this.alphaTest },\n                repeat: { type: 'v2', value: this.repeat },\n                offset: { type: 'v2', value: this.offset },\n                baseId: { type: 'f', value: this.baseId }\n\n            },\n            vertexShader: vertexShaderSource.join('\\r\\n'),\n            fragmentShader: fragmentShaderSource.join('\\r\\n')\n        });\n\n        delete parameters.growPer;\n        delete parameters.lineWidth;\n        delete parameters.map;\n        delete parameters.useMap;\n        delete parameters.alphaMap;\n        delete parameters.useAlphaMap;\n        delete parameters.color;\n        delete parameters.opacity;\n        delete parameters.resolution;\n        delete parameters.sizeAttenuation;\n        delete parameters.near;\n        delete parameters.far;\n        delete parameters.dashArray;\n        delete parameters.visibility;\n        delete parameters.alphaTest;\n        delete parameters.repeat;\n        delete parameters.baseId;\n\n        material.type = 'FaceIDMeshLineMaterial';\n\n        material.setValues(parameters);\n\n        return material;\n    }\n\n    FaceIDMeshLineMaterial.prototype = Object.create(THREE.Material.prototype);\n    FaceIDMeshLineMaterial.prototype.constructor = FaceIDMeshLineMaterial;\n\n    FaceIDMeshLineMaterial.prototype.copy = function (source) {\n\n        THREE.Material.prototype.copy.call(this, source);\n\n        this.growPer = source.growPer;\n        this.baseId = source.baseId;\n        this.lineWidth = source.lineWidth;\n        this.map = source.map;\n        this.useMap = source.useMap;\n        this.alphaMap = source.alphaMap;\n        this.useAlphaMap = source.useAlphaMap;\n        this.color.copy(source.color);\n        this.opacity = source.opacity;\n        this.resolution.copy(source.resolution);\n        this.sizeAttenuation = source.sizeAttenuation;\n        this.near = source.near;\n        this.far = source.far;\n        this.dashArray.copy(source.dashArray);\n        this.useDash = source.useDash;\n        this.visibility = source.visibility;\n        this.alphaTest = source.alphaTest;\n        this.repeat.copy(source.repeat);\n\n        return this;\n    };\n    FaceIDMeshLineMaterial.prototype.setBaseID = function (baseId) {\n        this.uniforms.baseId.value = baseId;\n    };\n    if (true) {\n        if ( true && module.exports) {\n            exports = module.exports = { MeshLine: MeshLine, FaceIDMeshLineMaterial: FaceIDMeshLineMaterial };\n        }\n        exports.MeshLine = MeshLine;\n        exports.FaceIDMeshLineMaterial = FaceIDMeshLineMaterial;\n    } else {}\n}).call(undefined);\n\n//# sourceURL=webpack:///./src/extra/FaceIDMeshLine.js?")
        },
        "./src/extra/ForceEdgeBunding.js": /*!***************************************!*\
  !*** ./src/extra/ForceEdgeBunding.js ***!
  \***************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\r\n FDEB algorithm implementation [www.win.tue.nl/~dholten/papers/forcebundles_eurovis.pdf].\r\n\r\n Author:  (github.com/upphiminn)\r\n 2013\r\n\r\n */\n\nvar ForceEdgeBundling = function ForceEdgeBundling() {\n  var data_nodes = {},\n      // {'nodeid':{'x':,'y':},..}\n  data_edges = [],\n      // [{'source':'nodeid1', 'target':'nodeid2'},..]\n  compatibility_list_for_edge = [],\n      subdivision_points_for_edge = [],\n      K = 0.1,\n      // global bundling constant controling edge stiffness\n  S_initial = 0.1,\n      // init. distance to move points\n  P_initial = 1,\n      // init. subdivision number\n  P_rate = 2,\n      // subdivision rate increase\n  C = 6,\n      // number of cycles to perform\n  I_initial = 70,\n      // init. number of iterations for cycle\n  I_rate = 0.6666667,\n      // rate at which iteration number decreases i.e. 2/3\n  compatibility_threshold = 0.6,\n      invers_quadratic_mode = false,\n      compatbility_threshold = 0,\n      P = 0,\n      eps = 1e-8;\n\n  /*** Geometry Helper Methods ***/\n  function vector_dot_product(p, q) {\n    return p.x * q.x + p.y * q.y;\n  }\n\n  function edge_as_vector(P) {\n    return { 'x': data_nodes[P.target].x - data_nodes[P.source].x,\n      'y': data_nodes[P.target].y - data_nodes[P.source].y };\n  }\n\n  function edge_length(e) {\n    return Math.sqrt(Math.pow(data_nodes[e.source].x - data_nodes[e.target].x, 2) + Math.pow(data_nodes[e.source].y - data_nodes[e.target].y, 2));\n  }\n\n  function custom_edge_length(e) {\n    return Math.sqrt(Math.pow(e.source.x - e.target.x, 2) + Math.pow(e.source.y - e.target.y, 2));\n  }\n\n  function edge_midpoint(e) {\n    var middle_x = (data_nodes[e.source].x + data_nodes[e.target].x) / 2.0;\n    var middle_y = (data_nodes[e.source].y + data_nodes[e.target].y) / 2.0;\n    return { 'x': middle_x, 'y': middle_y };\n  }\n\n  function compute_divided_edge_length(e_idx) {\n    var length = 0;\n    for (var i = 1; i < subdivision_points_for_edge[e_idx].length; i++) {\n      var segment_length = euclidean_distance(subdivision_points_for_edge[e_idx][i], subdivision_points_for_edge[e_idx][i - 1]);\n      length += segment_length;\n    }\n    return length;\n  }\n\n  function euclidean_distance(p, q) {\n    return Math.sqrt(Math.pow(p.x - q.x, 2) + Math.pow(p.y - q.y, 2));\n  }\n\n  function project_point_on_line(p, Q) {\n    var L = Math.sqrt((Q.target.x - Q.source.x) * (Q.target.x - Q.source.x) + (Q.target.y - Q.source.y) * (Q.target.y - Q.source.y));\n    var r = ((Q.source.y - p.y) * (Q.source.y - Q.target.y) - (Q.source.x - p.x) * (Q.target.x - Q.source.x)) / (L * L);\n\n    return { 'x': Q.source.x + r * (Q.target.x - Q.source.x), 'y': Q.source.y + r * (Q.target.y - Q.source.y) };\n  }\n\n  /*** ********************** ***/\n\n  /*** Initialization Methods ***/\n  function initialize_edge_subdivisions() {\n    for (var i = 0; i < data_edges.length; i++) {\n      if (P_initial == 1) subdivision_points_for_edge[i] = []; //0 subdivisions\n      else {\n          subdivision_points_for_edge[i] = [];\n          subdivision_points_for_edge[i].push(data_nodes[data_edges[i].source]);\n          subdivision_points_for_edge[i].push(data_nodes[data_edges[i].target]);\n        }\n    }\n  }\n\n  function initialize_compatibility_lists() {\n    for (var i = 0; i < data_edges.length; i++) {\n      compatibility_list_for_edge[i] = [];\n    } //0 compatible edges.\n  }\n\n  function filter_self_loops(edgelist) {\n    var filtered_edge_list = [];\n    for (var e = 0; e < edgelist.length; e++) {\n      if (data_nodes[edgelist[e].source].x != data_nodes[edgelist[e].target].x && data_nodes[edgelist[e].source].y != data_nodes[edgelist[e].target].y) {\n        //or smaller than eps\n        filtered_edge_list.push(edgelist[e]);\n      }\n    }\n\n    return filtered_edge_list;\n  }\n  /*** ********************** ***/\n\n  /*** Force Calculation Methods ***/\n  function apply_spring_force(e_idx, i, kP) {\n\n    var prev = subdivision_points_for_edge[e_idx][i - 1];\n    var next = subdivision_points_for_edge[e_idx][i + 1];\n    var crnt = subdivision_points_for_edge[e_idx][i];\n\n    var x = prev.x - crnt.x + next.x - crnt.x;\n    var y = prev.y - crnt.y + next.y - crnt.y;\n\n    x *= kP;\n    y *= kP;\n\n    return { 'x': x, 'y': y };\n  }\n\n  function apply_electrostatic_force(e_idx, i, S) {\n    var sum_of_forces = { 'x': 0, 'y': 0 };\n    var compatible_edges_list = compatibility_list_for_edge[e_idx];\n\n    for (var oe = 0; oe < compatible_edges_list.length; oe++) {\n      var force = { 'x': subdivision_points_for_edge[compatible_edges_list[oe]][i].x - subdivision_points_for_edge[e_idx][i].x,\n        'y': subdivision_points_for_edge[compatible_edges_list[oe]][i].y - subdivision_points_for_edge[e_idx][i].y };\n\n      if (Math.abs(force.x) > eps || Math.abs(force.y) > eps) {\n\n        var diff = 1 / Math.pow(custom_edge_length({ 'source': subdivision_points_for_edge[compatible_edges_list[oe]][i],\n          'target': subdivision_points_for_edge[e_idx][i] }), 1);\n\n        sum_of_forces.x += force.x * diff;\n        sum_of_forces.y += force.y * diff;\n      }\n    }\n    return sum_of_forces;\n  }\n\n  function apply_resulting_forces_on_subdivision_points(e_idx, P, S) {\n    var kP = K / (edge_length(data_edges[e_idx]) * (P + 1)); // kP=K/|P|(number of segments), where |P| is the initial length of edge P.\n    // (length * (num of sub division pts - 1))\n    var resulting_forces_for_subdivision_points = [{ 'x': 0, 'y': 0 }];\n    for (var i = 1; i < P + 1; i++) {\n      // exclude initial end points of the edge 0 and P+1\n      var resulting_force = { 'x': 0, 'y': 0 };\n\n      var spring_force = apply_spring_force(e_idx, i, kP);\n      var electrostatic_force = apply_electrostatic_force(e_idx, i, S);\n\n      resulting_force.x = S * (spring_force.x + electrostatic_force.x);\n      resulting_force.y = S * (spring_force.y + electrostatic_force.y);\n\n      resulting_forces_for_subdivision_points.push(resulting_force);\n    }\n    resulting_forces_for_subdivision_points.push({ 'x': 0, 'y': 0 });\n    return resulting_forces_for_subdivision_points;\n  }\n  /*** ********************** ***/\n\n  /*** Edge Division Calculation Methods ***/\n  function update_edge_divisions(P) {\n    for (var e_idx = 0; e_idx < data_edges.length; e_idx++) {\n\n      if (P == 1) {\n        subdivision_points_for_edge[e_idx].push(data_nodes[data_edges[e_idx].source]); // source\n        subdivision_points_for_edge[e_idx].push(edge_midpoint(data_edges[e_idx])); // mid point\n        subdivision_points_for_edge[e_idx].push(data_nodes[data_edges[e_idx].target]); // target\n      } else {\n\n        var divided_edge_length = compute_divided_edge_length(e_idx);\n        var segment_length = divided_edge_length / (P + 1);\n        var current_segment_length = segment_length;\n        var new_subdivision_points = [];\n        new_subdivision_points.push(data_nodes[data_edges[e_idx].source]); //source\n\n        for (var i = 1; i < subdivision_points_for_edge[e_idx].length; i++) {\n          var old_segment_length = euclidean_distance(subdivision_points_for_edge[e_idx][i], subdivision_points_for_edge[e_idx][i - 1]);\n\n          while (old_segment_length > current_segment_length) {\n            var percent_position = current_segment_length / old_segment_length;\n            var new_subdivision_point_x = subdivision_points_for_edge[e_idx][i - 1].x;\n            var new_subdivision_point_y = subdivision_points_for_edge[e_idx][i - 1].y;\n\n            new_subdivision_point_x += percent_position * (subdivision_points_for_edge[e_idx][i].x - subdivision_points_for_edge[e_idx][i - 1].x);\n            new_subdivision_point_y += percent_position * (subdivision_points_for_edge[e_idx][i].y - subdivision_points_for_edge[e_idx][i - 1].y);\n            new_subdivision_points.push({ 'x': new_subdivision_point_x,\n              'y': new_subdivision_point_y });\n\n            old_segment_length -= current_segment_length;\n            current_segment_length = segment_length;\n          }\n          current_segment_length -= old_segment_length;\n        }\n        new_subdivision_points.push(data_nodes[data_edges[e_idx].target]); //target\n        subdivision_points_for_edge[e_idx] = new_subdivision_points;\n      }\n    }\n  }\n  /*** ********************** ***/\n\n  /*** Edge compatibility measures ***/\n  function angle_compatibility(P, Q) {\n    var result = Math.abs(vector_dot_product(edge_as_vector(P), edge_as_vector(Q)) / (edge_length(P) * edge_length(Q)));\n    return result;\n  }\n\n  function scale_compatibility(P, Q) {\n    var lavg = (edge_length(P) + edge_length(Q)) / 2.0;\n    var result = 2.0 / (lavg / Math.min(edge_length(P), edge_length(Q)) + Math.max(edge_length(P), edge_length(Q)) / lavg);\n    return result;\n  }\n\n  function position_compatibility(P, Q) {\n    var lavg = (edge_length(P) + edge_length(Q)) / 2.0;\n    var midP = { 'x': (data_nodes[P.source].x + data_nodes[P.target].x) / 2.0,\n      'y': (data_nodes[P.source].y + data_nodes[P.target].y) / 2.0 };\n    var midQ = { 'x': (data_nodes[Q.source].x + data_nodes[Q.target].x) / 2.0,\n      'y': (data_nodes[Q.source].y + data_nodes[Q.target].y) / 2.0 };\n    var result = lavg / (lavg + euclidean_distance(midP, midQ));\n    return result;\n  }\n\n  function edge_visibility(P, Q) {\n    var I0 = project_point_on_line(data_nodes[Q.source], { 'source': data_nodes[P.source],\n      'target': data_nodes[P.target] });\n    var I1 = project_point_on_line(data_nodes[Q.target], { 'source': data_nodes[P.source],\n      'target': data_nodes[P.target] }); //send acutal edge points positions\n    var midI = { 'x': (I0.x + I1.x) / 2.0,\n      'y': (I0.y + I1.y) / 2.0 };\n    var midP = { 'x': (data_nodes[P.source].x + data_nodes[P.target].x) / 2.0,\n      'y': (data_nodes[P.source].y + data_nodes[P.target].y) / 2.0 };\n    var result = Math.max(0, 1 - 2 * euclidean_distance(midP, midI) / euclidean_distance(I0, I1));\n    return result;\n  }\n\n  function visibility_compatibility(P, Q) {\n    return Math.min(edge_visibility(P, Q), edge_visibility(Q, P));\n  }\n\n  function compatibility_score(P, Q) {\n    var result = angle_compatibility(P, Q) * scale_compatibility(P, Q) * position_compatibility(P, Q) * visibility_compatibility(P, Q);\n\n    return result;\n  }\n\n  function are_compatible(P, Q) {\n    // console.log('compatibility ' + P.source +' - '+ P.target + ' and ' + Q.source +' '+ Q.target);\n    return compatibility_score(P, Q) >= compatibility_threshold;\n  }\n\n  function compute_compatibility_lists() {\n    for (var e = 0; e < data_edges.length - 1; e++) {\n      for (var oe = e + 1; oe < data_edges.length; oe++) {\n        // don't want any duplicates\n        if (e == oe) continue;else {\n          if (are_compatible(data_edges[e], data_edges[oe])) {\n            compatibility_list_for_edge[e].push(oe);\n            compatibility_list_for_edge[oe].push(e);\n          }\n        }\n      }\n    }\n  }\n\n  /*** ************************ ***/\n\n  /*** Main Bundling Loop Methods ***/\n  var forcebundle = function forcebundle() {\n    var S = S_initial;\n    var I = I_initial;\n    var P = P_initial;\n\n    initialize_edge_subdivisions();\n    initialize_compatibility_lists();\n    update_edge_divisions(P);\n    compute_compatibility_lists();\n    for (var cycle = 0; cycle < C; cycle++) {\n      for (var iteration = 0; iteration < I; iteration++) {\n        var forces = [];\n        for (var edge = 0; edge < data_edges.length; edge++) {\n          forces[edge] = apply_resulting_forces_on_subdivision_points(edge, P, S);\n        }\n        for (var e = 0; e < data_edges.length; e++) {\n          for (var i = 0; i < P + 1; i++) {\n            subdivision_points_for_edge[e][i].x += forces[e][i].x;\n            subdivision_points_for_edge[e][i].y += forces[e][i].y;\n          }\n        }\n      }\n      //prepare for next cycle\n      S = S / 2;\n      P = P * 2;\n      I = I_rate * I;\n\n      update_edge_divisions(P);\n      // console.log('C' + cycle);\n      // console.log('P' + P);\n      // console.log('S' + S);\n    }\n    return subdivision_points_for_edge;\n  };\n  /*** ************************ ***/\n\n  /*** Getters/Setters Methods ***/\n  forcebundle.nodes = function (nl) {\n    if (arguments.length == 0) {\n      return data_nodes;\n    } else {\n      data_nodes = nl;\n    }\n    return forcebundle;\n  };\n\n  forcebundle.edges = function (ll) {\n    if (arguments.length == 0) {\n      return data_edges;\n    } else {\n      data_edges = filter_self_loops(ll); //remove edges to from to the same point\n    }\n    return forcebundle;\n  };\n\n  forcebundle.bundling_stiffness = function (k) {\n    if (arguments.length == 0) {\n      return K;\n    } else {\n      K = k;\n    }\n    return forcebundle;\n  };\n\n  forcebundle.step_size = function (step) {\n    if (arguments.length == 0) {\n      return S_initial;\n    } else {\n      S_initial = step;\n    }\n    return forcebundle;\n  };\n\n  forcebundle.cycles = function (c) {\n    if (arguments.length == 0) {\n      return C;\n    } else {\n      C = c;\n    }\n    return forcebundle;\n  };\n\n  forcebundle.iterations = function (i) {\n    if (arguments.length == 0) {\n      return I_initial;\n    } else {\n      I_initial = i;\n    }\n    return forcebundle;\n  };\n\n  forcebundle.iterations_rate = function (i) {\n    if (arguments.length == 0) {\n      return I_rate;\n    } else {\n      I_rate = i;\n    }\n    return forcebundle;\n  };\n\n  forcebundle.subdivision_points_seed = function (p) {\n    if (arguments.length == 0) {\n      return P;\n    } else {\n      P = p;\n    }\n    return forcebundle;\n  };\n\n  forcebundle.subdivision_rate = function (r) {\n    if (arguments.length == 0) {\n      return P_rate;\n    } else {\n      P_rate = r;\n    }\n    return forcebundle;\n  };\n\n  forcebundle.compatbility_threshold = function (t) {\n    if (arguments.length == 0) {\n      return compatbility_threshold;\n    } else {\n      compatibility_threshold = t;\n    }\n    return forcebundle;\n  };\n\n  /*** ************************ ***/\n\n  return forcebundle;\n};\n\nexports.default = ForceEdgeBundling;\n\n//# sourceURL=webpack:///./src/extra/ForceEdgeBunding.js?")
        },
        "./src/extra/GPUParticleSystem.js": /*!****************************************!*\
  !*** ./src/extra/GPUParticleSystem.js ***!
  \****************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\n/*\r\n * GPU Particle System\r\n * @author flimshaw - Charlie Hoey - http://charliehoey.com\r\n *\r\n * A simple to use, general purpose GPU system. Particles are spawn-and-forget with\r\n * several options available, and do not require monitoring or cleanup after spawning.\r\n * Because the paths of all particles are completely deterministic once spawned, the scale\r\n * and direction of time is also variable.\r\n *\r\n * Currently uses a static wrapping perlin noise texture for turbulence, and a small png texture for\r\n * particles, but adding support for a particle texture atlas or changing to a different type of turbulence\r\n * would be a fairly light day's work.\r\n *\r\n * Shader and javascript packing code derrived from several Stack Overflow examples.\r\n *\r\n */\n\nTHREE.GPUParticleSystem = function (options) {\n\n\t\t\tTHREE.Object3D.apply(this, arguments);\n\n\t\t\toptions = options || {};\n\n\t\t\t// parse options and use defaults\n\n\t\t\tthis.PARTICLE_COUNT = options.maxParticles || 1000000;\n\t\t\tthis.PARTICLE_CONTAINERS = options.containerCount || 1;\n\n\t\t\tthis.PARTICLE_NOISE_TEXTURE = options.particleNoiseTex || null;\n\t\t\tthis.PARTICLE_SPRITE_TEXTURE = options.particleSpriteTex || null;\n\n\t\t\tthis.PARTICLES_PER_CONTAINER = Math.ceil(this.PARTICLE_COUNT / this.PARTICLE_CONTAINERS);\n\t\t\tthis.PARTICLE_CURSOR = 0;\n\t\t\tthis.time = 0;\n\t\t\tthis.particleContainers = [];\n\t\t\tthis.rand = [];\n\n\t\t\t// custom vertex and fragement shader\n\n\t\t\tvar GPUParticleShader = {\n\n\t\t\t\t\t\tvertexShader: ['#include <common>', '#include <logdepthbuf_pars_vertex>', 'uniform float uTime;', 'uniform float uScale;', 'uniform sampler2D tNoise;', 'attribute vec3 positionStart;', 'attribute float startTime;', 'attribute vec3 velocity;', 'attribute float turbulence;', 'attribute vec3 color;', 'attribute float size;', 'attribute float lifeTime;', 'varying vec4 vColor;', 'varying float lifeLeft;', 'void main() {',\n\n\t\t\t\t\t\t// unpack things from our attributes'\n\n\t\t\t\t\t\t'\tvColor = vec4( color, 1.0 );',\n\n\t\t\t\t\t\t// convert our velocity back into a value we can use'\n\n\t\t\t\t\t\t'\tvec3 newPosition;', '\tvec3 v;', '\tfloat timeElapsed = uTime - startTime;', '\tlifeLeft = 1.0 - ( timeElapsed / lifeTime );', '\tgl_PointSize = ( uScale * size ) * lifeLeft;', '\tv.x = ( velocity.x - 0.5 ) * 3.0;', '\tv.y = ( velocity.y - 0.5 ) * 3.0;', '\tv.z = ( velocity.z - 0.5 ) * 3.0;', '\tnewPosition = positionStart + ( v * 10.0 ) * timeElapsed;', '\tvec3 noise = texture2D( tNoise, vec2( newPosition.x * 0.015 + ( uTime * 0.05 ), newPosition.y * 0.02 + ( uTime * 0.015 ) ) ).rgb;', '\tvec3 noiseVel = ( noise.rgb - 0.5 ) * 30.0;', '\tnewPosition = mix( newPosition, newPosition + vec3( noiseVel * ( turbulence * 5.0 ) ), ( timeElapsed / lifeTime ) );', '\tif( v.y > 0. && v.y < .05 ) {', '\t\tlifeLeft = 0.0;', '\t}', '\tif( v.x < - 1.45 ) {', '\t\tlifeLeft = 0.0;', '\t}', '\tif( timeElapsed > 0.0 ) {', '\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );', '\t} else {', '\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '\t\tlifeLeft = 0.0;', '\t\tgl_PointSize = 0.;', '\t}', '#include <logdepthbuf_vertex>', '}'].join('\\n'),\n\n\t\t\t\t\t\tfragmentShader: ['#include <logdepthbuf_pars_fragment>', 'float scaleLinear( float value, vec2 valueDomain ) {', '\treturn ( value - valueDomain.x ) / ( valueDomain.y - valueDomain.x );', '}', 'float scaleLinear( float value, vec2 valueDomain, vec2 valueRange ) {', '\treturn mix( valueRange.x, valueRange.y, scaleLinear( value, valueDomain ) );', '}', 'varying vec4 vColor;', 'varying float lifeLeft;', 'uniform sampler2D tSprite;', 'void main() {', '#include <logdepthbuf_fragment>', '\tfloat alpha = 0.;', '\tif( lifeLeft > 0.995 ) {', '\t\talpha = scaleLinear( lifeLeft, vec2( 1.0, 0.995 ), vec2( 0.0, 1.0 ) );', '\t} else {', '\t\talpha = lifeLeft * 0.75;', '\t}', '\tvec4 tex = texture2D( tSprite, gl_PointCoord );', '\tgl_FragColor = vec4( vColor.rgb * tex.a, alpha * tex.a );', '}'].join('\\n')\n\n\t\t\t};\n\n\t\t\t// preload a million random numbers\n\n\t\t\tvar i;\n\n\t\t\tfor (i = 1e2; i > 0; i--) {\n\n\t\t\t\t\t\tthis.rand.push(Math.random() - 0.5);\n\t\t\t}\n\n\t\t\tthis.random = function () {\n\n\t\t\t\t\t\treturn ++i >= this.rand.length ? this.rand[i = 1] : this.rand[i];\n\t\t\t};\n\n\t\t\tvar textureLoader = new THREE.TextureLoader();\n\n\t\t\tvar textureLoader = new THREE.TextureLoader();\n\n\t\t\tvar maxCanvas = document.createElement('canvas');\n\t\t\tvar ctx = maxCanvas.getContext('2d');\n\t\t\tmaxCanvas.width = 100;\n\t\t\tmaxCanvas.height = 100;\n\t\t\t// ctx.fillRect(0,0,1,1);\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(50, 50, 50, 0, 2 * Math.PI);\n\t\t\t// ctx.fillStyle = \"rgba(255,255,255,1)\";\n\t\t\tctx.fill();\n\n\t\t\tvar ct = new THREE.CanvasTexture(maxCanvas);\n\n\t\t\tthis.particleNoiseTex = ct;\n\t\t\t// this.particleNoiseTex = this.PARTICLE_NOISE_TEXTURE || textureLoader.load( 'textures/perlin-512.png' );\n\t\t\tthis.particleNoiseTex.wrapS = this.particleNoiseTex.wrapT = THREE.RepeatWrapping;\n\n\t\t\tthis.particleSpriteTex = ct;\n\t\t\t// this.particleSpriteTex = this.PARTICLE_SPRITE_TEXTURE || textureLoader.load( 'textures/particle2.png' );\n\t\t\tthis.particleSpriteTex.wrapS = this.particleSpriteTex.wrapT = THREE.RepeatWrapping;\n\n\t\t\tthis.particleShaderMat = new THREE.ShaderMaterial({\n\t\t\t\t\t\ttransparent: true,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tdepthTest: true,\n\t\t\t\t\t\tuniforms: {\n\t\t\t\t\t\t\t\t\t'uTime': {\n\t\t\t\t\t\t\t\t\t\t\t\tvalue: 0.0\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t'uScale': {\n\t\t\t\t\t\t\t\t\t\t\t\tvalue: 1.0\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t'tNoise': {\n\t\t\t\t\t\t\t\t\t\t\t\tvalue: this.particleNoiseTex\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t'tSprite': {\n\t\t\t\t\t\t\t\t\t\t\t\tvalue: this.particleSpriteTex\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tblending: THREE.AdditiveBlending,\n\t\t\t\t\t\tvertexShader: GPUParticleShader.vertexShader,\n\t\t\t\t\t\tfragmentShader: GPUParticleShader.fragmentShader\n\t\t\t});\n\n\t\t\tthis.particleShaderMat.polygonOffset = true;\n\t\t\tthis.particleShaderMat.polygonOffsetUnits = -10000;\n\n\t\t\t// define defaults for all values\n\n\t\t\tthis.particleShaderMat.defaultAttributeValues.particlePositionsStartTime = [0, 0, 0, 0];\n\t\t\tthis.particleShaderMat.defaultAttributeValues.particleVelColSizeLife = [0, 0, 0, 0];\n\n\t\t\tthis.init = function () {\n\n\t\t\t\t\t\tfor (var i = 0; i < this.PARTICLE_CONTAINERS; i++) {\n\n\t\t\t\t\t\t\t\t\tvar c = new THREE.GPUParticleContainer(this.PARTICLES_PER_CONTAINER, this);\n\t\t\t\t\t\t\t\t\tthis.particleContainers.push(c);\n\t\t\t\t\t\t\t\t\tthis.add(c);\n\t\t\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.spawnParticle = function (options) {\n\n\t\t\t\t\t\tthis.PARTICLE_CURSOR++;\n\n\t\t\t\t\t\tif (this.PARTICLE_CURSOR >= this.PARTICLE_COUNT) {\n\n\t\t\t\t\t\t\t\t\tthis.PARTICLE_CURSOR = 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar currentContainer = this.particleContainers[Math.floor(this.PARTICLE_CURSOR / this.PARTICLES_PER_CONTAINER)];\n\n\t\t\t\t\t\tcurrentContainer.spawnParticle(options);\n\t\t\t};\n\n\t\t\tthis.update = function (time) {\n\n\t\t\t\t\t\tfor (var i = 0; i < this.PARTICLE_CONTAINERS; i++) {\n\n\t\t\t\t\t\t\t\t\tthis.particleContainers[i].update(time);\n\t\t\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.dispose = function () {\n\n\t\t\t\t\t\tthis.particleShaderMat.dispose();\n\t\t\t\t\t\tthis.particleNoiseTex.dispose();\n\t\t\t\t\t\tthis.particleSpriteTex.dispose();\n\n\t\t\t\t\t\tfor (var i = 0; i < this.PARTICLE_CONTAINERS; i++) {\n\n\t\t\t\t\t\t\t\t\tthis.particleContainers[i].dispose();\n\t\t\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.init();\n};\n\nTHREE.GPUParticleSystem.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.GPUParticleSystem.prototype.constructor = THREE.GPUParticleSystem;\n\n// Subclass for particle containers, allows for very large arrays to be spread out\n\nTHREE.GPUParticleContainer = function (maxParticles, particleSystem) {\n\n\t\t\tTHREE.Object3D.apply(this, arguments);\n\n\t\t\tthis.PARTICLE_COUNT = maxParticles || 100000;\n\t\t\tthis.PARTICLE_CURSOR = 0;\n\t\t\tthis.time = 0;\n\t\t\tthis.offset = 0;\n\t\t\tthis.count = 0;\n\t\t\tthis.DPR = window.devicePixelRatio;\n\t\t\tthis.GPUParticleSystem = particleSystem;\n\t\t\tthis.particleUpdate = false;\n\n\t\t\t// geometry\n\n\t\t\tthis.particleShaderGeo = new THREE.BufferGeometry();\n\n\t\t\tthis.particleShaderGeo.addAttribute('position', new THREE.BufferAttribute(new Float32Array(this.PARTICLE_COUNT * 3), 3).setDynamic(true));\n\t\t\tthis.particleShaderGeo.addAttribute('positionStart', new THREE.BufferAttribute(new Float32Array(this.PARTICLE_COUNT * 3), 3).setDynamic(true));\n\t\t\tthis.particleShaderGeo.addAttribute('startTime', new THREE.BufferAttribute(new Float32Array(this.PARTICLE_COUNT), 1).setDynamic(true));\n\t\t\tthis.particleShaderGeo.addAttribute('velocity', new THREE.BufferAttribute(new Float32Array(this.PARTICLE_COUNT * 3), 3).setDynamic(true));\n\t\t\tthis.particleShaderGeo.addAttribute('turbulence', new THREE.BufferAttribute(new Float32Array(this.PARTICLE_COUNT), 1).setDynamic(true));\n\t\t\tthis.particleShaderGeo.addAttribute('color', new THREE.BufferAttribute(new Float32Array(this.PARTICLE_COUNT * 3), 3).setDynamic(true));\n\t\t\tthis.particleShaderGeo.addAttribute('size', new THREE.BufferAttribute(new Float32Array(this.PARTICLE_COUNT), 1).setDynamic(true));\n\t\t\tthis.particleShaderGeo.addAttribute('lifeTime', new THREE.BufferAttribute(new Float32Array(this.PARTICLE_COUNT), 1).setDynamic(true));\n\n\t\t\t// material\n\n\t\t\tthis.particleShaderMat = this.GPUParticleSystem.particleShaderMat;\n\n\t\t\tvar position = new THREE.Vector3();\n\t\t\tvar velocity = new THREE.Vector3();\n\t\t\tvar color = new THREE.Color();\n\n\t\t\tthis.spawnParticle = function (options) {\n\n\t\t\t\t\t\tvar positionStartAttribute = this.particleShaderGeo.getAttribute('positionStart');\n\t\t\t\t\t\tvar startTimeAttribute = this.particleShaderGeo.getAttribute('startTime');\n\t\t\t\t\t\tvar velocityAttribute = this.particleShaderGeo.getAttribute('velocity');\n\t\t\t\t\t\tvar turbulenceAttribute = this.particleShaderGeo.getAttribute('turbulence');\n\t\t\t\t\t\tvar colorAttribute = this.particleShaderGeo.getAttribute('color');\n\t\t\t\t\t\tvar sizeAttribute = this.particleShaderGeo.getAttribute('size');\n\t\t\t\t\t\tvar lifeTimeAttribute = this.particleShaderGeo.getAttribute('lifeTime');\n\n\t\t\t\t\t\toptions = options || {};\n\n\t\t\t\t\t\t// setup reasonable default values for all arguments\n\n\t\t\t\t\t\tposition = options.position !== undefined ? position.copy(options.position) : position.set(0, 0, 0);\n\t\t\t\t\t\tvelocity = options.velocity !== undefined ? velocity.copy(options.velocity) : velocity.set(0, 0, 0);\n\t\t\t\t\t\tcolor = options.color !== undefined ? color.set(options.color) : color.set(0xffffff);\n\n\t\t\t\t\t\tvar positionRandomness = options.positionRandomness !== undefined ? options.positionRandomness : 0;\n\t\t\t\t\t\tvar velocityRandomness = options.velocityRandomness !== undefined ? options.velocityRandomness : 0;\n\t\t\t\t\t\tvar colorRandomness = options.colorRandomness !== undefined ? options.colorRandomness : 1;\n\t\t\t\t\t\tvar turbulence = options.turbulence !== undefined ? options.turbulence : 1;\n\t\t\t\t\t\tvar lifetime = options.lifetime !== undefined ? options.lifetime : 5;\n\t\t\t\t\t\tvar size = options.size !== undefined ? options.size : 10;\n\t\t\t\t\t\tvar sizeRandomness = options.sizeRandomness !== undefined ? options.sizeRandomness : 0;\n\t\t\t\t\t\tvar smoothPosition = options.smoothPosition !== undefined ? options.smoothPosition : false;\n\n\t\t\t\t\t\tif (this.DPR !== undefined) size *= this.DPR;\n\n\t\t\t\t\t\tvar i = this.PARTICLE_CURSOR;\n\n\t\t\t\t\t\t// position\n\n\t\t\t\t\t\tpositionStartAttribute.array[i * 3 + 0] = position.x + particleSystem.random() * positionRandomness;\n\t\t\t\t\t\tpositionStartAttribute.array[i * 3 + 1] = position.y + particleSystem.random() * positionRandomness;\n\t\t\t\t\t\tpositionStartAttribute.array[i * 3 + 2] = position.z + particleSystem.random() * positionRandomness;\n\n\t\t\t\t\t\tif (smoothPosition === true) {\n\n\t\t\t\t\t\t\t\t\tpositionStartAttribute.array[i * 3 + 0] += -(velocity.x * particleSystem.random());\n\t\t\t\t\t\t\t\t\tpositionStartAttribute.array[i * 3 + 1] += -(velocity.y * particleSystem.random());\n\t\t\t\t\t\t\t\t\tpositionStartAttribute.array[i * 3 + 2] += -(velocity.z * particleSystem.random());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// velocity\n\n\t\t\t\t\t\tvar maxVel = 2;\n\n\t\t\t\t\t\tvar velX = velocity.x + particleSystem.random() * velocityRandomness;\n\t\t\t\t\t\tvar velY = velocity.y + particleSystem.random() * velocityRandomness;\n\t\t\t\t\t\tvar velZ = velocity.z + particleSystem.random() * velocityRandomness;\n\n\t\t\t\t\t\tvelX = THREE.MathUtils.clamp((velX - -maxVel) / (maxVel - -maxVel), 0, 1);\n\t\t\t\t\t\tvelY = THREE.MathUtils.clamp((velY - -maxVel) / (maxVel - -maxVel), 0, 1);\n\t\t\t\t\t\tvelZ = THREE.MathUtils.clamp((velZ - -maxVel) / (maxVel - -maxVel), 0, 1);\n\n\t\t\t\t\t\tvelocityAttribute.array[i * 3 + 0] = velX;\n\t\t\t\t\t\tvelocityAttribute.array[i * 3 + 1] = velY;\n\t\t\t\t\t\tvelocityAttribute.array[i * 3 + 2] = velZ;\n\n\t\t\t\t\t\t// color\n\n\t\t\t\t\t\tcolor.r = THREE.MathUtils.clamp(color.r + particleSystem.random() * colorRandomness, 0, 1);\n\t\t\t\t\t\tcolor.g = THREE.MathUtils.clamp(color.g + particleSystem.random() * colorRandomness, 0, 1);\n\t\t\t\t\t\tcolor.b = THREE.MathUtils.clamp(color.b + particleSystem.random() * colorRandomness, 0, 1);\n\n\t\t\t\t\t\tcolorAttribute.array[i * 3 + 0] = color.r;\n\t\t\t\t\t\tcolorAttribute.array[i * 3 + 1] = color.g;\n\t\t\t\t\t\tcolorAttribute.array[i * 3 + 2] = color.b;\n\n\t\t\t\t\t\t// turbulence, size, lifetime and starttime\n\n\t\t\t\t\t\tturbulenceAttribute.array[i] = turbulence;\n\t\t\t\t\t\tsizeAttribute.array[i] = size + particleSystem.random() * sizeRandomness;\n\t\t\t\t\t\tlifeTimeAttribute.array[i] = lifetime;\n\t\t\t\t\t\tstartTimeAttribute.array[i] = this.time + particleSystem.random() * 2e-2;\n\n\t\t\t\t\t\t// offset\n\n\t\t\t\t\t\tif (this.offset === 0) {\n\n\t\t\t\t\t\t\t\t\tthis.offset = this.PARTICLE_CURSOR;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// counter and cursor\n\n\t\t\t\t\t\tthis.count++;\n\t\t\t\t\t\tthis.PARTICLE_CURSOR++;\n\n\t\t\t\t\t\tif (this.PARTICLE_CURSOR >= this.PARTICLE_COUNT) {\n\n\t\t\t\t\t\t\t\t\tthis.PARTICLE_CURSOR = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.particleUpdate = true;\n\t\t\t};\n\n\t\t\tthis.init = function () {\n\n\t\t\t\t\t\tthis.particleSystem = new THREE.Points(this.particleShaderGeo, this.particleShaderMat);\n\t\t\t\t\t\tthis.particleSystem.frustumCulled = false;\n\t\t\t\t\t\tthis.add(this.particleSystem);\n\t\t\t};\n\n\t\t\tthis.update = function (time) {\n\n\t\t\t\t\t\tthis.time = time;\n\t\t\t\t\t\tthis.particleShaderMat.uniforms.uTime.value = time;\n\n\t\t\t\t\t\tthis.geometryUpdate();\n\t\t\t};\n\n\t\t\tthis.geometryUpdate = function () {\n\n\t\t\t\t\t\tif (this.particleUpdate === true) {\n\n\t\t\t\t\t\t\t\t\tthis.particleUpdate = false;\n\n\t\t\t\t\t\t\t\t\tvar positionStartAttribute = this.particleShaderGeo.getAttribute('positionStart');\n\t\t\t\t\t\t\t\t\tvar startTimeAttribute = this.particleShaderGeo.getAttribute('startTime');\n\t\t\t\t\t\t\t\t\tvar velocityAttribute = this.particleShaderGeo.getAttribute('velocity');\n\t\t\t\t\t\t\t\t\tvar turbulenceAttribute = this.particleShaderGeo.getAttribute('turbulence');\n\t\t\t\t\t\t\t\t\tvar colorAttribute = this.particleShaderGeo.getAttribute('color');\n\t\t\t\t\t\t\t\t\tvar sizeAttribute = this.particleShaderGeo.getAttribute('size');\n\t\t\t\t\t\t\t\t\tvar lifeTimeAttribute = this.particleShaderGeo.getAttribute('lifeTime');\n\n\t\t\t\t\t\t\t\t\tif (this.offset + this.count < this.PARTICLE_COUNT) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tpositionStartAttribute.updateRange.offset = this.offset * positionStartAttribute.itemSize;\n\t\t\t\t\t\t\t\t\t\t\t\tstartTimeAttribute.updateRange.offset = this.offset * startTimeAttribute.itemSize;\n\t\t\t\t\t\t\t\t\t\t\t\tvelocityAttribute.updateRange.offset = this.offset * velocityAttribute.itemSize;\n\t\t\t\t\t\t\t\t\t\t\t\tturbulenceAttribute.updateRange.offset = this.offset * turbulenceAttribute.itemSize;\n\t\t\t\t\t\t\t\t\t\t\t\tcolorAttribute.updateRange.offset = this.offset * colorAttribute.itemSize;\n\t\t\t\t\t\t\t\t\t\t\t\tsizeAttribute.updateRange.offset = this.offset * sizeAttribute.itemSize;\n\t\t\t\t\t\t\t\t\t\t\t\tlifeTimeAttribute.updateRange.offset = this.offset * lifeTimeAttribute.itemSize;\n\n\t\t\t\t\t\t\t\t\t\t\t\tpositionStartAttribute.updateRange.count = this.count * positionStartAttribute.itemSize;\n\t\t\t\t\t\t\t\t\t\t\t\tstartTimeAttribute.updateRange.count = this.count * startTimeAttribute.itemSize;\n\t\t\t\t\t\t\t\t\t\t\t\tvelocityAttribute.updateRange.count = this.count * velocityAttribute.itemSize;\n\t\t\t\t\t\t\t\t\t\t\t\tturbulenceAttribute.updateRange.count = this.count * turbulenceAttribute.itemSize;\n\t\t\t\t\t\t\t\t\t\t\t\tcolorAttribute.updateRange.count = this.count * colorAttribute.itemSize;\n\t\t\t\t\t\t\t\t\t\t\t\tsizeAttribute.updateRange.count = this.count * sizeAttribute.itemSize;\n\t\t\t\t\t\t\t\t\t\t\t\tlifeTimeAttribute.updateRange.count = this.count * lifeTimeAttribute.itemSize;\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tpositionStartAttribute.updateRange.offset = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tstartTimeAttribute.updateRange.offset = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tvelocityAttribute.updateRange.offset = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tturbulenceAttribute.updateRange.offset = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tcolorAttribute.updateRange.offset = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tsizeAttribute.updateRange.offset = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tlifeTimeAttribute.updateRange.offset = 0;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Use -1 to update the entire buffer, see #11476\n\t\t\t\t\t\t\t\t\t\t\t\tpositionStartAttribute.updateRange.count = -1;\n\t\t\t\t\t\t\t\t\t\t\t\tstartTimeAttribute.updateRange.count = -1;\n\t\t\t\t\t\t\t\t\t\t\t\tvelocityAttribute.updateRange.count = -1;\n\t\t\t\t\t\t\t\t\t\t\t\tturbulenceAttribute.updateRange.count = -1;\n\t\t\t\t\t\t\t\t\t\t\t\tcolorAttribute.updateRange.count = -1;\n\t\t\t\t\t\t\t\t\t\t\t\tsizeAttribute.updateRange.count = -1;\n\t\t\t\t\t\t\t\t\t\t\t\tlifeTimeAttribute.updateRange.count = -1;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tpositionStartAttribute.needsUpdate = true;\n\t\t\t\t\t\t\t\t\tstartTimeAttribute.needsUpdate = true;\n\t\t\t\t\t\t\t\t\tvelocityAttribute.needsUpdate = true;\n\t\t\t\t\t\t\t\t\tturbulenceAttribute.needsUpdate = true;\n\t\t\t\t\t\t\t\t\tcolorAttribute.needsUpdate = true;\n\t\t\t\t\t\t\t\t\tsizeAttribute.needsUpdate = true;\n\t\t\t\t\t\t\t\t\tlifeTimeAttribute.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tthis.offset = 0;\n\t\t\t\t\t\t\t\t\tthis.count = 0;\n\t\t\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.dispose = function () {\n\n\t\t\t\t\t\tthis.particleShaderGeo.dispose();\n\t\t\t};\n\n\t\t\tthis.init();\n};\n\nTHREE.GPUParticleContainer.prototype = Object.create(THREE.Object3D.prototype);\nTHREE.GPUParticleContainer.prototype.constructor = THREE.GPUParticleContainer;\n\n//# sourceURL=webpack:///./src/extra/GPUParticleSystem.js?")
        },
        "./src/extra/MeshLine.js": /*!*******************************!*\
  !*** ./src/extra/MeshLine.js ***!
  \*******************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\n//changed by zhgu\n//feat:增加贴图移动接口，当然还是不太完美\n(function () {\n\n    'use strict';\n\n    var root = this;\n\n    //var has_require = typeof require !== 'undefined'\n\n    //var THREE = root.THREE || has_require && require('three')\n    if (!THREE) throw new Error('MeshLine requires three.min.js');\n\n    function MeshLine() {\n\n        this.positions = [];\n\n        this.previous = [];\n        this.next = [];\n        this.side = [];\n        this.width = [];\n        this.indices_array = [];\n        this.uvs = [];\n        this.counters = [];\n        this.geometry = new THREE.BufferGeometry();\n\n        this.widthCallback = null;\n    }\n\n    MeshLine.prototype.setGeometry = function (g, c, uStep) {\n\n        this.widthCallback = c;\n\n        this.positions = [];\n        this.counters = [];\n\n        this.textureCoord = g.textureCoord;\n\n        if (g instanceof THREE.Geometry) {\n            for (var j = 0; j < g.vertices.length; j++) {\n                var v = g.vertices[j];\n                var c = j / g.vertices.length;\n                this.positions.push(v.x, v.y, v.z);\n                this.positions.push(v.x, v.y, v.z);\n                this.counters.push(c);\n                this.counters.push(c);\n            }\n        }\n\n        if (g instanceof THREE.BufferGeometry) {\n            // read attribute positions ?\n        }\n\n        if (g instanceof Float32Array || g instanceof Array) {\n            for (var j = 0; j < g.length; j += 3) {\n                var c = j / g.length;\n                this.positions.push(g[j], g[j + 1], g[j + 2]);\n                this.positions.push(g[j], g[j + 1], g[j + 2]);\n                this.counters.push(c);\n                this.counters.push(c);\n            }\n        }\n\n        this.process(uStep);\n    };\n\n    MeshLine.prototype.compareV3 = function (a, b) {\n\n        var aa = a * 6;\n        var ab = b * 6;\n        return this.positions[aa] === this.positions[ab] && this.positions[aa + 1] === this.positions[ab + 1] && this.positions[aa + 2] === this.positions[ab + 2];\n    };\n\n    MeshLine.prototype.copyV3 = function (a) {\n\n        var aa = a * 6;\n        return [this.positions[aa], this.positions[aa + 1], this.positions[aa + 2]];\n    };\n\n    MeshLine.prototype.process = function (uStep) {\n\n        var l = this.positions.length / 6;\n\n        this.previous = [];\n        this.next = [];\n        this.side = [];\n        this.width = [];\n        this.indices_array = [];\n        this.uvs = [];\n\n        for (var j = 0; j < l; j++) {\n            this.side.push(1);\n            this.side.push(-1);\n        }\n\n        var w;\n        for (var j = 0; j < l; j++) {\n            if (this.widthCallback) w = this.widthCallback(j / (l - 1));else w = 1;\n            this.width.push(w);\n            this.width.push(w);\n        }\n        if (uStep) {\n            var dx,\n                dy,\n                dz,\n                d,\n                totalDist = 0;\n            var distArray = [];\n            for (var j = 0; j < l; j++) {\n                if (j === 0) {\n                    d = 0;\n                } else {\n                    dx = this.positions[j * 6] - this.positions[j * 6 - 6];\n                    dy = this.positions[j * 6 + 1] - this.positions[j * 6 - 6 + 1];\n                    dz = this.positions[j * 6 + 2] - this.positions[j * 6 - 6 + 2];\n                    d = Math.sqrt(dx * dx + dy * dy + dz * dz);\n                }\n\n                totalDist += d;\n                distArray.push(totalDist);\n            }\n\n            for (var j = 0; j < l; j++) {\n                this.uvs.push(distArray[j] / uStep, 0);\n                this.uvs.push(distArray[j] / uStep, 1);\n            }\n        } else {\n            for (var j = 0; j < l; j++) {\n                if (this.textureCoord && this.textureCoord.length > 0) {\n                    var tc = this.textureCoord[j];\n                    this.uvs.push(tc.x, 0);\n                    this.uvs.push(tc.x, 1);\n                } else {\n                    this.uvs.push(j / (l - 1), 0);\n                    this.uvs.push(j / (l - 1), 1);\n                }\n            }\n        }\n\n        var v;\n\n        if (this.compareV3(0, l - 1)) {\n            v = this.copyV3(l - 2);\n        } else {\n            v = this.copyV3(0);\n        }\n        this.previous.push(v[0], v[1], v[2]);\n        this.previous.push(v[0], v[1], v[2]);\n        for (var j = 0; j < l - 1; j++) {\n            v = this.copyV3(j);\n            this.previous.push(v[0], v[1], v[2]);\n            this.previous.push(v[0], v[1], v[2]);\n        }\n\n        for (var j = 1; j < l; j++) {\n            v = this.copyV3(j);\n            this.next.push(v[0], v[1], v[2]);\n            this.next.push(v[0], v[1], v[2]);\n        }\n\n        if (this.compareV3(l - 1, 0)) {\n            v = this.copyV3(1);\n        } else {\n            v = this.copyV3(l - 1);\n        }\n        this.next.push(v[0], v[1], v[2]);\n        this.next.push(v[0], v[1], v[2]);\n\n        for (var j = 0; j < l - 1; j++) {\n            var n = j * 2;\n            this.indices_array.push(n, n + 1, n + 2);\n            this.indices_array.push(n + 2, n + 1, n + 3);\n        }\n\n        if (!this.attributes) {\n            this.attributes = {\n                position: new THREE.BufferAttribute(new Float32Array(this.positions), 3),\n                previous: new THREE.BufferAttribute(new Float32Array(this.previous), 3),\n                next: new THREE.BufferAttribute(new Float32Array(this.next), 3),\n                side: new THREE.BufferAttribute(new Float32Array(this.side), 1),\n                width: new THREE.BufferAttribute(new Float32Array(this.width), 1),\n                uv: new THREE.BufferAttribute(new Float32Array(this.uvs), 2),\n                index: new THREE.BufferAttribute(new Uint16Array(this.indices_array), 1),\n                counters: new THREE.BufferAttribute(new Float32Array(this.counters), 1)\n            };\n        } else {\n            this.attributes.position.copyArray(new Float32Array(this.positions));\n            this.attributes.position.needsUpdate = true;\n            this.attributes.previous.copyArray(new Float32Array(this.previous));\n            this.attributes.previous.needsUpdate = true;\n            this.attributes.next.copyArray(new Float32Array(this.next));\n            this.attributes.next.needsUpdate = true;\n            this.attributes.side.copyArray(new Float32Array(this.side));\n            this.attributes.side.needsUpdate = true;\n            this.attributes.width.copyArray(new Float32Array(this.width));\n            this.attributes.width.needsUpdate = true;\n            this.attributes.uv.copyArray(new Float32Array(this.uvs));\n            this.attributes.uv.needsUpdate = true;\n            this.attributes.index.copyArray(new Uint16Array(this.indices_array));\n            this.attributes.index.needsUpdate = true;\n        }\n\n        this.geometry.addAttribute('position', this.attributes.position);\n        this.geometry.addAttribute('previous', this.attributes.previous);\n        this.geometry.addAttribute('next', this.attributes.next);\n        this.geometry.addAttribute('side', this.attributes.side);\n        this.geometry.addAttribute('width', this.attributes.width);\n        this.geometry.addAttribute('uv', this.attributes.uv);\n        this.geometry.addAttribute('counters', this.attributes.counters);\n\n        this.geometry.setIndex(this.attributes.index);\n    };\n\n    function memcpy(src, srcOffset, dst, dstOffset, length) {\n        var i;\n\n        src = src.subarray || src.slice ? src : src.buffer;\n        dst = dst.subarray || dst.slice ? dst : dst.buffer;\n\n        src = srcOffset ? src.subarray ? src.subarray(srcOffset, length && srcOffset + length) : src.slice(srcOffset, length && srcOffset + length) : src;\n\n        if (dst.set) {\n            dst.set(src, dstOffset);\n        } else {\n            for (i = 0; i < src.length; i++) {\n                dst[i + dstOffset] = src[i];\n            }\n        }\n\n        return dst;\n    }\n\n    /**\r\n     * Fast method to advance the line by one position.  The oldest position is removed.\r\n     * @param position\r\n     */\n    MeshLine.prototype.advance = function (position) {\n\n        var positions = this.attributes.position.array;\n        var previous = this.attributes.previous.array;\n        var next = this.attributes.next.array;\n        var l = positions.length;\n\n        // PREVIOUS\n        memcpy(positions, 0, previous, 0, l);\n\n        // POSITIONS\n        memcpy(positions, 6, positions, 0, l - 6);\n\n        positions[l - 6] = position.x;\n        positions[l - 5] = position.y;\n        positions[l - 4] = position.z;\n        positions[l - 3] = position.x;\n        positions[l - 2] = position.y;\n        positions[l - 1] = position.z;\n\n        // NEXT\n        memcpy(positions, 6, next, 0, l - 6);\n\n        next[l - 6] = position.x;\n        next[l - 5] = position.y;\n        next[l - 4] = position.z;\n        next[l - 3] = position.x;\n        next[l - 2] = position.y;\n        next[l - 1] = position.z;\n\n        this.attributes.position.needsUpdate = true;\n        this.attributes.previous.needsUpdate = true;\n        this.attributes.next.needsUpdate = true;\n    };\n\n    function MeshLineMaterial(parameters) {\n\n        var vertexShaderSource = ['precision highp float;', 'attribute vec2 uv2;', 'attribute vec3 previous;', 'attribute vec3 next;', 'attribute float side;', 'attribute float width;', 'attribute float counters;', '#ifdef USE_VISIBLE', 'attribute float vis;', '#endif', '#include <common>', '#include <logdepthbuf_pars_vertex>', '#include <fog_pars_vertex>', 'uniform vec2 resolution;', 'uniform float lineWidth;', 'uniform vec3 color;', 'uniform float opacity;', 'uniform float near;', 'uniform float far;', 'uniform float sizeAttenuation;', '', 'varying vec2 vUV;', 'varying vec2 vUV2;', 'varying vec4 vColor;', 'varying float vCounters;', '#ifdef USE_GPUPICKER', '   varying vec4 worldId;', '#ifdef USE_ID_ATTRIBUTES', 'attribute float id;', '#else', '       uniform float baseId;', '#endif', '#endif', '#define EPSILON 1e-6', '', 'vec2 fix( vec4 i, float aspect ) {', '', '    vec2 res = i.xy / i.w;', '    res.x *= aspect;', '\t vCounters = counters;', '    return res;', '', '}', '', 'void main() {', '', '    float aspect = resolution.x / resolution.y;', '\t float pixelWidthRatio = 1. / (resolution.x * projectionMatrix[0][0]);', '', '    vColor = vec4( color, opacity );', '    vUV = uv;', '    vUV2 = uv2;', '', '    mat4 m = projectionMatrix * modelViewMatrix;', '    vec4 finalPosition = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '    vec4 prevPos = m * vec4( previous, 1.0 );', '    vec4 nextPos = m * vec4( next, 1.0 );', '', '    vec2 currentP = fix( finalPosition, aspect );', '    vec2 prevP = fix( prevPos, aspect );', '    vec2 nextP = fix( nextPos, aspect );', '', '\t float pixelWidth = finalPosition.w * pixelWidthRatio;', '    float w = 1.8 * pixelWidth * lineWidth * width;', '', '    if( sizeAttenuation == 1. ) {', '        w = lineWidth * width * finalPosition.w * 2. / resolution.x;', '    }', '', '    vec2 dir;', '    if( nextP == currentP ) dir = normalize( currentP - prevP );', '    else if( prevP == currentP ) dir = normalize( nextP - currentP );', '    else {', '        vec2 dir1 = normalize( currentP - prevP );', '        vec2 dir2 = normalize( nextP - currentP );', '        dir = normalize( dir1 + dir2 );', '', '        vec2 perp = vec2( -dir1.y, dir1.x );', '        vec2 miter = vec2( -dir.y, dir.x );', '        //w = clamp( w / dot( miter, perp ), 0., 4. * lineWidth * width );', '        w = w / max(dot( miter, perp ), 0.2);', '', '    }', '', '    //vec2 normal = ( cross( vec3( dir, 0. ), vec3( 0., 0., 1. ) ) ).xy;', '    vec2 normal = vec2( -dir.y, dir.x );', '    if( sizeAttenuation == 1. ) {', '       normal.y *= aspect;', '    } else {', '       normal.x /= aspect;', '    }', '    normal *= .5 * w;', '', '    vec4 offset = vec4( normal * side, 0.0, 1.0 );', '    finalPosition.xy += offset.xy;', '#ifdef USE_GPUPICKER', '#ifdef USE_ID_ATTRIBUTES', 'float baseId = id;', '#endif', ' vec3 a = fract(vec3(1.0/255.0, 1.0/(255.0*255.0), 1.0/(255.0*255.0*255.0)) * baseId);', '        a -= a.xxy * vec3(0.0, 1.0/255.0, 1.0/255.0);', '        worldId = vec4(a,1);', '#endif', '', 'vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );', '#include <fog_vertex>', '#ifdef USE_VISIBLE', '   gl_Position = finalPosition * vis;', '#else', '   gl_Position = finalPosition;', '#endif', \"#include <logdepthbuf_vertex>\", '', '}'];\n\n        var fragmentShaderSource = [\n        //'#extension GL_OES_standard_derivatives : enable',\n        'precision highp float;', 'uniform sampler2D map;', 'uniform sampler2D alphaMap;', 'uniform float useMap;', 'uniform float useAlphaMap;', 'uniform float useDash;', 'uniform vec2 dashArray;', 'uniform float visibility;', 'uniform float alphaTest;', 'uniform vec2 repeat;', 'uniform vec2 offset;', 'uniform float growPer;', 'uniform mat3 uvTransform;', 'uniform float strength;', '#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', 'varying vec2 vUV;', 'varying vec2 vUV2;', 'varying vec4 vColor;', 'varying float vCounters;', ' #ifdef USE_GPUPICKER', 'varying vec4 worldId;', '#endif', THREE.ShaderChunk[\"common\"], '', 'void main() {', '', '    vec4 c = vColor;', '    if( useMap == 1. ) c *= texture2D( map, vUV * repeat + offset);',\n        // '    vec2 vUv1 = ( uvTransform * vec3( vUV, 1 ) ).xy;',\n        '    vec2 vUv2 = ( uvTransform * vec3( vUV2, 1 ) ).xy;', '    if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUv2 ).g;', '\t if( c.a < alphaTest ) discard;', '#include <logdepthbuf_fragment>', '\t if( useDash == 1. ){', '\t \t ', '\t }', '    gl_FragColor = c;',\n\n        // '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n',\n        // 'gl_FragDepthEXT = 0.0001;\\n',\n        // '#endif\\n',\n        'gl_FragColor.a *= step(vCounters,visibility);', '#ifdef USE_GPUPICKER', ' gl_FragColor = worldId;', 'return;', '#endif', 'gl_FragColor *= strength;', '#include <fog_fragment>', '}'];\n\n        function check(v, d) {\n            if (v === undefined) return d;\n            return v;\n        }\n\n        THREE.Material.call(this);\n\n        parameters = parameters || {};\n        this.growPer = check(parameters.growPer, 1.0);\n        this.strength = check(parameters.strength, 1.0);\n        this.baseId = check(parameters.baseId, 0.0);\n        this.lineWidth = check(parameters.lineWidth, 1);\n        this.map = check(parameters.map, null);\n        this.useMap = check(parameters.useMap, 0);\n        this.alphaMap = check(parameters.alphaMap, null);\n        this.useAlphaMap = check(parameters.useAlphaMap, 0);\n        this.color = check(parameters.color, new THREE.Color(0xffffff));\n        this.opacity = check(parameters.opacity, 1);\n        this.resolution = check(parameters.resolution, new THREE.Vector2(1, 1));\n        this.sizeAttenuation = check(parameters.sizeAttenuation, 1);\n        this.near = check(parameters.near, 1);\n        this.far = check(parameters.far, 1);\n        this.logDepthBufFC = check(parameters.logDepthBufFC, 1);\n        this.dashArray = check(parameters.dashArray, []);\n        this.useDash = this.dashArray !== [] ? 1 : 0;\n        this.visibility = check(parameters.visibility, 1);\n        this.alphaTest = check(parameters.alphaTest, 0);\n        this.repeat = check(parameters.repeat, new THREE.Vector2(1, 1));\n        this.offset = check(parameters.offset, new THREE.Vector2(0, 0));\n\n        var material = new THREE.ShaderMaterial({\n            uniforms: {\n                fogDensity: { value: 0.00025 },\n                fogNear: { value: 1 },\n                fogFar: { value: 2000 },\n                fogColor: { value: new THREE.Color(0xffffff) },\n                fogAlpha: { value: 1.0 },\n                growPer: { type: 'f', value: this.growPer },\n                strength: { type: 'f', value: this.strength },\n                baseId: { value: this.baseId },\n                lineWidth: { type: 'f', value: this.lineWidth },\n                map: { type: 't', value: this.map },\n                useMap: { type: 'f', value: this.useMap },\n                alphaMap: { type: 't', value: this.alphaMap },\n                useAlphaMap: { type: 'f', value: this.useAlphaMap },\n                color: { type: 'c', value: this.color },\n                opacity: { type: 'f', value: this.opacity },\n                resolution: { type: 'v2', value: this.resolution },\n                sizeAttenuation: { type: 'f', value: this.sizeAttenuation },\n                near: { type: 'f', value: this.near },\n                far: { type: 'f', value: this.far },\n                dashArray: { type: 'v2', value: new THREE.Vector2(this.dashArray[0], this.dashArray[1]) },\n                useDash: { type: 'f', value: this.useDash },\n                visibility: { type: 'f', value: this.visibility },\n                alphaTest: { type: 'f', value: this.alphaTest },\n                repeat: { type: 'v2', value: this.repeat },\n                offset: { type: 'v2', value: this.offset },\n                // logDepthBufFC: {type:'f', value: this.logDepthBufFC},\n                uvTransform: { value: new THREE.Matrix3() }\n            },\n            vertexShader: vertexShaderSource.join('\\r\\n'),\n            fragmentShader: fragmentShaderSource.join('\\r\\n'),\n            // defines:{\n            //     USE_GPUPICKER:false,\n            //     USE_LOGDEPTHBUF:false,\n            //     USE_LOGDEPTHBUF_EXT:false\n            // },\n            fog: true\n        });\n\n        material.type = 'MeshLineMaterial';\n\n        // material.setValues( parameters );\n\n        return material;\n    }\n\n    MeshLineMaterial.prototype = Object.create(THREE.Material.prototype);\n    MeshLineMaterial.prototype.constructor = MeshLineMaterial;\n    THREE.RawShaderMaterial.prototype.setBaseID = function (baseId) {\n        this.uniforms.baseId.value = baseId;\n    };\n\n    MeshLineMaterial.prototype.copy = function (source) {\n\n        THREE.Material.prototype.copy.call(this, source);\n        this.growPer = source.growPer;\n        this.strength = source.strength;\n        this.lineWidth = source.lineWidth;\n        this.map = source.map;\n        this.useMap = source.useMap;\n        this.alphaMap = source.alphaMap;\n        this.useAlphaMap = source.useAlphaMap;\n        this.color.copy(source.color);\n        this.opacity = source.opacity;\n        this.resolution.copy(source.resolution);\n        this.sizeAttenuation = source.sizeAttenuation;\n        this.near = source.near;\n        this.far = source.far;\n        this.logDepthBufFC = source.logDepthBufFC;\n        this.dashArray.copy(source.dashArray);\n        this.useDash = source.useDash;\n        this.visibility = source.visibility;\n        this.alphaTest = source.alphaTest;\n        this.repeat.copy(source.repeat);\n        this.uvTransform.copy(source.uvTransform);\n\n        return this;\n    };\n\n    if (true) {\n        if ( true && module.exports) {\n            exports = module.exports = { MeshLine: MeshLine, MeshLineMaterial: MeshLineMaterial };\n        }\n        exports.MeshLine = MeshLine;\n        exports.MeshLineMaterial = MeshLineMaterial;\n    } else {}\n}).call(undefined);\n\n//# sourceURL=webpack:///./src/extra/MeshLine.js?")
        },
        "./src/extra/SceneUtils.js": /*!*********************************!*\
  !*** ./src/extra/SceneUtils.js ***!
  \*********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.SceneUtils = {\n\n\t\tcreateMultiMaterialObject: function createMultiMaterialObject(geometry, materials) {\n\n\t\t\t\tvar group = new THREE.Group();\n\n\t\t\t\tfor (var i = 0, l = materials.length; i < l; i++) {\n\n\t\t\t\t\t\tgroup.add(new THREE.Mesh(geometry, materials[i]));\n\t\t\t\t}\n\n\t\t\t\treturn group;\n\t\t},\n\n\t\tdetach: function detach(child, parent, scene) {\n\n\t\t\t\tchild.applyMatrix4(parent.matrixWorld);\n\t\t\t\tparent.remove(child);\n\t\t\t\tscene.add(child);\n\t\t},\n\n\t\tattach: function attach(child, scene, parent) {\n\n\t\t\t\tchild.applyMatrix4(new THREE.Matrix4().getInverse(parent.matrixWorld));\n\n\t\t\t\tscene.remove(child);\n\t\t\t\tparent.add(child);\n\t\t}\n\n};\n\n//# sourceURL=webpack:///./src/extra/SceneUtils.js?")
        },
        "./src/extra/TGALoader.js": /*!********************************!*\
  !*** ./src/extra/TGALoader.js ***!
  \********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\n/*\r\n * @author Daosheng Mu / https://github.com/DaoshengMu/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author takahirox / https://github.com/takahirox/\r\n */\n\nTHREE.TGALoader = function (manager) {\n\n\t\t\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nTHREE.TGALoader.prototype = {\n\n\t\t\tconstructor: THREE.TGALoader,\n\n\t\t\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\t\t\t\t\tvar scope = this;\n\n\t\t\t\t\t\tvar texture = new THREE.Texture();\n\n\t\t\t\t\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\t\t\t\t\tloader.setResponseType('arraybuffer');\n\t\t\t\t\t\tloader.setPath(this.path);\n\n\t\t\t\t\t\tloader.load(url, function (buffer) {\n\n\t\t\t\t\t\t\t\t\ttexture.image = scope.parse(buffer);\n\t\t\t\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tif (onLoad !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tonLoad(texture);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, onProgress, onError);\n\n\t\t\t\t\t\treturn texture;\n\t\t\t},\n\n\t\t\tparse: function parse(buffer) {\n\n\t\t\t\t\t\t// reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n\n\t\t\t\t\t\tfunction tgaCheckHeader(header) {\n\n\t\t\t\t\t\t\t\t\tswitch (header.image_type) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// check indexed type\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\t\t\t\t\t\t\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.error('THREE.TGALoader: Invalid type colormap data for indexed type.');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// check colormap type\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\t\t\t\t\t\t\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\t\t\t\t\t\t\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\t\t\t\t\t\t\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (header.colormap_type) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.error('THREE.TGALoader: Invalid type colormap data for colormap type.');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// What the need of a file without data ?\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase TGA_TYPE_NO_DATA:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.error('THREE.TGALoader: No data.');\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Invalid type ?\n\n\t\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.error('THREE.TGALoader: Invalid type \"%s\".', header.image_type);\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// check image width and height\n\n\t\t\t\t\t\t\t\t\tif (header.width <= 0 || header.height <= 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.error('THREE.TGALoader: Invalid image size.');\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// check image pixel size\n\n\t\t\t\t\t\t\t\t\tif (header.pixel_size !== 8 && header.pixel_size !== 16 && header.pixel_size !== 24 && header.pixel_size !== 32) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.error('THREE.TGALoader: Invalid pixel size \"%s\".', header.pixel_size);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// parse tga image buffer\n\n\t\t\t\t\t\tfunction tgaParse(use_rle, use_pal, header, offset, data) {\n\n\t\t\t\t\t\t\t\t\tvar pixel_data, pixel_size, pixel_total, palettes;\n\n\t\t\t\t\t\t\t\t\tpixel_size = header.pixel_size >> 3;\n\t\t\t\t\t\t\t\t\tpixel_total = header.width * header.height * pixel_size;\n\n\t\t\t\t\t\t\t\t\t// read palettes\n\n\t\t\t\t\t\t\t\t\tif (use_pal) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tpalettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// read RLE\n\n\t\t\t\t\t\t\t\t\tif (use_rle) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tpixel_data = new Uint8Array(pixel_total);\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar c, count, i;\n\t\t\t\t\t\t\t\t\t\t\t\tvar shift = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tvar pixels = new Uint8Array(pixel_size);\n\n\t\t\t\t\t\t\t\t\t\t\t\twhile (shift < pixel_total) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tc = data[offset++];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount = (c & 0x7f) + 1;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// RLE pixels\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (c & 0x80) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// bind pixel tmp array\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (i = 0; i < pixel_size; ++i) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpixels[i] = data[offset++];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// copy pixel array\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (i = 0; i < count; ++i) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpixel_data.set(pixels, shift + i * pixel_size);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshift += pixel_size * count;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// raw pixels\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcount *= pixel_size;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (i = 0; i < count; ++i) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpixel_data[shift + i] = data[offset++];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tshift += count;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// raw pixels\n\n\t\t\t\t\t\t\t\t\t\t\t\tpixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\t\tpixel_data: pixel_data,\n\t\t\t\t\t\t\t\t\t\t\t\tpalettes: palettes\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfunction tgaGetImageData8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {\n\n\t\t\t\t\t\t\t\t\tvar colormap = palettes;\n\t\t\t\t\t\t\t\t\tvar color,\n\t\t\t\t\t\t\t\t\t    i = 0,\n\t\t\t\t\t\t\t\t\t    x,\n\t\t\t\t\t\t\t\t\t    y;\n\t\t\t\t\t\t\t\t\tvar width = header.width;\n\n\t\t\t\t\t\t\t\t\tfor (y = y_start; y !== y_end; y += y_step) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (x = x_start; x !== x_end; x += x_step, i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolor = image[i];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 3] = 255;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn imageData;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfunction tgaGetImageData16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n\n\t\t\t\t\t\t\t\t\tvar color,\n\t\t\t\t\t\t\t\t\t    i = 0,\n\t\t\t\t\t\t\t\t\t    x,\n\t\t\t\t\t\t\t\t\t    y;\n\t\t\t\t\t\t\t\t\tvar width = header.width;\n\n\t\t\t\t\t\t\t\t\tfor (y = y_start; y !== y_end; y += y_step) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (x = x_start; x !== x_end; x += x_step, i += 2) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolor = image[i + 0] + (image[i + 1] << 8); // Inversed ?\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 0] = (color & 0x7C00) >> 7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 1] = (color & 0x03E0) >> 2;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 2] = (color & 0x001F) >> 3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn imageData;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfunction tgaGetImageData24bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n\n\t\t\t\t\t\t\t\t\tvar i = 0,\n\t\t\t\t\t\t\t\t\t    x,\n\t\t\t\t\t\t\t\t\t    y;\n\t\t\t\t\t\t\t\t\tvar width = header.width;\n\n\t\t\t\t\t\t\t\t\tfor (y = y_start; y !== y_end; y += y_step) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (x = x_start; x !== x_end; x += x_step, i += 3) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 3] = 255;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 2] = image[i + 0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 1] = image[i + 1];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 0] = image[i + 2];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn imageData;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfunction tgaGetImageData32bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n\n\t\t\t\t\t\t\t\t\tvar i = 0,\n\t\t\t\t\t\t\t\t\t    x,\n\t\t\t\t\t\t\t\t\t    y;\n\t\t\t\t\t\t\t\t\tvar width = header.width;\n\n\t\t\t\t\t\t\t\t\tfor (y = y_start; y !== y_end; y += y_step) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (x = x_start; x !== x_end; x += x_step, i += 4) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 2] = image[i + 0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 1] = image[i + 1];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 0] = image[i + 2];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 3] = image[i + 3];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn imageData;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfunction tgaGetImageDataGrey8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n\n\t\t\t\t\t\t\t\t\tvar color,\n\t\t\t\t\t\t\t\t\t    i = 0,\n\t\t\t\t\t\t\t\t\t    x,\n\t\t\t\t\t\t\t\t\t    y;\n\t\t\t\t\t\t\t\t\tvar width = header.width;\n\n\t\t\t\t\t\t\t\t\tfor (y = y_start; y !== y_end; y += y_step) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (x = x_start; x !== x_end; x += x_step, i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolor = image[i];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 0] = color;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 1] = color;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 2] = color;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 3] = 255;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn imageData;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfunction tgaGetImageDataGrey16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n\n\t\t\t\t\t\t\t\t\tvar i = 0,\n\t\t\t\t\t\t\t\t\t    x,\n\t\t\t\t\t\t\t\t\t    y;\n\t\t\t\t\t\t\t\t\tvar width = header.width;\n\n\t\t\t\t\t\t\t\t\tfor (y = y_start; y !== y_end; y += y_step) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (x = x_start; x !== x_end; x += x_step, i += 2) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 0] = image[i + 0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 1] = image[i + 0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 2] = image[i + 0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timageData[(x + width * y) * 4 + 3] = image[i + 1];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn imageData;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfunction getTgaRGBA(data, width, height, image, palette) {\n\n\t\t\t\t\t\t\t\t\tvar x_start, y_start, x_step, y_step, x_end, y_end;\n\n\t\t\t\t\t\t\t\t\tswitch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\tcase TGA_ORIGIN_UL:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx_start = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx_step = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx_end = width;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty_start = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty_step = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty_end = height;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase TGA_ORIGIN_BL:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx_start = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx_step = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx_end = width;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty_step = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty_end = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase TGA_ORIGIN_UR:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx_step = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx_end = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty_start = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty_step = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty_end = height;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase TGA_ORIGIN_BR:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx_step = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tx_end = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty_step = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ty_end = -1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (use_grey) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tswitch (header.pixel_size) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 16:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.error('THREE.TGALoader: Format not supported.');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tswitch (header.pixel_size) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 16:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 24:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 32:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.error('THREE.TGALoader: Format not supported.');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Load image data according to specific method\n\t\t\t\t\t\t\t\t\t// var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n\t\t\t\t\t\t\t\t\t// func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n\t\t\t\t\t\t\t\t\treturn data;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// TGA constants\n\n\t\t\t\t\t\tvar TGA_TYPE_NO_DATA = 0,\n\t\t\t\t\t\t    TGA_TYPE_INDEXED = 1,\n\t\t\t\t\t\t    TGA_TYPE_RGB = 2,\n\t\t\t\t\t\t    TGA_TYPE_GREY = 3,\n\t\t\t\t\t\t    TGA_TYPE_RLE_INDEXED = 9,\n\t\t\t\t\t\t    TGA_TYPE_RLE_RGB = 10,\n\t\t\t\t\t\t    TGA_TYPE_RLE_GREY = 11,\n\t\t\t\t\t\t    TGA_ORIGIN_MASK = 0x30,\n\t\t\t\t\t\t    TGA_ORIGIN_SHIFT = 0x04,\n\t\t\t\t\t\t    TGA_ORIGIN_BL = 0x00,\n\t\t\t\t\t\t    TGA_ORIGIN_BR = 0x01,\n\t\t\t\t\t\t    TGA_ORIGIN_UL = 0x02,\n\t\t\t\t\t\t    TGA_ORIGIN_UR = 0x03;\n\n\t\t\t\t\t\tif (buffer.length < 19) console.error('THREE.TGALoader: Not enough data to contain header.');\n\n\t\t\t\t\t\tvar content = new Uint8Array(buffer),\n\t\t\t\t\t\t    offset = 0,\n\t\t\t\t\t\t    header = {\n\t\t\t\t\t\t\t\t\tid_length: content[offset++],\n\t\t\t\t\t\t\t\t\tcolormap_type: content[offset++],\n\t\t\t\t\t\t\t\t\timage_type: content[offset++],\n\t\t\t\t\t\t\t\t\tcolormap_index: content[offset++] | content[offset++] << 8,\n\t\t\t\t\t\t\t\t\tcolormap_length: content[offset++] | content[offset++] << 8,\n\t\t\t\t\t\t\t\t\tcolormap_size: content[offset++],\n\t\t\t\t\t\t\t\t\torigin: [content[offset++] | content[offset++] << 8, content[offset++] | content[offset++] << 8],\n\t\t\t\t\t\t\t\t\twidth: content[offset++] | content[offset++] << 8,\n\t\t\t\t\t\t\t\t\theight: content[offset++] | content[offset++] << 8,\n\t\t\t\t\t\t\t\t\tpixel_size: content[offset++],\n\t\t\t\t\t\t\t\t\tflags: content[offset++]\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// check tga if it is valid format\n\n\t\t\t\t\t\ttgaCheckHeader(header);\n\n\t\t\t\t\t\tif (header.id_length + offset > buffer.length) {\n\n\t\t\t\t\t\t\t\t\tconsole.error('THREE.TGALoader: No data.');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// skip the needn't data\n\n\t\t\t\t\t\toffset += header.id_length;\n\n\t\t\t\t\t\t// get targa information about RLE compression and palette\n\n\t\t\t\t\t\tvar use_rle = false,\n\t\t\t\t\t\t    use_pal = false,\n\t\t\t\t\t\t    use_grey = false;\n\n\t\t\t\t\t\tswitch (header.image_type) {\n\n\t\t\t\t\t\t\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\t\t\t\t\t\t\t\t\tuse_rle = true;\n\t\t\t\t\t\t\t\t\t\t\t\tuse_pal = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\t\t\t\t\t\t\t\t\tuse_pal = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\t\t\t\t\t\t\t\t\tuse_rle = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\t\t\t\t\t\t\t\t\tuse_rle = true;\n\t\t\t\t\t\t\t\t\t\t\t\tuse_grey = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\t\t\t\t\t\t\t\t\tuse_grey = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//\n\n\t\t\t\t\t\tvar canvas = document.createElement('canvas');\n\t\t\t\t\t\tcanvas.width = header.width;\n\t\t\t\t\t\tcanvas.height = header.height;\n\n\t\t\t\t\t\tvar context = canvas.getContext('2d');\n\t\t\t\t\t\tvar imageData = context.createImageData(header.width, header.height);\n\n\t\t\t\t\t\tvar result = tgaParse(use_rle, use_pal, header, offset, content);\n\t\t\t\t\t\tvar rgbaData = getTgaRGBA(imageData.data, header.width, header.height, result.pixel_data, result.palettes);\n\n\t\t\t\t\t\tcontext.putImageData(imageData, 0, 0);\n\n\t\t\t\t\t\treturn canvas;\n\t\t\t},\n\n\t\t\tsetPath: function setPath(value) {\n\n\t\t\t\t\t\tthis.path = value;\n\t\t\t\t\t\treturn this;\n\t\t\t}\n\n};\n\n//# sourceURL=webpack:///./src/extra/TGALoader.js?")
        },
        "./src/extra/cansvg.js": /*!*****************************!*\
  !*** ./src/extra/cansvg.js ***!
  \*****************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\n/*\r\n * canvg.js - Javascript SVG parser and renderer on Canvas\r\n * MIT Licensed\r\n * Gabe Lerner (gabelerner@gmail.com)\r\n * http://code.google.com/p/canvg/\r\n *\r\n * Requires: rgbcolor.js - http://www.phpied.com/rgb-color-parser-in-javascript/\r\n */\n(function () {\n\t// canvg(target, s)\n\t// empty parameters: replace all 'svg' elements on page with 'canvas' elements\n\t// target: canvas element or the id of a canvas element\n\t// s: svg string, url to svg file, or xml document\n\t// opts: optional hash of options\n\t//\t\t ignoreMouse: true => ignore mouse events\n\t//\t\t ignoreAnimation: true => ignore animations\n\t//\t\t ignoreDimensions: true => does not try to resize canvas\n\t//\t\t ignoreClear: true => does not clear canvas\n\t//\t\t offsetX: int => draws at a x offset\n\t//\t\t offsetY: int => draws at a y offset\n\t//\t\t scaleWidth: int => scales horizontally to width\n\t//\t\t scaleHeight: int => scales vertically to height\n\t//\t\t renderCallback: function => will call the function after the first render is completed\n\t//\t\t forceRedraw: function => will call the function on every frame, if it returns true, will redraw\n\twindow.canvg = function (target, s, opts) {\n\t\t// no parameters\n\t\tif (target == null && s == null && opts == null) {\n\t\t\tvar svgTags = document.querySelectorAll('svg');\n\t\t\tfor (var i = 0; i < svgTags.length; i++) {\n\t\t\t\tvar svgTag = svgTags[i];\n\t\t\t\tvar c = document.createElement('canvas');\n\t\t\t\tc.width = svgTag.clientWidth;\n\t\t\t\tc.height = svgTag.clientHeight;\n\t\t\t\tsvgTag.parentNode.insertBefore(c, svgTag);\n\t\t\t\tsvgTag.parentNode.removeChild(svgTag);\n\t\t\t\tvar div = document.createElement('div');\n\t\t\t\tdiv.appendChild(svgTag);\n\t\t\t\tcanvg(c, div.innerHTML);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (typeof target == 'string') {\n\t\t\ttarget = document.getElementById(target);\n\t\t}\n\n\t\t// store class on canvas\n\t\tif (target.svg != null) target.svg.stop();\n\t\tvar svg = build(opts || {});\n\t\t// on i.e. 8 for flash canvas, we can't assign the property so check for it\n\t\tif (!(target.childNodes.length == 1 && target.childNodes[0].nodeName == 'OBJECT')) target.svg = svg;\n\n\t\tvar ctx = target.getContext('2d');\n\t\tif (typeof s.documentElement != 'undefined') {\n\t\t\t// load from xml doc\n\t\t\tsvg.loadXmlDoc(ctx, s);\n\t\t} else if (s.substr(0, 1) == '<') {\n\t\t\t// load from xml string\n\t\t\tsvg.loadXml(ctx, s);\n\t\t} else {\n\t\t\t// load from url\n\t\t\tsvg.load(ctx, s);\n\t\t}\n\t};\n\n\t// see https://developer.mozilla.org/en-US/docs/Web/API/Element.matches\n\tvar matchesSelector;\n\tif (typeof Element.prototype.matches != 'undefined') {\n\t\tmatchesSelector = function matchesSelector(node, selector) {\n\t\t\treturn node.matches(selector);\n\t\t};\n\t} else if (typeof Element.prototype.webkitMatchesSelector != 'undefined') {\n\t\tmatchesSelector = function matchesSelector(node, selector) {\n\t\t\treturn node.webkitMatchesSelector(selector);\n\t\t};\n\t} else if (typeof Element.prototype.mozMatchesSelector != 'undefined') {\n\t\tmatchesSelector = function matchesSelector(node, selector) {\n\t\t\treturn node.mozMatchesSelector(selector);\n\t\t};\n\t} else if (typeof Element.prototype.msMatchesSelector != 'undefined') {\n\t\tmatchesSelector = function matchesSelector(node, selector) {\n\t\t\treturn node.msMatchesSelector(selector);\n\t\t};\n\t} else if (typeof Element.prototype.oMatchesSelector != 'undefined') {\n\t\tmatchesSelector = function matchesSelector(node, selector) {\n\t\t\treturn node.oMatchesSelector(selector);\n\t\t};\n\t} else {\n\t\t// requires Sizzle: https://github.com/jquery/sizzle/wiki/Sizzle-Documentation\n\t\t// or jQuery: http://jquery.com/download/\n\t\t// or Zepto: http://zeptojs.com/#\n\t\t// without it, this is a ReferenceError\n\n\t\tif (typeof jQuery === 'function' || typeof Zepto === 'function') {\n\t\t\tmatchesSelector = function matchesSelector(node, selector) {\n\t\t\t\treturn $(node).is(selector);\n\t\t\t};\n\t\t}\n\n\t\tif (typeof matchesSelector === 'undefined') {\n\t\t\tmatchesSelector = Sizzle.matchesSelector;\n\t\t}\n\t}\n\n\t// slightly modified version of https://github.com/keeganstreet/specificity/blob/master/specificity.js\n\tvar attributeRegex = /(\\[[^\\]]+\\])/g;\n\tvar idRegex = /(#[^\\s\\+>~\\.\\[:]+)/g;\n\tvar classRegex = /(\\.[^\\s\\+>~\\.\\[:]+)/g;\n\tvar pseudoElementRegex = /(::[^\\s\\+>~\\.\\[:]+|:first-line|:first-letter|:before|:after)/gi;\n\tvar pseudoClassWithBracketsRegex = /(:[\\w-]+\\([^\\)]*\\))/gi;\n\tvar pseudoClassRegex = /(:[^\\s\\+>~\\.\\[:]+)/g;\n\tvar elementRegex = /([^\\s\\+>~\\.\\[:]+)/g;\n\tfunction getSelectorSpecificity(selector) {\n\t\tvar typeCount = [0, 0, 0];\n\t\tvar findMatch = function findMatch(regex, type) {\n\t\t\tvar matches = selector.match(regex);\n\t\t\tif (matches == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttypeCount[type] += matches.length;\n\t\t\tselector = selector.replace(regex, ' ');\n\t\t};\n\n\t\tselector = selector.replace(/:not\\(([^\\)]*)\\)/g, '     $1 ');\n\t\tselector = selector.replace(/{[^]*/gm, ' ');\n\t\tfindMatch(attributeRegex, 1);\n\t\tfindMatch(idRegex, 0);\n\t\tfindMatch(classRegex, 1);\n\t\tfindMatch(pseudoElementRegex, 2);\n\t\tfindMatch(pseudoClassWithBracketsRegex, 1);\n\t\tfindMatch(pseudoClassRegex, 1);\n\t\tselector = selector.replace(/[\\*\\s\\+>~]/g, ' ');\n\t\tselector = selector.replace(/[#\\.]/g, ' ');\n\t\tfindMatch(elementRegex, 2);\n\t\treturn typeCount.join('');\n\t}\n\n\tfunction build(opts) {\n\t\tvar svg = { opts: opts };\n\n\t\tsvg.FRAMERATE = 30;\n\t\tsvg.MAX_VIRTUAL_PIXELS = 30000;\n\n\t\tsvg.log = function (msg) {};\n\t\tif (svg.opts['log'] == true && typeof console != 'undefined') {\n\t\t\tsvg.log = function (msg) {\n\t\t\t\tconsole.log(msg);\n\t\t\t};\n\t\t};\n\n\t\t// globals\n\t\tsvg.init = function (ctx) {\n\t\t\tvar uniqueId = 0;\n\t\t\tsvg.UniqueId = function () {\n\t\t\t\tuniqueId++;return 'canvg' + uniqueId;\n\t\t\t};\n\t\t\tsvg.Definitions = {};\n\t\t\tsvg.Styles = {};\n\t\t\tsvg.StylesSpecificity = {};\n\t\t\tsvg.Animations = [];\n\t\t\tsvg.Images = [];\n\t\t\tsvg.ctx = ctx;\n\t\t\tsvg.ViewPort = new function () {\n\t\t\t\tthis.viewPorts = [];\n\t\t\t\tthis.Clear = function () {\n\t\t\t\t\tthis.viewPorts = [];\n\t\t\t\t};\n\t\t\t\tthis.SetCurrent = function (width, height) {\n\t\t\t\t\tthis.viewPorts.push({ width: width, height: height });\n\t\t\t\t};\n\t\t\t\tthis.RemoveCurrent = function () {\n\t\t\t\t\tthis.viewPorts.pop();\n\t\t\t\t};\n\t\t\t\tthis.Current = function () {\n\t\t\t\t\treturn this.viewPorts[this.viewPorts.length - 1];\n\t\t\t\t};\n\t\t\t\tthis.width = function () {\n\t\t\t\t\treturn this.Current().width;\n\t\t\t\t};\n\t\t\t\tthis.height = function () {\n\t\t\t\t\treturn this.Current().height;\n\t\t\t\t};\n\t\t\t\tthis.ComputeSize = function (d) {\n\t\t\t\t\tif (d != null && typeof d == 'number') return d;\n\t\t\t\t\tif (d == 'x') return this.width();\n\t\t\t\t\tif (d == 'y') return this.height();\n\t\t\t\t\treturn Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2);\n\t\t\t\t};\n\t\t\t}();\n\t\t};\n\t\tsvg.init();\n\n\t\t// images loaded\n\t\tsvg.ImagesLoaded = function () {\n\t\t\tfor (var i = 0; i < svg.Images.length; i++) {\n\t\t\t\tif (!svg.Images[i].loaded) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\n\t\t// trim\n\t\tsvg.trim = function (s) {\n\t\t\treturn s.replace(/^\\s+|\\s+$/g, '');\n\t\t};\n\n\t\t// compress spaces\n\t\tsvg.compressSpaces = function (s) {\n\t\t\treturn s.replace(/[\\s\\r\\t\\n]+/gm, ' ');\n\t\t};\n\n\t\t// ajax\n\t\tsvg.ajax = function (url) {\n\t\t\tvar AJAX;\n\t\t\tif (window.XMLHttpRequest) {\n\t\t\t\tAJAX = new XMLHttpRequest();\n\t\t\t} else {\n\t\t\t\tAJAX = new ActiveXObject('Microsoft.XMLHTTP');\n\t\t\t}\n\t\t\tif (AJAX) {\n\t\t\t\tAJAX.open('GET', url, false);\n\t\t\t\tAJAX.send(null);\n\t\t\t\treturn AJAX.responseText;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\n\t\t// parse xml\n\t\tsvg.parseXml = function (xml) {\n\t\t\tif (typeof Windows != 'undefined' && typeof Windows.Data != 'undefined' && typeof Windows.Data.Xml != 'undefined') {\n\t\t\t\tvar xmlDoc = new Windows.Data.Xml.Dom.XmlDocument();\n\t\t\t\tvar settings = new Windows.Data.Xml.Dom.XmlLoadSettings();\n\t\t\t\tsettings.prohibitDtd = false;\n\t\t\t\txmlDoc.loadXml(xml, settings);\n\t\t\t\treturn xmlDoc;\n\t\t\t} else if (window.DOMParser) {\n\t\t\t\tvar parser = new DOMParser();\n\t\t\t\treturn parser.parseFromString(xml, 'text/xml');\n\t\t\t} else {\n\t\t\t\txml = xml.replace(/<!DOCTYPE svg[^>]*>/, '');\n\t\t\t\tvar xmlDoc = new ActiveXObject('Microsoft.XMLDOM');\n\t\t\t\txmlDoc.async = 'false';\n\t\t\t\txmlDoc.loadXML(xml);\n\t\t\t\treturn xmlDoc;\n\t\t\t}\n\t\t};\n\n\t\tsvg.Property = function (name, value) {\n\t\t\tthis.name = name;\n\t\t\tthis.value = value;\n\t\t};\n\t\tsvg.Property.prototype.getValue = function () {\n\t\t\treturn this.value;\n\t\t};\n\n\t\tsvg.Property.prototype.hasValue = function () {\n\t\t\treturn this.value != null && this.value !== '';\n\t\t};\n\n\t\t// return the numerical value of the property\n\t\tsvg.Property.prototype.numValue = function () {\n\t\t\tif (!this.hasValue()) return 0;\n\n\t\t\tvar n = parseFloat(this.value);\n\t\t\tif ((this.value + '').match(/%$/)) {\n\t\t\t\tn = n / 100.0;\n\t\t\t}\n\t\t\treturn n;\n\t\t};\n\n\t\tsvg.Property.prototype.valueOrDefault = function (def) {\n\t\t\tif (this.hasValue()) return this.value;\n\t\t\treturn def;\n\t\t};\n\n\t\tsvg.Property.prototype.numValueOrDefault = function (def) {\n\t\t\tif (this.hasValue()) return this.numValue();\n\t\t\treturn def;\n\t\t};\n\n\t\t// color extensions\n\t\t// augment the current color value with the opacity\n\t\tsvg.Property.prototype.addOpacity = function (opacityProp) {\n\t\t\tvar newValue = this.value;\n\t\t\tif (opacityProp.value != null && opacityProp.value != '' && typeof this.value == 'string') {\n\t\t\t\t// can only add opacity to colors, not patterns\n\t\t\t\tvar color = new RGBColor(this.value);\n\t\t\t\tif (color.ok) {\n\t\t\t\t\tnewValue = 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + opacityProp.numValue() + ')';\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new svg.Property(this.name, newValue);\n\t\t};\n\n\t\t// definition extensions\n\t\t// get the definition from the definitions table\n\t\tsvg.Property.prototype.getDefinition = function () {\n\t\t\tvar name = this.value.match(/#([^\\)'\"]+)/);\n\t\t\tif (name) {\n\t\t\t\tname = name[1];\n\t\t\t}\n\t\t\tif (!name) {\n\t\t\t\tname = this.value;\n\t\t\t}\n\t\t\treturn svg.Definitions[name];\n\t\t};\n\n\t\tsvg.Property.prototype.isUrlDefinition = function () {\n\t\t\treturn this.value.indexOf('url(') == 0;\n\t\t};\n\n\t\tsvg.Property.prototype.getFillStyleDefinition = function (e, opacityProp) {\n\t\t\tvar def = this.getDefinition();\n\n\t\t\t// gradient\n\t\t\tif (def != null && def.createGradient) {\n\t\t\t\treturn def.createGradient(svg.ctx, e, opacityProp);\n\t\t\t}\n\n\t\t\t// pattern\n\t\t\tif (def != null && def.createPattern) {\n\t\t\t\tif (def.getHrefAttribute().hasValue()) {\n\t\t\t\t\tvar pt = def.attribute('patternTransform');\n\t\t\t\t\tdef = def.getHrefAttribute().getDefinition();\n\t\t\t\t\tif (pt.hasValue()) {\n\t\t\t\t\t\tdef.attribute('patternTransform', true).value = pt.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn def.createPattern(svg.ctx, e);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\t// length extensions\n\t\tsvg.Property.prototype.getDPI = function (viewPort) {\n\t\t\treturn 96.0; // TODO: compute?\n\t\t};\n\n\t\tsvg.Property.prototype.getEM = function (viewPort) {\n\t\t\tvar em = 12;\n\n\t\t\tvar fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);\n\t\t\tif (fontSize.hasValue()) em = fontSize.toPixels(viewPort);\n\n\t\t\treturn em;\n\t\t};\n\n\t\tsvg.Property.prototype.getUnits = function () {\n\t\t\tvar s = this.value + '';\n\t\t\treturn s.replace(/[0-9\\.\\-]/g, '');\n\t\t};\n\n\t\t// get the length as pixels\n\t\tsvg.Property.prototype.toPixels = function (viewPort, processPercent) {\n\t\t\tif (!this.hasValue()) return 0;\n\t\t\tvar s = this.value + '';\n\t\t\tif (s.match(/em$/)) return this.numValue() * this.getEM(viewPort);\n\t\t\tif (s.match(/ex$/)) return this.numValue() * this.getEM(viewPort) / 2.0;\n\t\t\tif (s.match(/px$/)) return this.numValue();\n\t\t\tif (s.match(/pt$/)) return this.numValue() * this.getDPI(viewPort) * (1.0 / 72.0);\n\t\t\tif (s.match(/pc$/)) return this.numValue() * 15;\n\t\t\tif (s.match(/cm$/)) return this.numValue() * this.getDPI(viewPort) / 2.54;\n\t\t\tif (s.match(/mm$/)) return this.numValue() * this.getDPI(viewPort) / 25.4;\n\t\t\tif (s.match(/in$/)) return this.numValue() * this.getDPI(viewPort);\n\t\t\tif (s.match(/%$/)) return this.numValue() * svg.ViewPort.ComputeSize(viewPort);\n\t\t\tvar n = this.numValue();\n\t\t\tif (processPercent && n < 1.0) return n * svg.ViewPort.ComputeSize(viewPort);\n\t\t\treturn n;\n\t\t};\n\n\t\t// time extensions\n\t\t// get the time as milliseconds\n\t\tsvg.Property.prototype.toMilliseconds = function () {\n\t\t\tif (!this.hasValue()) return 0;\n\t\t\tvar s = this.value + '';\n\t\t\tif (s.match(/s$/)) return this.numValue() * 1000;\n\t\t\tif (s.match(/ms$/)) return this.numValue();\n\t\t\treturn this.numValue();\n\t\t};\n\n\t\t// angle extensions\n\t\t// get the angle as radians\n\t\tsvg.Property.prototype.toRadians = function () {\n\t\t\tif (!this.hasValue()) return 0;\n\t\t\tvar s = this.value + '';\n\t\t\tif (s.match(/deg$/)) return this.numValue() * (Math.PI / 180.0);\n\t\t\tif (s.match(/grad$/)) return this.numValue() * (Math.PI / 200.0);\n\t\t\tif (s.match(/rad$/)) return this.numValue();\n\t\t\treturn this.numValue() * (Math.PI / 180.0);\n\t\t};\n\n\t\t// text extensions\n\t\t// get the text baseline\n\t\tvar textBaselineMapping = {\n\t\t\t'baseline': 'alphabetic',\n\t\t\t'before-edge': 'top',\n\t\t\t'text-before-edge': 'top',\n\t\t\t'middle': 'middle',\n\t\t\t'central': 'middle',\n\t\t\t'after-edge': 'bottom',\n\t\t\t'text-after-edge': 'bottom',\n\t\t\t'ideographic': 'ideographic',\n\t\t\t'alphabetic': 'alphabetic',\n\t\t\t'hanging': 'hanging',\n\t\t\t'mathematical': 'alphabetic'\n\t\t};\n\t\tsvg.Property.prototype.toTextBaseline = function () {\n\t\t\tif (!this.hasValue()) return null;\n\t\t\treturn textBaselineMapping[this.value];\n\t\t};\n\n\t\t// fonts\n\t\tsvg.Font = new function () {\n\t\t\tthis.Styles = 'normal|italic|oblique|inherit';\n\t\t\tthis.Variants = 'normal|small-caps|inherit';\n\t\t\tthis.Weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';\n\n\t\t\tthis.CreateFont = function (fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {\n\t\t\t\tvar f = inherit != null ? this.Parse(inherit) : this.CreateFont('', '', '', '', '', svg.ctx.font);\n\t\t\t\treturn {\n\t\t\t\t\tfontFamily: fontFamily || f.fontFamily,\n\t\t\t\t\tfontSize: fontSize || f.fontSize,\n\t\t\t\t\tfontStyle: fontStyle || f.fontStyle,\n\t\t\t\t\tfontWeight: fontWeight || f.fontWeight,\n\t\t\t\t\tfontVariant: fontVariant || f.fontVariant,\n\t\t\t\t\ttoString: function toString() {\n\t\t\t\t\t\treturn [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(' ');\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tvar that = this;\n\t\t\tthis.Parse = function (s) {\n\t\t\t\tvar f = {};\n\t\t\t\tvar d = svg.trim(svg.compressSpaces(s || '')).split(' ');\n\t\t\t\tvar set = { fontSize: false, fontStyle: false, fontWeight: false, fontVariant: false };\n\t\t\t\tvar ff = '';\n\t\t\t\tfor (var i = 0; i < d.length; i++) {\n\t\t\t\t\tif (!set.fontStyle && that.Styles.indexOf(d[i]) != -1) {\n\t\t\t\t\t\tif (d[i] != 'inherit') f.fontStyle = d[i];set.fontStyle = true;\n\t\t\t\t\t} else if (!set.fontVariant && that.Variants.indexOf(d[i]) != -1) {\n\t\t\t\t\t\tif (d[i] != 'inherit') f.fontVariant = d[i];set.fontStyle = set.fontVariant = true;\n\t\t\t\t\t} else if (!set.fontWeight && that.Weights.indexOf(d[i]) != -1) {\n\t\t\t\t\t\tif (d[i] != 'inherit') f.fontWeight = d[i];set.fontStyle = set.fontVariant = set.fontWeight = true;\n\t\t\t\t\t} else if (!set.fontSize) {\n\t\t\t\t\t\tif (d[i] != 'inherit') f.fontSize = d[i].split('/')[0];set.fontStyle = set.fontVariant = set.fontWeight = set.fontSize = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (d[i] != 'inherit') ff += d[i];\n\t\t\t\t\t}\n\t\t\t\t}if (ff != '') f.fontFamily = ff;\n\t\t\t\treturn f;\n\t\t\t};\n\t\t}();\n\n\t\t// points and paths\n\t\tsvg.ToNumberArray = function (s) {\n\t\t\tvar a = svg.trim(svg.compressSpaces((s || '').replace(/,/g, ' '))).split(' ');\n\t\t\tfor (var i = 0; i < a.length; i++) {\n\t\t\t\ta[i] = parseFloat(a[i]);\n\t\t\t}\n\t\t\treturn a;\n\t\t};\n\t\tsvg.Point = function (x, y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t};\n\t\tsvg.Point.prototype.angleTo = function (p) {\n\t\t\treturn Math.atan2(p.y - this.y, p.x - this.x);\n\t\t};\n\n\t\tsvg.Point.prototype.applyTransform = function (v) {\n\t\t\tvar xp = this.x * v[0] + this.y * v[2] + v[4];\n\t\t\tvar yp = this.x * v[1] + this.y * v[3] + v[5];\n\t\t\tthis.x = xp;\n\t\t\tthis.y = yp;\n\t\t};\n\n\t\tsvg.CreatePoint = function (s) {\n\t\t\tvar a = svg.ToNumberArray(s);\n\t\t\treturn new svg.Point(a[0], a[1]);\n\t\t};\n\t\tsvg.CreatePath = function (s) {\n\t\t\tvar a = svg.ToNumberArray(s);\n\t\t\tvar path = [];\n\t\t\tfor (var i = 0; i < a.length; i += 2) {\n\t\t\t\tpath.push(new svg.Point(a[i], a[i + 1]));\n\t\t\t}\n\t\t\treturn path;\n\t\t};\n\n\t\t// bounding box\n\t\tsvg.BoundingBox = function (x1, y1, x2, y2) {\n\t\t\t// pass in initial points if you want\n\t\t\tthis.x1 = Number.NaN;\n\t\t\tthis.y1 = Number.NaN;\n\t\t\tthis.x2 = Number.NaN;\n\t\t\tthis.y2 = Number.NaN;\n\n\t\t\tthis.x = function () {\n\t\t\t\treturn this.x1;\n\t\t\t};\n\t\t\tthis.y = function () {\n\t\t\t\treturn this.y1;\n\t\t\t};\n\t\t\tthis.width = function () {\n\t\t\t\treturn this.x2 - this.x1;\n\t\t\t};\n\t\t\tthis.height = function () {\n\t\t\t\treturn this.y2 - this.y1;\n\t\t\t};\n\n\t\t\tthis.addPoint = function (x, y) {\n\t\t\t\tif (x != null) {\n\t\t\t\t\tif (isNaN(this.x1) || isNaN(this.x2)) {\n\t\t\t\t\t\tthis.x1 = x;\n\t\t\t\t\t\tthis.x2 = x;\n\t\t\t\t\t}\n\t\t\t\t\tif (x < this.x1) this.x1 = x;\n\t\t\t\t\tif (x > this.x2) this.x2 = x;\n\t\t\t\t}\n\n\t\t\t\tif (y != null) {\n\t\t\t\t\tif (isNaN(this.y1) || isNaN(this.y2)) {\n\t\t\t\t\t\tthis.y1 = y;\n\t\t\t\t\t\tthis.y2 = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (y < this.y1) this.y1 = y;\n\t\t\t\t\tif (y > this.y2) this.y2 = y;\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.addX = function (x) {\n\t\t\t\tthis.addPoint(x, null);\n\t\t\t};\n\t\t\tthis.addY = function (y) {\n\t\t\t\tthis.addPoint(null, y);\n\t\t\t};\n\n\t\t\tthis.addBoundingBox = function (bb) {\n\t\t\t\tthis.addPoint(bb.x1, bb.y1);\n\t\t\t\tthis.addPoint(bb.x2, bb.y2);\n\t\t\t};\n\n\t\t\tthis.addQuadraticCurve = function (p0x, p0y, p1x, p1y, p2x, p2y) {\n\t\t\t\tvar cp1x = p0x + 2 / 3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)\n\t\t\t\tvar cp1y = p0y + 2 / 3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)\n\t\t\t\tvar cp2x = cp1x + 1 / 3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)\n\t\t\t\tvar cp2y = cp1y + 1 / 3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)\n\t\t\t\tthis.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);\n\t\t\t};\n\n\t\t\tthis.addBezierCurve = function (p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {\n\t\t\t\t// from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n\t\t\t\tvar p0 = [p0x, p0y],\n\t\t\t\t    p1 = [p1x, p1y],\n\t\t\t\t    p2 = [p2x, p2y],\n\t\t\t\t    p3 = [p3x, p3y];\n\t\t\t\tthis.addPoint(p0[0], p0[1]);\n\t\t\t\tthis.addPoint(p3[0], p3[1]);\n\n\t\t\t\tfor (i = 0; i <= 1; i++) {\n\t\t\t\t\tvar f = function f(t) {\n\t\t\t\t\t\treturn Math.pow(1 - t, 3) * p0[i] + 3 * Math.pow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * Math.pow(t, 2) * p2[i] + Math.pow(t, 3) * p3[i];\n\t\t\t\t\t};\n\n\t\t\t\t\tvar b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];\n\t\t\t\t\tvar a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];\n\t\t\t\t\tvar c = 3 * p1[i] - 3 * p0[i];\n\n\t\t\t\t\tif (a == 0) {\n\t\t\t\t\t\tif (b == 0) continue;\n\t\t\t\t\t\tvar t = -c / b;\n\t\t\t\t\t\tif (0 < t && t < 1) {\n\t\t\t\t\t\t\tif (i == 0) this.addX(f(t));\n\t\t\t\t\t\t\tif (i == 1) this.addY(f(t));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar b2ac = Math.pow(b, 2) - 4 * c * a;\n\t\t\t\t\tif (b2ac < 0) continue;\n\t\t\t\t\tvar t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\n\t\t\t\t\tif (0 < t1 && t1 < 1) {\n\t\t\t\t\t\tif (i == 0) this.addX(f(t1));\n\t\t\t\t\t\tif (i == 1) this.addY(f(t1));\n\t\t\t\t\t}\n\t\t\t\t\tvar t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\n\t\t\t\t\tif (0 < t2 && t2 < 1) {\n\t\t\t\t\t\tif (i == 0) this.addX(f(t2));\n\t\t\t\t\t\tif (i == 1) this.addY(f(t2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.isPointInBox = function (x, y) {\n\t\t\t\treturn this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2;\n\t\t\t};\n\n\t\t\tthis.addPoint(x1, y1);\n\t\t\tthis.addPoint(x2, y2);\n\t\t};\n\n\t\t// transforms\n\t\tsvg.Transform = function (v) {\n\t\t\tvar that = this;\n\t\t\tthis.Type = {};\n\n\t\t\t// translate\n\t\t\tthis.Type.translate = function (s) {\n\t\t\t\tthis.p = svg.CreatePoint(s);\n\t\t\t\tthis.apply = function (ctx) {\n\t\t\t\t\tctx.translate(this.p.x || 0.0, this.p.y || 0.0);\n\t\t\t\t};\n\t\t\t\tthis.unapply = function (ctx) {\n\t\t\t\t\tctx.translate(-1.0 * this.p.x || 0.0, -1.0 * this.p.y || 0.0);\n\t\t\t\t};\n\t\t\t\tthis.applyToPoint = function (p) {\n\t\t\t\t\tp.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t// rotate\n\t\t\tthis.Type.rotate = function (s) {\n\t\t\t\tvar a = svg.ToNumberArray(s);\n\t\t\t\tthis.angle = new svg.Property('angle', a[0]);\n\t\t\t\tthis.cx = a[1] || 0;\n\t\t\t\tthis.cy = a[2] || 0;\n\t\t\t\tthis.apply = function (ctx) {\n\t\t\t\t\tctx.translate(this.cx, this.cy);\n\t\t\t\t\tctx.rotate(this.angle.toRadians());\n\t\t\t\t\tctx.translate(-this.cx, -this.cy);\n\t\t\t\t};\n\t\t\t\tthis.unapply = function (ctx) {\n\t\t\t\t\tctx.translate(this.cx, this.cy);\n\t\t\t\t\tctx.rotate(-1.0 * this.angle.toRadians());\n\t\t\t\t\tctx.translate(-this.cx, -this.cy);\n\t\t\t\t};\n\t\t\t\tthis.applyToPoint = function (p) {\n\t\t\t\t\tvar a = this.angle.toRadians();\n\t\t\t\t\tp.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);\n\t\t\t\t\tp.applyTransform([Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]);\n\t\t\t\t\tp.applyTransform([1, 0, 0, 1, -this.p.x || 0.0, -this.p.y || 0.0]);\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tthis.Type.scale = function (s) {\n\t\t\t\tthis.p = svg.CreatePoint(s);\n\t\t\t\tthis.apply = function (ctx) {\n\t\t\t\t\tctx.scale(this.p.x || 1.0, this.p.y || this.p.x || 1.0);\n\t\t\t\t};\n\t\t\t\tthis.unapply = function (ctx) {\n\t\t\t\t\tctx.scale(1.0 / this.p.x || 1.0, 1.0 / this.p.y || this.p.x || 1.0);\n\t\t\t\t};\n\t\t\t\tthis.applyToPoint = function (p) {\n\t\t\t\t\tp.applyTransform([this.p.x || 0.0, 0, 0, this.p.y || 0.0, 0, 0]);\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tthis.Type.matrix = function (s) {\n\t\t\t\tthis.m = svg.ToNumberArray(s);\n\t\t\t\tthis.apply = function (ctx) {\n\t\t\t\t\tctx.transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5]);\n\t\t\t\t};\n\t\t\t\tthis.unapply = function (ctx) {\n\t\t\t\t\tvar a = this.m[0];\n\t\t\t\t\tvar b = this.m[2];\n\t\t\t\t\tvar c = this.m[4];\n\t\t\t\t\tvar d = this.m[1];\n\t\t\t\t\tvar e = this.m[3];\n\t\t\t\t\tvar f = this.m[5];\n\t\t\t\t\tvar g = 0.0;\n\t\t\t\t\tvar h = 0.0;\n\t\t\t\t\tvar i = 1.0;\n\t\t\t\t\tvar det = 1 / (a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g));\n\t\t\t\t\tctx.transform(det * (e * i - f * h), det * (f * g - d * i), det * (c * h - b * i), det * (a * i - c * g), det * (b * f - c * e), det * (c * d - a * f));\n\t\t\t\t};\n\t\t\t\tthis.applyToPoint = function (p) {\n\t\t\t\t\tp.applyTransform(this.m);\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tthis.Type.SkewBase = function (s) {\n\t\t\t\tthis.base = that.Type.matrix;\n\t\t\t\tthis.base(s);\n\t\t\t\tthis.angle = new svg.Property('angle', s);\n\t\t\t};\n\t\t\tthis.Type.SkewBase.prototype = new this.Type.matrix();\n\n\t\t\tthis.Type.skewX = function (s) {\n\t\t\t\tthis.base = that.Type.SkewBase;\n\t\t\t\tthis.base(s);\n\t\t\t\tthis.m = [1, 0, Math.tan(this.angle.toRadians()), 1, 0, 0];\n\t\t\t};\n\t\t\tthis.Type.skewX.prototype = new this.Type.SkewBase();\n\n\t\t\tthis.Type.skewY = function (s) {\n\t\t\t\tthis.base = that.Type.SkewBase;\n\t\t\t\tthis.base(s);\n\t\t\t\tthis.m = [1, Math.tan(this.angle.toRadians()), 0, 1, 0, 0];\n\t\t\t};\n\t\t\tthis.Type.skewY.prototype = new this.Type.SkewBase();\n\n\t\t\tthis.transforms = [];\n\n\t\t\tthis.apply = function (ctx) {\n\t\t\t\tfor (var i = 0; i < this.transforms.length; i++) {\n\t\t\t\t\tthis.transforms[i].apply(ctx);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.unapply = function (ctx) {\n\t\t\t\tfor (var i = this.transforms.length - 1; i >= 0; i--) {\n\t\t\t\t\tthis.transforms[i].unapply(ctx);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.applyToPoint = function (p) {\n\t\t\t\tfor (var i = 0; i < this.transforms.length; i++) {\n\t\t\t\t\tthis.transforms[i].applyToPoint(p);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar data = svg.trim(svg.compressSpaces(v)).replace(/\\)([a-zA-Z])/g, ') $1').replace(/\\)(\\s?,\\s?)/g, ') ').split(/\\s(?=[a-z])/);\n\t\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\t\tvar type = svg.trim(data[i].split('(')[0]);\n\t\t\t\tvar s = data[i].split('(')[1].replace(')', '');\n\t\t\t\tvar transform = new this.Type[type](s);\n\t\t\t\ttransform.type = type;\n\t\t\t\tthis.transforms.push(transform);\n\t\t\t}\n\t\t};\n\n\t\t// aspect ratio\n\t\tsvg.AspectRatio = function (ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX, minY, refX, refY) {\n\t\t\t// aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute\n\t\t\taspectRatio = svg.compressSpaces(aspectRatio);\n\t\t\taspectRatio = aspectRatio.replace(/^defer\\s/, ''); // ignore defer\n\t\t\tvar align = aspectRatio.split(' ')[0] || 'xMidYMid';\n\t\t\tvar meetOrSlice = aspectRatio.split(' ')[1] || 'meet';\n\n\t\t\t// calculate scale\n\t\t\tvar scaleX = width / desiredWidth;\n\t\t\tvar scaleY = height / desiredHeight;\n\t\t\tvar scaleMin = Math.min(scaleX, scaleY);\n\t\t\tvar scaleMax = Math.max(scaleX, scaleY);\n\t\t\tif (meetOrSlice == 'meet') {\n\t\t\t\tdesiredWidth *= scaleMin;desiredHeight *= scaleMin;\n\t\t\t}\n\t\t\tif (meetOrSlice == 'slice') {\n\t\t\t\tdesiredWidth *= scaleMax;desiredHeight *= scaleMax;\n\t\t\t}\n\n\t\t\trefX = new svg.Property('refX', refX);\n\t\t\trefY = new svg.Property('refY', refY);\n\t\t\tif (refX.hasValue() && refY.hasValue()) {\n\t\t\t\tctx.translate(-scaleMin * refX.toPixels('x'), -scaleMin * refY.toPixels('y'));\n\t\t\t} else {\n\t\t\t\t// align\n\t\t\t\tif (align.match(/^xMid/) && (meetOrSlice == 'meet' && scaleMin == scaleY || meetOrSlice == 'slice' && scaleMax == scaleY)) ctx.translate(width / 2.0 - desiredWidth / 2.0, 0);\n\t\t\t\tif (align.match(/YMid$/) && (meetOrSlice == 'meet' && scaleMin == scaleX || meetOrSlice == 'slice' && scaleMax == scaleX)) ctx.translate(0, height / 2.0 - desiredHeight / 2.0);\n\t\t\t\tif (align.match(/^xMax/) && (meetOrSlice == 'meet' && scaleMin == scaleY || meetOrSlice == 'slice' && scaleMax == scaleY)) ctx.translate(width - desiredWidth, 0);\n\t\t\t\tif (align.match(/YMax$/) && (meetOrSlice == 'meet' && scaleMin == scaleX || meetOrSlice == 'slice' && scaleMax == scaleX)) ctx.translate(0, height - desiredHeight);\n\t\t\t}\n\n\t\t\t// scale\n\t\t\tif (align == 'none') ctx.scale(scaleX, scaleY);else if (meetOrSlice == 'meet') ctx.scale(scaleMin, scaleMin);else if (meetOrSlice == 'slice') ctx.scale(scaleMax, scaleMax);\n\n\t\t\t// translate\n\t\t\tctx.translate(minX == null ? 0 : -minX, minY == null ? 0 : -minY);\n\t\t};\n\n\t\t// elements\n\t\tsvg.Element = {};\n\n\t\tsvg.EmptyProperty = new svg.Property('EMPTY', '');\n\n\t\tsvg.Element.ElementBase = function (node) {\n\t\t\tthis.attributes = {};\n\t\t\tthis.styles = {};\n\t\t\tthis.stylesSpecificity = {};\n\t\t\tthis.children = [];\n\n\t\t\t// get or create attribute\n\t\t\tthis.attribute = function (name, createIfNotExists) {\n\t\t\t\tvar a = this.attributes[name];\n\t\t\t\tif (a != null) return a;\n\n\t\t\t\tif (createIfNotExists == true) {\n\t\t\t\t\ta = new svg.Property(name, '');this.attributes[name] = a;\n\t\t\t\t}\n\t\t\t\treturn a || svg.EmptyProperty;\n\t\t\t};\n\n\t\t\tthis.getHrefAttribute = function () {\n\t\t\t\tfor (var a in this.attributes) {\n\t\t\t\t\tif (a == 'href' || a.match(/:href$/)) {\n\t\t\t\t\t\treturn this.attributes[a];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn svg.EmptyProperty;\n\t\t\t};\n\n\t\t\t// get or create style, crawls up node tree\n\t\t\tthis.style = function (name, createIfNotExists, skipAncestors) {\n\t\t\t\tvar s = this.styles[name];\n\t\t\t\tif (s != null) return s;\n\n\t\t\t\tvar a = this.attribute(name);\n\t\t\t\tif (a != null && a.hasValue()) {\n\t\t\t\t\tthis.styles[name] = a; // move up to me to cache\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\n\t\t\t\tif (skipAncestors != true) {\n\t\t\t\t\tvar p = this.parent;\n\t\t\t\t\tif (p != null) {\n\t\t\t\t\t\tvar ps = p.style(name);\n\t\t\t\t\t\tif (ps != null && ps.hasValue()) {\n\t\t\t\t\t\t\treturn ps;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (createIfNotExists == true) {\n\t\t\t\t\ts = new svg.Property(name, '');this.styles[name] = s;\n\t\t\t\t}\n\t\t\t\treturn s || svg.EmptyProperty;\n\t\t\t};\n\n\t\t\t// base render\n\t\t\tthis.render = function (ctx) {\n\t\t\t\t// don't render display=none\n\t\t\t\tif (this.style('display').value == 'none') return;\n\n\t\t\t\t// don't render visibility=hidden\n\t\t\t\tif (this.style('visibility').value == 'hidden') return;\n\n\t\t\t\tctx.save();\n\t\t\t\tif (this.attribute('mask').hasValue()) {\n\t\t\t\t\t// mask\n\t\t\t\t\tvar mask = this.attribute('mask').getDefinition();\n\t\t\t\t\tif (mask != null) mask.apply(ctx, this);\n\t\t\t\t} else if (this.style('filter').hasValue()) {\n\t\t\t\t\t// filter\n\t\t\t\t\tvar filter = this.style('filter').getDefinition();\n\t\t\t\t\tif (filter != null) filter.apply(ctx, this);\n\t\t\t\t} else {\n\t\t\t\t\tthis.setContext(ctx);\n\t\t\t\t\tthis.renderChildren(ctx);\n\t\t\t\t\tthis.clearContext(ctx);\n\t\t\t\t}\n\t\t\t\tctx.restore();\n\t\t\t};\n\n\t\t\t// base set context\n\t\t\tthis.setContext = function (ctx) {}\n\t\t\t// OVERRIDE ME!\n\n\n\t\t\t// base clear context\n\t\t\t;this.clearContext = function (ctx) {}\n\t\t\t// OVERRIDE ME!\n\n\n\t\t\t// base render children\n\t\t\t;this.renderChildren = function (ctx) {\n\t\t\t\tfor (var i = 0; i < this.children.length; i++) {\n\t\t\t\t\tthis.children[i].render(ctx);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.addChild = function (childNode, create) {\n\t\t\t\tvar child = childNode;\n\t\t\t\tif (create) child = svg.CreateElement(childNode);\n\t\t\t\tchild.parent = this;\n\t\t\t\tif (child.type != 'title') {\n\t\t\t\t\tthis.children.push(child);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.addStylesFromStyleDefinition = function () {\n\t\t\t\t// add styles\n\t\t\t\tfor (var selector in svg.Styles) {\n\t\t\t\t\tif (selector[0] != '@' && matchesSelector(node, selector)) {\n\t\t\t\t\t\tvar styles = svg.Styles[selector];\n\t\t\t\t\t\tvar specificity = svg.StylesSpecificity[selector];\n\t\t\t\t\t\tif (styles != null) {\n\t\t\t\t\t\t\tfor (var name in styles) {\n\t\t\t\t\t\t\t\tvar existingSpecificity = this.stylesSpecificity[name];\n\t\t\t\t\t\t\t\tif (typeof existingSpecificity == 'undefined') {\n\t\t\t\t\t\t\t\t\texistingSpecificity = '000';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (specificity > existingSpecificity) {\n\t\t\t\t\t\t\t\t\tthis.styles[name] = styles[name];\n\t\t\t\t\t\t\t\t\tthis.stylesSpecificity[name] = specificity;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (node != null && node.nodeType == 1) {\n\t\t\t\t//ELEMENT_NODE\n\t\t\t\t// add attributes\n\t\t\t\tfor (var i = 0; i < node.attributes.length; i++) {\n\t\t\t\t\tvar attribute = node.attributes[i];\n\t\t\t\t\tthis.attributes[attribute.nodeName] = new svg.Property(attribute.nodeName, attribute.value);\n\t\t\t\t}\n\n\t\t\t\tthis.addStylesFromStyleDefinition();\n\n\t\t\t\t// add inline styles\n\t\t\t\tif (this.attribute('style').hasValue()) {\n\t\t\t\t\tvar styles = this.attribute('style').value.split(';');\n\t\t\t\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\t\t\t\tif (svg.trim(styles[i]) != '') {\n\t\t\t\t\t\t\tvar style = styles[i].split(':');\n\t\t\t\t\t\t\tvar name = svg.trim(style[0]);\n\t\t\t\t\t\t\tvar value = svg.trim(style[1]);\n\t\t\t\t\t\t\tthis.styles[name] = new svg.Property(name, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// add id\n\t\t\t\tif (this.attribute('id').hasValue()) {\n\t\t\t\t\tif (svg.Definitions[this.attribute('id').value] == null) {\n\t\t\t\t\t\tsvg.Definitions[this.attribute('id').value] = this;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// add children\n\t\t\t\tfor (var i = 0; i < node.childNodes.length; i++) {\n\t\t\t\t\tvar childNode = node.childNodes[i];\n\t\t\t\t\tif (childNode.nodeType == 1) this.addChild(childNode, true); //ELEMENT_NODE\n\t\t\t\t\tif (this.captureTextNodes && (childNode.nodeType == 3 || childNode.nodeType == 4)) {\n\t\t\t\t\t\tvar text = childNode.value || childNode.text || childNode.textContent || '';\n\t\t\t\t\t\tif (svg.compressSpaces(text) != '') {\n\t\t\t\t\t\t\tthis.addChild(new svg.Element.tspan(childNode), false); // TEXT_NODE\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tsvg.Element.RenderedElementBase = function (node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.setContext = function (ctx) {\n\t\t\t\t// fill\n\t\t\t\tif (this.style('fill').isUrlDefinition()) {\n\t\t\t\t\tvar fs = this.style('fill').getFillStyleDefinition(this, this.style('fill-opacity'));\n\t\t\t\t\tif (fs != null) ctx.fillStyle = fs;\n\t\t\t\t} else if (this.style('fill').hasValue()) {\n\t\t\t\t\tvar fillStyle = this.style('fill');\n\t\t\t\t\tif (fillStyle.value == 'currentColor') fillStyle.value = this.style('color').value;\n\t\t\t\t\tif (fillStyle.value != 'inherit') ctx.fillStyle = fillStyle.value == 'none' ? 'rgba(0,0,0,0)' : fillStyle.value;\n\t\t\t\t}\n\t\t\t\tif (this.style('fill-opacity').hasValue()) {\n\t\t\t\t\tvar fillStyle = new svg.Property('fill', ctx.fillStyle);\n\t\t\t\t\tfillStyle = fillStyle.addOpacity(this.style('fill-opacity'));\n\t\t\t\t\tctx.fillStyle = fillStyle.value;\n\t\t\t\t}\n\n\t\t\t\t// stroke\n\t\t\t\tif (this.style('stroke').isUrlDefinition()) {\n\t\t\t\t\tvar fs = this.style('stroke').getFillStyleDefinition(this, this.style('stroke-opacity'));\n\t\t\t\t\tif (fs != null) ctx.strokeStyle = fs;\n\t\t\t\t} else if (this.style('stroke').hasValue()) {\n\t\t\t\t\tvar strokeStyle = this.style('stroke');\n\t\t\t\t\tif (strokeStyle.value == 'currentColor') strokeStyle.value = this.style('color').value;\n\t\t\t\t\tif (strokeStyle.value != 'inherit') ctx.strokeStyle = strokeStyle.value == 'none' ? 'rgba(0,0,0,0)' : strokeStyle.value;\n\t\t\t\t}\n\t\t\t\tif (this.style('stroke-opacity').hasValue()) {\n\t\t\t\t\tvar strokeStyle = new svg.Property('stroke', ctx.strokeStyle);\n\t\t\t\t\tstrokeStyle = strokeStyle.addOpacity(this.style('stroke-opacity'));\n\t\t\t\t\tctx.strokeStyle = strokeStyle.value;\n\t\t\t\t}\n\t\t\t\tif (this.style('stroke-width').hasValue()) {\n\t\t\t\t\tvar newLineWidth = this.style('stroke-width').toPixels();\n\t\t\t\t\tctx.lineWidth = newLineWidth == 0 ? 0.001 : newLineWidth; // browsers don't respect 0\n\t\t\t\t}\n\t\t\t\tif (this.style('stroke-linecap').hasValue()) ctx.lineCap = this.style('stroke-linecap').value;\n\t\t\t\tif (this.style('stroke-linejoin').hasValue()) ctx.lineJoin = this.style('stroke-linejoin').value;\n\t\t\t\tif (this.style('stroke-miterlimit').hasValue()) ctx.miterLimit = this.style('stroke-miterlimit').value;\n\t\t\t\tif (this.style('stroke-dasharray').hasValue() && this.style('stroke-dasharray').value != 'none') {\n\t\t\t\t\tvar gaps = svg.ToNumberArray(this.style('stroke-dasharray').value);\n\t\t\t\t\tif (typeof ctx.setLineDash != 'undefined') {\n\t\t\t\t\t\tctx.setLineDash(gaps);\n\t\t\t\t\t} else if (typeof ctx.webkitLineDash != 'undefined') {\n\t\t\t\t\t\tctx.webkitLineDash = gaps;\n\t\t\t\t\t} else if (typeof ctx.mozDash != 'undefined' && !(gaps.length == 1 && gaps[0] == 0)) {\n\t\t\t\t\t\tctx.mozDash = gaps;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar offset = this.style('stroke-dashoffset').numValueOrDefault(1);\n\t\t\t\t\tif (typeof ctx.lineDashOffset != 'undefined') {\n\t\t\t\t\t\tctx.lineDashOffset = offset;\n\t\t\t\t\t} else if (typeof ctx.webkitLineDashOffset != 'undefined') {\n\t\t\t\t\t\tctx.webkitLineDashOffset = offset;\n\t\t\t\t\t} else if (typeof ctx.mozDashOffset != 'undefined') {\n\t\t\t\t\t\tctx.mozDashOffset = offset;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// font\n\t\t\t\tif (typeof ctx.font != 'undefined') {\n\t\t\t\t\tctx.font = svg.Font.CreateFont(this.style('font-style').value, this.style('font-variant').value, this.style('font-weight').value, this.style('font-size').hasValue() ? this.style('font-size').toPixels() + 'px' : '', this.style('font-family').value).toString();\n\t\t\t\t}\n\n\t\t\t\t// transform\n\t\t\t\tif (this.style('transform', false, true).hasValue()) {\n\t\t\t\t\tvar transform = new svg.Transform(this.style('transform', false, true).value);\n\t\t\t\t\ttransform.apply(ctx);\n\t\t\t\t}\n\n\t\t\t\t// clip\n\t\t\t\tif (this.attribute('clip-path', false, true).hasValue()) {\n\t\t\t\t\tvar clip = this.attribute('clip-path', false, true).getDefinition();\n\t\t\t\t\tif (clip != null) clip.apply(ctx);\n\t\t\t\t}\n\n\t\t\t\t// opacity\n\t\t\t\tif (this.style('opacity').hasValue()) {\n\t\t\t\t\tctx.globalAlpha = this.style('opacity').numValue();\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t\tsvg.Element.RenderedElementBase.prototype = new svg.Element.ElementBase();\n\n\t\tsvg.Element.PathElementBase = function (node) {\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.path = function (ctx) {\n\t\t\t\tif (ctx != null) ctx.beginPath();\n\t\t\t\treturn new svg.BoundingBox();\n\t\t\t};\n\n\t\t\tthis.renderChildren = function (ctx) {\n\t\t\t\tthis.path(ctx);\n\t\t\t\tsvg.Mouse.checkPath(this, ctx);\n\t\t\t\tif (ctx.fillStyle != '') {\n\t\t\t\t\tif (this.style('fill-rule').valueOrDefault('inherit') != 'inherit') {\n\t\t\t\t\t\tctx.fill(this.style('fill-rule').value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.fill();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ctx.strokeStyle != '') ctx.stroke();\n\n\t\t\t\tvar markers = this.getMarkers();\n\t\t\t\tif (markers != null) {\n\t\t\t\t\tif (this.style('marker-start').isUrlDefinition()) {\n\t\t\t\t\t\tvar marker = this.style('marker-start').getDefinition();\n\t\t\t\t\t\tmarker.render(ctx, markers[0][0], markers[0][1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (this.style('marker-mid').isUrlDefinition()) {\n\t\t\t\t\t\tvar marker = this.style('marker-mid').getDefinition();\n\t\t\t\t\t\tfor (var i = 1; i < markers.length - 1; i++) {\n\t\t\t\t\t\t\tmarker.render(ctx, markers[i][0], markers[i][1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this.style('marker-end').isUrlDefinition()) {\n\t\t\t\t\t\tvar marker = this.style('marker-end').getDefinition();\n\t\t\t\t\t\tmarker.render(ctx, markers[markers.length - 1][0], markers[markers.length - 1][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.getBoundingBox = function () {\n\t\t\t\treturn this.path();\n\t\t\t};\n\n\t\t\tthis.getMarkers = function () {\n\t\t\t\treturn null;\n\t\t\t};\n\t\t};\n\t\tsvg.Element.PathElementBase.prototype = new svg.Element.RenderedElementBase();\n\n\t\t// svg element\n\t\tsvg.Element.svg = function (node) {\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.baseClearContext = this.clearContext;\n\t\t\tthis.clearContext = function (ctx) {\n\t\t\t\tthis.baseClearContext(ctx);\n\t\t\t\tsvg.ViewPort.RemoveCurrent();\n\t\t\t};\n\n\t\t\tthis.baseSetContext = this.setContext;\n\t\t\tthis.setContext = function (ctx) {\n\t\t\t\t// initial values and defaults\n\t\t\t\tctx.strokeStyle = 'rgba(0,0,0,0)';\n\t\t\t\tctx.lineCap = 'butt';\n\t\t\t\tctx.lineJoin = 'miter';\n\t\t\t\tctx.miterLimit = 4;\n\t\t\t\tif (typeof ctx.font != 'undefined' && typeof window.getComputedStyle != 'undefined') {\n\t\t\t\t\tctx.font = window.getComputedStyle(ctx.canvas).getPropertyValue('font');\n\t\t\t\t}\n\n\t\t\t\tthis.baseSetContext(ctx);\n\n\t\t\t\t// create new view port\n\t\t\t\tif (!this.attribute('x').hasValue()) this.attribute('x', true).value = 0;\n\t\t\t\tif (!this.attribute('y').hasValue()) this.attribute('y', true).value = 0;\n\t\t\t\tctx.translate(this.attribute('x').toPixels('x'), this.attribute('y').toPixels('y'));\n\n\t\t\t\tvar width = svg.ViewPort.width();\n\t\t\t\tvar height = svg.ViewPort.height();\n\n\t\t\t\tif (!this.attribute('width').hasValue()) this.attribute('width', true).value = '100%';\n\t\t\t\tif (!this.attribute('height').hasValue()) this.attribute('height', true).value = '100%';\n\t\t\t\tif (typeof this.root == 'undefined') {\n\t\t\t\t\twidth = this.attribute('width').toPixels('x');\n\t\t\t\t\theight = this.attribute('height').toPixels('y');\n\n\t\t\t\t\tvar x = 0;\n\t\t\t\t\tvar y = 0;\n\t\t\t\t\tif (this.attribute('refX').hasValue() && this.attribute('refY').hasValue()) {\n\t\t\t\t\t\tx = -this.attribute('refX').toPixels('x');\n\t\t\t\t\t\ty = -this.attribute('refY').toPixels('y');\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.attribute('overflow').valueOrDefault('hidden') != 'visible') {\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.moveTo(x, y);\n\t\t\t\t\t\tctx.lineTo(width, y);\n\t\t\t\t\t\tctx.lineTo(width, height);\n\t\t\t\t\t\tctx.lineTo(x, height);\n\t\t\t\t\t\tctx.closePath();\n\t\t\t\t\t\tctx.clip();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsvg.ViewPort.SetCurrent(width, height);\n\n\t\t\t\t// viewbox\n\t\t\t\tif (this.attribute('viewBox').hasValue()) {\n\t\t\t\t\tvar viewBox = svg.ToNumberArray(this.attribute('viewBox').value);\n\t\t\t\t\tvar minX = viewBox[0];\n\t\t\t\t\tvar minY = viewBox[1];\n\t\t\t\t\twidth = viewBox[2];\n\t\t\t\t\theight = viewBox[3];\n\n\t\t\t\t\tsvg.AspectRatio(ctx, this.attribute('preserveAspectRatio').value, svg.ViewPort.width(), width, svg.ViewPort.height(), height, minX, minY, this.attribute('refX').value, this.attribute('refY').value);\n\n\t\t\t\t\tsvg.ViewPort.RemoveCurrent();\n\t\t\t\t\tsvg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t\tsvg.Element.svg.prototype = new svg.Element.RenderedElementBase();\n\n\t\t// rect element\n\t\tsvg.Element.rect = function (node) {\n\t\t\tthis.base = svg.Element.PathElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.path = function (ctx) {\n\t\t\t\tvar x = this.attribute('x').toPixels('x');\n\t\t\t\tvar y = this.attribute('y').toPixels('y');\n\t\t\t\tvar width = this.attribute('width').toPixels('x');\n\t\t\t\tvar height = this.attribute('height').toPixels('y');\n\t\t\t\tvar rx = this.attribute('rx').toPixels('x');\n\t\t\t\tvar ry = this.attribute('ry').toPixels('y');\n\t\t\t\tif (this.attribute('rx').hasValue() && !this.attribute('ry').hasValue()) ry = rx;\n\t\t\t\tif (this.attribute('ry').hasValue() && !this.attribute('rx').hasValue()) rx = ry;\n\t\t\t\trx = Math.min(rx, width / 2.0);\n\t\t\t\try = Math.min(ry, height / 2.0);\n\t\t\t\tif (ctx != null) {\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(x + rx, y);\n\t\t\t\t\tctx.lineTo(x + width - rx, y);\n\t\t\t\t\tctx.quadraticCurveTo(x + width, y, x + width, y + ry);\n\t\t\t\t\tctx.lineTo(x + width, y + height - ry);\n\t\t\t\t\tctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height);\n\t\t\t\t\tctx.lineTo(x + rx, y + height);\n\t\t\t\t\tctx.quadraticCurveTo(x, y + height, x, y + height - ry);\n\t\t\t\t\tctx.lineTo(x, y + ry);\n\t\t\t\t\tctx.quadraticCurveTo(x, y, x + rx, y);\n\t\t\t\t\tctx.closePath();\n\t\t\t\t}\n\n\t\t\t\treturn new svg.BoundingBox(x, y, x + width, y + height);\n\t\t\t};\n\t\t};\n\t\tsvg.Element.rect.prototype = new svg.Element.PathElementBase();\n\n\t\t// circle element\n\t\tsvg.Element.circle = function (node) {\n\t\t\tthis.base = svg.Element.PathElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.path = function (ctx) {\n\t\t\t\tvar cx = this.attribute('cx').toPixels('x');\n\t\t\t\tvar cy = this.attribute('cy').toPixels('y');\n\t\t\t\tvar r = this.attribute('r').toPixels();\n\n\t\t\t\tif (ctx != null) {\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(cx, cy, r, 0, Math.PI * 2, true);\n\t\t\t\t\tctx.closePath();\n\t\t\t\t}\n\n\t\t\t\treturn new svg.BoundingBox(cx - r, cy - r, cx + r, cy + r);\n\t\t\t};\n\t\t};\n\t\tsvg.Element.circle.prototype = new svg.Element.PathElementBase();\n\n\t\t// ellipse element\n\t\tsvg.Element.ellipse = function (node) {\n\t\t\tthis.base = svg.Element.PathElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.path = function (ctx) {\n\t\t\t\tvar KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);\n\t\t\t\tvar rx = this.attribute('rx').toPixels('x');\n\t\t\t\tvar ry = this.attribute('ry').toPixels('y');\n\t\t\t\tvar cx = this.attribute('cx').toPixels('x');\n\t\t\t\tvar cy = this.attribute('cy').toPixels('y');\n\n\t\t\t\tif (ctx != null) {\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(cx, cy - ry);\n\t\t\t\t\tctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);\n\t\t\t\t\tctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);\n\t\t\t\t\tctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);\n\t\t\t\t\tctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);\n\t\t\t\t\tctx.closePath();\n\t\t\t\t}\n\n\t\t\t\treturn new svg.BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);\n\t\t\t};\n\t\t};\n\t\tsvg.Element.ellipse.prototype = new svg.Element.PathElementBase();\n\n\t\t// line element\n\t\tsvg.Element.line = function (node) {\n\t\t\tthis.base = svg.Element.PathElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.getPoints = function () {\n\t\t\t\treturn [new svg.Point(this.attribute('x1').toPixels('x'), this.attribute('y1').toPixels('y')), new svg.Point(this.attribute('x2').toPixels('x'), this.attribute('y2').toPixels('y'))];\n\t\t\t};\n\n\t\t\tthis.path = function (ctx) {\n\t\t\t\tvar points = this.getPoints();\n\n\t\t\t\tif (ctx != null) {\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(points[0].x, points[0].y);\n\t\t\t\t\tctx.lineTo(points[1].x, points[1].y);\n\t\t\t\t}\n\n\t\t\t\treturn new svg.BoundingBox(points[0].x, points[0].y, points[1].x, points[1].y);\n\t\t\t};\n\n\t\t\tthis.getMarkers = function () {\n\t\t\t\tvar points = this.getPoints();\n\t\t\t\tvar a = points[0].angleTo(points[1]);\n\t\t\t\treturn [[points[0], a], [points[1], a]];\n\t\t\t};\n\t\t};\n\t\tsvg.Element.line.prototype = new svg.Element.PathElementBase();\n\n\t\t// polyline element\n\t\tsvg.Element.polyline = function (node) {\n\t\t\tthis.base = svg.Element.PathElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.points = svg.CreatePath(this.attribute('points').value);\n\t\t\tthis.path = function (ctx) {\n\t\t\t\tvar bb = new svg.BoundingBox(this.points[0].x, this.points[0].y);\n\t\t\t\tif (ctx != null) {\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(this.points[0].x, this.points[0].y);\n\t\t\t\t}\n\t\t\t\tfor (var i = 1; i < this.points.length; i++) {\n\t\t\t\t\tbb.addPoint(this.points[i].x, this.points[i].y);\n\t\t\t\t\tif (ctx != null) ctx.lineTo(this.points[i].x, this.points[i].y);\n\t\t\t\t}\n\t\t\t\treturn bb;\n\t\t\t};\n\n\t\t\tthis.getMarkers = function () {\n\t\t\t\tvar markers = [];\n\t\t\t\tfor (var i = 0; i < this.points.length - 1; i++) {\n\t\t\t\t\tmarkers.push([this.points[i], this.points[i].angleTo(this.points[i + 1])]);\n\t\t\t\t}\n\t\t\t\tmarkers.push([this.points[this.points.length - 1], markers[markers.length - 1][1]]);\n\t\t\t\treturn markers;\n\t\t\t};\n\t\t};\n\t\tsvg.Element.polyline.prototype = new svg.Element.PathElementBase();\n\n\t\t// polygon element\n\t\tsvg.Element.polygon = function (node) {\n\t\t\tthis.base = svg.Element.polyline;\n\t\t\tthis.base(node);\n\n\t\t\tthis.basePath = this.path;\n\t\t\tthis.path = function (ctx) {\n\t\t\t\tvar bb = this.basePath(ctx);\n\t\t\t\tif (ctx != null) {\n\t\t\t\t\tctx.lineTo(this.points[0].x, this.points[0].y);\n\t\t\t\t\tctx.closePath();\n\t\t\t\t}\n\t\t\t\treturn bb;\n\t\t\t};\n\t\t};\n\t\tsvg.Element.polygon.prototype = new svg.Element.polyline();\n\n\t\t// path element\n\t\tsvg.Element.path = function (node) {\n\t\t\tthis.base = svg.Element.PathElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tvar d = this.attribute('d').value;\n\t\t\t// TODO: convert to real lexer based on http://www.w3.org/TR/SVG11/paths.html#PathDataBNF\n\t\t\td = d.replace(/,/gm, ' '); // get rid of all commas\n\t\t\t// As the end of a match can also be the start of the next match, we need to run this replace twice.\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\td = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\\s])/gm, '$1 $2');\n\t\t\t} // suffix commands with spaces\n\t\t\td = d.replace(/([^\\s])([MmZzLlHhVvCcSsQqTtAa])/gm, '$1 $2'); // prefix commands with spaces\n\t\t\td = d.replace(/([0-9])([+\\-])/gm, '$1 $2'); // separate digits on +- signs\n\t\t\t// Again, we need to run this twice to find all occurances\n\t\t\tfor (var i = 0; i < 2; i++) {\n\t\t\t\td = d.replace(/(\\.[0-9]*)(\\.)/gm, '$1 $2');\n\t\t\t} // separate digits when they start with a comma\n\t\t\td = d.replace(/([Aa](\\s+[0-9]+){3})\\s+([01])\\s*([01])/gm, '$1 $3 $4 '); // shorthand elliptical arc path syntax\n\t\t\td = svg.compressSpaces(d); // compress multiple spaces\n\t\t\td = svg.trim(d);\n\t\t\tthis.PathParser = new function (d) {\n\t\t\t\tthis.tokens = d.split(' ');\n\n\t\t\t\tthis.reset = function () {\n\t\t\t\t\tthis.i = -1;\n\t\t\t\t\tthis.command = '';\n\t\t\t\t\tthis.previousCommand = '';\n\t\t\t\t\tthis.start = new svg.Point(0, 0);\n\t\t\t\t\tthis.control = new svg.Point(0, 0);\n\t\t\t\t\tthis.current = new svg.Point(0, 0);\n\t\t\t\t\tthis.points = [];\n\t\t\t\t\tthis.angles = [];\n\t\t\t\t};\n\n\t\t\t\tthis.isEnd = function () {\n\t\t\t\t\treturn this.i >= this.tokens.length - 1;\n\t\t\t\t};\n\n\t\t\t\tthis.isCommandOrEnd = function () {\n\t\t\t\t\tif (this.isEnd()) return true;\n\t\t\t\t\treturn this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null;\n\t\t\t\t};\n\n\t\t\t\tthis.isRelativeCommand = function () {\n\t\t\t\t\tswitch (this.command) {\n\t\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tcase 's':\n\t\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tcase 't':\n\t\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tcase 'z':\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\n\t\t\t\tthis.getToken = function () {\n\t\t\t\t\tthis.i++;\n\t\t\t\t\treturn this.tokens[this.i];\n\t\t\t\t};\n\n\t\t\t\tthis.getScalar = function () {\n\t\t\t\t\treturn parseFloat(this.getToken());\n\t\t\t\t};\n\n\t\t\t\tthis.nextCommand = function () {\n\t\t\t\t\tthis.previousCommand = this.command;\n\t\t\t\t\tthis.command = this.getToken();\n\t\t\t\t};\n\n\t\t\t\tthis.getPoint = function () {\n\t\t\t\t\tvar p = new svg.Point(this.getScalar(), this.getScalar());\n\t\t\t\t\treturn this.makeAbsolute(p);\n\t\t\t\t};\n\n\t\t\t\tthis.getAsControlPoint = function () {\n\t\t\t\t\tvar p = this.getPoint();\n\t\t\t\t\tthis.control = p;\n\t\t\t\t\treturn p;\n\t\t\t\t};\n\n\t\t\t\tthis.getAsCurrentPoint = function () {\n\t\t\t\t\tvar p = this.getPoint();\n\t\t\t\t\tthis.current = p;\n\t\t\t\t\treturn p;\n\t\t\t\t};\n\n\t\t\t\tthis.getReflectedControlPoint = function () {\n\t\t\t\t\tif (this.previousCommand.toLowerCase() != 'c' && this.previousCommand.toLowerCase() != 's' && this.previousCommand.toLowerCase() != 'q' && this.previousCommand.toLowerCase() != 't') {\n\t\t\t\t\t\treturn this.current;\n\t\t\t\t\t}\n\n\t\t\t\t\t// reflect point\n\t\t\t\t\tvar p = new svg.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);\n\t\t\t\t\treturn p;\n\t\t\t\t};\n\n\t\t\t\tthis.makeAbsolute = function (p) {\n\t\t\t\t\tif (this.isRelativeCommand()) {\n\t\t\t\t\t\tp.x += this.current.x;\n\t\t\t\t\t\tp.y += this.current.y;\n\t\t\t\t\t}\n\t\t\t\t\treturn p;\n\t\t\t\t};\n\n\t\t\t\tthis.addMarker = function (p, from, priorTo) {\n\t\t\t\t\t// if the last angle isn't filled in because we didn't have this point yet ...\n\t\t\t\t\tif (priorTo != null && this.angles.length > 0 && this.angles[this.angles.length - 1] == null) {\n\t\t\t\t\t\tthis.angles[this.angles.length - 1] = this.points[this.points.length - 1].angleTo(priorTo);\n\t\t\t\t\t}\n\t\t\t\t\tthis.addMarkerAngle(p, from == null ? null : from.angleTo(p));\n\t\t\t\t};\n\n\t\t\t\tthis.addMarkerAngle = function (p, a) {\n\t\t\t\t\tthis.points.push(p);\n\t\t\t\t\tthis.angles.push(a);\n\t\t\t\t};\n\n\t\t\t\tthis.getMarkerPoints = function () {\n\t\t\t\t\treturn this.points;\n\t\t\t\t};\n\t\t\t\tthis.getMarkerAngles = function () {\n\t\t\t\t\tfor (var i = 0; i < this.angles.length; i++) {\n\t\t\t\t\t\tif (this.angles[i] == null) {\n\t\t\t\t\t\t\tfor (var j = i + 1; j < this.angles.length; j++) {\n\t\t\t\t\t\t\t\tif (this.angles[j] != null) {\n\t\t\t\t\t\t\t\t\tthis.angles[i] = this.angles[j];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this.angles;\n\t\t\t\t};\n\t\t\t}(d);\n\n\t\t\tthis.path = function (ctx) {\n\t\t\t\tvar pp = this.PathParser;\n\t\t\t\tpp.reset();\n\n\t\t\t\tvar bb = new svg.BoundingBox();\n\t\t\t\tif (ctx != null) ctx.beginPath();\n\t\t\t\twhile (!pp.isEnd()) {\n\t\t\t\t\tpp.nextCommand();\n\t\t\t\t\tswitch (pp.command) {\n\t\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tcase 'm':\n\t\t\t\t\t\t\tvar p = pp.getAsCurrentPoint();\n\t\t\t\t\t\t\tpp.addMarker(p);\n\t\t\t\t\t\t\tbb.addPoint(p.x, p.y);\n\t\t\t\t\t\t\tif (ctx != null) ctx.moveTo(p.x, p.y);\n\t\t\t\t\t\t\tpp.start = pp.current;\n\t\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\n\t\t\t\t\t\t\t\tvar p = pp.getAsCurrentPoint();\n\t\t\t\t\t\t\t\tpp.addMarker(p, pp.start);\n\t\t\t\t\t\t\t\tbb.addPoint(p.x, p.y);\n\t\t\t\t\t\t\t\tif (ctx != null) ctx.lineTo(p.x, p.y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\n\t\t\t\t\t\t\t\tvar c = pp.current;\n\t\t\t\t\t\t\t\tvar p = pp.getAsCurrentPoint();\n\t\t\t\t\t\t\t\tpp.addMarker(p, c);\n\t\t\t\t\t\t\t\tbb.addPoint(p.x, p.y);\n\t\t\t\t\t\t\t\tif (ctx != null) ctx.lineTo(p.x, p.y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tcase 'h':\n\t\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\n\t\t\t\t\t\t\t\tvar newP = new svg.Point((pp.isRelativeCommand() ? pp.current.x : 0) + pp.getScalar(), pp.current.y);\n\t\t\t\t\t\t\t\tpp.addMarker(newP, pp.current);\n\t\t\t\t\t\t\t\tpp.current = newP;\n\t\t\t\t\t\t\t\tbb.addPoint(pp.current.x, pp.current.y);\n\t\t\t\t\t\t\t\tif (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'V':\n\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\n\t\t\t\t\t\t\t\tvar newP = new svg.Point(pp.current.x, (pp.isRelativeCommand() ? pp.current.y : 0) + pp.getScalar());\n\t\t\t\t\t\t\t\tpp.addMarker(newP, pp.current);\n\t\t\t\t\t\t\t\tpp.current = newP;\n\t\t\t\t\t\t\t\tbb.addPoint(pp.current.x, pp.current.y);\n\t\t\t\t\t\t\t\tif (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\n\t\t\t\t\t\t\t\tvar curr = pp.current;\n\t\t\t\t\t\t\t\tvar p1 = pp.getPoint();\n\t\t\t\t\t\t\t\tvar cntrl = pp.getAsControlPoint();\n\t\t\t\t\t\t\t\tvar cp = pp.getAsCurrentPoint();\n\t\t\t\t\t\t\t\tpp.addMarker(cp, cntrl, p1);\n\t\t\t\t\t\t\t\tbb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);\n\t\t\t\t\t\t\t\tif (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tcase 's':\n\t\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\n\t\t\t\t\t\t\t\tvar curr = pp.current;\n\t\t\t\t\t\t\t\tvar p1 = pp.getReflectedControlPoint();\n\t\t\t\t\t\t\t\tvar cntrl = pp.getAsControlPoint();\n\t\t\t\t\t\t\t\tvar cp = pp.getAsCurrentPoint();\n\t\t\t\t\t\t\t\tpp.addMarker(cp, cntrl, p1);\n\t\t\t\t\t\t\t\tbb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);\n\t\t\t\t\t\t\t\tif (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tcase 'q':\n\t\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\n\t\t\t\t\t\t\t\tvar curr = pp.current;\n\t\t\t\t\t\t\t\tvar cntrl = pp.getAsControlPoint();\n\t\t\t\t\t\t\t\tvar cp = pp.getAsCurrentPoint();\n\t\t\t\t\t\t\t\tpp.addMarker(cp, cntrl, cntrl);\n\t\t\t\t\t\t\t\tbb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);\n\t\t\t\t\t\t\t\tif (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tcase 't':\n\t\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\n\t\t\t\t\t\t\t\tvar curr = pp.current;\n\t\t\t\t\t\t\t\tvar cntrl = pp.getReflectedControlPoint();\n\t\t\t\t\t\t\t\tpp.control = cntrl;\n\t\t\t\t\t\t\t\tvar cp = pp.getAsCurrentPoint();\n\t\t\t\t\t\t\t\tpp.addMarker(cp, cntrl, cntrl);\n\t\t\t\t\t\t\t\tbb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);\n\t\t\t\t\t\t\t\tif (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\tcase 'a':\n\t\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\n\t\t\t\t\t\t\t\tvar curr = pp.current;\n\t\t\t\t\t\t\t\tvar rx = pp.getScalar();\n\t\t\t\t\t\t\t\tvar ry = pp.getScalar();\n\t\t\t\t\t\t\t\tvar xAxisRotation = pp.getScalar() * (Math.PI / 180.0);\n\t\t\t\t\t\t\t\tvar largeArcFlag = pp.getScalar();\n\t\t\t\t\t\t\t\tvar sweepFlag = pp.getScalar();\n\t\t\t\t\t\t\t\tvar cp = pp.getAsCurrentPoint();\n\n\t\t\t\t\t\t\t\t// Conversion from endpoint to center parameterization\n\t\t\t\t\t\t\t\t// http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n\t\t\t\t\t\t\t\t// x1', y1'\n\t\t\t\t\t\t\t\tvar currp = new svg.Point(Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0, -Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0);\n\t\t\t\t\t\t\t\t// adjust radii\n\t\t\t\t\t\t\t\tvar l = Math.pow(currp.x, 2) / Math.pow(rx, 2) + Math.pow(currp.y, 2) / Math.pow(ry, 2);\n\t\t\t\t\t\t\t\tif (l > 1) {\n\t\t\t\t\t\t\t\t\trx *= Math.sqrt(l);\n\t\t\t\t\t\t\t\t\try *= Math.sqrt(l);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// cx', cy'\n\t\t\t\t\t\t\t\tvar s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(currp.y, 2) - Math.pow(ry, 2) * Math.pow(currp.x, 2)) / (Math.pow(rx, 2) * Math.pow(currp.y, 2) + Math.pow(ry, 2) * Math.pow(currp.x, 2)));\n\t\t\t\t\t\t\t\tif (isNaN(s)) s = 0;\n\t\t\t\t\t\t\t\tvar cpp = new svg.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);\n\t\t\t\t\t\t\t\t// cx, cy\n\t\t\t\t\t\t\t\tvar centp = new svg.Point((curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y);\n\t\t\t\t\t\t\t\t// vector magnitude\n\t\t\t\t\t\t\t\tvar m = function m(v) {\n\t\t\t\t\t\t\t\t\treturn Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t// ratio between two vectors\n\t\t\t\t\t\t\t\tvar r = function r(u, v) {\n\t\t\t\t\t\t\t\t\treturn (u[0] * v[0] + u[1] * v[1]) / (m(u) * m(v));\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t// angle between two vectors\n\t\t\t\t\t\t\t\tvar a = function a(u, v) {\n\t\t\t\t\t\t\t\t\treturn (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(r(u, v));\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t// initial angle\n\t\t\t\t\t\t\t\tvar a1 = a([1, 0], [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry]);\n\t\t\t\t\t\t\t\t// angle delta\n\t\t\t\t\t\t\t\tvar u = [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry];\n\t\t\t\t\t\t\t\tvar v = [(-currp.x - cpp.x) / rx, (-currp.y - cpp.y) / ry];\n\t\t\t\t\t\t\t\tvar ad = a(u, v);\n\t\t\t\t\t\t\t\tif (r(u, v) <= -1) ad = Math.PI;\n\t\t\t\t\t\t\t\tif (r(u, v) >= 1) ad = 0;\n\n\t\t\t\t\t\t\t\t// for markers\n\t\t\t\t\t\t\t\tvar dir = 1 - sweepFlag ? 1.0 : -1.0;\n\t\t\t\t\t\t\t\tvar ah = a1 + dir * (ad / 2.0);\n\t\t\t\t\t\t\t\tvar halfWay = new svg.Point(centp.x + rx * Math.cos(ah), centp.y + ry * Math.sin(ah));\n\t\t\t\t\t\t\t\tpp.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);\n\t\t\t\t\t\t\t\tpp.addMarkerAngle(cp, ah - dir * Math.PI);\n\n\t\t\t\t\t\t\t\tbb.addPoint(cp.x, cp.y); // TODO: this is too naive, make it better\n\t\t\t\t\t\t\t\tif (ctx != null) {\n\t\t\t\t\t\t\t\t\tvar r = rx > ry ? rx : ry;\n\t\t\t\t\t\t\t\t\tvar sx = rx > ry ? 1 : rx / ry;\n\t\t\t\t\t\t\t\t\tvar sy = rx > ry ? ry / rx : 1;\n\n\t\t\t\t\t\t\t\t\tctx.translate(centp.x, centp.y);\n\t\t\t\t\t\t\t\t\tctx.rotate(xAxisRotation);\n\t\t\t\t\t\t\t\t\tctx.scale(sx, sy);\n\t\t\t\t\t\t\t\t\tctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);\n\t\t\t\t\t\t\t\t\tctx.scale(1 / sx, 1 / sy);\n\t\t\t\t\t\t\t\t\tctx.rotate(-xAxisRotation);\n\t\t\t\t\t\t\t\t\tctx.translate(-centp.x, -centp.y);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'Z':\n\t\t\t\t\t\tcase 'z':\n\t\t\t\t\t\t\tif (ctx != null) ctx.closePath();\n\t\t\t\t\t\t\tpp.current = pp.start;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn bb;\n\t\t\t};\n\n\t\t\tthis.getMarkers = function () {\n\t\t\t\tvar points = this.PathParser.getMarkerPoints();\n\t\t\t\tvar angles = this.PathParser.getMarkerAngles();\n\n\t\t\t\tvar markers = [];\n\t\t\t\tfor (var i = 0; i < points.length; i++) {\n\t\t\t\t\tmarkers.push([points[i], angles[i]]);\n\t\t\t\t}\n\t\t\t\treturn markers;\n\t\t\t};\n\t\t};\n\t\tsvg.Element.path.prototype = new svg.Element.PathElementBase();\n\n\t\t// pattern element\n\t\tsvg.Element.pattern = function (node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.createPattern = function (ctx, element) {\n\t\t\t\tvar width = this.attribute('width').toPixels('x', true);\n\t\t\t\tvar height = this.attribute('height').toPixels('y', true);\n\n\t\t\t\t// render me using a temporary svg element\n\t\t\t\tvar tempSvg = new svg.Element.svg();\n\t\t\t\ttempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);\n\t\t\t\ttempSvg.attributes['width'] = new svg.Property('width', width + 'px');\n\t\t\t\ttempSvg.attributes['height'] = new svg.Property('height', height + 'px');\n\t\t\t\ttempSvg.attributes['transform'] = new svg.Property('transform', this.attribute('patternTransform').value);\n\t\t\t\ttempSvg.children = this.children;\n\n\t\t\t\tvar c = document.createElement('canvas');\n\t\t\t\tc.width = width;\n\t\t\t\tc.height = height;\n\t\t\t\tvar cctx = c.getContext('2d');\n\t\t\t\tif (this.attribute('x').hasValue() && this.attribute('y').hasValue()) {\n\t\t\t\t\tcctx.translate(this.attribute('x').toPixels('x', true), this.attribute('y').toPixels('y', true));\n\t\t\t\t}\n\t\t\t\t// render 3x3 grid so when we transform there's no white space on edges\n\t\t\t\tfor (var x = -1; x <= 1; x++) {\n\t\t\t\t\tfor (var y = -1; y <= 1; y++) {\n\t\t\t\t\t\tcctx.save();\n\t\t\t\t\t\ttempSvg.attributes['x'] = new svg.Property('x', x * c.width);\n\t\t\t\t\t\ttempSvg.attributes['y'] = new svg.Property('y', y * c.height);\n\t\t\t\t\t\ttempSvg.render(cctx);\n\t\t\t\t\t\tcctx.restore();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar pattern = ctx.createPattern(c, 'repeat');\n\t\t\t\treturn pattern;\n\t\t\t};\n\t\t};\n\t\tsvg.Element.pattern.prototype = new svg.Element.ElementBase();\n\n\t\t// marker element\n\t\tsvg.Element.marker = function (node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.baseRender = this.render;\n\t\t\tthis.render = function (ctx, point, angle) {\n\t\t\t\tctx.translate(point.x, point.y);\n\t\t\t\tif (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(angle);\n\t\t\t\tif (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(ctx.lineWidth, ctx.lineWidth);\n\t\t\t\tctx.save();\n\n\t\t\t\t// render me using a temporary svg element\n\t\t\t\tvar tempSvg = new svg.Element.svg();\n\t\t\t\ttempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);\n\t\t\t\ttempSvg.attributes['refX'] = new svg.Property('refX', this.attribute('refX').value);\n\t\t\t\ttempSvg.attributes['refY'] = new svg.Property('refY', this.attribute('refY').value);\n\t\t\t\ttempSvg.attributes['width'] = new svg.Property('width', this.attribute('markerWidth').value);\n\t\t\t\ttempSvg.attributes['height'] = new svg.Property('height', this.attribute('markerHeight').value);\n\t\t\t\ttempSvg.attributes['fill'] = new svg.Property('fill', this.attribute('fill').valueOrDefault('black'));\n\t\t\t\ttempSvg.attributes['stroke'] = new svg.Property('stroke', this.attribute('stroke').valueOrDefault('none'));\n\t\t\t\ttempSvg.children = this.children;\n\t\t\t\ttempSvg.render(ctx);\n\n\t\t\t\tctx.restore();\n\t\t\t\tif (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);\n\t\t\t\tif (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(-angle);\n\t\t\t\tctx.translate(-point.x, -point.y);\n\t\t\t};\n\t\t};\n\t\tsvg.Element.marker.prototype = new svg.Element.ElementBase();\n\n\t\t// definitions element\n\t\tsvg.Element.defs = function (node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.render = function (ctx) {\n\t\t\t\t// NOOP\n\t\t\t};\n\t\t};\n\t\tsvg.Element.defs.prototype = new svg.Element.ElementBase();\n\n\t\t// base for gradients\n\t\tsvg.Element.GradientBase = function (node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.stops = [];\n\t\t\tfor (var i = 0; i < this.children.length; i++) {\n\t\t\t\tvar child = this.children[i];\n\t\t\t\tif (child.type == 'stop') this.stops.push(child);\n\t\t\t}\n\n\t\t\tthis.getGradient = function () {\n\t\t\t\t// OVERRIDE ME!\n\t\t\t};\n\n\t\t\tthis.gradientUnits = function () {\n\t\t\t\treturn this.attribute('gradientUnits').valueOrDefault('objectBoundingBox');\n\t\t\t};\n\n\t\t\tthis.attributesToInherit = ['gradientUnits'];\n\n\t\t\tthis.inheritStopContainer = function (stopsContainer) {\n\t\t\t\tfor (var i = 0; i < this.attributesToInherit.length; i++) {\n\t\t\t\t\tvar attributeToInherit = this.attributesToInherit[i];\n\t\t\t\t\tif (!this.attribute(attributeToInherit).hasValue() && stopsContainer.attribute(attributeToInherit).hasValue()) {\n\t\t\t\t\t\tthis.attribute(attributeToInherit, true).value = stopsContainer.attribute(attributeToInherit).value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.createGradient = function (ctx, element, parentOpacityProp) {\n\t\t\t\tvar stopsContainer = this;\n\t\t\t\tif (this.getHrefAttribute().hasValue()) {\n\t\t\t\t\tstopsContainer = this.getHrefAttribute().getDefinition();\n\t\t\t\t\tthis.inheritStopContainer(stopsContainer);\n\t\t\t\t}\n\n\t\t\t\tvar addParentOpacity = function addParentOpacity(color) {\n\t\t\t\t\tif (parentOpacityProp.hasValue()) {\n\t\t\t\t\t\tvar p = new svg.Property('color', color);\n\t\t\t\t\t\treturn p.addOpacity(parentOpacityProp).value;\n\t\t\t\t\t}\n\t\t\t\t\treturn color;\n\t\t\t\t};\n\n\t\t\t\tvar g = this.getGradient(ctx, element);\n\t\t\t\tif (g == null) return addParentOpacity(stopsContainer.stops[stopsContainer.stops.length - 1].color);\n\t\t\t\tfor (var i = 0; i < stopsContainer.stops.length; i++) {\n\t\t\t\t\tg.addColorStop(stopsContainer.stops[i].offset, addParentOpacity(stopsContainer.stops[i].color));\n\t\t\t\t}\n\n\t\t\t\tif (this.attribute('gradientTransform').hasValue()) {\n\t\t\t\t\t// render as transformed pattern on temporary canvas\n\t\t\t\t\tvar rootView = svg.ViewPort.viewPorts[0];\n\n\t\t\t\t\tvar rect = new svg.Element.rect();\n\t\t\t\t\trect.attributes['x'] = new svg.Property('x', -svg.MAX_VIRTUAL_PIXELS / 3.0);\n\t\t\t\t\trect.attributes['y'] = new svg.Property('y', -svg.MAX_VIRTUAL_PIXELS / 3.0);\n\t\t\t\t\trect.attributes['width'] = new svg.Property('width', svg.MAX_VIRTUAL_PIXELS);\n\t\t\t\t\trect.attributes['height'] = new svg.Property('height', svg.MAX_VIRTUAL_PIXELS);\n\n\t\t\t\t\tvar group = new svg.Element.g();\n\t\t\t\t\tgroup.attributes['transform'] = new svg.Property('transform', this.attribute('gradientTransform').value);\n\t\t\t\t\tgroup.children = [rect];\n\n\t\t\t\t\tvar tempSvg = new svg.Element.svg();\n\t\t\t\t\ttempSvg.attributes['x'] = new svg.Property('x', 0);\n\t\t\t\t\ttempSvg.attributes['y'] = new svg.Property('y', 0);\n\t\t\t\t\ttempSvg.attributes['width'] = new svg.Property('width', rootView.width);\n\t\t\t\t\ttempSvg.attributes['height'] = new svg.Property('height', rootView.height);\n\t\t\t\t\ttempSvg.children = [group];\n\n\t\t\t\t\tvar c = document.createElement('canvas');\n\t\t\t\t\tc.width = rootView.width;\n\t\t\t\t\tc.height = rootView.height;\n\t\t\t\t\tvar tempCtx = c.getContext('2d');\n\t\t\t\t\ttempCtx.fillStyle = g;\n\t\t\t\t\ttempSvg.render(tempCtx);\n\t\t\t\t\treturn tempCtx.createPattern(c, 'no-repeat');\n\t\t\t\t}\n\n\t\t\t\treturn g;\n\t\t\t};\n\t\t};\n\t\tsvg.Element.GradientBase.prototype = new svg.Element.ElementBase();\n\n\t\t// linear gradient element\n\t\tsvg.Element.linearGradient = function (node) {\n\t\t\tthis.base = svg.Element.GradientBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.attributesToInherit.push('x1');\n\t\t\tthis.attributesToInherit.push('y1');\n\t\t\tthis.attributesToInherit.push('x2');\n\t\t\tthis.attributesToInherit.push('y2');\n\n\t\t\tthis.getGradient = function (ctx, element) {\n\t\t\t\tvar bb = this.gradientUnits() == 'objectBoundingBox' ? element.getBoundingBox() : null;\n\n\t\t\t\tif (!this.attribute('x1').hasValue() && !this.attribute('y1').hasValue() && !this.attribute('x2').hasValue() && !this.attribute('y2').hasValue()) {\n\t\t\t\t\tthis.attribute('x1', true).value = 0;\n\t\t\t\t\tthis.attribute('y1', true).value = 0;\n\t\t\t\t\tthis.attribute('x2', true).value = 1;\n\t\t\t\t\tthis.attribute('y2', true).value = 0;\n\t\t\t\t}\n\n\t\t\t\tvar x1 = this.gradientUnits() == 'objectBoundingBox' ? bb.x() + bb.width() * this.attribute('x1').numValue() : this.attribute('x1').toPixels('x');\n\t\t\t\tvar y1 = this.gradientUnits() == 'objectBoundingBox' ? bb.y() + bb.height() * this.attribute('y1').numValue() : this.attribute('y1').toPixels('y');\n\t\t\t\tvar x2 = this.gradientUnits() == 'objectBoundingBox' ? bb.x() + bb.width() * this.attribute('x2').numValue() : this.attribute('x2').toPixels('x');\n\t\t\t\tvar y2 = this.gradientUnits() == 'objectBoundingBox' ? bb.y() + bb.height() * this.attribute('y2').numValue() : this.attribute('y2').toPixels('y');\n\n\t\t\t\tif (x1 == x2 && y1 == y2) return null;\n\t\t\t\treturn ctx.createLinearGradient(x1, y1, x2, y2);\n\t\t\t};\n\t\t};\n\t\tsvg.Element.linearGradient.prototype = new svg.Element.GradientBase();\n\n\t\t// radial gradient element\n\t\tsvg.Element.radialGradient = function (node) {\n\t\t\tthis.base = svg.Element.GradientBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.attributesToInherit.push('cx');\n\t\t\tthis.attributesToInherit.push('cy');\n\t\t\tthis.attributesToInherit.push('r');\n\t\t\tthis.attributesToInherit.push('fx');\n\t\t\tthis.attributesToInherit.push('fy');\n\n\t\t\tthis.getGradient = function (ctx, element) {\n\t\t\t\tvar bb = element.getBoundingBox();\n\n\t\t\t\tif (!this.attribute('cx').hasValue()) this.attribute('cx', true).value = '50%';\n\t\t\t\tif (!this.attribute('cy').hasValue()) this.attribute('cy', true).value = '50%';\n\t\t\t\tif (!this.attribute('r').hasValue()) this.attribute('r', true).value = '50%';\n\n\t\t\t\tvar cx = this.gradientUnits() == 'objectBoundingBox' ? bb.x() + bb.width() * this.attribute('cx').numValue() : this.attribute('cx').toPixels('x');\n\t\t\t\tvar cy = this.gradientUnits() == 'objectBoundingBox' ? bb.y() + bb.height() * this.attribute('cy').numValue() : this.attribute('cy').toPixels('y');\n\n\t\t\t\tvar fx = cx;\n\t\t\t\tvar fy = cy;\n\t\t\t\tif (this.attribute('fx').hasValue()) {\n\t\t\t\t\tfx = this.gradientUnits() == 'objectBoundingBox' ? bb.x() + bb.width() * this.attribute('fx').numValue() : this.attribute('fx').toPixels('x');\n\t\t\t\t}\n\t\t\t\tif (this.attribute('fy').hasValue()) {\n\t\t\t\t\tfy = this.gradientUnits() == 'objectBoundingBox' ? bb.y() + bb.height() * this.attribute('fy').numValue() : this.attribute('fy').toPixels('y');\n\t\t\t\t}\n\n\t\t\t\tvar r = this.gradientUnits() == 'objectBoundingBox' ? (bb.width() + bb.height()) / 2.0 * this.attribute('r').numValue() : this.attribute('r').toPixels();\n\n\t\t\t\treturn ctx.createRadialGradient(fx, fy, 0, cx, cy, r);\n\t\t\t};\n\t\t};\n\t\tsvg.Element.radialGradient.prototype = new svg.Element.GradientBase();\n\n\t\t// gradient stop element\n\t\tsvg.Element.stop = function (node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.offset = this.attribute('offset').numValue();\n\t\t\tif (this.offset < 0) this.offset = 0;\n\t\t\tif (this.offset > 1) this.offset = 1;\n\n\t\t\tvar stopColor = this.style('stop-color', true);\n\t\t\tif (stopColor.value === '') stopColor.value = '#000';\n\t\t\tif (this.style('stop-opacity').hasValue()) stopColor = stopColor.addOpacity(this.style('stop-opacity'));\n\t\t\tthis.color = stopColor.value;\n\t\t};\n\t\tsvg.Element.stop.prototype = new svg.Element.ElementBase();\n\n\t\t// animation base element\n\t\tsvg.Element.AnimateBase = function (node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tsvg.Animations.push(this);\n\n\t\t\tthis.duration = 0.0;\n\t\t\tthis.begin = this.attribute('begin').toMilliseconds();\n\t\t\tthis.maxDuration = this.begin + this.attribute('dur').toMilliseconds();\n\n\t\t\tthis.getProperty = function () {\n\t\t\t\tvar attributeType = this.attribute('attributeType').value;\n\t\t\t\tvar attributeName = this.attribute('attributeName').value;\n\n\t\t\t\tif (attributeType == 'CSS') {\n\t\t\t\t\treturn this.parent.style(attributeName, true);\n\t\t\t\t}\n\t\t\t\treturn this.parent.attribute(attributeName, true);\n\t\t\t};\n\n\t\t\tthis.initialValue = null;\n\t\t\tthis.initialUnits = '';\n\t\t\tthis.removed = false;\n\n\t\t\tthis.calcValue = function () {\n\t\t\t\t// OVERRIDE ME!\n\t\t\t\treturn '';\n\t\t\t};\n\n\t\t\tthis.update = function (delta) {\n\t\t\t\t// set initial value\n\t\t\t\tif (this.initialValue == null) {\n\t\t\t\t\tthis.initialValue = this.getProperty().value;\n\t\t\t\t\tthis.initialUnits = this.getProperty().getUnits();\n\t\t\t\t}\n\n\t\t\t\t// if we're past the end time\n\t\t\t\tif (this.duration > this.maxDuration) {\n\t\t\t\t\t// loop for indefinitely repeating animations\n\t\t\t\t\tif (this.attribute('repeatCount').value == 'indefinite' || this.attribute('repeatDur').value == 'indefinite') {\n\t\t\t\t\t\tthis.duration = 0.0;\n\t\t\t\t\t} else if (this.attribute('fill').valueOrDefault('remove') == 'freeze' && !this.frozen) {\n\t\t\t\t\t\tthis.frozen = true;\n\t\t\t\t\t\tthis.parent.animationFrozen = true;\n\t\t\t\t\t\tthis.parent.animationFrozenValue = this.getProperty().value;\n\t\t\t\t\t} else if (this.attribute('fill').valueOrDefault('remove') == 'remove' && !this.removed) {\n\t\t\t\t\t\tthis.removed = true;\n\t\t\t\t\t\tthis.getProperty().value = this.parent.animationFrozen ? this.parent.animationFrozenValue : this.initialValue;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tthis.duration = this.duration + delta;\n\n\t\t\t\t// if we're past the begin time\n\t\t\t\tvar updated = false;\n\t\t\t\tif (this.begin < this.duration) {\n\t\t\t\t\tvar newValue = this.calcValue(); // tween\n\n\t\t\t\t\tif (this.attribute('type').hasValue()) {\n\t\t\t\t\t\t// for transform, etc.\n\t\t\t\t\t\tvar type = this.attribute('type').value;\n\t\t\t\t\t\tnewValue = type + '(' + newValue + ')';\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.getProperty().value = newValue;\n\t\t\t\t\tupdated = true;\n\t\t\t\t}\n\n\t\t\t\treturn updated;\n\t\t\t};\n\n\t\t\tthis.from = this.attribute('from');\n\t\t\tthis.to = this.attribute('to');\n\t\t\tthis.values = this.attribute('values');\n\t\t\tif (this.values.hasValue()) this.values.value = this.values.value.split(';');\n\n\t\t\t// fraction of duration we've covered\n\t\t\tthis.progress = function () {\n\t\t\t\tvar ret = { progress: (this.duration - this.begin) / (this.maxDuration - this.begin) };\n\t\t\t\tif (this.values.hasValue()) {\n\t\t\t\t\tvar p = ret.progress * (this.values.value.length - 1);\n\t\t\t\t\tvar lb = Math.floor(p),\n\t\t\t\t\t    ub = Math.ceil(p);\n\t\t\t\t\tret.from = new svg.Property('from', parseFloat(this.values.value[lb]));\n\t\t\t\t\tret.to = new svg.Property('to', parseFloat(this.values.value[ub]));\n\t\t\t\t\tret.progress = (p - lb) / (ub - lb);\n\t\t\t\t} else {\n\t\t\t\t\tret.from = this.from;\n\t\t\t\t\tret.to = this.to;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t};\n\t\t};\n\t\tsvg.Element.AnimateBase.prototype = new svg.Element.ElementBase();\n\n\t\t// animate element\n\t\tsvg.Element.animate = function (node) {\n\t\t\tthis.base = svg.Element.AnimateBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.calcValue = function () {\n\t\t\t\tvar p = this.progress();\n\n\t\t\t\t// tween value linearly\n\t\t\t\tvar newValue = p.from.numValue() + (p.to.numValue() - p.from.numValue()) * p.progress;\n\t\t\t\treturn newValue + this.initialUnits;\n\t\t\t};\n\t\t};\n\t\tsvg.Element.animate.prototype = new svg.Element.AnimateBase();\n\n\t\t// animate color element\n\t\tsvg.Element.animateColor = function (node) {\n\t\t\tthis.base = svg.Element.AnimateBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.calcValue = function () {\n\t\t\t\tvar p = this.progress();\n\t\t\t\tvar from = new RGBColor(p.from.value);\n\t\t\t\tvar to = new RGBColor(p.to.value);\n\n\t\t\t\tif (from.ok && to.ok) {\n\t\t\t\t\t// tween color linearly\n\t\t\t\t\tvar r = from.r + (to.r - from.r) * p.progress;\n\t\t\t\t\tvar g = from.g + (to.g - from.g) * p.progress;\n\t\t\t\t\tvar b = from.b + (to.b - from.b) * p.progress;\n\t\t\t\t\treturn 'rgb(' + parseInt(r, 10) + ',' + parseInt(g, 10) + ',' + parseInt(b, 10) + ')';\n\t\t\t\t}\n\t\t\t\treturn this.attribute('from').value;\n\t\t\t};\n\t\t};\n\t\tsvg.Element.animateColor.prototype = new svg.Element.AnimateBase();\n\n\t\t// animate transform element\n\t\tsvg.Element.animateTransform = function (node) {\n\t\t\tthis.base = svg.Element.AnimateBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.calcValue = function () {\n\t\t\t\tvar p = this.progress();\n\n\t\t\t\t// tween value linearly\n\t\t\t\tvar from = svg.ToNumberArray(p.from.value);\n\t\t\t\tvar to = svg.ToNumberArray(p.to.value);\n\t\t\t\tvar newValue = '';\n\t\t\t\tfor (var i = 0; i < from.length; i++) {\n\t\t\t\t\tnewValue += from[i] + (to[i] - from[i]) * p.progress + ' ';\n\t\t\t\t}\n\t\t\t\treturn newValue;\n\t\t\t};\n\t\t};\n\t\tsvg.Element.animateTransform.prototype = new svg.Element.animate();\n\n\t\t// font element\n\t\tsvg.Element.font = function (node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.horizAdvX = this.attribute('horiz-adv-x').numValue();\n\n\t\t\tthis.isRTL = false;\n\t\t\tthis.isArabic = false;\n\t\t\tthis.fontFace = null;\n\t\t\tthis.missingGlyph = null;\n\t\t\tthis.glyphs = [];\n\t\t\tfor (var i = 0; i < this.children.length; i++) {\n\t\t\t\tvar child = this.children[i];\n\t\t\t\tif (child.type == 'font-face') {\n\t\t\t\t\tthis.fontFace = child;\n\t\t\t\t\tif (child.style('font-family').hasValue()) {\n\t\t\t\t\t\tsvg.Definitions[child.style('font-family').value] = this;\n\t\t\t\t\t}\n\t\t\t\t} else if (child.type == 'missing-glyph') this.missingGlyph = child;else if (child.type == 'glyph') {\n\t\t\t\t\tif (child.arabicForm != '') {\n\t\t\t\t\t\tthis.isRTL = true;\n\t\t\t\t\t\tthis.isArabic = true;\n\t\t\t\t\t\tif (typeof this.glyphs[child.unicode] == 'undefined') this.glyphs[child.unicode] = [];\n\t\t\t\t\t\tthis.glyphs[child.unicode][child.arabicForm] = child;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.glyphs[child.unicode] = child;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tsvg.Element.font.prototype = new svg.Element.ElementBase();\n\n\t\t// font-face element\n\t\tsvg.Element.fontface = function (node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.ascent = this.attribute('ascent').value;\n\t\t\tthis.descent = this.attribute('descent').value;\n\t\t\tthis.unitsPerEm = this.attribute('units-per-em').numValue();\n\t\t};\n\t\tsvg.Element.fontface.prototype = new svg.Element.ElementBase();\n\n\t\t// missing-glyph element\n\t\tsvg.Element.missingglyph = function (node) {\n\t\t\tthis.base = svg.Element.path;\n\t\t\tthis.base(node);\n\n\t\t\tthis.horizAdvX = 0;\n\t\t};\n\t\tsvg.Element.missingglyph.prototype = new svg.Element.path();\n\n\t\t// glyph element\n\t\tsvg.Element.glyph = function (node) {\n\t\t\tthis.base = svg.Element.path;\n\t\t\tthis.base(node);\n\n\t\t\tthis.horizAdvX = this.attribute('horiz-adv-x').numValue();\n\t\t\tthis.unicode = this.attribute('unicode').value;\n\t\t\tthis.arabicForm = this.attribute('arabic-form').value;\n\t\t};\n\t\tsvg.Element.glyph.prototype = new svg.Element.path();\n\n\t\t// text element\n\t\tsvg.Element.text = function (node) {\n\t\t\tthis.captureTextNodes = true;\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.baseSetContext = this.setContext;\n\t\t\tthis.setContext = function (ctx) {\n\t\t\t\tthis.baseSetContext(ctx);\n\n\t\t\t\tvar textBaseline = this.style('dominant-baseline').toTextBaseline();\n\t\t\t\tif (textBaseline == null) textBaseline = this.style('alignment-baseline').toTextBaseline();\n\t\t\t\tif (textBaseline != null) ctx.textBaseline = textBaseline;\n\t\t\t};\n\n\t\t\tthis.getBoundingBox = function () {\n\t\t\t\tvar x = this.attribute('x').toPixels('x');\n\t\t\t\tvar y = this.attribute('y').toPixels('y');\n\t\t\t\tvar fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);\n\t\t\t\treturn new svg.BoundingBox(x, y - fontSize, x + Math.floor(fontSize * 2.0 / 3.0) * this.children[0].getText().length, y);\n\t\t\t};\n\n\t\t\tthis.renderChildren = function (ctx) {\n\t\t\t\tthis.x = this.attribute('x').toPixels('x');\n\t\t\t\tthis.y = this.attribute('y').toPixels('y');\n\t\t\t\tif (this.attribute('dx').hasValue()) this.x += this.attribute('dx').toPixels('x');\n\t\t\t\tif (this.attribute('dy').hasValue()) this.y += this.attribute('dy').toPixels('y');\n\t\t\t\tthis.x += this.getAnchorDelta(ctx, this, 0);\n\t\t\t\tfor (var i = 0; i < this.children.length; i++) {\n\t\t\t\t\tthis.renderChild(ctx, this, i);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.getAnchorDelta = function (ctx, parent, startI) {\n\t\t\t\tvar textAnchor = this.style('text-anchor').valueOrDefault('start');\n\t\t\t\tif (textAnchor != 'start') {\n\t\t\t\t\tvar width = 0;\n\t\t\t\t\tfor (var i = startI; i < parent.children.length; i++) {\n\t\t\t\t\t\tvar child = parent.children[i];\n\t\t\t\t\t\tif (i > startI && child.attribute('x').hasValue()) break; // new group\n\t\t\t\t\t\twidth += child.measureTextRecursive(ctx);\n\t\t\t\t\t}\n\t\t\t\t\treturn -1 * (textAnchor == 'end' ? width : width / 2.0);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t};\n\n\t\t\tthis.renderChild = function (ctx, parent, i) {\n\t\t\t\tvar child = parent.children[i];\n\t\t\t\tif (child.attribute('x').hasValue()) {\n\t\t\t\t\tchild.x = child.attribute('x').toPixels('x') + parent.getAnchorDelta(ctx, parent, i);\n\t\t\t\t\tif (child.attribute('dx').hasValue()) child.x += child.attribute('dx').toPixels('x');\n\t\t\t\t} else {\n\t\t\t\t\tif (child.attribute('dx').hasValue()) parent.x += child.attribute('dx').toPixels('x');\n\t\t\t\t\tchild.x = parent.x;\n\t\t\t\t}\n\t\t\t\tparent.x = child.x + child.measureText(ctx);\n\n\t\t\t\tif (child.attribute('y').hasValue()) {\n\t\t\t\t\tchild.y = child.attribute('y').toPixels('y');\n\t\t\t\t\tif (child.attribute('dy').hasValue()) child.y += child.attribute('dy').toPixels('y');\n\t\t\t\t} else {\n\t\t\t\t\tif (child.attribute('dy').hasValue()) parent.y += child.attribute('dy').toPixels('y');\n\t\t\t\t\tchild.y = parent.y;\n\t\t\t\t}\n\t\t\t\tparent.y = child.y;\n\n\t\t\t\tchild.render(ctx);\n\n\t\t\t\tfor (var i = 0; i < child.children.length; i++) {\n\t\t\t\t\tparent.renderChild(ctx, child, i);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t\tsvg.Element.text.prototype = new svg.Element.RenderedElementBase();\n\n\t\t// text base\n\t\tsvg.Element.TextElementBase = function (node) {\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.getGlyph = function (font, text, i) {\n\t\t\t\tvar c = text[i];\n\t\t\t\tvar glyph = null;\n\t\t\t\tif (font.isArabic) {\n\t\t\t\t\tvar arabicForm = 'isolated';\n\t\t\t\t\tif ((i == 0 || text[i - 1] == ' ') && i < text.length - 2 && text[i + 1] != ' ') arabicForm = 'terminal';\n\t\t\t\t\tif (i > 0 && text[i - 1] != ' ' && i < text.length - 2 && text[i + 1] != ' ') arabicForm = 'medial';\n\t\t\t\t\tif (i > 0 && text[i - 1] != ' ' && (i == text.length - 1 || text[i + 1] == ' ')) arabicForm = 'initial';\n\t\t\t\t\tif (typeof font.glyphs[c] != 'undefined') {\n\t\t\t\t\t\tglyph = font.glyphs[c][arabicForm];\n\t\t\t\t\t\tif (glyph == null && font.glyphs[c].type == 'glyph') glyph = font.glyphs[c];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tglyph = font.glyphs[c];\n\t\t\t\t}\n\t\t\t\tif (glyph == null) glyph = font.missingGlyph;\n\t\t\t\treturn glyph;\n\t\t\t};\n\n\t\t\tthis.renderChildren = function (ctx) {\n\t\t\t\tvar customFont = this.parent.style('font-family').getDefinition();\n\t\t\t\tif (customFont != null) {\n\t\t\t\t\tvar fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);\n\t\t\t\t\tvar fontStyle = this.parent.style('font-style').valueOrDefault(svg.Font.Parse(svg.ctx.font).fontStyle);\n\t\t\t\t\tvar text = this.getText();\n\t\t\t\t\tif (customFont.isRTL) text = text.split(\"\").reverse().join(\"\");\n\n\t\t\t\t\tvar dx = svg.ToNumberArray(this.parent.attribute('dx').value);\n\t\t\t\t\tfor (var i = 0; i < text.length; i++) {\n\t\t\t\t\t\tvar glyph = this.getGlyph(customFont, text, i);\n\t\t\t\t\t\tvar scale = fontSize / customFont.fontFace.unitsPerEm;\n\t\t\t\t\t\tctx.translate(this.x, this.y);\n\t\t\t\t\t\tctx.scale(scale, -scale);\n\t\t\t\t\t\tvar lw = ctx.lineWidth;\n\t\t\t\t\t\tctx.lineWidth = ctx.lineWidth * customFont.fontFace.unitsPerEm / fontSize;\n\t\t\t\t\t\tif (fontStyle == 'italic') ctx.transform(1, 0, .4, 1, 0, 0);\n\t\t\t\t\t\tglyph.render(ctx);\n\t\t\t\t\t\tif (fontStyle == 'italic') ctx.transform(1, 0, -.4, 1, 0, 0);\n\t\t\t\t\t\tctx.lineWidth = lw;\n\t\t\t\t\t\tctx.scale(1 / scale, -1 / scale);\n\t\t\t\t\t\tctx.translate(-this.x, -this.y);\n\n\t\t\t\t\t\tthis.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / customFont.fontFace.unitsPerEm;\n\t\t\t\t\t\tif (typeof dx[i] != 'undefined' && !isNaN(dx[i])) {\n\t\t\t\t\t\t\tthis.x += dx[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (ctx.fillStyle != '') ctx.fillText(svg.compressSpaces(this.getText()), this.x, this.y);\n\t\t\t\tif (ctx.strokeStyle != '') ctx.strokeText(svg.compressSpaces(this.getText()), this.x, this.y);\n\t\t\t};\n\n\t\t\tthis.getText = function () {\n\t\t\t\t// OVERRIDE ME\n\t\t\t};\n\n\t\t\tthis.measureTextRecursive = function (ctx) {\n\t\t\t\tvar width = this.measureText(ctx);\n\t\t\t\tfor (var i = 0; i < this.children.length; i++) {\n\t\t\t\t\twidth += this.children[i].measureTextRecursive(ctx);\n\t\t\t\t}\n\t\t\t\treturn width;\n\t\t\t};\n\n\t\t\tthis.measureText = function (ctx) {\n\t\t\t\tvar customFont = this.parent.style('font-family').getDefinition();\n\t\t\t\tif (customFont != null) {\n\t\t\t\t\tvar fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);\n\t\t\t\t\tvar measure = 0;\n\t\t\t\t\tvar text = this.getText();\n\t\t\t\t\tif (customFont.isRTL) text = text.split(\"\").reverse().join(\"\");\n\t\t\t\t\tvar dx = svg.ToNumberArray(this.parent.attribute('dx').value);\n\t\t\t\t\tfor (var i = 0; i < text.length; i++) {\n\t\t\t\t\t\tvar glyph = this.getGlyph(customFont, text, i);\n\t\t\t\t\t\tmeasure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;\n\t\t\t\t\t\tif (typeof dx[i] != 'undefined' && !isNaN(dx[i])) {\n\t\t\t\t\t\t\tmeasure += dx[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn measure;\n\t\t\t\t}\n\n\t\t\t\tvar textToMeasure = svg.compressSpaces(this.getText());\n\t\t\t\tif (!ctx.measureText) return textToMeasure.length * 10;\n\n\t\t\t\tctx.save();\n\t\t\t\tthis.setContext(ctx);\n\t\t\t\tvar width = ctx.measureText(textToMeasure).width;\n\t\t\t\tctx.restore();\n\t\t\t\treturn width;\n\t\t\t};\n\t\t};\n\t\tsvg.Element.TextElementBase.prototype = new svg.Element.RenderedElementBase();\n\n\t\t// tspan\n\t\tsvg.Element.tspan = function (node) {\n\t\t\tthis.captureTextNodes = true;\n\t\t\tthis.base = svg.Element.TextElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.text = svg.compressSpaces(node.value || node.text || node.textContent || '');\n\t\t\tthis.getText = function () {\n\t\t\t\t// if this node has children, then they own the text\n\t\t\t\tif (this.children.length > 0) {\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t\treturn this.text;\n\t\t\t};\n\t\t};\n\t\tsvg.Element.tspan.prototype = new svg.Element.TextElementBase();\n\n\t\t// tref\n\t\tsvg.Element.tref = function (node) {\n\t\t\tthis.base = svg.Element.TextElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.getText = function () {\n\t\t\t\tvar element = this.getHrefAttribute().getDefinition();\n\t\t\t\tif (element != null) return element.children[0].getText();\n\t\t\t};\n\t\t};\n\t\tsvg.Element.tref.prototype = new svg.Element.TextElementBase();\n\n\t\t// a element\n\t\tsvg.Element.a = function (node) {\n\t\t\tthis.base = svg.Element.TextElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.hasText = node.childNodes.length > 0;\n\t\t\tfor (var i = 0; i < node.childNodes.length; i++) {\n\t\t\t\tif (node.childNodes[i].nodeType != 3) this.hasText = false;\n\t\t\t}\n\n\t\t\t// this might contain text\n\t\t\tthis.text = this.hasText ? node.childNodes[0].value : '';\n\t\t\tthis.getText = function () {\n\t\t\t\treturn this.text;\n\t\t\t};\n\n\t\t\tthis.baseRenderChildren = this.renderChildren;\n\t\t\tthis.renderChildren = function (ctx) {\n\t\t\t\tif (this.hasText) {\n\t\t\t\t\t// render as text element\n\t\t\t\t\tthis.baseRenderChildren(ctx);\n\t\t\t\t\tvar fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);\n\t\t\t\t\tsvg.Mouse.checkBoundingBox(this, new svg.BoundingBox(this.x, this.y - fontSize.toPixels('y'), this.x + this.measureText(ctx), this.y));\n\t\t\t\t} else if (this.children.length > 0) {\n\t\t\t\t\t// render as temporary group\n\t\t\t\t\tvar g = new svg.Element.g();\n\t\t\t\t\tg.children = this.children;\n\t\t\t\t\tg.parent = this;\n\t\t\t\t\tg.render(ctx);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.onclick = function () {\n\t\t\t\twindow.open(this.getHrefAttribute().value);\n\t\t\t};\n\n\t\t\tthis.onmousemove = function () {\n\t\t\t\tsvg.ctx.canvas.style.cursor = 'pointer';\n\t\t\t};\n\t\t};\n\t\tsvg.Element.a.prototype = new svg.Element.TextElementBase();\n\n\t\t// image element\n\t\tsvg.Element.image = function (node) {\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tvar href = this.getHrefAttribute().value;\n\t\t\tif (href == '') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar isSvg = href.match(/\\.svg$/);\n\n\t\t\tsvg.Images.push(this);\n\t\t\tthis.loaded = false;\n\t\t\tif (!isSvg) {\n\t\t\t\tthis.img = document.createElement('img');\n\t\t\t\tif (svg.opts['useCORS'] == true) {\n\t\t\t\t\tthis.img.crossOrigin = 'Anonymous';\n\t\t\t\t}\n\t\t\t\tvar self = this;\n\t\t\t\tthis.img.onload = function () {\n\t\t\t\t\tself.loaded = true;\n\t\t\t\t};\n\t\t\t\tthis.img.onerror = function () {\n\t\t\t\t\tsvg.log('ERROR: image \"' + href + '\" not found');self.loaded = true;\n\t\t\t\t};\n\t\t\t\tthis.img.src = href;\n\t\t\t} else {\n\t\t\t\tthis.img = svg.ajax(href);\n\t\t\t\tthis.loaded = true;\n\t\t\t}\n\n\t\t\tthis.renderChildren = function (ctx) {\n\t\t\t\tvar x = this.attribute('x').toPixels('x');\n\t\t\t\tvar y = this.attribute('y').toPixels('y');\n\n\t\t\t\tvar width = this.attribute('width').toPixels('x');\n\t\t\t\tvar height = this.attribute('height').toPixels('y');\n\t\t\t\tif (width == 0 || height == 0) return;\n\n\t\t\t\tctx.save();\n\t\t\t\tif (isSvg) {\n\t\t\t\t\tctx.drawSvg(this.img, x, y, width, height);\n\t\t\t\t} else {\n\t\t\t\t\tctx.translate(x, y);\n\t\t\t\t\tsvg.AspectRatio(ctx, this.attribute('preserveAspectRatio').value, width, this.img.width, height, this.img.height, 0, 0);\n\t\t\t\t\tctx.drawImage(this.img, 0, 0);\n\t\t\t\t}\n\t\t\t\tctx.restore();\n\t\t\t};\n\n\t\t\tthis.getBoundingBox = function () {\n\t\t\t\tvar x = this.attribute('x').toPixels('x');\n\t\t\t\tvar y = this.attribute('y').toPixels('y');\n\t\t\t\tvar width = this.attribute('width').toPixels('x');\n\t\t\t\tvar height = this.attribute('height').toPixels('y');\n\t\t\t\treturn new svg.BoundingBox(x, y, x + width, y + height);\n\t\t\t};\n\t\t};\n\t\tsvg.Element.image.prototype = new svg.Element.RenderedElementBase();\n\n\t\t// group element\n\t\tsvg.Element.g = function (node) {\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.getBoundingBox = function () {\n\t\t\t\tvar bb = new svg.BoundingBox();\n\t\t\t\tfor (var i = 0; i < this.children.length; i++) {\n\t\t\t\t\tbb.addBoundingBox(this.children[i].getBoundingBox());\n\t\t\t\t}\n\t\t\t\treturn bb;\n\t\t\t};\n\t\t};\n\t\tsvg.Element.g.prototype = new svg.Element.RenderedElementBase();\n\n\t\t// symbol element\n\t\tsvg.Element.symbol = function (node) {\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.render = function (ctx) {\n\t\t\t\t// NO RENDER\n\t\t\t};\n\t\t};\n\t\tsvg.Element.symbol.prototype = new svg.Element.RenderedElementBase();\n\n\t\t// style element\n\t\tsvg.Element.style = function (node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\t// text, or spaces then CDATA\n\t\t\tvar css = '';\n\t\t\tfor (var i = 0; i < node.childNodes.length; i++) {\n\t\t\t\tcss += node.childNodes[i].data;\n\t\t\t}\n\t\t\tcss = css.replace(/(\\/\\*([^*]|[\\r\\n]|(\\*+([^*\\/]|[\\r\\n])))*\\*+\\/)|(^[\\s]*\\/\\/.*)/gm, ''); // remove comments\n\t\t\tcss = svg.compressSpaces(css); // replace whitespace\n\t\t\tvar cssDefs = css.split('}');\n\t\t\tfor (var i = 0; i < cssDefs.length; i++) {\n\t\t\t\tif (svg.trim(cssDefs[i]) != '') {\n\t\t\t\t\tvar cssDef = cssDefs[i].split('{');\n\t\t\t\t\tvar cssClasses = cssDef[0].split(',');\n\t\t\t\t\tvar cssProps = cssDef[1].split(';');\n\t\t\t\t\tfor (var j = 0; j < cssClasses.length; j++) {\n\t\t\t\t\t\tvar cssClass = svg.trim(cssClasses[j]);\n\t\t\t\t\t\tif (cssClass != '') {\n\t\t\t\t\t\t\tvar props = {};\n\t\t\t\t\t\t\tfor (var k = 0; k < cssProps.length; k++) {\n\t\t\t\t\t\t\t\tvar prop = cssProps[k].indexOf(':');\n\t\t\t\t\t\t\t\tvar name = cssProps[k].substr(0, prop);\n\t\t\t\t\t\t\t\tvar value = cssProps[k].substr(prop + 1, cssProps[k].length - prop);\n\t\t\t\t\t\t\t\tif (name != null && value != null) {\n\t\t\t\t\t\t\t\t\tprops[svg.trim(name)] = new svg.Property(svg.trim(name), svg.trim(value));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsvg.Styles[cssClass] = props;\n\t\t\t\t\t\t\tsvg.StylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);\n\t\t\t\t\t\t\tif (cssClass == '@font-face') {\n\t\t\t\t\t\t\t\tvar fontFamily = props['font-family'].value.replace(/\"/g, '');\n\t\t\t\t\t\t\t\tvar srcs = props['src'].value.split(',');\n\t\t\t\t\t\t\t\tfor (var s = 0; s < srcs.length; s++) {\n\t\t\t\t\t\t\t\t\tif (srcs[s].indexOf('format(\"svg\")') > 0) {\n\t\t\t\t\t\t\t\t\t\tvar urlStart = srcs[s].indexOf('url');\n\t\t\t\t\t\t\t\t\t\tvar urlEnd = srcs[s].indexOf(')', urlStart);\n\t\t\t\t\t\t\t\t\t\tvar url = srcs[s].substr(urlStart + 5, urlEnd - urlStart - 6);\n\t\t\t\t\t\t\t\t\t\tvar doc = svg.parseXml(svg.ajax(url));\n\t\t\t\t\t\t\t\t\t\tvar fonts = doc.getElementsByTagName('font');\n\t\t\t\t\t\t\t\t\t\tfor (var f = 0; f < fonts.length; f++) {\n\t\t\t\t\t\t\t\t\t\t\tvar font = svg.CreateElement(fonts[f]);\n\t\t\t\t\t\t\t\t\t\t\tsvg.Definitions[fontFamily] = font;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tsvg.Element.style.prototype = new svg.Element.ElementBase();\n\n\t\t// use element\n\t\tsvg.Element.use = function (node) {\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.baseSetContext = this.setContext;\n\t\t\tthis.setContext = function (ctx) {\n\t\t\t\tthis.baseSetContext(ctx);\n\t\t\t\tif (this.attribute('x').hasValue()) ctx.translate(this.attribute('x').toPixels('x'), 0);\n\t\t\t\tif (this.attribute('y').hasValue()) ctx.translate(0, this.attribute('y').toPixels('y'));\n\t\t\t};\n\n\t\t\tvar element = this.getHrefAttribute().getDefinition();\n\n\t\t\tthis.path = function (ctx) {\n\t\t\t\tif (element != null) element.path(ctx);\n\t\t\t};\n\n\t\t\tthis.getBoundingBox = function () {\n\t\t\t\tif (element != null) return element.getBoundingBox();\n\t\t\t};\n\n\t\t\tthis.renderChildren = function (ctx) {\n\t\t\t\tif (element != null) {\n\t\t\t\t\tvar tempSvg = element;\n\t\t\t\t\tif (element.type == 'symbol') {\n\t\t\t\t\t\t// render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)\n\t\t\t\t\t\ttempSvg = new svg.Element.svg();\n\t\t\t\t\t\ttempSvg.type = 'svg';\n\t\t\t\t\t\ttempSvg.attributes['viewBox'] = new svg.Property('viewBox', element.attribute('viewBox').value);\n\t\t\t\t\t\ttempSvg.attributes['preserveAspectRatio'] = new svg.Property('preserveAspectRatio', element.attribute('preserveAspectRatio').value);\n\t\t\t\t\t\ttempSvg.attributes['overflow'] = new svg.Property('overflow', element.attribute('overflow').value);\n\t\t\t\t\t\ttempSvg.children = element.children;\n\t\t\t\t\t}\n\t\t\t\t\tif (tempSvg.type == 'svg') {\n\t\t\t\t\t\t// if symbol or svg, inherit width/height from me\n\t\t\t\t\t\tif (this.attribute('width').hasValue()) tempSvg.attributes['width'] = new svg.Property('width', this.attribute('width').value);\n\t\t\t\t\t\tif (this.attribute('height').hasValue()) tempSvg.attributes['height'] = new svg.Property('height', this.attribute('height').value);\n\t\t\t\t\t}\n\t\t\t\t\tvar oldParent = tempSvg.parent;\n\t\t\t\t\ttempSvg.parent = null;\n\t\t\t\t\ttempSvg.render(ctx);\n\t\t\t\t\ttempSvg.parent = oldParent;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t\tsvg.Element.use.prototype = new svg.Element.RenderedElementBase();\n\n\t\t// mask element\n\t\tsvg.Element.mask = function (node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.apply = function (ctx, element) {\n\t\t\t\t// render as temp svg\n\t\t\t\tvar x = this.attribute('x').toPixels('x');\n\t\t\t\tvar y = this.attribute('y').toPixels('y');\n\t\t\t\tvar width = this.attribute('width').toPixels('x');\n\t\t\t\tvar height = this.attribute('height').toPixels('y');\n\n\t\t\t\tif (width == 0 && height == 0) {\n\t\t\t\t\tvar bb = new svg.BoundingBox();\n\t\t\t\t\tfor (var i = 0; i < this.children.length; i++) {\n\t\t\t\t\t\tbb.addBoundingBox(this.children[i].getBoundingBox());\n\t\t\t\t\t}\n\t\t\t\t\tvar x = Math.floor(bb.x1);\n\t\t\t\t\tvar y = Math.floor(bb.y1);\n\t\t\t\t\tvar width = Math.floor(bb.width());\n\t\t\t\t\tvar height = Math.floor(bb.height());\n\t\t\t\t}\n\n\t\t\t\t// temporarily remove mask to avoid recursion\n\t\t\t\tvar mask = element.attribute('mask').value;\n\t\t\t\telement.attribute('mask').value = '';\n\n\t\t\t\tvar cMask = document.createElement('canvas');\n\t\t\t\tcMask.width = x + width;\n\t\t\t\tcMask.height = y + height;\n\t\t\t\tvar maskCtx = cMask.getContext('2d');\n\t\t\t\tthis.renderChildren(maskCtx);\n\n\t\t\t\tvar c = document.createElement('canvas');\n\t\t\t\tc.width = x + width;\n\t\t\t\tc.height = y + height;\n\t\t\t\tvar tempCtx = c.getContext('2d');\n\t\t\t\telement.render(tempCtx);\n\t\t\t\ttempCtx.globalCompositeOperation = 'destination-in';\n\t\t\t\ttempCtx.fillStyle = maskCtx.createPattern(cMask, 'no-repeat');\n\t\t\t\ttempCtx.fillRect(0, 0, x + width, y + height);\n\n\t\t\t\tctx.fillStyle = tempCtx.createPattern(c, 'no-repeat');\n\t\t\t\tctx.fillRect(0, 0, x + width, y + height);\n\n\t\t\t\t// reassign mask\n\t\t\t\telement.attribute('mask').value = mask;\n\t\t\t};\n\n\t\t\tthis.render = function (ctx) {\n\t\t\t\t// NO RENDER\n\t\t\t};\n\t\t};\n\t\tsvg.Element.mask.prototype = new svg.Element.ElementBase();\n\n\t\t// clip element\n\t\tsvg.Element.clipPath = function (node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.apply = function (ctx) {\n\t\t\t\tvar oldBeginPath = CanvasRenderingContext2D.prototype.beginPath;\n\t\t\t\tCanvasRenderingContext2D.prototype.beginPath = function () {};\n\n\t\t\t\tvar oldClosePath = CanvasRenderingContext2D.prototype.closePath;\n\t\t\t\tCanvasRenderingContext2D.prototype.closePath = function () {};\n\n\t\t\t\toldBeginPath.call(ctx);\n\t\t\t\tfor (var i = 0; i < this.children.length; i++) {\n\t\t\t\t\tvar child = this.children[i];\n\t\t\t\t\tif (typeof child.path != 'undefined') {\n\t\t\t\t\t\tvar transform = null;\n\t\t\t\t\t\tif (child.style('transform', false, true).hasValue()) {\n\t\t\t\t\t\t\ttransform = new svg.Transform(child.style('transform', false, true).value);\n\t\t\t\t\t\t\ttransform.apply(ctx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchild.path(ctx);\n\t\t\t\t\t\tCanvasRenderingContext2D.prototype.closePath = oldClosePath;\n\t\t\t\t\t\tif (transform) {\n\t\t\t\t\t\t\ttransform.unapply(ctx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toldClosePath.call(ctx);\n\t\t\t\tctx.clip();\n\n\t\t\t\tCanvasRenderingContext2D.prototype.beginPath = oldBeginPath;\n\t\t\t\tCanvasRenderingContext2D.prototype.closePath = oldClosePath;\n\t\t\t};\n\n\t\t\tthis.render = function (ctx) {\n\t\t\t\t// NO RENDER\n\t\t\t};\n\t\t};\n\t\tsvg.Element.clipPath.prototype = new svg.Element.ElementBase();\n\n\t\t// filters\n\t\tsvg.Element.filter = function (node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.apply = function (ctx, element) {\n\t\t\t\t// render as temp svg\n\t\t\t\tvar bb = element.getBoundingBox();\n\t\t\t\tvar x = Math.floor(bb.x1);\n\t\t\t\tvar y = Math.floor(bb.y1);\n\t\t\t\tvar width = Math.floor(bb.width());\n\t\t\t\tvar height = Math.floor(bb.height());\n\n\t\t\t\t// temporarily remove filter to avoid recursion\n\t\t\t\tvar filter = element.style('filter').value;\n\t\t\t\telement.style('filter').value = '';\n\n\t\t\t\tvar px = 0,\n\t\t\t\t    py = 0;\n\t\t\t\tfor (var i = 0; i < this.children.length; i++) {\n\t\t\t\t\tvar efd = this.children[i].extraFilterDistance || 0;\n\t\t\t\t\tpx = Math.max(px, efd);\n\t\t\t\t\tpy = Math.max(py, efd);\n\t\t\t\t}\n\n\t\t\t\tvar c = document.createElement('canvas');\n\t\t\t\tc.width = width + 2 * px;\n\t\t\t\tc.height = height + 2 * py;\n\t\t\t\tvar tempCtx = c.getContext('2d');\n\t\t\t\ttempCtx.translate(-x + px, -y + py);\n\t\t\t\telement.render(tempCtx);\n\n\t\t\t\t// apply filters\n\t\t\t\tfor (var i = 0; i < this.children.length; i++) {\n\t\t\t\t\tif (typeof this.children[i].apply === 'function') {\n\t\t\t\t\t\tthis.children[i].apply(tempCtx, 0, 0, width + 2 * px, height + 2 * py);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// render on me\n\t\t\t\tctx.drawImage(c, 0, 0, width + 2 * px, height + 2 * py, x - px, y - py, width + 2 * px, height + 2 * py);\n\n\t\t\t\t// reassign filter\n\t\t\t\telement.style('filter', true).value = filter;\n\t\t\t};\n\n\t\t\tthis.render = function (ctx) {\n\t\t\t\t// NO RENDER\n\t\t\t};\n\t\t};\n\t\tsvg.Element.filter.prototype = new svg.Element.ElementBase();\n\n\t\tsvg.Element.feMorphology = function (node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.apply = function (ctx, x, y, width, height) {\n\t\t\t\t// TODO: implement\n\t\t\t};\n\t\t};\n\t\tsvg.Element.feMorphology.prototype = new svg.Element.ElementBase();\n\n\t\tsvg.Element.feComposite = function (node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.apply = function (ctx, x, y, width, height) {\n\t\t\t\t// TODO: implement\n\t\t\t};\n\t\t};\n\t\tsvg.Element.feComposite.prototype = new svg.Element.ElementBase();\n\n\t\tsvg.Element.feColorMatrix = function (node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tvar matrix = svg.ToNumberArray(this.attribute('values').value);\n\t\t\tswitch (this.attribute('type').valueOrDefault('matrix')) {// http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement\n\t\t\t\tcase 'saturate':\n\t\t\t\t\tvar s = matrix[0];\n\t\t\t\t\tmatrix = [0.213 + 0.787 * s, 0.715 - 0.715 * s, 0.072 - 0.072 * s, 0, 0, 0.213 - 0.213 * s, 0.715 + 0.285 * s, 0.072 - 0.072 * s, 0, 0, 0.213 - 0.213 * s, 0.715 - 0.715 * s, 0.072 + 0.928 * s, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'hueRotate':\n\t\t\t\t\tvar a = matrix[0] * Math.PI / 180.0;\n\t\t\t\t\tvar c = function c(m1, m2, m3) {\n\t\t\t\t\t\treturn m1 + Math.cos(a) * m2 + Math.sin(a) * m3;\n\t\t\t\t\t};\n\t\t\t\t\tmatrix = [c(0.213, 0.787, -0.213), c(0.715, -0.715, -0.715), c(0.072, -0.072, 0.928), 0, 0, c(0.213, -0.213, 0.143), c(0.715, 0.285, 0.140), c(0.072, -0.072, -0.283), 0, 0, c(0.213, -0.213, -0.787), c(0.715, -0.715, 0.715), c(0.072, 0.928, 0.072), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'luminanceToAlpha':\n\t\t\t\t\tmatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2125, 0.7154, 0.0721, 0, 0, 0, 0, 0, 0, 1];\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfunction imGet(img, x, y, width, height, rgba) {\n\t\t\t\treturn img[y * width * 4 + x * 4 + rgba];\n\t\t\t}\n\n\t\t\tfunction imSet(img, x, y, width, height, rgba, val) {\n\t\t\t\timg[y * width * 4 + x * 4 + rgba] = val;\n\t\t\t}\n\n\t\t\tfunction m(i, v) {\n\t\t\t\tvar mi = matrix[i];\n\t\t\t\treturn mi * (mi < 0 ? v - 255 : v);\n\t\t\t}\n\n\t\t\tthis.apply = function (ctx, x, y, width, height) {\n\t\t\t\t// assuming x==0 && y==0 for now\n\t\t\t\tvar srcData = ctx.getImageData(0, 0, width, height);\n\t\t\t\tfor (var y = 0; y < height; y++) {\n\t\t\t\t\tfor (var x = 0; x < width; x++) {\n\t\t\t\t\t\tvar r = imGet(srcData.data, x, y, width, height, 0);\n\t\t\t\t\t\tvar g = imGet(srcData.data, x, y, width, height, 1);\n\t\t\t\t\t\tvar b = imGet(srcData.data, x, y, width, height, 2);\n\t\t\t\t\t\tvar a = imGet(srcData.data, x, y, width, height, 3);\n\t\t\t\t\t\timSet(srcData.data, x, y, width, height, 0, m(0, r) + m(1, g) + m(2, b) + m(3, a) + m(4, 1));\n\t\t\t\t\t\timSet(srcData.data, x, y, width, height, 1, m(5, r) + m(6, g) + m(7, b) + m(8, a) + m(9, 1));\n\t\t\t\t\t\timSet(srcData.data, x, y, width, height, 2, m(10, r) + m(11, g) + m(12, b) + m(13, a) + m(14, 1));\n\t\t\t\t\t\timSet(srcData.data, x, y, width, height, 3, m(15, r) + m(16, g) + m(17, b) + m(18, a) + m(19, 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tctx.clearRect(0, 0, width, height);\n\t\t\t\tctx.putImageData(srcData, 0, 0);\n\t\t\t};\n\t\t};\n\t\tsvg.Element.feColorMatrix.prototype = new svg.Element.ElementBase();\n\n\t\tsvg.Element.feGaussianBlur = function (node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.blurRadius = Math.floor(this.attribute('stdDeviation').numValue());\n\t\t\tthis.extraFilterDistance = this.blurRadius;\n\n\t\t\tthis.apply = function (ctx, x, y, width, height) {\n\t\t\t\tif (typeof stackBlurCanvasRGBA == 'undefined') {\n\t\t\t\t\tsvg.log('ERROR: StackBlur.js must be included for blur to work');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// StackBlur requires canvas be on document\n\t\t\t\tctx.canvas.id = svg.UniqueId();\n\t\t\t\tctx.canvas.style.display = 'none';\n\t\t\t\tdocument.body.appendChild(ctx.canvas);\n\t\t\t\tstackBlurCanvasRGBA(ctx.canvas.id, x, y, width, height, this.blurRadius);\n\t\t\t\tdocument.body.removeChild(ctx.canvas);\n\t\t\t};\n\t\t};\n\t\tsvg.Element.feGaussianBlur.prototype = new svg.Element.ElementBase();\n\n\t\t// title element, do nothing\n\t\tsvg.Element.title = function (node) {};\n\t\tsvg.Element.title.prototype = new svg.Element.ElementBase();\n\n\t\t// desc element, do nothing\n\t\tsvg.Element.desc = function (node) {};\n\t\tsvg.Element.desc.prototype = new svg.Element.ElementBase();\n\n\t\tsvg.Element.MISSING = function (node) {\n\t\t\tsvg.log('ERROR: Element \\'' + node.nodeName + '\\' not yet implemented.');\n\t\t};\n\t\tsvg.Element.MISSING.prototype = new svg.Element.ElementBase();\n\n\t\t// element factory\n\t\tsvg.CreateElement = function (node) {\n\t\t\tvar className = node.nodeName.replace(/^[^:]+:/, ''); // remove namespace\n\t\t\tclassName = className.replace(/\\-/g, ''); // remove dashes\n\t\t\tvar e = null;\n\t\t\tif (typeof svg.Element[className] != 'undefined') {\n\t\t\t\te = new svg.Element[className](node);\n\t\t\t} else {\n\t\t\t\te = new svg.Element.MISSING(node);\n\t\t\t}\n\n\t\t\te.type = node.nodeName;\n\t\t\treturn e;\n\t\t};\n\n\t\t// load from url\n\t\tsvg.load = function (ctx, url) {\n\t\t\tsvg.loadXml(ctx, svg.ajax(url));\n\t\t};\n\n\t\t// load from xml\n\t\tsvg.loadXml = function (ctx, xml) {\n\t\t\tsvg.loadXmlDoc(ctx, svg.parseXml(xml));\n\t\t};\n\n\t\tsvg.loadXmlDoc = function (ctx, dom) {\n\t\t\tsvg.init(ctx);\n\n\t\t\tvar mapXY = function mapXY(p) {\n\t\t\t\tvar e = ctx.canvas;\n\t\t\t\twhile (e) {\n\t\t\t\t\tp.x -= e.offsetLeft;\n\t\t\t\t\tp.y -= e.offsetTop;\n\t\t\t\t\te = e.offsetParent;\n\t\t\t\t}\n\t\t\t\tif (window.scrollX) p.x += window.scrollX;\n\t\t\t\tif (window.scrollY) p.y += window.scrollY;\n\t\t\t\treturn p;\n\t\t\t};\n\n\t\t\t// bind mouse\n\t\t\tif (svg.opts['ignoreMouse'] != true) {\n\t\t\t\tctx.canvas.onclick = function (e) {\n\t\t\t\t\tvar p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));\n\t\t\t\t\tsvg.Mouse.onclick(p.x, p.y);\n\t\t\t\t};\n\t\t\t\tctx.canvas.onmousemove = function (e) {\n\t\t\t\t\tvar p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));\n\t\t\t\t\tsvg.Mouse.onmousemove(p.x, p.y);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar e = svg.CreateElement(dom.documentElement);\n\t\t\te.root = true;\n\t\t\te.addStylesFromStyleDefinition();\n\n\t\t\t// render loop\n\t\t\tvar isFirstRender = true;\n\t\t\tvar draw = function draw() {\n\t\t\t\tsvg.ViewPort.Clear();\n\t\t\t\tif (ctx.canvas.parentNode) svg.ViewPort.SetCurrent(ctx.canvas.parentNode.clientWidth, ctx.canvas.parentNode.clientHeight);\n\n\t\t\t\tif (svg.opts['ignoreDimensions'] != true) {\n\t\t\t\t\t// set canvas size\n\t\t\t\t\tif (e.style('width').hasValue()) {\n\t\t\t\t\t\tctx.canvas.width = e.style('width').toPixels('x');\n\t\t\t\t\t\tctx.canvas.style.width = ctx.canvas.width + 'px';\n\t\t\t\t\t}\n\t\t\t\t\tif (e.style('height').hasValue()) {\n\t\t\t\t\t\tctx.canvas.height = e.style('height').toPixels('y');\n\t\t\t\t\t\tctx.canvas.style.height = ctx.canvas.height + 'px';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar cWidth = ctx.canvas.clientWidth || ctx.canvas.width;\n\t\t\t\tvar cHeight = ctx.canvas.clientHeight || ctx.canvas.height;\n\t\t\t\tif (svg.opts['ignoreDimensions'] == true && e.style('width').hasValue() && e.style('height').hasValue()) {\n\t\t\t\t\tcWidth = e.style('width').toPixels('x');\n\t\t\t\t\tcHeight = e.style('height').toPixels('y');\n\t\t\t\t}\n\t\t\t\tsvg.ViewPort.SetCurrent(cWidth, cHeight);\n\n\t\t\t\tif (svg.opts['offsetX'] != null) e.attribute('x', true).value = svg.opts['offsetX'];\n\t\t\t\tif (svg.opts['offsetY'] != null) e.attribute('y', true).value = svg.opts['offsetY'];\n\t\t\t\tif (svg.opts['scaleWidth'] != null || svg.opts['scaleHeight'] != null) {\n\t\t\t\t\tvar xRatio = null,\n\t\t\t\t\t    yRatio = null,\n\t\t\t\t\t    viewBox = svg.ToNumberArray(e.attribute('viewBox').value);\n\n\t\t\t\t\tif (svg.opts['scaleWidth'] != null) {\n\t\t\t\t\t\tif (e.attribute('width').hasValue()) xRatio = e.attribute('width').toPixels('x') / svg.opts['scaleWidth'];else if (!isNaN(viewBox[2])) xRatio = viewBox[2] / svg.opts['scaleWidth'];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (svg.opts['scaleHeight'] != null) {\n\t\t\t\t\t\tif (e.attribute('height').hasValue()) yRatio = e.attribute('height').toPixels('y') / svg.opts['scaleHeight'];else if (!isNaN(viewBox[3])) yRatio = viewBox[3] / svg.opts['scaleHeight'];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (xRatio == null) {\n\t\t\t\t\t\txRatio = yRatio;\n\t\t\t\t\t}\n\t\t\t\t\tif (yRatio == null) {\n\t\t\t\t\t\tyRatio = xRatio;\n\t\t\t\t\t}\n\n\t\t\t\t\te.attribute('width', true).value = svg.opts['scaleWidth'];\n\t\t\t\t\te.attribute('height', true).value = svg.opts['scaleHeight'];\n\t\t\t\t\te.style('transform', true, true).value += ' scale(' + 1.0 / xRatio + ',' + 1.0 / yRatio + ')';\n\t\t\t\t}\n\n\t\t\t\t// clear and render\n\t\t\t\tif (svg.opts['ignoreClear'] != true) {\n\t\t\t\t\tctx.clearRect(0, 0, cWidth, cHeight);\n\t\t\t\t}\n\t\t\t\te.render(ctx);\n\t\t\t\tif (isFirstRender) {\n\t\t\t\t\tisFirstRender = false;\n\t\t\t\t\tif (typeof svg.opts['renderCallback'] == 'function') svg.opts['renderCallback'](dom);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar waitingForImages = true;\n\t\t\tif (svg.ImagesLoaded()) {\n\t\t\t\twaitingForImages = false;\n\t\t\t\tdraw();\n\t\t\t}\n\t\t\tsvg.intervalID = setInterval(function () {\n\t\t\t\tvar needUpdate = false;\n\n\t\t\t\tif (waitingForImages && svg.ImagesLoaded()) {\n\t\t\t\t\twaitingForImages = false;\n\t\t\t\t\tneedUpdate = true;\n\t\t\t\t}\n\n\t\t\t\t// need update from mouse events?\n\t\t\t\tif (svg.opts['ignoreMouse'] != true) {\n\t\t\t\t\tneedUpdate = needUpdate | svg.Mouse.hasEvents();\n\t\t\t\t}\n\n\t\t\t\t// need update from animations?\n\t\t\t\tif (svg.opts['ignoreAnimation'] != true) {\n\t\t\t\t\tfor (var i = 0; i < svg.Animations.length; i++) {\n\t\t\t\t\t\tneedUpdate = needUpdate | svg.Animations[i].update(1000 / svg.FRAMERATE);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// need update from redraw?\n\t\t\t\tif (typeof svg.opts['forceRedraw'] == 'function') {\n\t\t\t\t\tif (svg.opts['forceRedraw']() == true) needUpdate = true;\n\t\t\t\t}\n\n\t\t\t\t// render if needed\n\t\t\t\tif (needUpdate) {\n\t\t\t\t\tdraw();\n\t\t\t\t\tsvg.Mouse.runEvents(); // run and clear our events\n\t\t\t\t}\n\t\t\t}, 1000 / svg.FRAMERATE);\n\t\t};\n\n\t\tsvg.stop = function () {\n\t\t\tif (svg.intervalID) {\n\t\t\t\tclearInterval(svg.intervalID);\n\t\t\t}\n\t\t};\n\n\t\tsvg.Mouse = new function () {\n\t\t\tthis.events = [];\n\t\t\tthis.hasEvents = function () {\n\t\t\t\treturn this.events.length != 0;\n\t\t\t};\n\n\t\t\tthis.onclick = function (x, y) {\n\t\t\t\tthis.events.push({ type: 'onclick', x: x, y: y,\n\t\t\t\t\trun: function run(e) {\n\t\t\t\t\t\tif (e.onclick) e.onclick();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tthis.onmousemove = function (x, y) {\n\t\t\t\tthis.events.push({ type: 'onmousemove', x: x, y: y,\n\t\t\t\t\trun: function run(e) {\n\t\t\t\t\t\tif (e.onmousemove) e.onmousemove();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tthis.eventElements = [];\n\n\t\t\tthis.checkPath = function (element, ctx) {\n\t\t\t\tfor (var i = 0; i < this.events.length; i++) {\n\t\t\t\t\tvar e = this.events[i];\n\t\t\t\t\tif (ctx.isPointInPath && ctx.isPointInPath(e.x, e.y)) this.eventElements[i] = element;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.checkBoundingBox = function (element, bb) {\n\t\t\t\tfor (var i = 0; i < this.events.length; i++) {\n\t\t\t\t\tvar e = this.events[i];\n\t\t\t\t\tif (bb.isPointInBox(e.x, e.y)) this.eventElements[i] = element;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.runEvents = function () {\n\t\t\t\tsvg.ctx.canvas.style.cursor = '';\n\n\t\t\t\tfor (var i = 0; i < this.events.length; i++) {\n\t\t\t\t\tvar e = this.events[i];\n\t\t\t\t\tvar element = this.eventElements[i];\n\t\t\t\t\twhile (element) {\n\t\t\t\t\t\te.run(element);\n\t\t\t\t\t\telement = element.parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// done running, clear\n\t\t\t\tthis.events = [];\n\t\t\t\tthis.eventElements = [];\n\t\t\t};\n\t\t}();\n\n\t\treturn svg;\n\t}\n})(window);\n\nif (typeof CanvasRenderingContext2D != 'undefined') {\n\tCanvasRenderingContext2D.prototype.drawSvg = function (s, dx, dy, dw, dh) {\n\t\tcanvg(this.canvas, s, {\n\t\t\tignoreMouse: true,\n\t\t\tignoreAnimation: true,\n\t\t\tignoreDimensions: true,\n\t\t\tignoreClear: true,\n\t\t\toffsetX: dx,\n\t\t\toffsetY: dy,\n\t\t\tscaleWidth: dw,\n\t\t\tscaleHeight: dh\n\t\t});\n\t};\n}\n\n//# sourceURL=webpack:///./src/extra/cansvg.js?")
        },
        "./src/extra/json2mesh.js": /*!********************************!*\
  !*** ./src/extra/json2mesh.js ***!
  \********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof2=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};(function(global,factory){( false?undefined:_typeof2(exports))===\'object\'&&typeof module!==\'undefined\'?factory(exports): true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):undefined;})(undefined,function(exports){\'use strict\';var commonjsGlobal=typeof window!==\'undefined\'?window:typeof global!==\'undefined\'?global:typeof self!==\'undefined\'?self:{};function createCommonjsModule(fn,module){return module={exports:{}},fn(module,module.exports),module.exports;}var _global=createCommonjsModule(function(module){// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global=module.exports=typeof window!=\'undefined\'&&window.Math==Math?window:typeof self!=\'undefined\'&&self.Math==Math?self// eslint-disable-next-line no-new-func\n:Function(\'return this\')();if(typeof __g==\'number\')__g=global;// eslint-disable-line no-undef\n});var _core=createCommonjsModule(function(module){var core=module.exports={version:\'2.5.3\'};if(typeof __e==\'number\')__e=core;// eslint-disable-line no-undef\n});var _isObject=function _isObject(it){return(typeof it===\'undefined\'?\'undefined\':_typeof2(it))===\'object\'?it!==null:typeof it===\'function\';};var _anObject=function _anObject(it){if(!_isObject(it))throw TypeError(it+\' is not an object!\');return it;};var _fails=function _fails(exec){try{return!!exec();}catch(e){return true;}};// Thank\'s IE8 for his funny defineProperty\nvar _descriptors=!_fails(function(){return Object.defineProperty({},\'a\',{get:function get(){return 7;}}).a!=7;});var document$1=_global.document;// typeof document.createElement is \'object\' in old IE\nvar is=_isObject(document$1)&&_isObject(document$1.createElement);var _domCreate=function _domCreate(it){return is?document$1.createElement(it):{};};var _ie8DomDefine=!_descriptors&&!_fails(function(){return Object.defineProperty(_domCreate(\'div\'),\'a\',{get:function get(){return 7;}}).a!=7;});// 7.1.1 ToPrimitive(input [, PreferredType])\n// instead of the ES6 spec version, we didn\'t implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nvar _toPrimitive=function _toPrimitive(it,S){if(!_isObject(it))return it;var fn,val;if(S&&typeof(fn=it.toString)==\'function\'&&!_isObject(val=fn.call(it)))return val;if(typeof(fn=it.valueOf)==\'function\'&&!_isObject(val=fn.call(it)))return val;if(!S&&typeof(fn=it.toString)==\'function\'&&!_isObject(val=fn.call(it)))return val;throw TypeError("Can\'t convert object to primitive value");};var dP=Object.defineProperty;var f=_descriptors?Object.defineProperty:function defineProperty(O,P,Attributes){_anObject(O);P=_toPrimitive(P,true);_anObject(Attributes);if(_ie8DomDefine)try{return dP(O,P,Attributes);}catch(e){/* empty */}if(\'get\'in Attributes||\'set\'in Attributes)throw TypeError(\'Accessors not supported!\');if(\'value\'in Attributes)O[P]=Attributes.value;return O;};var _objectDp={f:f};var _propertyDesc=function _propertyDesc(bitmap,value){return{enumerable:!(bitmap&1),configurable:!(bitmap&2),writable:!(bitmap&4),value:value};};var _hide=_descriptors?function(object,key,value){return _objectDp.f(object,key,_propertyDesc(1,value));}:function(object,key,value){object[key]=value;return object;};var hasOwnProperty={}.hasOwnProperty;var _has=function _has(it,key){return hasOwnProperty.call(it,key);};var id=0;var px=Math.random();var _uid=function _uid(key){return\'Symbol(\'.concat(key===undefined?\'\':key,\')_\',(++id+px).toString(36));};var _redefine=createCommonjsModule(function(module){var SRC=_uid(\'src\');var TO_STRING=\'toString\';var $toString=Function[TO_STRING];var TPL=(\'\'+$toString).split(TO_STRING);_core.inspectSource=function(it){return $toString.call(it);};(module.exports=function(O,key,val,safe){var isFunction=typeof val==\'function\';if(isFunction)_has(val,\'name\')||_hide(val,\'name\',key);if(O[key]===val)return;if(isFunction)_has(val,SRC)||_hide(val,SRC,O[key]?\'\'+O[key]:TPL.join(String(key)));if(O===_global){O[key]=val;}else if(!safe){delete O[key];_hide(O,key,val);}else if(O[key]){O[key]=val;}else{_hide(O,key,val);}// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype,TO_STRING,function toString(){return typeof this==\'function\'&&this[SRC]||$toString.call(this);});});var _aFunction=function _aFunction(it){if(typeof it!=\'function\')throw TypeError(it+\' is not a function!\');return it;};// optional / simple context binding\nvar _ctx=function _ctx(fn,that,length){_aFunction(fn);if(that===undefined)return fn;switch(length){case 1:return function(a){return fn.call(that,a);};case 2:return function(a,b){return fn.call(that,a,b);};case 3:return function(a,b,c){return fn.call(that,a,b,c);};}return function()/* ...args */{return fn.apply(that,arguments);};};var PROTOTYPE=\'prototype\';var $export=function $export(type,name,source){var IS_FORCED=type&$export.F;var IS_GLOBAL=type&$export.G;var IS_STATIC=type&$export.S;var IS_PROTO=type&$export.P;var IS_BIND=type&$export.B;var target=IS_GLOBAL?_global:IS_STATIC?_global[name]||(_global[name]={}):(_global[name]||{})[PROTOTYPE];var exports=IS_GLOBAL?_core:_core[name]||(_core[name]={});var expProto=exports[PROTOTYPE]||(exports[PROTOTYPE]={});var key,own,out,exp;if(IS_GLOBAL)source=name;for(key in source){// contains in native\nown=!IS_FORCED&&target&&target[key]!==undefined;// export native or passed\nout=(own?target:source)[key];// bind timers to global for call from export context\nexp=IS_BIND&&own?_ctx(out,_global):IS_PROTO&&typeof out==\'function\'?_ctx(Function.call,out):out;// extend global\nif(target)_redefine(target,key,out,type&$export.U);// export\nif(exports[key]!=out)_hide(exports,key,exp);if(IS_PROTO&&expProto[key]!=out)expProto[key]=out;}};_global.core=_core;// type bitmap\n$export.F=1;// forced\n$export.G=2;// global\n$export.S=4;// static\n$export.P=8;// proto\n$export.B=16;// bind\n$export.W=32;// wrap\n$export.U=64;// safe\n$export.R=128;// real proto method for `library`\nvar _export=$export;var TYPED=_uid(\'typed_array\');var VIEW$1=_uid(\'view\');var ABV=!!(_global.ArrayBuffer&&_global.DataView);var CONSTR=ABV;var i=0;var l=9;var Typed;var TypedArrayConstructors=\'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array\'.split(\',\');while(i<l){if(Typed=_global[TypedArrayConstructors[i++]]){_hide(Typed.prototype,TYPED,true);_hide(Typed.prototype,VIEW$1,true);}else CONSTR=false;}var _typed={ABV:ABV,CONSTR:CONSTR,TYPED:TYPED,VIEW:VIEW$1};var _library=false;var _redefineAll=function _redefineAll(target,src,safe){for(var key in src){_redefine(target,key,src[key],safe);}return target;};var _anInstance=function _anInstance(it,Constructor,name,forbiddenField){if(!(it instanceof Constructor)||forbiddenField!==undefined&&forbiddenField in it){throw TypeError(name+\': incorrect invocation!\');}return it;};// 7.1.4 ToInteger\nvar ceil=Math.ceil;var floor=Math.floor;var _toInteger=function _toInteger(it){return isNaN(it=+it)?0:(it>0?floor:ceil)(it);};// 7.1.15 ToLength\nvar min=Math.min;var _toLength=function _toLength(it){return it>0?min(_toInteger(it),0x1fffffffffffff):0;// pow(2, 53) - 1 == 9007199254740991\n};// https://tc39.github.io/ecma262/#sec-toindex\nvar _toIndex=function _toIndex(it){if(it===undefined)return 0;var number=_toInteger(it);var length=_toLength(number);if(number!==length)throw RangeError(\'Wrong length!\');return length;};var toString={}.toString;var _cof=function _cof(it){return toString.call(it).slice(8,-1);};// fallback for non-array-like ES3 and non-enumerable old V8 strings\n// eslint-disable-next-line no-prototype-builtins\nvar _iobject=Object(\'z\').propertyIsEnumerable(0)?Object:function(it){return _cof(it)==\'String\'?it.split(\'\'):Object(it);};// 7.2.1 RequireObjectCoercible(argument)\nvar _defined=function _defined(it){if(it==undefined)throw TypeError("Can\'t call method on  "+it);return it;};// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar _toIobject=function _toIobject(it){return _iobject(_defined(it));};var max=Math.max;var min$1=Math.min;var _toAbsoluteIndex=function _toAbsoluteIndex(index,length){index=_toInteger(index);return index<0?max(index+length,0):min$1(index,length);};// false -> Array#indexOf\n// true  -> Array#includes\nvar _arrayIncludes=function _arrayIncludes(IS_INCLUDES){return function($this,el,fromIndex){var O=_toIobject($this);var length=_toLength(O.length);var index=_toAbsoluteIndex(fromIndex,length);var value;// Array#includes uses SameValueZero equality algorithm\n// eslint-disable-next-line no-self-compare\nif(IS_INCLUDES&&el!=el)while(length>index){value=O[index++];// eslint-disable-next-line no-self-compare\nif(value!=value)return true;// Array#indexOf ignores holes, Array#includes - not\n}else for(;length>index;index++){if(IS_INCLUDES||index in O){if(O[index]===el)return IS_INCLUDES||index||0;}}return!IS_INCLUDES&&-1;};};var SHARED=\'__core-js_shared__\';var store=_global[SHARED]||(_global[SHARED]={});var _shared=function _shared(key){return store[key]||(store[key]={});};var shared=_shared(\'keys\');var _sharedKey=function _sharedKey(key){return shared[key]||(shared[key]=_uid(key));};var arrayIndexOf=_arrayIncludes(false);var IE_PROTO=_sharedKey(\'IE_PROTO\');var _objectKeysInternal=function _objectKeysInternal(object,names){var O=_toIobject(object);var i=0;var result=[];var key;for(key in O){if(key!=IE_PROTO)_has(O,key)&&result.push(key);}// Don\'t enum bug & hidden keys\nwhile(names.length>i){if(_has(O,key=names[i++])){~arrayIndexOf(result,key)||result.push(key);}}return result;};// IE 8- don\'t enum bug keys\nvar _enumBugKeys=\'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf\'.split(\',\');// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar hiddenKeys=_enumBugKeys.concat(\'length\',\'prototype\');var f$1=Object.getOwnPropertyNames||function getOwnPropertyNames(O){return _objectKeysInternal(O,hiddenKeys);};var _objectGopn={f:f$1};// 7.1.13 ToObject(argument)\nvar _toObject=function _toObject(it){return Object(_defined(it));};var _arrayFill=function fill(value/* , start = 0, end = @length */){var O=_toObject(this);var length=_toLength(O.length);var aLen=arguments.length;var index=_toAbsoluteIndex(aLen>1?arguments[1]:undefined,length);var end=aLen>2?arguments[2]:undefined;var endPos=end===undefined?length:_toAbsoluteIndex(end,length);while(endPos>index){O[index++]=value;}return O;};var _wks=createCommonjsModule(function(module){var store=_shared(\'wks\');var _Symbol=_global.Symbol;var USE_SYMBOL=typeof _Symbol==\'function\';var $exports=module.exports=function(name){return store[name]||(store[name]=USE_SYMBOL&&_Symbol[name]||(USE_SYMBOL?_Symbol:_uid)(\'Symbol.\'+name));};$exports.store=store;});var def=_objectDp.f;var TAG=_wks(\'toStringTag\');var _setToStringTag=function _setToStringTag(it,tag,stat){if(it&&!_has(it=stat?it:it.prototype,TAG))def(it,TAG,{configurable:true,value:tag});};var _typedBuffer=createCommonjsModule(function(module,exports){\'use strict\';var gOPN=_objectGopn.f;var dP=_objectDp.f;var ARRAY_BUFFER=\'ArrayBuffer\';var DATA_VIEW=\'DataView\';var PROTOTYPE=\'prototype\';var WRONG_LENGTH=\'Wrong length!\';var WRONG_INDEX=\'Wrong index!\';var $ArrayBuffer=_global[ARRAY_BUFFER];var $DataView=_global[DATA_VIEW];var Math=_global.Math;var RangeError=_global.RangeError;// eslint-disable-next-line no-shadow-restricted-names\nvar Infinity=_global.Infinity;var BaseBuffer=$ArrayBuffer;var abs=Math.abs;var pow=Math.pow;var floor=Math.floor;var log=Math.log;var LN2=Math.LN2;var BUFFER=\'buffer\';var BYTE_LENGTH=\'byteLength\';var BYTE_OFFSET=\'byteOffset\';var $BUFFER=_descriptors?\'_b\':BUFFER;var $LENGTH=_descriptors?\'_l\':BYTE_LENGTH;var $OFFSET=_descriptors?\'_o\':BYTE_OFFSET;// IEEE754 conversions based on https://github.com/feross/ieee754\nfunction packIEEE754(value,mLen,nBytes){var buffer=new Array(nBytes);var eLen=nBytes*8-mLen-1;var eMax=(1<<eLen)-1;var eBias=eMax>>1;var rt=mLen===23?pow(2,-24)-pow(2,-77):0;var i=0;var s=value<0||value===0&&1/value<0?1:0;var e,m,c;value=abs(value);// eslint-disable-next-line no-self-compare\nif(value!=value||value===Infinity){// eslint-disable-next-line no-self-compare\nm=value!=value?1:0;e=eMax;}else{e=floor(log(value)/LN2);if(value*(c=pow(2,-e))<1){e--;c*=2;}if(e+eBias>=1){value+=rt/c;}else{value+=rt*pow(2,1-eBias);}if(value*c>=2){e++;c/=2;}if(e+eBias>=eMax){m=0;e=eMax;}else if(e+eBias>=1){m=(value*c-1)*pow(2,mLen);e=e+eBias;}else{m=value*pow(2,eBias-1)*pow(2,mLen);e=0;}}for(;mLen>=8;buffer[i++]=m&255,m/=256,mLen-=8){}e=e<<mLen|m;eLen+=mLen;for(;eLen>0;buffer[i++]=e&255,e/=256,eLen-=8){}buffer[--i]|=s*128;return buffer;}function unpackIEEE754(buffer,mLen,nBytes){var eLen=nBytes*8-mLen-1;var eMax=(1<<eLen)-1;var eBias=eMax>>1;var nBits=eLen-7;var i=nBytes-1;var s=buffer[i--];var e=s&127;var m;s>>=7;for(;nBits>0;e=e*256+buffer[i],i--,nBits-=8){}m=e&(1<<-nBits)-1;e>>=-nBits;nBits+=mLen;for(;nBits>0;m=m*256+buffer[i],i--,nBits-=8){}if(e===0){e=1-eBias;}else if(e===eMax){return m?NaN:s?-Infinity:Infinity;}else{m=m+pow(2,mLen);e=e-eBias;}return(s?-1:1)*m*pow(2,e-mLen);}function unpackI32(bytes){return bytes[3]<<24|bytes[2]<<16|bytes[1]<<8|bytes[0];}function packI8(it){return[it&0xff];}function packI16(it){return[it&0xff,it>>8&0xff];}function packI32(it){return[it&0xff,it>>8&0xff,it>>16&0xff,it>>24&0xff];}function packF64(it){return packIEEE754(it,52,8);}function packF32(it){return packIEEE754(it,23,4);}function addGetter(C,key,internal){dP(C[PROTOTYPE],key,{get:function get(){return this[internal];}});}function get(view,bytes,index,isLittleEndian){var numIndex=+index;var intIndex=_toIndex(numIndex);if(intIndex+bytes>view[$LENGTH])throw RangeError(WRONG_INDEX);var store=view[$BUFFER]._b;var start=intIndex+view[$OFFSET];var pack=store.slice(start,start+bytes);return isLittleEndian?pack:pack.reverse();}function set(view,bytes,index,conversion,value,isLittleEndian){var numIndex=+index;var intIndex=_toIndex(numIndex);if(intIndex+bytes>view[$LENGTH])throw RangeError(WRONG_INDEX);var store=view[$BUFFER]._b;var start=intIndex+view[$OFFSET];var pack=conversion(+value);for(var i=0;i<bytes;i++){store[start+i]=pack[isLittleEndian?i:bytes-i-1];}}if(!_typed.ABV){$ArrayBuffer=function ArrayBuffer(length){_anInstance(this,$ArrayBuffer,ARRAY_BUFFER);var byteLength=_toIndex(length);this._b=_arrayFill.call(new Array(byteLength),0);this[$LENGTH]=byteLength;};$DataView=function DataView(buffer,byteOffset,byteLength){_anInstance(this,$DataView,DATA_VIEW);_anInstance(buffer,$ArrayBuffer,DATA_VIEW);var bufferLength=buffer[$LENGTH];var offset=_toInteger(byteOffset);if(offset<0||offset>bufferLength)throw RangeError(\'Wrong offset!\');byteLength=byteLength===undefined?bufferLength-offset:_toLength(byteLength);if(offset+byteLength>bufferLength)throw RangeError(WRONG_LENGTH);this[$BUFFER]=buffer;this[$OFFSET]=offset;this[$LENGTH]=byteLength;};if(_descriptors){addGetter($ArrayBuffer,BYTE_LENGTH,\'_l\');addGetter($DataView,BUFFER,\'_b\');addGetter($DataView,BYTE_LENGTH,\'_l\');addGetter($DataView,BYTE_OFFSET,\'_o\');}_redefineAll($DataView[PROTOTYPE],{getInt8:function getInt8(byteOffset){return get(this,1,byteOffset)[0]<<24>>24;},getUint8:function getUint8(byteOffset){return get(this,1,byteOffset)[0];},getInt16:function getInt16(byteOffset/* , littleEndian */){var bytes=get(this,2,byteOffset,arguments[1]);return(bytes[1]<<8|bytes[0])<<16>>16;},getUint16:function getUint16(byteOffset/* , littleEndian */){var bytes=get(this,2,byteOffset,arguments[1]);return bytes[1]<<8|bytes[0];},getInt32:function getInt32(byteOffset/* , littleEndian */){return unpackI32(get(this,4,byteOffset,arguments[1]));},getUint32:function getUint32(byteOffset/* , littleEndian */){return unpackI32(get(this,4,byteOffset,arguments[1]))>>>0;},getFloat32:function getFloat32(byteOffset/* , littleEndian */){return unpackIEEE754(get(this,4,byteOffset,arguments[1]),23,4);},getFloat64:function getFloat64(byteOffset/* , littleEndian */){return unpackIEEE754(get(this,8,byteOffset,arguments[1]),52,8);},setInt8:function setInt8(byteOffset,value){set(this,1,byteOffset,packI8,value);},setUint8:function setUint8(byteOffset,value){set(this,1,byteOffset,packI8,value);},setInt16:function setInt16(byteOffset,value/* , littleEndian */){set(this,2,byteOffset,packI16,value,arguments[2]);},setUint16:function setUint16(byteOffset,value/* , littleEndian */){set(this,2,byteOffset,packI16,value,arguments[2]);},setInt32:function setInt32(byteOffset,value/* , littleEndian */){set(this,4,byteOffset,packI32,value,arguments[2]);},setUint32:function setUint32(byteOffset,value/* , littleEndian */){set(this,4,byteOffset,packI32,value,arguments[2]);},setFloat32:function setFloat32(byteOffset,value/* , littleEndian */){set(this,4,byteOffset,packF32,value,arguments[2]);},setFloat64:function setFloat64(byteOffset,value/* , littleEndian */){set(this,8,byteOffset,packF64,value,arguments[2]);}});}else{if(!_fails(function(){$ArrayBuffer(1);})||!_fails(function(){new $ArrayBuffer(-1);// eslint-disable-line no-new\n})||_fails(function(){new $ArrayBuffer();// eslint-disable-line no-new\nnew $ArrayBuffer(1.5);// eslint-disable-line no-new\nnew $ArrayBuffer(NaN);// eslint-disable-line no-new\nreturn $ArrayBuffer.name!=ARRAY_BUFFER;})){$ArrayBuffer=function ArrayBuffer(length){_anInstance(this,$ArrayBuffer);return new BaseBuffer(_toIndex(length));};var ArrayBufferProto=$ArrayBuffer[PROTOTYPE]=BaseBuffer[PROTOTYPE];for(var keys=gOPN(BaseBuffer),j=0,key;keys.length>j;){if(!((key=keys[j++])in $ArrayBuffer))_hide($ArrayBuffer,key,BaseBuffer[key]);}if(!_library)ArrayBufferProto.constructor=$ArrayBuffer;}// iOS Safari 7.x bug\nvar view=new $DataView(new $ArrayBuffer(2));var $setInt8=$DataView[PROTOTYPE].setInt8;view.setInt8(0,2147483648);view.setInt8(1,2147483649);if(view.getInt8(0)||!view.getInt8(1))_redefineAll($DataView[PROTOTYPE],{setInt8:function setInt8(byteOffset,value){$setInt8.call(this,byteOffset,value<<24>>24);},setUint8:function setUint8(byteOffset,value){$setInt8.call(this,byteOffset,value<<24>>24);}},true);}_setToStringTag($ArrayBuffer,ARRAY_BUFFER);_setToStringTag($DataView,DATA_VIEW);_hide($DataView[PROTOTYPE],_typed.VIEW,true);exports[ARRAY_BUFFER]=$ArrayBuffer;exports[DATA_VIEW]=$DataView;});// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar SPECIES=_wks(\'species\');var _speciesConstructor=function _speciesConstructor(O,D){var C=_anObject(O).constructor;var S;return C===undefined||(S=_anObject(C)[SPECIES])==undefined?D:_aFunction(S);};var SPECIES$1=_wks(\'species\');var _setSpecies=function _setSpecies(KEY){var C=_global[KEY];if(_descriptors&&C&&!C[SPECIES$1])_objectDp.f(C,SPECIES$1,{configurable:true,get:function get(){return this;}});};var ArrayBuffer=_global.ArrayBuffer;var $ArrayBuffer=_typedBuffer.ArrayBuffer;var $DataView=_typedBuffer.DataView;var $isView=_typed.ABV&&ArrayBuffer.isView;var $slice=$ArrayBuffer.prototype.slice;var VIEW=_typed.VIEW;var ARRAY_BUFFER=\'ArrayBuffer\';_export(_export.G+_export.W+_export.F*(ArrayBuffer!==$ArrayBuffer),{ArrayBuffer:$ArrayBuffer});_export(_export.S+_export.F*!_typed.CONSTR,ARRAY_BUFFER,{// 24.1.3.1 ArrayBuffer.isView(arg)\nisView:function isView(it){return $isView&&$isView(it)||_isObject(it)&&VIEW in it;}});_export(_export.P+_export.U+_export.F*_fails(function(){return!new $ArrayBuffer(2).slice(1,undefined).byteLength;}),ARRAY_BUFFER,{// 24.1.4.3 ArrayBuffer.prototype.slice(start, end)\nslice:function slice(start,end){if($slice!==undefined&&end===undefined)return $slice.call(_anObject(this),start);// FF fix\nvar len=_anObject(this).byteLength;var first=_toAbsoluteIndex(start,len);var final=_toAbsoluteIndex(end===undefined?len:end,len);var result=new(_speciesConstructor(this,$ArrayBuffer))(_toLength(final-first));var viewS=new $DataView(this);var viewT=new $DataView(result);var index=0;while(first<final){viewT.setUint8(index++,viewS.getUint8(first++));}return result;}});_setSpecies(ARRAY_BUFFER);// getting tag from 19.1.3.6 Object.prototype.toString()\nvar TAG$1=_wks(\'toStringTag\');// ES3 wrong here\nvar ARG=_cof(function(){return arguments;}())==\'Arguments\';// fallback for IE11 Script Access Denied error\nvar tryGet=function tryGet(it,key){try{return it[key];}catch(e){/* empty */}};var _classof=function _classof(it){var O,T,B;return it===undefined?\'Undefined\':it===null?\'Null\'// @@toStringTag case\n:typeof(T=tryGet(O=Object(it),TAG$1))==\'string\'?T// builtinTag case\n:ARG?_cof(O)// ES3 arguments fallback\n:(B=_cof(O))==\'Object\'&&typeof O.callee==\'function\'?\'Arguments\':B;};var _iterators={};// check on default Array iterator\nvar ITERATOR=_wks(\'iterator\');var ArrayProto=Array.prototype;var _isArrayIter=function _isArrayIter(it){return it!==undefined&&(_iterators.Array===it||ArrayProto[ITERATOR]===it);};// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar _objectKeys=Object.keys||function keys(O){return _objectKeysInternal(O,_enumBugKeys);};var _objectDps=_descriptors?Object.defineProperties:function defineProperties(O,Properties){_anObject(O);var keys=_objectKeys(Properties);var length=keys.length;var i=0;var P;while(length>i){_objectDp.f(O,P=keys[i++],Properties[P]);}return O;};var document$2=_global.document;var _html=document$2&&document$2.documentElement;// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar IE_PROTO$1=_sharedKey(\'IE_PROTO\');var Empty=function Empty(){/* empty */};var PROTOTYPE$1=\'prototype\';// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar _createDict=function createDict(){// Thrash, waste and sodomy: IE GC bug\nvar iframe=_domCreate(\'iframe\');var i=_enumBugKeys.length;var lt=\'<\';var gt=\'>\';var iframeDocument;iframe.style.display=\'none\';_html.appendChild(iframe);iframe.src=\'javascript:\';// eslint-disable-line no-script-url\n// createDict = iframe.contentWindow.Object;\n// html.removeChild(iframe);\niframeDocument=iframe.contentWindow.document;iframeDocument.open();iframeDocument.write(lt+\'script\'+gt+\'document.F=Object\'+lt+\'/script\'+gt);iframeDocument.close();_createDict=iframeDocument.F;while(i--){delete _createDict[PROTOTYPE$1][_enumBugKeys[i]];}return _createDict();};var _objectCreate=Object.create||function create(O,Properties){var result;if(O!==null){Empty[PROTOTYPE$1]=_anObject(O);result=new Empty();Empty[PROTOTYPE$1]=null;// add "__proto__" for Object.getPrototypeOf polyfill\nresult[IE_PROTO$1]=O;}else result=_createDict();return Properties===undefined?result:_objectDps(result,Properties);};// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar IE_PROTO$2=_sharedKey(\'IE_PROTO\');var ObjectProto=Object.prototype;var _objectGpo=Object.getPrototypeOf||function(O){O=_toObject(O);if(_has(O,IE_PROTO$2))return O[IE_PROTO$2];if(typeof O.constructor==\'function\'&&O instanceof O.constructor){return O.constructor.prototype;}return O instanceof Object?ObjectProto:null;};var ITERATOR$1=_wks(\'iterator\');var core_getIteratorMethod=_core.getIteratorMethod=function(it){if(it!=undefined)return it[ITERATOR$1]||it[\'@@iterator\']||_iterators[_classof(it)];};// 7.2.2 IsArray(argument)\nvar _isArray=Array.isArray||function isArray(arg){return _cof(arg)==\'Array\';};var SPECIES$2=_wks(\'species\');var _arraySpeciesConstructor=function _arraySpeciesConstructor(original){var C;if(_isArray(original)){C=original.constructor;// cross-realm fallback\nif(typeof C==\'function\'&&(C===Array||_isArray(C.prototype)))C=undefined;if(_isObject(C)){C=C[SPECIES$2];if(C===null)C=undefined;}}return C===undefined?Array:C;};// 9.4.2.3 ArraySpeciesCreate(originalArray, length)\nvar _arraySpeciesCreate=function _arraySpeciesCreate(original,length){return new(_arraySpeciesConstructor(original))(length);};// 0 -> Array#forEach\n// 1 -> Array#map\n// 2 -> Array#filter\n// 3 -> Array#some\n// 4 -> Array#every\n// 5 -> Array#find\n// 6 -> Array#findIndex\nvar _arrayMethods=function _arrayMethods(TYPE,$create){var IS_MAP=TYPE==1;var IS_FILTER=TYPE==2;var IS_SOME=TYPE==3;var IS_EVERY=TYPE==4;var IS_FIND_INDEX=TYPE==6;var NO_HOLES=TYPE==5||IS_FIND_INDEX;var create=$create||_arraySpeciesCreate;return function($this,callbackfn,that){var O=_toObject($this);var self=_iobject(O);var f=_ctx(callbackfn,that,3);var length=_toLength(self.length);var index=0;var result=IS_MAP?create($this,length):IS_FILTER?create($this,0):undefined;var val,res;for(;length>index;index++){if(NO_HOLES||index in self){val=self[index];res=f(val,index,O);if(TYPE){if(IS_MAP)result[index]=res;// map\nelse if(res)switch(TYPE){case 3:return true;// some\ncase 5:return val;// find\ncase 6:return index;// findIndex\ncase 2:result.push(val);// filter\n}else if(IS_EVERY)return false;// every\n}}}return IS_FIND_INDEX?-1:IS_SOME||IS_EVERY?IS_EVERY:result;};};// 22.1.3.31 Array.prototype[@@unscopables]\nvar UNSCOPABLES=_wks(\'unscopables\');var ArrayProto$1=Array.prototype;if(ArrayProto$1[UNSCOPABLES]==undefined)_hide(ArrayProto$1,UNSCOPABLES,{});var _addToUnscopables=function _addToUnscopables(key){ArrayProto$1[UNSCOPABLES][key]=true;};var _iterStep=function _iterStep(done,value){return{value:value,done:!!done};};var IteratorPrototype={};// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n_hide(IteratorPrototype,_wks(\'iterator\'),function(){return this;});var _iterCreate=function _iterCreate(Constructor,NAME,next){Constructor.prototype=_objectCreate(IteratorPrototype,{next:_propertyDesc(1,next)});_setToStringTag(Constructor,NAME+\' Iterator\');};var ITERATOR$2=_wks(\'iterator\');var BUGGY=!([].keys&&\'next\'in[].keys());// Safari has buggy iterators w/o `next`\nvar FF_ITERATOR=\'@@iterator\';var KEYS=\'keys\';var VALUES=\'values\';var returnThis=function returnThis(){return this;};var _iterDefine=function _iterDefine(Base,NAME,Constructor,next,DEFAULT,IS_SET,FORCED){_iterCreate(Constructor,NAME,next);var getMethod=function getMethod(kind){if(!BUGGY&&kind in proto)return proto[kind];switch(kind){case KEYS:return function keys(){return new Constructor(this,kind);};case VALUES:return function values(){return new Constructor(this,kind);};}return function entries(){return new Constructor(this,kind);};};var TAG=NAME+\' Iterator\';var DEF_VALUES=DEFAULT==VALUES;var VALUES_BUG=false;var proto=Base.prototype;var $native=proto[ITERATOR$2]||proto[FF_ITERATOR]||DEFAULT&&proto[DEFAULT];var $default=!BUGGY&&$native||getMethod(DEFAULT);var $entries=DEFAULT?!DEF_VALUES?$default:getMethod(\'entries\'):undefined;var $anyNative=NAME==\'Array\'?proto.entries||$native:$native;var methods,key,IteratorPrototype;// Fix native\nif($anyNative){IteratorPrototype=_objectGpo($anyNative.call(new Base()));if(IteratorPrototype!==Object.prototype&&IteratorPrototype.next){// Set @@toStringTag to native iterators\n_setToStringTag(IteratorPrototype,TAG,true);// fix for some old engines\nif(!_library&&!_has(IteratorPrototype,ITERATOR$2))_hide(IteratorPrototype,ITERATOR$2,returnThis);}}// fix Array#{values, @@iterator}.name in V8 / FF\nif(DEF_VALUES&&$native&&$native.name!==VALUES){VALUES_BUG=true;$default=function values(){return $native.call(this);};}// Define iterator\nif((!_library||FORCED)&&(BUGGY||VALUES_BUG||!proto[ITERATOR$2])){_hide(proto,ITERATOR$2,$default);}// Plug for library\n_iterators[NAME]=$default;_iterators[TAG]=returnThis;if(DEFAULT){methods={values:DEF_VALUES?$default:getMethod(VALUES),keys:IS_SET?$default:getMethod(KEYS),entries:$entries};if(FORCED)for(key in methods){if(!(key in proto))_redefine(proto,key,methods[key]);}else _export(_export.P+_export.F*(BUGGY||VALUES_BUG),NAME,methods);}return methods;};// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nvar es6_array_iterator=_iterDefine(Array,\'Array\',function(iterated,kind){this._t=_toIobject(iterated);// target\nthis._i=0;// next index\nthis._k=kind;// kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n},function(){var O=this._t;var kind=this._k;var index=this._i++;if(!O||index>=O.length){this._t=undefined;return _iterStep(1);}if(kind==\'keys\')return _iterStep(0,index);if(kind==\'values\')return _iterStep(0,O[index]);return _iterStep(0,[index,O[index]]);},\'values\');// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\n_iterators.Arguments=_iterators.Array;_addToUnscopables(\'keys\');_addToUnscopables(\'values\');_addToUnscopables(\'entries\');var ITERATOR$3=_wks(\'iterator\');var SAFE_CLOSING=false;try{var riter=[7][ITERATOR$3]();riter[\'return\']=function(){SAFE_CLOSING=true;};// eslint-disable-next-line no-throw-literal\nArray.from(riter,function(){throw 2;});}catch(e){/* empty */}var _iterDetect=function _iterDetect(exec,skipClosing){if(!skipClosing&&!SAFE_CLOSING)return false;var safe=false;try{var arr=[7];var iter=arr[ITERATOR$3]();iter.next=function(){return{done:safe=true};};arr[ITERATOR$3]=function(){return iter;};exec(arr);}catch(e){/* empty */}return safe;};var _arrayCopyWithin=[].copyWithin||function copyWithin(target/* = 0 */,start/* = 0, end = @length */){var O=_toObject(this);var len=_toLength(O.length);var to=_toAbsoluteIndex(target,len);var from=_toAbsoluteIndex(start,len);var end=arguments.length>2?arguments[2]:undefined;var count=Math.min((end===undefined?len:_toAbsoluteIndex(end,len))-from,len-to);var inc=1;if(from<to&&to<from+count){inc=-1;from+=count-1;to+=count-1;}while(count--\x3e0){if(from in O)O[to]=O[from];else delete O[to];to+=inc;from+=inc;}return O;};var f$3={}.propertyIsEnumerable;var _objectPie={f:f$3};var gOPD=Object.getOwnPropertyDescriptor;var f$2=_descriptors?gOPD:function getOwnPropertyDescriptor(O,P){O=_toIobject(O);P=_toPrimitive(P,true);if(_ie8DomDefine)try{return gOPD(O,P);}catch(e){/* empty */}if(_has(O,P))return _propertyDesc(!_objectPie.f.call(O,P),O[P]);};var _objectGopd={f:f$2};var _typedArray=createCommonjsModule(function(module){\'use strict\';if(_descriptors){var LIBRARY=_library;var global=_global;var fails=_fails;var $export=_export;var $typed=_typed;var $buffer=_typedBuffer;var ctx=_ctx;var anInstance=_anInstance;var propertyDesc=_propertyDesc;var hide=_hide;var redefineAll=_redefineAll;var toInteger=_toInteger;var toLength=_toLength;var toIndex=_toIndex;var toAbsoluteIndex=_toAbsoluteIndex;var toPrimitive=_toPrimitive;var has=_has;var classof$$1=_classof;var isObject=_isObject;var toObject=_toObject;var isArrayIter$$1=_isArrayIter;var create=_objectCreate;var getPrototypeOf=_objectGpo;var gOPN=_objectGopn.f;var getIterFn$$1=core_getIteratorMethod;var uid=_uid;var wks=_wks;var createArrayMethod=_arrayMethods;var createArrayIncludes=_arrayIncludes;var speciesConstructor=_speciesConstructor;var ArrayIterators=es6_array_iterator;var Iterators$$1=_iterators;var $iterDetect=_iterDetect;var setSpecies=_setSpecies;var arrayFill=_arrayFill;var arrayCopyWithin=_arrayCopyWithin;var $DP=_objectDp;var $GOPD=_objectGopd;var dP=$DP.f;var gOPD=$GOPD.f;var RangeError=global.RangeError;var TypeError=global.TypeError;var Uint8Array=global.Uint8Array;var ARRAY_BUFFER=\'ArrayBuffer\';var SHARED_BUFFER=\'Shared\'+ARRAY_BUFFER;var BYTES_PER_ELEMENT=\'BYTES_PER_ELEMENT\';var PROTOTYPE=\'prototype\';var ArrayProto=Array[PROTOTYPE];var $ArrayBuffer=$buffer.ArrayBuffer;var $DataView=$buffer.DataView;var arrayForEach=createArrayMethod(0);var arrayFilter=createArrayMethod(2);var arraySome=createArrayMethod(3);var arrayEvery=createArrayMethod(4);var arrayFind=createArrayMethod(5);var arrayFindIndex=createArrayMethod(6);var arrayIncludes=createArrayIncludes(true);var arrayIndexOf=createArrayIncludes(false);var arrayValues=ArrayIterators.values;var arrayKeys=ArrayIterators.keys;var arrayEntries=ArrayIterators.entries;var arrayLastIndexOf=ArrayProto.lastIndexOf;var arrayReduce=ArrayProto.reduce;var arrayReduceRight=ArrayProto.reduceRight;var arrayJoin=ArrayProto.join;var arraySort=ArrayProto.sort;var arraySlice=ArrayProto.slice;var arrayToString=ArrayProto.toString;var arrayToLocaleString=ArrayProto.toLocaleString;var ITERATOR=wks(\'iterator\');var TAG=wks(\'toStringTag\');var TYPED_CONSTRUCTOR=uid(\'typed_constructor\');var DEF_CONSTRUCTOR=uid(\'def_constructor\');var ALL_CONSTRUCTORS=$typed.CONSTR;var TYPED_ARRAY=$typed.TYPED;var VIEW=$typed.VIEW;var WRONG_LENGTH=\'Wrong length!\';var $map=createArrayMethod(1,function(O,length){return allocate(speciesConstructor(O,O[DEF_CONSTRUCTOR]),length);});var LITTLE_ENDIAN=fails(function(){// eslint-disable-next-line no-undef\nreturn new Uint8Array(new Uint16Array([1]).buffer)[0]===1;});var FORCED_SET=!!Uint8Array&&!!Uint8Array[PROTOTYPE].set&&fails(function(){new Uint8Array(1).set({});});var toOffset=function toOffset(it,BYTES){var offset=toInteger(it);if(offset<0||offset%BYTES)throw RangeError(\'Wrong offset!\');return offset;};var validate=function validate(it){if(isObject(it)&&TYPED_ARRAY in it)return it;throw TypeError(it+\' is not a typed array!\');};var allocate=function allocate(C,length){if(!(isObject(C)&&TYPED_CONSTRUCTOR in C)){throw TypeError(\'It is not a typed array constructor!\');}return new C(length);};var speciesFromList=function speciesFromList(O,list){return fromList(speciesConstructor(O,O[DEF_CONSTRUCTOR]),list);};var fromList=function fromList(C,list){var index=0;var length=list.length;var result=allocate(C,length);while(length>index){result[index]=list[index++];}return result;};var addGetter=function addGetter(it,key,internal){dP(it,key,{get:function get(){return this._d[internal];}});};var $from=function from(source/* , mapfn, thisArg */){var O=toObject(source);var aLen=arguments.length;var mapfn=aLen>1?arguments[1]:undefined;var mapping=mapfn!==undefined;var iterFn=getIterFn$$1(O);var i,length,values,result,step,iterator;if(iterFn!=undefined&&!isArrayIter$$1(iterFn)){for(iterator=iterFn.call(O),values=[],i=0;!(step=iterator.next()).done;i++){values.push(step.value);}O=values;}if(mapping&&aLen>2)mapfn=ctx(mapfn,arguments[2],2);for(i=0,length=toLength(O.length),result=allocate(this,length);length>i;i++){result[i]=mapping?mapfn(O[i],i):O[i];}return result;};var $of=function of()/* ...items */{var index=0;var length=arguments.length;var result=allocate(this,length);while(length>index){result[index]=arguments[index++];}return result;};// iOS Safari 6.x fails here\nvar TO_LOCALE_BUG=!!Uint8Array&&fails(function(){arrayToLocaleString.call(new Uint8Array(1));});var $toLocaleString=function toLocaleString(){return arrayToLocaleString.apply(TO_LOCALE_BUG?arraySlice.call(validate(this)):validate(this),arguments);};var proto={copyWithin:function copyWithin(target,start/* , end */){return arrayCopyWithin.call(validate(this),target,start,arguments.length>2?arguments[2]:undefined);},every:function every(callbackfn/* , thisArg */){return arrayEvery(validate(this),callbackfn,arguments.length>1?arguments[1]:undefined);},fill:function fill(value/* , start, end */){// eslint-disable-line no-unused-vars\nreturn arrayFill.apply(validate(this),arguments);},filter:function filter(callbackfn/* , thisArg */){return speciesFromList(this,arrayFilter(validate(this),callbackfn,arguments.length>1?arguments[1]:undefined));},find:function find(predicate/* , thisArg */){return arrayFind(validate(this),predicate,arguments.length>1?arguments[1]:undefined);},findIndex:function findIndex(predicate/* , thisArg */){return arrayFindIndex(validate(this),predicate,arguments.length>1?arguments[1]:undefined);},forEach:function forEach(callbackfn/* , thisArg */){arrayForEach(validate(this),callbackfn,arguments.length>1?arguments[1]:undefined);},indexOf:function indexOf(searchElement/* , fromIndex */){return arrayIndexOf(validate(this),searchElement,arguments.length>1?arguments[1]:undefined);},includes:function includes(searchElement/* , fromIndex */){return arrayIncludes(validate(this),searchElement,arguments.length>1?arguments[1]:undefined);},join:function join(separator){// eslint-disable-line no-unused-vars\nreturn arrayJoin.apply(validate(this),arguments);},lastIndexOf:function lastIndexOf(searchElement/* , fromIndex */){// eslint-disable-line no-unused-vars\nreturn arrayLastIndexOf.apply(validate(this),arguments);},map:function map(mapfn/* , thisArg */){return $map(validate(this),mapfn,arguments.length>1?arguments[1]:undefined);},reduce:function reduce(callbackfn/* , initialValue */){// eslint-disable-line no-unused-vars\nreturn arrayReduce.apply(validate(this),arguments);},reduceRight:function reduceRight(callbackfn/* , initialValue */){// eslint-disable-line no-unused-vars\nreturn arrayReduceRight.apply(validate(this),arguments);},reverse:function reverse(){var that=this;var length=validate(that).length;var middle=Math.floor(length/2);var index=0;var value;while(index<middle){value=that[index];that[index++]=that[--length];that[length]=value;}return that;},some:function some(callbackfn/* , thisArg */){return arraySome(validate(this),callbackfn,arguments.length>1?arguments[1]:undefined);},sort:function sort(comparefn){return arraySort.call(validate(this),comparefn);},subarray:function subarray(begin,end){var O=validate(this);var length=O.length;var $begin=toAbsoluteIndex(begin,length);return new(speciesConstructor(O,O[DEF_CONSTRUCTOR]))(O.buffer,O.byteOffset+$begin*O.BYTES_PER_ELEMENT,toLength((end===undefined?length:toAbsoluteIndex(end,length))-$begin));}};var $slice=function slice(start,end){return speciesFromList(this,arraySlice.call(validate(this),start,end));};var $set=function set(arrayLike/* , offset */){validate(this);var offset=toOffset(arguments[1],1);var length=this.length;var src=toObject(arrayLike);var len=toLength(src.length);var index=0;if(len+offset>length)throw RangeError(WRONG_LENGTH);while(index<len){this[offset+index]=src[index++];}};var $iterators$$1={entries:function entries(){return arrayEntries.call(validate(this));},keys:function keys(){return arrayKeys.call(validate(this));},values:function values(){return arrayValues.call(validate(this));}};var isTAIndex=function isTAIndex(target,key){return isObject(target)&&target[TYPED_ARRAY]&&(typeof key===\'undefined\'?\'undefined\':_typeof2(key))!=\'symbol\'&&key in target&&String(+key)==String(key);};var $getDesc=function getOwnPropertyDescriptor(target,key){return isTAIndex(target,key=toPrimitive(key,true))?propertyDesc(2,target[key]):gOPD(target,key);};var $setDesc=function defineProperty(target,key,desc){if(isTAIndex(target,key=toPrimitive(key,true))&&isObject(desc)&&has(desc,\'value\')&&!has(desc,\'get\')&&!has(desc,\'set\')// TODO: add validation descriptor w/o calling accessors\n&&!desc.configurable&&(!has(desc,\'writable\')||desc.writable)&&(!has(desc,\'enumerable\')||desc.enumerable)){target[key]=desc.value;return target;}return dP(target,key,desc);};if(!ALL_CONSTRUCTORS){$GOPD.f=$getDesc;$DP.f=$setDesc;}$export($export.S+$export.F*!ALL_CONSTRUCTORS,\'Object\',{getOwnPropertyDescriptor:$getDesc,defineProperty:$setDesc});if(fails(function(){arrayToString.call({});})){arrayToString=arrayToLocaleString=function toString(){return arrayJoin.call(this);};}var $TypedArrayPrototype$=redefineAll({},proto);redefineAll($TypedArrayPrototype$,$iterators$$1);hide($TypedArrayPrototype$,ITERATOR,$iterators$$1.values);redefineAll($TypedArrayPrototype$,{slice:$slice,set:$set,constructor:function constructor(){/* noop */},toString:arrayToString,toLocaleString:$toLocaleString});addGetter($TypedArrayPrototype$,\'buffer\',\'b\');addGetter($TypedArrayPrototype$,\'byteOffset\',\'o\');addGetter($TypedArrayPrototype$,\'byteLength\',\'l\');addGetter($TypedArrayPrototype$,\'length\',\'e\');dP($TypedArrayPrototype$,TAG,{get:function get(){return this[TYPED_ARRAY];}});// eslint-disable-next-line max-statements\nmodule.exports=function(KEY,BYTES,wrapper,CLAMPED){CLAMPED=!!CLAMPED;var NAME=KEY+(CLAMPED?\'Clamped\':\'\')+\'Array\';var GETTER=\'get\'+KEY;var SETTER=\'set\'+KEY;var TypedArray=global[NAME];var Base=TypedArray||{};var TAC=TypedArray&&getPrototypeOf(TypedArray);var FORCED=!TypedArray||!$typed.ABV;var O={};var TypedArrayPrototype=TypedArray&&TypedArray[PROTOTYPE];var getter=function getter(that,index){var data=that._d;return data.v[GETTER](index*BYTES+data.o,LITTLE_ENDIAN);};var setter=function setter(that,index,value){var data=that._d;if(CLAMPED)value=(value=Math.round(value))<0?0:value>0xff?0xff:value&0xff;data.v[SETTER](index*BYTES+data.o,value,LITTLE_ENDIAN);};var addElement=function addElement(that,index){dP(that,index,{get:function get(){return getter(this,index);},set:function set(value){return setter(this,index,value);},enumerable:true});};if(FORCED){TypedArray=wrapper(function(that,data,$offset,$length){anInstance(that,TypedArray,NAME,\'_d\');var index=0;var offset=0;var buffer,byteLength,length,klass;if(!isObject(data)){length=toIndex(data);byteLength=length*BYTES;buffer=new $ArrayBuffer(byteLength);}else if(data instanceof $ArrayBuffer||(klass=classof$$1(data))==ARRAY_BUFFER||klass==SHARED_BUFFER){buffer=data;offset=toOffset($offset,BYTES);var $len=data.byteLength;if($length===undefined){if($len%BYTES)throw RangeError(WRONG_LENGTH);byteLength=$len-offset;if(byteLength<0)throw RangeError(WRONG_LENGTH);}else{byteLength=toLength($length)*BYTES;if(byteLength+offset>$len)throw RangeError(WRONG_LENGTH);}length=byteLength/BYTES;}else if(TYPED_ARRAY in data){return fromList(TypedArray,data);}else{return $from.call(TypedArray,data);}hide(that,\'_d\',{b:buffer,o:offset,l:byteLength,e:length,v:new $DataView(buffer)});while(index<length){addElement(that,index++);}});TypedArrayPrototype=TypedArray[PROTOTYPE]=create($TypedArrayPrototype$);hide(TypedArrayPrototype,\'constructor\',TypedArray);}else if(!fails(function(){TypedArray(1);})||!fails(function(){new TypedArray(-1);// eslint-disable-line no-new\n})||!$iterDetect(function(iter){new TypedArray();// eslint-disable-line no-new\nnew TypedArray(null);// eslint-disable-line no-new\nnew TypedArray(1.5);// eslint-disable-line no-new\nnew TypedArray(iter);// eslint-disable-line no-new\n},true)){TypedArray=wrapper(function(that,data,$offset,$length){anInstance(that,TypedArray,NAME);var klass;// `ws` module bug, temporarily remove validation length for Uint8Array\n// https://github.com/websockets/ws/pull/645\nif(!isObject(data))return new Base(toIndex(data));if(data instanceof $ArrayBuffer||(klass=classof$$1(data))==ARRAY_BUFFER||klass==SHARED_BUFFER){return $length!==undefined?new Base(data,toOffset($offset,BYTES),$length):$offset!==undefined?new Base(data,toOffset($offset,BYTES)):new Base(data);}if(TYPED_ARRAY in data)return fromList(TypedArray,data);return $from.call(TypedArray,data);});arrayForEach(TAC!==Function.prototype?gOPN(Base).concat(gOPN(TAC)):gOPN(Base),function(key){if(!(key in TypedArray))hide(TypedArray,key,Base[key]);});TypedArray[PROTOTYPE]=TypedArrayPrototype;if(!LIBRARY)TypedArrayPrototype.constructor=TypedArray;}var $nativeIterator=TypedArrayPrototype[ITERATOR];var CORRECT_ITER_NAME=!!$nativeIterator&&($nativeIterator.name==\'values\'||$nativeIterator.name==undefined);var $iterator=$iterators$$1.values;hide(TypedArray,TYPED_CONSTRUCTOR,true);hide(TypedArrayPrototype,TYPED_ARRAY,NAME);hide(TypedArrayPrototype,VIEW,true);hide(TypedArrayPrototype,DEF_CONSTRUCTOR,TypedArray);if(CLAMPED?new TypedArray(1)[TAG]!=NAME:!(TAG in TypedArrayPrototype)){dP(TypedArrayPrototype,TAG,{get:function get(){return NAME;}});}O[NAME]=TypedArray;$export($export.G+$export.W+$export.F*(TypedArray!=Base),O);$export($export.S,NAME,{BYTES_PER_ELEMENT:BYTES});$export($export.S+$export.F*fails(function(){Base.of.call(TypedArray,1);}),NAME,{from:$from,of:$of});if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype,BYTES_PER_ELEMENT,BYTES);$export($export.P,NAME,proto);setSpecies(NAME);$export($export.P+$export.F*FORCED_SET,NAME,{set:$set});$export($export.P+$export.F*!CORRECT_ITER_NAME,NAME,$iterators$$1);if(!LIBRARY&&TypedArrayPrototype.toString!=arrayToString)TypedArrayPrototype.toString=arrayToString;$export($export.P+$export.F*fails(function(){new TypedArray(1).slice();}),NAME,{slice:$slice});$export($export.P+$export.F*(fails(function(){return[1,2].toLocaleString()!=new TypedArray([1,2]).toLocaleString();})||!fails(function(){TypedArrayPrototype.toLocaleString.call([1,2]);})),NAME,{toLocaleString:$toLocaleString});Iterators$$1[NAME]=CORRECT_ITER_NAME?$nativeIterator:$iterator;if(!LIBRARY&&!CORRECT_ITER_NAME)hide(TypedArrayPrototype,ITERATOR,$iterator);};}else module.exports=function(){/* empty */};});_typedArray(\'Int8\',1,function(init){return function Int8Array(data,byteOffset,length){return init(this,data,byteOffset,length);};});_typedArray(\'Uint8\',1,function(init){return function Uint8Array(data,byteOffset,length){return init(this,data,byteOffset,length);};});_typedArray(\'Uint8\',1,function(init){return function Uint8ClampedArray(data,byteOffset,length){return init(this,data,byteOffset,length);};},true);_typedArray(\'Int16\',2,function(init){return function Int16Array(data,byteOffset,length){return init(this,data,byteOffset,length);};});_typedArray(\'Uint16\',2,function(init){return function Uint16Array(data,byteOffset,length){return init(this,data,byteOffset,length);};});_typedArray(\'Int32\',4,function(init){return function Int32Array(data,byteOffset,length){return init(this,data,byteOffset,length);};});_typedArray(\'Uint32\',4,function(init){return function Uint32Array(data,byteOffset,length){return init(this,data,byteOffset,length);};});_typedArray(\'Float32\',4,function(init){return function Float32Array(data,byteOffset,length){return init(this,data,byteOffset,length);};});_typedArray(\'Float64\',8,function(init){return function Float64Array(data,byteOffset,length){return init(this,data,byteOffset,length);};});// call something on iterator step with safe closing on error\nvar _iterCall=function _iterCall(iterator,fn,value,entries){try{return entries?fn(_anObject(value)[0],value[1]):fn(value);// 7.4.6 IteratorClose(iterator, completion)\n}catch(e){var ret=iterator[\'return\'];if(ret!==undefined)_anObject(ret.call(iterator));throw e;}};var _forOf=createCommonjsModule(function(module){var BREAK={};var RETURN={};var exports=module.exports=function(iterable,entries,fn,that,ITERATOR){var iterFn=ITERATOR?function(){return iterable;}:core_getIteratorMethod(iterable);var f=_ctx(fn,that,entries?2:1);var index=0;var length,step,iterator,result;if(typeof iterFn!=\'function\')throw TypeError(iterable+\' is not iterable!\');// fast case for arrays with default iterator\nif(_isArrayIter(iterFn))for(length=_toLength(iterable.length);length>index;index++){result=entries?f(_anObject(step=iterable[index])[0],step[1]):f(iterable[index]);if(result===BREAK||result===RETURN)return result;}else for(iterator=iterFn.call(iterable);!(step=iterator.next()).done;){result=_iterCall(iterator,f,step.value,entries);if(result===BREAK||result===RETURN)return result;}};exports.BREAK=BREAK;exports.RETURN=RETURN;});var _meta=createCommonjsModule(function(module){var META=_uid(\'meta\');var setDesc=_objectDp.f;var id=0;var isExtensible=Object.isExtensible||function(){return true;};var FREEZE=!_fails(function(){return isExtensible(Object.preventExtensions({}));});var setMeta=function setMeta(it){setDesc(it,META,{value:{i:\'O\'+ ++id,// object ID\nw:{}// weak collections IDs\n}});};var fastKey=function fastKey(it,create){// return primitive with prefix\nif(!_isObject(it))return(typeof it===\'undefined\'?\'undefined\':_typeof2(it))==\'symbol\'?it:(typeof it==\'string\'?\'S\':\'P\')+it;if(!_has(it,META)){// can\'t set metadata to uncaught frozen object\nif(!isExtensible(it))return\'F\';// not necessary to add metadata\nif(!create)return\'E\';// add missing metadata\nsetMeta(it);// return object ID\n}return it[META].i;};var getWeak=function getWeak(it,create){if(!_has(it,META)){// can\'t set metadata to uncaught frozen object\nif(!isExtensible(it))return true;// not necessary to add metadata\nif(!create)return false;// add missing metadata\nsetMeta(it);// return hash weak collections IDs\n}return it[META].w;};// add metadata on freeze-family methods calling\nvar onFreeze=function onFreeze(it){if(FREEZE&&meta.NEED&&isExtensible(it)&&!_has(it,META))setMeta(it);return it;};var meta=module.exports={KEY:META,NEED:false,fastKey:fastKey,getWeak:getWeak,onFreeze:onFreeze};});var _validateCollection=function _validateCollection(it,TYPE){if(!_isObject(it)||it._t!==TYPE)throw TypeError(\'Incompatible receiver, \'+TYPE+\' required!\');return it;};var dP$1=_objectDp.f;var fastKey=_meta.fastKey;var SIZE=_descriptors?\'_s\':\'size\';var getEntry=function getEntry(that,key){// fast case\nvar index=fastKey(key);var entry;if(index!==\'F\')return that._i[index];// frozen object case\nfor(entry=that._f;entry;entry=entry.n){if(entry.k==key)return entry;}};var _collectionStrong={getConstructor:function getConstructor(wrapper,NAME,IS_MAP,ADDER){var C=wrapper(function(that,iterable){_anInstance(that,C,NAME,\'_i\');that._t=NAME;// collection type\nthat._i=_objectCreate(null);// index\nthat._f=undefined;// first entry\nthat._l=undefined;// last entry\nthat[SIZE]=0;// size\nif(iterable!=undefined)_forOf(iterable,IS_MAP,that[ADDER],that);});_redefineAll(C.prototype,{// 23.1.3.1 Map.prototype.clear()\n// 23.2.3.2 Set.prototype.clear()\nclear:function clear(){for(var that=_validateCollection(this,NAME),data=that._i,entry=that._f;entry;entry=entry.n){entry.r=true;if(entry.p)entry.p=entry.p.n=undefined;delete data[entry.i];}that._f=that._l=undefined;that[SIZE]=0;},// 23.1.3.3 Map.prototype.delete(key)\n// 23.2.3.4 Set.prototype.delete(value)\n\'delete\':function _delete(key){var that=_validateCollection(this,NAME);var entry=getEntry(that,key);if(entry){var next=entry.n;var prev=entry.p;delete that._i[entry.i];entry.r=true;if(prev)prev.n=next;if(next)next.p=prev;if(that._f==entry)that._f=next;if(that._l==entry)that._l=prev;that[SIZE]--;}return!!entry;},// 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n// 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\nforEach:function forEach(callbackfn/* , that = undefined */){_validateCollection(this,NAME);var f=_ctx(callbackfn,arguments.length>1?arguments[1]:undefined,3);var entry;while(entry=entry?entry.n:this._f){f(entry.v,entry.k,this);// revert to the last existing entry\nwhile(entry&&entry.r){entry=entry.p;}}},// 23.1.3.7 Map.prototype.has(key)\n// 23.2.3.7 Set.prototype.has(value)\nhas:function has(key){return!!getEntry(_validateCollection(this,NAME),key);}});if(_descriptors)dP$1(C.prototype,\'size\',{get:function get(){return _validateCollection(this,NAME)[SIZE];}});return C;},def:function def(that,key,value){var entry=getEntry(that,key);var prev,index;// change existing entry\nif(entry){entry.v=value;// create new entry\n}else{that._l=entry={i:index=fastKey(key,true),// <- index\nk:key,// <- key\nv:value,// <- value\np:prev=that._l,// <- previous entry\nn:undefined,// <- next entry\nr:false// <- removed\n};if(!that._f)that._f=entry;if(prev)prev.n=entry;that[SIZE]++;// add to index\nif(index!==\'F\')that._i[index]=entry;}return that;},getEntry:getEntry,setStrong:function setStrong(C,NAME,IS_MAP){// add .keys, .values, .entries, [@@iterator]\n// 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n_iterDefine(C,NAME,function(iterated,kind){this._t=_validateCollection(iterated,NAME);// target\nthis._k=kind;// kind\nthis._l=undefined;// previous\n},function(){var that=this;var kind=that._k;var entry=that._l;// revert to the last existing entry\nwhile(entry&&entry.r){entry=entry.p;}// get next entry\nif(!that._t||!(that._l=entry=entry?entry.n:that._t._f)){// or finish the iteration\nthat._t=undefined;return _iterStep(1);}// return step by kind\nif(kind==\'keys\')return _iterStep(0,entry.k);if(kind==\'values\')return _iterStep(0,entry.v);return _iterStep(0,[entry.k,entry.v]);},IS_MAP?\'entries\':\'values\',!IS_MAP,true);// add [@@species], 23.1.2.2, 23.2.2.2\n_setSpecies(NAME);}};// Works with __proto__ only. Old v8 can\'t work with null proto objects.\n/* eslint-disable no-proto */var check=function check(O,proto){_anObject(O);if(!_isObject(proto)&&proto!==null)throw TypeError(proto+": can\'t set as prototype!");};var _setProto={set:Object.setPrototypeOf||(\'__proto__\'in{}?// eslint-disable-line\nfunction(test,buggy,set){try{set=_ctx(Function.call,_objectGopd.f(Object.prototype,\'__proto__\').set,2);set(test,[]);buggy=!(test instanceof Array);}catch(e){buggy=true;}return function setPrototypeOf(O,proto){check(O,proto);if(buggy)O.__proto__=proto;else set(O,proto);return O;};}({},false):undefined),check:check};var setPrototypeOf=_setProto.set;var _inheritIfRequired=function _inheritIfRequired(that,target,C){var S=target.constructor;var P;if(S!==C&&typeof S==\'function\'&&(P=S.prototype)!==C.prototype&&_isObject(P)&&setPrototypeOf){setPrototypeOf(that,P);}return that;};var _collection=function _collection(NAME,wrapper,methods,common,IS_MAP,IS_WEAK){var Base=_global[NAME];var C=Base;var ADDER=IS_MAP?\'set\':\'add\';var proto=C&&C.prototype;var O={};var fixMethod=function fixMethod(KEY){var fn=proto[KEY];_redefine(proto,KEY,KEY==\'delete\'?function(a){return IS_WEAK&&!_isObject(a)?false:fn.call(this,a===0?0:a);}:KEY==\'has\'?function has(a){return IS_WEAK&&!_isObject(a)?false:fn.call(this,a===0?0:a);}:KEY==\'get\'?function get(a){return IS_WEAK&&!_isObject(a)?undefined:fn.call(this,a===0?0:a);}:KEY==\'add\'?function add(a){fn.call(this,a===0?0:a);return this;}:function set(a,b){fn.call(this,a===0?0:a,b);return this;});};if(typeof C!=\'function\'||!(IS_WEAK||proto.forEach&&!_fails(function(){new C().entries().next();}))){// create collection constructor\nC=common.getConstructor(wrapper,NAME,IS_MAP,ADDER);_redefineAll(C.prototype,methods);_meta.NEED=true;}else{var instance=new C();// early implementations not supports chaining\nvar HASNT_CHAINING=instance[ADDER](IS_WEAK?{}:-0,1)!=instance;// V8 ~  Chromium 40- weak-collections throws on primitives, but should return false\nvar THROWS_ON_PRIMITIVES=_fails(function(){instance.has(1);});// most early implementations doesn\'t supports iterables, most modern - not close it correctly\nvar ACCEPT_ITERABLES=_iterDetect(function(iter){new C(iter);});// eslint-disable-line no-new\n// for early implementations -0 and +0 not the same\nvar BUGGY_ZERO=!IS_WEAK&&_fails(function(){// V8 ~ Chromium 42- fails only with 5+ elements\nvar $instance=new C();var index=5;while(index--){$instance[ADDER](index,index);}return!$instance.has(-0);});if(!ACCEPT_ITERABLES){C=wrapper(function(target,iterable){_anInstance(target,C,NAME);var that=_inheritIfRequired(new Base(),target,C);if(iterable!=undefined)_forOf(iterable,IS_MAP,that[ADDER],that);return that;});C.prototype=proto;proto.constructor=C;}if(THROWS_ON_PRIMITIVES||BUGGY_ZERO){fixMethod(\'delete\');fixMethod(\'has\');IS_MAP&&fixMethod(\'get\');}if(BUGGY_ZERO||HASNT_CHAINING)fixMethod(ADDER);// weak collections should not contains .clear method\nif(IS_WEAK&&proto.clear)delete proto.clear;}_setToStringTag(C,NAME);O[NAME]=C;_export(_export.G+_export.W+_export.F*(C!=Base),O);if(!IS_WEAK)common.setStrong(C,NAME,IS_MAP);return C;};var MAP=\'Map\';// 23.1 Map Objects\nvar es6_map=_collection(MAP,function(get){return function Map(){return get(this,arguments.length>0?arguments[0]:undefined);};},{// 23.1.3.6 Map.prototype.get(key)\nget:function get(key){var entry=_collectionStrong.getEntry(_validateCollection(this,MAP),key);return entry&&entry.v;},// 23.1.3.9 Map.prototype.set(key, value)\nset:function set(key,value){return _collectionStrong.def(_validateCollection(this,MAP),key===0?0:key,value);}},_collectionStrong,true);var SET=\'Set\';// 23.2 Set Objects\nvar es6_set=_collection(SET,function(get){return function Set(){return get(this,arguments.length>0?arguments[0]:undefined);};},{// 23.2.3.1 Set.prototype.add(value)\nadd:function add(value){return _collectionStrong.def(_validateCollection(this,SET),value=value===0?0:value,value);}},_collectionStrong);var f$4=Object.getOwnPropertySymbols;var _objectGops={f:f$4};// 19.1.2.1 Object.assign(target, source, ...)\nvar $assign=Object.assign;// should work with symbols and should have deterministic property order (V8 bug)\nvar _objectAssign=!$assign||_fails(function(){var A={};var B={};// eslint-disable-next-line no-undef\nvar S=Symbol();var K=\'abcdefghijklmnopqrst\';A[S]=7;K.split(\'\').forEach(function(k){B[k]=k;});return $assign({},A)[S]!=7||Object.keys($assign({},B)).join(\'\')!=K;})?function assign(target,source){// eslint-disable-line no-unused-vars\nvar T=_toObject(target);var aLen=arguments.length;var index=1;var getSymbols=_objectGops.f;var isEnum=_objectPie.f;while(aLen>index){var S=_iobject(arguments[index++]);var keys=getSymbols?_objectKeys(S).concat(getSymbols(S)):_objectKeys(S);var length=keys.length;var j=0;var key;while(length>j){if(isEnum.call(S,key=keys[j++]))T[key]=S[key];}}return T;}:$assign;var getWeak=_meta.getWeak;var arrayFind=_arrayMethods(5);var arrayFindIndex=_arrayMethods(6);var id$1=0;// fallback for uncaught frozen keys\nvar uncaughtFrozenStore=function uncaughtFrozenStore(that){return that._l||(that._l=new UncaughtFrozenStore());};var UncaughtFrozenStore=function UncaughtFrozenStore(){this.a=[];};var findUncaughtFrozen=function findUncaughtFrozen(store,key){return arrayFind(store.a,function(it){return it[0]===key;});};UncaughtFrozenStore.prototype={get:function get(key){var entry=findUncaughtFrozen(this,key);if(entry)return entry[1];},has:function has(key){return!!findUncaughtFrozen(this,key);},set:function set(key,value){var entry=findUncaughtFrozen(this,key);if(entry)entry[1]=value;else this.a.push([key,value]);},\'delete\':function _delete(key){var index=arrayFindIndex(this.a,function(it){return it[0]===key;});if(~index)this.a.splice(index,1);return!!~index;}};var _collectionWeak={getConstructor:function getConstructor(wrapper,NAME,IS_MAP,ADDER){var C=wrapper(function(that,iterable){_anInstance(that,C,NAME,\'_i\');that._t=NAME;// collection type\nthat._i=id$1++;// collection id\nthat._l=undefined;// leak store for uncaught frozen objects\nif(iterable!=undefined)_forOf(iterable,IS_MAP,that[ADDER],that);});_redefineAll(C.prototype,{// 23.3.3.2 WeakMap.prototype.delete(key)\n// 23.4.3.3 WeakSet.prototype.delete(value)\n\'delete\':function _delete(key){if(!_isObject(key))return false;var data=getWeak(key);if(data===true)return uncaughtFrozenStore(_validateCollection(this,NAME))[\'delete\'](key);return data&&_has(data,this._i)&&delete data[this._i];},// 23.3.3.4 WeakMap.prototype.has(key)\n// 23.4.3.4 WeakSet.prototype.has(value)\nhas:function has(key){if(!_isObject(key))return false;var data=getWeak(key);if(data===true)return uncaughtFrozenStore(_validateCollection(this,NAME)).has(key);return data&&_has(data,this._i);}});return C;},def:function def(that,key,value){var data=getWeak(_anObject(key),true);if(data===true)uncaughtFrozenStore(that).set(key,value);else data[that._i]=value;return that;},ufstore:uncaughtFrozenStore};var es6_weakMap=createCommonjsModule(function(module){\'use strict\';var each=_arrayMethods(0);var WEAK_MAP=\'WeakMap\';var getWeak=_meta.getWeak;var isExtensible=Object.isExtensible;var uncaughtFrozenStore=_collectionWeak.ufstore;var tmp={};var InternalMap;var wrapper=function wrapper(get){return function WeakMap(){return get(this,arguments.length>0?arguments[0]:undefined);};};var methods={// 23.3.3.3 WeakMap.prototype.get(key)\nget:function get(key){if(_isObject(key)){var data=getWeak(key);if(data===true)return uncaughtFrozenStore(_validateCollection(this,WEAK_MAP)).get(key);return data?data[this._i]:undefined;}},// 23.3.3.5 WeakMap.prototype.set(key, value)\nset:function set(key,value){return _collectionWeak.def(_validateCollection(this,WEAK_MAP),key,value);}};// 23.3 WeakMap Objects\nvar $WeakMap=module.exports=_collection(WEAK_MAP,wrapper,methods,_collectionWeak,true,true);// IE11 WeakMap frozen keys fix\nif(_fails(function(){return new $WeakMap().set((Object.freeze||Object)(tmp),7).get(tmp)!=7;})){InternalMap=_collectionWeak.getConstructor(wrapper,WEAK_MAP);_objectAssign(InternalMap.prototype,methods);_meta.NEED=true;each([\'delete\',\'has\',\'get\',\'set\'],function(key){var proto=$WeakMap.prototype;var method=proto[key];_redefine(proto,key,function(a,b){// store frozen objects on internal weakmap shim\nif(_isObject(a)&&!isExtensible(a)){if(!this._f)this._f=new InternalMap();var result=this._f[key](a,b);return key==\'set\'?this:result;// store all the rest on native weakmap\n}return method.call(this,a,b);});});}});var WEAK_SET=\'WeakSet\';// 23.4 WeakSet Objects\n_collection(WEAK_SET,function(get){return function WeakSet(){return get(this,arguments.length>0?arguments[0]:undefined);};},{// 23.4.3.1 WeakSet.prototype.add(value)\nadd:function add(value){return _collectionWeak.def(_validateCollection(this,WEAK_SET),value,true);}},_collectionWeak,false,true);// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)\nvar rApply=(_global.Reflect||{}).apply;var fApply=Function.apply;// MS Edge argumentsList argument is optional\n_export(_export.S+_export.F*!_fails(function(){rApply(function(){/* empty */});}),\'Reflect\',{apply:function apply(target,thisArgument,argumentsList){var T=_aFunction(target);var L=_anObject(argumentsList);return rApply?rApply(T,thisArgument,L):fApply.call(T,thisArgument,L);}});// fast apply, http://jsperf.lnkit.com/fast-apply/5\nvar _invoke=function _invoke(fn,args,that){var un=that===undefined;switch(args.length){case 0:return un?fn():fn.call(that);case 1:return un?fn(args[0]):fn.call(that,args[0]);case 2:return un?fn(args[0],args[1]):fn.call(that,args[0],args[1]);case 3:return un?fn(args[0],args[1],args[2]):fn.call(that,args[0],args[1],args[2]);case 4:return un?fn(args[0],args[1],args[2],args[3]):fn.call(that,args[0],args[1],args[2],args[3]);}return fn.apply(that,args);};var arraySlice=[].slice;var factories={};var construct=function construct(F,len,args){if(!(len in factories)){for(var n=[],i=0;i<len;i++){n[i]=\'a[\'+i+\']\';}// eslint-disable-next-line no-new-func\nfactories[len]=Function(\'F,a\',\'return new F(\'+n.join(\',\')+\')\');}return factories[len](F,args);};var _bind=Function.bind||function bind(that/* , ...args */){var fn=_aFunction(this);var partArgs=arraySlice.call(arguments,1);var bound=function bound()/* args... */{var args=partArgs.concat(arraySlice.call(arguments));return this instanceof bound?construct(fn,args.length,args):_invoke(fn,args,that);};if(_isObject(fn.prototype))bound.prototype=fn.prototype;return bound;};// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])\nvar rConstruct=(_global.Reflect||{}).construct;// MS Edge supports only 2 arguments and argumentsList argument is optional\n// FF Nightly sets third argument as `new.target`, but does not create `this` from it\nvar NEW_TARGET_BUG=_fails(function(){function F(){/* empty */}return!(rConstruct(function(){/* empty */},[],F)instanceof F);});var ARGS_BUG=!_fails(function(){rConstruct(function(){/* empty */});});_export(_export.S+_export.F*(NEW_TARGET_BUG||ARGS_BUG),\'Reflect\',{construct:function construct(Target,args/* , newTarget */){_aFunction(Target);_anObject(args);var newTarget=arguments.length<3?Target:_aFunction(arguments[2]);if(ARGS_BUG&&!NEW_TARGET_BUG)return rConstruct(Target,args,newTarget);if(Target==newTarget){// w/o altered newTarget, optimization for 0-4 arguments\nswitch(args.length){case 0:return new Target();case 1:return new Target(args[0]);case 2:return new Target(args[0],args[1]);case 3:return new Target(args[0],args[1],args[2]);case 4:return new Target(args[0],args[1],args[2],args[3]);}// w/o altered newTarget, lot of arguments case\nvar $args=[null];$args.push.apply($args,args);return new(_bind.apply(Target,$args))();}// with altered newTarget, not support built-in constructors\nvar proto=newTarget.prototype;var instance=_objectCreate(_isObject(proto)?proto:Object.prototype);var result=Function.apply.call(Target,instance,args);return _isObject(result)?result:instance;}});// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)\n// MS Edge has broken Reflect.defineProperty - throwing instead of returning false\n_export(_export.S+_export.F*_fails(function(){// eslint-disable-next-line no-undef\nReflect.defineProperty(_objectDp.f({},1,{value:1}),1,{value:2});}),\'Reflect\',{defineProperty:function defineProperty(target,propertyKey,attributes){_anObject(target);propertyKey=_toPrimitive(propertyKey,true);_anObject(attributes);try{_objectDp.f(target,propertyKey,attributes);return true;}catch(e){return false;}}});// 26.1.4 Reflect.deleteProperty(target, propertyKey)\nvar gOPD$2=_objectGopd.f;_export(_export.S,\'Reflect\',{deleteProperty:function deleteProperty(target,propertyKey){var desc=gOPD$2(_anObject(target),propertyKey);return desc&&!desc.configurable?false:delete target[propertyKey];}});// 26.1.6 Reflect.get(target, propertyKey [, receiver])\nfunction get(target,propertyKey/* , receiver */){var receiver=arguments.length<3?target:arguments[2];var desc,proto;if(_anObject(target)===receiver)return target[propertyKey];if(desc=_objectGopd.f(target,propertyKey))return _has(desc,\'value\')?desc.value:desc.get!==undefined?desc.get.call(receiver):undefined;if(_isObject(proto=_objectGpo(target)))return get(proto,propertyKey,receiver);}_export(_export.S,\'Reflect\',{get:get});// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)\n_export(_export.S,\'Reflect\',{getOwnPropertyDescriptor:function getOwnPropertyDescriptor(target,propertyKey){return _objectGopd.f(_anObject(target),propertyKey);}});// 26.1.8 Reflect.getPrototypeOf(target)\n_export(_export.S,\'Reflect\',{getPrototypeOf:function getPrototypeOf(target){return _objectGpo(_anObject(target));}});// 26.1.9 Reflect.has(target, propertyKey)\n_export(_export.S,\'Reflect\',{has:function has(target,propertyKey){return propertyKey in target;}});// 26.1.10 Reflect.isExtensible(target)\nvar $isExtensible=Object.isExtensible;_export(_export.S,\'Reflect\',{isExtensible:function isExtensible(target){_anObject(target);return $isExtensible?$isExtensible(target):true;}});// all object keys, includes non-enumerable and symbols\nvar Reflect$1=_global.Reflect;var _ownKeys=Reflect$1&&Reflect$1.ownKeys||function ownKeys(it){var keys=_objectGopn.f(_anObject(it));var getSymbols=_objectGops.f;return getSymbols?keys.concat(getSymbols(it)):keys;};// 26.1.11 Reflect.ownKeys(target)\n_export(_export.S,\'Reflect\',{ownKeys:_ownKeys});// 26.1.12 Reflect.preventExtensions(target)\nvar $preventExtensions=Object.preventExtensions;_export(_export.S,\'Reflect\',{preventExtensions:function preventExtensions(target){_anObject(target);try{if($preventExtensions)$preventExtensions(target);return true;}catch(e){return false;}}});// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])\nfunction set(target,propertyKey,V/* , receiver */){var receiver=arguments.length<4?target:arguments[3];var ownDesc=_objectGopd.f(_anObject(target),propertyKey);var existingDescriptor,proto;if(!ownDesc){if(_isObject(proto=_objectGpo(target))){return set(proto,propertyKey,V,receiver);}ownDesc=_propertyDesc(0);}if(_has(ownDesc,\'value\')){if(ownDesc.writable===false||!_isObject(receiver))return false;existingDescriptor=_objectGopd.f(receiver,propertyKey)||_propertyDesc(0);existingDescriptor.value=V;_objectDp.f(receiver,propertyKey,existingDescriptor);return true;}return ownDesc.set===undefined?false:(ownDesc.set.call(receiver,V),true);}_export(_export.S,\'Reflect\',{set:set});// 26.1.14 Reflect.setPrototypeOf(target, proto)\nif(_setProto)_export(_export.S,\'Reflect\',{setPrototypeOf:function setPrototypeOf(target,proto){_setProto.check(target,proto);try{_setProto.set(target,proto);return true;}catch(e){return false;}}});var process$1=_global.process;var setTask=_global.setImmediate;var clearTask=_global.clearImmediate;var MessageChannel=_global.MessageChannel;var Dispatch=_global.Dispatch;var counter=0;var queue={};var ONREADYSTATECHANGE=\'onreadystatechange\';var defer;var channel;var port;var run=function run(){var id=+this;// eslint-disable-next-line no-prototype-builtins\nif(queue.hasOwnProperty(id)){var fn=queue[id];delete queue[id];fn();}};var listener=function listener(event){run.call(event.data);};// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif(!setTask||!clearTask){setTask=function setImmediate(fn){var args=[];var i=1;while(arguments.length>i){args.push(arguments[i++]);}queue[++counter]=function(){// eslint-disable-next-line no-new-func\n_invoke(typeof fn==\'function\'?fn:Function(fn),args);};defer(counter);return counter;};clearTask=function clearImmediate(id){delete queue[id];};// Node.js 0.8-\nif(_cof(process$1)==\'process\'){defer=function defer(id){process$1.nextTick(_ctx(run,id,1));};// Sphere (JS game engine) Dispatch API\n}else if(Dispatch&&Dispatch.now){defer=function defer(id){Dispatch.now(_ctx(run,id,1));};// Browsers with MessageChannel, includes WebWorkers\n}else if(MessageChannel){channel=new MessageChannel();port=channel.port2;channel.port1.onmessage=listener;defer=_ctx(port.postMessage,port,1);// Browsers with postMessage, skip WebWorkers\n// IE8 has postMessage, but it\'s sync & typeof its postMessage is \'object\'\n}else if(_global.addEventListener&&typeof postMessage==\'function\'&&!_global.importScripts){defer=function defer(id){_global.postMessage(id+\'\',\'*\');};_global.addEventListener(\'message\',listener,false);// IE8-\n}else if(ONREADYSTATECHANGE in _domCreate(\'script\')){defer=function defer(id){_html.appendChild(_domCreate(\'script\'))[ONREADYSTATECHANGE]=function(){_html.removeChild(this);run.call(id);};};// Rest old browsers\n}else{defer=function defer(id){setTimeout(_ctx(run,id,1),0);};}}var _task={set:setTask,clear:clearTask};var macrotask=_task.set;var Observer=_global.MutationObserver||_global.WebKitMutationObserver;var process$2=_global.process;var Promise$1=_global.Promise;var isNode$1=_cof(process$2)==\'process\';var _microtask=function _microtask(){var head,last,notify;var flush=function flush(){var parent,fn;if(isNode$1&&(parent=process$2.domain))parent.exit();while(head){fn=head.fn;head=head.next;try{fn();}catch(e){if(head)notify();else last=undefined;throw e;}}last=undefined;if(parent)parent.enter();};// Node.js\nif(isNode$1){notify=function notify(){process$2.nextTick(flush);};// browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339\n}else if(Observer&&!(_global.navigator&&_global.navigator.standalone)){var toggle=true;var node=document.createTextNode(\'\');new Observer(flush).observe(node,{characterData:true});// eslint-disable-line no-new\nnotify=function notify(){node.data=toggle=!toggle;};// environments with maybe non-completely correct, but existent Promise\n}else if(Promise$1&&Promise$1.resolve){var promise=Promise$1.resolve();notify=function notify(){promise.then(flush);};// for other environments - macrotask based on:\n// - setImmediate\n// - MessageChannel\n// - window.postMessag\n// - onreadystatechange\n// - setTimeout\n}else{notify=function notify(){// strange IE + webpack dev server bug - use .call(global)\nmacrotask.call(_global,flush);};}return function(fn){var task={fn:fn,next:undefined};if(last)last.next=task;if(!head){head=task;notify();}last=task;};};// 25.4.1.5 NewPromiseCapability(C)\nfunction PromiseCapability(C){var resolve,reject;this.promise=new C(function($$resolve,$$reject){if(resolve!==undefined||reject!==undefined)throw TypeError(\'Bad Promise constructor\');resolve=$$resolve;reject=$$reject;});this.resolve=_aFunction(resolve);this.reject=_aFunction(reject);}var f$5=function f$5(C){return new PromiseCapability(C);};var _newPromiseCapability={f:f$5};var _perform=function _perform(exec){try{return{e:false,v:exec()};}catch(e){return{e:true,v:e};}};var _promiseResolve=function _promiseResolve(C,x){_anObject(C);if(_isObject(x)&&x.constructor===C)return x;var promiseCapability=_newPromiseCapability.f(C);var resolve=promiseCapability.resolve;resolve(x);return promiseCapability.promise;};var task=_task.set;var microtask=_microtask();var PROMISE=\'Promise\';var TypeError$1=_global.TypeError;var process=_global.process;var $Promise=_global[PROMISE];var isNode=_classof(process)==\'process\';var empty=function empty(){/* empty */};var Internal;var newGenericPromiseCapability;var OwnPromiseCapability;var Wrapper;var newPromiseCapability=newGenericPromiseCapability=_newPromiseCapability.f;var USE_NATIVE=!!function(){try{// correct subclassing with @@species support\nvar promise=$Promise.resolve(1);var FakePromise=(promise.constructor={})[_wks(\'species\')]=function(exec){exec(empty,empty);};// unhandled rejections tracking support, NodeJS Promise without it fails @@species test\nreturn(isNode||typeof PromiseRejectionEvent==\'function\')&&promise.then(empty)instanceof FakePromise;}catch(e){/* empty */}}();// helpers\nvar isThenable=function isThenable(it){var then;return _isObject(it)&&typeof(then=it.then)==\'function\'?then:false;};var notify=function notify(promise,isReject){if(promise._n)return;promise._n=true;var chain=promise._c;microtask(function(){var value=promise._v;var ok=promise._s==1;var i=0;var run=function run(reaction){var handler=ok?reaction.ok:reaction.fail;var resolve=reaction.resolve;var reject=reaction.reject;var domain=reaction.domain;var result,then;try{if(handler){if(!ok){if(promise._h==2)onHandleUnhandled(promise);promise._h=1;}if(handler===true)result=value;else{if(domain)domain.enter();result=handler(value);if(domain)domain.exit();}if(result===reaction.promise){reject(TypeError$1(\'Promise-chain cycle\'));}else if(then=isThenable(result)){then.call(result,resolve,reject);}else resolve(result);}else reject(value);}catch(e){reject(e);}};while(chain.length>i){run(chain[i++]);}// variable length - can\'t use forEach\npromise._c=[];promise._n=false;if(isReject&&!promise._h)onUnhandled(promise);});};var onUnhandled=function onUnhandled(promise){task.call(_global,function(){var value=promise._v;var unhandled=isUnhandled(promise);var result,handler,console;if(unhandled){result=_perform(function(){if(isNode){process.emit(\'unhandledRejection\',value,promise);}else if(handler=_global.onunhandledrejection){handler({promise:promise,reason:value});}else if((console=_global.console)&&console.error){console.error(\'Unhandled promise rejection\',value);}});// Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\npromise._h=isNode||isUnhandled(promise)?2:1;}promise._a=undefined;if(unhandled&&result.e)throw result.v;});};var isUnhandled=function isUnhandled(promise){return promise._h!==1&&(promise._a||promise._c).length===0;};var onHandleUnhandled=function onHandleUnhandled(promise){task.call(_global,function(){var handler;if(isNode){process.emit(\'rejectionHandled\',promise);}else if(handler=_global.onrejectionhandled){handler({promise:promise,reason:promise._v});}});};var $reject=function $reject(value){var promise=this;if(promise._d)return;promise._d=true;promise=promise._w||promise;// unwrap\npromise._v=value;promise._s=2;if(!promise._a)promise._a=promise._c.slice();notify(promise,true);};var $resolve=function $resolve(value){var promise=this;var then;if(promise._d)return;promise._d=true;promise=promise._w||promise;// unwrap\ntry{if(promise===value)throw TypeError$1("Promise can\'t be resolved itself");if(then=isThenable(value)){microtask(function(){var wrapper={_w:promise,_d:false};// wrap\ntry{then.call(value,_ctx($resolve,wrapper,1),_ctx($reject,wrapper,1));}catch(e){$reject.call(wrapper,e);}});}else{promise._v=value;promise._s=1;notify(promise,false);}}catch(e){$reject.call({_w:promise,_d:false},e);// wrap\n}};// constructor polyfill\nif(!USE_NATIVE){// 25.4.3.1 Promise(executor)\n$Promise=function Promise(executor){_anInstance(this,$Promise,PROMISE,\'_h\');_aFunction(executor);Internal.call(this);try{executor(_ctx($resolve,this,1),_ctx($reject,this,1));}catch(err){$reject.call(this,err);}};// eslint-disable-next-line no-unused-vars\nInternal=function Promise(executor){this._c=[];// <- awaiting reactions\nthis._a=undefined;// <- checked in isUnhandled reactions\nthis._s=0;// <- state\nthis._d=false;// <- done\nthis._v=undefined;// <- value\nthis._h=0;// <- rejection state, 0 - default, 1 - handled, 2 - unhandled\nthis._n=false;// <- notify\n};Internal.prototype=_redefineAll($Promise.prototype,{// 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\nthen:function then(onFulfilled,onRejected){var reaction=newPromiseCapability(_speciesConstructor(this,$Promise));reaction.ok=typeof onFulfilled==\'function\'?onFulfilled:true;reaction.fail=typeof onRejected==\'function\'&&onRejected;reaction.domain=isNode?process.domain:undefined;this._c.push(reaction);if(this._a)this._a.push(reaction);if(this._s)notify(this,false);return reaction.promise;},// 25.4.5.1 Promise.prototype.catch(onRejected)\n\'catch\':function _catch(onRejected){return this.then(undefined,onRejected);}});OwnPromiseCapability=function OwnPromiseCapability(){var promise=new Internal();this.promise=promise;this.resolve=_ctx($resolve,promise,1);this.reject=_ctx($reject,promise,1);};_newPromiseCapability.f=newPromiseCapability=function newPromiseCapability(C){return C===$Promise||C===Wrapper?new OwnPromiseCapability(C):newGenericPromiseCapability(C);};}_export(_export.G+_export.W+_export.F*!USE_NATIVE,{Promise:$Promise});_setToStringTag($Promise,PROMISE);_setSpecies(PROMISE);Wrapper=_core[PROMISE];// statics\n_export(_export.S+_export.F*!USE_NATIVE,PROMISE,{// 25.4.4.5 Promise.reject(r)\nreject:function reject(r){var capability=newPromiseCapability(this);var $$reject=capability.reject;$$reject(r);return capability.promise;}});_export(_export.S+_export.F*(_library||!USE_NATIVE),PROMISE,{// 25.4.4.6 Promise.resolve(x)\nresolve:function resolve(x){return _promiseResolve(_library&&this===Wrapper?$Promise:this,x);}});_export(_export.S+_export.F*!(USE_NATIVE&&_iterDetect(function(iter){$Promise.all(iter)[\'catch\'](empty);})),PROMISE,{// 25.4.4.1 Promise.all(iterable)\nall:function all(iterable){var C=this;var capability=newPromiseCapability(C);var resolve=capability.resolve;var reject=capability.reject;var result=_perform(function(){var values=[];var index=0;var remaining=1;_forOf(iterable,false,function(promise){var $index=index++;var alreadyCalled=false;values.push(undefined);remaining++;C.resolve(promise).then(function(value){if(alreadyCalled)return;alreadyCalled=true;values[$index]=value;--remaining||resolve(values);},reject);});--remaining||resolve(values);});if(result.e)reject(result.v);return capability.promise;},// 25.4.4.4 Promise.race(iterable)\nrace:function race(iterable){var C=this;var capability=newPromiseCapability(C);var reject=capability.reject;var result=_perform(function(){_forOf(iterable,false,function(promise){C.resolve(promise).then(capability.resolve,reject);});});if(result.e)reject(result.v);return capability.promise;}});var f$6=_wks;var _wksExt={f:f$6};var defineProperty=_objectDp.f;var _wksDefine=function _wksDefine(name){var $Symbol=_core.Symbol||(_core.Symbol=_library?{}:_global.Symbol||{});if(name.charAt(0)!=\'_\'&&!(name in $Symbol))defineProperty($Symbol,name,{value:_wksExt.f(name)});};// all enumerable object keys, includes symbols\nvar _enumKeys=function _enumKeys(it){var result=_objectKeys(it);var getSymbols=_objectGops.f;if(getSymbols){var symbols=getSymbols(it);var isEnum=_objectPie.f;var i=0;var key;while(symbols.length>i){if(isEnum.call(it,key=symbols[i++]))result.push(key);}}return result;};// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar gOPN$1=_objectGopn.f;var toString$1={}.toString;var windowNames=(typeof window===\'undefined\'?\'undefined\':_typeof2(window))==\'object\'&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];var getWindowNames=function getWindowNames(it){try{return gOPN$1(it);}catch(e){return windowNames.slice();}};var f$7=function getOwnPropertyNames(it){return windowNames&&toString$1.call(it)==\'[object Window]\'?getWindowNames(it):gOPN$1(_toIobject(it));};var _objectGopnExt={f:f$7};// ECMAScript 6 symbols shim\nvar META=_meta.KEY;var gOPD$3=_objectGopd.f;var dP$2=_objectDp.f;var gOPN=_objectGopnExt.f;var $Symbol=_global.Symbol;var $JSON=_global.JSON;var _stringify=$JSON&&$JSON.stringify;var PROTOTYPE$2=\'prototype\';var HIDDEN=_wks(\'_hidden\');var TO_PRIMITIVE=_wks(\'toPrimitive\');var isEnum={}.propertyIsEnumerable;var SymbolRegistry=_shared(\'symbol-registry\');var AllSymbols=_shared(\'symbols\');var OPSymbols=_shared(\'op-symbols\');var ObjectProto$1=Object[PROTOTYPE$2];var USE_NATIVE$1=typeof $Symbol==\'function\';var QObject=_global.QObject;// Don\'t use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter=!QObject||!QObject[PROTOTYPE$2]||!QObject[PROTOTYPE$2].findChild;// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc=_descriptors&&_fails(function(){return _objectCreate(dP$2({},\'a\',{get:function get(){return dP$2(this,\'a\',{value:7}).a;}})).a!=7;})?function(it,key,D){var protoDesc=gOPD$3(ObjectProto$1,key);if(protoDesc)delete ObjectProto$1[key];dP$2(it,key,D);if(protoDesc&&it!==ObjectProto$1)dP$2(ObjectProto$1,key,protoDesc);}:dP$2;var wrap=function wrap(tag){var sym=AllSymbols[tag]=_objectCreate($Symbol[PROTOTYPE$2]);sym._k=tag;return sym;};var isSymbol=USE_NATIVE$1&&_typeof2($Symbol.iterator)==\'symbol\'?function(it){return(typeof it===\'undefined\'?\'undefined\':_typeof2(it))==\'symbol\';}:function(it){return it instanceof $Symbol;};var $defineProperty$1=function defineProperty(it,key,D){if(it===ObjectProto$1)$defineProperty$1(OPSymbols,key,D);_anObject(it);key=_toPrimitive(key,true);_anObject(D);if(_has(AllSymbols,key)){if(!D.enumerable){if(!_has(it,HIDDEN))dP$2(it,HIDDEN,_propertyDesc(1,{}));it[HIDDEN][key]=true;}else{if(_has(it,HIDDEN)&&it[HIDDEN][key])it[HIDDEN][key]=false;D=_objectCreate(D,{enumerable:_propertyDesc(0,false)});}return setSymbolDesc(it,key,D);}return dP$2(it,key,D);};var $defineProperties=function defineProperties(it,P){_anObject(it);var keys=_enumKeys(P=_toIobject(P));var i=0;var l=keys.length;var key;while(l>i){$defineProperty$1(it,key=keys[i++],P[key]);}return it;};var $create=function create(it,P){return P===undefined?_objectCreate(it):$defineProperties(_objectCreate(it),P);};var $propertyIsEnumerable=function propertyIsEnumerable(key){var E=isEnum.call(this,key=_toPrimitive(key,true));if(this===ObjectProto$1&&_has(AllSymbols,key)&&!_has(OPSymbols,key))return false;return E||!_has(this,key)||!_has(AllSymbols,key)||_has(this,HIDDEN)&&this[HIDDEN][key]?E:true;};var $getOwnPropertyDescriptor=function getOwnPropertyDescriptor(it,key){it=_toIobject(it);key=_toPrimitive(key,true);if(it===ObjectProto$1&&_has(AllSymbols,key)&&!_has(OPSymbols,key))return;var D=gOPD$3(it,key);if(D&&_has(AllSymbols,key)&&!(_has(it,HIDDEN)&&it[HIDDEN][key]))D.enumerable=true;return D;};var $getOwnPropertyNames=function getOwnPropertyNames(it){var names=gOPN(_toIobject(it));var result=[];var i=0;var key;while(names.length>i){if(!_has(AllSymbols,key=names[i++])&&key!=HIDDEN&&key!=META)result.push(key);}return result;};var $getOwnPropertySymbols=function getOwnPropertySymbols(it){var IS_OP=it===ObjectProto$1;var names=gOPN(IS_OP?OPSymbols:_toIobject(it));var result=[];var i=0;var key;while(names.length>i){if(_has(AllSymbols,key=names[i++])&&(IS_OP?_has(ObjectProto$1,key):true))result.push(AllSymbols[key]);}return result;};// 19.4.1.1 Symbol([description])\nif(!USE_NATIVE$1){$Symbol=function _Symbol2(){if(this instanceof $Symbol)throw TypeError(\'Symbol is not a constructor!\');var tag=_uid(arguments.length>0?arguments[0]:undefined);var $set=function $set(value){if(this===ObjectProto$1)$set.call(OPSymbols,value);if(_has(this,HIDDEN)&&_has(this[HIDDEN],tag))this[HIDDEN][tag]=false;setSymbolDesc(this,tag,_propertyDesc(1,value));};if(_descriptors&&setter)setSymbolDesc(ObjectProto$1,tag,{configurable:true,set:$set});return wrap(tag);};_redefine($Symbol[PROTOTYPE$2],\'toString\',function toString(){return this._k;});_objectGopd.f=$getOwnPropertyDescriptor;_objectDp.f=$defineProperty$1;_objectGopn.f=_objectGopnExt.f=$getOwnPropertyNames;_objectPie.f=$propertyIsEnumerable;_objectGops.f=$getOwnPropertySymbols;if(_descriptors&&!_library){_redefine(ObjectProto$1,\'propertyIsEnumerable\',$propertyIsEnumerable,true);}_wksExt.f=function(name){return wrap(_wks(name));};}_export(_export.G+_export.W+_export.F*!USE_NATIVE$1,{Symbol:$Symbol});for(var es6Symbols=// 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n\'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables\'.split(\',\'),j=0;es6Symbols.length>j;){_wks(es6Symbols[j++]);}for(var wellKnownSymbols=_objectKeys(_wks.store),k=0;wellKnownSymbols.length>k;){_wksDefine(wellKnownSymbols[k++]);}_export(_export.S+_export.F*!USE_NATIVE$1,\'Symbol\',{// 19.4.2.1 Symbol.for(key)\n\'for\':function _for(key){return _has(SymbolRegistry,key+=\'\')?SymbolRegistry[key]:SymbolRegistry[key]=$Symbol(key);},// 19.4.2.5 Symbol.keyFor(sym)\nkeyFor:function keyFor(sym){if(!isSymbol(sym))throw TypeError(sym+\' is not a symbol!\');for(var key in SymbolRegistry){if(SymbolRegistry[key]===sym)return key;}},useSetter:function useSetter(){setter=true;},useSimple:function useSimple(){setter=false;}});_export(_export.S+_export.F*!USE_NATIVE$1,\'Object\',{// 19.1.2.2 Object.create(O [, Properties])\ncreate:$create,// 19.1.2.4 Object.defineProperty(O, P, Attributes)\ndefineProperty:$defineProperty$1,// 19.1.2.3 Object.defineProperties(O, Properties)\ndefineProperties:$defineProperties,// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\ngetOwnPropertyDescriptor:$getOwnPropertyDescriptor,// 19.1.2.7 Object.getOwnPropertyNames(O)\ngetOwnPropertyNames:$getOwnPropertyNames,// 19.1.2.8 Object.getOwnPropertySymbols(O)\ngetOwnPropertySymbols:$getOwnPropertySymbols});// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON&&_export(_export.S+_export.F*(!USE_NATIVE$1||_fails(function(){var S=$Symbol();// MS Edge converts symbol values to JSON as {}\n// WebKit converts symbol values to JSON as null\n// V8 throws on boxed symbols\nreturn _stringify([S])!=\'[null]\'||_stringify({a:S})!=\'{}\'||_stringify(Object(S))!=\'{}\';})),\'JSON\',{stringify:function stringify(it){var args=[it];var i=1;var replacer,$replacer;while(arguments.length>i){args.push(arguments[i++]);}$replacer=replacer=args[1];if(!_isObject(replacer)&&it===undefined||isSymbol(it))return;// IE8 returns string on undefined\nif(!_isArray(replacer))replacer=function replacer(key,value){if(typeof $replacer==\'function\')value=$replacer.call(this,key,value);if(!isSymbol(value))return value;};args[1]=replacer;return _stringify.apply($JSON,args);}});// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE$2][TO_PRIMITIVE]||_hide($Symbol[PROTOTYPE$2],TO_PRIMITIVE,$Symbol[PROTOTYPE$2].valueOf);// 19.4.3.5 Symbol.prototype[@@toStringTag]\n_setToStringTag($Symbol,\'Symbol\');// 20.2.1.9 Math[@@toStringTag]\n_setToStringTag(Math,\'Math\',true);// 24.3.3 JSON[@@toStringTag]\n_setToStringTag(_global.JSON,\'JSON\',true);// most Object methods by ES6 should accept primitives\nvar _objectSap=function _objectSap(KEY,exec){var fn=(_core.Object||{})[KEY]||Object[KEY];var exp={};exp[KEY]=exec(fn);_export(_export.S+_export.F*_fails(function(){fn(1);}),\'Object\',exp);};// 19.1.2.5 Object.freeze(O)\nvar meta=_meta.onFreeze;_objectSap(\'freeze\',function($freeze){return function freeze(it){return $freeze&&_isObject(it)?$freeze(meta(it)):it;};});// 19.1.2.17 Object.seal(O)\nvar meta$1=_meta.onFreeze;_objectSap(\'seal\',function($seal){return function seal(it){return $seal&&_isObject(it)?$seal(meta$1(it)):it;};});// 19.1.2.15 Object.preventExtensions(O)\nvar meta$2=_meta.onFreeze;_objectSap(\'preventExtensions\',function($preventExtensions){return function preventExtensions(it){return $preventExtensions&&_isObject(it)?$preventExtensions(meta$2(it)):it;};});// 19.1.2.12 Object.isFrozen(O)\n_objectSap(\'isFrozen\',function($isFrozen){return function isFrozen(it){return _isObject(it)?$isFrozen?$isFrozen(it):false:true;};});// 19.1.2.13 Object.isSealed(O)\n_objectSap(\'isSealed\',function($isSealed){return function isSealed(it){return _isObject(it)?$isSealed?$isSealed(it):false:true;};});// 19.1.2.11 Object.isExtensible(O)\n_objectSap(\'isExtensible\',function($isExtensible){return function isExtensible(it){return _isObject(it)?$isExtensible?$isExtensible(it):true:false;};});// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\nvar $getOwnPropertyDescriptor$1=_objectGopd.f;_objectSap(\'getOwnPropertyDescriptor\',function(){return function getOwnPropertyDescriptor(it,key){return $getOwnPropertyDescriptor$1(_toIobject(it),key);};});// 19.1.2.9 Object.getPrototypeOf(O)\n_objectSap(\'getPrototypeOf\',function(){return function getPrototypeOf(it){return _objectGpo(_toObject(it));};});// 19.1.2.14 Object.keys(O)\n_objectSap(\'keys\',function(){return function keys(it){return _objectKeys(_toObject(it));};});// 19.1.2.7 Object.getOwnPropertyNames(O)\n_objectSap(\'getOwnPropertyNames\',function(){return _objectGopnExt.f;});// 19.1.3.1 Object.assign(target, source)\n_export(_export.S+_export.F,\'Object\',{assign:_objectAssign});// 7.2.9 SameValue(x, y)\nvar _sameValue=Object.is||function is(x,y){// eslint-disable-next-line no-self-compare\nreturn x===y?x!==0||1/x===1/y:x!=x&&y!=y;};// 19.1.3.10 Object.is(value1, value2)\n_export(_export.S,\'Object\',{is:_sameValue});// 19.1.3.19 Object.setPrototypeOf(O, proto)\n_export(_export.S,\'Object\',{setPrototypeOf:_setProto.set});var dP$3=_objectDp.f;var FProto=Function.prototype;var nameRE=/^\\s*function ([^ (]*)/;var NAME=\'name\';// 19.2.4.2 name\nNAME in FProto||_descriptors&&dP$3(FProto,NAME,{configurable:true,get:function get(){try{return(\'\'+this).match(nameRE)[1];}catch(e){return\'\';}}});_export(_export.S,\'String\',{// 21.1.2.4 String.raw(callSite, ...substitutions)\nraw:function raw(callSite){var tpl=_toIobject(callSite.raw);var len=_toLength(tpl.length);var aLen=arguments.length;var res=[];var i=0;while(len>i){res.push(String(tpl[i++]));if(i<aLen)res.push(String(arguments[i]));}return res.join(\'\');}});var fromCharCode=String.fromCharCode;var $fromCodePoint=String.fromCodePoint;// length should be 1, old FF problem\n_export(_export.S+_export.F*(!!$fromCodePoint&&$fromCodePoint.length!=1),\'String\',{// 21.1.2.2 String.fromCodePoint(...codePoints)\nfromCodePoint:function fromCodePoint(x){// eslint-disable-line no-unused-vars\nvar res=[];var aLen=arguments.length;var i=0;var code;while(aLen>i){code=+arguments[i++];if(_toAbsoluteIndex(code,0x10ffff)!==code)throw RangeError(code+\' is not a valid code point\');res.push(code<0x10000?fromCharCode(code):fromCharCode(((code-=0x10000)>>10)+0xd800,code%0x400+0xdc00));}return res.join(\'\');}});// true  -> String#at\n// false -> String#codePointAt\nvar _stringAt=function _stringAt(TO_STRING){return function(that,pos){var s=String(_defined(that));var i=_toInteger(pos);var l=s.length;var a,b;if(i<0||i>=l)return TO_STRING?\'\':undefined;a=s.charCodeAt(i);return a<0xd800||a>0xdbff||i+1===l||(b=s.charCodeAt(i+1))<0xdc00||b>0xdfff?TO_STRING?s.charAt(i):a:TO_STRING?s.slice(i,i+2):(a-0xd800<<10)+(b-0xdc00)+0x10000;};};var $at=_stringAt(false);_export(_export.P,\'String\',{// 21.1.3.3 String.prototype.codePointAt(pos)\ncodePointAt:function codePointAt(pos){return $at(this,pos);}});var _stringRepeat=function repeat(count){var str=String(_defined(this));var res=\'\';var n=_toInteger(count);if(n<0||n==Infinity)throw RangeError("Count can\'t be negative");for(;n>0;(n>>>=1)&&(str+=str)){if(n&1)res+=str;}return res;};_export(_export.P,\'String\',{// 21.1.3.13 String.prototype.repeat(count)\nrepeat:_stringRepeat});// 7.2.8 IsRegExp(argument)\nvar MATCH=_wks(\'match\');var _isRegexp=function _isRegexp(it){var isRegExp;return _isObject(it)&&((isRegExp=it[MATCH])!==undefined?!!isRegExp:_cof(it)==\'RegExp\');};// helper for String#{startsWith, endsWith, includes}\nvar _stringContext=function _stringContext(that,searchString,NAME){if(_isRegexp(searchString))throw TypeError(\'String#\'+NAME+" doesn\'t accept regex!");return String(_defined(that));};var MATCH$1=_wks(\'match\');var _failsIsRegexp=function _failsIsRegexp(KEY){var re=/./;try{\'/./\'[KEY](re);}catch(e){try{re[MATCH$1]=false;return!\'/./\'[KEY](re);}catch(f){/* empty */}}return true;};var STARTS_WITH=\'startsWith\';var $startsWith=\'\'[STARTS_WITH];_export(_export.P+_export.F*_failsIsRegexp(STARTS_WITH),\'String\',{startsWith:function startsWith(searchString/* , position = 0 */){var that=_stringContext(this,searchString,STARTS_WITH);var index=_toLength(Math.min(arguments.length>1?arguments[1]:undefined,that.length));var search=String(searchString);return $startsWith?$startsWith.call(that,search,index):that.slice(index,index+search.length)===search;}});var ENDS_WITH=\'endsWith\';var $endsWith=\'\'[ENDS_WITH];_export(_export.P+_export.F*_failsIsRegexp(ENDS_WITH),\'String\',{endsWith:function endsWith(searchString/* , endPosition = @length */){var that=_stringContext(this,searchString,ENDS_WITH);var endPosition=arguments.length>1?arguments[1]:undefined;var len=_toLength(that.length);var end=endPosition===undefined?len:Math.min(_toLength(endPosition),len);var search=String(searchString);return $endsWith?$endsWith.call(that,search,end):that.slice(end-search.length,end)===search;}});var INCLUDES=\'includes\';_export(_export.P+_export.F*_failsIsRegexp(INCLUDES),\'String\',{includes:function includes(searchString/* , position = 0 */){return!!~_stringContext(this,searchString,INCLUDES).indexOf(searchString,arguments.length>1?arguments[1]:undefined);}});// 21.2.5.3 get RegExp.prototype.flags\nvar _flags=function _flags(){var that=_anObject(this);var result=\'\';if(that.global)result+=\'g\';if(that.ignoreCase)result+=\'i\';if(that.multiline)result+=\'m\';if(that.unicode)result+=\'u\';if(that.sticky)result+=\'y\';return result;};// 21.2.5.3 get RegExp.prototype.flags()\nif(_descriptors&&/./g.flags!=\'g\')_objectDp.f(RegExp.prototype,\'flags\',{configurable:true,get:_flags});var _fixReWks=function _fixReWks(KEY,length,exec){var SYMBOL=_wks(KEY);var fns=exec(_defined,SYMBOL,\'\'[KEY]);var strfn=fns[0];var rxfn=fns[1];if(_fails(function(){var O={};O[SYMBOL]=function(){return 7;};return\'\'[KEY](O)!=7;})){_redefine(String.prototype,KEY,strfn);_hide(RegExp.prototype,SYMBOL,length==2// 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\n// 21.2.5.11 RegExp.prototype[@@split](string, limit)\n?function(string,arg){return rxfn.call(string,this,arg);}// 21.2.5.6 RegExp.prototype[@@match](string)\n// 21.2.5.9 RegExp.prototype[@@search](string)\n:function(string){return rxfn.call(string,this);});}};// @@match logic\n_fixReWks(\'match\',1,function(defined,MATCH,$match){// 21.1.3.11 String.prototype.match(regexp)\nreturn[function match(regexp){\'use strict\';var O=defined(this);var fn=regexp==undefined?undefined:regexp[MATCH];return fn!==undefined?fn.call(regexp,O):new RegExp(regexp)[MATCH](String(O));},$match];});// @@replace logic\n_fixReWks(\'replace\',2,function(defined,REPLACE,$replace){// 21.1.3.14 String.prototype.replace(searchValue, replaceValue)\nreturn[function replace(searchValue,replaceValue){\'use strict\';var O=defined(this);var fn=searchValue==undefined?undefined:searchValue[REPLACE];return fn!==undefined?fn.call(searchValue,O,replaceValue):$replace.call(String(O),searchValue,replaceValue);},$replace];});// @@split logic\n_fixReWks(\'split\',2,function(defined,SPLIT,$split){\'use strict\';var isRegExp=_isRegexp;var _split=$split;var $push=[].push;var $SPLIT=\'split\';var LENGTH=\'length\';var LAST_INDEX=\'lastIndex\';if(\'abbc\'[$SPLIT](/(b)*/)[1]==\'c\'||\'test\'[$SPLIT](/(?:)/,-1)[LENGTH]!=4||\'ab\'[$SPLIT](/(?:ab)*/)[LENGTH]!=2||\'.\'[$SPLIT](/(.?)(.?)/)[LENGTH]!=4||\'.\'[$SPLIT](/()()/)[LENGTH]>1||\'\'[$SPLIT](/.?/)[LENGTH]){var NPCG=/()??/.exec(\'\')[1]===undefined;// nonparticipating capturing group\n// based on es5-shim implementation, need to rework it\n$split=function $split(separator,limit){var string=String(this);if(separator===undefined&&limit===0)return[];// If `separator` is not a regex, use native split\nif(!isRegExp(separator))return _split.call(string,separator,limit);var output=[];var flags=(separator.ignoreCase?\'i\':\'\')+(separator.multiline?\'m\':\'\')+(separator.unicode?\'u\':\'\')+(separator.sticky?\'y\':\'\');var lastLastIndex=0;var splitLimit=limit===undefined?4294967295:limit>>>0;// Make `global` and avoid `lastIndex` issues by working with a copy\nvar separatorCopy=new RegExp(separator.source,flags+\'g\');var separator2,match,lastIndex,lastLength,i;// Doesn\'t need flags gy, but they don\'t hurt\nif(!NPCG)separator2=new RegExp(\'^\'+separatorCopy.source+\'$(?!\\\\s)\',flags);while(match=separatorCopy.exec(string)){// `separatorCopy.lastIndex` is not reliable cross-browser\nlastIndex=match.index+match[0][LENGTH];if(lastIndex>lastLastIndex){output.push(string.slice(lastLastIndex,match.index));// Fix browsers whose `exec` methods don\'t consistently return `undefined` for NPCG\n// eslint-disable-next-line no-loop-func\nif(!NPCG&&match[LENGTH]>1)match[0].replace(separator2,function(){for(i=1;i<arguments[LENGTH]-2;i++){if(arguments[i]===undefined)match[i]=undefined;}});if(match[LENGTH]>1&&match.index<string[LENGTH])$push.apply(output,match.slice(1));lastLength=match[0][LENGTH];lastLastIndex=lastIndex;if(output[LENGTH]>=splitLimit)break;}if(separatorCopy[LAST_INDEX]===match.index)separatorCopy[LAST_INDEX]++;// Avoid an infinite loop\n}if(lastLastIndex===string[LENGTH]){if(lastLength||!separatorCopy.test(\'\'))output.push(\'\');}else output.push(string.slice(lastLastIndex));return output[LENGTH]>splitLimit?output.slice(0,splitLimit):output;};// Chakra, V8\n}else if(\'0\'[$SPLIT](undefined,0)[LENGTH]){$split=function $split(separator,limit){return separator===undefined&&limit===0?[]:_split.call(this,separator,limit);};}// 21.1.3.17 String.prototype.split(separator, limit)\nreturn[function split(separator,limit){var O=defined(this);var fn=separator==undefined?undefined:separator[SPLIT];return fn!==undefined?fn.call(separator,O,limit):$split.call(String(O),separator,limit);},$split];});// @@search logic\n_fixReWks(\'search\',1,function(defined,SEARCH,$search){// 21.1.3.15 String.prototype.search(regexp)\nreturn[function search(regexp){\'use strict\';var O=defined(this);var fn=regexp==undefined?undefined:regexp[SEARCH];return fn!==undefined?fn.call(regexp,O):new RegExp(regexp)[SEARCH](String(O));},$search];});var _createProperty=function _createProperty(object,index,value){if(index in object)_objectDp.f(object,index,_propertyDesc(0,value));else object[index]=value;};_export(_export.S+_export.F*!_iterDetect(function(iter){Array.from(iter);}),\'Array\',{// 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\nfrom:function from(arrayLike/* , mapfn = undefined, thisArg = undefined */){var O=_toObject(arrayLike);var C=typeof this==\'function\'?this:Array;var aLen=arguments.length;var mapfn=aLen>1?arguments[1]:undefined;var mapping=mapfn!==undefined;var index=0;var iterFn=core_getIteratorMethod(O);var length,result,step,iterator;if(mapping)mapfn=_ctx(mapfn,aLen>2?arguments[2]:undefined,2);// if object isn\'t iterable or it\'s array with default iterator - use simple case\nif(iterFn!=undefined&&!(C==Array&&_isArrayIter(iterFn))){for(iterator=iterFn.call(O),result=new C();!(step=iterator.next()).done;index++){_createProperty(result,index,mapping?_iterCall(iterator,mapfn,[step.value,index],true):step.value);}}else{length=_toLength(O.length);for(result=new C(length);length>index;index++){_createProperty(result,index,mapping?mapfn(O[index],index):O[index]);}}result.length=index;return result;}});// WebKit Array.of isn\'t generic\n_export(_export.S+_export.F*_fails(function(){function F(){/* empty */}return!(Array.of.call(F)instanceof F);}),\'Array\',{// 22.1.2.3 Array.of( ...items)\nof:function of()/* ...args */{var index=0;var aLen=arguments.length;var result=new(typeof this==\'function\'?this:Array)(aLen);while(aLen>index){_createProperty(result,index,arguments[index++]);}result.length=aLen;return result;}});// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\n_export(_export.P,\'Array\',{copyWithin:_arrayCopyWithin});_addToUnscopables(\'copyWithin\');// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)\nvar $find=_arrayMethods(5);var KEY=\'find\';var forced=true;// Shouldn\'t skip holes\nif(KEY in[])Array(1)[KEY](function(){forced=false;});_export(_export.P+_export.F*forced,\'Array\',{find:function find(callbackfn/* , that = undefined */){return $find(this,callbackfn,arguments.length>1?arguments[1]:undefined);}});_addToUnscopables(KEY);// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)\nvar $find$1=_arrayMethods(6);var KEY$1=\'findIndex\';var forced$1=true;// Shouldn\'t skip holes\nif(KEY$1 in[])Array(1)[KEY$1](function(){forced$1=false;});_export(_export.P+_export.F*forced$1,\'Array\',{findIndex:function findIndex(callbackfn/* , that = undefined */){return $find$1(this,callbackfn,arguments.length>1?arguments[1]:undefined);}});_addToUnscopables(KEY$1);// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\n_export(_export.P,\'Array\',{fill:_arrayFill});_addToUnscopables(\'fill\');// 20.1.2.2 Number.isFinite(number)\nvar _isFinite=_global.isFinite;_export(_export.S,\'Number\',{isFinite:function isFinite(it){return typeof it==\'number\'&&_isFinite(it);}});// 20.1.2.3 Number.isInteger(number)\nvar floor$1=Math.floor;var _isInteger=function isInteger(it){return!_isObject(it)&&isFinite(it)&&floor$1(it)===it;};// 20.1.2.3 Number.isInteger(number)\n_export(_export.S,\'Number\',{isInteger:_isInteger});// 20.1.2.5 Number.isSafeInteger(number)\nvar abs=Math.abs;_export(_export.S,\'Number\',{isSafeInteger:function isSafeInteger(number){return _isInteger(number)&&abs(number)<=0x1fffffffffffff;}});// 20.1.2.4 Number.isNaN(number)\n_export(_export.S,\'Number\',{isNaN:function isNaN(number){// eslint-disable-next-line no-self-compare\nreturn number!=number;}});// 20.1.2.1 Number.EPSILON\n_export(_export.S,\'Number\',{EPSILON:Math.pow(2,-52)});// 20.1.2.10 Number.MIN_SAFE_INTEGER\n_export(_export.S,\'Number\',{MIN_SAFE_INTEGER:-0x1fffffffffffff});// 20.1.2.6 Number.MAX_SAFE_INTEGER\n_export(_export.S,\'Number\',{MAX_SAFE_INTEGER:0x1fffffffffffff});// 20.2.2.20 Math.log1p(x)\nvar _mathLog1p=Math.log1p||function log1p(x){return(x=+x)>-1e-8&&x<1e-8?x-x*x/2:Math.log(1+x);};// 20.2.2.3 Math.acosh(x)\nvar sqrt=Math.sqrt;var $acosh=Math.acosh;_export(_export.S+_export.F*!($acosh// V8 bug: https://code.google.com/p/v8/issues/detail?id=3509\n&&Math.floor($acosh(Number.MAX_VALUE))==710// Tor Browser bug: Math.acosh(Infinity) -> NaN\n&&$acosh(Infinity)==Infinity),\'Math\',{acosh:function acosh(x){return(x=+x)<1?NaN:x>94906265.62425156?Math.log(x)+Math.LN2:_mathLog1p(x-1+sqrt(x-1)*sqrt(x+1));}});// 20.2.2.5 Math.asinh(x)\nvar $asinh=Math.asinh;function asinh(x){return!isFinite(x=+x)||x==0?x:x<0?-asinh(-x):Math.log(x+Math.sqrt(x*x+1));}// Tor Browser bug: Math.asinh(0) -> -0\n_export(_export.S+_export.F*!($asinh&&1/$asinh(0)>0),\'Math\',{asinh:asinh});// 20.2.2.7 Math.atanh(x)\nvar $atanh=Math.atanh;// Tor Browser bug: Math.atanh(-0) -> 0\n_export(_export.S+_export.F*!($atanh&&1/$atanh(-0)<0),\'Math\',{atanh:function atanh(x){return(x=+x)==0?x:Math.log((1+x)/(1-x))/2;}});// 20.2.2.28 Math.sign(x)\nvar _mathSign=Math.sign||function sign(x){// eslint-disable-next-line no-self-compare\nreturn(x=+x)==0||x!=x?x:x<0?-1:1;};// 20.2.2.9 Math.cbrt(x)\n_export(_export.S,\'Math\',{cbrt:function cbrt(x){return _mathSign(x=+x)*Math.pow(Math.abs(x),1/3);}});// 20.2.2.11 Math.clz32(x)\n_export(_export.S,\'Math\',{clz32:function clz32(x){return(x>>>=0)?31-Math.floor(Math.log(x+0.5)*Math.LOG2E):32;}});// 20.2.2.12 Math.cosh(x)\nvar exp=Math.exp;_export(_export.S,\'Math\',{cosh:function cosh(x){return(exp(x=+x)+exp(-x))/2;}});// 20.2.2.14 Math.expm1(x)\nvar $expm1=Math.expm1;var _mathExpm1=!$expm1// Old FF bug\n||$expm1(10)>22025.465794806719||$expm1(10)<22025.4657948067165168// Tor Browser bug\n||$expm1(-2e-17)!=-2e-17?function expm1(x){return(x=+x)==0?x:x>-1e-6&&x<1e-6?x+x*x/2:Math.exp(x)-1;}:$expm1;// 20.2.2.14 Math.expm1(x)\n_export(_export.S+_export.F*(_mathExpm1!=Math.expm1),\'Math\',{expm1:_mathExpm1});// 20.2.2.16 Math.fround(x)\nvar pow=Math.pow;var EPSILON=pow(2,-52);var EPSILON32=pow(2,-23);var MAX32=pow(2,127)*(2-EPSILON32);var MIN32=pow(2,-126);var roundTiesToEven=function roundTiesToEven(n){return n+1/EPSILON-1/EPSILON;};var _mathFround=Math.fround||function fround(x){var $abs=Math.abs(x);var $sign=_mathSign(x);var a,result;if($abs<MIN32)return $sign*roundTiesToEven($abs/MIN32/EPSILON32)*MIN32*EPSILON32;a=(1+EPSILON32/EPSILON)*$abs;result=a-(a-$abs);// eslint-disable-next-line no-self-compare\nif(result>MAX32||result!=result)return $sign*Infinity;return $sign*result;};// 20.2.2.16 Math.fround(x)\n_export(_export.S,\'Math\',{fround:_mathFround});// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])\nvar abs$1=Math.abs;_export(_export.S,\'Math\',{hypot:function hypot(value1,value2){// eslint-disable-line no-unused-vars\nvar sum=0;var i=0;var aLen=arguments.length;var larg=0;var arg,div;while(i<aLen){arg=abs$1(arguments[i++]);if(larg<arg){div=larg/arg;sum=sum*div*div+1;larg=arg;}else if(arg>0){div=arg/larg;sum+=div*div;}else sum+=arg;}return larg===Infinity?Infinity:larg*Math.sqrt(sum);}});// 20.2.2.18 Math.imul(x, y)\nvar $imul=Math.imul;// some WebKit versions fails with big numbers, some has wrong arity\n_export(_export.S+_export.F*_fails(function(){return $imul(0xffffffff,5)!=-5||$imul.length!=2;}),\'Math\',{imul:function imul(x,y){var UINT16=0xffff;var xn=+x;var yn=+y;var xl=UINT16&xn;var yl=UINT16&yn;return 0|xl*yl+((UINT16&xn>>>16)*yl+xl*(UINT16&yn>>>16)<<16>>>0);}});// 20.2.2.20 Math.log1p(x)\n_export(_export.S,\'Math\',{log1p:_mathLog1p});// 20.2.2.21 Math.log10(x)\n_export(_export.S,\'Math\',{log10:function log10(x){return Math.log(x)*Math.LOG10E;}});// 20.2.2.22 Math.log2(x)\n_export(_export.S,\'Math\',{log2:function log2(x){return Math.log(x)/Math.LN2;}});// 20.2.2.28 Math.sign(x)\n_export(_export.S,\'Math\',{sign:_mathSign});// 20.2.2.30 Math.sinh(x)\nvar exp$1=Math.exp;// V8 near Chromium 38 has a problem with very small numbers\n_export(_export.S+_export.F*_fails(function(){return!Math.sinh(-2e-17)!=-2e-17;}),\'Math\',{sinh:function sinh(x){return Math.abs(x=+x)<1?(_mathExpm1(x)-_mathExpm1(-x))/2:(exp$1(x-1)-exp$1(-x-1))*(Math.E/2);}});// 20.2.2.33 Math.tanh(x)\nvar exp$2=Math.exp;_export(_export.S,\'Math\',{tanh:function tanh(x){var a=_mathExpm1(x=+x);var b=_mathExpm1(-x);return a==Infinity?1:b==Infinity?-1:(a-b)/(exp$2(x)+exp$2(-x));}});// 20.2.2.34 Math.trunc(x)\n_export(_export.S,\'Math\',{trunc:function trunc(it){return(it>0?Math.floor:Math.ceil)(it);}});// https://github.com/tc39/Array.prototype.includes\nvar $includes=_arrayIncludes(true);_export(_export.P,\'Array\',{includes:function includes(el/* , fromIndex = 0 */){return $includes(this,el,arguments.length>1?arguments[1]:undefined);}});_addToUnscopables(\'includes\');var isEnum$1=_objectPie.f;var _objectToArray=function _objectToArray(isEntries){return function(it){var O=_toIobject(it);var keys=_objectKeys(O);var length=keys.length;var i=0;var result=[];var key;while(length>i){if(isEnum$1.call(O,key=keys[i++])){result.push(isEntries?[key,O[key]]:O[key]);}}return result;};};// https://github.com/tc39/proposal-object-values-entries\nvar $values=_objectToArray(false);_export(_export.S,\'Object\',{values:function values(it){return $values(it);}});// https://github.com/tc39/proposal-object-values-entries\nvar $entries=_objectToArray(true);_export(_export.S,\'Object\',{entries:function entries(it){return $entries(it);}});// https://github.com/tc39/proposal-object-getownpropertydescriptors\n_export(_export.S,\'Object\',{getOwnPropertyDescriptors:function getOwnPropertyDescriptors(object){var O=_toIobject(object);var getDesc=_objectGopd.f;var keys=_ownKeys(O);var result={};var i=0;var key,desc;while(keys.length>i){desc=getDesc(O,key=keys[i++]);if(desc!==undefined)_createProperty(result,key,desc);}return result;}});// https://github.com/tc39/proposal-string-pad-start-end\nvar _stringPad=function _stringPad(that,maxLength,fillString,left){var S=String(_defined(that));var stringLength=S.length;var fillStr=fillString===undefined?\' \':String(fillString);var intMaxLength=_toLength(maxLength);if(intMaxLength<=stringLength||fillStr==\'\')return S;var fillLen=intMaxLength-stringLength;var stringFiller=_stringRepeat.call(fillStr,Math.ceil(fillLen/fillStr.length));if(stringFiller.length>fillLen)stringFiller=stringFiller.slice(0,fillLen);return left?stringFiller+S:S+stringFiller;};var navigator=_global.navigator;var _userAgent=navigator&&navigator.userAgent||\'\';// https://github.com/tc39/proposal-string-pad-start-end\n// https://github.com/zloirock/core-js/issues/280\n_export(_export.P+_export.F*/Version\\/10\\.\\d+(\\.\\d+)? Safari\\//.test(_userAgent),\'String\',{padStart:function padStart(maxLength/* , fillString = \' \' */){return _stringPad(this,maxLength,arguments.length>1?arguments[1]:undefined,true);}});// https://github.com/tc39/proposal-string-pad-start-end\n// https://github.com/zloirock/core-js/issues/280\n_export(_export.P+_export.F*/Version\\/10\\.\\d+(\\.\\d+)? Safari\\//.test(_userAgent),\'String\',{padEnd:function padEnd(maxLength/* , fillString = \' \' */){return _stringPad(this,maxLength,arguments.length>1?arguments[1]:undefined,false);}});// ie9- setTimeout & setInterval additional parameters fix\nvar slice=[].slice;var MSIE=/MSIE .\\./.test(_userAgent);// <- dirty ie9- check\nvar wrap$1=function wrap$1(set){return function(fn,time/* , ...args */){var boundArgs=arguments.length>2;var args=boundArgs?slice.call(arguments,2):false;return set(boundArgs?function(){// eslint-disable-next-line no-new-func\n(typeof fn==\'function\'?fn:Function(fn)).apply(this,args);}:fn,time);};};_export(_export.G+_export.B+_export.F*MSIE,{setTimeout:wrap$1(_global.setTimeout),setInterval:wrap$1(_global.setInterval)});_export(_export.G+_export.B,{setImmediate:_task.set,clearImmediate:_task.clear});var ITERATOR$4=_wks(\'iterator\');var TO_STRING_TAG=_wks(\'toStringTag\');var ArrayValues=_iterators.Array;var DOMIterables={CSSRuleList:true,// TODO: Not spec compliant, should be false.\nCSSStyleDeclaration:false,CSSValueList:false,ClientRectList:false,DOMRectList:false,DOMStringList:false,DOMTokenList:true,DataTransferItemList:false,FileList:false,HTMLAllCollection:false,HTMLCollection:false,HTMLFormElement:false,HTMLSelectElement:false,MediaList:true,// TODO: Not spec compliant, should be false.\nMimeTypeArray:false,NamedNodeMap:false,NodeList:true,PaintRequestList:false,Plugin:false,PluginArray:false,SVGLengthList:false,SVGNumberList:false,SVGPathSegList:false,SVGPointList:false,SVGStringList:false,SVGTransformList:false,SourceBufferList:false,StyleSheetList:true,// TODO: Not spec compliant, should be false.\nTextTrackCueList:false,TextTrackList:false,TouchList:false};for(var collections=_objectKeys(DOMIterables),i$1=0;i$1<collections.length;i$1++){var NAME$1=collections[i$1];var explicit=DOMIterables[NAME$1];var Collection=_global[NAME$1];var proto=Collection&&Collection.prototype;var key;if(proto){if(!proto[ITERATOR$4])_hide(proto,ITERATOR$4,ArrayValues);if(!proto[TO_STRING_TAG])_hide(proto,TO_STRING_TAG,NAME$1);_iterators[NAME$1]=ArrayValues;if(explicit)for(key in es6_array_iterator){if(!proto[key])_redefine(proto,key,es6_array_iterator[key],true);}}}var runtime=createCommonjsModule(function(module){/**\r\n\t * Copyright (c) 2014, Facebook, Inc.\r\n\t * All rights reserved.\r\n\t *\r\n\t * This source code is licensed under the BSD-style license found in the\r\n\t * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\r\n\t * additional grant of patent rights can be found in the PATENTS file in\r\n\t * the same directory.\r\n\t */!function(global){"use strict";var Op=Object.prototype;var hasOwn=Op.hasOwnProperty;var undefined;// More compressible than void 0.\nvar $Symbol=typeof Symbol==="function"?Symbol:{};var iteratorSymbol=$Symbol.iterator||"@@iterator";var asyncIteratorSymbol=$Symbol.asyncIterator||"@@asyncIterator";var toStringTagSymbol=$Symbol.toStringTag||"@@toStringTag";var inModule=\'object\'==="object";var runtime=global.regeneratorRuntime;if(runtime){if(inModule){// If regeneratorRuntime is defined globally and we\'re in a module,\n// make the exports object identical to regeneratorRuntime.\nmodule.exports=runtime;}// Don\'t bother evaluating the rest of this file if the runtime was\n// already defined globally.\nreturn;}// Define the runtime globally (as expected by generated code) as either\n// module.exports (if we\'re in a module) or a new, empty object.\nruntime=global.regeneratorRuntime=inModule?module.exports:{};function wrap(innerFn,outerFn,self,tryLocsList){// If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\nvar protoGenerator=outerFn&&outerFn.prototype instanceof Generator?outerFn:Generator;var generator=Object.create(protoGenerator.prototype);var context=new Context(tryLocsList||[]);// The ._invoke method unifies the implementations of the .next,\n// .throw, and .return methods.\ngenerator._invoke=makeInvokeMethod(innerFn,self,context);return generator;}runtime.wrap=wrap;// Try/catch helper to minimize deoptimizations. Returns a completion\n// record like context.tryEntries[i].completion. This interface could\n// have been (and was previously) designed to take a closure to be\n// invoked without arguments, but in all the cases we care about we\n// already have an existing method we want to call, so there\'s no need\n// to create a new function object. We can even get away with assuming\n// the method takes exactly one argument, since that happens to be true\n// in every case, so we don\'t have to touch the arguments object. The\n// only additional allocation required is the completion record, which\n// has a stable shape and so hopefully should be cheap to allocate.\nfunction tryCatch(fn,obj,arg){try{return{type:"normal",arg:fn.call(obj,arg)};}catch(err){return{type:"throw",arg:err};}}var GenStateSuspendedStart="suspendedStart";var GenStateSuspendedYield="suspendedYield";var GenStateExecuting="executing";var GenStateCompleted="completed";// Returning this object from the innerFn has the same effect as\n// breaking out of the dispatch switch statement.\nvar ContinueSentinel={};// Dummy constructor functions that we use as the .constructor and\n// .constructor.prototype properties for functions that return Generator\n// objects. For full spec compliance, you may wish to configure your\n// minifier not to mangle the names of these two functions.\nfunction Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}// This is a polyfill for %IteratorPrototype% for environments that\n// don\'t natively support it.\nvar IteratorPrototype={};IteratorPrototype[iteratorSymbol]=function(){return this;};var getProto=Object.getPrototypeOf;var NativeIteratorPrototype=getProto&&getProto(getProto(values([])));if(NativeIteratorPrototype&&NativeIteratorPrototype!==Op&&hasOwn.call(NativeIteratorPrototype,iteratorSymbol)){// This environment has a native %IteratorPrototype%; use it instead\n// of the polyfill.\nIteratorPrototype=NativeIteratorPrototype;}var Gp=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(IteratorPrototype);GeneratorFunction.prototype=Gp.constructor=GeneratorFunctionPrototype;GeneratorFunctionPrototype.constructor=GeneratorFunction;GeneratorFunctionPrototype[toStringTagSymbol]=GeneratorFunction.displayName="GeneratorFunction";// Helper for defining the .next, .throw, and .return methods of the\n// Iterator interface in terms of a single ._invoke method.\nfunction defineIteratorMethods(prototype){["next","throw","return"].forEach(function(method){prototype[method]=function(arg){return this._invoke(method,arg);};});}runtime.isGeneratorFunction=function(genFun){var ctor=typeof genFun==="function"&&genFun.constructor;return ctor?ctor===GeneratorFunction||// For the native GeneratorFunction constructor, the best we can\n// do is to check its .name property.\n(ctor.displayName||ctor.name)==="GeneratorFunction":false;};runtime.mark=function(genFun){if(Object.setPrototypeOf){Object.setPrototypeOf(genFun,GeneratorFunctionPrototype);}else{genFun.__proto__=GeneratorFunctionPrototype;if(!(toStringTagSymbol in genFun)){genFun[toStringTagSymbol]="GeneratorFunction";}}genFun.prototype=Object.create(Gp);return genFun;};// Within the body of any async function, `await x` is transformed to\n// `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n// `hasOwn.call(value, "__await")` to determine if the yielded value is\n// meant to be awaited.\nruntime.awrap=function(arg){return{__await:arg};};function AsyncIterator(generator){function invoke(method,arg,resolve,reject){var record=tryCatch(generator[method],generator,arg);if(record.type==="throw"){reject(record.arg);}else{var result=record.arg;var value=result.value;if(value&&(typeof value===\'undefined\'?\'undefined\':_typeof2(value))==="object"&&hasOwn.call(value,"__await")){return Promise.resolve(value.__await).then(function(value){invoke("next",value,resolve,reject);},function(err){invoke("throw",err,resolve,reject);});}return Promise.resolve(value).then(function(unwrapped){// When a yielded Promise is resolved, its final value becomes\n// the .value of the Promise<{value,done}> result for the\n// current iteration. If the Promise is rejected, however, the\n// result for this iteration will be rejected with the same\n// reason. Note that rejections of yielded Promises are not\n// thrown back into the generator function, as is the case\n// when an awaited Promise is rejected. This difference in\n// behavior between yield and await is important, because it\n// allows the consumer to decide what to do with the yielded\n// rejection (swallow it and continue, manually .throw it back\n// into the generator, abandon iteration, whatever). With\n// await, by contrast, there is no opportunity to examine the\n// rejection reason outside the generator function, so the\n// only option is to throw it from the await expression, and\n// let the generator function handle the exception.\nresult.value=unwrapped;resolve(result);},reject);}}if(_typeof2(global.process)==="object"&&global.process.domain){invoke=global.process.domain.bind(invoke);}var previousPromise;function enqueue(method,arg){function callInvokeWithMethodAndArg(){return new Promise(function(resolve,reject){invoke(method,arg,resolve,reject);});}return previousPromise=// If enqueue has been called before, then we want to wait until\n// all previous Promises have been resolved before calling invoke,\n// so that results are always delivered in the correct order. If\n// enqueue has not been called before, then it is important to\n// call invoke immediately, without waiting on a callback to fire,\n// so that the async generator function has the opportunity to do\n// any necessary setup in a predictable way. This predictability\n// is why the Promise constructor synchronously invokes its\n// executor callback, and why async functions synchronously\n// execute code before the first await. Since we implement simple\n// async functions in terms of async generators, it is especially\n// important to get this right, even though it requires care.\npreviousPromise?previousPromise.then(callInvokeWithMethodAndArg,// Avoid propagating failures to Promises returned by later\n// invocations of the iterator.\ncallInvokeWithMethodAndArg):callInvokeWithMethodAndArg();}// Define the unified helper method that is used to implement .next,\n// .throw, and .return (see defineIteratorMethods).\nthis._invoke=enqueue;}defineIteratorMethods(AsyncIterator.prototype);AsyncIterator.prototype[asyncIteratorSymbol]=function(){return this;};runtime.AsyncIterator=AsyncIterator;// Note that simple async functions are implemented on top of\n// AsyncIterator objects; they just return a Promise for the value of\n// the final result produced by the iterator.\nruntime.async=function(innerFn,outerFn,self,tryLocsList){var iter=new AsyncIterator(wrap(innerFn,outerFn,self,tryLocsList));return runtime.isGeneratorFunction(outerFn)?iter// If outerFn is a generator, return the full iterator.\n:iter.next().then(function(result){return result.done?result.value:iter.next();});};function makeInvokeMethod(innerFn,self,context){var state=GenStateSuspendedStart;return function invoke(method,arg){if(state===GenStateExecuting){throw new Error("Generator is already running");}if(state===GenStateCompleted){if(method==="throw"){throw arg;}// Be forgiving, per 25.3.3.3.3 of the spec:\n// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\nreturn doneResult();}context.method=method;context.arg=arg;while(true){var delegate=context.delegate;if(delegate){var delegateResult=maybeInvokeDelegate(delegate,context);if(delegateResult){if(delegateResult===ContinueSentinel)continue;return delegateResult;}}if(context.method==="next"){// Setting context._sent for legacy support of Babel\'s\n// function.sent implementation.\ncontext.sent=context._sent=context.arg;}else if(context.method==="throw"){if(state===GenStateSuspendedStart){state=GenStateCompleted;throw context.arg;}context.dispatchException(context.arg);}else if(context.method==="return"){context.abrupt("return",context.arg);}state=GenStateExecuting;var record=tryCatch(innerFn,self,context);if(record.type==="normal"){// If an exception is thrown from innerFn, we leave state ===\n// GenStateExecuting and loop back for another invocation.\nstate=context.done?GenStateCompleted:GenStateSuspendedYield;if(record.arg===ContinueSentinel){continue;}return{value:record.arg,done:context.done};}else if(record.type==="throw"){state=GenStateCompleted;// Dispatch the exception by looping back around to the\n// context.dispatchException(context.arg) call above.\ncontext.method="throw";context.arg=record.arg;}}};}// Call delegate.iterator[context.method](context.arg) and handle the\n// result, either by returning a { value, done } result from the\n// delegate iterator, or by modifying context.method and context.arg,\n// setting context.delegate to null, and returning the ContinueSentinel.\nfunction maybeInvokeDelegate(delegate,context){var method=delegate.iterator[context.method];if(method===undefined){// A .throw or .return when the delegate iterator has no .throw\n// method always terminates the yield* loop.\ncontext.delegate=null;if(context.method==="throw"){if(delegate.iterator.return){// If the delegate iterator has a return method, give it a\n// chance to clean up.\ncontext.method="return";context.arg=undefined;maybeInvokeDelegate(delegate,context);if(context.method==="throw"){// If maybeInvokeDelegate(context) changed context.method from\n// "return" to "throw", let that override the TypeError below.\nreturn ContinueSentinel;}}context.method="throw";context.arg=new TypeError("The iterator does not provide a \'throw\' method");}return ContinueSentinel;}var record=tryCatch(method,delegate.iterator,context.arg);if(record.type==="throw"){context.method="throw";context.arg=record.arg;context.delegate=null;return ContinueSentinel;}var info=record.arg;if(!info){context.method="throw";context.arg=new TypeError("iterator result is not an object");context.delegate=null;return ContinueSentinel;}if(info.done){// Assign the result of the finished delegate to the temporary\n// variable specified by delegate.resultName (see delegateYield).\ncontext[delegate.resultName]=info.value;// Resume execution at the desired location (see delegateYield).\ncontext.next=delegate.nextLoc;// If context.method was "throw" but the delegate handled the\n// exception, let the outer generator proceed normally. If\n// context.method was "next", forget context.arg since it has been\n// "consumed" by the delegate iterator. If context.method was\n// "return", allow the original .return call to continue in the\n// outer generator.\nif(context.method!=="return"){context.method="next";context.arg=undefined;}}else{// Re-yield the result returned by the delegate method.\nreturn info;}// The delegate iterator is finished, so forget it and continue with\n// the outer generator.\ncontext.delegate=null;return ContinueSentinel;}// Define Generator.prototype.{next,throw,return} in terms of the\n// unified ._invoke helper method.\ndefineIteratorMethods(Gp);Gp[toStringTagSymbol]="Generator";// A Generator should always return itself as the iterator object when the\n// @@iterator function is called on it. Some browsers\' implementations of the\n// iterator prototype chain incorrectly implement this, causing the Generator\n// object to not be returned from this call. This ensures that doesn\'t happen.\n// See https://github.com/facebook/regenerator/issues/274 for more details.\nGp[iteratorSymbol]=function(){return this;};Gp.toString=function(){return"[object Generator]";};function pushTryEntry(locs){var entry={tryLoc:locs[0]};if(1 in locs){entry.catchLoc=locs[1];}if(2 in locs){entry.finallyLoc=locs[2];entry.afterLoc=locs[3];}this.tryEntries.push(entry);}function resetTryEntry(entry){var record=entry.completion||{};record.type="normal";delete record.arg;entry.completion=record;}function Context(tryLocsList){// The root entry object (effectively a try statement without a catch\n// or a finally block) gives us a place to store values thrown from\n// locations where there is no enclosing try statement.\nthis.tryEntries=[{tryLoc:"root"}];tryLocsList.forEach(pushTryEntry,this);this.reset(true);}runtime.keys=function(object){var keys=[];for(var key in object){keys.push(key);}keys.reverse();// Rather than returning an object with a next method, we keep\n// things simple and return the next function itself.\nreturn function next(){while(keys.length){var key=keys.pop();if(key in object){next.value=key;next.done=false;return next;}}// To avoid creating an additional object, we just hang the .value\n// and .done properties off the next function object itself. This\n// also ensures that the minifier will not anonymize the function.\nnext.done=true;return next;};};function values(iterable){if(iterable){var iteratorMethod=iterable[iteratorSymbol];if(iteratorMethod){return iteratorMethod.call(iterable);}if(typeof iterable.next==="function"){return iterable;}if(!isNaN(iterable.length)){var i=-1,next=function next(){while(++i<iterable.length){if(hasOwn.call(iterable,i)){next.value=iterable[i];next.done=false;return next;}}next.value=undefined;next.done=true;return next;};return next.next=next;}}// Return an iterator with no values.\nreturn{next:doneResult};}runtime.values=values;function doneResult(){return{value:undefined,done:true};}Context.prototype={constructor:Context,reset:function reset(skipTempReset){this.prev=0;this.next=0;// Resetting context._sent for legacy support of Babel\'s\n// function.sent implementation.\nthis.sent=this._sent=undefined;this.done=false;this.delegate=null;this.method="next";this.arg=undefined;this.tryEntries.forEach(resetTryEntry);if(!skipTempReset){for(var name in this){// Not sure about the optimal order of these conditions:\nif(name.charAt(0)==="t"&&hasOwn.call(this,name)&&!isNaN(+name.slice(1))){this[name]=undefined;}}}},stop:function stop(){this.done=true;var rootEntry=this.tryEntries[0];var rootRecord=rootEntry.completion;if(rootRecord.type==="throw"){throw rootRecord.arg;}return this.rval;},dispatchException:function dispatchException(exception){if(this.done){throw exception;}var context=this;function handle(loc,caught){record.type="throw";record.arg=exception;context.next=loc;if(caught){// If the dispatched exception was caught by a catch block,\n// then let that catch block handle the exception normally.\ncontext.method="next";context.arg=undefined;}return!!caught;}for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];var record=entry.completion;if(entry.tryLoc==="root"){// Exception thrown outside of any try block that could handle\n// it, so set the completion value of the entire function to\n// throw the exception.\nreturn handle("end");}if(entry.tryLoc<=this.prev){var hasCatch=hasOwn.call(entry,"catchLoc");var hasFinally=hasOwn.call(entry,"finallyLoc");if(hasCatch&&hasFinally){if(this.prev<entry.catchLoc){return handle(entry.catchLoc,true);}else if(this.prev<entry.finallyLoc){return handle(entry.finallyLoc);}}else if(hasCatch){if(this.prev<entry.catchLoc){return handle(entry.catchLoc,true);}}else if(hasFinally){if(this.prev<entry.finallyLoc){return handle(entry.finallyLoc);}}else{throw new Error("try statement without catch or finally");}}}},abrupt:function abrupt(type,arg){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc<=this.prev&&hasOwn.call(entry,"finallyLoc")&&this.prev<entry.finallyLoc){var finallyEntry=entry;break;}}if(finallyEntry&&(type==="break"||type==="continue")&&finallyEntry.tryLoc<=arg&&arg<=finallyEntry.finallyLoc){// Ignore the finally entry if control is not jumping to a\n// location outside the try/catch block.\nfinallyEntry=null;}var record=finallyEntry?finallyEntry.completion:{};record.type=type;record.arg=arg;if(finallyEntry){this.method="next";this.next=finallyEntry.finallyLoc;return ContinueSentinel;}return this.complete(record);},complete:function complete(record,afterLoc){if(record.type==="throw"){throw record.arg;}if(record.type==="break"||record.type==="continue"){this.next=record.arg;}else if(record.type==="return"){this.rval=this.arg=record.arg;this.method="return";this.next="end";}else if(record.type==="normal"&&afterLoc){this.next=afterLoc;}return ContinueSentinel;},finish:function finish(finallyLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.finallyLoc===finallyLoc){this.complete(entry.completion,entry.afterLoc);resetTryEntry(entry);return ContinueSentinel;}}},"catch":function _catch(tryLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc===tryLoc){var record=entry.completion;if(record.type==="throw"){var thrown=record.arg;resetTryEntry(entry);}return thrown;}}// The context.catch method must only be called with a location\n// argument that corresponds to a known catch block.\nthrow new Error("illegal catch attempt");},delegateYield:function delegateYield(iterable,resultName,nextLoc){this.delegate={iterator:values(iterable),resultName:resultName,nextLoc:nextLoc};if(this.method==="next"){// Deliberately forget the last sent value so that we don\'t\n// accidentally pass it on to the delegate.\nthis.arg=undefined;}return ContinueSentinel;}};}(// Among the various tricks for obtaining a reference to the global\n// object, this seems to be the most reliable technique that does not\n// use indirect eval (which violates Content Security Policy).\n(typeof commonjsGlobal===\'undefined\'?\'undefined\':_typeof2(commonjsGlobal))==="object"?commonjsGlobal:(typeof window===\'undefined\'?\'undefined\':_typeof2(window))==="object"?window:(typeof self===\'undefined\'?\'undefined\':_typeof2(self))==="object"?self:commonjsGlobal);});var _typeof=typeof Symbol==="function"&&_typeof2(Symbol.iterator)==="symbol"?function(obj){return typeof obj===\'undefined\'?\'undefined\':_typeof2(obj);}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj===\'undefined\'?\'undefined\':_typeof2(obj);};var classCallCheck=function classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}};var createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var inherits=function inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+(typeof superClass===\'undefined\'?\'undefined\':_typeof2(superClass)));}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;};var possibleConstructorReturn=function possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");}return call&&((typeof call===\'undefined\'?\'undefined\':_typeof2(call))==="object"||typeof call==="function")?call:self;};/**\r\n\t * @author pzx 2018.2.12\r\n\t * WallCorner\r\n\t */var MeshInfo=function MeshInfo(){classCallCheck(this,MeshInfo);this.positionArray=null;this.normalArray=null;this.uvArray=null;this.colorArray=null;this.uv2Array=null;this.indexArray=null;this.material=null;this.resource=null;};var DefaultResource=function DefaultResource(){classCallCheck(this,DefaultResource);};DefaultResource.wallTexture=null;DefaultResource.wallEdgeTexture=null;DefaultResource.floorTexture=null;DefaultResource.ceilingTexture=null;DefaultResource.roofTexture=null;DefaultResource.wallLigthMapTexture=null;DefaultResource.floorLightMapTexture=null;DefaultResource.wallMaterial=null;DefaultResource.wallEdgeMaterial=null;DefaultResource.floorMaterial=null;DefaultResource.ceilingMaterial=null;DefaultResource.roofMaterial=null;var DefaultSetting=function DefaultSetting(){classCallCheck(this,DefaultSetting);};DefaultSetting.StraightManualWallHeight=3;DefaultSetting.StraightManualWallThick=0.15;DefaultSetting.enableDelayLoadMode=true;DefaultSetting.enableManaulWallLightMap=true;DefaultSetting.enableFloorLightMap=true;DefaultSetting.wallLightMapIntensity=3.8;DefaultSetting.enableUseHighestVersionResource=true;DefaultSetting.enableCombine=true;/**\r\n\t * @author pzx 2018.4.2\r\n\t * WallCorner\r\n\t */var BaseObject=function(){function BaseObject(){classCallCheck(this,BaseObject);this.id=null;this.name=null;this.userID=null;this.position=new THREE.Vector3();this.rotation=new THREE.Quaternion(0,0,0,1);this.scale=new THREE.Vector3(1,1,1);this.enableDelayLoadMode=DefaultSetting.enableDelayLoadMode;this.parent=null;this.properties=null;this.isShow=true;}createClass(BaseObject,[{key:"worldPosition",get:function get(){if(this.parent){var worldPosition=new THREE.Vector3();worldPosition.addVectors(this.parent.worldPosition,this.position);return worldPosition;}else{return this.position;}}}]);return BaseObject;}();/**\r\n\t * @author pzx 2018.5.31\r\n\t * BaseWall,墙的基类\r\n\t */var BaseWall=function(_BaseObject){inherits(BaseWall,_BaseObject);function BaseWall(){classCallCheck(this,BaseWall);var _this=possibleConstructorReturn(this,_BaseObject.call(this));_this.startCorner=null;_this.endCorner=null;_this.thick=-1;_this.height=-1;_this.length=-1;_this.pathPoints=[];_this.direction=new THREE.Vector3();_this.doorOrWindows=[];_this.subWalls=[];_this.subCorners=[];_this.suspend=0;_this.mesh=null;_this.isShow=true;return _this;}BaseWall.prototype.baseBuild=function baseBuild(){this.direction=new THREE.Vector3();this.direction.subVectors(this.endCorner.position,this.startCorner.position);this.length=this.direction.length();this.direction.normalize();this.pathPoints.push(this.startCorner.position);this.pathPoints.push(this.endCorner.position);this.position.addVectors(this.endCorner.position,this.startCorner.position);// this.endCorner.position.add(this.startCorner.position).divide(2);\nthis.position.divideScalar(2);};BaseWall.prototype.build=function build(){};BaseWall.prototype.getWallOtherCorner=function getWallOtherCorner(corner){if(this.startCorner===corner){return this.endCorner;}else if(this.endCorner===corner){return this.startCorner;}else{return null;}};BaseWall.prototype.sortDoorOrWins=function sortDoorOrWins(){var startPos=this.startCorner.position;var endPos=this.endCorner.position;var xFlag=endPos.x-startPos.x>0?1:-1;var zFlag=endPos.z-startPos.z>0?1:-1;var useXToCompare=true;if(Math.abs(endPos.x-startPos.x)<0.001){useXToCompare=false;}var sortedList=[];for(var i=0;i<this.doorOrWindows.length;i++){var dwMaster=this.doorOrWindows[i];for(var j=0;j<sortedList.length;j++){var sortedDWMaster=sortedList[j];var dValue;if(useXToCompare){dValue=(sortedDWMaster.position.x-dwMaster.position.x)*xFlag;}else{dValue=(sortedDWMaster.position.z-dwMaster.position.z)*zFlag;}if(dValue>=0){sortedList.splice(j,0,dwMaster);break;}else{if(j==sortedList.length-1){sortedList.push(dwMaster);break;}}}if(sortedList.length===0){sortedList.push(dwMaster);}}return sortedList;};BaseWall.prototype.getWallCornerByPos=function getWallCornerByPos(pos){var closestCorner=null;var shorterDis=-1;var allCorners=this.subCorners;for(var i=0;i<allCorners.length;i++){// var disVec = pos;\nvar dis=pos.distanceTo(allCorners[i].position);// var dis = Vector3.Distance(pos, allCorners[i].position);\nif(dis<0.01){if(closestCorner===null){closestCorner=allCorners[i];shorterDis=dis;}else{if(dis<shorterDis){shorterDis=dis;closestCorner=allCorners[i];}}}}return closestCorner;};BaseWall.prototype.getDoorOrWinStartAndEndPos=function getDoorOrWinStartAndEndPos(doorOrWin){var size=doorOrWin.size;var wallDir=this.direction;var pos=doorOrWin.position.clone();pos.y=0;// var localPos = doorOrWin.localPosition;\nvar start=pos.clone();var end=pos.clone();var halfSizeX=size.x/2;start.subVectors(start,wallDir.clone().multiplyScalar(halfSizeX));end.addVectors(end,wallDir.clone().multiplyScalar(halfSizeX));// var start = pos - wallDir * size.x / 2;\n// var end = pos + wallDir * size.x / 2;\n// var localStart = localPos - wallDir * size.x / 2;\n// var localEnd = localPos + wallDir * size.x / 2;\nvar startAndEndPos=[start,end];return startAndEndPos;};BaseWall.prototype.addSubWallCorner=function addSubWallCorner(corner){for(var i=0;i<this.subCorners.length;i++){var subCorner=this.subCorners[i];if(subCorner===corner)return;}this.subCorners.push(corner);// if (!subCornerList.Contains(corner)) {\n//     subCornerList.Add(corner);\n// }\n};createClass(BaseWall,[{key:"worldPosition",get:function get(){var startPos=this.startCorner.worldPosition;var endPos=this.endCorner.worldPosition;var pos=new THREE.Vector3();pos.addVectors(startPos,endPos);pos.divideScalar(2);// var pos = startPos.add(endPos).divide(2);\nreturn pos;}}]);return BaseWall;}(BaseObject);var Util=function(){function Util(){classCallCheck(this,Util);}Util.equalVectorZero=function equalVectorZero(vec){if(vec.x!==0||vec.y!==0||vec.z!==0){return false;}else{return true;}};Util.clone=function clone(obj){var clone=obj.clone();var skinnedMeshes={};obj.traverse(function(node){if(node.isSkinnedMesh){skinnedMeshes[node.name]=node;}});var cloneBones={};var cloneSkinnedMeshes={};clone.traverse(function(node){if(node.isBone){cloneBones[node.name]=node;}if(node.isSkinnedMesh){cloneSkinnedMeshes[node.name]=node;}});var hasSkin=false;for(var name in skinnedMeshes){hasSkin=true;var skinnedMesh=skinnedMeshes[name];var skeleton=skinnedMesh.skeleton;var cloneSkinnedMesh=cloneSkinnedMeshes[name];var orderedCloneBones=[];for(var i=0;i<skeleton.bones.length;++i){var cloneBone=cloneBones[skeleton.bones[i].name];orderedCloneBones.push(cloneBone);}cloneSkinnedMesh.bind(new THREE.Skeleton(orderedCloneBones,skeleton.boneInverses),cloneSkinnedMesh.matrixWorld);}if(hasSkin){clone.hasSkin=true;}else{clone.hasSkin=false;}return clone;};Util.cloneJSObject=function cloneJSObject(obj){// Handle the 3 simple types, and null or undefined or function\nif(null===obj||"object"!==(typeof obj==="undefined"?"undefined":_typeof(obj)))return obj;// Handle Date\nif(obj instanceof Date){var copy=new Date();copy.setTime(obj.getTime());return copy;}// Handle Array or Object\nif(obj instanceof Array|obj instanceof Object){var copy=obj instanceof Array?[]:{};for(var attr in obj){if(obj.hasOwnProperty(attr))copy[attr]=Util.cloneJSObject(obj[attr]);}return copy;}throw new Error("Unable to clone obj! Its type isn\'t supported.");};return Util;}();/**\r\n\t * @author pzx 2018.2.12\r\n\t * Wall\r\n\t */var BaseStraightManualWall=function(_BaseWall){inherits(BaseStraightManualWall,_BaseWall);function BaseStraightManualWall(){classCallCheck(this,BaseStraightManualWall);var _this=possibleConstructorReturn(this,_BaseWall.call(this));_this.startCorner=null;_this.endCorner=null;_this.thick=DefaultSetting.StraightManualWallThick;_this.height=DefaultSetting.StraightManualWallHeight;// this.thick = 0.25;\n// this.height = 3;\n_this.cornersVertices=[new THREE.Vector3(),new THREE.Vector3(),new THREE.Vector3(),new THREE.Vector3()];_this.direction=null;_this.pathPoints=[];_this.selfPathPoints=[];_this.upDirection=new THREE.Vector3(0,1,0);_this.downDirection=new THREE.Vector3(0,-1,0);_this.basePoints=null;_this.repeatUV=[];_this.uvMultiple=[1,1];_this.rightSideLength=null;_this.leftSideLength=null;_this.floorPlanHeight=3;_this.rightSideMeshInfo=new MeshInfo();_this.leftSideMeshInfo=new MeshInfo();_this.edgeSideMeshInfo=new MeshInfo();_this.defaultWallTexture=null;_this.rightWallTexture=null;_this.leftWallTexture=null;_this.startUVPercent=[0,0,0,0];_this.endUVPercent=[1,1,1,1];_this.wallGroup=null;_this.leftResource=null;_this.rightResource=null;_this.edgeResource=null;_this.lightMapResource=null;_this.isBuilded=false;_this.vectorUp=new THREE.Vector3(0,1,0);_this.onlyBuildMeshInfo=false;// this.downDirection = new THREE.Vector3(0, -1, 0);\n_this.enableLightMap=DefaultSetting.enableManaulWallLightMap;_this.aoMapIntensity=DefaultSetting.wallLightMapIntensity;return _this;}// 获取位置（世界）\nBaseStraightManualWall.prototype.leftResourceCallback=function leftResourceCallback(tex){};BaseStraightManualWall.prototype.rightResourceCallback=function rightResourceCallback(tex){this.rigthWallTexture=tex;if(this.isBuilded){this.wallGroup[0].material.texture=this.rigthWallTexture;}};BaseStraightManualWall.prototype.resourceCallback=function resourceCallback(resource){if(resource===this.leftResource){this.leftWallTexture=resource.texture;this.initLightMap();if(this.isBuilded&&this.wallGroup){// this.wallGroup.children[1].material.map = this.leftWallTexture;\n// this.wallGroup.children[1].material.needsUpdate = true;\nif(this.enableLightMap){this.wallGroup.children[0].material=this.leftResource.wallLightMaterial;}else{this.wallGroup.children[0].material=this.leftResource.material;}this.wallGroup.children[0].material.needsUpdate=true;}}else if(resource===this.rightResource){this.rigthWallTexture=resource.texture;this.initLightMap();if(this.isBuilded&&this.wallGroup){// this.wallGroup.children[0].material.map = this.rigthWallTexture;\n// this.wallGroup.children[0].material.needsUpdate = true;\nif(this.enableLightMap){this.wallGroup.children[1].material=this.leftResource.wallLightMaterial;}else{this.wallGroup.children[1].material=this.leftResource.material;}// this.wallGroup.children[0].material = this.rightResource.wallMaterial;\n// this.wallGroup.children[0].material.needsUpdate = true;\n}}};BaseStraightManualWall.prototype.initMaterial=function initMaterial(){if(this.leftResource){if(this.leftResource.ready){this.leftWallTexture=this.leftResource.texture;}else{this.leftResource.callbackObjects.push(this);}}else if(!this.leftWallTexture){this.leftWallTexture=DefaultResource.wallTexture;}if(this.rightResource){if(this.rightResource.ready){this.rightWallTexture=this.rightResource.texture;}else{this.rightResource.callbackObjects.push(this);}}else if(!this.rightWallTexture){this.rightWallTexture=DefaultResource.wallTexture;}if(this.leftResource){this.leftSideMeshInfo.resource=this.leftResource;this.leftSideMeshInfo.material=this.leftResource.material;// new THREE.MeshStandardMaterial({color: 0xffffff, map:this.leftWallTexture});\n}else{this.leftSideMeshInfo.material=new THREE.MeshStandardMaterial({map:null});}if(this.rightResource){this.rightSideMeshInfo.resource=this.rightResource;this.rightSideMeshInfo.material=this.rightResource.material;// new THREE.MeshStandardMaterial({color: 0xffffff,map: this.rightWallTexture});\n}else{this.rightSideMeshInfo.material=new THREE.MeshStandardMaterial({map:null});}if(this.edgeResource){this.edgeSideMeshInfo.resource=this.edgeResource;this.edgeSideMeshInfo.material=this.edgeResource.material;// DefaultResource.wallEdgeMaterial;//new THREE.MeshStandardMaterial({map: DefaultResource.wallEdgeTexture});\n}else{this.edgeSideMeshInfo.material=new THREE.MeshStandardMaterial({map:null});}this.initLightMap();};BaseStraightManualWall.prototype.initLightMap=function initLightMap(){if(this.lightMapResource&&this.enableLightMap){if(this.rightResource.ready){//还要考虑材质公用的问题,现在地板跟墙用了材质，先测试使用，可以考虑在res增加专属墙的材质\nif(this.rightResource.wallLightMaterial===undefined){this.rightResource.wallLightMaterial=this.rightResource.wallMaterial.clone();}this.rightSideMeshInfo.material=this.rightResource.wallLightMaterial;this.rightSideMeshInfo.material.aoMap=this.lightMapResource.texture;this.rightSideMeshInfo.material.defines["WALL_AO"]=true;this.rightSideMeshInfo.material.metalness=0.2;this.rightSideMeshInfo.material.roughness=0.8;}if(this.leftResource.ready){if(this.leftResource.wallLightMaterial===undefined){this.leftResource.wallLightMaterial=this.leftResource.wallMaterial.clone();}this.leftSideMeshInfo.material=this.leftResource.wallLightMaterial;// this.leftSideMeshInfo.material.aoMap = this.lightMapResource.texture;\n// this.leftSideMeshInfo.material.defines["WALL_AO"] = true;\nthis.leftSideMeshInfo.material.metalness=0;this.leftSideMeshInfo.material.roughness=1;}}};BaseStraightManualWall.prototype.build=function build(){this.baseBuild();this.calPosInfo();this.calEachSideLen();this.calRepeatUV();this.calBasePoints();this.fillMesh();this.initMaterial();// this.initSimpleCornersAndWalls();\nif(!this.onlyBuildMeshInfo){var pos=this.position;var group=new THREE.Group("wall");group.add(this.createMesh(this.leftSideMeshInfo));group.add(this.createMesh(this.rightSideMeshInfo));group.add(this.createMesh(this.edgeSideMeshInfo));group.position.set(pos.x,pos.y,pos.z);this.wallGroup=group;this.mesh=this.wallGroup;}this.isBuilded=true;};BaseStraightManualWall.prototype.baseBuild=function baseBuild(){this.direction=new THREE.Vector3();this.direction.subVectors(this.endCorner.position,this.startCorner.position);this.direction.normalize();this.pathPoints.push(this.startCorner.position);this.pathPoints.push(this.endCorner.position);// this.position = this.endCorner.position.add(this.startCorner.position.position).divide(2);\n};BaseStraightManualWall.prototype.calEachSideLen=function calEachSideLen(){var dir=new THREE.Vector3();dir.subVectors(this.endCorner.position,this.startCorner.position);dir.normalize();var halfThick=this.thick/2;var dir_up=new THREE.Vector3();// dir_up.crossVectors(this.upDirection, dir);\ndir_up.crossVectors(this.downDirection,dir);dir_up.normalize();var dir_down=dir_up.clone();dir_down.negate();var resultUp=dir_up.clone();resultUp.multiplyScalar(halfThick);var resultDown=dir_down.clone();resultDown.multiplyScalar(halfThick);var rightStart=new THREE.Vector3();var rightEnd=new THREE.Vector3();var leftStart=new THREE.Vector3();var leftEnd=new THREE.Vector3();if(Util.equalVectorZero(this.cornersVertices[0])){rightStart.addVectors(this.selfPathPoints[0],resultUp);}else{rightStart.copy(this.cornersVertices[0]);}if(Util.equalVectorZero(this.cornersVertices[3])){rightEnd.addVectors(this.selfPathPoints[1],resultUp);}else{rightEnd.copy(this.cornersVertices[3]);}if(Util.equalVectorZero(this.cornersVertices[1])){leftStart.addVectors(this.selfPathPoints[0],resultDown);}else{leftStart.copy(this.cornersVertices[1]);}if(Util.equalVectorZero(this.cornersVertices[2])){leftEnd.addVectors(this.selfPathPoints[1],resultDown);}else{leftEnd.copy(this.cornersVertices[2]);}this.rightSideLength=new THREE.Vector3();this.leftSideLength=new THREE.Vector3();this.rightSideLength.subVectors(rightStart,rightEnd);this.leftSideLength.subVectors(leftStart,leftEnd);this.rightSideLength=this.rightSideLength.length();this.leftSideLength=this.leftSideLength.length();};BaseStraightManualWall.prototype.calRepeatUV=function calRepeatUV(){this.repeatUV[0]=this.uvMultiple[0]*this.rightSideLength/this.floorPlanHeight;this.repeatUV[1]=this.uvMultiple[1]*this.height/this.floorPlanHeight;this.repeatUV[2]=this.uvMultiple[0]*this.leftSideLength/this.floorPlanHeight;this.repeatUV[3]=this.uvMultiple[1]*this.height/this.floorPlanHeight;};BaseStraightManualWall.prototype.calPosInfo=function calPosInfo(){var pos=new THREE.Vector3();this.selfPathPoints.push(pos.subVectors(this.startCorner.position,this.position));// this.selfPathPoints.push(this.endCorner.position.sub(this.position));\npos=new THREE.Vector3();this.selfPathPoints.push(pos.subVectors(this.endCorner.position,this.position));this.selfPathPoints[0].y=0;this.selfPathPoints[1].y=0;};BaseStraightManualWall.prototype.calBasePoints=function calBasePoints(){if(this.basePoints===null){this.basePoints=[];for(var i=0;i<12;i++){this.basePoints.push(new THREE.Vector3());}}var halfThick=this.thick/2;var dir_up=new THREE.Vector3();// dir_up.crossVectors(this.upDirection, this.direction);\ndir_up.crossVectors(this.downDirection,this.direction);dir_up.normalize();var dir_down=dir_up.clone();dir_down.negate();var result=dir_up.multiplyScalar(halfThick);if(Util.equalVectorZero(this.cornersVertices[0])){this.basePoints[4].x=this.selfPathPoints[0].x+result.x;this.basePoints[4].y=0;this.basePoints[4].z=this.selfPathPoints[0].z+result.z;}else{this.basePoints[4].x=this.cornersVertices[0].x;this.basePoints[4].y=0;this.basePoints[4].z=this.cornersVertices[0].z;}if(Util.equalVectorZero(this.cornersVertices[1])){// ||subWallList.Count > 0) {\nresult=dir_down.multiplyScalar(halfThick);this.basePoints[5].x=this.selfPathPoints[0].x+result.x;this.basePoints[5].y=0;this.basePoints[5].z=this.selfPathPoints[0].z+result.z;//this.cornersVertices[1] = this.basePoints[5];\n}else{this.basePoints[5].x=this.cornersVertices[1].x;this.basePoints[5].y=0;this.basePoints[5].z=this.cornersVertices[1].z;}var negateDir=this.direction.clone();// dir_up.crossVectors(this.upDirection, negateDir.negate());// this.upDirection.cross(negateDir.negate());\ndir_up.crossVectors(this.downDirection,negateDir.negate());// this.upDirection.cross(negateDir.negate());\ndir_up.normalize();dir_down=dir_up.clone();dir_down.negate();if(Util.equalVectorZero(this.cornersVertices[2])){// || subWallList.Count > 0) {\nresult=dir_up.clone();result.multiplyScalar(halfThick);// result = halfThick * dir_up;\nthis.basePoints[6].x=this.selfPathPoints[1].x+result.x;this.basePoints[6].y=0;this.basePoints[6].z=this.selfPathPoints[1].z+result.z;//this.cornersVertices[2] = this.basePoints[6];\n}else{this.basePoints[6].x=this.cornersVertices[2].x;this.basePoints[6].y=0;this.basePoints[6].z=this.cornersVertices[2].z;}if(Util.equalVectorZero(this.cornersVertices[3])){// || subWallList.Count > 0) {\nresult=dir_down.clone();result.multiplyScalar(halfThick);// result = halfThick * dir_down;\nthis.basePoints[7].x=this.selfPathPoints[1].x+result.x;this.basePoints[7].y=0;this.basePoints[7].z=this.selfPathPoints[1].z+result.z;//this.cornersVertices[3] = this.basePoints[7];\n}else{this.basePoints[7].x=this.cornersVertices[3].x;this.basePoints[7].y=0;this.basePoints[7].z=this.cornersVertices[3].z;}// if (this.basePoints[0] == null)\n//     this.basePoints[0] = Vector3.zero;\n// if (this.basePoints[1] == null)\n//     this.basePoints[1] = Vector3.zero;\n// if (this.basePoints[2] == null)\n//     this.basePoints[2] = Vector3.zero;\n// if (this.basePoints[3] == null)\n//     this.basePoints[3] = Vector3.zero;\nthis.basePoints[0].x=this.basePoints[4].x;this.basePoints[0].y=this.basePoints[4].y+this.height;this.basePoints[0].z=this.basePoints[4].z;this.basePoints[1].x=this.basePoints[5].x;this.basePoints[1].y=this.basePoints[5].y+this.height;this.basePoints[1].z=this.basePoints[5].z;this.basePoints[2].x=this.basePoints[6].x;this.basePoints[2].y=this.basePoints[6].y+this.height;this.basePoints[2].z=this.basePoints[6].z;this.basePoints[3].x=this.basePoints[7].x;this.basePoints[3].y=this.basePoints[7].y+this.height;this.basePoints[3].z=this.basePoints[7].z;this.basePoints[8].x=this.selfPathPoints[0].x;this.basePoints[8].y=this.selfPathPoints[0].y+this.height;this.basePoints[8].z=this.selfPathPoints[0].z;this.basePoints[9].x=this.selfPathPoints[1].x;this.basePoints[9].y=this.selfPathPoints[1].y+this.height;this.basePoints[9].z=this.selfPathPoints[1].z;};BaseStraightManualWall.prototype.fillMesh=function fillMesh(){this.leftSideMeshInfo.positionArray=new Float32Array(18);this.leftSideMeshInfo.normalArray=new Float32Array(18);this.leftSideMeshInfo.uvArray=new Float32Array(12);this.leftSideMeshInfo.indexArray=new Float32Array(6);this.rightSideMeshInfo.positionArray=new Float32Array(18);this.rightSideMeshInfo.normalArray=new Float32Array(18);this.rightSideMeshInfo.uvArray=new Float32Array(12);this.rightSideMeshInfo.indexArray=new Float32Array(6);this.edgeSideMeshInfo.positionArray=new Float32Array(72);this.edgeSideMeshInfo.normalArray=new Float32Array(72);this.edgeSideMeshInfo.uvArray=new Float32Array(48);this.edgeSideMeshInfo.indexArray=new Float32Array(24);if(this.lightMapResource){this.leftSideMeshInfo.uv2Array=new Float32Array(12);this.rightSideMeshInfo.uv2Array=new Float32Array(12);this.leftSideMeshInfo.uv2Array=new Float32Array(12);}for(var i=0;i<6;i++){this.leftSideMeshInfo.indexArray[i]=i;this.rightSideMeshInfo.indexArray[i]=i;}for(var i=0;i<24;i++){this.edgeSideMeshInfo.indexArray[i]=i;}//定死使用全部的数，不保证里面的的12都有值\nvar vertices=this.basePoints;var index=0;var rightDir=new THREE.Vector3();// rightDir.crossVectors(this.upDirection, this.direction); //Vector3.Cross(this.upDirection, mDir);\nrightDir.crossVectors(this.downDirection,this.direction);//Vector3.Cross(this.upDirection, mDir);\nrightDir.normalize();var leftDir=new THREE.Vector3();// leftDir.crossVectors(this.direction, this.upDirection); //Vector3.Cross(mDir, this.upDirection);\nleftDir.crossVectors(this.direction,this.downDirection);//Vector3.Cross(mDir, this.upDirection);\nleftDir.normalize();var wallDir=this.direction;var reverseWallDir=wallDir.clone();reverseWallDir.negate();var verticesFL=new Array();//右手的面,默认是\nverticesFL[index++]=vertices[0];verticesFL[index++]=vertices[7];verticesFL[index++]=vertices[3];verticesFL[index++]=vertices[0];verticesFL[index++]=vertices[4];verticesFL[index++]=vertices[7];//左手的面\nverticesFL[index++]=vertices[2];verticesFL[index++]=vertices[5];verticesFL[index++]=vertices[1];verticesFL[index++]=vertices[2];verticesFL[index++]=vertices[6];verticesFL[index++]=vertices[5];//顶部面\nverticesFL[index++]=vertices[0];verticesFL[index++]=vertices[2];verticesFL[index++]=vertices[1];verticesFL[index++]=vertices[0];verticesFL[index++]=vertices[3];verticesFL[index++]=vertices[2];//如果有悬空，则补一下底部的面\nif(this.suspend!==0){verticesFL[index++]=vertices[4];verticesFL[index++]=vertices[5];verticesFL[index++]=vertices[6];verticesFL[index++]=vertices[4];verticesFL[index++]=vertices[6];verticesFL[index++]=vertices[7];}//起点截面的一侧\nverticesFL[index++]=vertices[1];verticesFL[index++]=vertices[4];verticesFL[index++]=vertices[0];verticesFL[index++]=vertices[1];verticesFL[index++]=vertices[5];verticesFL[index++]=vertices[4];//终点截面的另一侧\nverticesFL[index++]=vertices[3];verticesFL[index++]=vertices[7];verticesFL[index++]=vertices[2];verticesFL[index++]=vertices[2];verticesFL[index++]=vertices[7];verticesFL[index++]=vertices[6];//startcorner的补画mesh\nverticesFL[index++]=vertices[1];verticesFL[index++]=vertices[8];verticesFL[index++]=vertices[0];//endcorner的补画mesh\nverticesFL[index++]=vertices[3];verticesFL[index++]=vertices[9];verticesFL[index++]=vertices[2];// FillUV();\nindex=0;var normals=new Array();//一侧的面\nnormals[index++]=rightDir;normals[index++]=rightDir;normals[index++]=rightDir;normals[index++]=rightDir;normals[index++]=rightDir;normals[index++]=rightDir;for(var i=0;i<normals.length;i++){var vec=normals[i];var arrayIndex=i*3;this.rightSideMeshInfo.normalArray[arrayIndex]=vec.x;this.rightSideMeshInfo.normalArray[arrayIndex+1]=vec.y;this.rightSideMeshInfo.normalArray[arrayIndex+2]=vec.z;}//另一侧的面\nnormals[index++]=leftDir;normals[index++]=leftDir;normals[index++]=leftDir;normals[index++]=leftDir;normals[index++]=leftDir;normals[index++]=leftDir;for(var i=6,j=0;i<normals.length;i++,j++){var vec=normals[i];var arrayIndex=j*3;this.leftSideMeshInfo.normalArray[arrayIndex]=vec.x;this.leftSideMeshInfo.normalArray[arrayIndex+1]=vec.y;this.leftSideMeshInfo.normalArray[arrayIndex+2]=vec.z;}//顶部面\nnormals[index++]=this.upDirection;normals[index++]=this.upDirection;normals[index++]=this.upDirection;normals[index++]=this.upDirection;normals[index++]=this.upDirection;normals[index++]=this.upDirection;//如果有悬空，则补一下底部的面\nif(this.suspend!==0){normals[index++]=this.downDirection;normals[index++]=this.downDirection;normals[index++]=this.downDirection;normals[index++]=this.downDirection;normals[index++]=this.downDirection;normals[index++]=this.downDirection;}//截面的一侧\nnormals[index++]=reverseWallDir;normals[index++]=reverseWallDir;normals[index++]=reverseWallDir;normals[index++]=reverseWallDir;normals[index++]=reverseWallDir;normals[index++]=reverseWallDir;//截面的另一侧\nnormals[index++]=wallDir;normals[index++]=wallDir;normals[index++]=wallDir;normals[index++]=wallDir;normals[index++]=wallDir;normals[index++]=wallDir;//startcorner的填补的mesh\nnormals[index++]=this.upDirection;normals[index++]=this.upDirection;normals[index++]=this.upDirection;//endcorner的填补的mesh\nnormals[index++]=this.upDirection;normals[index++]=this.upDirection;normals[index++]=this.upDirection;for(var i=0;i<6;i++){var vec=verticesFL[i];var arrayIndex=i*3;this.rightSideMeshInfo.positionArray[arrayIndex]=vec.x;this.rightSideMeshInfo.positionArray[arrayIndex+1]=vec.y+this.suspend;this.rightSideMeshInfo.positionArray[arrayIndex+2]=vec.z;}for(var i=6,j=0;i<12;i++,j++){var vec=verticesFL[i];var arrayIndex=j*3;this.leftSideMeshInfo.positionArray[arrayIndex]=vec.x;this.leftSideMeshInfo.positionArray[arrayIndex+1]=vec.y+this.suspend;this.leftSideMeshInfo.positionArray[arrayIndex+2]=vec.z;}for(var i=12,j=0;i<verticesFL.length;i++,j++){var vec=verticesFL[i];var arrayIndex=j*3;this.edgeSideMeshInfo.positionArray[arrayIndex]=vec.x;this.edgeSideMeshInfo.positionArray[arrayIndex+1]=vec.y+this.suspend;this.edgeSideMeshInfo.positionArray[arrayIndex+2]=vec.z;}for(var i=12,j=0;i<normals.length;i++,j++){var vec=normals[i];var arrayIndex=j*3;this.edgeSideMeshInfo.normalArray[arrayIndex]=vec.x;this.edgeSideMeshInfo.normalArray[arrayIndex+1]=vec.y;this.edgeSideMeshInfo.normalArray[arrayIndex+2]=vec.z;}this.fillUV();};BaseStraightManualWall.prototype.fillUV=function fillUV(){var index=0;var uv_0,uv_1,uv_2,uv_3;if(this.rightResource.isDefault){uv_0=this.startUVPercent[0];uv_1=this.startUVPercent[1];uv_2=this.endUVPercent[0];uv_3=this.endUVPercent[1];}else{uv_0=this.startUVPercent[0]*this.repeatUV[0];uv_1=this.startUVPercent[1]*this.repeatUV[1];uv_2=this.endUVPercent[0]*this.repeatUV[0];uv_3=this.endUVPercent[1]*this.repeatUV[1];}//右侧\nvar uv=this.rightSideMeshInfo.uvArray;uv[index++]=uv_0;uv[index++]=uv_3;uv[index++]=uv_2;uv[index++]=uv_1;uv[index++]=uv_2;uv[index++]=uv_3;uv[index++]=uv_0;uv[index++]=uv_3;uv[index++]=uv_0;uv[index++]=uv_1;uv[index++]=uv_2;uv[index++]=uv_1;//左侧\nif(this.leftResource.isDefault){uv_0=this.startUVPercent[2];uv_1=this.startUVPercent[3];uv_2=this.endUVPercent[2];uv_3=this.endUVPercent[3];}else{uv_0=this.startUVPercent[2]*this.repeatUV[2];uv_1=this.startUVPercent[3]*this.repeatUV[3];uv_2=this.endUVPercent[2]*this.repeatUV[2];uv_3=this.endUVPercent[3]*this.repeatUV[3];}index=0;var uv=this.leftSideMeshInfo.uvArray;uv[index++]=uv_2;uv[index++]=uv_3;uv[index++]=uv_0;uv[index++]=uv_1;uv[index++]=uv_0;uv[index++]=uv_3;uv[index++]=uv_2;uv[index++]=uv_3;uv[index++]=uv_2;uv[index++]=uv_1;uv[index++]=uv_0;uv[index++]=uv_1;//顶部\nindex=0;var uv=this.edgeSideMeshInfo.uvArray;uv[index++]=0;uv[index++]=1;uv[index++]=1;uv[index++]=0;uv[index++]=1;uv[index++]=1;uv[index++]=0;uv[index++]=1;uv[index++]=0;uv[index++]=0;uv[index++]=1;uv[index++]=0;//起点一侧\nuv[index++]=0;uv[index++]=1;uv[index++]=1;uv[index++]=0;uv[index++]=1;uv[index++]=1;uv[index++]=0;uv[index++]=1;uv[index++]=0;uv[index++]=0;uv[index++]=1;uv[index++]=0;//终点一侧\nuv[index++]=0;uv[index++]=1;uv[index++]=0;uv[index++]=0;uv[index++]=1;uv[index++]=1;uv[index++]=0;uv[index++]=0;uv[index++]=1;uv[index++]=1;uv[index++]=1;uv[index++]=0;//startcorner的填补的mesh\nuv[index++]=0;uv[index++]=1;uv[index++]=0;uv[index++]=0;uv[index++]=1;uv[index++]=1;//endcorner的填补的mesh\nuv[index++]=0;uv[index++]=1;uv[index++]=0;uv[index++]=0;uv[index++]=1;uv[index++]=1;if(this.lightMapResource){//填写光线图\nuv_0=this.startUVPercent[0];uv_1=this.startUVPercent[1];uv_2=this.endUVPercent[0];uv_3=this.endUVPercent[1];index=0;uv=this.rightSideMeshInfo.uv2Array;uv[index++]=uv_0;uv[index++]=uv_3;uv[index++]=uv_2;uv[index++]=uv_1;uv[index++]=uv_2;uv[index++]=uv_3;uv[index++]=uv_0;uv[index++]=uv_3;uv[index++]=uv_0;uv[index++]=uv_1;uv[index++]=uv_2;uv[index++]=uv_1;uv=this.leftSideMeshInfo.uv2Array;index=0;uv[index++]=uv_2;uv[index++]=uv_3;uv[index++]=uv_0;uv[index++]=uv_1;uv[index++]=uv_0;uv[index++]=uv_3;uv[index++]=uv_2;uv[index++]=uv_3;uv[index++]=uv_2;uv[index++]=uv_1;uv[index++]=uv_0;uv[index++]=uv_1;}};BaseStraightManualWall.prototype.getWallOtherCorner=function getWallOtherCorner(corner){if(this.startCorner===corner){return this.endCorner;}else if(this.endCorner===corner){return this.startCorner;}else{return null;}};BaseStraightManualWall.prototype.createMesh=function createMesh(meshInfo){var geometry=new THREE.BufferGeometry();geometry.addAttribute(\'position\',new THREE.BufferAttribute(meshInfo.positionArray,3));geometry.addAttribute(\'normal\',new THREE.BufferAttribute(meshInfo.normalArray,3));geometry.addAttribute(\'uv\',new THREE.BufferAttribute(meshInfo.uvArray,2));var material=meshInfo.material;if(this.lightMapResource&&meshInfo.uv2Array&&this.enableLightMap){geometry.addAttribute(\'uv2\',new THREE.BufferAttribute(meshInfo.uv2Array,2));}meshInfo.material=material;var mesh=new THREE.Mesh(geometry,material);return mesh;};createClass(BaseStraightManualWall,[{key:\'position\',get:function get(){var startPos=this.startCorner.position;var endPos=this.endCorner.position;var pos=new THREE.Vector3();pos.addVectors(startPos,endPos);pos.divideScalar(2);// var pos = startPos.add(endPos).divide(2);\nreturn pos;},set:function set(value){}}]);return BaseStraightManualWall;}(BaseWall);/**\r\n\t * @author pzx 2018.6.6\r\n\t * SubStraightManualWall\r\n\t */var SubStraightManualWall=function(_BaseStraightManualWa){inherits(SubStraightManualWall,_BaseStraightManualWa);function SubStraightManualWall(){classCallCheck(this,SubStraightManualWall);return possibleConstructorReturn(this,_BaseStraightManualWa.call(this));}SubStraightManualWall.prototype.build=function build(){this.baseBuild();this.calPosInfo();// this.calEachSideLen();\n// this.calRepeatUV();\nthis.calBasePoints();this.fillMesh();this.initMaterial();// this.initSimpleCornersAndWalls();\nif(!this.enableDelayLoadMode){var pos=this.position;var group=new THREE.Group("wall");group.add(this.createMesh(this.leftSideMeshInfo));group.add(this.createMesh(this.rightSideMeshInfo));group.add(this.createMesh(this.edgeSideMeshInfo));group.position.set(pos.x,pos.y,pos.z);this.wallGroup=group;this.mesh=this.wallGroup;}this.isBuilded=true;};return SubStraightManualWall;}(BaseStraightManualWall);/**\r\n\t * @author pzx 2018.2.12\r\n\t * WallCorner\r\n\t */// import {ModelWall} from \'./ModelWall\';\nvar WallCorner=function(_BaseObject){inherits(WallCorner,_BaseObject);function WallCorner(x,y,z){classCallCheck(this,WallCorner);var _this=possibleConstructorReturn(this,_BaseObject.call(this));_this.walls=[];_this.position=new THREE.Vector3(x,y,z);return _this;}WallCorner.prototype.addWall=function addWall(wall){for(var i=0,len=this.walls.length;i<len;i++){if(this.walls[i]===wall){console.error("repeat wall"+wall);return;}}this.walls.push(wall);};WallCorner.prototype.build=function build(){this.calVertices();};WallCorner.prototype.isFirstWallShouldNotCal=function isFirstWallShouldNotCal(wall){return!(wall instanceof Wall)||wall instanceof SubStraightManualWall;};WallCorner.prototype.isSecondWallShouldNotCal=function isSecondWallShouldNotCal(wall){return wall!=null&&(wall.resource&&wall.resource.isModel||wall instanceof SubStraightManualWall);};WallCorner.prototype.calVertices=function calVertices(){var walls=this.walls;var upDir=new THREE.Vector3(0,-1,0);if(walls.length===1){var wall=walls[0];if(wall instanceof Wall)this.setDefaultCornerVertices(wall);}else{this.sortWalls();for(var i=0;i<walls.length;i++){var wall1=walls[i];// if (!(wall1 instanceof Wall))\nif(this.isFirstWallShouldNotCal(wall1))continue;var wall2=null;var j=i;while(wall2==null){if(j===walls.length-1){j=0;}else{j+=1;}if(walls[j]===wall1)break;wall2=walls[j];if(this.isSecondWallShouldNotCal(wall2))wall2=null;}if(!wall2){this.setDefaultCornerVertices(wall1);continue;}// if (!(wall2 instanceof Wall))\n//     continue;\nvar otherPoint=wall1.getWallOtherCorner(this).position;var firstDir=new THREE.Vector3();firstDir.subVectors(otherPoint,this.position);// otherPoint - this.position;\notherPoint=wall2.getWallOtherCorner(this).position;var secondDir=new THREE.Vector3();secondDir.subVectors(otherPoint,this.position);// otherPoint - this.position;\nfirstDir.normalize();secondDir.normalize();if(firstDir.length()===0||secondDir.length()===0){this.setDefaultCornerVertices(wall1,true);this.setDefaultCornerVertices(wall2,false);continue;}var halfThick=wall1.thick/2;var verticalDir1=new THREE.Vector3();verticalDir1.crossVectors(upDir,firstDir);// upDir.cross(firstDir);\nverticalDir1.normalize();var linePoint1=verticalDir1.clone();linePoint1.multiplyScalar(halfThick);linePoint1.add(this.position);// this.position + verticalDir1 * halfThick;\nhalfThick=wall2.thick/2;var verticalDir2=secondDir.clone();verticalDir2.cross(upDir);// secondDir.cross(upDir);\nverticalDir2.normalize();var linePoint2=verticalDir2.clone();linePoint2.multiplyScalar(halfThick);linePoint2.add(this.position);// this.position + verticalDir2 * halfThick;\nthis.setCornersVertices(wall1,linePoint1,true);this.setCornersVertices(wall2,linePoint2,false);firstDir.normalize();secondDir.normalize();var angle=this.calAngle(firstDir,secondDir);if(angle>30){var intersectPoint;if(Math.abs(firstDir.dot(secondDir))===1){var verticalDir=firstDir.clone();verticalDir.cross(upDir);// firstDir.cross(upDir);\nverticalDir.normalize();this.setDefaultCornerVertices(wall1,true);this.setDefaultCornerVertices(wall2,true);continue;}else{intersectPoint=this.getIntersectPosition(linePoint1,firstDir,linePoint2,secondDir);//计算交点\n}if(intersectPoint.x!==0||intersectPoint.y!==0||intersectPoint.z!==0){var point=intersectPoint.clone();point.y=this.position.y+this.getWallHeight();this.setCornersVertices(wall1,intersectPoint,true);this.setCornersVertices(wall2,intersectPoint,false);}}else{this.setCornersVertices(wall1,linePoint1,true);this.setCornersVertices(wall2,linePoint2,false);}}}};WallCorner.prototype.sortWalls=function sortWalls(){var walls=this.walls;if(walls.length>1){var standardWall=walls[0];var low=0;var high=walls.length-1;var tmp;var j;while(low<high){for(j=low;j<high;++j){//正 向冒泡,找到最大者\nif(this.angleBetween(standardWall,walls[j])>this.angleBetween(standardWall,walls[j+1])){tmp=walls[j];walls[j]=walls[j+1];walls[j+1]=tmp;}}--high;//修改high值, 前移一位\nfor(j=high;j>low;--j){//反向冒泡,找到最小者\nif(this.angleBetween(standardWall,walls[j])<this.angleBetween(standardWall,walls[j-1])){tmp=walls[j];walls[j]=walls[j-1];walls[j-1]=tmp;}}++low;//修改low值,后移一位\n}}};WallCorner.prototype.angleBetween=function angleBetween(wallA,wallB){var dir_1=wallA.getWallOtherCorner(this).position.clone();dir_1.sub(this.position);var dir_2=wallB.getWallOtherCorner(this).position.clone();dir_2.sub(this.position);return this.calAngle(dir_1,dir_2);};WallCorner.prototype.calAngle=function calAngle(fromDir,toDir){fromDir.normalize();toDir.normalize();var angle=fromDir.angleTo(toDir);angle*=180/Math.PI;var result=fromDir.clone();result.cross(toDir);if(result.y>0){angle=360-angle;}return angle;};WallCorner.prototype.getWallHeight=function getWallHeight(){var height=99999;for(var i=0;i<this.walls.length;i++){var wall=this.walls[i];if(height>wall.height){height=wall.height;}}return height;};WallCorner.prototype.setCornersVertices=function setCornersVertices(wall,pos,flag){var refPos=new THREE.Vector3(0,0,0);refPos.x=pos.x-wall.position.x;refPos.y=pos.y-wall.position.y;refPos.z=pos.z-wall.position.z;if(wall.startCorner===this){if(flag){wall.cornersVertices[0].x=refPos.x;wall.cornersVertices[0].y=refPos.y;wall.cornersVertices[0].z=refPos.z;}else{wall.cornersVertices[1].x=refPos.x;wall.cornersVertices[1].y=refPos.y;wall.cornersVertices[1].z=refPos.z;}}else{if(flag){wall.cornersVertices[2].x=refPos.x;wall.cornersVertices[2].y=refPos.y;wall.cornersVertices[2].z=refPos.z;}else{wall.cornersVertices[3].x=refPos.x;wall.cornersVertices[3].y=refPos.y;wall.cornersVertices[3].z=refPos.z;}}};WallCorner.prototype.setDefaultCornerVertices=function setDefaultCornerVertices(wall,flag){var upVector3=new THREE.Vector3(0,-1,0);//墙的另一个点\nvar otherPoint=wall.getWallOtherCorner(this).position;//以交点为起点，计算向量\n//Vector3 dir_1 = otherPoint - RelativePosition;\nvar dir_1=otherPoint.clone();dir_1.sub(this.position);dir_1.normalize();var halfThick=wall.thick/2;var verticalDir_1=upVector3.clone();verticalDir_1.cross(dir_1);verticalDir_1.normalize();verticalDir_1.multiplyScalar(halfThick);var linePoint_1=new THREE.Vector3();linePoint_1.addVectors(this.position,verticalDir_1);// this.position.add(verticalDir_1.multiplyScalar(halfThick));\nvar linePoint_2=new THREE.Vector3();linePoint_2.subVectors(this.position,verticalDir_1);//this.position.sub(verticalDir_1.multiplyScalar(halfThick));\nif(flag===undefined){this.setCornersVertices(wall,linePoint_1,true);this.setCornersVertices(wall,linePoint_2,false);}else{if(flag){this.setCornersVertices(wall,linePoint_1,true);}else{this.setCornersVertices(wall,linePoint_2,false);}}};WallCorner.prototype.getIntersectPosition=function getIntersectPosition(posA,dirA,posB,dirB){if(posA.x===posB.x&&posA.y===posB.y&&posA.z===posB.z){return posA;}var height=posA.y;if(dirA.dot(dirB)===1){throw"two line in same direction ,can not cal intersected position!";}var posC=new THREE.Vector3();var posD=new THREE.Vector3();posC.addVectors(posA,dirA);posD.addVectors(posB,dirB);var a=new THREE.Vector2(posA.x,posA.z);var b=new THREE.Vector2(posC.x,posC.z);var c=new THREE.Vector2(posB.x,posB.z);var d=new THREE.Vector2(posD.x,posD.z);var denominator=(b.y-a.y)*(d.x-c.x)-(a.x-b.x)*(c.y-d.y);if(denominator==0){//\t\t\tisIntersect = false;\nreturn new THREE.Vector3();}// 线段所在直线的交点坐标 (x , y)\nvar x=((b.x-a.x)*(d.x-c.x)*(c.y-a.y)+(b.y-a.y)*(d.x-c.x)*a.x-(d.y-c.y)*(b.x-a.x)*c.x)/denominator;var y=-((b.y-a.y)*(d.y-c.y)*(c.x-a.x)+(b.x-a.x)*(d.y-c.y)*a.y-(d.x-c.x)*(b.y-a.y)*c.y)/denominator;//\t\tisIntersect = true;\nreturn new THREE.Vector3(x,height,y);};return WallCorner;}(BaseObject);/**\r\n\t * @author pzx 2018.6.6\r\n\t * SubWallCorner\r\n\t */var SubWallCorner=function(_WallCorner){inherits(SubWallCorner,_WallCorner);function SubWallCorner(){classCallCheck(this,SubWallCorner);return possibleConstructorReturn(this,_WallCorner.call(this));}SubWallCorner.createSubWallCorner=function createSubWallCorner(id,pos,parentWall){var corner=new SubWallCorner();corner.id=id;corner.position=pos;corner.parent=parentWall.parent;// parentWall.subCorners.push(corner);\nreturn corner;};SubWallCorner.prototype.isFirstWallShouldNotCal=function isFirstWallShouldNotCal(wall){return!(wall instanceof SubStraightManualWall);};SubWallCorner.prototype.isSecondWallShouldNotCal=function isSecondWallShouldNotCal(wall){return wall&&!(wall instanceof SubStraightManualWall);};return SubWallCorner;}(WallCorner);/**\r\n\t * @author pzx 2018.2.12\r\n\t * Wall\r\n\t */var Wall=function(_BaseStraightManualWa){inherits(Wall,_BaseStraightManualWa);function Wall(){classCallCheck(this,Wall);return possibleConstructorReturn(this,_BaseStraightManualWa.call(this));}Wall.prototype.initSimpleCornersAndWalls=function initSimpleCornersAndWalls(){var wallPos=this.position;// for (var i = 0; i < this.subWalls.Count; i++) {\n//     Core_Wall wall = subWallList[i];\n//     wall.Clear();\n// }\n// subWallList.Clear();\n// subCornerList.Clear();\nvar lookRot=new THREE.Vector3();lookRot.crossVectors(this.direction,this.vectorUp);// Vector3 projectRightTopOffSet = Vector3.Project(TopOffSet, lookRot);\n// float projectWallDirTopLen = Vector3.Project(TopOffSet,GetDirection()).magnitude;\n// float uMoveOffSet = LocalTopOffSet.x / Length;\nvar list=this.sortDoorOrWins();// WallDecorateParam decorateParam = GetDecorateParam();\nfor(var i=0;i<list.length;i++){var master=list[i];// if (master.Size == Vector3.zero)\n//     continue;\n//master.Refresh();\nvar startAndEndPos=this.getDoorOrWinStartAndEndPos(master);// GetDoorOrWinStartAndEndPos(master);\nvar doorWinRestPoints=this.getDoorOrWinRectPoints(master);var startCorner_DoorOrWin=SubWallCorner.createSubWallCorner(this.id+"_"+i+"_1",startAndEndPos[0],this);var endCorner_DoorOrWin=SubWallCorner.createSubWallCorner(this.id+"_"+i+"_2",startAndEndPos[1],this);// var startCorner_DoorOrWin = Core_WallCorner.CreateSubWallCorner(ID + "_" + i + "_1", startAndEndPos[0], startAndEndPos[2], this);\n// var endCorner_DoorOrWin = Core_WallCorner.CreateSubWallCorner(ID + "_" + i + "_2", startAndEndPos[1], startAndEndPos[3], this);\nthis.addSubWallCorner(startCorner_DoorOrWin);this.addSubWallCorner(endCorner_DoorOrWin);if(i===0){var wall1=new SubStraightManualWall();// Core_SubStraightManualWall();\nthis.subWalls.push(wall1);wall1.startCorner=this.startCorner;wall1.endCorner=startCorner_DoorOrWin;// wall1.SetWallDecorateParam(decorateParam);\nwall1.startCorner.build();// wall1.startTopOffSet = TopOffSet;\n// wall1.EndTopOffSet = projectRightTopOffSet;\nwall1.endCorner.build();//设置subwall的corner信息，因为跟父亲墙的corner顶点是一样的\nthis.setCornerVertices(wall1,true);wall1.calPosInfo();wall1.calEachSideLen();//wall1.EndUVPercent[0] = wall1.Length / Length;\nwall1.endUVPercent[0]=wall1.rightSideLength/this.rightSideLength;wall1.endUVPercent[2]=wall1.leftSideLength/this.leftSideLength;// if (TopOffSet != Vector3.zero) {\n//     wall1.TopLightUVEndMoveOffSet = uMoveOffSet;\n// }\nwall1.repeatUV=this.repeatUV;//wall1.Build();\nwall1.leftResource=this.leftResource;wall1.rightResource=this.rightResource;wall1.edgeResource=this.edgeResource;wall1.lightMapResource=this.lightMapResource;wall1.height=this.height;wall1.parentWall=this;// this.calLightUV(wall1);\n}else{var lastDoorOrWin=list[i-1];var lastStartAndEndPos=this.getDoorOrWinStartAndEndPos(lastDoorOrWin);var lastDoorWinRestPoints=this.getDoorOrWinRectPoints(lastDoorOrWin);var lastEndCorner=this.getWallCornerByPos(lastStartAndEndPos[1]);var manulWall=new SubStraightManualWall();this.subWalls.push(manulWall);// subWallList.Add(manulWall);\nmanulWall.startCorner=lastEndCorner;manulWall.endCorner=startCorner_DoorOrWin;var offset=new THREE.Vector3();offset.subVectors(lastEndCorner.position,startCorner_DoorOrWin.position);var wallLength=offset.length();manulWall.startCorner.build();manulWall.endCorner.build();manulWall.calPosInfo();manulWall.calEachSideLen();var rightSideDis=lastDoorWinRestPoints[3].distanceTo(wallPos.clone().addVectors(this.cornersVertices[0],wallPos));// Vector3.Distance(mCornersVertices[0] + wallPos, lastDoorWinRestPoints[3]);\n// var leftSideDis = Vector3.Distance(mCornersVertices[1] + wallPos, lastDoorWinRestPoints[2]);\nvar leftSideDis=lastDoorWinRestPoints[2].distanceTo(wallPos.clone().addVectors(this.cornersVertices[1],wallPos));// Vector3.Distance(mCornersVertices[1] + wallPos, lastDoorWinRestPoints[2]);\n// if (TopOffSet != Vector3.zero) {\n//     manulWall.TopLightUVEndMoveOffSet = uMoveOffSet;\n//     manulWall.TopLightUVStartMoveOffSet = uMoveOffSet;\n// }\nmanulWall.startUVPercent[0]=rightSideDis/this.rightSideLength;manulWall.startUVPercent[2]=leftSideDis/this.leftSideLength;manulWall.endUVPercent[0]=(rightSideDis+wallLength)/this.rightSideLength;manulWall.endUVPercent[2]=(leftSideDis+wallLength)/this.leftSideLength;manulWall.repeatUV=this.repeatUV;manulWall.leftResource=this.leftResource;manulWall.rightResource=this.rightResource;manulWall.edgeResource=this.edgeResource;manulWall.lightMapResource=this.lightMapResource;manulWall.height=this.height;manulWall.parentWall=this;}if(i==list.length-1){// var wall2 = new Core_SubStraightManualWall();\nvar wall2=new SubStraightManualWall();this.subWalls.push(wall2);// subWallList.Add(wall2);\nwall2.startCorner=endCorner_DoorOrWin;wall2.endCorner=this.endCorner;// wall2.SetWallDecorateParam(decorateParam);\nwall2.startCorner.build();//wall2.EndCorner.Build();\nthis.setCornerVertices(wall2,false);// wall2.StartTopOffSet = projectRightTopOffSet;\n// wall2.EndTopOffSet = TopOffSet;\nwall2.calPosInfo();wall2.calEachSideLen();// var rightSideDis = Vector3.Distance(mCornersVertices[0] + wallPos, doorWinRestPoints[3]);\n// var leftSideDis = Vector3.Distance(mCornersVertices[1] + wallPos, doorWinRestPoints[2]);\nvar rightSideDis=doorWinRestPoints[3].distanceTo(wallPos.clone().addVectors(this.cornersVertices[0],wallPos));//\n// Vector3.Distance(mCornersVertices[0] + wallPos, doorWinRestPoints[3]);\nvar leftSideDis=doorWinRestPoints[2].distanceTo(wallPos.clone().addVectors(this.cornersVertices[1],wallPos));// Vector3.Distance(mCornersVertices[1] + wallPos, doorWinRestPoints[2]);\n// if (TopOffSet != Vector3.zero) {\n//     wall2.TopLightUVStartMoveOffSet = uMoveOffSet;\n// }\nwall2.startUVPercent[0]=rightSideDis/this.rightSideLength;wall2.startUVPercent[2]=leftSideDis/this.leftSideLength;wall2.repeatUV=this.repeatUV;wall2.leftResource=this.leftResource;wall2.rightResource=this.rightResource;wall2.edgeResource=this.edgeResource;wall2.lightMapResource=this.lightMapResource;wall2.height=this.height;wall2.parentWall=this;//wall2.Build();\n// CalLightUV(wall2);\n}this.buildHeadAndFootWall(master,startCorner_DoorOrWin,endCorner_DoorOrWin);}};Wall.prototype.buildSimpleCornersAndWalls=function buildSimpleCornersAndWalls(){if(!this.enableDelayLoadMode){this.wallGroup=new THREE.Object3D();}for(var i=0;i<this.subCorners.length;i++){var subCorner=this.subCorners[i];subCorner.build();}for(var i=0;i<this.subWalls.length;i++){var subWall=this.subWalls[i];subWall.build();if(!this.enableDelayLoadMode){this.wallGroup.add(subWall.wallGroup);}}this.mesh=this.wallGroup;};/// <summary>\n/// 创建门窗的上下墙\n/// </summary>\n/// <param name="doorOrWindow"></param>\n/// <param name="startCorner"></param>\n/// <param name="endCorner"></param>\nWall.prototype.buildHeadAndFootWall=function buildHeadAndFootWall(doorOrWindow,startCorner,endCorner){var wallPos=this.position;//float len = Vector3.Distance(StartCorner.Position, startCorner.Position);\nvar doorWinRestPoints=this.getDoorOrWinRectPoints(doorOrWindow);var rightSideDis=doorWinRestPoints[0].distanceTo(wallPos.clone().addVectors(this.cornersVertices[0],wallPos));//\n// Vector3.Distance(mCornersVertices[0] + wallPos, doorWinRestPoints[0]);\n// float leftSideDis = Vector3.Distance(mCornersVertices[1] + wallPos, doorWinRestPoints[1]);\nvar leftSideDis=doorWinRestPoints[1].distanceTo(wallPos.clone().addVectors(this.cornersVertices[1],wallPos));//\n// Vector3.Distance(mCornersVertices[1] + wallPos, doorWinRestPoints[1]);\n// var uMoveOffSet =  (Vector3.Project(TopOffSet, GetDirection()).magnitude) / Length;\n// float uMoveOffSet =  (Vector3.Project(TopOffSet, GetDirection()).magnitude) / Length;\nvar windowBelowPercent=doorOrWindow.suspendPercent;//因为一个corner里有多个同样位置的墙，所以有可能对生成floor有影响\n//计算倾斜的数据\n// var bSize = BoundSizes\n// Vector3 topStartPos = StartCorner.Position;\n// topStartPos.y += Height;\n// topStartPos += TopOffSet;\nvar lookRot=new THREE.Vector3();lookRot.crossVectors(this.direction,this.vectorUp);var size=doorOrWindow.size;var suspend=size.y+this.height*windowBelowPercent;if(doorOrWindow.suspendPercent!==0){var belowWall=new SubStraightManualWall();this.subWalls.push(belowWall);belowWall.parent=this.parent;belowWall.startCorner=startCorner;belowWall.endCorner=endCorner;var offset=new THREE.Vector3();offset.subVectors(endCorner.position,startCorner.position);var wallLength=offset.length();// belowWall.SetWallDecorateParam(GetDecorateParam());\nbelowWall.height=this.height*windowBelowPercent;belowWall.startUVPercent=[rightSideDis/this.rightSideLength,0,leftSideDis/this.leftSideLength,0];belowWall.endUVPercent[0]=(rightSideDis+wallLength)/this.rightSideLength;belowWall.endUVPercent[1]=belowWall.height/this.height;belowWall.endUVPercent[2]=(leftSideDis+wallLength)/this.leftSideLength;belowWall.endUVPercent[3]=belowWall.height/this.height;// belowWall.TopLightUVStartMoveOffSet = LocalTopOffSet.x / Length;\n// belowWall.TopLightUVEndMoveOffSet = LocalTopOffSet.x / Length;\nbelowWall.uvMultiple=this.uvMultiple;belowWall.repeatUV=this.repeatUV;belowWall.leftResource=this.leftResource;belowWall.rightResource=this.rightResource;belowWall.edgeResource=this.edgeResource;belowWall.lightMapResource=this.lightMapResource;// belowWall.height = this.height;\n// belowWall.StartTopOffSet = projectRightTopOffSet * doorOrWindow.SuspendPercent  ;\n// belowWall.EndTopOffSet = projectRightTopOffSet * doorOrWindow.SuspendPercent ;\n// belowWall.TopOffSet = projectRightTopOffSet * doorOrWindow.SuspendPercent * forwordTopOffSetLen/Height ;\nbelowWall.parentWall=this;}if(suspend<this.height){var wall=new SubStraightManualWall();this.subWalls.push(wall);wall.parent=this.parent;wall.startCorner=startCorner;wall.endCorner=endCorner;var offset=new THREE.Vector3();offset.subVectors(endCorner.position,startCorner.position);var wallLength=offset.length();// wall.SetWallDecorateParam(GetDecorateParam());\nwall.suspend=suspend;wall.height=this.height-suspend;wall.startUVPercent=[rightSideDis/this.rightSideLength,suspend/this.height,leftSideDis/this.leftSideLength,suspend/this.height];wall.endUVPercent[0]=(rightSideDis+wallLength)/this.rightSideLength;wall.endUVPercent[2]=(leftSideDis+wallLength)/this.leftSideLength;wall.uvMultiple=this.uvMultiple;wall.repeatUV=this.repeatUV;wall.leftResource=this.leftResource;wall.rightResource=this.rightResource;wall.edgeResource=this.edgeResource;wall.lightMapResource=this.lightMapResource;// wall.height  =this.height;\nwall.parentWall=this;}};/// <summary>\n/// 设置sub墙的顶点，只有sub墙才会由父墙设置部分顶点，因为sub墙的一个墙角跟父墙公用，所以顶点也是一样的\n/// 就没有必要在计算了，直接赋值\n/// </summary>\n/// <param name="wall"></param>\n/// <param name="vertices"></param>\n/// <param name="flag">true为起始点，false为结束点</param>\nWall.prototype.setCornerVertices=function setCornerVertices(wall,flag){//注意CornersVertices里是相对坐标，不是绝对坐标\nif(flag){var posA=new THREE.Vector3();posA.addVectors(this.cornersVertices[0],this.position);posA.sub(wall.position);var posB=new THREE.Vector3();posB.addVectors(this.cornersVertices[1],this.position);posB.sub(wall.position);wall.cornersVertices[0]=posA;wall.cornersVertices[1]=posB;}else{var posA=new THREE.Vector3();posA.addVectors(this.cornersVertices[2],this.position);posA.sub(wall.position);var posB=new THREE.Vector3();posB.addVectors(this.cornersVertices[3],this.position);posB.sub(wall.position);wall.cornersVertices[2]=posA;wall.cornersVertices[3]=posB;// wall.CornersVertices[2] = CornersVertices[2] + Position - wall.Position;\n// wall.CornersVertices[3] = CornersVertices[3] + Position - wall.Position;\n}};/// <summary>\n/// 获取门窗2d平面下四个角的点\n/// </summary>\n/// <param name="doorOrWin"></param>\n/// <returns></returns>\nWall.prototype.getDoorOrWinRectPoints=function getDoorOrWinRectPoints(doorOrWin){var halfThick=this.thick/2;var dir_up=new THREE.Vector3();dir_up.crossVectors(this.vectorUp,this.direction);dir_up.normalize();var dir_down=dir_up.clone();dir_down.negate();var result=this.vectorUp.clone();result.multiplyScalar(halfThick);// halfThick * dir_up;\nvar size=doorOrWin.size;var wallDir=this.direction;var pos=doorOrWin.position;var halfSizeX=size.x/2;var start=new THREE.Vector3();var end=new THREE.Vector3();start.subVectors(pos,wallDir.clone().multiplyScalar(halfSizeX));end.addVectors(pos,wallDir.clone().multiplyScalar(halfSizeX));var startAndEndPos=[start.clone().addVectors(start,dir_up.clone().multiplyScalar(halfThick)),start.clone().addVectors(start,dir_down.clone().multiplyScalar(halfThick)),end.clone().addVectors(end,dir_down.clone().multiplyScalar(halfThick)),end.clone().addVectors(end,dir_up.clone().multiplyScalar(halfThick))];// Vector3 start = pos - wallDir * size.x / 2;\n// Vector3 end = pos + wallDir * size.x / 2;\n// Vector3[] startAndEndPos = new Vector3[]{\n// start+halfThick * dir_up,start+halfThick * dir_down,\n// end + halfThick * dir_down,end+halfThick * dir_up\nreturn startAndEndPos;};return Wall;}(BaseStraightManualWall);/**\r\n\t * @author pzx 2018.2.18\r\n\t * Floor\r\n\t */var Floor=function(_BaseObject){inherits(Floor,_BaseObject);function Floor(room){classCallCheck(this,Floor);var _this=possibleConstructorReturn(this,_BaseObject.call(this));_this.mesh=null;_this.shapePath=null;_this.holePaths=null;_this.room=room;_this.isDoubleSide=false;_this.texture=DefaultResource.floorTexture;_this.enableLightMap=DefaultSetting.enableFloorLightMap;_this.material=null;_this.geometry=null;_this.resource=null;_this.height=null;_this.blockSize=null;_this.DefaultHeight=0.01;return _this;}Floor.prototype.resourceCallback=function resourceCallback(resource){this.texture=resource.texture;if(this.mesh){this.mesh.material.map=this.texture;this.mesh.material.needsUpdate=true;}};Floor.prototype.initResource=function initResource(){var resource=this.room.floorResource;if(resource){if(resource.ready){this.texture=resource.texture;this.material=resource.material;}else{if(!DefaultSetting.enableCombine||this.room.userID||this.room.name||this.room.properties){resource.registerListener(this);}}}if(this.room.lightMapResource&&this.enableLightMap){this.material=resource;this.material.aoMap=this.room.lightMapResource.texture;}};Floor.prototype.build=function build(){if(!this.enableDelayLoadMode){//延迟合并的时候统一注册\nthis.initResource();}if(this.shapePath.length!==4||this.holePaths.length!==0){//仅针对四边形，其他的不适用\nthis.enableLightMap=false;}var center=new THREE.Vector3();for(var i=0;i<this.shapePath.length;i++){var point=this.shapePath[i];center.x+=point.x;center.z+=point.y;}center.x/=this.shapePath.length;center.z/=this.shapePath.length;var shape=new THREE.Shape(this.shapePath);if(this.holePaths){for(var i=0;i<this.holePaths.length;i++){var holePath=this.holePaths[i];shape.holes.push(new THREE.Path(holePath));}}var geometry=new THREE.ShapeGeometry(shape);if(this.blockSize){for(var i=0;i<geometry.faceVertexUvs.length;i++){var uvs=geometry.faceVertexUvs[i];for(var j=0;j<uvs.length;j++){var uv=uvs[j];for(var k=0;k<uv.length;k++){var vec2=uv[k];vec2.set(vec2.x/this.blockSize.x,vec2.y/this.blockSize.y);}}}}geometry.uvsNeedUpdate=true;this.geometry=geometry;// var uvs = geometry.attributes.uv.array;\n// geometry.addAttribute( \'uv2\', new THREE.BufferAttribute( uvs, 2 ) );\n//把uv变成一整张图贴上去，不再重复\n// geometry.faceVertexUvs = this.reCalUV(geometry);\nvar material=null;if(this.height===null){this.height=this.DefaultHeight;}if(this.room.lightMapResource&&this.enableLightMap){var res=this.room.floorResource;if(res.floorLightMaterial===undefined){res.floorLightMaterial=new THREE.MeshBasicMaterial({map:res.texture});}this.material=res.floorLightMaterial;this.material.aoMap=this.room.lightMapResource.texture;this.calLightMapUV(geometry);material=this.material;}else{material=this.room.floorResource.roomMaterial;}// var height = 0;\n// if (this.height) {\n//     height = this.height;\n// }\nmaterial.side=THREE.DoubleSide;if(material===undefined){console.error("floor material is null");}this.mesh=new THREE.Mesh(geometry,material);this.mesh.name="floor";this.mesh.position.y=this.height;this.mesh.rotateX(-Math.PI/2);if(this.room.center){var center=this.room.center;this.mesh.position.set(center.x,0,center.z);}this.mesh.visible=this.isShow;};Floor.prototype.calLightMapUV=function calLightMapUV(geometry){var faces=geometry.faceVertexUvs;faces[1]=[];var maxX,maxY,minX,minY;for(var i=0;i<faces.length;i++){var faceTris=faces[i];for(var j=0;j<faceTris.length;j++){var uvs=faceTris[j];for(var k=0;k<uvs.length;k++){var uv=uvs[k];if(maxX===undefined){maxX=uv.x;maxY=uv.y;minX=uv.x;minY=uv.y;continue;}if(uv.x>maxX){maxX=uv.x;}if(uv.x<minX){minX=uv.x;}if(uv.y>maxY){maxY=uv.y;}if(uv.y<minY){minY=uv.y;}}}}// var toPositiveDeltaX = Math.abs(minX);\n// var toPositiveDeltaY = Math.abs(minY)\n// maxX = maxX + toPositiveDeltaX;\n// maxY = maxY + toPositiveDeltaY;\nvar newFaces=[];// for (var i = 0; i < faces.length; i++) {\nvar faceUVs=faces[0];var newFaceTris=[];for(var j=0;j<faceUVs.length;j++){var uvs=faceUVs[j];var newUVs=[];for(var k=0;k<uvs.length;k++){var uv=uvs[k];var newVec=new THREE.Vector2();var x=uv.x===maxX?1:0;var y=uv.y===maxY?1:0;newVec.set(x,y);newUVs.push(newVec);// newUVs.push(uv);\n}newFaceTris.push(newUVs);}// newFaces.push(newFaceTris);\n// }\nfaces[1]=newFaceTris;// console.log(faces);\n// return newFaces;\n};Floor.prototype.reCalUV=function reCalUV(geometry){var faces=geometry.faceVertexUvs;var maxX,maxY,minX,minY;for(var i=0;i<faces.length;i++){var faceTris=faces[i];for(var j=0;j<faceTris.length;j++){var uvs=faceTris[j];for(var k=0;k<uvs.length;k++){var uv=uvs[k];if(maxX===undefined){maxX=uv.x;maxY=uv.y;minX=uv.x;minY=uv.y;continue;}if(uv.x>maxX){maxX=uv.x;}if(uv.x<minX){minX=uv.x;}if(uv.y>maxY){maxY=uv.y;}if(uv.y<minY){minY=uv.y;}}}}var toPositiveDeltaX=Math.abs(minX);var toPositiveDeltaY=Math.abs(minY);maxX=maxX+toPositiveDeltaX;maxY=maxY+toPositiveDeltaY;var newFaces=[];for(var i=0;i<faces.length;i++){var faceUVs=faces[i];var newFaceTris=[];for(var j=0;j<faceUVs.length;j++){var uvs=faceUVs[j];var newUVs=[];for(var k=0;k<uvs.length;k++){var uv=uvs[k];var newVec=new THREE.Vector2();newVec.set((uv.x+toPositiveDeltaX)/maxX,(uv.y+toPositiveDeltaY)/maxY);newUVs.push(newVec);// newUVs.push(uv);\n}newFaceTris.push(newUVs);}newFaces.push(newFaceTris);}return newFaces;};return Floor;}(BaseObject);/**\r\n\t * @author pzx 2018.2.18\r\n\t * Ceiling\r\n\t */var Ceiling=function(_BaseObject){inherits(Ceiling,_BaseObject);function Ceiling(room){classCallCheck(this,Ceiling);var _this=possibleConstructorReturn(this,_BaseObject.call(this));_this.mesh=null;_this.shapePath=[];_this.holePaths=null;_this.center=null;_this.room=room;_this.material=null;_this.geometry=null;_this.resource=null;_this.height=null;_this.blockSize=null;// for (var i = points.length-1; i >-1; i--) {\n//     var point = points[i];\n//     var newPoint = point.clone();\n//     this.points.push(newPoint);\n// }\nreturn _this;}Ceiling.prototype.initResource=function initResource(){var resource=this.room.ceilingResource;if(resource){if(resource.ready){this.texture=resource.texture;this.material=resource.material;}else{if(!DefaultSetting.enableCombine||this.room.userID||this.room.name||this.room.properties){resource.registerListener(this);}}}};Ceiling.prototype.resourceCallback=function resourceCallback(resource){this.texture=resource.texture;if(this.mesh){this.mesh.material.map=this.texture;this.mesh.material.needsUpdate=true;}};Ceiling.prototype.build=function build(){if(!this.enableDelayLoadMode){//延迟合并的时候统一注册\nthis.initResource();}var shape=new THREE.Shape(this.shapePath);if(this.holePaths){for(var i=0;i<this.holePaths.length;i++){var holePath=this.holePaths[i];shape.holes.push(new THREE.Path(holePath));}}var geometry=new THREE.ShapeGeometry(shape);this.material=this.room.ceilingResource.roomMaterial;this.geometry=geometry;if(this.blockSize){for(var i=0;i<geometry.faceVertexUvs.length;i++){var uvs=geometry.faceVertexUvs[i];for(var j=0;j<uvs.length;j++){var uv=uvs[j];for(var k=0;k<uv.length;k++){var vec2=uv[k];vec2.set(vec2.x/this.blockSize.x,vec2.y/this.blockSize.y);}}}}geometry.uvsNeedUpdate=true;// var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );\nvar material=null;// if(DefaultResource.floorTexture){\n//     material = new THREE.MeshStandardMaterial( { map: DefaultResource.ceilingTexture } );\n// }else{\n//     material = new THREE.MeshStandardMaterial( { map:null });\n// }\nmaterial=this.room.ceilingResource.roomMaterial;this.mesh=new THREE.Mesh(geometry,material);this.mesh.name="ceiling";this.mesh.rotateX(Math.PI/2);var height=2.9;if(this.room.parent){height=this.room.parent.height;}if(this.height){height=this.height;}this.height=height;// for (var i = 0; i < geometry.vertices.length; i++) {\n//     var ver = geometry.vertices[i];\n//     ver.y = height;\n// }\n// geometry.verticesNeedUpdate = true;\nthis.mesh.position.y=height;this.mesh.updateMatrixWorld();if(this.room.center){var center=this.room.center;this.mesh.position.set(center.x,3,center.z);}this.mesh.visible=this.isShow;// this.mesh.matr\n};return Ceiling;}(BaseObject);/**\r\n\t * @author pzx 2018.2.18\r\n\t * Roof\r\n\t */var Roof=function(_BaseObject){inherits(Roof,_BaseObject);function Roof(room){classCallCheck(this,Roof);var _this=possibleConstructorReturn(this,_BaseObject.call(this));_this.mesh=null;_this.shapePath=[];_this.holePaths=null;_this.center=null;_this.room=room;_this.material=null;_this.geometry=null;_this.resource=null;_this.height=null;_this.blockSize=null;// this.isShow = false;\nreturn _this;}Roof.prototype.resourceCallback=function resourceCallback(resource){this.texture=resource.texture;if(this.mesh){this.mesh.material.map=this.texture;this.mesh.material.needsUpdate=true;}};Roof.prototype.initResource=function initResource(){var resource=this.room.roofResource;if(resource){if(resource.ready){this.texture=resource.texture;this.material=resource.material;}else{if(!DefaultSetting.enableCombine||this.room.userID||this.room.name||this.room.properties){resource.registerListener(this);}}}};Roof.prototype.build=function build(){if(!this.enableDelayLoadMode){//延迟合并的时候统一注册\nthis.initResource();}var shape=new THREE.Shape(this.shapePath);if(this.holePaths){for(var i=0;i<this.holePaths.length;i++){var holePath=this.holePaths[i];shape.holes.push(new THREE.Path(holePath));}}var geometry=new THREE.ShapeGeometry(shape);this.geometry=geometry;this.material=this.room.roofResource.roomMaterial;if(this.blockSize){for(var i=0;i<geometry.faceVertexUvs.length;i++){var uvs=geometry.faceVertexUvs[i];for(var j=0;j<uvs.length;j++){var uv=uvs[j];for(var k=0;k<uv.length;k++){var vec2=uv[k];vec2.set(vec2.x/this.blockSize.x,vec2.y/this.blockSize.y);}}}}geometry.uvsNeedUpdate=true;// var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );\nvar material=null;// if(DefaultResource.floorTexture){\n//     material = new THREE.MeshStandardMaterial( { map: DefaultResource.roofTexture } );\n// }else{\n//     material = new THREE.MeshStandardMaterial( { map: null } );\n// }\nmaterial=this.room.roofResource.roomMaterial;this.mesh=new THREE.Mesh(geometry,material);var height=3;if(this.room.parent){height=this.room.parent.height;}if(this.height){height=this.height;}this.height=height;this.mesh.position.y=height+0.001;// this.mesh.position.y = 3;\n// for (var i = 0; i < geometry.vertices.length; i++) {\n//     var ver = geometry.vertices[i];\n//     ver.y = height;\n// }\n// geometry.verticesNeedUpdate = true;\nthis.mesh.name="roof";this.mesh.rotateX(-Math.PI/2);// var center = this.room.center;\nif(this.room.center){var center=this.room.center;this.mesh.position.set(center.x,this.height,center.z);}// this.mesh.position.set(center.x,3,center.z);\nthis.mesh.updateMatrixWorld();this.mesh.visible=this.isShow;this.mesh.name="roof"+this.id;};return Roof;}(BaseObject);/**\r\n\t * @author pzx 2018.2.18\r\n\t * Room\r\n\t */var Room=function(_BaseObject){inherits(Room,_BaseObject);function Room(roomJson){classCallCheck(this,Room);var _this=possibleConstructorReturn(this,_BaseObject.call(this));_this.dataJson=roomJson;_this.shapePath=[];_this.reverseZShapPath=[];_this.holePaths=[];_this.reverseZHolePaths=[];_this._points=[];_this._holes=[];_this.center=null;_this.meshGroup=null;_this.mesh=null;//测试使用\n_this.offset=null;_this.parentPosition=null;// for (var i = 0; i < this.dataJson["points"].length; i++) {\n//     var posArray = this.dataJson["points"][i];\n//     this.points.push(new THREE.Vector3(posArray[0],posArray[1]));\n// }\n_this.position=new THREE.Vector3();_this.floor=new Floor(_this);_this.roof=new Roof(_this);_this.ceiling=new Ceiling(_this);// if(this.dataJson["center"]){\n//     this.center = new THREE.Vector3(this.dataJson["center"][0],0,this.dataJson["center"][1])\n// }\n_this.floorResource=null;_this.ceilingResource=null;_this.roofResource=null;_this.lightMapResource=null;_this.isOnlyFloor=false;return _this;}Room.prototype.initShapePathPoints=function initShapePathPoints(){var points=this.points;this.shapePath.length=0;this.reverseZShapPath.length=0;for(var i=0;i<points.length;i++){var point=points[i];var newPoint=point.clone();this.shapePath.push(new THREE.Vector2(newPoint.x,newPoint.z));this.reverseZShapPath.push(new THREE.Vector2(newPoint.x,-newPoint.z));}this.floor.shapePath=this.reverseZShapPath;this.ceiling.shapePath=this.shapePath;this.roof.shapePath=this.reverseZShapPath;};Room.prototype.initShapeHolePoints=function initShapeHolePoints(){var holes=this.holes;this.holePaths.length=0;this.reverseZHolePaths.length=0;for(var i=0;i<holes.length;i++){var singleValue=holes[i];var len2=singleValue.length;// var holePoints = [];\nvar holeShapePath=[];var reverseZHoleShapPath=[];for(var j=0;j<len2;j++){var point=singleValue[j];var newPoint=point.clone();// holePoints.push(newPoint);\nholeShapePath.push(new THREE.Vector2(newPoint.x,newPoint.z));reverseZHoleShapPath.push(new THREE.Vector2(newPoint.x,-newPoint.z));}this.holePaths.push(holeShapePath);this.reverseZHolePaths.push(reverseZHoleShapPath);}this.floor.holePaths=this.reverseZHolePaths;this.ceiling.holePaths=this.holePaths;this.roof.holePaths=this.reverseZHolePaths;};Room.prototype.build=function build(){this.initShapePathPoints();this.initShapeHolePoints();if(this.parentPosition&&this.offset){var center=new THREE.Vector3();center.add(this.parentPosition);center.add(this.offset);this.center=center;}else{this.center=null;}if(!this.isOnlyFloor){this.floor.build();this.ceiling.build();this.roof.build();this.meshGroup=new THREE.Object3D("room");this.meshGroup.add(this.floor.mesh);this.meshGroup.add(this.ceiling.mesh);this.meshGroup.add(this.roof.mesh);}else{this.floor.build();// this.ceiling.build();\n// this.roof.build();\nthis.meshGroup=new THREE.Object3D("room");this.meshGroup.add(this.floor.mesh);}this.mesh=this.meshGroup;this.meshGroup.position.set(this.position.x,this.position.y,this.position.z);// if(this.center){\n//     this.meshGroup.position.set(this.center.x,this.center.y,this.center.z);\n// }\n};createClass(Room,[{key:"points",set:function set(points){this._points=points;}// 获取位置（世界）\n,get:function get(){return this._points;}},{key:"holes",set:function set(value){this._holes=value;},get:function get(){return this._holes;}}]);return Room;}(BaseObject);/**\r\n\t * @author pzx 2018.2.14\r\n\t * FloorPlan\r\n\t */var FloorPlan=function(_BaseObject){inherits(FloorPlan,_BaseObject);function FloorPlan(){classCallCheck(this,FloorPlan);var _this=possibleConstructorReturn(this,_BaseObject.call(this));_this.walls=[];_this.corners=[];_this.rooms=[];_this.placements=[];_this.videoprobes=[];_this.curvelines=[];_this.pipelines=[];_this.text3Ds=[];_this.groups=[];_this.height=3;//特殊的因为高度，技术上没有合并的room\n_this.uncombineWithHeigthRooms=[];_this.combinePlacements=[];_this.combineStraightManualWalls=[];_this.combineModelWalls=[];_this.combineRoofs=[];_this.combineCeilings=[];_this.combineFloors=[];_this.combineDoorOrWins=[];_this.curPlacementCombineProcessorMap=new Map();_this.curStraightManualWallCombineProcessorMap=new Map();_this.curModelWallCombineProcessorMap=new Map();_this.curFloorCombineProcessorMap=new Map();_this.curCeilingCombineProcessorMap=new Map();_this.curRoofCombineProcessorMap=new Map();_this.curDoorOrWinCombineProcessorMap=new Map();_this.curGroupCombineProcessorMap=new Map();_this.groupCombineProcessors=[];_this.placementCombineProcessors=[];_this.straightManualWallCombineProcessors=[];_this.modelWallCombineProcessors=[];_this.floorCombineProcessors=[];_this.ceilingCombineProcessors=[];_this.roofCombineProcessors=[];_this.doorOrWindowCombineProcessors=[];return _this;}FloorPlan.prototype.build=function build(){for(var i=0;i<this.corners.length;i++){var corner=this.corners[i];corner.build();}for(var i=0;i<this.walls.length;i++){var wall=this.walls[i];wall.build();for(var j=0;j<wall.doorOrWindows.length;j++){var doorOrWin=wall.doorOrWindows[j];doorOrWin.build();}}for(var i=0;i<this.walls.length;i++){var wall=this.walls[i];if(wall.doorOrWindows.length>0){wall.initSimpleCornersAndWalls();wall.buildSimpleCornersAndWalls();}}for(var i=0;i<this.rooms.length;i++){var room=this.rooms[i];room.build();}for(var i=0;i<this.placements.length;i++){var plc=this.placements[i];plc.build();}for(var i=0;i<this.videoprobes.length;i++){var plc=this.videoprobes[i];plc.build();}for(var i=0;i<this.groups.length;i++){var group=this.groups[i];group.build();}for(var i=0;i<this.text3Ds.length;i++){var text=this.text3Ds[i];text.build();}};FloorPlan.prototype.existsCorner=function existsCorner(x,y,z){for(var i=0,len=this.corners.length;i<len;i++){var pos=this.corners[i].position;if(pos.x===x&&pos.y===y&&pos.z===z){return true;}}return false;};FloorPlan.prototype.addCorner=function addCorner(x,y,z){var corner=new WallCorner(x,y,z);this.corners.push(corner);corner.parent=this;return corner;};FloorPlan.prototype.addWall=function addWall(wall){this.walls.push(wall);};FloorPlan.prototype.getCorner=function getCorner(x,y,z){for(var i=0,len=this.corners.length;i<len;i++){var pos=this.corners[i].position;if(pos.x===x&&pos.y===y&&pos.z===z){return this.corners[i];}}return null;};FloorPlan.prototype.exportTestXS=function exportTestXS(){var map={points:[],edges:[]};var points=[];var edges=[];for(var i=0;i<this.corners.length;i++){var corner=this.corners[i];points.push([corner.position.x,corner.position.z]);}for(var i=0;i<this.walls.length;i++){var wall=this.walls[i];edges.push([this.corners.indexOf(wall.startCorner),this.corners.indexOf(wall.endCorner)]);}map["points"]=points;map["edges"]=edges;return map;};return FloorPlan;}(BaseObject);/**\r\n\t * @author pzx 2018.4.2\r\n\t * Building\r\n\t */var Placement=function(_BaseObject){inherits(Placement,_BaseObject);function Placement(){classCallCheck(this,Placement);var _this=possibleConstructorReturn(this,_BaseObject.call(this));_this.resource=null;_this.mesh=null;_this.model=null;_this.customColor=null;_this.opacity=null;_this.renderMode=null;_this.delayObject=new THREE.Object3D();_this.initCompleteCallback=null;_this.customTextureResource=null;_this.hasSkin=false;_this.isPlayAnim=false;_this.animClip=null;_this.isResouceRegistered=false;return _this;}Placement.prototype.build=function build(){//当没有名字以及属性的时候，则意味着要合并了，所以就不build了\n// if (!this.name && !this.properties) {\n//     return;\n// }\nif(this.enableDelayLoadMode){//延迟合并的时候统一注册\nreturn;}this.initResource();if(this.model===null)return;// if(this.enableBuildMesh){\nthis.instanceModel();// }\n};Placement.prototype.initResource=function initResource(){if(this.resource){if(!this.resource.ready&&!this.isResouceRegistered){this.resource.registerListener(this);this.isResouceRegistered=true;}else{this.model=this.resource.model;}}};Placement.prototype.resourceCallback=function resourceCallback(resource){if(!this.mesh){this.model=resource.model;this.instanceModel();if(this.initCompleteCallback){this.initCompleteCallback(this);}}};Placement.prototype.instanceModel=function instanceModel(){if(this.model===null)return;this.mesh=Util.clone(this.model);this.hasSkin=this.mesh.hasSkin;// this.mesh = this.model;\nthis.mesh.name="placement";this.mesh.position.set(this.position.x,this.position.y,this.position.z);this.mesh.quaternion.set(this.rotation.x,this.rotation.y,this.rotation.z,this.rotation.w);this.mesh.scale.set(this.scale.x,this.scale.y,this.scale.z);this.mesh.visible=this.isShow;this.mesh.name="plc"+this.id;// this.mesh.plcID = this.id;\nif(this.renderMode!==null){this.changeRenderMode(this.mesh);}if(this.customTextureResource){this.changeWithCustomTexture(this.mesh);}if(this.customColor){this.changeWithCustomColor(this.mesh);}this.delayObject.add(this.mesh);};Placement.prototype.changeRenderMode=function changeRenderMode(obj){if(obj instanceof THREE.Mesh){obj.material.color=this.customColor;if(this.renderMode!==null){switch(this.renderMode){case 1:obj.material.transparent=false;obj.material.alphaTest=0.5;break;case 3:case 2:obj.material.transparent=true;break;default:console.error("can not find renderMode "+this.renderMode);}}}for(var i=0;i<obj.children.length;i++){var child=obj.children[i];this.changeRenderMode(child);}};Placement.prototype.changeWithCustomColor=function changeWithCustomColor(obj){if(obj instanceof THREE.Mesh){obj.material.color=this.customColor;if(this.opacity!==null){obj.material.opacity=this.opacity;obj.material.transparent=true;}}for(var i=0;i<obj.children.length;i++){var child=obj.children[i];this.changeWithCustomColor(child);}};Placement.prototype.changeWithCustomTexture=function changeWithCustomTexture(obj){if(obj instanceof THREE.Mesh){obj.material.map=this.customTextureResource.texture;}for(var i=0;i<obj.children.length;i++){var child=obj.children[i];this.changeWithCustomTexture(child);}};return Placement;}(BaseObject);/**\r\n\t * @author pzx 2018.6.7\r\n\t * FloorPlan\r\n\t */var DoorOrWindow=function(_Placement){inherits(DoorOrWindow,_Placement);function DoorOrWindow(){classCallCheck(this,DoorOrWindow);var _this=possibleConstructorReturn(this,_Placement.call(this));_this.suspendPercent=0;_this.size=new THREE.Vector3(1,1,1);_this.attachWall=null;_this.isOpen=false;_this.openDirIndex=0;_this.modelSize=null;return _this;}DoorOrWindow.prototype.build=function build(){this.initModelSize();if(this.model===null){this.initResource();return;}//有可能没有门窗的实例，只是一个空的，只有size，华为需要\nthis.fitAttachWall();this.instanceModel();};DoorOrWindow.prototype.resourceCallback=function resourceCallback(resource){if(!this.mesh){this.model=resource.model;this.build();if(this.initCompleteCallback){this.initCompleteCallback(this);}}};DoorOrWindow.prototype.fitAttachWall=function fitAttachWall(){if(this.attachWall){var wallDir=this.attachWall.direction;var lookAtDir=new THREE.Vector3();lookAtDir.crossVectors(new THREE.Vector3(0,-1,0),wallDir);this.rotation.setFromUnitVectors(new THREE.Vector3(0,0,-1),lookAtDir);this.changeOpenDirection();this.position.y=this.attachWall.height*this.suspendPercent;}};DoorOrWindow.prototype.changeOpenDirection=function changeOpenDirection(){if(this.openDirIndex===1||this.openDirIndex===3){if(!this.resource.hasAnimation()){var rot=new THREE.Quaternion();rot.setFromAxisAngle(new THREE.Vector3(0,1,0),Math.PI);this.rotation.multiply(rot);}}if(this.openDirIndex===0||this.openDirIndex===2){if(this.resource.hasAnimation()){var rot=new THREE.Quaternion();rot.setFromAxisAngle(new THREE.Vector3(0,1,0),Math.PI);this.rotation.multiply(rot);}}};DoorOrWindow.prototype.initModelSize=function initModelSize(){if(this.model){// this.mesh.name = "door";\nvar box=new THREE.Box3();box.makeEmpty();box=box.setFromObject(this.model);this.modelSize=box.getSize();}else{if(this.resource){this.modelSize=this.resource.modelSize;}}//因为门窗会有缩放，所以size要乘以缩放\nif(this.model||this.resource){this.size.set(this.modelSize.x*this.scale.x,this.modelSize.y*this.scale.y,this.modelSize.z*this.scale.z);}};return DoorOrWindow;}(Placement);/**\r\n\t * CombineBundleMesh\r\n\t * 把父亲节点的信息都合并到一个mesh对象里\r\n\t * @author pzx 2017.12.27\r\n\t * @ignore\r\n\t*/var CombineBundleMesh=function CombineBundleMesh(meshObj,localScaleArray,localRotArray,localPosArray){classCallCheck(this,CombineBundleMesh);this.positionArray=meshObj.geometry.getAttribute(\'position\').array.slice();var normalAttr=meshObj.geometry.getAttribute(\'normal\');if(normalAttr){this.normalArray=normalAttr.array.slice();}else{console.warn("not has normal");}var uvAttr=meshObj.geometry.getAttribute(\'uv\');if(uvAttr){this.uvArray=uvAttr.array;}var uv2Attr=meshObj.geometry.getAttribute("uv2");if(uv2Attr){this.uv2Array=uv2Attr.array;}var uv3Attr=meshObj.geometry.getAttribute("uv3");if(uv3Attr){this.uv3Array=uv3Attr.array;}var colorAttr=meshObj.geometry.getAttribute("color");if(colorAttr){this.colorArray=colorAttr.array;}this.indexArray=meshObj.geometry.index.array;this.material=meshObj.material;var posArray=this.positionArray;var normalArray=this.normalArray;for(var b=0;b<posArray.length;){for(var i=localPosArray.length-1;i>-1;i--){var localScale=localScaleArray[i];var localRot=localRotArray[i];var localPos=localPosArray[i];posArray[b]*=localScale.x;posArray[b+1]*=localScale.y;posArray[b+2]*=localScale.z;var vec=new THREE.Vector3(posArray[b],posArray[b+1],posArray[b+2]);vec=vec.applyQuaternion(localRot);vec.x+=localPos.x;vec.y+=localPos.y;vec.z+=localPos.z;posArray[b]=vec.x;posArray[b+1]=vec.y;posArray[b+2]=vec.z;if(normalArray){var normal=new THREE.Vector3(normalArray[b],normalArray[b+1],normalArray[b+2]);normal=normal.applyQuaternion(localRot);normalArray[b]=normal.x;normalArray[b+1]=normal.y;normalArray[b+2]=normal.z;}}b+=3;}this.vertexCount=this.positionArray.length/3;this.indexCount=this.indexArray.length;this.groups=meshObj.geometry.groups;// console.log(this.vertexCount);\n};/**\r\n\t * CombineBundleObject\r\n\t * @author pzx 2017.12.27\r\n\t * @ignore\r\n\t*/var CombineBundleObject$1=function(){function CombineBundleObject(bundleObj){classCallCheck(this,CombineBundleObject);this.bundeObj=bundleObj;// this.app = app;\n// this.models = {};\nthis.materialMap=new Map();this.combineBundleMeshs=[];this.vertexCount=0;}CombineBundleObject.prototype.combine=function combine(){this._combine(this.bundeObj,[],[],[]);};CombineBundleObject.prototype._combine=function _combine(obj,localScaleArray,localRotArray,localPosArray){localScaleArray.push(obj.scale);localPosArray.push(obj.position);localRotArray.push(obj.quaternion);if(obj instanceof THREE.Mesh){var cMesh=new CombineBundleMesh(obj,localScaleArray,localRotArray,localPosArray);if(cMesh.vertexCount!==0){this.combineBundleMeshs.push(cMesh);// if(Array.isArray(cMesh.material)){\n//     console.log("123");\n// }\nif(this.materialMap.get(cMesh.material)===undefined){this.materialMap.set(cMesh.material,[]);}this.materialMap.get(cMesh.material).push(cMesh);}this.vertexCount+=cMesh.vertexCount;}if(obj.children.length!==0){for(var i=0;i<obj.children.length;i++){var parentLocalRotArray=localRotArray.slice();var parentLocalScaleArray=localScaleArray.slice();var parentLocalPosArray=localPosArray.slice();this._combine(obj.children[i],parentLocalScaleArray,parentLocalRotArray,parentLocalPosArray);}}};return CombineBundleObject;}();var Resource=function(){function Resource(manager){classCallCheck(this,Resource);this.url=null;this.isEmpty=false;this.callbackObjects=[];this.ready=false;this.texture=null;this.model=null;this.modelName=null;this.modelID=null;// this.material = new THREE.MeshStandardMaterial({roughness:1});\nthis.material=new THREE.MeshStandardMaterial();this.wallMaterial=new THREE.MeshStandardMaterial({color:0xffffff});// this.wallMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});\nthis.roomMaterial=new THREE.MeshLambertMaterial({color:0xffffff});this.id=null;this.ext=null;this.baseUrl=null;this.version=null;this.isDefault=false;this.animations=null;this.isCombine=false;this.combineBundleObj=null;this.manager=manager;this.modelSize=null;// this.hasAnim = false;\nthis.animations=null;this.tryHightedtVersion=false;this.debug=false;this.gltfRoot=null;}Resource.prototype.registerListener=function registerListener(obj){this.callbackObjects.push(obj);};Resource.prototype.combine=function combine(){if(this.model){this.combineBundleObj=new CombineBundleObject$1(this.model);this.combineBundleObj.combine();if(this.combineBundleObj.vertexCount>=60000){this.isCombine=false;console.error("combine "+this.id+" exceed max vectex");}else{this.isCombine=true;}}};Resource.prototype.hasAnimation=function hasAnimation(){if(this.animations===undefined){return false;}if(this.animations===null){return false;}if(Array.isArray(this.animations)&&this.animations.length===0){return false;}return true;};Resource.prototype.getTextureUrl=function getTextureUrl(){return this.baseUrl+this.id+"."+(this.ext===null?"jpg":this.ext);};Resource.prototype.getModelUrl=function getModelUrl(){return this.baseUrl+this.id+"/"+this.version+"/gltf/";};Resource.prototype.downloadTexture=function downloadTexture(cb){var that=this;if(this.ext==="bundle"){that.ready=true;console.warn("not support bundle texture");cb();return;}var texLoader=new THREE.TextureLoader();texLoader.setCrossOrigin("anonymous");var url=null;if(this.url){url=this.url;}else{url=this.baseUrl+this.id+"."+(this.ext===null?"jpg":this.ext);}// this.url = url;\ntexLoader.load(// texture.flipY = true;\n// resource URL\n// that.sceneURL+"/"+texUri,\nurl,// Function when resource is loaded\nfunction(texture){texture.wrapS=THREE.RepeatWrapping;texture.wrapT=THREE.RepeatWrapping;texture.flipY=true;that.texture=texture;// that.material =new THREE.MeshStandardMaterial({color: 0xffffff, map:texture});\n// that.material = new THREE.MeshStandardMaterial({color: 0xffffff, map: texture});\nthat.material.map=texture;that.wallMaterial.map=texture;that.roomMaterial.map=texture;that.ready=true;that.material.roughness=1;// if(that.callback){\n//     that.callback(texture);\n// }\nif(that.debug){console.log(that.id+" download complete");}that.downloadCallback(cb);},// Function called when download progresses\nfunction(xhr){console.log(url+" "+xhr.loaded/xhr.total*100+\'% loaded\');},// Function called when download errors\nfunction(xhr){that.ready=true;console.error("download error "+url);that.downloadCallback(cb);});};Resource.prototype.downloadModel=function downloadModel(cb){var that=this;var loader=new thingjs.GLTFLoader();var url=null;var version=0;//如果开启使用最高版本，则用0，否则用本身的版本\nif(!this.manager.enableUserHighestVersionResource){version=this.version;}if(this.url){url=this.url;}else{url=this.baseUrl+this.id+"/"+version+"/gltf/";}loader.loadFromURL({url:url,modelCallback:function modelCallback(root){that.animations=root.animations;that.model=root.node;that.ready=true;that.downloadCallback(cb);if(that.debug){console.log(that.id+" download complete");}},errorCallback:function errorCallback(){console.error("download error "+url);that.ready=true;// that.model = new THREE.Object3D();\nthat.isEmpty=true;that.downloadCallback(cb);}});};Resource.prototype.downloadCallback=function downloadCallback(cb){try{for(var i=0;i<this.callbackObjects.length;i++){var obj=this.callbackObjects[i];obj.resourceCallback(this);}if(cb){cb();}}catch(e){console.error(e);}};Resource.prototype.dispose=function dispose(){if(this.texture){this.texture.dispose();}if(this.model){this._disposeModel(this.model);}};Resource.prototype._disposeModel=function _disposeModel(obj){for(var i=0;i<obj.children.length;i++){var child=obj.children[i];this._disposeModel(child);}if(obj instanceof THREE.Mesh){var mat=obj.material;var geo=obj.geometry;var tex=obj.material.texture;if(mat){mat.dispose();}if(geo){geo.dispose();}if(tex){tex.dispose();}}};createClass(Resource,[{key:"isModel",get:function get(){if(this.ext===null)return true;else return false;}}]);return Resource;}();/**\r\n\t * @author pzx 2018.2.13\r\n\t * Json2MeshBuilderParser\r\n\t */var HUAWEILoader=function(){function HUAWEILoader(){classCallCheck(this,HUAWEILoader);this.sceneJson=null;this.scale=1;//比例尺\nthis.curFloorPlan=null;this.defaultWallTextureUri="Textures/RoomWall.jpg";this.defaultWallEdgeTextureUri="Textures/WallEdge.jpg";this.defaultFloorTextureUri="Textures/FloorDefault.jpg";this.defaultCeilingTextureUri="Textures/CeilingDefault.jpg";this.defaultRoofTextureUri="Textures/RoofDefault.jpg";this.defaultWallLightMapUri="Textures/WallLighting.PNG";this.defaultFloorLightMapUri="Textures/FloorLighting.jpg";this.pointInLineDeviation=0.1;// 检测点在墙上的误差阀值\nDefaultSetting.enableDelayLoadMode=false;DefaultSetting.enableManaulWallLightMap=true;DefaultSetting.enableFloorLightMap=true;}//pzx start\nHUAWEILoader.prototype.load=function load(map){var that=this;if(map){if(map["url"]){this.sceneURL=map["url"];}if(map["json"]){this.sceneJson=map["json"];}}else{console.error("load param can not be null");return null;}return new Promise(function(resolve,reject){that.loadDefaultTexture().then(function(){return that.loadSceneJson();}).then(function(){that.curFloorPlan=new FloorPlan();that.parseSceneJson();that.curFloorPlan.build();var walls=that.createWalls();var rooms=that.createRooms();var map={"walls":walls,"rooms":rooms};resolve(map);}).catch(function(error){console.error(error);});});};HUAWEILoader.prototype.loadSceneJson=function loadSceneJson(){var that=this;return new Promise(function(resolve,reject){if(that.sceneJson){resolve(that.sceneJson);}else if(that.sceneURL){var loader=new THREE.FileLoader();loader.load(that.sceneURL,function(data){that.sceneJson=JSON.parse(data);resolve();},function(){},function(error){reject("can not load "+that.sceneURL);});}else{reject("load scene json error");}});};HUAWEILoader.prototype.createTextureLoaderPromise=function createTextureLoaderPromise(texUri){var that=this;return new Promise(function(resolve,reject){var texLoader=new THREE.TextureLoader();// var that = this;\n// load a resource\ntexLoader.load(// resource URL\n// that.sceneURL+"/"+texUri,\ntexUri,// Function when resource is loaded\nfunction(texture){texture.wrapS=THREE.RepeatWrapping;texture.wrapT=THREE.RepeatWrapping;// texture.wrapS = THREE.ClampToEdgeWrapping;\n// texture.wrapT = THREE.ClampToEdgeWrapping;\nresolve(texture);},// Function called when download progresses\nfunction(xhr){console.log(texUri+" "+xhr.loaded/xhr.total*100+\'% loaded\');},// Function called when download errors\nfunction(xhr){resolve(null);console.log(texUri+\'load error\');});});};HUAWEILoader.prototype.loadDefaultTexture=function loadDefaultTexture(){var that=this;return new Promise(function(resolve,reject){var promises=[];var wallTexPromise=that.createTextureLoaderPromise(that.defaultWallTextureUri).then(function(tex){DefaultResource.wallTexture=tex;var res=that.createDefaultResource(tex);DefaultResource.wallResource=res;});promises.push(wallTexPromise);var wallEdgePromise=that.createTextureLoaderPromise(that.defaultWallEdgeTextureUri).then(function(tex){DefaultResource.wallEdgeTexture=tex;var res=that.createDefaultResource(tex);DefaultResource.edgeResource=res;});promises.push(wallEdgePromise);var floorPromise=that.createTextureLoaderPromise(that.defaultFloorTextureUri).then(function(tex){DefaultResource.floorTexture=tex;var res=that.createDefaultResource(tex);DefaultResource.floorResource=res;});promises.push(floorPromise);var roofPromise=that.createTextureLoaderPromise(that.defaultRoofTextureUri).then(function(tex){DefaultResource.roofTexture=tex;var res=that.createDefaultResource(tex);DefaultResource.rooflResource=res;});promises.push(roofPromise);var ceilingPromise=that.createTextureLoaderPromise(that.defaultCeilingTextureUri).then(function(tex){DefaultResource.ceilingTexture=tex;var res=that.createDefaultResource(tex);DefaultResource.ceilingResource=res;});promises.push(ceilingPromise);if(DefaultSetting.enableManaulWallLightMap){var wallLightMapPromise=that.createTextureLoaderPromise(that.defaultWallLightMapUri).then(function(tex){DefaultResource.wallLigthMapTexture=tex;var res=that.createDefaultResource(tex);DefaultResource.wallLightMapResource=res;});promises.push(wallLightMapPromise);}if(DefaultSetting.enableFloorLightMap){var floorLightMapPromise=that.createTextureLoaderPromise(that.defaultFloorLightMapUri).then(function(tex){DefaultResource.floorLightMapTexture=tex;var res=that.createDefaultResource(tex);DefaultResource.floorLightMapResource=res;});promises.push(floorLightMapPromise);}Promise.all(promises).then(function(){resolve();});});};HUAWEILoader.prototype.createDefaultResource=function createDefaultResource(tex){var res=new Resource();res.ready=true;res.isDefault=true;res.texture=tex;res.material.map=tex;// res.wallMaterial.map = tex;\nres.roomMaterial.map=tex;return res;};HUAWEILoader.prototype.parseSceneJson=function parseSceneJson(){var sceneJson=this.sceneJson;if(sceneJson["unit"]){this.scale=sceneJson["unit"]*0.01;}if(sceneJson["walls"]){this.parseWallJson(sceneJson["walls"]);}if(sceneJson["rooms"]){this.parseRoomJson(sceneJson["rooms"]);}if(sceneJson["doors"]){this.parseDoorJson(sceneJson["doors"]);}};HUAWEILoader.prototype.parseWallJson=function parseWallJson(wallsJson){for(var i=0,len=wallsJson.length;i<len;i++){var singleWallData=wallsJson[i];var x=singleWallData["start"][0]*this.scale;var y=singleWallData["start"][1]*this.scale;var startCorner=null;var endCorner=null;if(!this.curFloorPlan.existsCorner(x,0,y)){startCorner=this.curFloorPlan.addCorner(x,0,y);}else{startCorner=this.curFloorPlan.getCorner(x,0,y);}x=singleWallData["end"][0]*this.scale;y=singleWallData["end"][1]*this.scale;if(!this.curFloorPlan.existsCorner(x,0,y)){endCorner=this.curFloorPlan.addCorner(x,0,y);}else{endCorner=this.curFloorPlan.getCorner(x,0,y);}var wall=new Wall();wall.leftResource=DefaultResource.wallResource;wall.rightResource=DefaultResource.wallResource;wall.edgeResource=DefaultResource.edgeResource;wall.lightMapResource=DefaultResource.wallLightMapResource;wall.startCorner=startCorner;wall.endCorner=endCorner;wall.startCorner.addWall(wall);wall.endCorner.addWall(wall);this.curFloorPlan.addWall(wall);}};HUAWEILoader.prototype.parseRoomJson=function parseRoomJson(roomsJson){for(var i=0;i<roomsJson.length;i++){var singleRoomJson=roomsJson[i];var points=[];for(var j=0;j<singleRoomJson["points"].length;j++){var posArray=singleRoomJson["points"][j];points.push(new THREE.Vector3(posArray[0]*this.scale,0,posArray[1]*this.scale));}var room=new Room();room.floorResource=DefaultResource.floorResource;room.ceilingResource=DefaultResource.ceilingResource;room.roofResource=DefaultResource.rooflResource;room.lightMapResource=DefaultResource.floorLightMapResource;room.points=points;if(singleRoomJson["center"]){var center=new THREE.Vector3();center.x=singleRoomJson["center"][0];center.y=0;center.z=singleRoomJson["center"][1];room.center=center;}if(singleRoomJson["offset"]){var offset=new THREE.Vector3();offset.x=singleRoomJson["offset"][0];offset.y=singleRoomJson["offset"][1];offset.z=singleRoomJson["offset"][2];room.offset=offset;}if(singleRoomJson["parentPosition"]){var parentPos=new THREE.Vector3();parentPos.x=singleRoomJson["parentPosition"][0];parentPos.y=singleRoomJson["parentPosition"][1];parentPos.z=singleRoomJson["parentPosition"][2];room.parentPosition=parentPos;}this.curFloorPlan.rooms.push(room);}};HUAWEILoader.prototype.parseDoorJson=function parseDoorJson(doorsJson){for(var i=0,len=doorsJson.length;i<len;i++){var singleDoorData=doorsJson[i];var height=singleDoorData["height"]*this.scale;var width=singleDoorData["width"]*this.scale;var x=singleDoorData["pos"][0]*this.scale;var y=singleDoorData["pos"][1]*this.scale;var pos=new THREE.Vector3(x,0,y);var attachWall=this.getPointOnWhichWall(this.curFloorPlan,pos);if(attachWall===null){console.warn("can not find door on which wall!");continue;}var door=new DoorOrWindow();if(singleDoorData["suspendpercent"]){door.suspendPercent=singleDoorData["suspendpercent"];}door.size.x=width;door.size.y=height;door.position=pos;attachWall.doorOrWindows.push(door);}};HUAWEILoader.prototype.createRooms=function createRooms(){var roomMeshs=[];for(var i=0;i<this.curFloorPlan.rooms.length;i++){var room=this.curFloorPlan.rooms[i];roomMeshs.push(room.meshGroup);}return roomMeshs;};HUAWEILoader.prototype.createWalls=function createWalls(){var floorPlan=this.curFloorPlan;var walls=floorPlan.walls;var wallMeshs=[];for(var i=0;i<walls.length;i++){var wall=walls[i];// var pos = wall.position;\n// var group = new THREE.Group("wall");\n// group.add(this.createWallMesh(wall.rightSideMeshInfo));\n// group.add(this.createWallMesh(wall.leftSideMeshInfo));\n// group.add(this.createWallMesh(wall.edgeSideMeshInfo));\n// group.position.set(pos.x,pos.y,pos.z);\nwallMeshs.push(wall.wallGroup);}return wallMeshs;};HUAWEILoader.prototype.createWallMesh=function createWallMesh(meshInfo){var geometry=new THREE.BufferGeometry();geometry.addAttribute(\'position\',new THREE.BufferAttribute(meshInfo.positionArray,3));geometry.addAttribute(\'normal\',new THREE.BufferAttribute(meshInfo.normalArray,3));geometry.addAttribute(\'uv\',new THREE.BufferAttribute(meshInfo.uvArray,2));var material=meshInfo.material;var mesh=new THREE.Mesh(geometry,material);return mesh;};HUAWEILoader.prototype.getPointOnWhichWall=function getPointOnWhichWall(plan,point){var walls=plan.walls;for(var i=0;i<walls.length;i++){var wall=walls[i];if(this.isPointOnLineAndBetweenPoints(wall.startCorner.position,wall.endCorner.position,point)){return wall;}}return null;};HUAWEILoader.prototype.isPointOnLine=function isPointOnLine(pointA,pointB,pointToCheck){var c=new THREE.Vector3();c.crossVectors(pointA.clone().sub(pointToCheck),pointB.clone().sub(pointToCheck));return c.length()<this.pointInLineDeviation;};HUAWEILoader.prototype.isPointOnLineAndBetweenPoints=function isPointOnLineAndBetweenPoints(pointA,pointB,pointToCheck){if(!this.isPointOnLine(pointA,pointB,pointToCheck)){return false;}var dx=pointB.x-pointA.x;var dy=pointB.z-pointA.z;// if a line is a more horizontal than vertical:\nif(Math.abs(dx)>=Math.abs(dy)){if(dx>0){return pointA.x<=pointToCheck.x&&pointToCheck.x<=pointB.x;}else{return pointB.x<=pointToCheck.x&&pointToCheck.x<=pointA.x;}}else{if(dy>0){return pointA.z<=pointToCheck.z&&pointToCheck.z<=pointB.z;}else{return pointB.z<=pointToCheck.z&&pointToCheck.z<=pointA.z;}}};return HUAWEILoader;}();/**\r\n\t * @author pzx 2018.4.2\r\n\t * World\r\n\t */var World=function(_BaseObject){inherits(World,_BaseObject);function World(){classCallCheck(this,World);var _this=possibleConstructorReturn(this,_BaseObject.call(this));_this.outdoors=null;_this.buildings=[];return _this;}World.prototype.build=function build(){for(var i=0;i<this.buildings.length;i++){var bd=this.buildings[i];bd.build();}if(this.outdoors){this.outdoors.build();}};return World;}(BaseObject);/**\r\n\t * @author pzx 2018.4.2\r\n\t * Building\r\n\t */var Building=function(_BaseObject){inherits(Building,_BaseObject);function Building(){classCallCheck(this,Building);var _this=possibleConstructorReturn(this,_BaseObject.call(this));_this.floorplans=[];_this.facades=[];_this.facadeGroups=[];return _this;}Building.prototype.build=function build(){for(var i=0;i<this.floorplans.length;i++){var plan=this.floorplans[i];plan.build();}for(var i=0;i<this.facades.length;i++){var facade=this.facades[i];facade.build();}for(var i=0;i<this.facadeGroups.length;i++){var facade=this.facadeGroups[i];facade.build();}};return Building;}(BaseObject);/**\r\n\t * @author pzx 2018.2.13\r\n\t * Json2MeshBuilderParser\r\n\t */var ubuilderLoadSceneKeys={id:"id",name:"name",position:"position",rotation:"rotation",scale:"scale",properties:"properties",plans:"plans",walls:"walls",placements:"placements",groups:"groups",corners:"corners",doorOrWindows:"doororwindows",rooms:"rooms",height:"height",thick:"thick",texture:"texture",type:"type",model:"model",suspendPercent:"suspendpercent",leftTexture:"lefttexture",rightTexture:"righttexture",edgeTexture:"edgetexture",floorTexture:"floortexture",ceilingTexture:"ceilingtexture",roofTexture:"rooftexture",wallType:"type"};var loadKeys=ubuilderLoadSceneKeys;var HUAWEIWorldLoader=function(){function HUAWEIWorldLoader(){classCallCheck(this,HUAWEIWorldLoader);this.sceneJson=null;this.scale=1;//比例尺\nthis.curFloorPlan=null;this.defaultWallTextureUri="Textures/RoomWall.jpg";this.defaultWallEdgeTextureUri="Textures/WallEdge.jpg";this.defaultFloorTextureUri="Textures/FloorDefault.jpg";this.defaultCeilingTextureUri="Textures/CeilingDefault.jpg";this.defaultRoofTextureUri="Textures/RoofDefault.jpg";// this.defaultWallLightMapUri = "Textures/墙.jpg";\nthis.defaultWallLightMapUri="Textures/WallLighting.PNG";this.defaultFloorLightMapUri="Textures/FloorLighting.jpg";this.world=null;DefaultSetting.enableDelayLoadMode=false;DefaultSetting.enableManaulWallLightMap=true;DefaultSetting.enableFloorLightMap=true;}//pzx start\nHUAWEIWorldLoader.prototype.load=function load(map){var that=this;if(map){if(map["url"]){this.sceneURL=map["url"];}if(map["json"]){this.sceneJson=map["json"];}}else{console.error("load param can not be null");return null;}return new Promise(function(resolve,reject){that.loadDefaultTexture().then(function(){return that.loadSceneJson();}).then(function(){// that.curFloorPlan = new FloorPlan();\nthat.parseWorld(that.sceneJson);that.world.build();// that.curFloorPlan.build();\n// var walls = that.createWalls();\n// var rooms = that.createRooms();\n// var map = {"walls":walls,"rooms":rooms}  ;\nresolve(that.world);}).catch(function(error){console.error(error);});});};HUAWEIWorldLoader.prototype.loadSceneJson=function loadSceneJson(){var that=this;return new Promise(function(resolve,reject){if(that.sceneJson){resolve(that.sceneJson);}else if(that.sceneURL){var loader=new THREE.FileLoader();loader.load(that.sceneURL,function(data){that.sceneJson=JSON.parse(data);resolve();},function(){},function(error){reject("can not load "+that.sceneURL);});}else{reject("load scene json error");}});};HUAWEIWorldLoader.prototype.createTextureLoaderPromise=function createTextureLoaderPromise(texUri){var that=this;return new Promise(function(resolve,reject){var texLoader=new THREE.TextureLoader();// var that = this;\n// load a resource\ntexLoader.load(// resource URL\n// that.sceneURL+"/"+texUri,\ntexUri,// Function when resource is loaded\nfunction(texture){texture.wrapS=THREE.RepeatWrapping;texture.wrapT=THREE.RepeatWrapping;// texture.wrapS = THREE.ClampToEdgeWrapping;\n// texture.wrapT = THREE.ClampToEdgeWrapping;\nresolve(texture);},// Function called when download progresses\nfunction(xhr){console.log(texUri+" "+xhr.loaded/xhr.total*100+\'% loaded\');},// Function called when download errors\nfunction(xhr){resolve(null);console.log(texUri+\'load error\');});});};HUAWEIWorldLoader.prototype.loadDefaultTexture=function loadDefaultTexture(){var that=this;return new Promise(function(resolve,reject){var promises=[];var wallTexPromise=that.createTextureLoaderPromise(that.defaultWallTextureUri).then(function(tex){DefaultResource.wallTexture=tex;var res=that.createDefaultResource(tex);DefaultResource.wallResource=res;});promises.push(wallTexPromise);var wallEdgePromise=that.createTextureLoaderPromise(that.defaultWallEdgeTextureUri).then(function(tex){DefaultResource.wallEdgeTexture=tex;var res=that.createDefaultResource(tex);DefaultResource.edgeResource=res;});promises.push(wallEdgePromise);var floorPromise=that.createTextureLoaderPromise(that.defaultFloorTextureUri).then(function(tex){DefaultResource.floorTexture=tex;var res=that.createDefaultResource(tex);DefaultResource.floorResource=res;});promises.push(floorPromise);var roofPromise=that.createTextureLoaderPromise(that.defaultRoofTextureUri).then(function(tex){DefaultResource.roofTexture=tex;var res=that.createDefaultResource(tex);DefaultResource.rooflResource=res;});promises.push(roofPromise);var ceilingPromise=that.createTextureLoaderPromise(that.defaultCeilingTextureUri).then(function(tex){DefaultResource.ceilingTexture=tex;var res=that.createDefaultResource(tex);DefaultResource.ceilingResource=res;});promises.push(ceilingPromise);if(DefaultSetting.enableManaulWallLightMap){var wallLightMapPromise=that.createTextureLoaderPromise(that.defaultWallLightMapUri).then(function(tex){DefaultResource.wallLigthMapTexture=tex;var res=that.createDefaultResource(tex);DefaultResource.wallLightMapResource=res;});promises.push(wallLightMapPromise);}if(DefaultSetting.enableFloorLightMap){var floorLightMapPromise=that.createTextureLoaderPromise(that.defaultFloorLightMapUri).then(function(tex){DefaultResource.floorLightMapTexture=tex;var res=that.createDefaultResource(tex);DefaultResource.floorLightMapResource=res;});promises.push(floorLightMapPromise);}Promise.all(promises).then(function(){resolve();});});};HUAWEIWorldLoader.prototype.createDefaultResource=function createDefaultResource(tex){var res=new Resource();res.ready=true;res.isDefault=true;res.texture=tex;res.material.map=tex;// res.wallMaterial.map = tex;\nres.roomMaterial.map=tex;return res;};HUAWEIWorldLoader.prototype.parseWorld=function parseWorld(jsonData){var world=new World();this.world=world;// this.parseBaseObject(jsonData, world);\nif(jsonData["buildings"]){var buildingsData=jsonData["buildings"];for(var i=0;i<buildingsData.length;i++){var buildingData=buildingsData[i];var bd=this.parseBuilding(buildingData);world.buildings.push(bd);}}// if (jsonData["outdoors"]) {\n//     var outdoors = new Outdoors();\n//     this.parseFloorPlan(jsonData["outdoors"], outdoors)\n//     world.outdoors = outdoors;\n// }\n};HUAWEIWorldLoader.prototype.parseBuilding=function parseBuilding(jsonData,parent){var buildingData=jsonData;var bd=new Building();if(jsonData.id){bd.id=jsonData.id;}// this.parseBaseObject(jsonData, bd, parent)\nvar plansData=buildingData[loadKeys.plans];for(var j=0;j<plansData.length;j++){var planData=plansData[j];var floorPlan=new FloorPlan();if(planData.id){floorPlan.id=planData.id;}this.parseFloorPlan(planData,floorPlan,bd);if(planData.height){// var pos = new THREE.Vector3(0,planData.height*j,0);\nfloorPlan.position.set(0,planData.height*j,0);}else{floorPlan.position.set(0,floorPlan.height*j,0);}bd.floorplans.push(floorPlan);}return bd;};HUAWEIWorldLoader.prototype.parseFloorPlan=function parseFloorPlan(jsonData,floorPlan){var sceneJson=jsonData;// this.sceneJson;\nif(sceneJson["unit"]){this.scale=sceneJson["unit"]*0.01;}if(sceneJson["walls"]){this.parseWallJson(sceneJson["walls"],floorPlan);}if(sceneJson["rooms"]){this.parseRoomJson(sceneJson["rooms"],floorPlan);}if(sceneJson["doors"]){this.parseDoorJson(sceneJson["doors"],floorPlan);}};HUAWEIWorldLoader.prototype.parseWallJson=function parseWallJson(wallsJson,floorPlan){for(var i=0,len=wallsJson.length;i<len;i++){var singleWallData=wallsJson[i];var x=singleWallData["start"][0]*this.scale;var y=singleWallData["start"][1]*this.scale;var startCorner=null;var endCorner=null;if(!floorPlan.existsCorner(x,0,y)){startCorner=floorPlan.addCorner(x,0,y);}else{startCorner=floorPlan.getCorner(x,0,y);}x=singleWallData["end"][0]*this.scale;y=singleWallData["end"][1]*this.scale;if(!floorPlan.existsCorner(x,0,y)){endCorner=floorPlan.addCorner(x,0,y);}else{endCorner=floorPlan.getCorner(x,0,y);}var wall=new Wall();if(singleWallData.id){wall.id=singleWallData.id;}wall.leftResource=DefaultResource.wallResource;wall.rightResource=DefaultResource.wallResource;wall.edgeResource=DefaultResource.edgeResource;wall.lightMapResource=DefaultResource.wallLightMapResource;wall.startCorner=startCorner;wall.endCorner=endCorner;wall.startCorner.addWall(wall);wall.endCorner.addWall(wall);floorPlan.addWall(wall);}};HUAWEIWorldLoader.prototype.parseRoomJson=function parseRoomJson(roomsJson,floorPlan){for(var i=0;i<roomsJson.length;i++){var singleRoomJson=roomsJson[i];var points=[];for(var j=0;j<singleRoomJson["points"].length;j++){var posArray=singleRoomJson["points"][j];points.push(new THREE.Vector3(posArray[0]*this.scale,0,posArray[1]*this.scale));}var room=new Room();if(singleRoomJson.id){room.id=singleRoomJson.id;}room.floorResource=DefaultResource.floorResource;room.ceilingResource=DefaultResource.ceilingResource;room.roofResource=DefaultResource.rooflResource;room.lightMapResource=DefaultResource.floorLightMapResource;room.points=points;if(singleRoomJson["center"]){var center=new THREE.Vector3();center.x=singleRoomJson["center"][0];center.y=0;center.z=singleRoomJson["center"][1];room.center=center;}if(singleRoomJson["offset"]){var offset=new THREE.Vector3();offset.x=singleRoomJson["offset"][0];offset.y=singleRoomJson["offset"][1];offset.z=singleRoomJson["offset"][2];room.offset=offset;}if(singleRoomJson["parentPosition"]){var parentPos=new THREE.Vector3();parentPos.x=singleRoomJson["parentPosition"][0];parentPos.y=singleRoomJson["parentPosition"][1];parentPos.z=singleRoomJson["parentPosition"][2];room.parentPosition=parentPos;}if(singleRoomJson.enableLightMap!==undefined){room.floor.enableLightMap=singleRoomJson.enableLightMap;}else{room.floor.enableLightMap=false;}room.parent=floorPlan;floorPlan.rooms.push(room);}};HUAWEIWorldLoader.prototype.parseDoorJson=function parseDoorJson(doorsJson,floorPlan){for(var i=0,len=doorsJson.length;i<len;i++){var singleDoorData=doorsJson[i];var height=singleDoorData["height"]*this.scale;var width=singleDoorData["width"]*this.scale;var x=singleDoorData["pos"][0]*this.scale;var y=singleDoorData["pos"][1]*this.scale;var pos=new THREE.Vector3(x,0,y);var attachWall=this.getPointOnWhichWall(floorPlan,pos);if(attachWall===null){console.warn("can not find door on which wall!");continue;}var door=new DoorOrWindow();door.size.x=width;door.size.y=height;door.position=pos;attachWall.doorOrWindows.push(door);}};// createRooms(){\n//     var roomMeshs = [];\n//     for (var i = 0; i < this.curFloorPlan.rooms.length; i++) {\n//         var room = this.curFloorPlan.rooms[i];\n//         roomMeshs.push(room.meshGroup);\n//     }\n//     return roomMeshs;\n// }\n//\n// createWalls() {\n//     var floorPlan = this.curFloorPlan;\n//     var walls = floorPlan.walls;\n//     var wallMeshs = [];\n//     for (var i = 0; i < walls.length; i++) {\n//         var wall = walls[i];\n//         // var pos = wall.position;\n//         // var group = new THREE.Group("wall");\n//         // group.add(this.createWallMesh(wall.rightSideMeshInfo));\n//         // group.add(this.createWallMesh(wall.leftSideMeshInfo));\n//         // group.add(this.createWallMesh(wall.edgeSideMeshInfo));\n//         // group.position.set(pos.x,pos.y,pos.z);\n//         wallMeshs.push(wall.wallGroup);\n//     }\n//     return wallMeshs;\n// }\nHUAWEIWorldLoader.prototype.createWallMesh=function createWallMesh(meshInfo){var geometry=new THREE.BufferGeometry();geometry.addAttribute(\'position\',new THREE.BufferAttribute(meshInfo.positionArray,3));geometry.addAttribute(\'normal\',new THREE.BufferAttribute(meshInfo.normalArray,3));geometry.addAttribute(\'uv\',new THREE.BufferAttribute(meshInfo.uvArray,2));var material=meshInfo.material;var mesh=new THREE.Mesh(geometry,material);return mesh;};HUAWEIWorldLoader.prototype.getPointOnWhichWall=function getPointOnWhichWall(plan,point){var walls=plan.walls;for(var i=0;i<walls.length;i++){var wall=walls[i];if(this.isPointOnLineAndBetweenPoints(wall.startCorner.position,wall.endCorner.position,point)){return wall;}}return null;};HUAWEIWorldLoader.prototype.isPointOnLine=function isPointOnLine(pointA,pointB,pointToCheck){var c=new THREE.Vector3();c.crossVectors(pointA.clone().sub(pointToCheck),pointB.clone().sub(pointToCheck));return!c.length();};HUAWEIWorldLoader.prototype.isPointOnLineAndBetweenPoints=function isPointOnLineAndBetweenPoints(pointA,pointB,pointToCheck){if(!this.isPointOnLine(pointA,pointB,pointToCheck)){return false;}var dx=pointB.x-pointA.x;var dy=pointB.z-pointA.z;// if a line is a more horizontal than vertical:\nif(Math.abs(dx)>=Math.abs(dy)){if(dx>0){return pointA.x<=pointToCheck.x&&pointToCheck.x<=pointB.x;}else{return pointB.x<=pointToCheck.x&&pointToCheck.x<=pointA.x;}}else{if(dy>0){return pointA.z<=pointToCheck.z&&pointToCheck.z<=pointB.z;}else{return pointB.z<=pointToCheck.z&&pointToCheck.z<=pointA.z;}}};return HUAWEIWorldLoader;}();/**\r\n\t * @author pzx 2018.2.13\r\n\t * Json2MeshBuilderParser\r\n\t */var HUAWEIFloorPlanLoader=function(){function HUAWEIFloorPlanLoader(){classCallCheck(this,HUAWEIFloorPlanLoader);this.sceneJson=null;this.scale=1;//比例尺\nthis.curFloorPlan=null;this.defaultWallTextureUri="Textures/RoomWall.jpg";this.defaultWallEdgeTextureUri="Textures/WallEdge.jpg";this.defaultFloorTextureUri="Textures/FloorDefault.jpg";this.defaultCeilingTextureUri="Textures/CeilingDefault.jpg";this.defaultRoofTextureUri="Textures/RoofDefault.jpg";this.defaultWallLightMapUri="Textures/WallLighting.PNG";this.defaultFloorLightMapUri="Textures/FloorLighting.jpg";DefaultSetting.enableDelayLoadMode=false;DefaultSetting.enableManaulWallLightMap=true;DefaultSetting.enableFloorLightMap=true;}//pzx start\nHUAWEIFloorPlanLoader.prototype.load=function load(map){var that=this;var that=this;if(map){if(map["url"]){this.sceneURL=map["url"];}if(map["json"]){this.sceneJson=map["json"];}}else{console.error("load param can not be null");return null;}return new Promise(function(resolve,reject){that.loadDefaultTexture().then(function(){return that.loadSceneJson();}).then(function(){that.curFloorPlan=new FloorPlan();that.parseSceneJson();that.curFloorPlan.build();var walls=that.createWalls();var rooms=that.createRooms();var map={"walls":walls,"rooms":rooms};resolve(map);}).catch(function(error){console.error(error);});});};HUAWEIFloorPlanLoader.prototype.loadSceneJson=function loadSceneJson(){var that=this;return new Promise(function(resolve,reject){if(that.sceneJson){resolve(that.sceneJson);}else if(that.sceneURL){var loader=new THREE.FileLoader();loader.load(that.sceneURL,function(data){that.sceneJson=JSON.parse(data);resolve();},function(){},function(error){reject("can not load "+that.sceneURL);});}else{reject("load scene json error");}});};HUAWEIFloorPlanLoader.prototype.createTextureLoaderPromise=function createTextureLoaderPromise(texUri){var that=this;return new Promise(function(resolve,reject){var texLoader=new THREE.TextureLoader();// var that = this;\n// load a resource\ntexLoader.load(// resource URL\n// that.sceneURL+"/"+texUri,\ntexUri,// Function when resource is loaded\nfunction(texture){texture.wrapS=THREE.RepeatWrapping;texture.wrapT=THREE.RepeatWrapping;// texture.wrapS = THREE.ClampToEdgeWrapping;\n// texture.wrapT = THREE.ClampToEdgeWrapping;\nresolve(texture);},// Function called when download progresses\nfunction(xhr){console.log(texUri+" "+xhr.loaded/xhr.total*100+\'% loaded\');},// Function called when download errors\nfunction(xhr){resolve(null);console.log(texUri+\'load error\');});});};HUAWEIFloorPlanLoader.prototype.loadDefaultTexture=function loadDefaultTexture(){var that=this;return new Promise(function(resolve,reject){var promises=[];var wallTexPromise=that.createTextureLoaderPromise(that.defaultWallTextureUri).then(function(tex){DefaultResource.wallTexture=tex;var res=that.createDefaultResource(tex);DefaultResource.wallResource=res;});promises.push(wallTexPromise);var wallEdgePromise=that.createTextureLoaderPromise(that.defaultWallEdgeTextureUri).then(function(tex){DefaultResource.wallEdgeTexture=tex;var res=that.createDefaultResource(tex);DefaultResource.edgeResource=res;});promises.push(wallEdgePromise);var floorPromise=that.createTextureLoaderPromise(that.defaultFloorTextureUri).then(function(tex){DefaultResource.floorTexture=tex;var res=that.createDefaultResource(tex);DefaultResource.floorResource=res;});promises.push(floorPromise);var roofPromise=that.createTextureLoaderPromise(that.defaultRoofTextureUri).then(function(tex){DefaultResource.roofTexture=tex;var res=that.createDefaultResource(tex);DefaultResource.rooflResource=res;});promises.push(roofPromise);var ceilingPromise=that.createTextureLoaderPromise(that.defaultCeilingTextureUri).then(function(tex){DefaultResource.ceilingTexture=tex;var res=that.createDefaultResource(tex);DefaultResource.ceilingResource=res;});promises.push(ceilingPromise);if(DefaultSetting.enableManaulWallLightMap){var wallLightMapPromise=that.createTextureLoaderPromise(that.defaultWallLightMapUri).then(function(tex){DefaultResource.wallLigthMapTexture=tex;var res=that.createDefaultResource(tex);DefaultResource.wallLightMapResource=res;});promises.push(wallLightMapPromise);}if(DefaultSetting.enableFloorLightMap){var floorLightMapPromise=that.createTextureLoaderPromise(that.defaultFloorLightMapUri).then(function(tex){DefaultResource.floorLightMapTexture=tex;var res=that.createDefaultResource(tex);DefaultResource.floorLightMapResource=res;});promises.push(floorLightMapPromise);}Promise.all(promises).then(function(){resolve();});});};HUAWEIFloorPlanLoader.prototype.createDefaultResource=function createDefaultResource(tex){var res=new Resource();res.ready=true;res.isDefault=true;res.texture=tex;res.material.map=tex;// res.wallMaterial.map = tex;\nres.roomMaterial.map=tex;return res;};HUAWEIFloorPlanLoader.prototype.parseSceneJson=function parseSceneJson(){var sceneJson=this.sceneJson;for(var key in sceneJson){var value=sceneJson[key];if(value){this.sceneJson=value;}else{console.error("load param can not be null");return null;}break;}sceneJson=this.sceneJson;if(sceneJson.id){this.curFloorPlan.id=sceneJson.id;}if(sceneJson["unit"]){this.scale=sceneJson["unit"]*0.01;}if(sceneJson["walls"]){this.parseWallJson(sceneJson["walls"]);}if(sceneJson["rooms"]){this.parseRoomJson(sceneJson["rooms"]);}if(sceneJson["doors"]){this.parseDoorJson(sceneJson["doors"]);}};HUAWEIFloorPlanLoader.prototype.parseWallJson=function parseWallJson(wallsJson){for(var i=0,len=wallsJson.length;i<len;i++){var singleWallData=wallsJson[i];var x=singleWallData["start"][0]*this.scale;var y=singleWallData["start"][1]*this.scale;var startCorner=null;var endCorner=null;if(!this.curFloorPlan.existsCorner(x,0,y)){startCorner=this.curFloorPlan.addCorner(x,0,y);}else{startCorner=this.curFloorPlan.getCorner(x,0,y);}x=singleWallData["end"][0]*this.scale;y=singleWallData["end"][1]*this.scale;if(!this.curFloorPlan.existsCorner(x,0,y)){endCorner=this.curFloorPlan.addCorner(x,0,y);}else{endCorner=this.curFloorPlan.getCorner(x,0,y);}var wall=new Wall();wall.leftResource=DefaultResource.wallResource;wall.rightResource=DefaultResource.wallResource;wall.edgeResource=DefaultResource.edgeResource;wall.lightMapResource=DefaultResource.wallLightMapResource;wall.startCorner=startCorner;wall.endCorner=endCorner;wall.startCorner.addWall(wall);wall.endCorner.addWall(wall);this.curFloorPlan.addWall(wall);}};HUAWEIFloorPlanLoader.prototype.parseRoomJson=function parseRoomJson(roomsJson){for(var i=0;i<roomsJson.length;i++){var singleRoomJson=roomsJson[i];var points=[];for(var j=0;j<singleRoomJson["points"].length;j++){var posArray=singleRoomJson["points"][j];points.push(new THREE.Vector3(posArray[0]*this.scale,0,posArray[1]*this.scale));}var room=new Room();room.floorResource=DefaultResource.floorResource;room.ceilingResource=DefaultResource.ceilingResource;room.roofResource=DefaultResource.rooflResource;room.lightMapResource=DefaultResource.floorLightMapResource;room.points=points;if(singleRoomJson["center"]){var center=new THREE.Vector3();center.x=singleRoomJson["center"][0];center.y=0;center.z=singleRoomJson["center"][1];room.center=center;}if(singleRoomJson["offset"]){var offset=new THREE.Vector3();offset.x=singleRoomJson["offset"][0];offset.y=singleRoomJson["offset"][1];offset.z=singleRoomJson["offset"][2];room.offset=offset;}if(singleRoomJson["parentPosition"]){var parentPos=new THREE.Vector3();parentPos.x=singleRoomJson["parentPosition"][0];parentPos.y=singleRoomJson["parentPosition"][1];parentPos.z=singleRoomJson["parentPosition"][2];room.parentPosition=parentPos;}if(singleRoomJson.enableLightMap!==undefined){room.floor.enableLightMap=singleRoomJson.enableLightMap;}else{room.floor.enableLightMap=false;}this.curFloorPlan.rooms.push(room);}};HUAWEIFloorPlanLoader.prototype.parseDoorJson=function parseDoorJson(doorsJson){for(var i=0,len=doorsJson.length;i<len;i++){var singleDoorData=doorsJson[i];var height=singleDoorData["height"]*this.scale;var width=singleDoorData["width"]*this.scale;var x=singleDoorData["pos"][0]*this.scale;var y=singleDoorData["pos"][1]*this.scale;var pos=new THREE.Vector3(x,0,y);var attachWall=this.getPointOnWhichWall(this.curFloorPlan,pos);if(attachWall===null){console.warn("can not find door on which wall!");continue;}var door=new DoorOrWindow();if(singleDoorData["suspendpercent"]){door.suspendPercent=singleDoorData["suspendpercent"];}door.size.x=width;door.size.y=height;door.position=pos;attachWall.doorOrWindows.push(door);}};HUAWEIFloorPlanLoader.prototype.createRooms=function createRooms(){var roomMeshs=[];for(var i=0;i<this.curFloorPlan.rooms.length;i++){var room=this.curFloorPlan.rooms[i];roomMeshs.push(room.meshGroup);}return roomMeshs;};HUAWEIFloorPlanLoader.prototype.createWalls=function createWalls(){var floorPlan=this.curFloorPlan;var walls=floorPlan.walls;var wallMeshs=[];for(var i=0;i<walls.length;i++){var wall=walls[i];// var pos = wall.position;\n// var group = new THREE.Group("wall");\n// group.add(this.createWallMesh(wall.rightSideMeshInfo));\n// group.add(this.createWallMesh(wall.leftSideMeshInfo));\n// group.add(this.createWallMesh(wall.edgeSideMeshInfo));\n// group.position.set(pos.x,pos.y,pos.z);\nwallMeshs.push(wall.wallGroup);}return wallMeshs;};HUAWEIFloorPlanLoader.prototype.createWallMesh=function createWallMesh(meshInfo){var geometry=new THREE.BufferGeometry();geometry.addAttribute(\'position\',new THREE.BufferAttribute(meshInfo.positionArray,3));geometry.addAttribute(\'normal\',new THREE.BufferAttribute(meshInfo.normalArray,3));geometry.addAttribute(\'uv\',new THREE.BufferAttribute(meshInfo.uvArray,2));var material=meshInfo.material;var mesh=new THREE.Mesh(geometry,material);return mesh;};HUAWEIFloorPlanLoader.prototype.getPointOnWhichWall=function getPointOnWhichWall(plan,point){var walls=plan.walls;for(var i=0;i<walls.length;i++){var wall=walls[i];if(this.isPointOnLineAndBetweenPoints(wall.startCorner.position,wall.endCorner.position,point)){return wall;}}return null;};HUAWEIFloorPlanLoader.prototype.isPointOnLine=function isPointOnLine(pointA,pointB,pointToCheck){var c=new THREE.Vector3();c.crossVectors(pointA.clone().sub(pointToCheck),pointB.clone().sub(pointToCheck));return!c.length();};HUAWEIFloorPlanLoader.prototype.isPointOnLineAndBetweenPoints=function isPointOnLineAndBetweenPoints(pointA,pointB,pointToCheck){if(!this.isPointOnLine(pointA,pointB,pointToCheck)){return false;}var dx=pointB.x-pointA.x;var dy=pointB.z-pointA.z;// if a line is a more horizontal than vertical:\nif(Math.abs(dx)>=Math.abs(dy)){if(dx>0){return pointA.x<=pointToCheck.x&&pointToCheck.x<=pointB.x;}else{return pointB.x<=pointToCheck.x&&pointToCheck.x<=pointA.x;}}else{if(dy>0){return pointA.z<=pointToCheck.z&&pointToCheck.z<=pointB.z;}else{return pointB.z<=pointToCheck.z&&pointToCheck.z<=pointA.z;}}};return HUAWEIFloorPlanLoader;}();/**\r\n\t * @author pzx 2018.2.13\r\n\t * Json2MeshBuilderParser\r\n\t */var Thing3DCadLoader=function(){function Thing3DCadLoader(){classCallCheck(this,Thing3DCadLoader);this.sceneJson=null;this.scale=1;//比例尺\nthis.curFloorPlan=null;this.defaultWallTextureUri="Textures/RoomWall.jpg";this.defaultWallEdgeTextureUri="Textures/WallEdge.jpg";this.defaultFloorTextureUri="Textures/FloorDefault.jpg";this.defaultCeilingTextureUri="Textures/CeilingDefault.jpg";this.defaultRoofTextureUri="Textures/RoofDefault.jpg";//test\nthis.wallLines=[];this.roomLines=[];}//pzx start\nThing3DCadLoader.prototype.load=function load(map){var that=this;if(map){if(map["url"]){this.sceneURL=map["url"];}if(map["json"]){this.sceneJson=map["json"];}}else{console.error("load param can not be null");return null;}return new Promise(function(resolve,reject){that.loadDefaultTexture().then(function(){return that.loadSceneJson();}).then(function(){that.curFloorPlan=new FloorPlan();that.parseSceneJson();that.curFloorPlan.build();var walls=that.createWalls();var rooms=that.createRooms();var map={"walls":walls,"rooms":rooms,"wallLines":that.wallLines,"roomLines":that.roomLines};resolve(map);}).catch(function(error){console.error(error);});});};Thing3DCadLoader.prototype.loadSceneJson=function loadSceneJson(){var that=this;return new Promise(function(resolve,reject){if(that.sceneJson){resolve(that.sceneJson);}else if(that.sceneURL){var loader=new THREE.FileLoader();loader.load(that.sceneURL,function(data){that.sceneJson=JSON.parse(data);resolve();},function(){},function(error){reject("can not load "+that.sceneURL);});}else{reject("load scene json error");}});};Thing3DCadLoader.prototype.createTextureLoaderPromise=function createTextureLoaderPromise(texUri){var that=this;return new Promise(function(resolve,reject){var texLoader=new THREE.TextureLoader();// var that = this;\n// load a resource\ntexLoader.load(// resource URL\n// that.sceneURL+"/"+texUri,\ntexUri,// Function when resource is loaded\nfunction(texture){texture.wrapS=THREE.RepeatWrapping;texture.wrapT=THREE.RepeatWrapping;resolve(texture);},// Function called when download progresses\nfunction(xhr){console.log(texUri+" "+xhr.loaded/xhr.total*100+\'% loaded\');},// Function called when download errors\nfunction(xhr){resolve(null);console.log(texUri+\'load error\');});});};Thing3DCadLoader.prototype.loadDefaultTexture=function loadDefaultTexture(){var that=this;return new Promise(function(resolve,reject){var wallTexPromise=that.createTextureLoaderPromise(that.defaultWallTextureUri);var wallEdgePromise=that.createTextureLoaderPromise(that.defaultWallEdgeTextureUri);var floorPromise=that.createTextureLoaderPromise(that.defaultFloorTextureUri);var roofPromise=that.createTextureLoaderPromise(that.defaultRoofTextureUri);var ceilingPromise=that.createTextureLoaderPromise(that.defaultCeilingTextureUri);Promise.all([wallTexPromise,wallEdgePromise,floorPromise,roofPromise,ceilingPromise]).then(function(textures){DefaultResource.wallTexture=textures[0];DefaultResource.wallEdgeTexture=textures[1];DefaultResource.floorTexture=textures[2];DefaultResource.roofTexture=textures[3];DefaultResource.ceilingTexture=textures[4];resolve();});});};Thing3DCadLoader.prototype.createLine=function createLine(list,color){var material=new THREE.LineBasicMaterial({color:color});var geometry=new THREE.Geometry();for(var i=0;i<list.length;i++){var pos=list[i];geometry.vertices.push(pos);}var line=new THREE.Line(geometry,material);return line;};Thing3DCadLoader.prototype.parseSceneJson=function parseSceneJson(){var sceneJson=this.sceneJson;if(sceneJson["unit"]){this.scale=sceneJson["unit"]*0.01;}if(sceneJson["walls"]){this.parseWallJson(sceneJson["walls"]);}if(sceneJson["rooms"]){this.parseRoomJson(sceneJson["rooms"]);}};Thing3DCadLoader.prototype.parseWallJson=function parseWallJson(wallsJson){for(var i=0,len=wallsJson.length;i<len;i++){var singleWallData=wallsJson[i];var x=singleWallData["start"][0]*this.scale;var y=singleWallData["start"][1]*this.scale;var startCorner=null;var endCorner=null;if(!this.curFloorPlan.existsCorner(x,0,y)){startCorner=this.curFloorPlan.addCorner(x,0,y);}else{startCorner=this.curFloorPlan.getCorner(x,0,y);}x=singleWallData["end"][0]*this.scale;y=singleWallData["end"][1]*this.scale;if(!this.curFloorPlan.existsCorner(x,0,y)){endCorner=this.curFloorPlan.addCorner(x,0,y);}else{endCorner=this.curFloorPlan.getCorner(x,0,y);}var wall=new Wall();if(singleWallData.height){wall.height=singleWallData.height;}wall.startCorner=startCorner;wall.endCorner=endCorner;wall.startCorner.addWall(wall);wall.endCorner.addWall(wall);//test start\nvar list=[];list.push(wall.startCorner.position);list.push(wall.endCorner.position);var line=this.createLine(list,new THREE.Color(1,0,0));this.wallLines.push(line);//test end\nthis.curFloorPlan.addWall(wall);}};Thing3DCadLoader.prototype.parseRoomJson=function parseRoomJson(roomsJson){for(var i=0;i<roomsJson.length;i++){var singleRoomJson=roomsJson[i];var points=[];for(var j=0;j<singleRoomJson["points"].length;j++){var posArray=singleRoomJson["points"][j];points.push(new THREE.Vector3(posArray[0]*this.scale,0,posArray[1]*this.scale));}var room=new Room();//test start\nvar line=this.createLine(points,new THREE.Color(0,1,0));this.roomLines.push(line);//test end\nroom.points=points;if(singleRoomJson["center"]){var center=new THREE.Vector3();center.x=singleRoomJson["center"][0];center.y=0;center.z=singleRoomJson["center"][1];room.center=center;}if(singleRoomJson["offset"]){var offset=new THREE.Vector3();offset.x=singleRoomJson["offset"][0];offset.y=singleRoomJson["offset"][1];offset.z=singleRoomJson["offset"][2];room.offset=offset;}if(singleRoomJson["parentPosition"]){var parentPos=new THREE.Vector3();parentPos.x=singleRoomJson["parentPosition"][0];parentPos.y=singleRoomJson["parentPosition"][1];parentPos.z=singleRoomJson["parentPosition"][2];room.parentPosition=parentPos;}this.curFloorPlan.rooms.push(room);}};Thing3DCadLoader.prototype.createRooms=function createRooms(){var roomMeshs=[];for(var i=0;i<this.curFloorPlan.rooms.length;i++){var room=this.curFloorPlan.rooms[i];roomMeshs.push(room.meshGroup);}return roomMeshs;};Thing3DCadLoader.prototype.createWalls=function createWalls(){var floorPlan=this.curFloorPlan;var walls=floorPlan.walls;var wallMeshs=[];for(var i=0;i<walls.length;i++){var wall=walls[i];var pos=wall.position;var group=new THREE.Group("wall");group.add(this.createWallMesh(wall.rightSideMeshInfo));group.add(this.createWallMesh(wall.leftSideMeshInfo));group.add(this.createWallMesh(wall.edgeSideMeshInfo));group.position.set(pos.x,pos.y,pos.z);wallMeshs.push(group);}return wallMeshs;};Thing3DCadLoader.prototype.createWallMesh=function createWallMesh(meshInfo){var geometry=new THREE.BufferGeometry();geometry.addAttribute(\'position\',new THREE.BufferAttribute(meshInfo.positionArray,3));geometry.addAttribute(\'normal\',new THREE.BufferAttribute(meshInfo.normalArray,3));geometry.addAttribute(\'uv\',new THREE.BufferAttribute(meshInfo.uvArray,2));var material=meshInfo.material;var mesh=new THREE.Mesh(geometry,material);return mesh;};return Thing3DCadLoader;}();/**\r\n\t * @author pzx 2018.4.2\r\n\t * Building\r\n\t */var Outdoors=function(_FloorPlan){inherits(Outdoors,_FloorPlan);function Outdoors(){classCallCheck(this,Outdoors);return possibleConstructorReturn(this,_FloorPlan.call(this));}Outdoors.prototype.build=function build(){for(var i=0;i<this.rooms.length;i++){var room=this.rooms[i];room.isOnlyFloor=true;}_FloorPlan.prototype.build.call(this);};return Outdoors;}(FloorPlan);var CustomResource=function(_Resource){inherits(CustomResource,_Resource);function CustomResource(url){classCallCheck(this,CustomResource);//针对自定义贴图，颜色以及渲染模式\nvar _this=possibleConstructorReturn(this,_Resource.call(this,url));_this.customTexture=null;_this.color=null;_this.renderMode=null;_this.modelID=null;return _this;}CustomResource.prototype.combine=function combine(){if(this.model){if(this.customTexture!==null){this.changeWithCustomTexture(this.model);}if(this.color!==null){this.changeWithCustomColor(this.model);}if(this.renderMode!==null){this.changeRenderMode(this.model);}this.combineBundleObj=new CombineBundleObject$1(this.model);this.combineBundleObj.combine();this.isCombine=true;}};CustomResource.prototype.changeRenderMode=function changeRenderMode(obj){if(obj instanceof THREE.Mesh){obj.material.color=this.color;if(this.renderMode!==null){switch(this.renderMode){case 1:obj.material.transparent=false;obj.material.alphaTest=0.5;break;case 3:case 2:obj.material.transparent=true;break;default:console.error("can not find renderMode "+this.renderMode);}}}for(var i=0;i<obj.children.length;i++){var child=obj.children[i];this.changeRenderMode(child);}};CustomResource.prototype.changeWithCustomColor=function changeWithCustomColor(obj){if(obj instanceof THREE.Mesh){obj.material.color=this.color;if(this.opacity!==null){obj.material.opacity=this.opacity;obj.material.transparent=true;}}for(var i=0;i<obj.children.length;i++){var child=obj.children[i];this.changeWithCustomColor(child);}};CustomResource.prototype.changeWithCustomTexture=function changeWithCustomTexture(obj){if(obj instanceof THREE.Mesh){if(this.customTexture&&this.customTexture.texture){this.customTexture.texture.flipY=false;}obj.material.map=this.customTexture.texture;}for(var i=0;i<obj.children.length;i++){var child=obj.children[i];this.changeWithCustomTexture(child);}};CustomResource.prototype.downloadModel=function downloadModel(cb){var that=this;var loader=new thingjs.GLTFLoader();var url=null;var version=0;//如果开启使用最高版本，则用0，否则用本身的版本\nif(!this.manager.enableUserHighestVersionResource){version=this.version;}if(this.url){url=this.url;}else{url=this.baseUrl+this.modelID+"/"+version+"/gltf/";}loader.loadFromURL({url:url,modelCallback:function modelCallback(root){that.model=root.node.children[0];that.animations=root.animations;that.ready=true;//\nif(that.customTexture!==null){that.customTexture.downloadTexture(function(){if(that.customTexture!==null){that.changeWithCustomTexture(that.model);}if(that.color!==null){that.changeWithCustomColor(that.model);}if(that.renderMode!==null){that.changeRenderMode(that.model);}that.downloadCallback(cb);});}else{if(that.color!==null){that.changeWithCustomColor(that.model);}if(that.renderMode!==null){that.changeRenderMode(that.model);}that.downloadCallback(cb);}},errorCallback:function errorCallback(){console.error("download error "+url);that.ready=true;// that.model = new THREE.Object3D();\nthat.isEmpty=true;that.downloadCallback(cb);}});};// downloadModel(cb) {\n//     var that = this;\n//     var loader = new encryptmodel.ModelLoader();\n//     var url = null;\n//     var version = 0;\n//     //如果开启使用最高版本，则用0，否则用本身的版本\n//     if (!this.manager.enableUserHighestVersionResource) {\n//         version = this.version;\n//     }\n//     if (this.url) {\n//         url = this.url;\n//     } else {\n//         url = this.baseUrl + this.modelID + "/" + version + "/gltf/";\n//     }\n//     loader.load(url, function (root) {\n//         that.model = root.scene.children[0];\n//         that.animations = root.animations;\n//         that.ready = true;//\n//         if (that.customTexture !== null) {\n//             that.customTexture.downloadTexture(function () {\n//                 if (that.customTexture !== null) {\n//                     that.changeWithCustomTexture(that.model);\n//                 }\n//                 if (that.color !== null) {\n//                     that.changeWithCustomColor(that.model);\n//                 }\n//                 if (that.renderMode !== null) {\n//                     that.changeRenderMode(that.model);\n//                 }\n//                 that.downloadCallback(cb);\n//             })\n//         } else {\n//             if (that.color !== null) {\n//                 that.changeWithCustomColor(that.model);\n//             }\n//             if (that.renderMode !== null) {\n//                 that.changeRenderMode(that.model);\n//             }\n//             that.downloadCallback(cb);\n//         }\n//     }, function () {\n//     }, function () {\n//         console.error("download error " + (url));\n//         that.ready = true;\n//         // that.model = new THREE.Object3D();\n//         that.isEmpty = true;\n//         that.downloadCallback(cb);\n//     })\n// }\n// downloadModel(cb) {\n//     var that = this;\n//     var loader = new THREE.FileLoader();\n//     var url = null;\n//     var version = 0;\n//     //如果开启使用最高版本，则用0，否则用本身的版本\n//     if(!this.manager.enableUserHighestVersionResource){\n//         version = this.version;\n//     }\n//     if (this.url) {\n//         url = this.url;\n//     } else {\n//         url = this.baseUrl + this.modelID + "/" + version + "/gltf/";\n//     }\n//     // this.url = url;\n//     var fileloader = new THREE.FileLoader();\n//     // fileloader.setCrossOrigin("anonymous");\n//     fileloader.setResponseType(\'json\');\n//     fileloader.load(url + "index.json", function (data) {\n//         if (data&&data["gltfFiles"]) {\n//\n//             // var singleObjLoader = new THREE.GLTFLoader(that.app.loadingManager);\n//             var singleObjLoader = new THREE.GLTFLoader();\n//             singleObjLoader.setCrossOrigin("anonymous");\n//             var out = {};\n//             singleObjLoader.setDRACOLoader(new encryptmodel.DracoXLoader(null,data, out))\n//             var gltfFile = out.data["gltffiles"][0];\n//             singleObjLoader.load(url + gltfFile, function (root) {\n//                     that.model = root.scene.children[0];\n//                     that.animations = root.animations;\n//                     that.ready = true;//\n//                     if(that.customTexture!==null){\n//                         that.customTexture.downloadTexture(function(){\n//                             if(that.customTexture!==null){\n//                                 that.changeWithCustomTexture(that.model);\n//                             }\n//                             if(that.color!==null){\n//                                 that.changeWithCustomColor(that.model);\n//                             }\n//                             if(that.renderMode!==null){\n//                                 that.changeRenderMode(that.model);\n//                             }\n//                             that.downloadCallback(cb);\n//                         })\n//                     }else{\n//                         if(that.color!==null){\n//                             that.changeWithCustomColor(that.model);\n//                         }\n//                         if(that.renderMode!==null){\n//                             that.changeRenderMode(that.model);\n//                         }\n//                         that.downloadCallback(cb);\n//                     }\n//                 },\n//                 //过程\n//                 function () {\n//\n//                 },\n//                 //出错\n//                 function (error) {\n//                     console.error("download error " + (url + gltfFile));\n//                     that.ready = true;\n//                     // that.model = new THREE.Object3D();\n//                     that.isEmpty = true;\n//                     that.downloadCallback(cb);\n//                 });\n//         } else {\n//             that.ready = true;\n//             console.warn("fail parse " + (url + "index.json"));\n//             // that.model = new THREE.Object3D();\n//             that.downloadCallback(cb);\n//         }\n//\n//\n//     }, function () {\n//     }, function (error) {\n//         if(!that.tryHightedtVersion){\n//             that.version = 0;\n//             that.tryHightedtVersion = true;\n//             that.downloadModel(cb);\n//             return ;\n//\n//         }\n//         console.log("error" + (url + "index.json"));\n//         that.ready = true;\n//         // that.model = new THREE.Object3D();\n//         that.isEmpty = true;\n//         that.downloadCallback(cb);\n//     });\n// }\nreturn CustomResource;}(Resource);var CustomModelResource=function(_Resource){inherits(CustomModelResource,_Resource);function CustomModelResource(url){classCallCheck(this,CustomModelResource);//针对自定义贴图，颜色以及渲染模式\nvar _this=possibleConstructorReturn(this,_Resource.call(this,url));_this.customTexture=null;_this.color=null;_this.renderMode=null;_this.modelID=null;_this.localBaseUrl=null;_this.localUrl=null;return _this;}CustomModelResource.prototype.combine=function combine(){if(this.model){if(this.customTexture!==null){this.changeWithCustomTexture(this.model);}if(this.color!==null){this.changeWithCustomColor(this.model);}if(this.renderMode!==null){this.changeRenderMode(this.model);}this.combineBundleObj=new CombineBundleObject$1(this.model);this.combineBundleObj.combine();this.isCombine=true;}};CustomModelResource.prototype.changeRenderMode=function changeRenderMode(obj){if(obj instanceof THREE.Mesh){obj.material.color=this.color;if(this.renderMode!==null){switch(this.renderMode){case 1:obj.material.transparent=false;obj.material.alphaTest=0.5;break;case 3:case 2:obj.material.transparent=true;break;default:console.error("can not find renderMode "+this.renderMode);}}}for(var i=0;i<obj.children.length;i++){var child=obj.children[i];this.changeRenderMode(child);}};CustomModelResource.prototype.changeWithCustomColor=function changeWithCustomColor(obj){if(obj instanceof THREE.Mesh){obj.material.color=this.color;if(this.opacity!==null){obj.material.opacity=this.opacity;obj.material.transparent=true;}}for(var i=0;i<obj.children.length;i++){var child=obj.children[i];this.changeWithCustomColor(child);}};CustomModelResource.prototype.changeWithCustomTexture=function changeWithCustomTexture(obj){if(obj instanceof THREE.Mesh){if(this.customTexture&&this.customTexture.texture){this.customTexture.texture.flipY=false;}obj.material.map=this.customTexture.texture;}for(var i=0;i<obj.children.length;i++){var child=obj.children[i];this.changeWithCustomTexture(child);}};// downloadModel(cb) {\n//     var that = this;\n//     var loader = new THREE.FileLoader();\n//     var url = null;\n//     if (this.localUrl) {\n//         url = this.localBaseUrl + this.localUrl;\n//     } else {\n//         console.error("can not find url");\n//         return;\n//     }\n//     var singleObjLoader = new THREE.GLTFLoader();\n//     // singleObjLoader.setDRACOLoader(new DracoXLoader(null,data))\n//     singleObjLoader.setCrossOrigin("anonymous");\n//     singleObjLoader.load(url, function (root) {\n//             that.model = root.scene;\n//             that.animations = root.animations;\n//             that.ready = true;\n//             if (that.customTexture !== null) {\n//                 that.customTexture.downloadTexture(function () {\n//                     that.downloadCallback(cb);\n//                 })\n//             } else {\n//                 that.downloadCallback(cb);\n//             }\n//         },\n//         //过程\n//         function () {\n//         },\n//         //出错\n//         function (error) {\n//             console.error("download error " + (url));\n//             that.ready = true;\n//             // that.model = new THREE.Object3D();\n//             that.isEmpty = true;\n//             that.downloadCallback(cb);\n//         });\n// }\nCustomModelResource.prototype.downloadModel=function downloadModel(cb){var that=this;var loader=new THREE.FileLoader();var url=null;if(this.localUrl){url=this.localBaseUrl+this.localUrl;}else{console.error("can not find url");return;}var loader=new thingjs.GLTFLoader();loader.load(url,function(gltf){that.model=gltf.scene;that.animations=gltf.animations;that.ready=true;if(that.customTexture!==null){that.customTexture.downloadTexture(function(){if(that.customTexture!==null){that.changeWithCustomTexture(that.model);}if(that.color!==null){that.changeWithCustomColor(that.model);}if(that.renderMode!==null){that.changeRenderMode(that.model);}that.downloadCallback(cb);});}else{if(that.color!==null){that.changeWithCustomColor(that.model);}if(that.renderMode!==null){that.changeRenderMode(that.model);}that.downloadCallback(cb);}// if (that.customTexture !== null) {\n//     that.customTexture.downloadTexture(function () {\n//         that.downloadCallback(cb);\n//     })\n// } else {\n//     that.downloadCallback(cb);\n// }\n},undefined,function(error){console.error("download error "+url+"  "+error);that.ready=true;// that.model = new THREE.Object3D();\nthat.isEmpty=true;that.downloadCallback(cb);});};return CustomModelResource;}(Resource);var ResourceManager=function(){function ResourceManager(){classCallCheck(this,ResourceManager);this.textures=[];this.models=[];// this.baseTextureUrl = "http://model.3dmomoda.cn/textures/";\nthis.baseTextureUrl="https://static.3dmomoda.com/textures/";// this.baseModelUrl = "http://model.3dmomoda.cn/models/" + bundleID + "/" + version + "/gltf/";\nthis.baseModelUrl="https://model.3dmomoda.com/models/";this.localCustomModelBaseUrl=null;this.wallTextures=[];this.wallModels=[];this.roomTextures=[];this.commonTextures=[];this.doorOrWindowModels=[];this.placementModels=[];this.isStartedDonwloadResouces=false;this.allResouces=[];this.curDonwloadResIndex=-1;this.alreadyResouceCount=0;this.downloadResMaxCount=10;this.downloadResCompleteCallback=null;this.delayDownload=false;this.resourceMap={};this.downloadResProgess=0;this.opacity=null;this.currentDownloadResMap=new Map();this.enableUserHighestVersionResource=DefaultSetting.enableUseHighestVersionResource;}ResourceManager.prototype.addCommonTextureResource=function addCommonTextureResource(res){this._addResource(res,this.commonTextures);};ResourceManager.prototype.addWallTextureResource=function addWallTextureResource(resource){for(var i=0;i<this.wallTextures.length;i++){var res=this.wallTextures[i];if(res.id===resource.id)return;}this.wallTextures.push(resource);};ResourceManager.prototype.addWallModelResource=function addWallModelResource(resource){for(var i=0;i<this.wallModels.length;i++){var res=this.wallModels[i];if(res.id===resource.id)return;}this.wallModels.push(resource);};ResourceManager.prototype.addPlacementResource=function addPlacementResource(res){this._addResource(res,this.placementModels);};ResourceManager.prototype.addRoomResource=function addRoomResource(res){this._addResource(res,this.roomTextures);};ResourceManager.prototype._addResource=function _addResource(res,list){for(var i=0;i<list.length;i++){var item=list[i];if(item.id===res.id){return;}}list.push(res);};ResourceManager.prototype.checkAllResourcesIsReady=function checkAllResourcesIsReady(){for(var i=0;i<this.textures.length;i++){var tex=this.textures[i];if(!tex.ready){console.log(tex.url);return false;}}for(var i=0;i<this.models.length;i++){var model=this.models[i];if(!model.ready){console.log(model.url);return false;}}return true;};ResourceManager.prototype.resourceCallback=function resourceCallback(){this.alreadyResouceCount++;if(this.alreadyResouceCount===this.downloadResMaxCount){this.downloadResources();}};ResourceManager.prototype.initLightMaps=function initLightMaps(cb){var res=null;var wallLightMapID="18091219l1g1hnjt";// var wallLightMapID = "WallLighting";\nvar floorLigthMapID="18091216vjlgtwbh";var promises=[];if(DefaultSetting.enableManaulWallLightMap){res=new Resource(this);res.baseUrl=this.baseTextureUrl;// res.baseUrl = "./Textures/";\nres.id=wallLightMapID;res.ext="png";DefaultResource.wallLightMapResource=res;var p=new Promise(function(resolve,reject){DefaultResource.wallLightMapResource.downloadTexture(function(){resolve();});});promises.push(p);}if(DefaultSetting.enableFloorLightMap){res=new Resource(this);res.baseUrl=this.baseTextureUrl;res.id=floorLigthMapID;res.ext="jpg";DefaultResource.floorLightMapResource=res;var p=new Promise(function(resolve,reject){DefaultResource.floorLightMapResource.downloadTexture(function(){resolve();});});promises.push(p);}Promise.all(promises).then(function(){if(cb){cb();}});};ResourceManager.prototype.downloadResources=function downloadResources(cb){var that=this;if(!this.isStartedDonwloadResouces){var allResources=[];this.downloadResProgess=0;allResources=allResources.concat(this.wallTextures).concat(this.wallModels).concat(this.roomTextures).concat(this.doorOrWindowModels).concat(this.placementModels).concat(this.commonTextures);this.allResouces=allResources;this.isStartedDonwloadResouces=true;this.curDonwloadResIndex=0;}else{if(this.curDonwloadResIndex===this.allResouces.length-1){this.downloadResProgess=1;cb();return;}}if(this.allResouces.length===0){this.downloadResProgess=1;cb();return;}var curCount=0;var promises=[];for(var i=this.curDonwloadResIndex;i<this.allResouces.length;i++,curCount++){var res=this.allResouces[i];if(res.ext===null){var p=new Promise(function(resolve,reject){res.downloadModel(function(){resolve();});});promises.push(p);}else{var p=new Promise(function(resolve,reject){res.downloadTexture(function(){resolve();});});promises.push(p);}this.curDonwloadResIndex++;if(curCount===this.downloadResMaxCount){this.curDonwloadResIndex=i;break;}if(i===this.allResouces.length-1){this.curDonwloadResIndex=i;}}Promise.all(promises).then(function(){that.downloadResProgess=that.curDonwloadResIndex/(that.allResouces.length-1);that.downloadResources(cb);}).catch(function(error){console.log(error);});};ResourceManager.prototype.downloadResourcesWithQueue=function downloadResourcesWithQueue(cb){var that=this;if(that.allResouces.length!==0){this.downloadResProgess=(this.curDonwloadResIndex-this.currentDownloadResMap.size)/that.allResouces.length;}// console.log(this.downloadResProgess);\nif(!this.isStartedDonwloadResouces){var allResources=[];this.downloadResProgess=0;if(DefaultSetting.enableCombine){allResources=allResources.concat(this.wallTextures).concat(this.wallModels).concat(this.roomTextures).concat(this.doorOrWindowModels).concat(this.placementModels).concat(this.commonTextures);}else{allResources=allResources.concat(this.textures).concat(this.models);}this.allResouces=allResources;this.isStartedDonwloadResouces=true;this.curDonwloadResIndex=0;this.currentDownloadResMap=new Map();}else{if(this.curDonwloadResIndex===this.allResouces.length&&this.currentDownloadResMap.size===0){// console.log("over " + this.downloadResProgess);\nthis.downloadResProgess=1;cb();return;}}if(this.allResouces.length===0){this.downloadResProgess=1;cb();return;}if(this.curDonwloadResIndex>this.allResouces.length-1)return;var curCount=0;var promises=[];var maxCount=this.downloadResMaxCount-this.currentDownloadResMap.size;if(maxCount!==0){var res=this.allResouces[this.curDonwloadResIndex];if(res.ext===null){var p=new Promise(function(resolve,reject){res.downloadModel(function(){resolve(res);});});p.then(function(r){that.currentDownloadResMap.delete(r.id);that.downloadResourcesWithQueue(cb);});this.currentDownloadResMap.set(res.id,res);// promises.push(p);\n}else{var p=new Promise(function(resolve,reject){res.downloadTexture(function(){resolve(res);});});p.then(function(r){that.currentDownloadResMap.delete(r.id);that.downloadResourcesWithQueue(cb);});this.currentDownloadResMap.set(res.id,res);}this.curDonwloadResIndex++;this.downloadResourcesWithQueue(cb);}// for (var i = this.curDonwloadResIndex; i < this.allResouces.length; i++, curCount++) {\n//     var res = this.allResouces[i];\n//     if (res.ext === null) {\n//         var p = new Promise((resolve, reject) => {\n//             res.downloadModel(function () {\n//\n//                 resolve(res);\n//             });\n//         });\n//         p.then(function(r){\n//             that.currentDownloadResMap.delete(r.id);\n//             that.downloadResourcesWithQueue(cb);\n//         });\n//         this.currentDownloadResMap.set(res.id,res);\n//         // promises.push(p);\n//     } else {\n//         var p = new Promise((resolve, reject) => {\n//             res.downloadTexture(function () {\n//\n//                 resolve(res);\n//             });\n//         });\n//         p.then(function(r){\n//             that.currentDownloadResMap.delete(r.id);\n//             that.downloadResourcesWithQueue(cb);\n//         });\n//         this.currentDownloadResMap.set(res.id,res);\n//         // promises.push(p);\n//     }\n//     this.curDonwloadResIndex++;\n//     if (curCount === maxCount-1) {\n//         // this.curDonwloadResIndex = i;\n//         break;\n//     }\n//     if (i === this.allResouces.length - 1) {\n//         this.curDonwloadResIndex = i;\n//     }\n// }\n};ResourceManager.prototype.loadTextures=function loadTextures(jsonData){var res=null;for(var i=0;i<jsonData.length;i++){var data=jsonData[i];res=new Resource(this);res.baseUrl=this.baseTextureUrl;if(data.url){res.url=data.url;}else if(data.id){res.id=data.id;res.ext=data.ext;}if(data.isDefault){res.isDefault=data.isDefault;}this.textures.push(res);if(!this.delayDownload){res.downloadTexture();}}};ResourceManager.prototype.loadModels=function loadModels(jsonData){var res=null;for(var i=0;i<jsonData.length;i++){var data=jsonData[i];if(data.model){res=new CustomResource(this);}else if(data.localurl){res=new CustomModelResource(this);}else{res=new Resource(this);}res.baseUrl=this.baseModelUrl;if(data.localurl){res.localUrl=data.localurl;res.id=data.id;res.localBaseUrl=this.localCustomModelBaseUrl;if(data.title){res.modelName=data.title;}res.modelID=data.id;if(data.texture!==null&&data.texture!==undefined){//注意要先加载textures，否则index会找不到\nres.customTexture=this.textures[data.texture];}if(data.rendermode){res.renderMode=data.rendermode;}if(data.color){var colorData=data.color;res.color=new THREE.Color(colorData[0],colorData[1],colorData[2]);if(colorData.length===4){res.opacity=colorData[3];}}}else if(data.id){res.id=data.id;res.modelID=data.id;res.version=data.version;if(data.texture!==null&&data.texture!==undefined){//注意要先加载textures，否则index会找不到\nres.customTexture=this.textures[data.texture];}if(data.rendermode){res.renderMode=data.rendermode;}if(data.model){//这里如果有model说明是修改过颜色或者贴图的，对应的类不一样，解析model的id也不一样\nres.modelID=data.model;}if(data.title){res.modelName=data.title;}if(data.color){var colorData=data.color;res.color=new THREE.Color(colorData[0],colorData[1],colorData[2]);if(colorData.length===4){res.opacity=colorData[3];}}if(data.size){var sizeData=data.size;res.modelSize=new THREE.Vector3(sizeData[0],sizeData[1],sizeData[2]);}if(data.hasanimation){res.hasAnim=data.hasanimation;}if(data.url){res.url=data.url;}}this.models.push(res);if(!this.delayDownload){res.downloadModel();}}};//待写完单元测试后再替换，现在还不行\nResourceManager.prototype.loadCustomModelResource=function loadCustomModelResource(data,res){this.loadBaseResourceData(data,res);if(data.localurl){res.localUrl=data.localurl;res.localBaseUrl=this.localCustomModelBaseUrl;if(data.texture!==null&&data.texture!==undefined){//注意要先加载textures，否则index会找不到\nres.customTexture=this.textures[data.texture];}}};ResourceManager.prototype.loadCustomResource=function loadCustomResource(data,res){this.loadBaseResourceData(data,res);};ResourceManager.prototype.loadBaseResourceData=function loadBaseResourceData(data,res){res.id=data.id;res.modelID=data.id;res.version=data.version;if(data.texture!==null&&data.texture!==undefined){//注意要先加载textures，否则index会找不到\nres.customTexture=this.textures[data.texture];}if(data.rendermode){res.renderMode=data.rendermode;}if(data.model){//这里如果有model说明是修改过颜色或者贴图的，对应的类不一样，解析model的id也不一样\nres.modelID=data.model;}if(data.title){res.modelName=data.title;}if(data.color){var colorData=data.color;res.color=new THREE.Color(colorData[0],colorData[1],colorData[2]);if(colorData.length===4){res.opacity=colorData[3];}}if(data.size){var sizeData=data.size;res.modelSize=new THREE.Vector3(sizeData[0],sizeData[1],sizeData[2]);}if(data.hasanimation){res.hasAnim=data.hasanimation;}};ResourceManager.prototype.disposeModels=function disposeModels(){for(var i=0;i<this.models.length;i++){var res=this.models[i];res.dispose();}};ResourceManager.prototype.disposeTextures=function disposeTextures(){for(var i=0;i<this.textures.length;i++){var res=this.textures[i];res.dispose();}};return ResourceManager;}();/**\r\n\t * @author pzx 2018.4.2\r\n\t * WallCorner\r\n\t */var BaseObject$1=function(){function BaseObject(){classCallCheck(this,BaseObject);this.id=null;this.name=null;this.userID=null;this.position=new THREE.Vector3();this.rotation=new THREE.Quaternion(0,0,0,1);this.scale=new THREE.Vector3(1,1,1);this.enableDelayLoadMode=DefaultSetting.enableDelayLoadMode;this.parent=null;this.properties=null;this.isShow=true;}createClass(BaseObject,[{key:"worldPosition",get:function get(){if(this.parent){var worldPosition=new THREE.Vector3();worldPosition.addVectors(this.parent.worldPosition,this.position);return worldPosition;}else{return this.position;}}}]);return BaseObject;}();/**\r\n\t * @author pzx 2018.5.31\r\n\t * BaseWall,墙的基类\r\n\t */var BaseWall$1=function(_BaseObject){inherits(BaseWall,_BaseObject);function BaseWall(){classCallCheck(this,BaseWall);var _this=possibleConstructorReturn(this,_BaseObject.call(this));_this.startCorner=null;_this.endCorner=null;_this.thick=-1;_this.height=-1;_this.length=-1;_this.pathPoints=[];_this.direction=new THREE.Vector3();_this.doorOrWindows=[];_this.subWalls=[];_this.subCorners=[];_this.suspend=0;_this.mesh=null;_this.isShow=true;return _this;}BaseWall.prototype.baseBuild=function baseBuild(){this.direction=new THREE.Vector3();this.direction.subVectors(this.endCorner.position,this.startCorner.position);this.length=this.direction.length();this.direction.normalize();this.pathPoints.push(this.startCorner.position);this.pathPoints.push(this.endCorner.position);this.position.addVectors(this.endCorner.position,this.startCorner.position);// this.endCorner.position.add(this.startCorner.position).divide(2);\nthis.position.divideScalar(2);};BaseWall.prototype.build=function build(){};BaseWall.prototype.getWallOtherCorner=function getWallOtherCorner(corner){if(this.startCorner===corner){return this.endCorner;}else if(this.endCorner===corner){return this.startCorner;}else{return null;}};BaseWall.prototype.sortDoorOrWins=function sortDoorOrWins(){var startPos=this.startCorner.position;var endPos=this.endCorner.position;var xFlag=endPos.x-startPos.x>0?1:-1;var zFlag=endPos.z-startPos.z>0?1:-1;var useXToCompare=true;if(Math.abs(endPos.x-startPos.x)<0.001){useXToCompare=false;}var sortedList=[];for(var i=0;i<this.doorOrWindows.length;i++){var dwMaster=this.doorOrWindows[i];for(var j=0;j<sortedList.length;j++){var sortedDWMaster=sortedList[j];var dValue;if(useXToCompare){dValue=(sortedDWMaster.position.x-dwMaster.position.x)*xFlag;}else{dValue=(sortedDWMaster.position.z-dwMaster.position.z)*zFlag;}if(dValue>=0){sortedList.splice(j,0,dwMaster);break;}else{if(j==sortedList.length-1){sortedList.push(dwMaster);break;}}}if(sortedList.length===0){sortedList.push(dwMaster);}}return sortedList;};BaseWall.prototype.getWallCornerByPos=function getWallCornerByPos(pos){var closestCorner=null;var shorterDis=-1;var allCorners=this.subCorners;for(var i=0;i<allCorners.length;i++){// var disVec = pos;\nvar dis=pos.distanceTo(allCorners[i].position);// var dis = Vector3.Distance(pos, allCorners[i].position);\nif(dis<0.01){if(closestCorner===null){closestCorner=allCorners[i];shorterDis=dis;}else{if(dis<shorterDis){shorterDis=dis;closestCorner=allCorners[i];}}}}return closestCorner;};BaseWall.prototype.getDoorOrWinStartAndEndPos=function getDoorOrWinStartAndEndPos(doorOrWin){var size=doorOrWin.size;var wallDir=this.direction;var pos=doorOrWin.position.clone();pos.y=0;// var localPos = doorOrWin.localPosition;\nvar start=pos.clone();var end=pos.clone();var halfSizeX=size.x/2;start.subVectors(start,wallDir.clone().multiplyScalar(halfSizeX));end.addVectors(end,wallDir.clone().multiplyScalar(halfSizeX));// var start = pos - wallDir * size.x / 2;\n// var end = pos + wallDir * size.x / 2;\n// var localStart = localPos - wallDir * size.x / 2;\n// var localEnd = localPos + wallDir * size.x / 2;\nvar startAndEndPos=[start,end];return startAndEndPos;};BaseWall.prototype.addSubWallCorner=function addSubWallCorner(corner){for(var i=0;i<this.subCorners.length;i++){var subCorner=this.subCorners[i];if(subCorner===corner)return;}this.subCorners.push(corner);// if (!subCornerList.Contains(corner)) {\n//     subCornerList.Add(corner);\n// }\n};createClass(BaseWall,[{key:"worldPosition",get:function get(){var startPos=this.startCorner.worldPosition;var endPos=this.endCorner.worldPosition;var pos=new THREE.Vector3();pos.addVectors(startPos,endPos);pos.divideScalar(2);// var pos = startPos.add(endPos).divide(2);\nreturn pos;}}]);return BaseWall;}(BaseObject$1);/**\r\n\t * @author pzx 2018.2.12\r\n\t * WallCorner\r\n\t */var MeshInfo$1=function MeshInfo(){classCallCheck(this,MeshInfo);this.positionArray=null;this.normalArray=null;this.uvArray=null;this.colorArray=null;this.uv2Array=null;this.indexArray=null;this.material=null;this.resource=null;};/**\r\n\t * @author pzx 2018.2.12\r\n\t * Wall\r\n\t */var BaseStraightManualWall$1=function(_BaseWall){inherits(BaseStraightManualWall,_BaseWall);function BaseStraightManualWall(){classCallCheck(this,BaseStraightManualWall);var _this=possibleConstructorReturn(this,_BaseWall.call(this));_this.startCorner=null;_this.endCorner=null;_this.thick=DefaultSetting.StraightManualWallThick;_this.height=DefaultSetting.StraightManualWallHeight;// this.thick = 0.25;\n// this.height = 3;\n_this.cornersVertices=[new THREE.Vector3(),new THREE.Vector3(),new THREE.Vector3(),new THREE.Vector3()];_this.direction=null;_this.pathPoints=[];_this.selfPathPoints=[];_this.upDirection=new THREE.Vector3(0,1,0);_this.downDirection=new THREE.Vector3(0,-1,0);_this.basePoints=null;_this.repeatUV=[];_this.uvMultiple=[1,1];_this.rightSideLength=null;_this.leftSideLength=null;_this.floorPlanHeight=3;_this.rightSideMeshInfo=new MeshInfo$1();_this.leftSideMeshInfo=new MeshInfo$1();_this.edgeSideMeshInfo=new MeshInfo$1();_this.defaultWallTexture=null;_this.rightWallTexture=null;_this.leftWallTexture=null;_this.startUVPercent=[0,0,0,0];_this.endUVPercent=[1,1,1,1];_this.wallGroup=null;_this.leftResource=null;_this.rightResource=null;_this.edgeResource=null;_this.lightMapResource=null;_this.isBuilded=false;_this.vectorUp=new THREE.Vector3(0,1,0);_this.onlyBuildMeshInfo=false;// this.downDirection = new THREE.Vector3(0, -1, 0);\n_this.enableLightMap=DefaultSetting.enableManaulWallLightMap;_this.aoMapIntensity=DefaultSetting.wallLightMapIntensity;return _this;}// 获取位置（世界）\nBaseStraightManualWall.prototype.leftResourceCallback=function leftResourceCallback(tex){};BaseStraightManualWall.prototype.rightResourceCallback=function rightResourceCallback(tex){this.rigthWallTexture=tex;if(this.isBuilded){this.wallGroup[0].material.texture=this.rigthWallTexture;}};BaseStraightManualWall.prototype.resourceCallback=function resourceCallback(resource){if(resource===this.leftResource){this.leftWallTexture=resource.texture;this.initLightMap();if(this.isBuilded&&this.wallGroup){// this.wallGroup.children[1].material.map = this.leftWallTexture;\n// this.wallGroup.children[1].material.needsUpdate = true;\nif(this.enableLightMap){this.wallGroup.children[0].material=this.leftResource.wallLightMaterial;}else{this.wallGroup.children[0].material=this.leftResource.material;}this.wallGroup.children[0].material.needsUpdate=true;}}else if(resource===this.rightResource){this.rigthWallTexture=resource.texture;this.initLightMap();if(this.isBuilded&&this.wallGroup){// this.wallGroup.children[0].material.map = this.rigthWallTexture;\n// this.wallGroup.children[0].material.needsUpdate = true;\nif(this.enableLightMap){this.wallGroup.children[1].material=this.leftResource.wallLightMaterial;}else{this.wallGroup.children[1].material=this.leftResource.material;}// this.wallGroup.children[0].material = this.rightResource.wallMaterial;\n// this.wallGroup.children[0].material.needsUpdate = true;\n}}};BaseStraightManualWall.prototype.initMaterial=function initMaterial(){if(this.leftResource){if(this.leftResource.ready){this.leftWallTexture=this.leftResource.texture;}else{this.leftResource.callbackObjects.push(this);}}else if(!this.leftWallTexture){this.leftWallTexture=DefaultResource.wallTexture;}if(this.rightResource){if(this.rightResource.ready){this.rightWallTexture=this.rightResource.texture;}else{this.rightResource.callbackObjects.push(this);}}else if(!this.rightWallTexture){this.rightWallTexture=DefaultResource.wallTexture;}if(this.leftResource){this.leftSideMeshInfo.resource=this.leftResource;this.leftSideMeshInfo.material=this.leftResource.material;// new THREE.MeshStandardMaterial({color: 0xffffff, map:this.leftWallTexture});\n}else{this.leftSideMeshInfo.material=new THREE.MeshStandardMaterial({map:null});}if(this.rightResource){this.rightSideMeshInfo.resource=this.rightResource;this.rightSideMeshInfo.material=this.rightResource.material;// new THREE.MeshStandardMaterial({color: 0xffffff,map: this.rightWallTexture});\n}else{this.rightSideMeshInfo.material=new THREE.MeshStandardMaterial({map:null});}if(this.edgeResource){this.edgeSideMeshInfo.resource=this.edgeResource;this.edgeSideMeshInfo.material=this.edgeResource.material;// DefaultResource.wallEdgeMaterial;//new THREE.MeshStandardMaterial({map: DefaultResource.wallEdgeTexture});\n}else{this.edgeSideMeshInfo.material=new THREE.MeshStandardMaterial({map:null});}this.initLightMap();};BaseStraightManualWall.prototype.initLightMap=function initLightMap(){if(this.lightMapResource&&this.enableLightMap){if(this.rightResource.ready){//还要考虑材质公用的问题,现在地板跟墙用了材质，先测试使用，可以考虑在res增加专属墙的材质\nif(this.rightResource.wallLightMaterial===undefined){this.rightResource.wallLightMaterial=this.rightResource.wallMaterial.clone();}this.rightSideMeshInfo.material=this.rightResource.wallLightMaterial;this.rightSideMeshInfo.material.aoMap=this.lightMapResource.texture;this.rightSideMeshInfo.material.defines["WALL_AO"]=true;this.rightSideMeshInfo.material.metalness=0.2;this.rightSideMeshInfo.material.roughness=0.8;}if(this.leftResource.ready){if(this.leftResource.wallLightMaterial===undefined){this.leftResource.wallLightMaterial=this.leftResource.wallMaterial.clone();}this.leftSideMeshInfo.material=this.leftResource.wallLightMaterial;// this.leftSideMeshInfo.material.aoMap = this.lightMapResource.texture;\n// this.leftSideMeshInfo.material.defines["WALL_AO"] = true;\nthis.leftSideMeshInfo.material.metalness=0;this.leftSideMeshInfo.material.roughness=1;}}};BaseStraightManualWall.prototype.build=function build(){this.baseBuild();this.calPosInfo();this.calEachSideLen();this.calRepeatUV();this.calBasePoints();this.fillMesh();this.initMaterial();// this.initSimpleCornersAndWalls();\nif(!this.onlyBuildMeshInfo){var pos=this.position;var group=new THREE.Group("wall");group.add(this.createMesh(this.leftSideMeshInfo));group.add(this.createMesh(this.rightSideMeshInfo));group.add(this.createMesh(this.edgeSideMeshInfo));group.position.set(pos.x,pos.y,pos.z);this.wallGroup=group;this.mesh=this.wallGroup;}this.isBuilded=true;};BaseStraightManualWall.prototype.baseBuild=function baseBuild(){this.direction=new THREE.Vector3();this.direction.subVectors(this.endCorner.position,this.startCorner.position);this.direction.normalize();this.pathPoints.push(this.startCorner.position);this.pathPoints.push(this.endCorner.position);// this.position = this.endCorner.position.add(this.startCorner.position.position).divide(2);\n};BaseStraightManualWall.prototype.calEachSideLen=function calEachSideLen(){var dir=new THREE.Vector3();dir.subVectors(this.endCorner.position,this.startCorner.position);dir.normalize();var halfThick=this.thick/2;var dir_up=new THREE.Vector3();// dir_up.crossVectors(this.upDirection, dir);\ndir_up.crossVectors(this.downDirection,dir);dir_up.normalize();var dir_down=dir_up.clone();dir_down.negate();var resultUp=dir_up.clone();resultUp.multiplyScalar(halfThick);var resultDown=dir_down.clone();resultDown.multiplyScalar(halfThick);var rightStart=new THREE.Vector3();var rightEnd=new THREE.Vector3();var leftStart=new THREE.Vector3();var leftEnd=new THREE.Vector3();if(Util.equalVectorZero(this.cornersVertices[0])){rightStart.addVectors(this.selfPathPoints[0],resultUp);}else{rightStart.copy(this.cornersVertices[0]);}if(Util.equalVectorZero(this.cornersVertices[3])){rightEnd.addVectors(this.selfPathPoints[1],resultUp);}else{rightEnd.copy(this.cornersVertices[3]);}if(Util.equalVectorZero(this.cornersVertices[1])){leftStart.addVectors(this.selfPathPoints[0],resultDown);}else{leftStart.copy(this.cornersVertices[1]);}if(Util.equalVectorZero(this.cornersVertices[2])){leftEnd.addVectors(this.selfPathPoints[1],resultDown);}else{leftEnd.copy(this.cornersVertices[2]);}this.rightSideLength=new THREE.Vector3();this.leftSideLength=new THREE.Vector3();this.rightSideLength.subVectors(rightStart,rightEnd);this.leftSideLength.subVectors(leftStart,leftEnd);this.rightSideLength=this.rightSideLength.length();this.leftSideLength=this.leftSideLength.length();};BaseStraightManualWall.prototype.calRepeatUV=function calRepeatUV(){this.repeatUV[0]=this.uvMultiple[0]*this.rightSideLength/this.floorPlanHeight;this.repeatUV[1]=this.uvMultiple[1]*this.height/this.floorPlanHeight;this.repeatUV[2]=this.uvMultiple[0]*this.leftSideLength/this.floorPlanHeight;this.repeatUV[3]=this.uvMultiple[1]*this.height/this.floorPlanHeight;};BaseStraightManualWall.prototype.calPosInfo=function calPosInfo(){var pos=new THREE.Vector3();this.selfPathPoints.push(pos.subVectors(this.startCorner.position,this.position));// this.selfPathPoints.push(this.endCorner.position.sub(this.position));\npos=new THREE.Vector3();this.selfPathPoints.push(pos.subVectors(this.endCorner.position,this.position));this.selfPathPoints[0].y=0;this.selfPathPoints[1].y=0;};BaseStraightManualWall.prototype.calBasePoints=function calBasePoints(){if(this.basePoints===null){this.basePoints=[];for(var i=0;i<12;i++){this.basePoints.push(new THREE.Vector3());}}var halfThick=this.thick/2;var dir_up=new THREE.Vector3();// dir_up.crossVectors(this.upDirection, this.direction);\ndir_up.crossVectors(this.downDirection,this.direction);dir_up.normalize();var dir_down=dir_up.clone();dir_down.negate();var result=dir_up.multiplyScalar(halfThick);if(Util.equalVectorZero(this.cornersVertices[0])){this.basePoints[4].x=this.selfPathPoints[0].x+result.x;this.basePoints[4].y=0;this.basePoints[4].z=this.selfPathPoints[0].z+result.z;}else{this.basePoints[4].x=this.cornersVertices[0].x;this.basePoints[4].y=0;this.basePoints[4].z=this.cornersVertices[0].z;}if(Util.equalVectorZero(this.cornersVertices[1])){// ||subWallList.Count > 0) {\nresult=dir_down.multiplyScalar(halfThick);this.basePoints[5].x=this.selfPathPoints[0].x+result.x;this.basePoints[5].y=0;this.basePoints[5].z=this.selfPathPoints[0].z+result.z;//this.cornersVertices[1] = this.basePoints[5];\n}else{this.basePoints[5].x=this.cornersVertices[1].x;this.basePoints[5].y=0;this.basePoints[5].z=this.cornersVertices[1].z;}var negateDir=this.direction.clone();// dir_up.crossVectors(this.upDirection, negateDir.negate());// this.upDirection.cross(negateDir.negate());\ndir_up.crossVectors(this.downDirection,negateDir.negate());// this.upDirection.cross(negateDir.negate());\ndir_up.normalize();dir_down=dir_up.clone();dir_down.negate();if(Util.equalVectorZero(this.cornersVertices[2])){// || subWallList.Count > 0) {\nresult=dir_up.clone();result.multiplyScalar(halfThick);// result = halfThick * dir_up;\nthis.basePoints[6].x=this.selfPathPoints[1].x+result.x;this.basePoints[6].y=0;this.basePoints[6].z=this.selfPathPoints[1].z+result.z;//this.cornersVertices[2] = this.basePoints[6];\n}else{this.basePoints[6].x=this.cornersVertices[2].x;this.basePoints[6].y=0;this.basePoints[6].z=this.cornersVertices[2].z;}if(Util.equalVectorZero(this.cornersVertices[3])){// || subWallList.Count > 0) {\nresult=dir_down.clone();result.multiplyScalar(halfThick);// result = halfThick * dir_down;\nthis.basePoints[7].x=this.selfPathPoints[1].x+result.x;this.basePoints[7].y=0;this.basePoints[7].z=this.selfPathPoints[1].z+result.z;//this.cornersVertices[3] = this.basePoints[7];\n}else{this.basePoints[7].x=this.cornersVertices[3].x;this.basePoints[7].y=0;this.basePoints[7].z=this.cornersVertices[3].z;}// if (this.basePoints[0] == null)\n//     this.basePoints[0] = Vector3.zero;\n// if (this.basePoints[1] == null)\n//     this.basePoints[1] = Vector3.zero;\n// if (this.basePoints[2] == null)\n//     this.basePoints[2] = Vector3.zero;\n// if (this.basePoints[3] == null)\n//     this.basePoints[3] = Vector3.zero;\nthis.basePoints[0].x=this.basePoints[4].x;this.basePoints[0].y=this.basePoints[4].y+this.height;this.basePoints[0].z=this.basePoints[4].z;this.basePoints[1].x=this.basePoints[5].x;this.basePoints[1].y=this.basePoints[5].y+this.height;this.basePoints[1].z=this.basePoints[5].z;this.basePoints[2].x=this.basePoints[6].x;this.basePoints[2].y=this.basePoints[6].y+this.height;this.basePoints[2].z=this.basePoints[6].z;this.basePoints[3].x=this.basePoints[7].x;this.basePoints[3].y=this.basePoints[7].y+this.height;this.basePoints[3].z=this.basePoints[7].z;this.basePoints[8].x=this.selfPathPoints[0].x;this.basePoints[8].y=this.selfPathPoints[0].y+this.height;this.basePoints[8].z=this.selfPathPoints[0].z;this.basePoints[9].x=this.selfPathPoints[1].x;this.basePoints[9].y=this.selfPathPoints[1].y+this.height;this.basePoints[9].z=this.selfPathPoints[1].z;};BaseStraightManualWall.prototype.fillMesh=function fillMesh(){this.leftSideMeshInfo.positionArray=new Float32Array(18);this.leftSideMeshInfo.normalArray=new Float32Array(18);this.leftSideMeshInfo.uvArray=new Float32Array(12);this.leftSideMeshInfo.indexArray=new Float32Array(6);this.rightSideMeshInfo.positionArray=new Float32Array(18);this.rightSideMeshInfo.normalArray=new Float32Array(18);this.rightSideMeshInfo.uvArray=new Float32Array(12);this.rightSideMeshInfo.indexArray=new Float32Array(6);this.edgeSideMeshInfo.positionArray=new Float32Array(72);this.edgeSideMeshInfo.normalArray=new Float32Array(72);this.edgeSideMeshInfo.uvArray=new Float32Array(48);this.edgeSideMeshInfo.indexArray=new Float32Array(24);if(this.lightMapResource){this.leftSideMeshInfo.uv2Array=new Float32Array(12);this.rightSideMeshInfo.uv2Array=new Float32Array(12);this.leftSideMeshInfo.uv2Array=new Float32Array(12);}for(var i=0;i<6;i++){this.leftSideMeshInfo.indexArray[i]=i;this.rightSideMeshInfo.indexArray[i]=i;}for(var i=0;i<24;i++){this.edgeSideMeshInfo.indexArray[i]=i;}//定死使用全部的数，不保证里面的的12都有值\nvar vertices=this.basePoints;var index=0;var rightDir=new THREE.Vector3();// rightDir.crossVectors(this.upDirection, this.direction); //Vector3.Cross(this.upDirection, mDir);\nrightDir.crossVectors(this.downDirection,this.direction);//Vector3.Cross(this.upDirection, mDir);\nrightDir.normalize();var leftDir=new THREE.Vector3();// leftDir.crossVectors(this.direction, this.upDirection); //Vector3.Cross(mDir, this.upDirection);\nleftDir.crossVectors(this.direction,this.downDirection);//Vector3.Cross(mDir, this.upDirection);\nleftDir.normalize();var wallDir=this.direction;var reverseWallDir=wallDir.clone();reverseWallDir.negate();var verticesFL=new Array();//右手的面,默认是\nverticesFL[index++]=vertices[0];verticesFL[index++]=vertices[7];verticesFL[index++]=vertices[3];verticesFL[index++]=vertices[0];verticesFL[index++]=vertices[4];verticesFL[index++]=vertices[7];//左手的面\nverticesFL[index++]=vertices[2];verticesFL[index++]=vertices[5];verticesFL[index++]=vertices[1];verticesFL[index++]=vertices[2];verticesFL[index++]=vertices[6];verticesFL[index++]=vertices[5];//顶部面\nverticesFL[index++]=vertices[0];verticesFL[index++]=vertices[2];verticesFL[index++]=vertices[1];verticesFL[index++]=vertices[0];verticesFL[index++]=vertices[3];verticesFL[index++]=vertices[2];//如果有悬空，则补一下底部的面\nif(this.suspend!==0){verticesFL[index++]=vertices[4];verticesFL[index++]=vertices[5];verticesFL[index++]=vertices[6];verticesFL[index++]=vertices[4];verticesFL[index++]=vertices[6];verticesFL[index++]=vertices[7];}//起点截面的一侧\nverticesFL[index++]=vertices[1];verticesFL[index++]=vertices[4];verticesFL[index++]=vertices[0];verticesFL[index++]=vertices[1];verticesFL[index++]=vertices[5];verticesFL[index++]=vertices[4];//终点截面的另一侧\nverticesFL[index++]=vertices[3];verticesFL[index++]=vertices[7];verticesFL[index++]=vertices[2];verticesFL[index++]=vertices[2];verticesFL[index++]=vertices[7];verticesFL[index++]=vertices[6];//startcorner的补画mesh\nverticesFL[index++]=vertices[1];verticesFL[index++]=vertices[8];verticesFL[index++]=vertices[0];//endcorner的补画mesh\nverticesFL[index++]=vertices[3];verticesFL[index++]=vertices[9];verticesFL[index++]=vertices[2];// FillUV();\nindex=0;var normals=new Array();//一侧的面\nnormals[index++]=rightDir;normals[index++]=rightDir;normals[index++]=rightDir;normals[index++]=rightDir;normals[index++]=rightDir;normals[index++]=rightDir;for(var i=0;i<normals.length;i++){var vec=normals[i];var arrayIndex=i*3;this.rightSideMeshInfo.normalArray[arrayIndex]=vec.x;this.rightSideMeshInfo.normalArray[arrayIndex+1]=vec.y;this.rightSideMeshInfo.normalArray[arrayIndex+2]=vec.z;}//另一侧的面\nnormals[index++]=leftDir;normals[index++]=leftDir;normals[index++]=leftDir;normals[index++]=leftDir;normals[index++]=leftDir;normals[index++]=leftDir;for(var i=6,j=0;i<normals.length;i++,j++){var vec=normals[i];var arrayIndex=j*3;this.leftSideMeshInfo.normalArray[arrayIndex]=vec.x;this.leftSideMeshInfo.normalArray[arrayIndex+1]=vec.y;this.leftSideMeshInfo.normalArray[arrayIndex+2]=vec.z;}//顶部面\nnormals[index++]=this.upDirection;normals[index++]=this.upDirection;normals[index++]=this.upDirection;normals[index++]=this.upDirection;normals[index++]=this.upDirection;normals[index++]=this.upDirection;//如果有悬空，则补一下底部的面\nif(this.suspend!==0){normals[index++]=this.downDirection;normals[index++]=this.downDirection;normals[index++]=this.downDirection;normals[index++]=this.downDirection;normals[index++]=this.downDirection;normals[index++]=this.downDirection;}//截面的一侧\nnormals[index++]=reverseWallDir;normals[index++]=reverseWallDir;normals[index++]=reverseWallDir;normals[index++]=reverseWallDir;normals[index++]=reverseWallDir;normals[index++]=reverseWallDir;//截面的另一侧\nnormals[index++]=wallDir;normals[index++]=wallDir;normals[index++]=wallDir;normals[index++]=wallDir;normals[index++]=wallDir;normals[index++]=wallDir;//startcorner的填补的mesh\nnormals[index++]=this.upDirection;normals[index++]=this.upDirection;normals[index++]=this.upDirection;//endcorner的填补的mesh\nnormals[index++]=this.upDirection;normals[index++]=this.upDirection;normals[index++]=this.upDirection;for(var i=0;i<6;i++){var vec=verticesFL[i];var arrayIndex=i*3;this.rightSideMeshInfo.positionArray[arrayIndex]=vec.x;this.rightSideMeshInfo.positionArray[arrayIndex+1]=vec.y+this.suspend;this.rightSideMeshInfo.positionArray[arrayIndex+2]=vec.z;}for(var i=6,j=0;i<12;i++,j++){var vec=verticesFL[i];var arrayIndex=j*3;this.leftSideMeshInfo.positionArray[arrayIndex]=vec.x;this.leftSideMeshInfo.positionArray[arrayIndex+1]=vec.y+this.suspend;this.leftSideMeshInfo.positionArray[arrayIndex+2]=vec.z;}for(var i=12,j=0;i<verticesFL.length;i++,j++){var vec=verticesFL[i];var arrayIndex=j*3;this.edgeSideMeshInfo.positionArray[arrayIndex]=vec.x;this.edgeSideMeshInfo.positionArray[arrayIndex+1]=vec.y+this.suspend;this.edgeSideMeshInfo.positionArray[arrayIndex+2]=vec.z;}for(var i=12,j=0;i<normals.length;i++,j++){var vec=normals[i];var arrayIndex=j*3;this.edgeSideMeshInfo.normalArray[arrayIndex]=vec.x;this.edgeSideMeshInfo.normalArray[arrayIndex+1]=vec.y;this.edgeSideMeshInfo.normalArray[arrayIndex+2]=vec.z;}this.fillUV();};BaseStraightManualWall.prototype.fillUV=function fillUV(){var index=0;var uv_0,uv_1,uv_2,uv_3;if(this.rightResource.isDefault){uv_0=this.startUVPercent[0];uv_1=this.startUVPercent[1];uv_2=this.endUVPercent[0];uv_3=this.endUVPercent[1];}else{uv_0=this.startUVPercent[0]*this.repeatUV[0];uv_1=this.startUVPercent[1]*this.repeatUV[1];uv_2=this.endUVPercent[0]*this.repeatUV[0];uv_3=this.endUVPercent[1]*this.repeatUV[1];}//右侧\nvar uv=this.rightSideMeshInfo.uvArray;uv[index++]=uv_0;uv[index++]=uv_3;uv[index++]=uv_2;uv[index++]=uv_1;uv[index++]=uv_2;uv[index++]=uv_3;uv[index++]=uv_0;uv[index++]=uv_3;uv[index++]=uv_0;uv[index++]=uv_1;uv[index++]=uv_2;uv[index++]=uv_1;//左侧\nif(this.leftResource.isDefault){uv_0=this.startUVPercent[2];uv_1=this.startUVPercent[3];uv_2=this.endUVPercent[2];uv_3=this.endUVPercent[3];}else{uv_0=this.startUVPercent[2]*this.repeatUV[2];uv_1=this.startUVPercent[3]*this.repeatUV[3];uv_2=this.endUVPercent[2]*this.repeatUV[2];uv_3=this.endUVPercent[3]*this.repeatUV[3];}index=0;var uv=this.leftSideMeshInfo.uvArray;uv[index++]=uv_2;uv[index++]=uv_3;uv[index++]=uv_0;uv[index++]=uv_1;uv[index++]=uv_0;uv[index++]=uv_3;uv[index++]=uv_2;uv[index++]=uv_3;uv[index++]=uv_2;uv[index++]=uv_1;uv[index++]=uv_0;uv[index++]=uv_1;//顶部\nindex=0;var uv=this.edgeSideMeshInfo.uvArray;uv[index++]=0;uv[index++]=1;uv[index++]=1;uv[index++]=0;uv[index++]=1;uv[index++]=1;uv[index++]=0;uv[index++]=1;uv[index++]=0;uv[index++]=0;uv[index++]=1;uv[index++]=0;//起点一侧\nuv[index++]=0;uv[index++]=1;uv[index++]=1;uv[index++]=0;uv[index++]=1;uv[index++]=1;uv[index++]=0;uv[index++]=1;uv[index++]=0;uv[index++]=0;uv[index++]=1;uv[index++]=0;//终点一侧\nuv[index++]=0;uv[index++]=1;uv[index++]=0;uv[index++]=0;uv[index++]=1;uv[index++]=1;uv[index++]=0;uv[index++]=0;uv[index++]=1;uv[index++]=1;uv[index++]=1;uv[index++]=0;//startcorner的填补的mesh\nuv[index++]=0;uv[index++]=1;uv[index++]=0;uv[index++]=0;uv[index++]=1;uv[index++]=1;//endcorner的填补的mesh\nuv[index++]=0;uv[index++]=1;uv[index++]=0;uv[index++]=0;uv[index++]=1;uv[index++]=1;if(this.lightMapResource){//填写光线图\nuv_0=this.startUVPercent[0];uv_1=this.startUVPercent[1];uv_2=this.endUVPercent[0];uv_3=this.endUVPercent[1];index=0;uv=this.rightSideMeshInfo.uv2Array;uv[index++]=uv_0;uv[index++]=uv_3;uv[index++]=uv_2;uv[index++]=uv_1;uv[index++]=uv_2;uv[index++]=uv_3;uv[index++]=uv_0;uv[index++]=uv_3;uv[index++]=uv_0;uv[index++]=uv_1;uv[index++]=uv_2;uv[index++]=uv_1;uv=this.leftSideMeshInfo.uv2Array;index=0;uv[index++]=uv_2;uv[index++]=uv_3;uv[index++]=uv_0;uv[index++]=uv_1;uv[index++]=uv_0;uv[index++]=uv_3;uv[index++]=uv_2;uv[index++]=uv_3;uv[index++]=uv_2;uv[index++]=uv_1;uv[index++]=uv_0;uv[index++]=uv_1;}};BaseStraightManualWall.prototype.getWallOtherCorner=function getWallOtherCorner(corner){if(this.startCorner===corner){return this.endCorner;}else if(this.endCorner===corner){return this.startCorner;}else{return null;}};BaseStraightManualWall.prototype.createMesh=function createMesh(meshInfo){var geometry=new THREE.BufferGeometry();geometry.addAttribute(\'position\',new THREE.BufferAttribute(meshInfo.positionArray,3));geometry.addAttribute(\'normal\',new THREE.BufferAttribute(meshInfo.normalArray,3));geometry.addAttribute(\'uv\',new THREE.BufferAttribute(meshInfo.uvArray,2));var material=meshInfo.material;if(this.lightMapResource&&meshInfo.uv2Array&&this.enableLightMap){geometry.addAttribute(\'uv2\',new THREE.BufferAttribute(meshInfo.uv2Array,2));}meshInfo.material=material;var mesh=new THREE.Mesh(geometry,material);return mesh;};createClass(BaseStraightManualWall,[{key:\'position\',get:function get(){var startPos=this.startCorner.position;var endPos=this.endCorner.position;var pos=new THREE.Vector3();pos.addVectors(startPos,endPos);pos.divideScalar(2);// var pos = startPos.add(endPos).divide(2);\nreturn pos;},set:function set(value){}}]);return BaseStraightManualWall;}(BaseWall$1);/**\r\n\t * @author pzx 2018.6.6\r\n\t * SubStraightManualWall\r\n\t */var SubStraightManualWall$1=function(_BaseStraightManualWa){inherits(SubStraightManualWall,_BaseStraightManualWa);function SubStraightManualWall(){classCallCheck(this,SubStraightManualWall);return possibleConstructorReturn(this,_BaseStraightManualWa.call(this));}SubStraightManualWall.prototype.build=function build(){this.baseBuild();this.calPosInfo();// this.calEachSideLen();\n// this.calRepeatUV();\nthis.calBasePoints();this.fillMesh();this.initMaterial();// this.initSimpleCornersAndWalls();\nif(!this.enableDelayLoadMode){var pos=this.position;var group=new THREE.Group("wall");group.add(this.createMesh(this.leftSideMeshInfo));group.add(this.createMesh(this.rightSideMeshInfo));group.add(this.createMesh(this.edgeSideMeshInfo));group.position.set(pos.x,pos.y,pos.z);this.wallGroup=group;this.mesh=this.wallGroup;}this.isBuilded=true;};return SubStraightManualWall;}(BaseStraightManualWall$1);/**\r\n\t * @author pzx 2018.2.12\r\n\t * Wall\r\n\t */var Wall$1=function(_BaseStraightManualWa){inherits(Wall,_BaseStraightManualWa);function Wall(){classCallCheck(this,Wall);return possibleConstructorReturn(this,_BaseStraightManualWa.call(this));}Wall.prototype.initSimpleCornersAndWalls=function initSimpleCornersAndWalls(){var wallPos=this.position;// for (var i = 0; i < this.subWalls.Count; i++) {\n//     Core_Wall wall = subWallList[i];\n//     wall.Clear();\n// }\n// subWallList.Clear();\n// subCornerList.Clear();\nvar lookRot=new THREE.Vector3();lookRot.crossVectors(this.direction,this.vectorUp);// Vector3 projectRightTopOffSet = Vector3.Project(TopOffSet, lookRot);\n// float projectWallDirTopLen = Vector3.Project(TopOffSet,GetDirection()).magnitude;\n// float uMoveOffSet = LocalTopOffSet.x / Length;\nvar list=this.sortDoorOrWins();// WallDecorateParam decorateParam = GetDecorateParam();\nfor(var i=0;i<list.length;i++){var master=list[i];// if (master.Size == Vector3.zero)\n//     continue;\n//master.Refresh();\nvar startAndEndPos=this.getDoorOrWinStartAndEndPos(master);// GetDoorOrWinStartAndEndPos(master);\nvar doorWinRestPoints=this.getDoorOrWinRectPoints(master);var startCorner_DoorOrWin=SubWallCorner$1.createSubWallCorner(this.id+"_"+i+"_1",startAndEndPos[0],this);var endCorner_DoorOrWin=SubWallCorner$1.createSubWallCorner(this.id+"_"+i+"_2",startAndEndPos[1],this);// var startCorner_DoorOrWin = Core_WallCorner.CreateSubWallCorner(ID + "_" + i + "_1", startAndEndPos[0], startAndEndPos[2], this);\n// var endCorner_DoorOrWin = Core_WallCorner.CreateSubWallCorner(ID + "_" + i + "_2", startAndEndPos[1], startAndEndPos[3], this);\nthis.addSubWallCorner(startCorner_DoorOrWin);this.addSubWallCorner(endCorner_DoorOrWin);if(i===0){var wall1=new SubStraightManualWall$1();// Core_SubStraightManualWall();\nthis.subWalls.push(wall1);wall1.startCorner=this.startCorner;wall1.endCorner=startCorner_DoorOrWin;// wall1.SetWallDecorateParam(decorateParam);\nwall1.startCorner.build();// wall1.startTopOffSet = TopOffSet;\n// wall1.EndTopOffSet = projectRightTopOffSet;\nwall1.endCorner.build();//设置subwall的corner信息，因为跟父亲墙的corner顶点是一样的\nthis.setCornerVertices(wall1,true);wall1.calPosInfo();wall1.calEachSideLen();//wall1.EndUVPercent[0] = wall1.Length / Length;\nwall1.endUVPercent[0]=wall1.rightSideLength/this.rightSideLength;wall1.endUVPercent[2]=wall1.leftSideLength/this.leftSideLength;// if (TopOffSet != Vector3.zero) {\n//     wall1.TopLightUVEndMoveOffSet = uMoveOffSet;\n// }\nwall1.repeatUV=this.repeatUV;//wall1.Build();\nwall1.leftResource=this.leftResource;wall1.rightResource=this.rightResource;wall1.edgeResource=this.edgeResource;wall1.lightMapResource=this.lightMapResource;wall1.height=this.height;wall1.parentWall=this;// this.calLightUV(wall1);\n}else{var lastDoorOrWin=list[i-1];var lastStartAndEndPos=this.getDoorOrWinStartAndEndPos(lastDoorOrWin);var lastDoorWinRestPoints=this.getDoorOrWinRectPoints(lastDoorOrWin);var lastEndCorner=this.getWallCornerByPos(lastStartAndEndPos[1]);var manulWall=new SubStraightManualWall$1();this.subWalls.push(manulWall);// subWallList.Add(manulWall);\nmanulWall.startCorner=lastEndCorner;manulWall.endCorner=startCorner_DoorOrWin;var offset=new THREE.Vector3();offset.subVectors(lastEndCorner.position,startCorner_DoorOrWin.position);var wallLength=offset.length();manulWall.startCorner.build();manulWall.endCorner.build();manulWall.calPosInfo();manulWall.calEachSideLen();var rightSideDis=lastDoorWinRestPoints[3].distanceTo(wallPos.clone().addVectors(this.cornersVertices[0],wallPos));// Vector3.Distance(mCornersVertices[0] + wallPos, lastDoorWinRestPoints[3]);\n// var leftSideDis = Vector3.Distance(mCornersVertices[1] + wallPos, lastDoorWinRestPoints[2]);\nvar leftSideDis=lastDoorWinRestPoints[2].distanceTo(wallPos.clone().addVectors(this.cornersVertices[1],wallPos));// Vector3.Distance(mCornersVertices[1] + wallPos, lastDoorWinRestPoints[2]);\n// if (TopOffSet != Vector3.zero) {\n//     manulWall.TopLightUVEndMoveOffSet = uMoveOffSet;\n//     manulWall.TopLightUVStartMoveOffSet = uMoveOffSet;\n// }\nmanulWall.startUVPercent[0]=rightSideDis/this.rightSideLength;manulWall.startUVPercent[2]=leftSideDis/this.leftSideLength;manulWall.endUVPercent[0]=(rightSideDis+wallLength)/this.rightSideLength;manulWall.endUVPercent[2]=(leftSideDis+wallLength)/this.leftSideLength;manulWall.repeatUV=this.repeatUV;manulWall.leftResource=this.leftResource;manulWall.rightResource=this.rightResource;manulWall.edgeResource=this.edgeResource;manulWall.lightMapResource=this.lightMapResource;manulWall.height=this.height;manulWall.parentWall=this;}if(i==list.length-1){// var wall2 = new Core_SubStraightManualWall();\nvar wall2=new SubStraightManualWall$1();this.subWalls.push(wall2);// subWallList.Add(wall2);\nwall2.startCorner=endCorner_DoorOrWin;wall2.endCorner=this.endCorner;// wall2.SetWallDecorateParam(decorateParam);\nwall2.startCorner.build();//wall2.EndCorner.Build();\nthis.setCornerVertices(wall2,false);// wall2.StartTopOffSet = projectRightTopOffSet;\n// wall2.EndTopOffSet = TopOffSet;\nwall2.calPosInfo();wall2.calEachSideLen();// var rightSideDis = Vector3.Distance(mCornersVertices[0] + wallPos, doorWinRestPoints[3]);\n// var leftSideDis = Vector3.Distance(mCornersVertices[1] + wallPos, doorWinRestPoints[2]);\nvar rightSideDis=doorWinRestPoints[3].distanceTo(wallPos.clone().addVectors(this.cornersVertices[0],wallPos));//\n// Vector3.Distance(mCornersVertices[0] + wallPos, doorWinRestPoints[3]);\nvar leftSideDis=doorWinRestPoints[2].distanceTo(wallPos.clone().addVectors(this.cornersVertices[1],wallPos));// Vector3.Distance(mCornersVertices[1] + wallPos, doorWinRestPoints[2]);\n// if (TopOffSet != Vector3.zero) {\n//     wall2.TopLightUVStartMoveOffSet = uMoveOffSet;\n// }\nwall2.startUVPercent[0]=rightSideDis/this.rightSideLength;wall2.startUVPercent[2]=leftSideDis/this.leftSideLength;wall2.repeatUV=this.repeatUV;wall2.leftResource=this.leftResource;wall2.rightResource=this.rightResource;wall2.edgeResource=this.edgeResource;wall2.lightMapResource=this.lightMapResource;wall2.height=this.height;wall2.parentWall=this;//wall2.Build();\n// CalLightUV(wall2);\n}this.buildHeadAndFootWall(master,startCorner_DoorOrWin,endCorner_DoorOrWin);}};Wall.prototype.buildSimpleCornersAndWalls=function buildSimpleCornersAndWalls(){if(!this.enableDelayLoadMode){this.wallGroup=new THREE.Object3D();}for(var i=0;i<this.subCorners.length;i++){var subCorner=this.subCorners[i];subCorner.build();}for(var i=0;i<this.subWalls.length;i++){var subWall=this.subWalls[i];subWall.build();if(!this.enableDelayLoadMode){this.wallGroup.add(subWall.wallGroup);}}this.mesh=this.wallGroup;};/// <summary>\n/// 创建门窗的上下墙\n/// </summary>\n/// <param name="doorOrWindow"></param>\n/// <param name="startCorner"></param>\n/// <param name="endCorner"></param>\nWall.prototype.buildHeadAndFootWall=function buildHeadAndFootWall(doorOrWindow,startCorner,endCorner){var wallPos=this.position;//float len = Vector3.Distance(StartCorner.Position, startCorner.Position);\nvar doorWinRestPoints=this.getDoorOrWinRectPoints(doorOrWindow);var rightSideDis=doorWinRestPoints[0].distanceTo(wallPos.clone().addVectors(this.cornersVertices[0],wallPos));//\n// Vector3.Distance(mCornersVertices[0] + wallPos, doorWinRestPoints[0]);\n// float leftSideDis = Vector3.Distance(mCornersVertices[1] + wallPos, doorWinRestPoints[1]);\nvar leftSideDis=doorWinRestPoints[1].distanceTo(wallPos.clone().addVectors(this.cornersVertices[1],wallPos));//\n// Vector3.Distance(mCornersVertices[1] + wallPos, doorWinRestPoints[1]);\n// var uMoveOffSet =  (Vector3.Project(TopOffSet, GetDirection()).magnitude) / Length;\n// float uMoveOffSet =  (Vector3.Project(TopOffSet, GetDirection()).magnitude) / Length;\nvar windowBelowPercent=doorOrWindow.suspendPercent;//因为一个corner里有多个同样位置的墙，所以有可能对生成floor有影响\n//计算倾斜的数据\n// var bSize = BoundSizes\n// Vector3 topStartPos = StartCorner.Position;\n// topStartPos.y += Height;\n// topStartPos += TopOffSet;\nvar lookRot=new THREE.Vector3();lookRot.crossVectors(this.direction,this.vectorUp);var size=doorOrWindow.size;var suspend=size.y+this.height*windowBelowPercent;if(doorOrWindow.suspendPercent!==0){var belowWall=new SubStraightManualWall$1();this.subWalls.push(belowWall);belowWall.parent=this.parent;belowWall.startCorner=startCorner;belowWall.endCorner=endCorner;var offset=new THREE.Vector3();offset.subVectors(endCorner.position,startCorner.position);var wallLength=offset.length();// belowWall.SetWallDecorateParam(GetDecorateParam());\nbelowWall.height=this.height*windowBelowPercent;belowWall.startUVPercent=[rightSideDis/this.rightSideLength,0,leftSideDis/this.leftSideLength,0];belowWall.endUVPercent[0]=(rightSideDis+wallLength)/this.rightSideLength;belowWall.endUVPercent[1]=belowWall.height/this.height;belowWall.endUVPercent[2]=(leftSideDis+wallLength)/this.leftSideLength;belowWall.endUVPercent[3]=belowWall.height/this.height;// belowWall.TopLightUVStartMoveOffSet = LocalTopOffSet.x / Length;\n// belowWall.TopLightUVEndMoveOffSet = LocalTopOffSet.x / Length;\nbelowWall.uvMultiple=this.uvMultiple;belowWall.repeatUV=this.repeatUV;belowWall.leftResource=this.leftResource;belowWall.rightResource=this.rightResource;belowWall.edgeResource=this.edgeResource;belowWall.lightMapResource=this.lightMapResource;// belowWall.height = this.height;\n// belowWall.StartTopOffSet = projectRightTopOffSet * doorOrWindow.SuspendPercent  ;\n// belowWall.EndTopOffSet = projectRightTopOffSet * doorOrWindow.SuspendPercent ;\n// belowWall.TopOffSet = projectRightTopOffSet * doorOrWindow.SuspendPercent * forwordTopOffSetLen/Height ;\nbelowWall.parentWall=this;}if(suspend<this.height){var wall=new SubStraightManualWall$1();this.subWalls.push(wall);wall.parent=this.parent;wall.startCorner=startCorner;wall.endCorner=endCorner;var offset=new THREE.Vector3();offset.subVectors(endCorner.position,startCorner.position);var wallLength=offset.length();// wall.SetWallDecorateParam(GetDecorateParam());\nwall.suspend=suspend;wall.height=this.height-suspend;wall.startUVPercent=[rightSideDis/this.rightSideLength,suspend/this.height,leftSideDis/this.leftSideLength,suspend/this.height];wall.endUVPercent[0]=(rightSideDis+wallLength)/this.rightSideLength;wall.endUVPercent[2]=(leftSideDis+wallLength)/this.leftSideLength;wall.uvMultiple=this.uvMultiple;wall.repeatUV=this.repeatUV;wall.leftResource=this.leftResource;wall.rightResource=this.rightResource;wall.edgeResource=this.edgeResource;wall.lightMapResource=this.lightMapResource;// wall.height  =this.height;\nwall.parentWall=this;}};/// <summary>\n/// 设置sub墙的顶点，只有sub墙才会由父墙设置部分顶点，因为sub墙的一个墙角跟父墙公用，所以顶点也是一样的\n/// 就没有必要在计算了，直接赋值\n/// </summary>\n/// <param name="wall"></param>\n/// <param name="vertices"></param>\n/// <param name="flag">true为起始点，false为结束点</param>\nWall.prototype.setCornerVertices=function setCornerVertices(wall,flag){//注意CornersVertices里是相对坐标，不是绝对坐标\nif(flag){var posA=new THREE.Vector3();posA.addVectors(this.cornersVertices[0],this.position);posA.sub(wall.position);var posB=new THREE.Vector3();posB.addVectors(this.cornersVertices[1],this.position);posB.sub(wall.position);wall.cornersVertices[0]=posA;wall.cornersVertices[1]=posB;}else{var posA=new THREE.Vector3();posA.addVectors(this.cornersVertices[2],this.position);posA.sub(wall.position);var posB=new THREE.Vector3();posB.addVectors(this.cornersVertices[3],this.position);posB.sub(wall.position);wall.cornersVertices[2]=posA;wall.cornersVertices[3]=posB;// wall.CornersVertices[2] = CornersVertices[2] + Position - wall.Position;\n// wall.CornersVertices[3] = CornersVertices[3] + Position - wall.Position;\n}};/// <summary>\n/// 获取门窗2d平面下四个角的点\n/// </summary>\n/// <param name="doorOrWin"></param>\n/// <returns></returns>\nWall.prototype.getDoorOrWinRectPoints=function getDoorOrWinRectPoints(doorOrWin){var halfThick=this.thick/2;var dir_up=new THREE.Vector3();dir_up.crossVectors(this.vectorUp,this.direction);dir_up.normalize();var dir_down=dir_up.clone();dir_down.negate();var result=this.vectorUp.clone();result.multiplyScalar(halfThick);// halfThick * dir_up;\nvar size=doorOrWin.size;var wallDir=this.direction;var pos=doorOrWin.position;var halfSizeX=size.x/2;var start=new THREE.Vector3();var end=new THREE.Vector3();start.subVectors(pos,wallDir.clone().multiplyScalar(halfSizeX));end.addVectors(pos,wallDir.clone().multiplyScalar(halfSizeX));var startAndEndPos=[start.clone().addVectors(start,dir_up.clone().multiplyScalar(halfThick)),start.clone().addVectors(start,dir_down.clone().multiplyScalar(halfThick)),end.clone().addVectors(end,dir_down.clone().multiplyScalar(halfThick)),end.clone().addVectors(end,dir_up.clone().multiplyScalar(halfThick))];// Vector3 start = pos - wallDir * size.x / 2;\n// Vector3 end = pos + wallDir * size.x / 2;\n// Vector3[] startAndEndPos = new Vector3[]{\n// start+halfThick * dir_up,start+halfThick * dir_down,\n// end + halfThick * dir_down,end+halfThick * dir_up\nreturn startAndEndPos;};return Wall;}(BaseStraightManualWall$1);/**\r\n\t * @author pzx 2018.2.12\r\n\t * WallCorner\r\n\t */// import {ModelWall} from \'./ModelWall\';\nvar WallCorner$1=function(_BaseObject){inherits(WallCorner,_BaseObject);function WallCorner(x,y,z){classCallCheck(this,WallCorner);var _this=possibleConstructorReturn(this,_BaseObject.call(this));_this.walls=[];_this.position=new THREE.Vector3(x,y,z);return _this;}WallCorner.prototype.addWall=function addWall(wall){for(var i=0,len=this.walls.length;i<len;i++){if(this.walls[i]===wall){console.error("repeat wall"+wall);return;}}this.walls.push(wall);};WallCorner.prototype.build=function build(){this.calVertices();};WallCorner.prototype.isFirstWallShouldNotCal=function isFirstWallShouldNotCal(wall){return!(wall instanceof Wall$1)||wall instanceof SubStraightManualWall$1;};WallCorner.prototype.isSecondWallShouldNotCal=function isSecondWallShouldNotCal(wall){return wall!=null&&(wall.resource&&wall.resource.isModel||wall instanceof SubStraightManualWall$1);};WallCorner.prototype.calVertices=function calVertices(){var walls=this.walls;var upDir=new THREE.Vector3(0,-1,0);if(walls.length===1){var wall=walls[0];if(wall instanceof Wall$1)this.setDefaultCornerVertices(wall);}else{this.sortWalls();for(var i=0;i<walls.length;i++){var wall1=walls[i];// if (!(wall1 instanceof Wall))\nif(this.isFirstWallShouldNotCal(wall1))continue;var wall2=null;var j=i;while(wall2==null){if(j===walls.length-1){j=0;}else{j+=1;}if(walls[j]===wall1)break;wall2=walls[j];if(this.isSecondWallShouldNotCal(wall2))wall2=null;}if(!wall2){this.setDefaultCornerVertices(wall1);continue;}// if (!(wall2 instanceof Wall))\n//     continue;\nvar otherPoint=wall1.getWallOtherCorner(this).position;var firstDir=new THREE.Vector3();firstDir.subVectors(otherPoint,this.position);// otherPoint - this.position;\notherPoint=wall2.getWallOtherCorner(this).position;var secondDir=new THREE.Vector3();secondDir.subVectors(otherPoint,this.position);// otherPoint - this.position;\nfirstDir.normalize();secondDir.normalize();if(firstDir.length()===0||secondDir.length()===0){this.setDefaultCornerVertices(wall1,true);this.setDefaultCornerVertices(wall2,false);continue;}var halfThick=wall1.thick/2;var verticalDir1=new THREE.Vector3();verticalDir1.crossVectors(upDir,firstDir);// upDir.cross(firstDir);\nverticalDir1.normalize();var linePoint1=verticalDir1.clone();linePoint1.multiplyScalar(halfThick);linePoint1.add(this.position);// this.position + verticalDir1 * halfThick;\nhalfThick=wall2.thick/2;var verticalDir2=secondDir.clone();verticalDir2.cross(upDir);// secondDir.cross(upDir);\nverticalDir2.normalize();var linePoint2=verticalDir2.clone();linePoint2.multiplyScalar(halfThick);linePoint2.add(this.position);// this.position + verticalDir2 * halfThick;\nthis.setCornersVertices(wall1,linePoint1,true);this.setCornersVertices(wall2,linePoint2,false);firstDir.normalize();secondDir.normalize();var angle=this.calAngle(firstDir,secondDir);if(angle>30){var intersectPoint;if(Math.abs(firstDir.dot(secondDir))===1){var verticalDir=firstDir.clone();verticalDir.cross(upDir);// firstDir.cross(upDir);\nverticalDir.normalize();this.setDefaultCornerVertices(wall1,true);this.setDefaultCornerVertices(wall2,true);continue;}else{intersectPoint=this.getIntersectPosition(linePoint1,firstDir,linePoint2,secondDir);//计算交点\n}if(intersectPoint.x!==0||intersectPoint.y!==0||intersectPoint.z!==0){var point=intersectPoint.clone();point.y=this.position.y+this.getWallHeight();this.setCornersVertices(wall1,intersectPoint,true);this.setCornersVertices(wall2,intersectPoint,false);}}else{this.setCornersVertices(wall1,linePoint1,true);this.setCornersVertices(wall2,linePoint2,false);}}}};WallCorner.prototype.sortWalls=function sortWalls(){var walls=this.walls;if(walls.length>1){var standardWall=walls[0];var low=0;var high=walls.length-1;var tmp;var j;while(low<high){for(j=low;j<high;++j){//正 向冒泡,找到最大者\nif(this.angleBetween(standardWall,walls[j])>this.angleBetween(standardWall,walls[j+1])){tmp=walls[j];walls[j]=walls[j+1];walls[j+1]=tmp;}}--high;//修改high值, 前移一位\nfor(j=high;j>low;--j){//反向冒泡,找到最小者\nif(this.angleBetween(standardWall,walls[j])<this.angleBetween(standardWall,walls[j-1])){tmp=walls[j];walls[j]=walls[j-1];walls[j-1]=tmp;}}++low;//修改low值,后移一位\n}}};WallCorner.prototype.angleBetween=function angleBetween(wallA,wallB){var dir_1=wallA.getWallOtherCorner(this).position.clone();dir_1.sub(this.position);var dir_2=wallB.getWallOtherCorner(this).position.clone();dir_2.sub(this.position);return this.calAngle(dir_1,dir_2);};WallCorner.prototype.calAngle=function calAngle(fromDir,toDir){fromDir.normalize();toDir.normalize();var angle=fromDir.angleTo(toDir);angle*=180/Math.PI;var result=fromDir.clone();result.cross(toDir);if(result.y>0){angle=360-angle;}return angle;};WallCorner.prototype.getWallHeight=function getWallHeight(){var height=99999;for(var i=0;i<this.walls.length;i++){var wall=this.walls[i];if(height>wall.height){height=wall.height;}}return height;};WallCorner.prototype.setCornersVertices=function setCornersVertices(wall,pos,flag){var refPos=new THREE.Vector3(0,0,0);refPos.x=pos.x-wall.position.x;refPos.y=pos.y-wall.position.y;refPos.z=pos.z-wall.position.z;if(wall.startCorner===this){if(flag){wall.cornersVertices[0].x=refPos.x;wall.cornersVertices[0].y=refPos.y;wall.cornersVertices[0].z=refPos.z;}else{wall.cornersVertices[1].x=refPos.x;wall.cornersVertices[1].y=refPos.y;wall.cornersVertices[1].z=refPos.z;}}else{if(flag){wall.cornersVertices[2].x=refPos.x;wall.cornersVertices[2].y=refPos.y;wall.cornersVertices[2].z=refPos.z;}else{wall.cornersVertices[3].x=refPos.x;wall.cornersVertices[3].y=refPos.y;wall.cornersVertices[3].z=refPos.z;}}};WallCorner.prototype.setDefaultCornerVertices=function setDefaultCornerVertices(wall,flag){var upVector3=new THREE.Vector3(0,-1,0);//墙的另一个点\nvar otherPoint=wall.getWallOtherCorner(this).position;//以交点为起点，计算向量\n//Vector3 dir_1 = otherPoint - RelativePosition;\nvar dir_1=otherPoint.clone();dir_1.sub(this.position);dir_1.normalize();var halfThick=wall.thick/2;var verticalDir_1=upVector3.clone();verticalDir_1.cross(dir_1);verticalDir_1.normalize();verticalDir_1.multiplyScalar(halfThick);var linePoint_1=new THREE.Vector3();linePoint_1.addVectors(this.position,verticalDir_1);// this.position.add(verticalDir_1.multiplyScalar(halfThick));\nvar linePoint_2=new THREE.Vector3();linePoint_2.subVectors(this.position,verticalDir_1);//this.position.sub(verticalDir_1.multiplyScalar(halfThick));\nif(flag===undefined){this.setCornersVertices(wall,linePoint_1,true);this.setCornersVertices(wall,linePoint_2,false);}else{if(flag){this.setCornersVertices(wall,linePoint_1,true);}else{this.setCornersVertices(wall,linePoint_2,false);}}};WallCorner.prototype.getIntersectPosition=function getIntersectPosition(posA,dirA,posB,dirB){if(posA.x===posB.x&&posA.y===posB.y&&posA.z===posB.z){return posA;}var height=posA.y;if(dirA.dot(dirB)===1){throw"two line in same direction ,can not cal intersected position!";}var posC=new THREE.Vector3();var posD=new THREE.Vector3();posC.addVectors(posA,dirA);posD.addVectors(posB,dirB);var a=new THREE.Vector2(posA.x,posA.z);var b=new THREE.Vector2(posC.x,posC.z);var c=new THREE.Vector2(posB.x,posB.z);var d=new THREE.Vector2(posD.x,posD.z);var denominator=(b.y-a.y)*(d.x-c.x)-(a.x-b.x)*(c.y-d.y);if(denominator==0){//\t\t\tisIntersect = false;\nreturn new THREE.Vector3();}// 线段所在直线的交点坐标 (x , y)\nvar x=((b.x-a.x)*(d.x-c.x)*(c.y-a.y)+(b.y-a.y)*(d.x-c.x)*a.x-(d.y-c.y)*(b.x-a.x)*c.x)/denominator;var y=-((b.y-a.y)*(d.y-c.y)*(c.x-a.x)+(b.x-a.x)*(d.y-c.y)*a.y-(d.x-c.x)*(b.y-a.y)*c.y)/denominator;//\t\tisIntersect = true;\nreturn new THREE.Vector3(x,height,y);};return WallCorner;}(BaseObject$1);/**\r\n\t * @author pzx 2018.6.6\r\n\t * SubWallCorner\r\n\t */var SubWallCorner$1=function(_WallCorner){inherits(SubWallCorner,_WallCorner);function SubWallCorner(){classCallCheck(this,SubWallCorner);return possibleConstructorReturn(this,_WallCorner.call(this));}SubWallCorner.createSubWallCorner=function createSubWallCorner(id,pos,parentWall){var corner=new SubWallCorner();corner.id=id;corner.position=pos;corner.parent=parentWall.parent;// parentWall.subCorners.push(corner);\nreturn corner;};SubWallCorner.prototype.isFirstWallShouldNotCal=function isFirstWallShouldNotCal(wall){return!(wall instanceof SubStraightManualWall$1);};SubWallCorner.prototype.isSecondWallShouldNotCal=function isSecondWallShouldNotCal(wall){return wall&&!(wall instanceof SubStraightManualWall$1);};return SubWallCorner;}(WallCorner$1);/**\r\n\t * @author pzx 2018.6.6\r\n\t * SubStraightManualWall\r\n\t */var SubModelWall=function(_BaseWall){inherits(SubModelWall,_BaseWall);function SubModelWall(){classCallCheck(this,SubModelWall);var _this=possibleConstructorReturn(this,_BaseWall.call(this));_this.resource=null;_this.model=null;_this.objPositions=[];_this.objLocalPositions=[];_this.objRotations=[];_this.objScales=[];_this.modelSize=new THREE.Vector3();_this.box=new THREE.Box3();_this.heightRatio=1;_this.modelNumber=-1;_this.models=[];_this.mesh=new THREE.Object3D();_this.wallGroup=_this.mesh;_this.subWalls=[];_this.subCorners=[];return _this;}SubModelWall.prototype.build=function build(){this.baseBuild();if(this.resource){if(!this.resource.ready&&!DefaultSetting.enableCombine){this.resource.registerListener(this);}else{this.model=this.resource.model;}}if(this.model===null)return;this.calObjInfo();if(this.enableBuildMesh){this.instanceModels();}};SubModelWall.prototype.resourceCallback=function resourceCallback(resource){this.model=resource.model;this.calObjInfo();this.instanceModels();};SubModelWall.prototype.instanceModels=function instanceModels(){if(this.model===null)return;this.models=[];var objNum=this.modelNumber;for(var i=0;i<objNum;i++){var cloneModel=this.model.clone();var pos=this.objPositions[i];var rot=this.objRotations[i];var scale=this.objScales[i];cloneModel.position.set(pos.x,pos.y,pos.z);cloneModel.quaternion.set(rot.x,rot.y,rot.z,rot.w);cloneModel.scale.set(scale.x,scale.y,scale.z);this.mesh.add(cloneModel);this.models.push(cloneModel);}};SubModelWall.prototype.calObjInfo=function calObjInfo(){this.objPositions=[];this.objRotations=[];this.objScales=[];if(this.model===null){return;}this.box.makeEmpty();this.box=this.box.setFromObject(this.model);this.modelSize=this.box.getSize(new THREE.Vector3(0,0,0));// this.height = this.modelSize.y;\nif(this.height===-1){this.height=this.modelSize.y;}else{if(this.modelSize.y!==0){this.heightRatio=this.height/this.modelSize.y;}else{console.warn("model size is zero "+this.resource.id);this.height=3;}}var vectorUp=new THREE.Vector3(0,1,0);var modelLength=this.modelSize.x;var modelThick=this.modelSize.z;var modelHeight=this.modelSize.y;var fObjNumber=this.length/modelLength;var iObjNumber=parseInt(fObjNumber);var objNumber=Math.ceil(fObjNumber);this.modelNumber=objNumber;var needWallLen=objNumber*modelLength;var needEndCornerPosition=new THREE.Vector3();var wallDir=this.direction.clone();needEndCornerPosition.addVectors(this.startCorner.position,wallDir.multiplyScalar(needWallLen));var vecRight=new THREE.Vector3();vecRight.crossVectors(this.direction,vectorUp);vecRight.normalize();var wallRot=new THREE.Quaternion();if(vecRight.x!==0||vecRight.y!==0||vecRight.z!==0){//这点还存疑\nwallRot.setFromUnitVectors(new THREE.Vector3(0,0,1),vecRight);}var baseLen=modelLength*0.5;var basePos=new THREE.Vector3(baseLen,0,0);// basePos.multiplyVectors(wallRot,new THREE.Vector3(baseLen,0,0));\nvar wallPos=this.position;basePos.applyQuaternion(wallRot);for(var i=0;i<objNumber;i++){var percent=i/objNumber;//疑点，有可能不是浮点类型\nvar offsetPos=new THREE.Vector3();offsetPos.lerpVectors(this.startCorner.position,needEndCornerPosition,percent);var objPos=new THREE.Vector3();objPos.addVectors(basePos,offsetPos);this.objPositions.push(objPos);// this.objLocalPositions.push();\nthis.objRotations.push(wallRot);var scale=new THREE.Vector3(1,this.height/modelHeight,1);this.objScales.push(scale);}var theLastObjLen=(fObjNumber-iObjNumber)*modelLength;//存疑，有可能不是浮点\nvar theLastObjScale=theLastObjLen/modelLength;if(objNumber>0&&theLastObjLen>0){this.objScales[objNumber-1]=new THREE.Vector3(theLastObjScale,this.height/modelHeight,1);var halfModelLen=baseLen;var offset=new THREE.Vector3(-halfModelLen*(1-theLastObjScale),0,0);offset.applyQuaternion(wallRot);this.objPositions[objNumber-1].add(offset);// this.objLocalPositions[objNumber-1].subVectors(this.objPositions[objNumber-1],wallPos);\n}};return SubModelWall;}(BaseWall$1);/**\r\n\t * @author pzx 2018.5.31\r\n\t * BaseWall,墙的基类\r\n\t */var ModelWall=function(_BaseWall){inherits(ModelWall,_BaseWall);function ModelWall(){classCallCheck(this,ModelWall);var _this=possibleConstructorReturn(this,_BaseWall.call(this));_this.resource=null;_this.model=null;_this.objPositions=[];_this.objLocalPositions=[];_this.objRotations=[];_this.objScales=[];_this.modelSize=new THREE.Vector3();_this.box=new THREE.Box3();_this.heightRatio=1;_this.modelNumber=-1;_this.models=[];_this.mesh=new THREE.Object3D();_this.wallGroup=_this.mesh;_this.subWalls=[];_this.subCorners=[];return _this;}ModelWall.prototype.build=function build(){this.baseBuild();if(this.resource){if(!this.resource.ready&&!DefaultSetting.enableCombine){this.resource.registerListener(this);}else{this.model=this.resource.model;}}if(this.model===null&&DefaultSetting.enableCombine)return;this.calObjInfo();if(this.enableBuildMesh){this.instanceModels();}};ModelWall.prototype.resourceCallback=function resourceCallback(resource){this.model=resource.model;this.calObjInfo();this.instanceModels();};ModelWall.prototype.instanceModels=function instanceModels(){if(this.model===null)return;this.models=[];var objNum=this.modelNumber;for(var i=0;i<objNum;i++){var cloneModel=this.model.clone();var pos=this.objPositions[i];var rot=this.objRotations[i];var scale=this.objScales[i];cloneModel.position.set(pos.x,pos.y,pos.z);cloneModel.quaternion.set(rot.x,rot.y,rot.z,rot.w);cloneModel.scale.set(scale.x,scale.y,scale.z);this.mesh.add(cloneModel);this.models.push(cloneModel);}};ModelWall.prototype.calObjInfo=function calObjInfo(){this.objPositions=[];this.objRotations=[];this.objScales=[];if(this.model===null){return;}this.box.makeEmpty();this.box=this.box.setFromObject(this.model);this.modelSize=this.box.getSize(new THREE.Vector3(0,0,0));if(this.height===-1){this.height=this.modelSize.y;}else{if(this.modelSize.y!==0){this.heightRatio=this.height/this.modelSize.y;}else{console.warn("model size is zero "+this.resource.id);this.height=3;}}if(this.height===0){console.error("size is zero");return;}var vectorUp=new THREE.Vector3(0,1,0);var modelLength=this.modelSize.x;var modelThick=this.modelSize.z;var modelHeight=this.modelSize.y;var fObjNumber=this.length/modelLength;var iObjNumber=parseInt(fObjNumber);var objNumber=Math.ceil(fObjNumber);this.modelNumber=objNumber;var needWallLen=objNumber*modelLength;var needEndCornerPosition=new THREE.Vector3();var wallDir=this.direction.clone();needEndCornerPosition.addVectors(this.startCorner.position,wallDir.multiplyScalar(needWallLen));var vecRight=new THREE.Vector3();vecRight.crossVectors(this.direction,vectorUp);vecRight.normalize();var wallRot=new THREE.Quaternion();if(vecRight.x!==0||vecRight.y!==0||vecRight.z!==0){//这点还存疑\nwallRot.setFromUnitVectors(new THREE.Vector3(0,0,1),vecRight);}var baseLen=modelLength*0.5;var basePos=new THREE.Vector3(baseLen,0,0);// basePos.multiplyVectors(wallRot,new THREE.Vector3(baseLen,0,0));\nvar wallPos=this.position;basePos.applyQuaternion(wallRot);for(var i=0;i<objNumber;i++){var percent=i/objNumber;//疑点，有可能不是浮点类型\nvar offsetPos=new THREE.Vector3();offsetPos.lerpVectors(this.startCorner.position,needEndCornerPosition,percent);var objPos=new THREE.Vector3();objPos.addVectors(basePos,offsetPos);this.objPositions.push(objPos);// this.objLocalPositions.push();\nthis.objRotations.push(wallRot);var scale=new THREE.Vector3(1,this.height/modelHeight,1);this.objScales.push(scale);}var theLastObjLen=(fObjNumber-iObjNumber)*modelLength;//存疑，有可能不是浮点\nvar theLastObjScale=theLastObjLen/modelLength;if(objNumber>0&&theLastObjLen>0){this.objScales[objNumber-1]=new THREE.Vector3(theLastObjScale,this.height/modelHeight,1);var halfModelLen=baseLen;var offset=new THREE.Vector3(-halfModelLen*(1-theLastObjScale),0,0);offset.applyQuaternion(wallRot);this.objPositions[objNumber-1].add(offset);// this.objLocalPositions[objNumber-1].subVectors(this.objPositions[objNumber-1],wallPos);\n}};ModelWall.prototype.initSimpleCornersAndWalls=function initSimpleCornersAndWalls(){// var wallPos = this.position;\n// var lookRot = new THREE.Vector3();\n// lookRot.crossVectors(this.direction,this.vectorUp);\nvar list=this.sortDoorOrWins();// WallDecorateParam decorateParam = GetDecorateParam();\nfor(var i=0;i<list.length;i++){var master=list[i];// if (master.Size == Vector3.zero)\n//     continue;\n//master.Refresh();\nvar startAndEndPos=this.getDoorOrWinStartAndEndPos(master);// GetDoorOrWinStartAndEndPos(master);\nvar startCorner_DoorOrWin=SubWallCorner$1.createSubWallCorner(this.id+"_"+i+"_1",startAndEndPos[0],this);var endCorner_DoorOrWin=SubWallCorner$1.createSubWallCorner(this.id+"_"+i+"_2",startAndEndPos[1],this);// var startCorner_DoorOrWin = Core_WallCorner.CreateSubWallCorner(ID + "_" + i + "_1", startAndEndPos[0], startAndEndPos[2], this);\n// var endCorner_DoorOrWin = Core_WallCorner.CreateSubWallCorner(ID + "_" + i + "_2", startAndEndPos[1], startAndEndPos[3], this);\nthis.addSubWallCorner(startCorner_DoorOrWin);this.addSubWallCorner(endCorner_DoorOrWin);if(i===0){var wall1=new SubModelWall();// Core_SubStraightManualWall();\nwall1.resource=this.resource;this.subWalls.push(wall1);wall1.startCorner=this.startCorner;wall1.endCorner=startCorner_DoorOrWin;// wall1.SetWallDecorateParam(decorateParam);\nwall1.startCorner.build();wall1.endCorner.build();wall1.parentWall=this;wall1.height=this.height;}else{var lastDoorOrWin=list[i-1];var lastStartAndEndPos=this.getDoorOrWinStartAndEndPos(lastDoorOrWin);var lastEndCorner=this.getWallCornerByPos(lastStartAndEndPos[1]);var manulWall=new SubModelWall();manulWall.resource=this.resource;this.subWalls.push(manulWall);manulWall.startCorner=lastEndCorner;manulWall.endCorner=startCorner_DoorOrWin;manulWall.startCorner.build();manulWall.endCorner.build();manulWall.parentWall=this;manulWall.height=this.height;}if(i==list.length-1){var wall2=new SubModelWall();wall2.resource=this.resource;this.subWalls.push(wall2);wall2.startCorner=endCorner_DoorOrWin;wall2.endCorner=this.endCorner;wall2.startCorner.build();wall2.parentWall=this;wall2.height=this.height;}// this.buildHeadAndFootWall(master, startCorner_DoorOrWin, endCorner_DoorOrWin);\n}};ModelWall.prototype.buildSimpleCornersAndWalls=function buildSimpleCornersAndWalls(){this.wallGroup=new THREE.Object3D();for(var i=0;i<this.subCorners.length;i++){var subCorner=this.subCorners[i];subCorner.build();}for(var i=0;i<this.subWalls.length;i++){var subWall=this.subWalls[i];subWall.build();this.wallGroup.add(subWall.wallGroup);}};return ModelWall;}(BaseWall$1);/**\r\n\t * @author pzx 2018.6.5\r\n\t * PlacementGroup\r\n\t */var PlacementGroup=function(_BaseObject){inherits(PlacementGroup,_BaseObject);function PlacementGroup(){classCallCheck(this,PlacementGroup);var _this=possibleConstructorReturn(this,_BaseObject.call(this));_this.resource=null;_this.mesh=new THREE.Object3D();_this.groups=[];_this.placements=[];_this.delayObject=new THREE.Object3D();return _this;}PlacementGroup.prototype.build=function build(){for(var i=0;i<this.groups.length;i++){var group=this.groups[i];group.build();// if(this.enableBuildMesh){\nthis.mesh.add(group.mesh);// }\n}for(var i=0;i<this.placements.length;i++){var plc=this.placements[i];plc.build();// if(this.enableBuildMesh){\nthis.mesh.add(plc.delayObject);// }\n}// if(this.enableBuildMesh){\nthis.mesh.position.set(this.position.x,this.position.y,this.position.z);this.mesh.quaternion.set(this.rotation.x,this.rotation.y,this.rotation.z,this.rotation.w);this.mesh.scale.set(this.scale.x,this.scale.y,this.scale.z);this.delayObject=this.mesh;// }\n};return PlacementGroup;}(BaseObject);/**\r\n\t * CombineMeshProcessor\r\n\t * @author pzx\r\n\t * @ignore\r\n\t */var BaseCombineProcessor=function(){function BaseCombineProcessor(material,combineManager){classCallCheck(this,BaseCombineProcessor);this.vertexCount=0;this.indexCount=0;this.material=material;this.bundeMeshs=[];this.groups=[];//对应的mesh的相对仿射信息\nthis.transformations=[];this.maxCount=65534;this.combineMesh=null;this.combineManager=combineManager;// this.combineManager.processors.push(this);\n}BaseCombineProcessor.prototype.isExceed=function isExceed(num){var count=this.vertexCount+num;if(count>this.maxCount){return true;}else{return false;}};BaseCombineProcessor.prototype.build=function build(){var oneMaxArray=this.bundeMeshs;var idxCount=this.indexCount;// oneMaxArray.pop();\nvar count=this.vertexCount;//oneMaxArray.pop();\nvar sumPosArr=new Float32Array(count*3);var sumNormArr=new Float32Array(count*3);var sumUvArr=new Float32Array(count*2);var sumColorArr=new Float32Array(count*4);var sumUv2Arr=new Float32Array(count*2);var sumIdxArr=new Uint16Array(idxCount);var sumPosCursor=0;var sumNormCursor=0;var sumUvCursor=0;var sumIdxCursor=0;var sumColorCursor=0;var combineGeometry=new THREE.BufferGeometry();for(var j=0;j<oneMaxArray.length;j++){var obj=oneMaxArray[j];var transformation=this.transformations[j];var localPositions=transformation.positions;var localScales=transformation.scales;var localRots=transformation.quaternions;var idxAttArr=obj.indexArray;// obj.geometry.index.array;\nfor(var b=0;b<idxAttArr.length;b++){sumIdxArr[b+sumIdxCursor]=sumPosCursor/3+idxAttArr[b];}sumIdxCursor+=idxAttArr.length;var posAttArr=obj.positionArray;// obj.geometry.getAttribute(\'position\').array;\nfor(var b=0;b<posAttArr.length;){var vec=new THREE.Vector3(posAttArr[b],posAttArr[b+1],posAttArr[b+2]);for(var i=localPositions.length-1;i>-1;i--){var pos=localPositions[i];var scale=localScales[i];var rot=localRots[i];vec.x*=scale.x;vec.y*=scale.y;vec.z*=scale.z;vec=vec.applyQuaternion(rot);vec.x+=pos.x;vec.y+=pos.y;vec.z+=pos.z;}sumPosArr[b+sumPosCursor]=vec.x;sumPosArr[b+sumPosCursor+1]=vec.y;sumPosArr[b+sumPosCursor+2]=vec.z;b+=3;}sumPosCursor+=posAttArr.length;var numAttArr=obj.normalArray;// obj.geometry.getAttribute(\'normal\').array;\n// for (var b = 0; b < numAttArr.length; b++) {\n//     sumNormArr[b + sumNormCursor] = numAttArr[b];\n// }\nfor(var b=0;b<numAttArr.length;){// var vec = new THREE.Vector3(posAttArr[b], posAttArr[b + 1], posAttArr[b + 2]);\nvar normal=new THREE.Vector3(numAttArr[b],numAttArr[b+1],numAttArr[b+2]);for(var i=localRots.length-1;i>-1;i--){// var pos = localPositions[i];\n// var scale = localScales[i];\nvar rot=localRots[i];normal=normal.applyQuaternion(rot);}sumNormArr[b+sumNormCursor]=normal.x;sumNormArr[b+sumNormCursor+1]=normal.y;sumNormArr[b+sumNormCursor+2]=normal.z;b+=3;}sumNormCursor+=numAttArr.length;var uvAttArr=obj.uvArray;// obj.geometry.getAttribute(\'uv\').array;\nif(uvAttArr){for(var b=0;b<uvAttArr.length;b++){sumUvArr[b+sumUvCursor]=uvAttArr[b];}}var uv2AttrArr=obj.uv2Array;if(uv2AttrArr){for(var b=0;b<uv2AttrArr.length;b++){sumUv2Arr[b+sumUvCursor]=uv2AttrArr[b];}}if(uvAttArr){sumUvCursor+=uvAttArr.length;}var colorAttrArr=obj.colorArray;if(colorAttrArr){for(var b=0;b<colorAttrArr.length;b++){sumColorArr[b+sumColorCursor]=colorAttrArr[b];}sumColorCursor+=colorAttrArr.length;}}combineGeometry.addAttribute(\'position\',new THREE.BufferAttribute(sumPosArr,3));combineGeometry.addAttribute(\'normal\',new THREE.BufferAttribute(sumNormArr,3));combineGeometry.addAttribute(\'uv\',new THREE.BufferAttribute(sumUvArr,2));if(sumUv2Arr.length!==0){combineGeometry.addAttribute(\'uv2\',new THREE.BufferAttribute(sumUv2Arr,2));}if(sumColorArr.length!==0){combineGeometry.addAttribute("color",new THREE.BufferAttribute(sumColorArr,4));}combineGeometry.setIndex(new THREE.BufferAttribute(sumIdxArr,1));var combineMesh=new THREE.Mesh(combineGeometry,this.material);if(this.material.defines){if(this.material.defines["USE_ALPHAINDEX"]){delete this.material.defines["USE_ALPHAINDEX"];}}combineMesh.name="combine";this.combineMesh=combineMesh;// combineNodes.push(combineMesh);\n};return BaseCombineProcessor;}();/**\r\n\t * CombineMeshProcessor\r\n\t * @author pzx\r\n\t * @ignore\r\n\t */var CombineMeshProcessor$1=function(_BaseCombineProcessor){inherits(CombineMeshProcessor,_BaseCombineProcessor);function CombineMeshProcessor(material,manager){classCallCheck(this,CombineMeshProcessor);return possibleConstructorReturn(this,_BaseCombineProcessor.call(this,material,manager));}CombineMeshProcessor.prototype.add=function add(bundleMesh,transformation){var allCount=0;// for(var i = 0;i<bundleMeshs.length;i++){\n//     allCount+=bundleMeshs[i].vertexCount;\n// }\nif(this.isExceed(bundleMesh.vertexCount)){console.error("combine exceed vertex count ");return false;}// for(var i = 0;i<bundleMeshs.length;i++){\n//     var bundleMesh=bundleMeshs[i];\nthis.vertexCount+=bundleMesh.vertexCount;this.indexCount+=bundleMesh.indexCount;this.bundeMeshs.push(bundleMesh);this.transformations.push(transformation);// }\n};CombineMeshProcessor.prototype.cloneGroups=function cloneGroups(groups){var newGroups=[];for(var i=0;i<groups.length;i++){var item=groups[i];newGroups.push(Util.cloneJSObject(item));}return newGroups;};CombineMeshProcessor.prototype.build=function build(){var oneMaxArray=this.bundeMeshs;var idxCount=this.indexCount;// oneMaxArray.pop();\nvar count=this.vertexCount;//oneMaxArray.pop();\nvar groups=[];var sumPosArr=new Float32Array(count*3);var sumNormArr=new Float32Array(count*3);var sumUvArr=new Float32Array(count*2);var sumColorArr=new Float32Array(count*4);var sumAlphaArr=new Float32Array(count*1);var sumUv2Arr=new Float32Array(count*2);var sumUv3Arr=new Float32Array(count*2);var sumIdxArr=new Uint16Array(idxCount);var sumPosCursor=0;var sumNormCursor=0;var sumUvCursor=0;var sumIdxCursor=0;var sumColorCursor=0;var sumAlphaCursor=0;var combineGeometry=new THREE.BufferGeometry();var offset=0;for(var j=0;j<oneMaxArray.length;j++){var obj=oneMaxArray[j];var transformation=this.transformations[j];var localPositions=transformation.positions;var localScales=transformation.scales;var localRots=transformation.quaternions;var idxAttArr=obj.indexArray;// obj.geometry.index.array;\nif(obj.groups.length>0){var geoGroups=this.cloneGroups(obj.groups);geoGroups.forEach(function(item){item.start+=offset;});groups=groups.concat(geoGroups);}offset+=idxAttArr.length;for(var b=0;b<idxAttArr.length;b++){sumIdxArr[b+sumIdxCursor]=sumPosCursor/3+idxAttArr[b];}sumIdxCursor+=idxAttArr.length;var posAttArr=obj.positionArray;// obj.geometry.getAttribute(\'position\').array;\nfor(var b=0;b<posAttArr.length;){var vec=new THREE.Vector3(posAttArr[b],posAttArr[b+1],posAttArr[b+2]);for(var i=localPositions.length-1;i>-1;i--){var pos=localPositions[i];var scale=localScales[i];var rot=localRots[i];vec.x*=scale.x;vec.y*=scale.y;vec.z*=scale.z;vec=vec.applyQuaternion(rot);vec.x+=pos.x;vec.y+=pos.y;vec.z+=pos.z;}sumPosArr[b+sumPosCursor]=vec.x;sumPosArr[b+sumPosCursor+1]=vec.y;sumPosArr[b+sumPosCursor+2]=vec.z;b+=3;}sumPosCursor+=posAttArr.length;var numAttArr=obj.normalArray;// obj.geometry.getAttribute(\'normal\').array;\n// for (var b = 0; b < numAttArr.length; b++) {\n//     sumNormArr[b + sumNormCursor] = numAttArr[b];\n// }\nfor(var b=0;b<numAttArr.length;){// var vec = new THREE.Vector3(posAttArr[b], posAttArr[b + 1], posAttArr[b + 2]);\nvar normal=new THREE.Vector3(numAttArr[b],numAttArr[b+1],numAttArr[b+2]);for(var i=localRots.length-1;i>-1;i--){// var pos = localPositions[i];\n// var scale = localScales[i];\nvar rot=localRots[i];normal=normal.applyQuaternion(rot);}sumNormArr[b+sumNormCursor]=normal.x;sumNormArr[b+sumNormCursor+1]=normal.y;sumNormArr[b+sumNormCursor+2]=normal.z;b+=3;}sumNormCursor+=numAttArr.length;var uvAttArr=obj.uvArray;// obj.geometry.getAttribute(\'uv\').array;\nif(uvAttArr){for(var b=0;b<uvAttArr.length;b++){sumUvArr[b+sumUvCursor]=uvAttArr[b];}}var uv2AttrArr=obj.uv2Array;if(uv2AttrArr){for(var b=0;b<uv2AttrArr.length;b++){sumUv2Arr[b+sumUvCursor]=uv2AttrArr[b];}}var uv3AttrArr=obj.uv3Array;if(uv3AttrArr){for(var b=0;b<uv3AttrArr.length;b++){sumUv3Arr[b+sumUvCursor]=uv3AttrArr[b];}}if(uvAttArr){sumUvCursor+=uvAttArr.length;}var colorAttrArr=obj.colorArray;if(colorAttrArr){for(var b=0;b<colorAttrArr.length;b++){sumColorArr[b+sumColorCursor]=colorAttrArr[b];}sumColorCursor+=colorAttrArr.length;for(var b=3;b<colorAttrArr.length;b+=4){sumAlphaArr[(b-3)/4+sumAlphaCursor]=colorAttrArr[b];}sumAlphaCursor+=colorAttrArr.length/4;}}combineGeometry.addAttribute(\'position\',new THREE.BufferAttribute(sumPosArr,3));combineGeometry.addAttribute(\'normal\',new THREE.BufferAttribute(sumNormArr,3));combineGeometry.addAttribute(\'uv\',new THREE.BufferAttribute(sumUvArr,2));if(sumUv2Arr.length!==0){combineGeometry.addAttribute(\'uv2\',new THREE.BufferAttribute(sumUv2Arr,2));}if(sumUv3Arr.length!==0){combineGeometry.addAttribute(\'uv3\',new THREE.BufferAttribute(sumUv3Arr,2));}if(sumColorArr.length!==0){combineGeometry.addAttribute("color",new THREE.BufferAttribute(sumColorArr,4));}if(sumAlphaArr.length!==0){combineGeometry.addAttribute("alphaIndex",new THREE.BufferAttribute(sumAlphaArr,1));}combineGeometry.setIndex(new THREE.BufferAttribute(sumIdxArr,1));combineGeometry.groups=groups;var combineMesh=new THREE.Mesh(combineGeometry,this.material);// if (this.material.defines) {\n//     if (this.material.defines["USE_ALPHAINDEX"]) {\n//         delete this.material.defines["USE_ALPHAINDEX"];\n//     }\n// }\ncombineMesh.name="combine";this.combineMesh=combineMesh;this.combineMesh.name="mesh";// combineNodes.push(combineMesh);\n};return CombineMeshProcessor;}(BaseCombineProcessor);/**\r\n\t * Transformation\r\n\t * @author pzx\r\n\t * @ignore\r\n\t*/var Transformation=function(){function Transformation(){classCallCheck(this,Transformation);this.positions=[];this.scales=[];this.quaternions=[];}Transformation.prototype.clone=function clone(){var t=new Transformation();t.positions=this.positions.slice();t.scales=this.scales.slice();t.quaternions=this.quaternions.slice();return t;};return Transformation;}();/**\r\n\t * CombineMeshProcessor\r\n\t * @author pzx\r\n\t * @ignore\r\n\t */var CombineStraightManualWallProcessor=function(_BaseCombineProcessor){inherits(CombineStraightManualWallProcessor,_BaseCombineProcessor);function CombineStraightManualWallProcessor(material,combineManager){classCallCheck(this,CombineStraightManualWallProcessor);//mesh的相关信息，但不是mesh对象\nvar _this=possibleConstructorReturn(this,_BaseCombineProcessor.call(this,material,combineManager));_this.meshInfos=[];return _this;}CombineStraightManualWallProcessor.prototype.add=function add(meshInfo){if(this.isExceed(meshInfo.indexArray.length)){console.error("combine exceed vertex count ");return false;}this.vertexCount+=meshInfo.indexArray.length;this.indexCount+=meshInfo.indexArray.length;this.meshInfos.push(meshInfo);};CombineStraightManualWallProcessor.prototype.build=function build(){var oneMaxArray=this.meshInfos;var idxCount=this.indexCount;// oneMaxArray.pop();\nvar count=this.vertexCount;//oneMaxArray.pop();\nvar sumPosArr=new Float32Array(count*3);var sumNormArr=new Float32Array(count*3);var sumUvArr=new Float32Array(count*2);var sumColorArr=new Float32Array(count*4);var sumUv2Arr=new Float32Array(count*2);var sumIdxArr=new Uint16Array(idxCount);var sumPosCursor=0;var sumNormCursor=0;var sumUvCursor=0;var sumIdxCursor=0;var sumColorCursor=0;var combineGeometry=new THREE.BufferGeometry();for(var j=0;j<oneMaxArray.length;j++){var meshInfo=oneMaxArray[j];var parentPos=meshInfo.parentPosition;var idxAttArr=meshInfo.indexArray;// obj.geometry.index.array;\nfor(var b=0;b<idxAttArr.length;b++){sumIdxArr[b+sumIdxCursor]=sumPosCursor/3+idxAttArr[b];}sumIdxCursor+=idxAttArr.length;var posAttArr=meshInfo.positionArray;// obj.geometry.getAttribute(\'position\').array;\nfor(var b=0;b<posAttArr.length;){var vec=new THREE.Vector3(posAttArr[b]+parentPos.x,posAttArr[b+1]+parentPos.y,posAttArr[b+2]+parentPos.z);sumPosArr[b+sumPosCursor]=vec.x;sumPosArr[b+sumPosCursor+1]=vec.y;sumPosArr[b+sumPosCursor+2]=vec.z;b+=3;}sumPosCursor+=posAttArr.length;var numAttArr=meshInfo.normalArray;// obj.geometry.getAttribute(\'normal\').array;\n// for (var b = 0; b < numAttArr.length; b++) {\n//     sumNormArr[b + sumNormCursor] = numAttArr[b];\n// }\nfor(var b=0;b<numAttArr.length;){// var vec = new THREE.Vector3(posAttArr[b], posAttArr[b + 1], posAttArr[b + 2]);\nvar normal=new THREE.Vector3(numAttArr[b],numAttArr[b+1],numAttArr[b+2]);// for(var i = localRots.length-1;i>-1;i--){\n//     // var pos = localPositions[i];\n//     // var scale = localScales[i];\n//     var rot = localRots[i];\n//     normal = normal.applyQuaternion(rot);\n// }\nsumNormArr[b+sumNormCursor]=normal.x;sumNormArr[b+sumNormCursor+1]=normal.y;sumNormArr[b+sumNormCursor+2]=normal.z;b+=3;}sumNormCursor+=numAttArr.length;var uvAttArr=meshInfo.uvArray;// obj.geometry.getAttribute(\'uv\').array;\nif(uvAttArr){for(var b=0;b<uvAttArr.length;b++){sumUvArr[b+sumUvCursor]=uvAttArr[b];}}var uv2AttrArr=meshInfo.uv2Array;if(uv2AttrArr){for(var b=0;b<uv2AttrArr.length;b++){sumUv2Arr[b+sumUvCursor]=uv2AttrArr[b];}}if(uvAttArr){sumUvCursor+=uvAttArr.length;}var colorAttrArr=meshInfo.colorArray;if(colorAttrArr){for(var b=0;b<colorAttrArr.length;b++){sumColorArr[b+sumColorCursor]=colorAttrArr[b];}sumColorCursor+=colorAttrArr.length;}}combineGeometry.addAttribute(\'position\',new THREE.BufferAttribute(sumPosArr,3));combineGeometry.addAttribute(\'normal\',new THREE.BufferAttribute(sumNormArr,3));combineGeometry.addAttribute(\'uv\',new THREE.BufferAttribute(sumUvArr,2));if(sumUv2Arr.length!==0){combineGeometry.addAttribute(\'uv2\',new THREE.BufferAttribute(sumUv2Arr,2));}if(sumColorArr.length!==0){combineGeometry.addAttribute("color",new THREE.BufferAttribute(sumColorArr,4));}combineGeometry.setIndex(new THREE.BufferAttribute(sumIdxArr,1));var combineMesh=new THREE.Mesh(combineGeometry,this.material);if(this.material.defines){if(this.material.defines["USE_ALPHAINDEX"]){delete this.material.defines["USE_ALPHAINDEX"];}}combineMesh.name="combine";this.combineMesh=combineMesh;// combineNodes.push(combineMesh);\nthis.combineMesh.name="manualWall";};return CombineStraightManualWallProcessor;}(BaseCombineProcessor);/**\r\n\t * CombineMeshProcessor\r\n\t * @author pzx\r\n\t * @ignore\r\n\t */var CombineFloorProcessor=function(_BaseCombineProcessor){inherits(CombineFloorProcessor,_BaseCombineProcessor);function CombineFloorProcessor(material,combineManager){classCallCheck(this,CombineFloorProcessor);//mesh的相关信息，但不是mesh对象\nvar _this=possibleConstructorReturn(this,_BaseCombineProcessor.call(this,material,combineManager));_this.meshInfos=[];_this.geometrys=[];return _this;}CombineFloorProcessor.prototype.add=function add(geometry){this.geometrys.push(geometry);};CombineFloorProcessor.prototype.build=function build(){var combineGeometry=new THREE.Geometry();for(var i=0;i<this.geometrys.length;i++){var geometry=this.geometrys[i];combineGeometry.merge(geometry);}var combineMesh=new THREE.Mesh(combineGeometry,this.material);if(this.material.defines){if(this.material.defines["USE_ALPHAINDEX"]){delete this.material.defines["USE_ALPHAINDEX"];}}combineMesh.name="combine";combineMesh.rotateX(-Math.PI/2);combineMesh.position.y=0.1;this.combineMesh=combineMesh;this.combineMesh.name="floor";};return CombineFloorProcessor;}(BaseCombineProcessor);/**\r\n\t * CombineMeshProcessor\r\n\t * @author pzx\r\n\t * @ignore\r\n\t */var CombineCeilingProcessor=function(_BaseCombineProcessor){inherits(CombineCeilingProcessor,_BaseCombineProcessor);function CombineCeilingProcessor(material,combineManager){classCallCheck(this,CombineCeilingProcessor);//mesh的相关信息，但不是mesh对象\nvar _this=possibleConstructorReturn(this,_BaseCombineProcessor.call(this,material,combineManager));_this.meshInfos=[];_this.geometrys=[];_this.height=3;return _this;}CombineCeilingProcessor.prototype.add=function add(geometry){this.geometrys.push(geometry);};CombineCeilingProcessor.prototype.build=function build(){var combineGeometry=new THREE.Geometry();for(var i=0;i<this.geometrys.length;i++){var geometry=this.geometrys[i];combineGeometry.merge(geometry);}var combineMesh=new THREE.Mesh(combineGeometry,this.material);if(this.material.defines){if(this.material.defines["USE_ALPHAINDEX"]){delete this.material.defines["USE_ALPHAINDEX"];}}combineMesh.name="combine";combineMesh.rotateX(Math.PI/2);combineMesh.position.y=this.height;this.combineMesh=combineMesh;this.combineMesh.name="ceiling";};return CombineCeilingProcessor;}(BaseCombineProcessor);/**\r\n\t * CombineMeshProcessor\r\n\t * @author pzx\r\n\t * @ignore\r\n\t */var CombineRoofProcessor=function(_BaseCombineProcessor){inherits(CombineRoofProcessor,_BaseCombineProcessor);function CombineRoofProcessor(material,combineManager){classCallCheck(this,CombineRoofProcessor);//mesh的相关信息，但不是mesh对象\nvar _this=possibleConstructorReturn(this,_BaseCombineProcessor.call(this,material,combineManager));_this.meshInfos=[];_this.geometrys=[];return _this;}CombineRoofProcessor.prototype.add=function add(geometry){this.geometrys.push(geometry);};CombineRoofProcessor.prototype.build=function build(){var combineGeometry=new THREE.Geometry();for(var i=0;i<this.geometrys.length;i++){var geometry=this.geometrys[i];combineGeometry.merge(geometry);}var combineMesh=new THREE.Mesh(combineGeometry,this.material);if(this.material.defines){if(this.material.defines["USE_ALPHAINDEX"]){delete this.material.defines["USE_ALPHAINDEX"];}}combineMesh.name="combine";combineMesh.rotateX(-Math.PI/2);combineMesh.position.y=3.1;this.combineMesh=combineMesh;this.combineMesh.name="roof";};return CombineRoofProcessor;}(BaseCombineProcessor);/**\r\n\t * CombineManager\r\n\t * @author pzx\r\n\t * @ignore\r\n\t */var CombineManager=function(){function CombineManager(resourceManager){classCallCheck(this,CombineManager);this.resourceManager=resourceManager;this.combineBundleObjectMap={};this.processors=[];}CombineManager.prototype.combineModels=function combineModels(){var modelMap=this.resourceManager.models;var results=[];var that=this;var maxTime=0.1;var waitTime=10;for(var key in modelMap){results.push(new Promise(function(resolve,reject){var loadStartTime=performance.now();var resource=modelMap[key];var combineBundleObj=new CombineBundleObject$1(resource.model);that.combineBundleObjectMap[resource.id]=combineBundleObj;combineBundleObj.combine();var elapseTime=performance.now()-loadStartTime;// console.log(elapseTime+"==========");\nif(elapseTime>maxTime){setTimeout(function(){// console.log("combine");\nresolve();},waitTime);}else{resolve();}// resolve();\n}));}return Promise.all(results);};CombineManager.prototype.getModelObject=function getModelObject(bundleId){var combineBundleObj=this.combineBundleObjectMap[bundleId];if(combineBundleObj){return combineBundleObj;}else{return null;}};CombineManager.prototype.addGroup=function addGroup(group,plan,transformation){var map=plan.curPlacementCombineProcessorMap;// this.floorMaterialMap.get(floor);\nvar list=plan.placementCombineProcessors;if(!transformation){transformation=new Transformation();// transformation.positions.push(plan.worldPosition);\n// transformation.scales.push(plan.scale);\n// transformation.quaternions.push(plan.rotation);\n}transformation.positions.push(group.position);transformation.scales.push(group.scale);transformation.quaternions.push(group.rotation);for(var i=0;i<group.placements.length;i++){var plc=group.placements[i];if(plc.isShow){this.addPlacement(plc,plan,transformation.clone());}}for(var i=0;i<group.groups.length;i++){var childGroup=group.groups[i];if(childGroup.isShow){this.addGroup(childGroup,plan,transformation.clone());}}};CombineManager.prototype.addDoorOrWindow=function addDoorOrWindow(doorOrWin,plan,transformation){var map=plan.curDoorOrWinCombineProcessorMap;// this.floorMaterialMap.get(floor);\nvar list=plan.doorOrWindowCombineProcessors;if(!transformation){transformation=new Transformation();}transformation.positions.push(doorOrWin.position);transformation.scales.push(doorOrWin.scale);transformation.quaternions.push(doorOrWin.rotation);//获取合并过的bundle对象\nvar combineBundleObj=this.combineBundleObjectMap[doorOrWin.resource.id];//获取bundle合并过的mesh的map\nvar bundleMaterialMap=combineBundleObj.materialMap;//遍历材质的map，根据mesh的顶点数，创建或者添加到processor\nbundleMaterialMap.forEach(function(value,key,orgMap){var combineMeshList=value;var material=key;for(var i=0;i<combineMeshList.length;i++){var combineMesh=combineMeshList[i];var processor=map.get(material);//如果没有，或者超过顶点数\nif(!processor||processor.isExceed(combineMesh.vertexCount)){processor=new CombineMeshProcessor$1(material,this);map.set(material,processor);list.push(processor);}processor.add(combineMesh,transformation);}});};CombineManager.prototype.addPlacement=function addPlacement(placement,plan,transformation){var map=plan.curPlacementCombineProcessorMap;// this.floorMaterialMap.get(floor);\nvar list=plan.placementCombineProcessors;if(!transformation){transformation=new Transformation();// transformation.positions.push(plan.worldPosition);\n// transformation.scales.push(plan.scale);\n// transformation.quaternions.push(plan.rotation);\n}transformation.positions.push(placement.position);transformation.scales.push(placement.scale);transformation.quaternions.push(placement.rotation);//获取合并过的bundle对象\nvar combineBundleObj=this.combineBundleObjectMap[placement.resource.id];//获取bundle合并过的mesh的map\nvar bundleMaterialMap=combineBundleObj.materialMap;//遍历材质的map，根据mesh的顶点数，创建或者添加到processor\nbundleMaterialMap.forEach(function(value,key,orgMap){var combineMeshList=value;var material=key;for(var i=0;i<combineMeshList.length;i++){var combineMesh=combineMeshList[i];var processor=map.get(material);//如果没有，或者超过顶点数\nif(!processor||processor.isExceed(combineMesh.vertexCount)){processor=new CombineMeshProcessor$1(material,this);map.set(material,processor);list.push(processor);}processor.add(combineMesh,transformation);}});};CombineManager.prototype.addStraightManualWall=function addStraightManualWall(wall,plan){var map=plan.curStraightManualWallCombineProcessorMap;var list=plan.straightManualWallCombineProcessors;wall.build();var rightMeshInfo=wall.rightSideMeshInfo;var leftMeshInfo=wall.leftSideMeshInfo;var edgeMeshInfo=wall.edgeSideMeshInfo;this.addWallMeshInfo(rightMeshInfo,wall.position,map,list);this.addWallMeshInfo(leftMeshInfo,wall.position,map,list);this.addWallMeshInfo(edgeMeshInfo,wall.position,map,list);};CombineManager.prototype.addModelWall=function addModelWall(wall,plan){var map=plan.curModelWallCombineProcessorMap;// this.floorMaterialMap.get(floor);\nvar list=plan.modelWallCombineProcessors;var combineBundleObj=this.combineBundleObjectMap[wall.resource.id];for(var i=0;i<wall.modelNumber;i++){var pos=wall.objPositions[i];var rot=wall.objRotations[i];var scale=wall.objScales[i];var transformation=new Transformation();transformation.positions.push(pos);transformation.scales.push(scale);transformation.quaternions.push(rot);var bundleMaterialMap=combineBundleObj.materialMap;//遍历材质的map，根据mesh的顶点数，创建或者添加到processor\nbundleMaterialMap.forEach(function(value,key,orgMap){var combineMeshList=value;var material=key;for(var i=0;i<combineMeshList.length;i++){var combineMesh=combineMeshList[i];var processor=map.get(material);//如果没有，或者超过顶点数\nif(!processor||processor.isExceed(combineMesh.vertexCount)){processor=new CombineMeshProcessor$1(material,this);map.set(material,processor);list.push(processor);}processor.add(combineMesh,transformation);}});}//获取合并过的bundle对象\n// var combineBundleObj = this.combineBundleObjectMap[placement.resource.id];\n//获取bundle合并过的mesh的map\n};CombineManager.prototype.addRoom=function addRoom(room,plan){this.addRoomShapeGeometry(room.floor.material,room.floor.geometry,plan.height,CombineFloorProcessor,plan.curFloorCombineProcessorMap,plan.floorCombineProcessors);if(!room.isOnlyFloor){this.addRoomShapeGeometry(room.ceiling.material,room.ceiling.geometry,plan.height,CombineCeilingProcessor,plan.curCeilingCombineProcessorMap,plan.ceilingCombineProcessors);this.addRoomShapeGeometry(room.roof.material,room.roof.geometry,plan.height,CombineRoofProcessor,plan.curRoofCombineProcessorMap,plan.roofCombineProcessors);}};CombineManager.prototype.addWallMeshInfo=function addWallMeshInfo(meshInfo,position,curProcessorMap,processors){var mat=meshInfo.material;meshInfo.parentPosition=position;var processor=curProcessorMap.get(mat);if(!processor){processor=new CombineStraightManualWallProcessor(mat,this);processor.height=processors.push(processor);curProcessorMap.set(mat,processor);}processor.add(meshInfo);};CombineManager.prototype.addRoomShapeGeometry=function addRoomShapeGeometry(material,geometry,height,classProcssor,curProcessorMap,processors){var mat=material;// meshInfo.parentPosition = position;\nvar processor=curProcessorMap.get(mat);if(!processor){processor=new classProcssor(mat,this);processors.push(processor);processor.height=height;curProcessorMap.set(mat,processor);}processor.add(geometry);};//启用的方法，只是给0.0版本用\nCombineManager.prototype.getCombineProcessors=function getCombineProcessors(dataJson,posArray,scaleArray,rotArray){var list=[];var map=new Map();for(var t in dataJson){var data=dataJson[t];if(data["uid"]){continue;}if(data["name"]){continue;}var bundleID=this.app.modelResource.bundleIDArray[data["bIdx"]];var bundle=this.app.modelResource.get(bundleID).node;var pos=new THREE.Vector3(0,0,0);var transformation=new Transformation();if(data["pos"]){var posStrArray=data["pos"].split(" ");// var pos = new THREE.Vector3();\npos.x=parseFloat(posStrArray[0]);pos.y=parseFloat(posStrArray[1]);pos.z=-parseFloat(posStrArray[2]);// transformation.position = pos;\n}var scale=new THREE.Vector3(1,1,1);if(data["scl"]){var sclStrArray=data["scl"].split(" ");// var pos = new THREE.Vector3();\nscale.x=parseFloat(sclStrArray[0]);scale.y=parseFloat(sclStrArray[1]);scale.z=parseFloat(sclStrArray[2]);// transformation.scale = scale;\n}var quaternion=new THREE.Quaternion(0,0,0,1);if(data["rot"]){var rotStrArray=data["rot"].split(" ");// var pos = new THREE.Vector3();\nquaternion.x=parseFloat(rotStrArray[0]);quaternion.y=parseFloat(rotStrArray[1]);quaternion.z=-parseFloat(rotStrArray[2]);quaternion.w=-parseFloat(rotStrArray[3]);// transformation.quaternion = quaternion;\n}var localPosArray=posArray.slice();var localScaleArray=scaleArray.slice();var localRotArray=rotArray.slice();localRotArray.push(quaternion);localScaleArray.push(scale);localPosArray.push(pos);transformation.positions=localPosArray;transformation.scales=localScaleArray;transformation.quaternions=localRotArray;//获取合并过的bundle对象\nvar combineBundleObj=this.combineBundleObjectMap[bundleID];//获取bundle合并过的mesh的map\nvar bundleMaterialMap=combineBundleObj.materialMap;//遍历材质的map，根据mesh的顶点数，创建或者添加到processor\nbundleMaterialMap.forEach(function(value,key,orgMap){var combineMeshList=value;var material=key;for(var i=0;i<combineMeshList.length;i++){var combineMesh=combineMeshList[i];var processor=map.get(material);//如果没有，或者超过顶点数\nif(!processor||processor.isExceed(combineMesh.vertexCount)){processor=new CombineMeshProcessor$1(material);map.set(material,processor);list.push(processor);}processor.add(combineMesh,transformation);}});}return list;};return CombineManager;}();var runtime$2=createCommonjsModule(function(module){/**\r\n\t * Copyright (c) 2014-present, Facebook, Inc.\r\n\t *\r\n\t * This source code is licensed under the MIT license found in the\r\n\t * LICENSE file in the root directory of this source tree.\r\n\t */!function(global){"use strict";var Op=Object.prototype;var hasOwn=Op.hasOwnProperty;var undefined;// More compressible than void 0.\nvar $Symbol=typeof Symbol==="function"?Symbol:{};var iteratorSymbol=$Symbol.iterator||"@@iterator";var asyncIteratorSymbol=$Symbol.asyncIterator||"@@asyncIterator";var toStringTagSymbol=$Symbol.toStringTag||"@@toStringTag";var inModule=\'object\'==="object";var runtime=global.regeneratorRuntime;if(runtime){if(inModule){// If regeneratorRuntime is defined globally and we\'re in a module,\n// make the exports object identical to regeneratorRuntime.\nmodule.exports=runtime;}// Don\'t bother evaluating the rest of this file if the runtime was\n// already defined globally.\nreturn;}// Define the runtime globally (as expected by generated code) as either\n// module.exports (if we\'re in a module) or a new, empty object.\nruntime=global.regeneratorRuntime=inModule?module.exports:{};function wrap(innerFn,outerFn,self,tryLocsList){// If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\nvar protoGenerator=outerFn&&outerFn.prototype instanceof Generator?outerFn:Generator;var generator=Object.create(protoGenerator.prototype);var context=new Context(tryLocsList||[]);// The ._invoke method unifies the implementations of the .next,\n// .throw, and .return methods.\ngenerator._invoke=makeInvokeMethod(innerFn,self,context);return generator;}runtime.wrap=wrap;// Try/catch helper to minimize deoptimizations. Returns a completion\n// record like context.tryEntries[i].completion. This interface could\n// have been (and was previously) designed to take a closure to be\n// invoked without arguments, but in all the cases we care about we\n// already have an existing method we want to call, so there\'s no need\n// to create a new function object. We can even get away with assuming\n// the method takes exactly one argument, since that happens to be true\n// in every case, so we don\'t have to touch the arguments object. The\n// only additional allocation required is the completion record, which\n// has a stable shape and so hopefully should be cheap to allocate.\nfunction tryCatch(fn,obj,arg){try{return{type:"normal",arg:fn.call(obj,arg)};}catch(err){return{type:"throw",arg:err};}}var GenStateSuspendedStart="suspendedStart";var GenStateSuspendedYield="suspendedYield";var GenStateExecuting="executing";var GenStateCompleted="completed";// Returning this object from the innerFn has the same effect as\n// breaking out of the dispatch switch statement.\nvar ContinueSentinel={};// Dummy constructor functions that we use as the .constructor and\n// .constructor.prototype properties for functions that return Generator\n// objects. For full spec compliance, you may wish to configure your\n// minifier not to mangle the names of these two functions.\nfunction Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}// This is a polyfill for %IteratorPrototype% for environments that\n// don\'t natively support it.\nvar IteratorPrototype={};IteratorPrototype[iteratorSymbol]=function(){return this;};var getProto=Object.getPrototypeOf;var NativeIteratorPrototype=getProto&&getProto(getProto(values([])));if(NativeIteratorPrototype&&NativeIteratorPrototype!==Op&&hasOwn.call(NativeIteratorPrototype,iteratorSymbol)){// This environment has a native %IteratorPrototype%; use it instead\n// of the polyfill.\nIteratorPrototype=NativeIteratorPrototype;}var Gp=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(IteratorPrototype);GeneratorFunction.prototype=Gp.constructor=GeneratorFunctionPrototype;GeneratorFunctionPrototype.constructor=GeneratorFunction;GeneratorFunctionPrototype[toStringTagSymbol]=GeneratorFunction.displayName="GeneratorFunction";// Helper for defining the .next, .throw, and .return methods of the\n// Iterator interface in terms of a single ._invoke method.\nfunction defineIteratorMethods(prototype){["next","throw","return"].forEach(function(method){prototype[method]=function(arg){return this._invoke(method,arg);};});}runtime.isGeneratorFunction=function(genFun){var ctor=typeof genFun==="function"&&genFun.constructor;return ctor?ctor===GeneratorFunction||// For the native GeneratorFunction constructor, the best we can\n// do is to check its .name property.\n(ctor.displayName||ctor.name)==="GeneratorFunction":false;};runtime.mark=function(genFun){if(Object.setPrototypeOf){Object.setPrototypeOf(genFun,GeneratorFunctionPrototype);}else{genFun.__proto__=GeneratorFunctionPrototype;if(!(toStringTagSymbol in genFun)){genFun[toStringTagSymbol]="GeneratorFunction";}}genFun.prototype=Object.create(Gp);return genFun;};// Within the body of any async function, `await x` is transformed to\n// `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n// `hasOwn.call(value, "__await")` to determine if the yielded value is\n// meant to be awaited.\nruntime.awrap=function(arg){return{__await:arg};};function AsyncIterator(generator){function invoke(method,arg,resolve,reject){var record=tryCatch(generator[method],generator,arg);if(record.type==="throw"){reject(record.arg);}else{var result=record.arg;var value=result.value;if(value&&(typeof value===\'undefined\'?\'undefined\':_typeof2(value))==="object"&&hasOwn.call(value,"__await")){return Promise.resolve(value.__await).then(function(value){invoke("next",value,resolve,reject);},function(err){invoke("throw",err,resolve,reject);});}return Promise.resolve(value).then(function(unwrapped){// When a yielded Promise is resolved, its final value becomes\n// the .value of the Promise<{value,done}> result for the\n// current iteration. If the Promise is rejected, however, the\n// result for this iteration will be rejected with the same\n// reason. Note that rejections of yielded Promises are not\n// thrown back into the generator function, as is the case\n// when an awaited Promise is rejected. This difference in\n// behavior between yield and await is important, because it\n// allows the consumer to decide what to do with the yielded\n// rejection (swallow it and continue, manually .throw it back\n// into the generator, abandon iteration, whatever). With\n// await, by contrast, there is no opportunity to examine the\n// rejection reason outside the generator function, so the\n// only option is to throw it from the await expression, and\n// let the generator function handle the exception.\nresult.value=unwrapped;resolve(result);},reject);}}var previousPromise;function enqueue(method,arg){function callInvokeWithMethodAndArg(){return new Promise(function(resolve,reject){invoke(method,arg,resolve,reject);});}return previousPromise=// If enqueue has been called before, then we want to wait until\n// all previous Promises have been resolved before calling invoke,\n// so that results are always delivered in the correct order. If\n// enqueue has not been called before, then it is important to\n// call invoke immediately, without waiting on a callback to fire,\n// so that the async generator function has the opportunity to do\n// any necessary setup in a predictable way. This predictability\n// is why the Promise constructor synchronously invokes its\n// executor callback, and why async functions synchronously\n// execute code before the first await. Since we implement simple\n// async functions in terms of async generators, it is especially\n// important to get this right, even though it requires care.\npreviousPromise?previousPromise.then(callInvokeWithMethodAndArg,// Avoid propagating failures to Promises returned by later\n// invocations of the iterator.\ncallInvokeWithMethodAndArg):callInvokeWithMethodAndArg();}// Define the unified helper method that is used to implement .next,\n// .throw, and .return (see defineIteratorMethods).\nthis._invoke=enqueue;}defineIteratorMethods(AsyncIterator.prototype);AsyncIterator.prototype[asyncIteratorSymbol]=function(){return this;};runtime.AsyncIterator=AsyncIterator;// Note that simple async functions are implemented on top of\n// AsyncIterator objects; they just return a Promise for the value of\n// the final result produced by the iterator.\nruntime.async=function(innerFn,outerFn,self,tryLocsList){var iter=new AsyncIterator(wrap(innerFn,outerFn,self,tryLocsList));return runtime.isGeneratorFunction(outerFn)?iter// If outerFn is a generator, return the full iterator.\n:iter.next().then(function(result){return result.done?result.value:iter.next();});};function makeInvokeMethod(innerFn,self,context){var state=GenStateSuspendedStart;return function invoke(method,arg){if(state===GenStateExecuting){throw new Error("Generator is already running");}if(state===GenStateCompleted){if(method==="throw"){throw arg;}// Be forgiving, per 25.3.3.3.3 of the spec:\n// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\nreturn doneResult();}context.method=method;context.arg=arg;while(true){var delegate=context.delegate;if(delegate){var delegateResult=maybeInvokeDelegate(delegate,context);if(delegateResult){if(delegateResult===ContinueSentinel)continue;return delegateResult;}}if(context.method==="next"){// Setting context._sent for legacy support of Babel\'s\n// function.sent implementation.\ncontext.sent=context._sent=context.arg;}else if(context.method==="throw"){if(state===GenStateSuspendedStart){state=GenStateCompleted;throw context.arg;}context.dispatchException(context.arg);}else if(context.method==="return"){context.abrupt("return",context.arg);}state=GenStateExecuting;var record=tryCatch(innerFn,self,context);if(record.type==="normal"){// If an exception is thrown from innerFn, we leave state ===\n// GenStateExecuting and loop back for another invocation.\nstate=context.done?GenStateCompleted:GenStateSuspendedYield;if(record.arg===ContinueSentinel){continue;}return{value:record.arg,done:context.done};}else if(record.type==="throw"){state=GenStateCompleted;// Dispatch the exception by looping back around to the\n// context.dispatchException(context.arg) call above.\ncontext.method="throw";context.arg=record.arg;}}};}// Call delegate.iterator[context.method](context.arg) and handle the\n// result, either by returning a { value, done } result from the\n// delegate iterator, or by modifying context.method and context.arg,\n// setting context.delegate to null, and returning the ContinueSentinel.\nfunction maybeInvokeDelegate(delegate,context){var method=delegate.iterator[context.method];if(method===undefined){// A .throw or .return when the delegate iterator has no .throw\n// method always terminates the yield* loop.\ncontext.delegate=null;if(context.method==="throw"){if(delegate.iterator.return){// If the delegate iterator has a return method, give it a\n// chance to clean up.\ncontext.method="return";context.arg=undefined;maybeInvokeDelegate(delegate,context);if(context.method==="throw"){// If maybeInvokeDelegate(context) changed context.method from\n// "return" to "throw", let that override the TypeError below.\nreturn ContinueSentinel;}}context.method="throw";context.arg=new TypeError("The iterator does not provide a \'throw\' method");}return ContinueSentinel;}var record=tryCatch(method,delegate.iterator,context.arg);if(record.type==="throw"){context.method="throw";context.arg=record.arg;context.delegate=null;return ContinueSentinel;}var info=record.arg;if(!info){context.method="throw";context.arg=new TypeError("iterator result is not an object");context.delegate=null;return ContinueSentinel;}if(info.done){// Assign the result of the finished delegate to the temporary\n// variable specified by delegate.resultName (see delegateYield).\ncontext[delegate.resultName]=info.value;// Resume execution at the desired location (see delegateYield).\ncontext.next=delegate.nextLoc;// If context.method was "throw" but the delegate handled the\n// exception, let the outer generator proceed normally. If\n// context.method was "next", forget context.arg since it has been\n// "consumed" by the delegate iterator. If context.method was\n// "return", allow the original .return call to continue in the\n// outer generator.\nif(context.method!=="return"){context.method="next";context.arg=undefined;}}else{// Re-yield the result returned by the delegate method.\nreturn info;}// The delegate iterator is finished, so forget it and continue with\n// the outer generator.\ncontext.delegate=null;return ContinueSentinel;}// Define Generator.prototype.{next,throw,return} in terms of the\n// unified ._invoke helper method.\ndefineIteratorMethods(Gp);Gp[toStringTagSymbol]="Generator";// A Generator should always return itself as the iterator object when the\n// @@iterator function is called on it. Some browsers\' implementations of the\n// iterator prototype chain incorrectly implement this, causing the Generator\n// object to not be returned from this call. This ensures that doesn\'t happen.\n// See https://github.com/facebook/regenerator/issues/274 for more details.\nGp[iteratorSymbol]=function(){return this;};Gp.toString=function(){return"[object Generator]";};function pushTryEntry(locs){var entry={tryLoc:locs[0]};if(1 in locs){entry.catchLoc=locs[1];}if(2 in locs){entry.finallyLoc=locs[2];entry.afterLoc=locs[3];}this.tryEntries.push(entry);}function resetTryEntry(entry){var record=entry.completion||{};record.type="normal";delete record.arg;entry.completion=record;}function Context(tryLocsList){// The root entry object (effectively a try statement without a catch\n// or a finally block) gives us a place to store values thrown from\n// locations where there is no enclosing try statement.\nthis.tryEntries=[{tryLoc:"root"}];tryLocsList.forEach(pushTryEntry,this);this.reset(true);}runtime.keys=function(object){var keys=[];for(var key in object){keys.push(key);}keys.reverse();// Rather than returning an object with a next method, we keep\n// things simple and return the next function itself.\nreturn function next(){while(keys.length){var key=keys.pop();if(key in object){next.value=key;next.done=false;return next;}}// To avoid creating an additional object, we just hang the .value\n// and .done properties off the next function object itself. This\n// also ensures that the minifier will not anonymize the function.\nnext.done=true;return next;};};function values(iterable){if(iterable){var iteratorMethod=iterable[iteratorSymbol];if(iteratorMethod){return iteratorMethod.call(iterable);}if(typeof iterable.next==="function"){return iterable;}if(!isNaN(iterable.length)){var i=-1,next=function next(){while(++i<iterable.length){if(hasOwn.call(iterable,i)){next.value=iterable[i];next.done=false;return next;}}next.value=undefined;next.done=true;return next;};return next.next=next;}}// Return an iterator with no values.\nreturn{next:doneResult};}runtime.values=values;function doneResult(){return{value:undefined,done:true};}Context.prototype={constructor:Context,reset:function reset(skipTempReset){this.prev=0;this.next=0;// Resetting context._sent for legacy support of Babel\'s\n// function.sent implementation.\nthis.sent=this._sent=undefined;this.done=false;this.delegate=null;this.method="next";this.arg=undefined;this.tryEntries.forEach(resetTryEntry);if(!skipTempReset){for(var name in this){// Not sure about the optimal order of these conditions:\nif(name.charAt(0)==="t"&&hasOwn.call(this,name)&&!isNaN(+name.slice(1))){this[name]=undefined;}}}},stop:function stop(){this.done=true;var rootEntry=this.tryEntries[0];var rootRecord=rootEntry.completion;if(rootRecord.type==="throw"){throw rootRecord.arg;}return this.rval;},dispatchException:function dispatchException(exception){if(this.done){throw exception;}var context=this;function handle(loc,caught){record.type="throw";record.arg=exception;context.next=loc;if(caught){// If the dispatched exception was caught by a catch block,\n// then let that catch block handle the exception normally.\ncontext.method="next";context.arg=undefined;}return!!caught;}for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];var record=entry.completion;if(entry.tryLoc==="root"){// Exception thrown outside of any try block that could handle\n// it, so set the completion value of the entire function to\n// throw the exception.\nreturn handle("end");}if(entry.tryLoc<=this.prev){var hasCatch=hasOwn.call(entry,"catchLoc");var hasFinally=hasOwn.call(entry,"finallyLoc");if(hasCatch&&hasFinally){if(this.prev<entry.catchLoc){return handle(entry.catchLoc,true);}else if(this.prev<entry.finallyLoc){return handle(entry.finallyLoc);}}else if(hasCatch){if(this.prev<entry.catchLoc){return handle(entry.catchLoc,true);}}else if(hasFinally){if(this.prev<entry.finallyLoc){return handle(entry.finallyLoc);}}else{throw new Error("try statement without catch or finally");}}}},abrupt:function abrupt(type,arg){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc<=this.prev&&hasOwn.call(entry,"finallyLoc")&&this.prev<entry.finallyLoc){var finallyEntry=entry;break;}}if(finallyEntry&&(type==="break"||type==="continue")&&finallyEntry.tryLoc<=arg&&arg<=finallyEntry.finallyLoc){// Ignore the finally entry if control is not jumping to a\n// location outside the try/catch block.\nfinallyEntry=null;}var record=finallyEntry?finallyEntry.completion:{};record.type=type;record.arg=arg;if(finallyEntry){this.method="next";this.next=finallyEntry.finallyLoc;return ContinueSentinel;}return this.complete(record);},complete:function complete(record,afterLoc){if(record.type==="throw"){throw record.arg;}if(record.type==="break"||record.type==="continue"){this.next=record.arg;}else if(record.type==="return"){this.rval=this.arg=record.arg;this.method="return";this.next="end";}else if(record.type==="normal"&&afterLoc){this.next=afterLoc;}return ContinueSentinel;},finish:function finish(finallyLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.finallyLoc===finallyLoc){this.complete(entry.completion,entry.afterLoc);resetTryEntry(entry);return ContinueSentinel;}}},"catch":function _catch(tryLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc===tryLoc){var record=entry.completion;if(record.type==="throw"){var thrown=record.arg;resetTryEntry(entry);}return thrown;}}// The context.catch method must only be called with a location\n// argument that corresponds to a known catch block.\nthrow new Error("illegal catch attempt");},delegateYield:function delegateYield(iterable,resultName,nextLoc){this.delegate={iterator:values(iterable),resultName:resultName,nextLoc:nextLoc};if(this.method==="next"){// Deliberately forget the last sent value so that we don\'t\n// accidentally pass it on to the delegate.\nthis.arg=undefined;}return ContinueSentinel;}};}(// In sloppy mode, unbound `this` refers to the global object, fallback to\n// Function constructor if we\'re in global strict mode. That is sadly a form\n// of indirect eval which violates Content Security Policy.\nfunction(){return this;}()||Function("return this")());});/**\r\n\t * Copyright (c) 2014-present, Facebook, Inc.\r\n\t *\r\n\t * This source code is licensed under the MIT license found in the\r\n\t * LICENSE file in the root directory of this source tree.\r\n\t */// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g=function(){return this;}()||Function("return this")();// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime=g.regeneratorRuntime&&Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime")>=0;// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime=hadRuntime&&g.regeneratorRuntime;// Force reevalutation of runtime.js.\ng.regeneratorRuntime=undefined;var runtimeModule=runtime$2;if(hadRuntime){// Restore the original runtime.\ng.regeneratorRuntime=oldRuntime;}else{// Remove the global property added by runtime.js.\ntry{delete g.regeneratorRuntime;}catch(e){g.regeneratorRuntime=undefined;}}var regenerator=runtimeModule;/**\r\n\t * Transformation\r\n\t * @author pzx\r\n\t * @ignore\r\n\t */var UBuilderSceneCombineParser=function(){function UBuilderSceneCombineParser(loader){classCallCheck(this,UBuilderSceneCombineParser);this.combineManager=loader.combineManager;}UBuilderSceneCombineParser.prototype.parseWorld=function parseWorld(world){var _marked=/*#__PURE__*/regenerator.mark(gen);var outdoors=world.outdoors;this.parsePlan(outdoors);var buildings=world.buildings;for(var i=0;i<buildings.length;i++){var bd=buildings[i];this.parseBuilding(bd);}function gen(plans){var maxTime,waitTime,i,plan,plcProcessors,wallProcessors,modelWallProcessors,floorProcessors,ceilingProcessors,roofProcessors,doorOrWinProcessors,j;return regenerator.wrap(function gen$(_context){while(1){switch(_context.prev=_context.next){case 0:maxTime=0.1;waitTime=10;i=0;case 3:if(!(i<plans.length)){_context.next=64;break;}plan=plans[i];plcProcessors=plan.placementCombineProcessors;wallProcessors=plan.straightManualWallCombineProcessors;modelWallProcessors=plan.modelWallCombineProcessors;floorProcessors=plan.floorCombineProcessors;ceilingProcessors=plan.ceilingCombineProcessors;roofProcessors=plan.roofCombineProcessors;doorOrWinProcessors=plan.doorOrWindowCombineProcessors;// var floor = key;\n// delayBuildProcessor(plcProcessors, plan.combinePlacements);\n// delayBuildProcessor(wallProcessors, plan.combineStraightManualWalls);\n// delayBuildProcessor(modelWallProcessors, plan.combineModelWalls);\n// delayBuildProcessor(plcProcessors,plan.combinePlacements);\nj=0;case 13:if(!(j<ceilingProcessors.length)){_context.next=19;break;}_context.next=16;return new Promise(function(resolve,reject){var loadStartTime=performance.now();var processor=ceilingProcessors[j];processor.build();var mesh=processor.combineMesh;plan.combineCeilings.push(mesh);// floor.node.add(mesh);\nvar elapseTime=performance.now()-loadStartTime;if(elapseTime>maxTime){setTimeout(function(){resolve();},waitTime);}else{resolve();}});case 16:j++;_context.next=13;break;case 19:j=0;case 20:if(!(j<roofProcessors.length)){_context.next=26;break;}_context.next=23;return new Promise(function(resolve,reject){var loadStartTime=performance.now();var processor=roofProcessors[j];processor.build();var mesh=processor.combineMesh;plan.combineRoofs.push(mesh);// floor.node.add(mesh);\nvar elapseTime=performance.now()-loadStartTime;if(elapseTime>maxTime){setTimeout(function(){resolve();},waitTime);}else{resolve();}});case 23:j++;_context.next=20;break;case 26:j=0;case 27:if(!(j<floorProcessors.length)){_context.next=33;break;}_context.next=30;return new Promise(function(resolve,reject){var loadStartTime=performance.now();var processor=floorProcessors[j];processor.build();var mesh=processor.combineMesh;plan.combineFloors.push(mesh);// floor.node.add(mesh);\nvar elapseTime=performance.now()-loadStartTime;if(elapseTime>maxTime){setTimeout(function(){resolve();},waitTime);}else{resolve();}});case 30:j++;_context.next=27;break;case 33:j=0;case 34:if(!(j<plcProcessors.length)){_context.next=40;break;}_context.next=37;return new Promise(function(resolve,reject){var loadStartTime=performance.now();var processor=plcProcessors[j];processor.build();var mesh=processor.combineMesh;plan.combinePlacements.push(mesh);// floor.node.add(mesh);\nvar elapseTime=performance.now()-loadStartTime;if(elapseTime>maxTime){setTimeout(function(){resolve();},waitTime);}else{resolve();}});case 37:j++;_context.next=34;break;case 40:j=0;case 41:if(!(j<doorOrWinProcessors.length)){_context.next=47;break;}_context.next=44;return new Promise(function(resolve,reject){var loadStartTime=performance.now();var processor=doorOrWinProcessors[j];processor.build();var mesh=processor.combineMesh;plan.combineDoorOrWins.push(mesh);// floor.node.add(mesh);\nvar elapseTime=performance.now()-loadStartTime;if(elapseTime>maxTime){setTimeout(function(){resolve();},waitTime);}else{resolve();}});case 44:j++;_context.next=41;break;case 47:j=0;case 48:if(!(j<wallProcessors.length)){_context.next=54;break;}_context.next=51;return new Promise(function(resolve,reject){var loadStartTime=performance.now();var processor=wallProcessors[j];processor.build();var mesh=processor.combineMesh;plan.combineStraightManualWalls.push(mesh);// floor.node.add(mesh);\nvar elapseTime=performance.now()-loadStartTime;if(elapseTime>maxTime){setTimeout(function(){resolve();},waitTime);}else{resolve();}});case 51:j++;_context.next=48;break;case 54:j=0;case 55:if(!(j<modelWallProcessors.length)){_context.next=61;break;}_context.next=58;return new Promise(function(resolve,reject){// delayBuildProcessor(modelWallProcessors[j],plan.combineModelWalls,resolve);\nvar loadStartTime=performance.now();var processor=modelWallProcessors[j];processor.build();var mesh=processor.combineMesh;plan.combineModelWalls.push(mesh);// floor.node.add(mesh);\nvar elapseTime=performance.now()-loadStartTime;if(elapseTime>maxTime){setTimeout(function(){resolve();},waitTime);}else{resolve();}});case 58:j++;_context.next=55;break;case 61:i++;_context.next=3;break;case 64:case"end":return _context.stop();}}},_marked,this);}// function delayBuildProcessor(processor, list,resolve,) {\n//     var maxTime = 0.1;\n//     var waitTime = 10;\n//     var loadStartTime = performance.now();\n//     // var processor = processors[j];\n//     processor.build();\n//     var mesh = processor.combineMesh;\n//     list.push(mesh);\n//     // floor.node.add(mesh);\n//     var elapseTime = performance.now() - loadStartTime;\n//     if (elapseTime > maxTime) {\n//         setTimeout(function () {\n//             resolve();\n//         }, waitTime);\n//     } else {\n//         resolve();\n//     }\n//\n// }\nvar plans=[];for(var i=0;i<world.buildings.length;i++){var bd=world.buildings[i];for(var j=0;j<bd.floorplans.length;j++){var plan=bd.floorplans[j];plans.push(plan);}}plans.push(world.outdoors);return gen(plans);};UBuilderSceneCombineParser.prototype.parseBuilding=function parseBuilding(bd){var plans=bd.floorplans;for(var i=0;i<plans.length;i++){var plan=plans[i];this.parsePlan(plan);}};UBuilderSceneCombineParser.prototype.parsePlan=function parsePlan(plan){var placements=plan.placements;var walls=plan.walls;var rooms=plan.rooms;var uncombinePlcs=[];var uncombienGroups=[];for(var i=0;i<placements.length;i++){var plc=placements[i];if(!plc.properties&&!plc.name){this.combineManager.addPlacement(plc,plan);}else{uncombinePlcs.push(plc);}}plan.placements=uncombinePlcs;for(var i=0;i<plan.groups.length;i++){var group=plan.groups[i];if(!group.properties&&!group.name){this.combineManager.addGroup(group,plan);}else{uncombienGroups.push(group);}}plan.groups=uncombienGroups;for(var i=0;i<walls.length;i++){var wall=walls[i];if(!wall.isShow)continue;if(wall.subWalls.length!==0){for(var j=0;j<wall.subWalls.length;j++){var subWall=wall.subWalls[j];if(subWall instanceof SubStraightManualWall){this.combineManager.addStraightManualWall(subWall,plan);}else{this.combineManager.addModelWall(subWall,plan);}}}else{if(wall instanceof Wall){this.combineManager.addStraightManualWall(wall,plan);}else{this.combineManager.addModelWall(wall,plan);}}if(wall.doorOrWindows.length>0){for(var j=0;j<wall.doorOrWindows.length;j++){var doorOrWin=wall.doorOrWindows[j];this.combineManager.addDoorOrWindow(doorOrWin,plan);}}}for(var i=0;i<rooms.length;i++){var room=rooms[i];if(!room.properties&&!room.name){this.combineManager.addRoom(room,plan);}}};return UBuilderSceneCombineParser;}();/**\r\n\t * @author pzx 2018.2.13\r\n\t * Json2MeshBuilderParser\r\n\t */var ubuilderLoadSceneKeys$1={id:"id",name:"name",position:"position",rotation:"rotation",scale:"scale",properties:"properties",plans:"plans",walls:"walls",placements:"placements",groups:"groups",corners:"corners",doorOrWindows:"doororwindows",rooms:"rooms",height:"height",thick:"thick",texture:"texture",type:"type",model:"model",suspendPercent:"suspendpercent",leftTexture:"lefttexture",rightTexture:"righttexture",edgeTexture:"edgetexture",floorTexture:"floortexture",ceilingTexture:"ceilingtexture",roofTexture:"rooftexture",wallType:"type"};var loadKeys$1=ubuilderLoadSceneKeys$1;var UBuilderSceneLoader=function(){function UBuilderSceneLoader(){classCallCheck(this,UBuilderSceneLoader);this.sceneJson=null;this.scale=1;//比例尺\nthis.curFloorPlan=null;this.enableCombine=true;// this.defaultWallTextureUri = "Textures/微信图片_20180404142945.png";\n//\n// this.defaultWallEdgeTextureUri = "Textures/微信图片_20180404142945.png";\n// this.defaultFloorTextureUri = "Textures/微信图片_20180404142945.png";\n// this.defaultCeilingTextureUri = "Textures/微信图片_20180404142945.png";\n// this.defaultRoofTextureUri = "Textures/微信图片_20180404142945.png";\nthis.defaultWallEdgeTextureUri="Textures/WallEdge.jpg";this.defaultWallTextureUri="Textures/RoomWall.jpg";this.defaultFloorTextureUri="Textures/FloorDefault.jpg";this.defaultCeilingTextureUri="Textures/CeilingDefault.jpg";this.defaultRoofTextureUri="Textures/RoofDefault.jpg";this.world=null;this.resourceManager=new ResourceManager();this.combineManager=new CombineManager(this.resourceManager);this.combineParser=new UBuilderSceneCombineParser(this);// DefaultSetting.enableBuildMesh = false;\n}UBuilderSceneLoader.prototype._nestingLoopYield=function _nestingLoopYield(gen,success,fail){var _this=this;var item=gen.next();if(item.done){if(success){success();}return item.value;}var value=item.value,done=item.done;if(value instanceof Promise){value.then(function(e){return _this._nestingLoopYield(gen,success,fail);}).catch(function(error){fail(error);});}else{this._nestingLoopYield(gen,success,fail);}};//pzx start\nUBuilderSceneLoader.prototype.load=function load(map){var that=this;if(map){if(map["url"]){this.sceneURL=map["url"];}if(map["json"]){this.sceneJson=map["json"];}}else{console.error("load param can not be null");return null;}return new Promise(function(resolve,reject){// that.loadDefaultTexture().then(function () {\n//     return that.loadSceneJson();\n// }).\nthat.loadSceneJson().then(function(){// that.curFloorPlan = new FloorPlan();\nthat.parseSceneJson().then(function(){that.world.build();that.combineManager.combineModels().then(function(){console.log("finish combine models");// return that.combineParser.parseWorld(that.world);\nreturn new Promise(function(resolve,reject){var gen=that.combineParser.parseWorld(that.world);if(gen){that._nestingLoopYield(gen,function(){resolve();},function(error){reject(error);});}else{resolve();}});}).then(function(){resolve(that.world);});});}).catch(function(error){console.error(error);});});};UBuilderSceneLoader.prototype.loadSceneJson=function loadSceneJson(){var that=this;return new Promise(function(resolve,reject){if(that.sceneJson){resolve(that.sceneJson);}else if(that.sceneURL){var loader=new THREE.FileLoader();loader.load(that.sceneURL,function(data){that.sceneJson=JSON.parse(data);resolve();},function(){},function(error){reject("can not load "+that.sceneURL);});}else{reject("load scene json error");}});};UBuilderSceneLoader.prototype.createTextureLoaderPromise=function createTextureLoaderPromise(texUri){var that=this;return new Promise(function(resolve,reject){var texLoader=new THREE.TextureLoader();// var that = this;\n// load a resource\ntexLoader.load(// resource URL\n// that.sceneURL+"/"+texUri,\ntexUri,// Function when resource is loaded\nfunction(texture){texture.wrapS=THREE.RepeatWrapping;texture.wrapT=THREE.RepeatWrapping;resolve(texture);},// Function called when download progresses\nfunction(xhr){console.log(texUri+" "+xhr.loaded/xhr.total*100+\'% loaded\');},// Function called when download errors\nfunction(xhr){resolve(null);console.log(texUri+\'load error\');});});};UBuilderSceneLoader.prototype.loadResources=function loadResources(){var that=this;return new Promise(function(resolve,reject){var wallTexPromise=that.createTextureLoaderPromise(that.defaultWallTextureUri);var wallEdgePromise=that.createTextureLoaderPromise(that.defaultWallEdgeTextureUri);var floorPromise=that.createTextureLoaderPromise(that.defaultFloorTextureUri);var roofPromise=that.createTextureLoaderPromise(that.defaultRoofTextureUri);var ceilingPromise=that.createTextureLoaderPromise(that.defaultCeilingTextureUri);Promise.all([wallTexPromise,wallEdgePromise,floorPromise,roofPromise,ceilingPromise]).then(function(textures){DefaultResource.wallTexture=textures[0];DefaultResource.wallEdgeTexture=textures[1];DefaultResource.floorTexture=textures[2];DefaultResource.roofTexture=textures[3];DefaultResource.ceilingTexture=textures[4];resolve();});});};UBuilderSceneLoader.prototype.loadDefaultTexture=function loadDefaultTexture(){var that=this;return new Promise(function(resolve,reject){var wallTexPromise=that.createTextureLoaderPromise(that.defaultWallTextureUri);var wallEdgePromise=that.createTextureLoaderPromise(that.defaultWallEdgeTextureUri);var floorPromise=that.createTextureLoaderPromise(that.defaultFloorTextureUri);var roofPromise=that.createTextureLoaderPromise(that.defaultRoofTextureUri);var ceilingPromise=that.createTextureLoaderPromise(that.defaultCeilingTextureUri);Promise.all([wallTexPromise,wallEdgePromise,floorPromise,roofPromise,ceilingPromise]).then(function(textures){DefaultResource.wallTexture=textures[0];DefaultResource.wallEdgeTexture=textures[1];DefaultResource.floorTexture=textures[2];DefaultResource.roofTexture=textures[3];DefaultResource.ceilingTexture=textures[4];DefaultResource.wallMaterial=new THREE.MeshStandardMaterial({color:0xffffff,map:textures[0]});DefaultResource.wallEdgeMaterial=new THREE.MeshStandardMaterial({color:0xffffff,map:textures[1]});DefaultResource.floorMaterial=new THREE.MeshStandardMaterial({color:0xffffff,map:textures[2]});DefaultResource.ceilingMaterial=new THREE.MeshStandardMaterial({color:0xffffff,map:textures[3]});DefaultResource.roofMaterial=new THREE.MeshStandardMaterial({color:0xffffff,map:textures[4]});resolve();});});};UBuilderSceneLoader.prototype.parseSceneJson=function parseSceneJson(){var that=this;return new Promise(function(resolve,reject){that.resourceManager.loadTextures(that.sceneJson.textures);that.resourceManager.loadModels(that.sceneJson.models);var id=setInterval(function(){if(that.resourceManager.checkAllResourcesIsReady()){clearInterval(id);that.parseWorld(that.sceneJson);resolve();}},10);});};UBuilderSceneLoader.prototype.parseWorld=function parseWorld(jsonData){var world=new World();this.world=world;this.parseBaseObject(jsonData,world);if(jsonData["buildings"]){var buildingsData=jsonData["buildings"];for(var i=0;i<buildingsData.length;i++){var buildingData=buildingsData[i];var bd=this.parseBuilding(buildingData);world.buildings.push(bd);}}if(jsonData["outdoors"]){var outdoors=new Outdoors();this.parseFloorPlan(jsonData["outdoors"],outdoors);world.outdoors=outdoors;}};UBuilderSceneLoader.prototype.parseBuilding=function parseBuilding(jsonData,parent){var buildingData=jsonData;var bd=new Building();this.parseBaseObject(jsonData,bd,parent);var plansData=buildingData[loadKeys$1.plans];if(plansData){for(var j=0;j<plansData.length;j++){var planData=plansData[j];var floorPlan=new FloorPlan();this.parseFloorPlan(planData,floorPlan,bd);bd.floorplans.push(floorPlan);}}return bd;};UBuilderSceneLoader.prototype.parseFloorPlan=function parseFloorPlan(jsonData,floorPlan,parent){// var floorPlan = new FloorPlan();\n// floorPlan.id = id;\n// floorPlan.name = name;\nthis.parseBaseObject(jsonData,floorPlan,parent);if(jsonData[loadKeys$1.height]){floorPlan.height=jsonData[loadKeys$1.height];}if(jsonData[loadKeys$1.corners]){var cornersData=jsonData[loadKeys$1.corners];for(var i=0;i<cornersData.length;i++){var cornerData=cornersData[i];var x=cornerData[0];var y=cornerData[1];var z=-cornerData[2];if(!floorPlan.existsCorner(x,y,z)){floorPlan.addCorner(x,y,z);}else{console.error("repeat corner");}}}if(jsonData[loadKeys$1.walls]){var wallsData=jsonData[loadKeys$1.walls];for(var i=0;i<wallsData.length;i++){var wallData=wallsData[i];this.parseWall(wallData,floorPlan);}}if(jsonData[loadKeys$1.rooms]){var roomsData=jsonData[loadKeys$1.rooms];for(var i=0;i<roomsData.length;i++){var roomData=roomsData[i];this.parseRoom(roomData,floorPlan);}}if(jsonData[loadKeys$1.placements]){var plcsData=jsonData[loadKeys$1.placements];for(var i=0;i<plcsData.length;i++){var plcData=plcsData[i];this.parsePlacement(plcData,floorPlan);}}if(jsonData[loadKeys$1.groups]){var groupsData=jsonData[loadKeys$1.groups];for(var i=0;i<groupsData.length;i++){var groupData=groupsData[i];this.parseGroup(groupData,floorPlan);}}if(jsonData[loadKeys$1.doorOrWindows]){var doorOrWinsData=jsonData[loadKeys$1.doorOrWindows];for(var i=0;i<doorOrWinsData.length;i++){var doorOrWinData=doorOrWinsData[i];this.parseDoorOrWindow(doorOrWinData,floorPlan);}}return floorPlan;};UBuilderSceneLoader.prototype.parseDoorOrWindow=function parseDoorOrWindow(jsonData,wall){var doorOrWin=new DoorOrWindow();this.parseBaseObject(jsonData,doorOrWin,wall.parent);doorOrWin.resource=this.resourceManager.models[jsonData[loadKeys$1.model]];wall.doorOrWindows.push(doorOrWin);if(jsonData[loadKeys$1.suspendPercent]){doorOrWin.suspendPercent=jsonData[loadKeys$1.suspendPercent];}doorOrWin.attachWall=wall;};UBuilderSceneLoader.prototype.parsePlacement=function parsePlacement(jsonData,plan){var plc=new Placement();this.parseBaseObject(jsonData,plc,plan);plc.resource=this.resourceManager.models[jsonData[loadKeys$1.model]];if(jsonData.texture!==undefined&&jsonData.texture!==null){plc.customTextureResource=this.resourceManager.textures[jsonData.texture];}if(jsonData.color){var colorData=jsonData.color;plc.customColor=new THREE.Color(colorData[0],colorData[1],colorData[2]);if(colorData.length==4){plc.opacity=colorData[3];}}if(jsonData.rendermode){plc.renderMode=jsonData.rendermode;}// var pos = jsonData[loadKeys.position];\n// var scale = jsonData[loadKeys.scale];\n// var rot = jsonData[loadKeys.rotation];\n// if(pos){\n//     plc.position.set(pos.x,pos.y,pos.z);\n// }\n// if(scale){\n//     plc.scale.set(scale.x,scale.y,scale.z);\n// }\n// if(rot){\n//     plc.rotation.set(rot.x,rot.y,rot.z);\n// }\nplan.placements.push(plc);};UBuilderSceneLoader.prototype.parseGroup=function parseGroup(jsonData,plan){var group=new PlacementGroup();this.parseBaseObject(jsonData,group,plan);plan.groups.push(group);if(jsonData[loadKeys$1.placements]){var plcsData=jsonData[loadKeys$1.placements];for(var i=0;i<plcsData.length;i++){var plcData=plcsData[i];this.parsePlacement(plcData,group);}}if(jsonData[loadKeys$1.groups]){var groupsData=jsonData[loadKeys$1.groups];for(var i=0;i<groupsData.length;i++){var groupData=groupsData[i];this.parseGroup(groupData,group);}}};UBuilderSceneLoader.prototype.parseWall=function parseWall(jsonData,floorPlan){var type=jsonData[loadKeys$1.wallType];var wall=null;if(type==0){wall=new Wall();}else{wall=new ModelWall();}this.parseBaseObject(jsonData,wall,floorPlan);var cornersIndex=jsonData[loadKeys$1.corners];wall.startCorner=floorPlan.corners[cornersIndex[0]];wall.endCorner=floorPlan.corners[cornersIndex[1]];if(jsonData[loadKeys$1.leftTexture]!==undefined){// wall.rightResource = this.resourceManager.textures[jsonData[loadKeys.leftTexture]];\nwall.rightResource=this.resourceManager.textures[jsonData[loadKeys$1.leftTexture]];}if(jsonData[loadKeys$1.rightTexture]!==undefined){// wall.leftResource = this.resourceManager.textures[jsonData[loadKeys.rightTexture]];\nwall.leftResource=this.resourceManager.textures[jsonData[loadKeys$1.rightTexture]];}if(jsonData[loadKeys$1.edgeTexture]!==undefined){wall.edgeResource=this.resourceManager.textures[jsonData[loadKeys$1.edgeTexture]];}//处理模型墙\nif(jsonData[loadKeys$1.model]!==undefined){wall.resource=this.resourceManager.models[jsonData[loadKeys$1.model]];}if(jsonData[loadKeys$1.doorOrWindows]){var doorOrWinsData=jsonData[loadKeys$1.doorOrWindows];for(var i=0;i<doorOrWinsData.length;i++){var doorOrWinData=doorOrWinsData[i];this.parseDoorOrWindow(doorOrWinData,wall,floorPlan);}}// this.parseDoorOrWindow(jsonData,wall)\nwall.startCorner.addWall(wall);wall.endCorner.addWall(wall);floorPlan.addWall(wall);// return wall;\n};UBuilderSceneLoader.prototype.parseRoom=function parseRoom(jsonData,plan){var room=new Room();this.parseBaseObject(jsonData,room,plan);var cornersIndex=jsonData[loadKeys$1.corners];var points=[];var x=0;var y=0;var z=0;for(var i=0;i<cornersIndex.length;i++){var idx=cornersIndex[i];var point=plan.corners[idx].position;x+=point.x;y+=point.y;z+=point.z;points.push(point);}var len=cornersIndex.len();var position=new THREE.Vector3(x/len,y/len,z/len);for(var i=0;i<points.length;i++){var point=points[i];point.x-=position.x;point.y-=position.y;point.z-=position.z;}if(jsonData[loadKeys$1.floorTexture]!==undefined){room.floorResource=this.resourceManager.textures[jsonData[loadKeys$1.floorTexture]];}if(jsonData[loadKeys$1.ceilingTexture]!==undefined){room.ceilingResource=this.resourceManager.textures[jsonData[loadKeys$1.ceilingTexture]];}if(jsonData[loadKeys$1.roofTexture]!==undefined){room.roofResource=this.resourceManager.textures[jsonData[loadKeys$1.roofTexture]];}room.points=points;room.position=position;plan.rooms.push(room);};UBuilderSceneLoader.prototype.parseBaseObject=function parseBaseObject(jsonData,baseObj,parent){var id,name;baseObj.parent=parent;if(jsonData[loadKeys$1.id]){id=jsonData[loadKeys$1.id];baseObj.id=id;}if(jsonData[loadKeys$1.name]){name=jsonData[loadKeys$1.name];baseObj.name=name;}if(jsonData[loadKeys$1.position]){var posArray=jsonData[loadKeys$1.position];var position=baseObj.position;position.set(posArray[0],posArray[1],-posArray[2]);// position = new THREE.Vector3(posArray[0], posArray[1], posArray[2]);\n// baseObj.position = position;\n}if(jsonData[loadKeys$1.scale]){var scaleArray=jsonData[loadKeys$1.scale];var scale=baseObj.scale;scale.set(scaleArray[0],scaleArray[1],scaleArray[2]);// position = new THREE.Vector3(posArray[0], posArray[1], posArray[2]);\n// baseObj.position = position;\n}if(jsonData[loadKeys$1.rotation]){var rotArray=jsonData[loadKeys$1.rotation];var rotation=baseObj.rotation;rotation.set(rotArray[0],rotArray[1],-rotArray[2],-rotArray[3]);// rotation = new THREE.Quaternion(rotArray[0], rotArray[1], rotArray[2],rotArray[3]);\n// baseObj.rotation = rotation;\n}if(jsonData[loadKeys$1.properties]){baseObj.properties=jsonData[loadKeys$1.properties];}};UBuilderSceneLoader.prototype.createRooms=function createRooms(){var roomMeshs=[];for(var i=0;i<this.curFloorPlan.rooms.length;i++){var room=this.curFloorPlan.rooms[i];roomMeshs.push(room.meshGroup);}return roomMeshs;};UBuilderSceneLoader.prototype.createWalls=function createWalls(){var wallMeshs=[];for(var i=0;i<this.world.buildings.length;i++){var bd=this.world.buildings[i];for(var j=0;j<bd.floorplans.length;j++){var plan=bd.floorplans[j];for(var k=0;k<plan.walls.length;k++){var wall=plan.walls[k];// var pos = wall.position;\n// var group = new THREE.Group("wall");\n// group.add(this.createWallMesh(wall.rightSideMeshInfo));\n// group.add(this.createWallMesh(wall.leftSideMeshInfo));\n// group.add(this.createWallMesh(wall.edgeSideMeshInfo));\n// group.position.set(pos.x, pos.y, pos.z);\nwallMeshs.push(wall.wallGroup);}}}return wallMeshs;};UBuilderSceneLoader.prototype.createWallMesh=function createWallMesh(meshInfo){var geometry=new THREE.BufferGeometry();geometry.addAttribute(\'position\',new THREE.BufferAttribute(meshInfo.positionArray,3));geometry.addAttribute(\'normal\',new THREE.BufferAttribute(meshInfo.normalArray,3));geometry.addAttribute(\'uv\',new THREE.BufferAttribute(meshInfo.uvArray,2));var material=meshInfo.material;var mesh=new THREE.Mesh(geometry,material);return mesh;};return UBuilderSceneLoader;}();/**\r\n\t * Transformation\r\n\t * @author pzx\r\n\t * @ignore\r\n\t */var UBuilderSceneDelayCombineParser=function(){function UBuilderSceneDelayCombineParser(loader){classCallCheck(this,UBuilderSceneDelayCombineParser);this.combineManager=loader.combineManager;}UBuilderSceneDelayCombineParser.prototype.parseWorld=function parseWorld(world){var outdoors=world.outdoors;this.parsePlan(outdoors);var buildings=world.buildings;for(var i=0;i<buildings.length;i++){var bd=buildings[i];this.parseBuilding(bd);}var plans=[];for(var i=0;i<world.buildings.length;i++){var bd=world.buildings[i];for(var j=0;j<bd.floorplans.length;j++){var plan=bd.floorplans[j];plans.push(plan);}}plans.push(world.outdoors);};UBuilderSceneDelayCombineParser.prototype.parseBuilding=function parseBuilding(bd){var plans=bd.floorplans;for(var i=0;i<plans.length;i++){var plan=plans[i];this.parsePlan(plan);}for(var i=0;i<bd.facades.length;i++){var facade=bd.facades[i];this.addUncombinePlacementResource(facade);}for(var i=0;i<bd.facadeGroups.length;i++){var facade=bd.facadeGroups[i];this.addUncombineGroupResource(facade);}};UBuilderSceneDelayCombineParser.prototype.parsePlan=function parsePlan(plan){var placements=plan.placements;var walls=plan.walls;var rooms=plan.rooms;var uncombinePlcs=[];var uncombienGroups=[];var uncombineRooms=[];var uncombineWithHeightRooms=[];var uncombineDoorOrWins=[];for(var i=0;i<plan.curvelines.length;i++){var line=plan.curvelines[i];this.addCommoneTextureResource(line);}for(var i=0;i<plan.pipelines.length;i++){var line=plan.pipelines[i];this.addCommoneTextureResource(line);}for(var i=0;i<placements.length;i++){var plc=placements[i];// if(!plc.isShow)\n//     continue;\nif(!plc.properties&&!plc.userID&&!plc.name&&!plc.resource.hasAnim&&plc.isShow){this.combineManager.addPlacement(plc,plan);}else{uncombinePlcs.push(plc);this.addUncombinePlacementResource(plc);}}plan.placements=uncombinePlcs;for(var i=0;i<plan.groups.length;i++){var group=plan.groups[i];// if(!group.isShow)\n//     continue;\nif(!group.properties&&!group.userID&&!group.name&&group.isShow){this.combineManager.addGroup(group,plan);}else{uncombienGroups.push(group);this.addUncombineGroupResource(group);}}plan.groups=uncombienGroups;for(var i=0;i<walls.length;i++){var wall=walls[i];if(!wall.isShow)continue;if(wall.subWalls.length!==0){for(var j=0;j<wall.subWalls.length;j++){var subWall=wall.subWalls[j];if(subWall instanceof SubStraightManualWall){this.combineManager.addStraightManualWall(subWall,plan);}else{this.combineManager.addModelWall(subWall,plan);}}}else{if(wall instanceof Wall){this.combineManager.addStraightManualWall(wall,plan);}else{this.combineManager.addModelWall(wall,plan);}}uncombineDoorOrWins=[];if(wall.doorOrWindows.length>0){for(var j=0;j<wall.doorOrWindows.length;j++){var doorOrWin=wall.doorOrWindows[j];if(!doorOrWin.resource)continue;if(!doorOrWin.properties&&!doorOrWin.userID&&!doorOrWin.name&&!doorOrWin.resource.hasAnim){this.combineManager.addDoorOrWindow(doorOrWin,plan);}else{uncombineDoorOrWins.push(doorOrWin);this.addUncombinePlacementResource(doorOrWin);}}}wall.doorOrWindows=uncombineDoorOrWins;}for(var i=0;i<rooms.length;i++){var room=rooms[i];//鉴于ShapeGeometry合并时候不能修改高度，则对于有高度的房间，默认都不会合并\n//等自己写生成mesh的算法后，在合并有高度的房间\nif(!room.properties&&!room.userID&&!room.name&&room.floor.height===room.floor.DefaultHeight){this.combineManager.addRoom(room,plan);}else{this.addUncombineRoomResource(room);if(room.properties||room.userID||room.name){uncombineRooms.push(room);}else{uncombineWithHeightRooms.push(room);}}}plan.rooms=uncombineRooms;plan.uncombineWithHeigthRooms=uncombineWithHeightRooms;};UBuilderSceneDelayCombineParser.prototype.addUncombineRoomResource=function addUncombineRoomResource(room){this.combineManager.resourceManager.addRoomResource(room.floorResource);this.combineManager.resourceManager.addRoomResource(room.ceilingResource);this.combineManager.resourceManager.addRoomResource(room.roofResource);room.floor.initResource();room.ceiling.initResource();room.roof.initResource();};UBuilderSceneDelayCombineParser.prototype.addCommoneTextureResource=function addCommoneTextureResource(obj){if(obj.resource){obj.initResource();this.combineManager.resourceManager.addCommonTextureResource(obj.resource);}};UBuilderSceneDelayCombineParser.prototype.addUncombinePlacementResource=function addUncombinePlacementResource(plc){this.combineManager.resourceManager.addPlacementResource(plc.resource);plc.initResource();};UBuilderSceneDelayCombineParser.prototype.addUncombineGroupResource=function addUncombineGroupResource(group){for(var i=0;i<group.placements.length;i++){var plc=group.placements[i];this.addUncombinePlacementResource(plc);}for(var i=0;i<group.groups.length;i++){var childGroup=group.groups[i];this.addUncombineGroupResource(childGroup);}};UBuilderSceneDelayCombineParser.prototype.buildWorld=function buildWorld(world){this.buildPlan(world.outdoors);var buildings=world.buildings;for(var i=0;i<buildings.length;i++){var bd=buildings[i];this.buildBuilding(bd);}};UBuilderSceneDelayCombineParser.prototype.buildBuilding=function buildBuilding(bd){var plans=bd.floorplans;for(var i=0;i<plans.length;i++){var plan=plans[i];this.buildPlan(plan);}};UBuilderSceneDelayCombineParser.prototype.buildPlan=function buildPlan(plan){var plcProcessors=plan.placementCombineProcessors;var wallProcessors=plan.straightManualWallCombineProcessors;var modelWallProcessors=plan.modelWallCombineProcessors;var floorProcessors=plan.floorCombineProcessors;var ceilingProcessors=plan.ceilingCombineProcessors;var roofProcessors=plan.roofCombineProcessors;var doorOrWinProcessors=plan.doorOrWindowCombineProcessors;var uncombineWithHeightRooms=plan.uncombineWithHeigthRooms;// var floor = key;\n// delayBuildProcessor(plcProcessors, plan.combinePlacements);\n// delayBuildProcessor(wallProcessors, plan.combineStraightManualWalls);\n// delayBuildProcessor(modelWallProcessors, plan.combineModelWalls);\n// delayBuildProcessor(plcProcessors,plan.combinePlacements);\nfor(var j=0;j<ceilingProcessors.length;j++){var processor=ceilingProcessors[j];processor.build();var mesh=processor.combineMesh;plan.combineCeilings.push(mesh);}for(var j=0;j<roofProcessors.length;j++){var processor=roofProcessors[j];processor.build();var mesh=processor.combineMesh;plan.combineRoofs.push(mesh);}for(var i=0;i<uncombineWithHeightRooms.length;i++){var room=uncombineWithHeightRooms[i];var roomPos=room.position;if(room.floor.mesh){room.floor.mesh.position.add(roomPos);}if(room.ceiling.mesh){room.ceiling.mesh.position.add(roomPos);}if(room.roof.mesh){room.roof.mesh.position.add(roomPos);}plan.combineFloors.push(room.floor.mesh);if(room.ceiling.mesh){plan.combineCeilings.push(room.ceiling.mesh);}if(room.roof.mesh){plan.combineRoofs.push(room.roof.mesh);}}for(var j=0;j<floorProcessors.length;j++){var processor=floorProcessors[j];processor.build();var mesh=processor.combineMesh;plan.combineFloors.push(mesh);}//\nfor(var j=0;j<plcProcessors.length;j++){var processor=plcProcessors[j];processor.build();plan.combinePlacements.push(processor.combineMesh);}//\nfor(var j=0;j<doorOrWinProcessors.length;j++){var processor=doorOrWinProcessors[j];processor.build();plan.combineDoorOrWins.push(processor.combineMesh);}for(var j=0;j<wallProcessors.length;j++){var processor=wallProcessors[j];processor.build();var mesh=processor.combineMesh;plan.combineStraightManualWalls.push(mesh);}for(var j=0;j<modelWallProcessors.length;j++){var processor=modelWallProcessors[j];processor.build();// var meshs = processor.combineMeshs;\n// if(meshs.length>0){\n//     for (var i = 0; i < meshs.length; i++) {\n//         var mesh = meshs[i];\n//         plan.combinePlacements.push(mesh);\n//     }\n// }\nvar mesh=processor.combineMesh;plan.combineModelWalls.push(mesh);}};return UBuilderSceneDelayCombineParser;}();/**\r\n\t * CombineMeshProcessor\r\n\t * @author pzx\r\n\t * @ignore\r\n\t */var BaseDelayCombineProcessor=function(){function BaseDelayCombineProcessor(resource,combineManager,plan){classCallCheck(this,BaseDelayCombineProcessor);this.vertexCount=0;this.indexCount=0;this.resource=resource;this.bundeMeshs=[];//对应的mesh的相对仿射信息\nthis.transformations=[];this.maxCount=65534;this.combineMesh=new THREE.Object3D();this.combineManager=combineManager;this.plan=plan;// this.combineManager.processors.push(this);\n}BaseDelayCombineProcessor.prototype.isExceed=function isExceed(num){var count=this.vertexCount+num;if(count>this.maxCount){return true;}else{return false;}};BaseDelayCombineProcessor.prototype.build=function build(){};BaseDelayCombineProcessor.prototype.resourceCallback=function resourceCallback(resource){this.combineMesh.material=resource.material;};return BaseDelayCombineProcessor;}();/**\r\n\t * CombineMeshProcessor\r\n\t * @author pzx\r\n\t * @ignore\r\n\t */var DelayCombineFloorProcessor=function(_BaseDelayCombineProc){inherits(DelayCombineFloorProcessor,_BaseDelayCombineProc);function DelayCombineFloorProcessor(resource,combineManager){classCallCheck(this,DelayCombineFloorProcessor);//mesh的相关信息，但不是mesh对象\nvar _this=possibleConstructorReturn(this,_BaseDelayCombineProc.call(this,resource,combineManager));_this.meshInfos=[];_this.geometrys=[];return _this;}DelayCombineFloorProcessor.prototype.add=function add(geometry){this.geometrys.push(geometry);};DelayCombineFloorProcessor.prototype.resourceCallback=function resourceCallback(resource){this.combineMesh.material=resource.roomMaterial;this.combineMesh.material.side=THREE.DoubleSide;};DelayCombineFloorProcessor.prototype.build=function build(){var material=null;if(this.resource.ready){material=this.resource.roomMaterial;}else{material=new THREE.MeshBasicMaterial();this.resource.registerListener(this);}material.side=THREE.DoubleSide;var combineGeometry=new THREE.Geometry();for(var i=0;i<this.geometrys.length;i++){var geometry=this.geometrys[i];combineGeometry.merge(geometry);}var combineMesh=new THREE.Mesh(combineGeometry,material);combineMesh.name="combine";combineMesh.rotateX(-Math.PI/2);// combineMesh.position.y = 0.1;\nthis.combineMesh=combineMesh;this.combineMesh.name="floor";};return DelayCombineFloorProcessor;}(BaseDelayCombineProcessor);/**\r\n\t * CombineMeshProcessor\r\n\t * @author pzx\r\n\t * @ignore\r\n\t */var DelayCombineCeilingProcessor=function(_BaseDelayCombineProc){inherits(DelayCombineCeilingProcessor,_BaseDelayCombineProc);function DelayCombineCeilingProcessor(resource,combineManager){classCallCheck(this,DelayCombineCeilingProcessor);//mesh的相关信息，但不是mesh对象\nvar _this=possibleConstructorReturn(this,_BaseDelayCombineProc.call(this,resource,combineManager));_this.meshInfos=[];_this.geometrys=[];_this.height=3;return _this;}DelayCombineCeilingProcessor.prototype.add=function add(geometry){this.geometrys.push(geometry);};DelayCombineCeilingProcessor.prototype.resourceCallback=function resourceCallback(resource){this.combineMesh.material=resource.roomMaterial;// this.combineMesh.material.side = THREE.DoubleSide;\n};DelayCombineCeilingProcessor.prototype.build=function build(){var material=null;if(this.resource.ready){material=this.resource.roomMaterial;}else{material=new THREE.MeshBasicMaterial({color:0xffffff});this.resource.registerListener(this);}var combineGeometry=new THREE.Geometry();for(var i=0;i<this.geometrys.length;i++){var geometry=this.geometrys[i];combineGeometry.merge(geometry);}var combineMesh=new THREE.Mesh(combineGeometry,material);combineMesh.name="combine";combineMesh.rotateX(Math.PI/2);combineMesh.position.y=this.height;this.combineMesh=combineMesh;this.combineMesh.name="ceiling";};return DelayCombineCeilingProcessor;}(BaseDelayCombineProcessor);/**\r\n\t * CombineMeshProcessor\r\n\t * @author pzx\r\n\t * @ignore\r\n\t */var DelayCombineRoofProcessor=function(_BaseDelayCombineProc){inherits(DelayCombineRoofProcessor,_BaseDelayCombineProc);function DelayCombineRoofProcessor(resource,combineManager){classCallCheck(this,DelayCombineRoofProcessor);//mesh的相关信息，但不是mesh对象\nvar _this=possibleConstructorReturn(this,_BaseDelayCombineProc.call(this,resource,combineManager));_this.meshInfos=[];_this.geometrys=[];_this.height=3;return _this;}DelayCombineRoofProcessor.prototype.add=function add(geometry){this.geometrys.push(geometry);};DelayCombineRoofProcessor.prototype.resourceCallback=function resourceCallback(resource){this.combineMesh.material=resource.roomMaterial;// this.combineMesh.material.side = THREE.DoubleSide;\n};DelayCombineRoofProcessor.prototype.build=function build(){var material=null;if(this.resource.ready){material=this.resource.roomMaterial;}else{material=new THREE.MeshBasicMaterial();this.resource.registerListener(this);}var combineGeometry=new THREE.Geometry();for(var i=0;i<this.geometrys.length;i++){var geometry=this.geometrys[i];combineGeometry.merge(geometry);}var combineMesh=new THREE.Mesh(combineGeometry,material);combineMesh.name="combine";combineMesh.rotateX(-Math.PI/2);combineMesh.position.y=this.height+0.01;this.combineMesh=combineMesh;this.combineMesh.name="roof";};return DelayCombineRoofProcessor;}(BaseDelayCombineProcessor);/**\r\n\t * CombineMeshProcessor\r\n\t * @author pzx\r\n\t * @ignore\r\n\t */var DelayCombineStraightManualWallProcessor=function(_BaseDelayCombineProc){inherits(DelayCombineStraightManualWallProcessor,_BaseDelayCombineProc);function DelayCombineStraightManualWallProcessor(resource,combineManager,plan){classCallCheck(this,DelayCombineStraightManualWallProcessor);//mesh的相关信息，但不是mesh对象\nvar _this=possibleConstructorReturn(this,_BaseDelayCombineProc.call(this,resource,combineManager,plan));_this.meshInfos=[];return _this;}DelayCombineStraightManualWallProcessor.prototype.add=function add(meshInfo){if(this.isExceed(meshInfo.indexArray.length)){console.error("combine exceed vertex count ");return false;}this.vertexCount+=meshInfo.indexArray.length;this.indexCount+=meshInfo.indexArray.length;this.meshInfos.push(meshInfo);};DelayCombineStraightManualWallProcessor.prototype.build=function build(){var material=null;if(this.resource.ready){material=this.resource.material;}else{// material = new THREE.MeshStandardMaterial({color: 0xffffff});\nmaterial=new THREE.MeshBasicMaterial({color:0xffffff});this.resource.registerListener(this);}var oneMaxArray=this.meshInfos;var idxCount=this.indexCount;// oneMaxArray.pop();\nvar count=this.vertexCount;//oneMaxArray.pop();\nvar sumPosArr=new Float32Array(count*3);var sumNormArr=new Float32Array(count*3);var sumUvArr=new Float32Array(count*2);var sumColorArr=new Float32Array(count*4);var sumUv2Arr=new Float32Array(count*2);var sumIdxArr=new Uint16Array(idxCount);var sumPosCursor=0;var sumNormCursor=0;var sumUvCursor=0;var sumIdxCursor=0;var sumColorCursor=0;var combineGeometry=new THREE.BufferGeometry();for(var j=0;j<oneMaxArray.length;j++){var meshInfo=oneMaxArray[j];var parentPos=meshInfo.parentPosition;var idxAttArr=meshInfo.indexArray;// obj.geometry.index.array;\nfor(var b=0;b<idxAttArr.length;b++){sumIdxArr[b+sumIdxCursor]=sumPosCursor/3+idxAttArr[b];}sumIdxCursor+=idxAttArr.length;var posAttArr=meshInfo.positionArray;// obj.geometry.getAttribute(\'position\').array;\nfor(var b=0;b<posAttArr.length;){var vec=new THREE.Vector3(posAttArr[b]+parentPos.x,posAttArr[b+1]+parentPos.y,posAttArr[b+2]+parentPos.z);sumPosArr[b+sumPosCursor]=vec.x;sumPosArr[b+sumPosCursor+1]=vec.y;sumPosArr[b+sumPosCursor+2]=vec.z;b+=3;}sumPosCursor+=posAttArr.length;var numAttArr=meshInfo.normalArray;// obj.geometry.getAttribute(\'normal\').array;\n// for (var b = 0; b < numAttArr.length; b++) {\n//     sumNormArr[b + sumNormCursor] = numAttArr[b];\n// }\nfor(var b=0;b<numAttArr.length;){// var vec = new THREE.Vector3(posAttArr[b], posAttArr[b + 1], posAttArr[b + 2]);\nvar normal=new THREE.Vector3(numAttArr[b],numAttArr[b+1],numAttArr[b+2]);// for(var i = localRots.length-1;i>-1;i--){\n//     // var pos = localPositions[i];\n//     // var scale = localScales[i];\n//     var rot = localRots[i];\n//     normal = normal.applyQuaternion(rot);\n// }\nsumNormArr[b+sumNormCursor]=normal.x;sumNormArr[b+sumNormCursor+1]=normal.y;sumNormArr[b+sumNormCursor+2]=normal.z;b+=3;}sumNormCursor+=numAttArr.length;var uvAttArr=meshInfo.uvArray;// obj.geometry.getAttribute(\'uv\').array;\nif(uvAttArr){for(var b=0;b<uvAttArr.length;b++){sumUvArr[b+sumUvCursor]=uvAttArr[b];}}var uv2AttrArr=meshInfo.uv2Array;if(uv2AttrArr){for(var b=0;b<uv2AttrArr.length;b++){sumUv2Arr[b+sumUvCursor]=uv2AttrArr[b];}}if(uvAttArr){sumUvCursor+=uvAttArr.length;}var colorAttrArr=meshInfo.colorArray;if(colorAttrArr){for(var b=0;b<colorAttrArr.length;b++){sumColorArr[b+sumColorCursor]=colorAttrArr[b];}sumColorCursor+=colorAttrArr.length;}}combineGeometry.addAttribute(\'position\',new THREE.BufferAttribute(sumPosArr,3));combineGeometry.addAttribute(\'normal\',new THREE.BufferAttribute(sumNormArr,3));combineGeometry.addAttribute(\'uv\',new THREE.BufferAttribute(sumUvArr,2));if(sumUv2Arr.length!==0){combineGeometry.addAttribute(\'uv2\',new THREE.BufferAttribute(sumUv2Arr,2));}if(sumColorArr.length!==0){combineGeometry.addAttribute("color",new THREE.BufferAttribute(sumColorArr,4));}combineGeometry.setIndex(new THREE.BufferAttribute(sumIdxArr,1));var combineMesh=new THREE.Mesh(combineGeometry,material);combineMesh.name="combine";this.combineMesh=combineMesh;// combineNodes.push(combineMesh);\nthis.combineMesh.name="manualWall";};DelayCombineStraightManualWallProcessor.prototype.resourceCallback=function resourceCallback(resource){var material=null;if(DefaultSetting.enableManaulWallLightMap){if(resource.wallLightMaterial){material=resource.wallLightMaterial;}else{material=resource.material;}}else{material=resource.material;}this.combineMesh.material=material;};return DelayCombineStraightManualWallProcessor;}(BaseDelayCombineProcessor);/**\r\n\t * CombineMeshProcessor\r\n\t * @author pzx\r\n\t * @ignore\r\n\t */var DelayCombineModelWallProcessor=function(_BaseDelayCombineProc){inherits(DelayCombineModelWallProcessor,_BaseDelayCombineProc);function DelayCombineModelWallProcessor(resource,combineManager,plan){classCallCheck(this,DelayCombineModelWallProcessor);//mesh的相关信息，但不是mesh对象\nvar _this=possibleConstructorReturn(this,_BaseDelayCombineProc.call(this,resource,combineManager,plan));_this.meshInfos=[];_this.walls=[];_this.combineProcessorMap=new Map();_this.combineProcessors=[];// this.combineMeshs = [];\nreturn _this;}DelayCombineModelWallProcessor.prototype.add=function add(wall){this.walls.push(wall);};DelayCombineModelWallProcessor.prototype.build=function build(){if(!this.resource.ready){this.resource.registerListener(this);return;}if(!this.resource.isCombine){this.resource.combine();}for(var j=0;j<this.walls.length;j++){var wall=this.walls[j];wall.build();var map=this.combineProcessorMap;// this.floorMaterialMap.get(floor);\nvar list=this.combineProcessors;var combineBundleObj=this.resource.combineBundleObj;for(var i=0;i<wall.modelNumber;i++){var pos=wall.objPositions[i];var rot=wall.objRotations[i];var scale=wall.objScales[i];var transformation=new Transformation();transformation.positions.push(pos);transformation.scales.push(scale);transformation.quaternions.push(rot);var bundleMaterialMap=combineBundleObj.materialMap;//遍历材质的map，根据mesh的顶点数，创建或者添加到processor\nbundleMaterialMap.forEach(function(value,key,orgMap){var combineMeshList=value;var material=key;for(var i=0;i<combineMeshList.length;i++){var combineMesh=combineMeshList[i];var processor=map.get(material);//如果没有，或者超过顶点数\nif(!processor||processor.isExceed(combineMesh.vertexCount)){processor=new CombineMeshProcessor$1(material,this);map.set(material,processor);list.push(processor);}processor.add(combineMesh,transformation);}});}}for(var i=0;i<this.combineProcessors.length;i++){var processor=this.combineProcessors[i];processor.build();this.combineMesh.add(processor.combineMesh);}// if(this.plan){\n//     this.plan.combineModelWalls = this.plan.combineModelWalls.concat(this.combineMeshs);\n// }\n};DelayCombineModelWallProcessor.prototype.resourceCallback=function resourceCallback(resource){this.build();};return DelayCombineModelWallProcessor;}(BaseDelayCombineProcessor);/**\r\n\t * CombineMeshProcessor\r\n\t * @author pzx\r\n\t * @ignore\r\n\t */var DelayCombinePlacementProcessor=function(_BaseDelayCombineProc){inherits(DelayCombinePlacementProcessor,_BaseDelayCombineProc);function DelayCombinePlacementProcessor(resource,manager,plan){classCallCheck(this,DelayCombinePlacementProcessor);var _this=possibleConstructorReturn(this,_BaseDelayCombineProc.call(this,resource,manager,plan));_this.placements=[];_this.transformations=[];_this.combineProcessorMap=new Map();_this.combineProcessors=[];_this.combineMeshs=[];return _this;}DelayCombinePlacementProcessor.prototype.add=function add(plc,transformation){this.placements.push(plc);this.transformations.push(transformation);};DelayCombinePlacementProcessor.prototype.build=function build(){if(!this.resource.ready){this.resource.registerListener(this);return;}if(!this.resource.isCombine){this.resource.combine();}if(!this.resource.combineBundleObj&&this.resource.isCombine)return;if(this.resource.isCombine){this.combinePlacements();}else{if(this.resource.model){this.instancePlacements();}}};DelayCombinePlacementProcessor.prototype.instancePlacements=function instancePlacements(){for(var j=0;j<this.placements.length;j++){var placement=this.placements[j];placement.initResource();placement.instanceModel();var trans=this.transformations[j];var child=null;if(trans){for(var k=trans.positions.length-1;k>-1;k--){var curObj=new THREE.Object3D();var pos=trans.positions[k];var scale=trans.scales[k];var rot=trans.quaternions[k];curObj.position.set(pos.x,pos.y,pos.z);curObj.scale.set(scale.x,scale.y,scale.z);curObj.quaternion.set(rot.x,rot.y,rot.z,rot.w);if(child!==null){curObj.add(child);}else{curObj.add(placement.mesh);}child=curObj;}}else{child=placement.mesh;}// child.add(placement.mesh);\n// placement.mesh.parent = child;\n// for (var k = trans.positions.length-1; k >-1; k--) {\n//     var pos = trans.positions[k];\n//     var scale = trans.scales[k];\n//     var rot = trans.quaternions[k];\n//     var plcPos = placement.mesh.position;\n//     plcPos.add(pos);\n//     var plcScale = placement.mesh.scale;\n//     plcScale.multiply(scale);\n//     var plcRot = placement.mesh.quaternion;\n//     plcRot.multiply(plcRot);\n//\n//     placement.mesh.scale.set(plcScale.x,plcScale.y,plcScale.z);\n//     placement.mesh.quaternion.set(plcRot.x,plcRot.y,plcRot.z,plcRot.w);\n//     placement.mesh.position.set(plcPos.x,plcPos.y,plcPos.z);\n//\n// }\nthis.combineMesh.add(child);}};DelayCombinePlacementProcessor.prototype.combinePlacements=function combinePlacements(){for(var j=0;j<this.placements.length;j++){var placement=this.placements[j];var transformation=this.transformations[j];if(transformation===undefined){transformation=new Transformation();}var map=this.combineProcessorMap;// this.floorMaterialMap.get(floor);\nvar list=this.combineProcessors;var combineBundleObj=this.resource.combineBundleObj;transformation.positions.push(placement.position);transformation.scales.push(placement.scale);transformation.quaternions.push(placement.rotation);//获取合并过的bundle对象\n// var combineBundleObj = this.combineBundleObjectMap[placement.resource.id];\n//获取bundle合并过的mesh的map\nvar bundleMaterialMap=combineBundleObj.materialMap;//遍历材质的map，根据mesh的顶点数，创建或者添加到processor\nbundleMaterialMap.forEach(function(value,key,orgMap){var combineMeshList=value;var material=key;for(var i=0;i<combineMeshList.length;i++){var combineMesh=combineMeshList[i];var processor=map.get(material);//如果没有，或者超过顶点数\nif(!processor||processor.isExceed(combineMesh.vertexCount)){processor=new CombineMeshProcessor$1(material,this);map.set(material,processor);list.push(processor);}processor.add(combineMesh,transformation);}});}for(var i=0;i<this.combineProcessors.length;i++){var processor=this.combineProcessors[i];processor.build();this.combineMesh.add(processor.combineMesh);}};DelayCombinePlacementProcessor.prototype.resourceCallback=function resourceCallback(resource){this.build();};return DelayCombinePlacementProcessor;}(BaseDelayCombineProcessor);// import {CombineBundleObject} from "./DelayCombineBundleObject";\n// import {CombineMeshProcessor} from "./DelayCombineMeshProcessor";\n//\n/**\r\n\t * CombineManager\r\n\t * @author pzx\r\n\t * @ignore\r\n\t */var DelayCombineManager=function(){function DelayCombineManager(resourceManager){classCallCheck(this,DelayCombineManager);this.resourceManager=resourceManager;this.combineBundleObjectMap={};this.processors=[];}DelayCombineManager.prototype.combineModels=function combineModels(){var modelMap=this.resourceManager.models;var results=[];var that=this;var maxTime=0.1;var waitTime=10;for(var key in modelMap){results.push(new Promise(function(resolve,reject){var loadStartTime=performance.now();var resource=modelMap[key];var combineBundleObj=new CombineBundleObject(resource.model);that.combineBundleObjectMap[resource.id]=combineBundleObj;combineBundleObj.combine();var elapseTime=performance.now()-loadStartTime;// console.log(elapseTime+"==========");\nif(elapseTime>maxTime){setTimeout(function(){// console.log("combine");\nresolve();},waitTime);}else{resolve();}// resolve();\n}));}return Promise.all(results);};DelayCombineManager.prototype.getModelObject=function getModelObject(bundleId){var combineBundleObj=this.combineBundleObjectMap[bundleId];if(combineBundleObj){return combineBundleObj;}else{return null;}};// addGroup(group, plan, transformation) {\n//     var map = plan.curPlacementCombineProcessorMap;// this.floorMaterialMap.get(floor);\n//     var list = plan.placementCombineProcessors;\n//     if (!transformation) {\n//         transformation = new Transformation();\n//\n//         // transformation.positions.push(plan.worldPosition);\n//         // transformation.scales.push(plan.scale);\n//         // transformation.quaternions.push(plan.rotation);\n//     }\n//     transformation.positions.push(group.position);\n//     transformation.scales.push(group.scale);\n//     transformation.quaternions.push(group.rotation);\n//\n//     for (var i = 0; i < group.placements.length; i++) {\n//         var plc = group.placements[i];\n//         this.addPlacement(plc, plan, transformation.clone());\n//     }\n//\n//     for (var i = 0; i < group.groups.length; i++) {\n//         var childGroup = group.groups[i];\n//         this.addGroup(childGroup, plan, transformation.clone());\n//     }\n// }\nDelayCombineManager.prototype.addDoorOrWindow=function addDoorOrWindow(doorOrWin,plan,transformation){// var map = plan.curPlacementCombineProcessorMap;// this.floorMaterialMap.get(floor);\n// var processors = plan.placementCombineProcessors;\nvar map=plan.curDoorOrWinCombineProcessorMap;// this.floorMaterialMap.get(floor);\nvar processors=plan.doorOrWindowCombineProcessors;var resource=doorOrWin.resource;this.resourceManager.addPlacementResource(resource);var processor=map.get(resource);if(!processor){processor=new DelayCombinePlacementProcessor(resource,this,plan);processors.push(processor);map.set(resource,processor);}processor.add(doorOrWin,transformation);};// addPlacement(placement, plan, transformation) {\n//     var map = plan.curPlacementCombineProcessorMap;// this.floorMaterialMap.get(floor);\n//     var list = plan.placementCombineProcessors;\n//\n//     if (!transformation) {\n//         transformation = new Transformation();\n//\n//         // transformation.positions.push(plan.worldPosition);\n//         // transformation.scales.push(plan.scale);\n//         // transformation.quaternions.push(plan.rotation);\n//     }\n//\n//     transformation.positions.push(placement.position);\n//     transformation.scales.push(placement.scale);\n//     transformation.quaternions.push(placement.rotation);\n//     //获取合并过的bundle对象\n//     var combineBundleObj = this.combineBundleObjectMap[placement.resource.id];\n//     //获取bundle合并过的mesh的map\n//     var bundleMaterialMap = combineBundleObj.materialMap;\n//     //遍历材质的map，根据mesh的顶点数，创建或者添加到processor\n//     bundleMaterialMap.forEach(function (value, key, orgMap) {\n//         var combineMeshList = value;\n//         var material = key;\n//         for (var i = 0; i < combineMeshList.length; i++) {\n//             var combineMesh = combineMeshList[i];\n//             var processor = map.get(material);\n//             //如果没有，或者超过顶点数\n//             if (!processor || processor.isExceed(combineMesh.vertexCount)) {\n//                 processor = new CombineMeshProcessor(material, this);\n//                 map.set(material, processor);\n//                 list.push(processor)\n//             }\n//             processor.add(combineMesh, transformation);\n//         }\n//\n//     })\n//\n// }\nDelayCombineManager.prototype.addStraightManualWall=function addStraightManualWall(wall,plan){var map=plan.curStraightManualWallCombineProcessorMap;var list=plan.straightManualWallCombineProcessors;wall.build();var rightMeshInfo=wall.rightSideMeshInfo;var leftMeshInfo=wall.leftSideMeshInfo;var edgeMeshInfo=wall.edgeSideMeshInfo;this.addWallMeshInfo(rightMeshInfo,wall.position,map,list,plan);this.addWallMeshInfo(leftMeshInfo,wall.position,map,list,plan);this.addWallMeshInfo(edgeMeshInfo,wall.position,map,list,plan);};DelayCombineManager.prototype.addModelWall=function addModelWall(wall,plan){var map=plan.curModelWallCombineProcessorMap;// this.floorMaterialMap.get(floor);\nvar processors=plan.modelWallCombineProcessors;var resource=wall.resource;this.resourceManager.addWallModelResource(resource);var processor=map.get(resource);if(!processor){processor=new DelayCombineModelWallProcessor(resource,this,plan);processors.push(processor);map.set(resource,processor);}processor.add(wall);};DelayCombineManager.prototype.addRoom=function addRoom(room,plan){if(room.floor.isShow){this.addRoomShapeGeometry(room.floorResource,room.floor.geometry,room.floor.height,DelayCombineFloorProcessor,plan.curFloorCombineProcessorMap,plan.floorCombineProcessors);}if(!room.isOnlyFloor){if(room.ceiling.isShow){this.addRoomShapeGeometry(room.ceilingResource,room.ceiling.geometry,room.ceiling.height,DelayCombineCeilingProcessor,plan.curCeilingCombineProcessorMap,plan.ceilingCombineProcessors);}if(room.roof.isShow){this.addRoomShapeGeometry(room.roofResource,room.roof.geometry,room.roof.height,DelayCombineRoofProcessor,plan.curRoofCombineProcessorMap,plan.roofCombineProcessors);}}};DelayCombineManager.prototype.addPlacement=function addPlacement(plc,plan,transformation){var map=plan.curPlacementCombineProcessorMap;// this.floorMaterialMap.get(floor);\nvar processors=plan.placementCombineProcessors;var resource=plc.resource;this.resourceManager.addPlacementResource(resource);var processor=map.get(resource);if(!processor){processor=new DelayCombinePlacementProcessor(resource,this,plan);processors.push(processor);map.set(resource,processor);}processor.add(plc,transformation);};DelayCombineManager.prototype.addGroup=function addGroup(group,plan,transformation){if(!transformation){transformation=new Transformation();}transformation.positions.push(group.position);transformation.scales.push(group.scale);transformation.quaternions.push(group.rotation);for(var i=0;i<group.placements.length;i++){var plc=group.placements[i];if(plc.isShow){this.addPlacement(plc,plan,transformation.clone());}}for(var i=0;i<group.groups.length;i++){var childGroup=group.groups[i];if(childGroup.isShow){this.addGroup(childGroup,plan,transformation.clone());}}};DelayCombineManager.prototype.addWallMeshInfo=function addWallMeshInfo(meshInfo,position,curProcessorMap,processors,plan){var resource=meshInfo.resource;this.resourceManager.addWallTextureResource(resource);meshInfo.parentPosition=position;var processor=curProcessorMap.get(resource);if(!processor){processor=new DelayCombineStraightManualWallProcessor(resource,this,plan);processors.push(processor);curProcessorMap.set(resource,processor);}processor.add(meshInfo);};DelayCombineManager.prototype.addRoomShapeGeometry=function addRoomShapeGeometry(resource,geometry,height,classProcssor,curProcessorMap,processors){this.resourceManager.addRoomResource(resource);// meshInfo.parentPosition = position;\nvar id=resource.id+height;var processor=curProcessorMap.get(id);if(!processor){processor=new classProcssor(resource,this);processors.push(processor);processor.height=height;curProcessorMap.set(id,processor);}processor.add(geometry);};//启用的方法，只是给0.0版本用\nDelayCombineManager.prototype.getCombineProcessors=function getCombineProcessors(dataJson,posArray,scaleArray,rotArray){var list=[];var map=new Map();for(var t in dataJson){var data=dataJson[t];if(data["uid"]){continue;}if(data["name"]){continue;}var bundleID=this.app.modelResource.bundleIDArray[data["bIdx"]];var bundle=this.app.modelResource.get(bundleID).node;var pos=new THREE.Vector3(0,0,0);var transformation=new Transformation();if(data["pos"]){var posStrArray=data["pos"].split(" ");// var pos = new THREE.Vector3();\npos.x=parseFloat(posStrArray[0]);pos.y=parseFloat(posStrArray[1]);pos.z=-parseFloat(posStrArray[2]);// transformation.position = pos;\n}var scale=new THREE.Vector3(1,1,1);if(data["scl"]){var sclStrArray=data["scl"].split(" ");// var pos = new THREE.Vector3();\nscale.x=parseFloat(sclStrArray[0]);scale.y=parseFloat(sclStrArray[1]);scale.z=parseFloat(sclStrArray[2]);// transformation.scale = scale;\n}var quaternion=new THREE.Quaternion(0,0,0,1);if(data["rot"]){var rotStrArray=data["rot"].split(" ");// var pos = new THREE.Vector3();\nquaternion.x=parseFloat(rotStrArray[0]);quaternion.y=parseFloat(rotStrArray[1]);quaternion.z=-parseFloat(rotStrArray[2]);quaternion.w=-parseFloat(rotStrArray[3]);// transformation.quaternion = quaternion;\n}var localPosArray=posArray.slice();var localScaleArray=scaleArray.slice();var localRotArray=rotArray.slice();localRotArray.push(quaternion);localScaleArray.push(scale);localPosArray.push(pos);transformation.positions=localPosArray;transformation.scales=localScaleArray;transformation.quaternions=localRotArray;//获取合并过的bundle对象\nvar combineBundleObj=this.combineBundleObjectMap[bundleID];//获取bundle合并过的mesh的map\nvar bundleMaterialMap=combineBundleObj.materialMap;//遍历材质的map，根据mesh的顶点数，创建或者添加到processor\nbundleMaterialMap.forEach(function(value,key,orgMap){var combineMeshList=value;var material=key;for(var i=0;i<combineMeshList.length;i++){var combineMesh=combineMeshList[i];var processor=map.get(material);//如果没有，或者超过顶点数\nif(!processor||processor.isExceed(combineMesh.vertexCount)){processor=new CombineMeshProcessor(material);map.set(material,processor);list.push(processor);}processor.add(combineMesh,transformation);}});}return list;};return DelayCombineManager;}();/**\r\n\t * @author pzx 2018.4.2\r\n\t * Building\r\n\t */var Facade=function(_Placement){inherits(Facade,_Placement);function Facade(){classCallCheck(this,Facade);return possibleConstructorReturn(this,_Placement.call(this));}Facade.prototype.build=function build(){_Placement.prototype.build.call(this);};return Facade;}(Placement);/**\r\n\t * @author pzx 2018.8.2\r\n\t * CurveLine\r\n\t */var CurveLine=function(_BaseObject){inherits(CurveLine,_BaseObject);function CurveLine(){classCallCheck(this,CurveLine);var _this=possibleConstructorReturn(this,_BaseObject.call(this));_this.points=[];_this.resource=null;_this.color=null;_this.mesh=null;_this.texture=null;_this.initCompleteCallback=null;_this.width=null;return _this;}CurveLine.prototype.build=function build(){};CurveLine.prototype.initResource=function initResource(){if(this.resource){if(!this.resource.ready){this.resource.registerListener(this);}else{this.texture=this.resource.texture;}}};CurveLine.prototype.resourceCallback=function resourceCallback(resource){if(!this.mesh){this.texture=resource.texture;if(this.initCompleteCallback){this.initCompleteCallback(this);}}};return CurveLine;}(BaseObject);/**\r\n\t * @author pzx 2018.8.2\r\n\t * CurveLine\r\n\t */var PipeLine=function(_BaseObject){inherits(PipeLine,_BaseObject);function PipeLine(){classCallCheck(this,PipeLine);var _this=possibleConstructorReturn(this,_BaseObject.call(this));_this.points=[];_this.resource=null;_this.color=new THREE.Color(0,0,1);_this.mesh=null;_this.texture=null;_this.initCompleteCallback=null;_this.renderMode=null;_this.opacity=null;_this.radius=null;_this.sectionType=null;return _this;}PipeLine.prototype.build=function build(){};PipeLine.prototype.initResource=function initResource(){if(this.resource){if(!this.resource.ready){this.resource.registerListener(this);}else{this.texture=this.resource.texture;}}};PipeLine.prototype.resourceCallback=function resourceCallback(resource){if(!this.mesh){this.texture=resource.texture;if(this.initCompleteCallback){this.initCompleteCallback(this);}}};return PipeLine;}(BaseObject);/**\r\n\t * @author pzx 2018.4.2\r\n\t * Building\r\n\t */var FacadeGroup=function(_PlacementGroup){inherits(FacadeGroup,_PlacementGroup);function FacadeGroup(){classCallCheck(this,FacadeGroup);return possibleConstructorReturn(this,_PlacementGroup.call(this));}FacadeGroup.prototype.build=function build(){_PlacementGroup.prototype.build.call(this);};return FacadeGroup;}(PlacementGroup);/**\r\n\t * @author pzx 2018.8.2\r\n\t * CurveLine\r\n\t */var Text3D=function(_BaseObject){inherits(Text3D,_BaseObject);function Text3D(){classCallCheck(this,Text3D);var _this=possibleConstructorReturn(this,_BaseObject.call(this));_this.text=null;_this.color=null;_this.font=null;_this.opacity=null;_this.mesh=null;return _this;}Text3D.prototype.build=function build(){var geometry=new THREE.TextGeometry(this.text,{font:Text3D.getFont(),size:80,height:1,curveSegments:2});geometry.computeBoundingBox();var centerOffset=-0.5*(geometry.boundingBox.max.x-geometry.boundingBox.min.x);var materials=[new THREE.MeshBasicMaterial({color:Math.random()*0xffffff,overdraw:0.5}),new THREE.MeshBasicMaterial({color:0x000000,overdraw:0.5})];var mesh=new THREE.Mesh(geometry,materials);mesh.position.x=centerOffset;mesh.position.y=100;mesh.position.z=0;mesh.rotation.x=0;mesh.rotation.y=Math.PI*2;this.mesh=mesh;};Text3D.getFont=function getFont(){if(Text3D.font){return Text3D.font;}else return new THREE.Font({"glyphs":{"ο":{"x_min":0,"x_max":712,"ha":815,"o":"m 356 -25 q 96 88 192 -25 q 0 368 0 201 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 "},"S":{"x_min":0,"x_max":788,"ha":890,"o":"m 788 291 q 662 54 788 144 q 397 -26 550 -26 q 116 68 226 -26 q 0 337 0 168 l 131 337 q 200 152 131 220 q 384 85 269 85 q 557 129 479 85 q 650 270 650 183 q 490 429 650 379 q 194 513 341 470 q 33 739 33 584 q 142 964 33 881 q 388 1041 242 1041 q 644 957 543 1041 q 756 716 756 867 l 625 716 q 561 874 625 816 q 395 933 497 933 q 243 891 309 933 q 164 759 164 841 q 325 609 164 656 q 625 526 475 568 q 788 291 788 454 "},"¦":{"x_min":343,"x_max":449,"ha":792,"o":"m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 "},"/":{"x_min":183.25,"x_max":608.328125,"ha":792,"o":"m 608 1041 l 266 -129 l 183 -129 l 520 1041 l 608 1041 "},"Τ":{"x_min":-0.4375,"x_max":777.453125,"ha":839,"o":"m 777 893 l 458 893 l 458 0 l 319 0 l 319 892 l 0 892 l 0 1013 l 777 1013 l 777 893 "},"y":{"x_min":0,"x_max":684.78125,"ha":771,"o":"m 684 738 l 388 -83 q 311 -216 356 -167 q 173 -279 252 -279 q 97 -266 133 -279 l 97 -149 q 132 -155 109 -151 q 168 -160 155 -160 q 240 -114 213 -160 q 274 -26 248 -98 l 0 738 l 137 737 l 341 139 l 548 737 l 684 738 "},"Π":{"x_min":0,"x_max":803,"ha":917,"o":"m 803 0 l 667 0 l 667 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 803 1012 l 803 0 "},"ΐ":{"x_min":-111,"x_max":339,"ha":361,"o":"m 339 800 l 229 800 l 229 925 l 339 925 l 339 800 m -1 800 l -111 800 l -111 925 l -1 925 l -1 800 m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 m 302 1040 l 113 819 l 30 819 l 165 1040 l 302 1040 "},"g":{"x_min":0,"x_max":686,"ha":838,"o":"m 686 34 q 586 -213 686 -121 q 331 -306 487 -306 q 131 -252 216 -306 q 31 -84 31 -190 l 155 -84 q 228 -174 166 -138 q 345 -207 284 -207 q 514 -109 454 -207 q 564 89 564 -27 q 461 6 521 36 q 335 -23 401 -23 q 88 100 184 -23 q 0 370 0 215 q 87 634 0 522 q 330 758 183 758 q 457 728 398 758 q 564 644 515 699 l 564 737 l 686 737 l 686 34 m 582 367 q 529 560 582 481 q 358 652 468 652 q 189 561 250 652 q 135 369 135 482 q 189 176 135 255 q 361 85 251 85 q 529 176 468 85 q 582 367 582 255 "},"²":{"x_min":0,"x_max":442,"ha":539,"o":"m 442 383 l 0 383 q 91 566 0 492 q 260 668 176 617 q 354 798 354 727 q 315 875 354 845 q 227 905 277 905 q 136 869 173 905 q 99 761 99 833 l 14 761 q 82 922 14 864 q 232 974 141 974 q 379 926 316 974 q 442 797 442 878 q 351 635 442 704 q 183 539 321 611 q 92 455 92 491 l 442 455 l 442 383 "},"–":{"x_min":0,"x_max":705.5625,"ha":803,"o":"m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 "},"Κ":{"x_min":0,"x_max":819.5625,"ha":893,"o":"m 819 0 l 650 0 l 294 509 l 139 356 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 "},"ƒ":{"x_min":-46.265625,"x_max":392,"ha":513,"o":"m 392 651 l 259 651 l 79 -279 l -46 -278 l 134 651 l 14 651 l 14 751 l 135 751 q 151 948 135 900 q 304 1041 185 1041 q 334 1040 319 1041 q 392 1034 348 1039 l 392 922 q 337 931 360 931 q 271 883 287 931 q 260 793 260 853 l 260 751 l 392 751 l 392 651 "},"e":{"x_min":0,"x_max":714,"ha":813,"o":"m 714 326 l 140 326 q 200 157 140 227 q 359 87 260 87 q 488 130 431 87 q 561 245 545 174 l 697 245 q 577 48 670 123 q 358 -26 484 -26 q 97 85 195 -26 q 0 363 0 197 q 94 642 0 529 q 358 765 195 765 q 626 627 529 765 q 714 326 714 503 m 576 429 q 507 583 564 522 q 355 650 445 650 q 206 583 266 650 q 140 429 152 522 l 576 429 "},"ό":{"x_min":0,"x_max":712,"ha":815,"o":"m 356 -25 q 94 91 194 -25 q 0 368 0 202 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 m 576 1040 l 387 819 l 303 819 l 438 1040 l 576 1040 "},"J":{"x_min":0,"x_max":588,"ha":699,"o":"m 588 279 q 287 -26 588 -26 q 58 73 126 -26 q 0 327 0 158 l 133 327 q 160 172 133 227 q 288 96 198 96 q 426 171 391 96 q 449 336 449 219 l 449 1013 l 588 1013 l 588 279 "},"»":{"x_min":-1,"x_max":503,"ha":601,"o":"m 503 302 l 280 136 l 281 256 l 429 373 l 281 486 l 280 608 l 503 440 l 503 302 m 221 302 l 0 136 l 0 255 l 145 372 l 0 486 l -1 608 l 221 440 l 221 302 "},"©":{"x_min":-3,"x_max":1008,"ha":1106,"o":"m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 741 394 q 661 246 731 302 q 496 190 591 190 q 294 285 369 190 q 228 497 228 370 q 295 714 228 625 q 499 813 370 813 q 656 762 588 813 q 733 625 724 711 l 634 625 q 589 704 629 673 q 498 735 550 735 q 377 666 421 735 q 334 504 334 597 q 374 340 334 408 q 490 272 415 272 q 589 304 549 272 q 638 394 628 337 l 741 394 "},"ώ":{"x_min":0,"x_max":922,"ha":1030,"o":"m 687 1040 l 498 819 l 415 819 l 549 1040 l 687 1040 m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 338 0 202 q 45 551 0 444 q 161 737 84 643 l 302 737 q 175 552 219 647 q 124 336 124 446 q 155 179 124 248 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 341 797 257 q 745 555 797 450 q 619 737 705 637 l 760 737 q 874 551 835 640 q 922 339 922 444 "},"^":{"x_min":193.0625,"x_max":598.609375,"ha":792,"o":"m 598 772 l 515 772 l 395 931 l 277 772 l 193 772 l 326 1013 l 462 1013 l 598 772 "},"«":{"x_min":0,"x_max":507.203125,"ha":604,"o":"m 506 136 l 284 302 l 284 440 l 506 608 l 507 485 l 360 371 l 506 255 l 506 136 m 222 136 l 0 302 l 0 440 l 222 608 l 221 486 l 73 373 l 222 256 l 222 136 "},"D":{"x_min":0,"x_max":828,"ha":935,"o":"m 389 1013 q 714 867 593 1013 q 828 521 828 729 q 712 161 828 309 q 382 0 587 0 l 0 0 l 0 1013 l 389 1013 m 376 124 q 607 247 523 124 q 681 510 681 355 q 607 771 681 662 q 376 896 522 896 l 139 896 l 139 124 l 376 124 "},"∙":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 "},"ÿ":{"x_min":0,"x_max":47,"ha":125,"o":"m 47 3 q 37 -7 47 -7 q 28 0 30 -7 q 39 -4 32 -4 q 45 3 45 -1 l 37 0 q 28 9 28 0 q 39 19 28 19 l 47 16 l 47 19 l 47 3 m 37 1 q 44 8 44 1 q 37 16 44 16 q 30 8 30 16 q 37 1 30 1 m 26 1 l 23 22 l 14 0 l 3 22 l 3 3 l 0 25 l 13 1 l 22 25 l 26 1 "},"w":{"x_min":0,"x_max":1009.71875,"ha":1100,"o":"m 1009 738 l 783 0 l 658 0 l 501 567 l 345 0 l 222 0 l 0 738 l 130 738 l 284 174 l 432 737 l 576 738 l 721 173 l 881 737 l 1009 738 "},"$":{"x_min":0,"x_max":700,"ha":793,"o":"m 664 717 l 542 717 q 490 825 531 785 q 381 872 450 865 l 381 551 q 620 446 540 522 q 700 241 700 370 q 618 45 700 116 q 381 -25 536 -25 l 381 -152 l 307 -152 l 307 -25 q 81 62 162 -25 q 0 297 0 149 l 124 297 q 169 146 124 204 q 307 81 215 89 l 307 441 q 80 536 148 469 q 13 725 13 603 q 96 910 13 839 q 307 982 180 982 l 307 1077 l 381 1077 l 381 982 q 574 917 494 982 q 664 717 664 845 m 307 565 l 307 872 q 187 831 233 872 q 142 724 142 791 q 180 618 142 656 q 307 565 218 580 m 381 76 q 562 237 562 96 q 517 361 562 313 q 381 423 472 409 l 381 76 "},"\\\\":{"x_min":-0.015625,"x_max":425.0625,"ha":522,"o":"m 425 -129 l 337 -129 l 0 1041 l 83 1041 l 425 -129 "},"µ":{"x_min":0,"x_max":697.21875,"ha":747,"o":"m 697 -4 q 629 -14 658 -14 q 498 97 513 -14 q 422 9 470 41 q 313 -23 374 -23 q 207 4 258 -23 q 119 81 156 32 l 119 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 173 124 246 q 308 83 216 83 q 452 178 402 83 q 493 359 493 255 l 493 738 l 617 738 l 617 214 q 623 136 617 160 q 673 92 637 92 q 697 96 684 92 l 697 -4 "},"Ι":{"x_min":42,"x_max":181,"ha":297,"o":"m 181 0 l 42 0 l 42 1013 l 181 1013 l 181 0 "},"Ύ":{"x_min":0,"x_max":1144.5,"ha":1214,"o":"m 1144 1012 l 807 416 l 807 0 l 667 0 l 667 416 l 325 1012 l 465 1012 l 736 533 l 1004 1012 l 1144 1012 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"’":{"x_min":0,"x_max":139,"ha":236,"o":"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 "},"Ν":{"x_min":0,"x_max":801,"ha":915,"o":"m 801 0 l 651 0 l 131 822 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 191 l 670 1013 l 801 1013 l 801 0 "},"-":{"x_min":8.71875,"x_max":350.390625,"ha":478,"o":"m 350 317 l 8 317 l 8 428 l 350 428 l 350 317 "},"Q":{"x_min":0,"x_max":968,"ha":1072,"o":"m 954 5 l 887 -79 l 744 35 q 622 -11 687 2 q 483 -26 556 -26 q 127 130 262 -26 q 0 504 0 279 q 127 880 0 728 q 484 1041 262 1041 q 841 884 708 1041 q 968 507 968 735 q 933 293 968 398 q 832 104 899 188 l 954 5 m 723 191 q 802 330 777 248 q 828 499 828 412 q 744 790 828 673 q 483 922 650 922 q 228 791 322 922 q 142 505 142 673 q 227 221 142 337 q 487 91 323 91 q 632 123 566 91 l 520 215 l 587 301 l 723 191 "},"ς":{"x_min":1,"x_max":676.28125,"ha":740,"o":"m 676 460 l 551 460 q 498 595 542 546 q 365 651 448 651 q 199 578 263 651 q 136 401 136 505 q 266 178 136 241 q 508 106 387 142 q 640 -50 640 62 q 625 -158 640 -105 q 583 -278 611 -211 l 465 -278 q 498 -182 490 -211 q 515 -80 515 -126 q 381 12 515 -15 q 134 91 197 51 q 1 388 1 179 q 100 651 1 542 q 354 761 199 761 q 587 680 498 761 q 676 460 676 599 "},"M":{"x_min":0,"x_max":954,"ha":1067,"o":"m 954 0 l 819 0 l 819 869 l 537 0 l 405 0 l 128 866 l 128 0 l 0 0 l 0 1013 l 200 1013 l 472 160 l 757 1013 l 954 1013 l 954 0 "},"Ψ":{"x_min":0,"x_max":1006,"ha":1094,"o":"m 1006 678 q 914 319 1006 429 q 571 200 814 200 l 571 0 l 433 0 l 433 200 q 92 319 194 200 q 0 678 0 429 l 0 1013 l 139 1013 l 139 679 q 191 417 139 492 q 433 326 255 326 l 433 1013 l 571 1013 l 571 326 l 580 326 q 813 423 747 326 q 868 679 868 502 l 868 1013 l 1006 1013 l 1006 678 "},"C":{"x_min":0,"x_max":886,"ha":944,"o":"m 886 379 q 760 87 886 201 q 455 -26 634 -26 q 112 136 236 -26 q 0 509 0 283 q 118 882 0 737 q 469 1041 245 1041 q 748 955 630 1041 q 879 708 879 859 l 745 708 q 649 862 724 805 q 473 920 573 920 q 219 791 312 920 q 136 509 136 675 q 217 229 136 344 q 470 99 311 99 q 672 179 591 99 q 753 379 753 259 l 886 379 "},"!":{"x_min":0,"x_max":138,"ha":236,"o":"m 138 684 q 116 409 138 629 q 105 244 105 299 l 33 244 q 16 465 33 313 q 0 684 0 616 l 0 1013 l 138 1013 l 138 684 m 138 0 l 0 0 l 0 151 l 138 151 l 138 0 "},"{":{"x_min":0,"x_max":480.5625,"ha":578,"o":"m 480 -286 q 237 -213 303 -286 q 187 -45 187 -159 q 194 48 187 -15 q 201 141 201 112 q 164 264 201 225 q 0 314 118 314 l 0 417 q 164 471 119 417 q 201 605 201 514 q 199 665 201 644 q 193 772 193 769 q 241 941 193 887 q 480 1015 308 1015 l 480 915 q 336 866 375 915 q 306 742 306 828 q 310 662 306 717 q 314 577 314 606 q 288 452 314 500 q 176 365 256 391 q 289 275 257 337 q 314 143 314 226 q 313 84 314 107 q 310 -11 310 -5 q 339 -131 310 -94 q 480 -182 377 -182 l 480 -286 "},"X":{"x_min":-0.015625,"x_max":854.15625,"ha":940,"o":"m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 428 637 l 675 1013 l 836 1013 l 504 520 l 854 0 "},"#":{"x_min":0,"x_max":963.890625,"ha":1061,"o":"m 963 690 l 927 590 l 719 590 l 655 410 l 876 410 l 840 310 l 618 310 l 508 -3 l 393 -2 l 506 309 l 329 310 l 215 -2 l 102 -3 l 212 310 l 0 310 l 36 410 l 248 409 l 312 590 l 86 590 l 120 690 l 347 690 l 459 1006 l 573 1006 l 462 690 l 640 690 l 751 1006 l 865 1006 l 754 690 l 963 690 m 606 590 l 425 590 l 362 410 l 543 410 l 606 590 "},"ι":{"x_min":42,"x_max":284,"ha":361,"o":"m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 738 l 167 738 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 "},"Ά":{"x_min":0,"x_max":906.953125,"ha":982,"o":"m 283 1040 l 88 799 l 5 799 l 145 1040 l 283 1040 m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1012 l 529 1012 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 "},")":{"x_min":0,"x_max":318,"ha":415,"o":"m 318 365 q 257 25 318 191 q 87 -290 197 -141 l 0 -290 q 140 21 93 -128 q 193 360 193 189 q 141 704 193 537 q 0 1024 97 850 l 87 1024 q 257 706 197 871 q 318 365 318 542 "},"ε":{"x_min":0,"x_max":634.71875,"ha":714,"o":"m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 314 0 265 q 128 390 67 353 q 56 460 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 "},"Δ":{"x_min":0,"x_max":952.78125,"ha":1028,"o":"m 952 0 l 0 0 l 400 1013 l 551 1013 l 952 0 m 762 124 l 476 867 l 187 124 l 762 124 "},"}":{"x_min":0,"x_max":481,"ha":578,"o":"m 481 314 q 318 262 364 314 q 282 136 282 222 q 284 65 282 97 q 293 -58 293 -48 q 241 -217 293 -166 q 0 -286 174 -286 l 0 -182 q 143 -130 105 -182 q 171 -2 171 -93 q 168 81 171 22 q 165 144 165 140 q 188 275 165 229 q 306 365 220 339 q 191 455 224 391 q 165 588 165 505 q 168 681 165 624 q 171 742 171 737 q 141 865 171 827 q 0 915 102 915 l 0 1015 q 243 942 176 1015 q 293 773 293 888 q 287 675 293 741 q 282 590 282 608 q 318 466 282 505 q 481 417 364 417 l 481 314 "},"‰":{"x_min":-3,"x_max":1672,"ha":1821,"o":"m 846 0 q 664 76 732 0 q 603 244 603 145 q 662 412 603 344 q 846 489 729 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 846 0 962 0 m 845 103 q 945 143 910 103 q 981 243 981 184 q 947 340 981 301 q 845 385 910 385 q 745 342 782 385 q 709 243 709 300 q 742 147 709 186 q 845 103 781 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 m 1428 0 q 1246 76 1314 0 q 1185 244 1185 145 q 1244 412 1185 344 q 1428 489 1311 489 q 1610 412 1542 489 q 1672 244 1672 343 q 1612 76 1672 144 q 1428 0 1545 0 m 1427 103 q 1528 143 1492 103 q 1564 243 1564 184 q 1530 340 1564 301 q 1427 385 1492 385 q 1327 342 1364 385 q 1291 243 1291 300 q 1324 147 1291 186 q 1427 103 1363 103 "},"a":{"x_min":0,"x_max":698.609375,"ha":794,"o":"m 698 0 q 661 -12 679 -7 q 615 -17 643 -17 q 536 12 564 -17 q 500 96 508 41 q 384 6 456 37 q 236 -25 312 -25 q 65 31 130 -25 q 0 194 0 88 q 118 390 0 334 q 328 435 180 420 q 488 483 476 451 q 495 523 495 504 q 442 619 495 584 q 325 654 389 654 q 209 617 257 654 q 152 513 161 580 l 33 513 q 123 705 33 633 q 332 772 207 772 q 528 712 448 772 q 617 531 617 645 l 617 163 q 624 108 617 126 q 664 90 632 90 l 698 94 l 698 0 m 491 262 l 491 372 q 272 329 350 347 q 128 201 128 294 q 166 113 128 144 q 264 83 205 83 q 414 130 346 83 q 491 262 491 183 "},"—":{"x_min":0,"x_max":941.671875,"ha":1039,"o":"m 941 334 l 0 334 l 0 410 l 941 410 l 941 334 "},"=":{"x_min":8.71875,"x_max":780.953125,"ha":792,"o":"m 780 510 l 8 510 l 8 606 l 780 606 l 780 510 m 780 235 l 8 235 l 8 332 l 780 332 l 780 235 "},"N":{"x_min":0,"x_max":801,"ha":914,"o":"m 801 0 l 651 0 l 131 823 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 193 l 670 1013 l 801 1013 l 801 0 "},"ρ":{"x_min":0,"x_max":712,"ha":797,"o":"m 712 369 q 620 94 712 207 q 362 -26 521 -26 q 230 2 292 -26 q 119 83 167 30 l 119 -278 l 0 -278 l 0 362 q 91 643 0 531 q 355 764 190 764 q 617 647 517 764 q 712 369 712 536 m 583 366 q 530 559 583 480 q 359 651 469 651 q 190 562 252 651 q 135 370 135 483 q 189 176 135 257 q 359 85 250 85 q 528 175 466 85 q 583 366 583 254 "},"2":{"x_min":59,"x_max":731,"ha":792,"o":"m 731 0 l 59 0 q 197 314 59 188 q 457 487 199 315 q 598 691 598 580 q 543 819 598 772 q 411 867 488 867 q 272 811 328 867 q 209 630 209 747 l 81 630 q 182 901 81 805 q 408 986 271 986 q 629 909 536 986 q 731 694 731 826 q 613 449 731 541 q 378 316 495 383 q 201 122 235 234 l 731 122 l 731 0 "},"¯":{"x_min":0,"x_max":941.671875,"ha":938,"o":"m 941 1033 l 0 1033 l 0 1109 l 941 1109 l 941 1033 "},"Z":{"x_min":0,"x_max":779,"ha":849,"o":"m 779 0 l 0 0 l 0 113 l 621 896 l 40 896 l 40 1013 l 779 1013 l 778 887 l 171 124 l 779 124 l 779 0 "},"u":{"x_min":0,"x_max":617,"ha":729,"o":"m 617 0 l 499 0 l 499 110 q 391 10 460 45 q 246 -25 322 -25 q 61 58 127 -25 q 0 258 0 136 l 0 738 l 125 738 l 125 284 q 156 148 125 202 q 273 82 197 82 q 433 165 369 82 q 493 340 493 243 l 493 738 l 617 738 l 617 0 "},"k":{"x_min":0,"x_max":612.484375,"ha":697,"o":"m 612 738 l 338 465 l 608 0 l 469 0 l 251 382 l 121 251 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 402 l 456 738 l 612 738 "},"Η":{"x_min":0,"x_max":803,"ha":917,"o":"m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 "},"Α":{"x_min":0,"x_max":906.953125,"ha":985,"o":"m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 "},"s":{"x_min":0,"x_max":604,"ha":697,"o":"m 604 217 q 501 36 604 104 q 292 -23 411 -23 q 86 43 166 -23 q 0 238 0 114 l 121 237 q 175 122 121 164 q 300 85 223 85 q 415 112 363 85 q 479 207 479 147 q 361 309 479 276 q 140 372 141 370 q 21 544 21 426 q 111 708 21 647 q 298 761 190 761 q 492 705 413 761 q 583 531 583 643 l 462 531 q 412 625 462 594 q 298 657 363 657 q 199 636 242 657 q 143 558 143 608 q 262 454 143 486 q 484 394 479 397 q 604 217 604 341 "},"B":{"x_min":0,"x_max":778,"ha":876,"o":"m 580 546 q 724 469 670 535 q 778 311 778 403 q 673 83 778 171 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 892 q 691 633 732 693 q 580 546 650 572 m 393 899 l 139 899 l 139 588 l 379 588 q 521 624 462 588 q 592 744 592 667 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 303 635 219 q 559 436 635 389 q 402 477 494 477 l 139 477 l 139 124 l 419 124 "},"…":{"x_min":0,"x_max":614,"ha":708,"o":"m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 m 378 0 l 236 0 l 236 151 l 378 151 l 378 0 m 614 0 l 472 0 l 472 151 l 614 151 l 614 0 "},"?":{"x_min":0,"x_max":607,"ha":704,"o":"m 607 777 q 543 599 607 674 q 422 474 482 537 q 357 272 357 391 l 236 272 q 297 487 236 395 q 411 619 298 490 q 474 762 474 691 q 422 885 474 838 q 301 933 371 933 q 179 880 228 933 q 124 706 124 819 l 0 706 q 94 963 0 872 q 302 1044 177 1044 q 511 973 423 1044 q 607 777 607 895 m 370 0 l 230 0 l 230 151 l 370 151 l 370 0 "},"H":{"x_min":0,"x_max":803,"ha":915,"o":"m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 "},"ν":{"x_min":0,"x_max":675,"ha":761,"o":"m 675 738 l 404 0 l 272 0 l 0 738 l 133 738 l 340 147 l 541 738 l 675 738 "},"c":{"x_min":1,"x_max":701.390625,"ha":775,"o":"m 701 264 q 584 53 681 133 q 353 -26 487 -26 q 91 91 188 -26 q 1 370 1 201 q 92 645 1 537 q 353 761 190 761 q 572 688 479 761 q 690 493 666 615 l 556 493 q 487 606 545 562 q 356 650 428 650 q 186 563 246 650 q 134 372 134 487 q 188 179 134 258 q 359 88 250 88 q 492 136 437 88 q 566 264 548 185 l 701 264 "},"¶":{"x_min":0,"x_max":566.671875,"ha":678,"o":"m 21 892 l 52 892 l 98 761 l 145 892 l 176 892 l 178 741 l 157 741 l 157 867 l 108 741 l 88 741 l 40 871 l 40 741 l 21 741 l 21 892 m 308 854 l 308 731 q 252 691 308 691 q 227 691 240 691 q 207 696 213 695 l 207 712 l 253 706 q 288 733 288 706 l 288 763 q 244 741 279 741 q 193 797 193 741 q 261 860 193 860 q 287 860 273 860 q 308 854 302 855 m 288 842 l 263 843 q 213 796 213 843 q 248 756 213 756 q 288 796 288 756 l 288 842 m 566 988 l 502 988 l 502 -1 l 439 -1 l 439 988 l 317 988 l 317 -1 l 252 -1 l 252 602 q 81 653 155 602 q 0 805 0 711 q 101 989 0 918 q 309 1053 194 1053 l 566 1053 l 566 988 "},"β":{"x_min":0,"x_max":660,"ha":745,"o":"m 471 550 q 610 450 561 522 q 660 280 660 378 q 578 64 660 151 q 367 -22 497 -22 q 239 5 299 -22 q 126 82 178 32 l 126 -278 l 0 -278 l 0 593 q 54 903 0 801 q 318 1042 127 1042 q 519 964 436 1042 q 603 771 603 887 q 567 644 603 701 q 471 550 532 586 m 337 79 q 476 138 418 79 q 535 279 535 198 q 427 437 535 386 q 226 477 344 477 l 226 583 q 398 620 329 583 q 486 762 486 668 q 435 884 486 833 q 312 935 384 935 q 169 861 219 935 q 126 698 126 797 l 126 362 q 170 169 126 242 q 337 79 224 79 "},"Μ":{"x_min":0,"x_max":954,"ha":1068,"o":"m 954 0 l 819 0 l 819 868 l 537 0 l 405 0 l 128 865 l 128 0 l 0 0 l 0 1013 l 199 1013 l 472 158 l 758 1013 l 954 1013 l 954 0 "},"Ό":{"x_min":0.109375,"x_max":1120,"ha":1217,"o":"m 1120 505 q 994 132 1120 282 q 642 -29 861 -29 q 290 130 422 -29 q 167 505 167 280 q 294 883 167 730 q 650 1046 430 1046 q 999 882 868 1046 q 1120 505 1120 730 m 977 504 q 896 784 977 669 q 644 915 804 915 q 391 785 484 915 q 307 504 307 669 q 391 224 307 339 q 644 95 486 95 q 894 224 803 95 q 977 504 977 339 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"Ή":{"x_min":0,"x_max":1158,"ha":1275,"o":"m 1158 0 l 1022 0 l 1022 475 l 496 475 l 496 0 l 356 0 l 356 1012 l 496 1012 l 496 599 l 1022 599 l 1022 1012 l 1158 1012 l 1158 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"•":{"x_min":0,"x_max":663.890625,"ha":775,"o":"m 663 529 q 566 293 663 391 q 331 196 469 196 q 97 294 194 196 q 0 529 0 393 q 96 763 0 665 q 331 861 193 861 q 566 763 469 861 q 663 529 663 665 "},"¥":{"x_min":0.1875,"x_max":819.546875,"ha":886,"o":"m 563 561 l 697 561 l 696 487 l 520 487 l 482 416 l 482 380 l 697 380 l 695 308 l 482 308 l 482 0 l 342 0 l 342 308 l 125 308 l 125 380 l 342 380 l 342 417 l 303 487 l 125 487 l 125 561 l 258 561 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 l 563 561 "},"(":{"x_min":0,"x_max":318.0625,"ha":415,"o":"m 318 -290 l 230 -290 q 61 23 122 -142 q 0 365 0 190 q 62 712 0 540 q 230 1024 119 869 l 318 1024 q 175 705 219 853 q 125 360 125 542 q 176 22 125 187 q 318 -290 223 -127 "},"U":{"x_min":0,"x_max":796,"ha":904,"o":"m 796 393 q 681 93 796 212 q 386 -25 566 -25 q 101 95 208 -25 q 0 393 0 211 l 0 1013 l 138 1013 l 138 391 q 204 191 138 270 q 394 107 276 107 q 586 191 512 107 q 656 391 656 270 l 656 1013 l 796 1013 l 796 393 "},"γ":{"x_min":0.5,"x_max":744.953125,"ha":822,"o":"m 744 737 l 463 54 l 463 -278 l 338 -278 l 338 54 l 154 495 q 104 597 124 569 q 13 651 67 651 l 0 651 l 0 751 l 39 753 q 168 711 121 753 q 242 594 207 676 l 403 208 l 617 737 l 744 737 "},"α":{"x_min":0,"x_max":765.5625,"ha":809,"o":"m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 728 407 760 q 563 637 524 696 l 563 739 l 685 739 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 96 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 "},"F":{"x_min":0,"x_max":683.328125,"ha":717,"o":"m 683 888 l 140 888 l 140 583 l 613 583 l 613 458 l 140 458 l 140 0 l 0 0 l 0 1013 l 683 1013 l 683 888 "},"­":{"x_min":0,"x_max":705.5625,"ha":803,"o":"m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 "},":":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 "},"Χ":{"x_min":0,"x_max":854.171875,"ha":935,"o":"m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 427 637 l 675 1013 l 836 1013 l 504 521 l 854 0 "},"*":{"x_min":116,"x_max":674,"ha":792,"o":"m 674 768 l 475 713 l 610 544 l 517 477 l 394 652 l 272 478 l 178 544 l 314 713 l 116 766 l 153 876 l 341 812 l 342 1013 l 446 1013 l 446 811 l 635 874 l 674 768 "},"†":{"x_min":0,"x_max":777,"ha":835,"o":"m 458 804 l 777 804 l 777 683 l 458 683 l 458 0 l 319 0 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 "},"°":{"x_min":0,"x_max":347,"ha":444,"o":"m 173 802 q 43 856 91 802 q 0 977 0 905 q 45 1101 0 1049 q 173 1153 90 1153 q 303 1098 255 1153 q 347 977 347 1049 q 303 856 347 905 q 173 802 256 802 m 173 884 q 238 910 214 884 q 262 973 262 937 q 239 1038 262 1012 q 173 1064 217 1064 q 108 1037 132 1064 q 85 973 85 1010 q 108 910 85 937 q 173 884 132 884 "},"V":{"x_min":0,"x_max":862.71875,"ha":940,"o":"m 862 1013 l 505 0 l 361 0 l 0 1013 l 143 1013 l 434 165 l 718 1012 l 862 1013 "},"Ξ":{"x_min":0,"x_max":734.71875,"ha":763,"o":"m 723 889 l 9 889 l 9 1013 l 723 1013 l 723 889 m 673 463 l 61 463 l 61 589 l 673 589 l 673 463 m 734 0 l 0 0 l 0 124 l 734 124 l 734 0 "}," ":{"x_min":0,"x_max":0,"ha":853},"Ϋ":{"x_min":0.328125,"x_max":819.515625,"ha":889,"o":"m 588 1046 l 460 1046 l 460 1189 l 588 1189 l 588 1046 m 360 1046 l 232 1046 l 232 1189 l 360 1189 l 360 1046 m 819 1012 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1012 l 140 1012 l 411 533 l 679 1012 l 819 1012 "},"0":{"x_min":73,"x_max":715,"ha":792,"o":"m 394 -29 q 153 129 242 -29 q 73 479 73 272 q 152 829 73 687 q 394 989 241 989 q 634 829 545 989 q 715 479 715 684 q 635 129 715 270 q 394 -29 546 -29 m 394 89 q 546 211 489 89 q 598 479 598 322 q 548 748 598 640 q 394 871 491 871 q 241 748 298 871 q 190 479 190 637 q 239 211 190 319 q 394 89 296 89 "},"”":{"x_min":0,"x_max":347,"ha":454,"o":"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 m 347 851 q 310 737 347 784 q 208 669 273 690 l 208 734 q 267 787 250 741 q 280 873 280 821 l 208 873 l 208 1013 l 347 1013 l 347 851 "},"@":{"x_min":0,"x_max":1260,"ha":1357,"o":"m 1098 -45 q 877 -160 1001 -117 q 633 -203 752 -203 q 155 -29 327 -203 q 0 360 0 127 q 176 802 0 616 q 687 1008 372 1008 q 1123 854 969 1008 q 1260 517 1260 718 q 1155 216 1260 341 q 868 82 1044 82 q 772 106 801 82 q 737 202 737 135 q 647 113 700 144 q 527 82 594 82 q 367 147 420 82 q 314 312 314 212 q 401 565 314 452 q 639 690 498 690 q 810 588 760 690 l 849 668 l 938 668 q 877 441 900 532 q 833 226 833 268 q 853 182 833 198 q 902 167 873 167 q 1088 272 1012 167 q 1159 512 1159 372 q 1051 793 1159 681 q 687 925 925 925 q 248 747 415 925 q 97 361 97 586 q 226 26 97 159 q 627 -122 370 -122 q 856 -87 737 -122 q 1061 8 976 -53 l 1098 -45 m 786 488 q 738 580 777 545 q 643 615 700 615 q 483 517 548 615 q 425 322 425 430 q 457 203 425 250 q 552 156 490 156 q 722 273 665 156 q 786 488 738 309 "},"Ί":{"x_min":0,"x_max":499,"ha":613,"o":"m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 m 499 0 l 360 0 l 360 1012 l 499 1012 l 499 0 "},"i":{"x_min":14,"x_max":136,"ha":275,"o":"m 136 873 l 14 873 l 14 1013 l 136 1013 l 136 873 m 136 0 l 14 0 l 14 737 l 136 737 l 136 0 "},"Β":{"x_min":0,"x_max":778,"ha":877,"o":"m 580 545 q 724 468 671 534 q 778 310 778 402 q 673 83 778 170 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 891 q 691 632 732 692 q 580 545 650 571 m 393 899 l 139 899 l 139 587 l 379 587 q 521 623 462 587 q 592 744 592 666 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 302 635 219 q 559 435 635 388 q 402 476 494 476 l 139 476 l 139 124 l 419 124 "},"υ":{"x_min":0,"x_max":617,"ha":725,"o":"m 617 352 q 540 94 617 199 q 308 -24 455 -24 q 76 94 161 -24 q 0 352 0 199 l 0 739 l 126 739 l 126 355 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 355 492 257 l 492 739 l 617 739 l 617 352 "},"]":{"x_min":0,"x_max":275,"ha":372,"o":"m 275 -281 l 0 -281 l 0 -187 l 151 -187 l 151 920 l 0 920 l 0 1013 l 275 1013 l 275 -281 "},"m":{"x_min":0,"x_max":1019,"ha":1128,"o":"m 1019 0 l 897 0 l 897 454 q 860 591 897 536 q 739 660 816 660 q 613 586 659 660 q 573 436 573 522 l 573 0 l 447 0 l 447 455 q 412 591 447 535 q 294 657 372 657 q 165 586 213 657 q 122 437 122 521 l 122 0 l 0 0 l 0 738 l 117 738 l 117 640 q 202 730 150 697 q 316 763 254 763 q 437 730 381 763 q 525 642 494 697 q 621 731 559 700 q 753 763 682 763 q 943 694 867 763 q 1019 512 1019 625 l 1019 0 "},"χ":{"x_min":8.328125,"x_max":780.5625,"ha":815,"o":"m 780 -278 q 715 -294 747 -294 q 616 -257 663 -294 q 548 -175 576 -227 l 379 133 l 143 -277 l 9 -277 l 313 254 l 163 522 q 127 586 131 580 q 36 640 91 640 q 8 637 27 640 l 8 752 l 52 757 q 162 719 113 757 q 236 627 200 690 l 383 372 l 594 737 l 726 737 l 448 250 l 625 -69 q 670 -153 647 -110 q 743 -188 695 -188 q 780 -184 759 -188 l 780 -278 "},"8":{"x_min":55,"x_max":736,"ha":792,"o":"m 571 527 q 694 424 652 491 q 736 280 736 358 q 648 71 736 158 q 395 -26 551 -26 q 142 69 238 -26 q 55 279 55 157 q 96 425 55 359 q 220 527 138 491 q 120 615 153 562 q 88 726 88 668 q 171 904 88 827 q 395 986 261 986 q 618 905 529 986 q 702 727 702 830 q 670 616 702 667 q 571 527 638 565 m 394 565 q 519 610 475 565 q 563 717 563 655 q 521 823 563 781 q 392 872 474 872 q 265 824 312 872 q 224 720 224 783 q 265 613 224 656 q 394 565 312 565 m 395 91 q 545 150 488 91 q 597 280 597 204 q 546 408 597 355 q 395 465 492 465 q 244 408 299 465 q 194 280 194 356 q 244 150 194 203 q 395 91 299 91 "},"ί":{"x_min":42,"x_max":326.71875,"ha":361,"o":"m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 102 239 101 q 284 112 257 104 l 284 3 m 326 1040 l 137 819 l 54 819 l 189 1040 l 326 1040 "},"Ζ":{"x_min":0,"x_max":779.171875,"ha":850,"o":"m 779 0 l 0 0 l 0 113 l 620 896 l 40 896 l 40 1013 l 779 1013 l 779 887 l 170 124 l 779 124 l 779 0 "},"R":{"x_min":0,"x_max":781.953125,"ha":907,"o":"m 781 0 l 623 0 q 587 242 590 52 q 407 433 585 433 l 138 433 l 138 0 l 0 0 l 0 1013 l 396 1013 q 636 946 539 1013 q 749 731 749 868 q 711 597 749 659 q 608 502 674 534 q 718 370 696 474 q 729 207 722 352 q 781 26 736 62 l 781 0 m 373 551 q 533 594 465 551 q 614 731 614 645 q 532 859 614 815 q 373 896 465 896 l 138 896 l 138 551 l 373 551 "},"o":{"x_min":0,"x_max":713,"ha":821,"o":"m 357 -25 q 94 91 194 -25 q 0 368 0 202 q 93 642 0 533 q 357 761 193 761 q 618 644 518 761 q 713 368 713 533 q 619 91 713 201 q 357 -25 521 -25 m 357 85 q 528 175 465 85 q 584 369 584 255 q 529 562 584 484 q 357 651 467 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 357 85 250 85 "},"5":{"x_min":54.171875,"x_max":738,"ha":792,"o":"m 738 314 q 626 60 738 153 q 382 -23 526 -23 q 155 47 248 -23 q 54 256 54 125 l 183 256 q 259 132 204 174 q 382 91 314 91 q 533 149 471 91 q 602 314 602 213 q 538 469 602 411 q 386 528 475 528 q 284 506 332 528 q 197 439 237 484 l 81 439 l 159 958 l 684 958 l 684 840 l 254 840 l 214 579 q 306 627 258 612 q 407 643 354 643 q 636 552 540 643 q 738 314 738 457 "},"7":{"x_min":58.71875,"x_max":730.953125,"ha":792,"o":"m 730 839 q 469 448 560 641 q 335 0 378 255 l 192 0 q 328 441 235 252 q 593 830 421 630 l 58 830 l 58 958 l 730 958 l 730 839 "},"K":{"x_min":0,"x_max":819.46875,"ha":906,"o":"m 819 0 l 649 0 l 294 509 l 139 355 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 "},",":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 -12 q 105 -132 142 -82 q 0 -205 68 -182 l 0 -138 q 57 -82 40 -124 q 70 0 70 -51 l 0 0 l 0 151 l 142 151 l 142 -12 "},"d":{"x_min":0,"x_max":683,"ha":796,"o":"m 683 0 l 564 0 l 564 93 q 456 6 516 38 q 327 -25 395 -25 q 87 100 181 -25 q 0 365 0 215 q 90 639 0 525 q 343 763 187 763 q 564 647 486 763 l 564 1013 l 683 1013 l 683 0 m 582 373 q 529 562 582 484 q 361 653 468 653 q 190 561 253 653 q 135 365 135 479 q 189 175 135 254 q 358 85 251 85 q 529 178 468 85 q 582 373 582 258 "},"¨":{"x_min":-109,"x_max":247,"ha":232,"o":"m 247 1046 l 119 1046 l 119 1189 l 247 1189 l 247 1046 m 19 1046 l -109 1046 l -109 1189 l 19 1189 l 19 1046 "},"E":{"x_min":0,"x_max":736.109375,"ha":789,"o":"m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 "},"Y":{"x_min":0,"x_max":820,"ha":886,"o":"m 820 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 534 l 679 1012 l 820 1013 "},"\\"":{"x_min":0,"x_max":299,"ha":396,"o":"m 299 606 l 203 606 l 203 988 l 299 988 l 299 606 m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 "},"‹":{"x_min":17.984375,"x_max":773.609375,"ha":792,"o":"m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 "},"„":{"x_min":0,"x_max":364,"ha":467,"o":"m 141 -12 q 104 -132 141 -82 q 0 -205 67 -182 l 0 -138 q 56 -82 40 -124 q 69 0 69 -51 l 0 0 l 0 151 l 141 151 l 141 -12 m 364 -12 q 327 -132 364 -82 q 222 -205 290 -182 l 222 -138 q 279 -82 262 -124 q 292 0 292 -51 l 222 0 l 222 151 l 364 151 l 364 -12 "},"δ":{"x_min":1,"x_max":710,"ha":810,"o":"m 710 360 q 616 87 710 196 q 356 -28 518 -28 q 99 82 197 -28 q 1 356 1 192 q 100 606 1 509 q 355 703 199 703 q 180 829 288 754 q 70 903 124 866 l 70 1012 l 643 1012 l 643 901 l 258 901 q 462 763 422 794 q 636 592 577 677 q 710 360 710 485 m 584 365 q 552 501 584 447 q 451 602 521 555 q 372 611 411 611 q 197 541 258 611 q 136 355 136 472 q 190 171 136 245 q 358 85 252 85 q 528 173 465 85 q 584 365 584 252 "},"έ":{"x_min":0,"x_max":634.71875,"ha":714,"o":"m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 313 0 265 q 128 390 67 352 q 56 459 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 m 520 1040 l 331 819 l 248 819 l 383 1040 l 520 1040 "},"ω":{"x_min":0,"x_max":922,"ha":1031,"o":"m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 339 0 203 q 45 551 0 444 q 161 738 84 643 l 302 738 q 175 553 219 647 q 124 336 124 446 q 155 179 124 249 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 342 797 257 q 745 556 797 450 q 619 738 705 638 l 760 738 q 874 551 835 640 q 922 339 922 444 "},"´":{"x_min":0,"x_max":96,"ha":251,"o":"m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 "},"±":{"x_min":11,"x_max":781,"ha":792,"o":"m 781 490 l 446 490 l 446 255 l 349 255 l 349 490 l 11 490 l 11 586 l 349 586 l 349 819 l 446 819 l 446 586 l 781 586 l 781 490 m 781 21 l 11 21 l 11 115 l 781 115 l 781 21 "},"|":{"x_min":343,"x_max":449,"ha":792,"o":"m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 "},"ϋ":{"x_min":0,"x_max":617,"ha":725,"o":"m 482 800 l 372 800 l 372 925 l 482 925 l 482 800 m 239 800 l 129 800 l 129 925 l 239 925 l 239 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 "},"§":{"x_min":0,"x_max":593,"ha":690,"o":"m 593 425 q 554 312 593 369 q 467 233 516 254 q 537 83 537 172 q 459 -74 537 -12 q 288 -133 387 -133 q 115 -69 184 -133 q 47 96 47 -6 l 166 96 q 199 7 166 40 q 288 -26 232 -26 q 371 -5 332 -26 q 420 60 420 21 q 311 201 420 139 q 108 309 210 255 q 0 490 0 383 q 33 602 0 551 q 124 687 66 654 q 75 743 93 712 q 58 812 58 773 q 133 984 58 920 q 300 1043 201 1043 q 458 987 394 1043 q 529 814 529 925 l 411 814 q 370 908 404 877 q 289 939 336 939 q 213 911 246 939 q 180 841 180 883 q 286 720 180 779 q 484 612 480 615 q 593 425 593 534 m 467 409 q 355 544 467 473 q 196 630 228 612 q 146 587 162 609 q 124 525 124 558 q 239 387 124 462 q 398 298 369 315 q 448 345 429 316 q 467 409 467 375 "},"b":{"x_min":0,"x_max":685,"ha":783,"o":"m 685 372 q 597 99 685 213 q 347 -25 501 -25 q 219 5 277 -25 q 121 93 161 36 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 634 q 214 723 157 692 q 341 754 272 754 q 591 637 493 754 q 685 372 685 526 m 554 356 q 499 550 554 470 q 328 644 437 644 q 162 556 223 644 q 108 369 108 478 q 160 176 108 256 q 330 83 221 83 q 498 169 435 83 q 554 356 554 245 "},"q":{"x_min":0,"x_max":683,"ha":876,"o":"m 683 -278 l 564 -278 l 564 97 q 474 8 533 39 q 345 -23 415 -23 q 91 93 188 -23 q 0 364 0 203 q 87 635 0 522 q 337 760 184 760 q 466 727 408 760 q 564 637 523 695 l 564 737 l 683 737 l 683 -278 m 582 375 q 527 564 582 488 q 358 652 466 652 q 190 565 253 652 q 135 377 135 488 q 189 179 135 261 q 361 84 251 84 q 530 179 469 84 q 582 375 582 260 "},"Ω":{"x_min":-0.171875,"x_max":969.5625,"ha":1068,"o":"m 969 0 l 555 0 l 555 123 q 744 308 675 194 q 814 558 814 423 q 726 812 814 709 q 484 922 633 922 q 244 820 334 922 q 154 567 154 719 q 223 316 154 433 q 412 123 292 199 l 412 0 l 0 0 l 0 124 l 217 124 q 68 327 122 210 q 15 572 15 444 q 144 911 15 781 q 484 1041 274 1041 q 822 909 691 1041 q 953 569 953 777 q 899 326 953 443 q 750 124 846 210 l 969 124 l 969 0 "},"ύ":{"x_min":0,"x_max":617,"ha":725,"o":"m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 535 1040 l 346 819 l 262 819 l 397 1040 l 535 1040 "},"z":{"x_min":-0.015625,"x_max":613.890625,"ha":697,"o":"m 613 0 l 0 0 l 0 100 l 433 630 l 20 630 l 20 738 l 594 738 l 593 636 l 163 110 l 613 110 l 613 0 "},"™":{"x_min":0,"x_max":894,"ha":1000,"o":"m 389 951 l 229 951 l 229 503 l 160 503 l 160 951 l 0 951 l 0 1011 l 389 1011 l 389 951 m 894 503 l 827 503 l 827 939 l 685 503 l 620 503 l 481 937 l 481 503 l 417 503 l 417 1011 l 517 1011 l 653 580 l 796 1010 l 894 1011 l 894 503 "},"ή":{"x_min":0.78125,"x_max":697,"ha":810,"o":"m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 721 124 755 q 200 630 193 687 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 m 479 1040 l 290 819 l 207 819 l 341 1040 l 479 1040 "},"Θ":{"x_min":0,"x_max":960,"ha":1056,"o":"m 960 507 q 833 129 960 280 q 476 -32 698 -32 q 123 129 255 -32 q 0 507 0 280 q 123 883 0 732 q 476 1045 255 1045 q 832 883 696 1045 q 960 507 960 732 m 817 500 q 733 789 817 669 q 476 924 639 924 q 223 792 317 924 q 142 507 142 675 q 222 222 142 339 q 476 89 315 89 q 730 218 636 89 q 817 500 817 334 m 716 449 l 243 449 l 243 571 l 716 571 l 716 449 "},"®":{"x_min":-3,"x_max":1008,"ha":1106,"o":"m 503 532 q 614 562 566 532 q 672 658 672 598 q 614 747 672 716 q 503 772 569 772 l 338 772 l 338 532 l 503 532 m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 788 146 l 678 146 q 653 316 655 183 q 527 449 652 449 l 338 449 l 338 146 l 241 146 l 241 854 l 518 854 q 688 808 621 854 q 766 658 766 755 q 739 563 766 607 q 668 497 713 519 q 751 331 747 472 q 788 164 756 190 l 788 146 "},"~":{"x_min":0,"x_max":833,"ha":931,"o":"m 833 958 q 778 753 833 831 q 594 665 716 665 q 402 761 502 665 q 240 857 302 857 q 131 795 166 857 q 104 665 104 745 l 0 665 q 54 867 0 789 q 237 958 116 958 q 429 861 331 958 q 594 765 527 765 q 704 827 670 765 q 729 958 729 874 l 833 958 "},"Ε":{"x_min":0,"x_max":736.21875,"ha":778,"o":"m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 "},"³":{"x_min":0,"x_max":450,"ha":547,"o":"m 450 552 q 379 413 450 464 q 220 366 313 366 q 69 414 130 366 q 0 567 0 470 l 85 567 q 126 470 85 504 q 225 437 168 437 q 320 467 280 437 q 360 552 360 498 q 318 632 360 608 q 213 657 276 657 q 195 657 203 657 q 176 657 181 657 l 176 722 q 279 733 249 722 q 334 815 334 752 q 300 881 334 856 q 220 907 267 907 q 133 875 169 907 q 97 781 97 844 l 15 781 q 78 926 15 875 q 220 972 135 972 q 364 930 303 972 q 426 817 426 888 q 344 697 426 733 q 421 642 392 681 q 450 552 450 603 "},"[":{"x_min":0,"x_max":273.609375,"ha":371,"o":"m 273 -281 l 0 -281 l 0 1013 l 273 1013 l 273 920 l 124 920 l 124 -187 l 273 -187 l 273 -281 "},"L":{"x_min":0,"x_max":645.828125,"ha":696,"o":"m 645 0 l 0 0 l 0 1013 l 140 1013 l 140 126 l 645 126 l 645 0 "},"σ":{"x_min":0,"x_max":803.390625,"ha":894,"o":"m 803 628 l 633 628 q 713 368 713 512 q 618 93 713 204 q 357 -25 518 -25 q 94 91 194 -25 q 0 368 0 201 q 94 644 0 533 q 356 761 194 761 q 481 750 398 761 q 608 739 564 739 l 803 739 l 803 628 m 360 85 q 529 180 467 85 q 584 374 584 262 q 527 566 584 490 q 352 651 463 651 q 187 559 247 651 q 135 368 135 478 q 189 175 135 254 q 360 85 251 85 "},"ζ":{"x_min":0,"x_max":573,"ha":642,"o":"m 573 -40 q 553 -162 573 -97 q 510 -278 543 -193 l 400 -278 q 441 -187 428 -219 q 462 -90 462 -132 q 378 -14 462 -14 q 108 45 197 -14 q 0 290 0 117 q 108 631 0 462 q 353 901 194 767 l 55 901 l 55 1012 l 561 1012 l 561 924 q 261 669 382 831 q 128 301 128 489 q 243 117 128 149 q 458 98 350 108 q 573 -40 573 80 "},"θ":{"x_min":0,"x_max":674,"ha":778,"o":"m 674 496 q 601 160 674 304 q 336 -26 508 -26 q 73 153 165 -26 q 0 485 0 296 q 72 840 0 683 q 343 1045 166 1045 q 605 844 516 1045 q 674 496 674 692 m 546 579 q 498 798 546 691 q 336 935 437 935 q 178 798 237 935 q 126 579 137 701 l 546 579 m 546 475 l 126 475 q 170 233 126 348 q 338 80 230 80 q 504 233 447 80 q 546 475 546 346 "},"Ο":{"x_min":0,"x_max":958,"ha":1054,"o":"m 485 1042 q 834 883 703 1042 q 958 511 958 735 q 834 136 958 287 q 481 -26 701 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 729 q 485 1042 263 1042 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 670 q 480 913 640 913 q 226 785 321 913 q 142 504 142 671 q 226 224 142 339 q 480 98 319 98 "},"Γ":{"x_min":0,"x_max":705.28125,"ha":749,"o":"m 705 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 705 1012 l 705 886 "}," ":{"x_min":0,"x_max":0,"ha":375},"%":{"x_min":-3,"x_max":1089,"ha":1186,"o":"m 845 0 q 663 76 731 0 q 602 244 602 145 q 661 412 602 344 q 845 489 728 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 845 0 962 0 m 844 103 q 945 143 909 103 q 981 243 981 184 q 947 340 981 301 q 844 385 909 385 q 744 342 781 385 q 708 243 708 300 q 741 147 708 186 q 844 103 780 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 "},"P":{"x_min":0,"x_max":726,"ha":806,"o":"m 424 1013 q 640 931 555 1013 q 726 719 726 850 q 637 506 726 587 q 413 426 548 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 379 889 l 140 889 l 140 548 l 372 548 q 522 589 459 548 q 593 720 593 637 q 528 845 593 801 q 379 889 463 889 "},"Έ":{"x_min":0,"x_max":1078.21875,"ha":1118,"o":"m 1078 0 l 342 0 l 342 1013 l 1067 1013 l 1067 889 l 481 889 l 481 585 l 1019 585 l 1019 467 l 481 467 l 481 125 l 1078 125 l 1078 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 "},"Ώ":{"x_min":0.125,"x_max":1136.546875,"ha":1235,"o":"m 1136 0 l 722 0 l 722 123 q 911 309 842 194 q 981 558 981 423 q 893 813 981 710 q 651 923 800 923 q 411 821 501 923 q 321 568 321 720 q 390 316 321 433 q 579 123 459 200 l 579 0 l 166 0 l 166 124 l 384 124 q 235 327 289 210 q 182 572 182 444 q 311 912 182 782 q 651 1042 441 1042 q 989 910 858 1042 q 1120 569 1120 778 q 1066 326 1120 443 q 917 124 1013 210 l 1136 124 l 1136 0 m 277 1040 l 83 800 l 0 800 l 140 1041 l 277 1040 "},"_":{"x_min":0,"x_max":705.5625,"ha":803,"o":"m 705 -334 l 0 -334 l 0 -234 l 705 -234 l 705 -334 "},"Ϊ":{"x_min":-110,"x_max":246,"ha":275,"o":"m 246 1046 l 118 1046 l 118 1189 l 246 1189 l 246 1046 m 18 1046 l -110 1046 l -110 1189 l 18 1189 l 18 1046 m 136 0 l 0 0 l 0 1012 l 136 1012 l 136 0 "},"+":{"x_min":23,"x_max":768,"ha":792,"o":"m 768 372 l 444 372 l 444 0 l 347 0 l 347 372 l 23 372 l 23 468 l 347 468 l 347 840 l 444 840 l 444 468 l 768 468 l 768 372 "},"½":{"x_min":0,"x_max":1050,"ha":1149,"o":"m 1050 0 l 625 0 q 712 178 625 108 q 878 277 722 187 q 967 385 967 328 q 932 456 967 429 q 850 484 897 484 q 759 450 798 484 q 721 352 721 416 l 640 352 q 706 502 640 448 q 851 551 766 551 q 987 509 931 551 q 1050 385 1050 462 q 976 251 1050 301 q 829 179 902 215 q 717 68 740 133 l 1050 68 l 1050 0 m 834 985 l 215 -28 l 130 -28 l 750 984 l 834 985 m 224 422 l 142 422 l 142 811 l 0 811 l 0 867 q 104 889 62 867 q 164 973 157 916 l 224 973 l 224 422 "},"Ρ":{"x_min":0,"x_max":720,"ha":783,"o":"m 424 1013 q 637 933 554 1013 q 720 723 720 853 q 633 508 720 591 q 413 426 546 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 378 889 l 140 889 l 140 548 l 371 548 q 521 589 458 548 q 592 720 592 637 q 527 845 592 801 q 378 889 463 889 "},"\'":{"x_min":0,"x_max":139,"ha":236,"o":"m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 "},"ª":{"x_min":0,"x_max":350,"ha":397,"o":"m 350 625 q 307 616 328 616 q 266 631 281 616 q 247 673 251 645 q 190 628 225 644 q 116 613 156 613 q 32 641 64 613 q 0 722 0 669 q 72 826 0 800 q 247 866 159 846 l 247 887 q 220 934 247 916 q 162 953 194 953 q 104 934 129 953 q 76 882 80 915 l 16 882 q 60 976 16 941 q 166 1011 104 1011 q 266 979 224 1011 q 308 891 308 948 l 308 706 q 311 679 308 688 q 331 670 315 670 l 350 672 l 350 625 m 247 757 l 247 811 q 136 790 175 798 q 64 726 64 773 q 83 682 64 697 q 132 667 103 667 q 207 690 174 667 q 247 757 247 718 "},"΅":{"x_min":0,"x_max":450,"ha":553,"o":"m 450 800 l 340 800 l 340 925 l 450 925 l 450 800 m 406 1040 l 212 800 l 129 800 l 269 1040 l 406 1040 m 110 800 l 0 800 l 0 925 l 110 925 l 110 800 "},"T":{"x_min":0,"x_max":777,"ha":835,"o":"m 777 894 l 458 894 l 458 0 l 319 0 l 319 894 l 0 894 l 0 1013 l 777 1013 l 777 894 "},"Φ":{"x_min":0,"x_max":915,"ha":997,"o":"m 527 0 l 389 0 l 389 122 q 110 231 220 122 q 0 509 0 340 q 110 785 0 677 q 389 893 220 893 l 389 1013 l 527 1013 l 527 893 q 804 786 693 893 q 915 509 915 679 q 805 231 915 341 q 527 122 696 122 l 527 0 m 527 226 q 712 310 641 226 q 779 507 779 389 q 712 705 779 627 q 527 787 641 787 l 527 226 m 389 226 l 389 787 q 205 698 275 775 q 136 505 136 620 q 206 308 136 391 q 389 226 276 226 "},"⁋":{"x_min":0,"x_max":0,"ha":694},"j":{"x_min":-77.78125,"x_max":167,"ha":349,"o":"m 167 871 l 42 871 l 42 1013 l 167 1013 l 167 871 m 167 -80 q 121 -231 167 -184 q -26 -278 76 -278 l -77 -278 l -77 -164 l -41 -164 q 26 -143 11 -164 q 42 -65 42 -122 l 42 737 l 167 737 l 167 -80 "},"Σ":{"x_min":0,"x_max":756.953125,"ha":819,"o":"m 756 0 l 0 0 l 0 107 l 395 523 l 22 904 l 22 1013 l 745 1013 l 745 889 l 209 889 l 566 523 l 187 125 l 756 125 l 756 0 "},"1":{"x_min":215.671875,"x_max":574,"ha":792,"o":"m 574 0 l 442 0 l 442 697 l 215 697 l 215 796 q 386 833 330 796 q 475 986 447 875 l 574 986 l 574 0 "},"›":{"x_min":18.0625,"x_max":774,"ha":792,"o":"m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 "},"<":{"x_min":17.984375,"x_max":773.609375,"ha":792,"o":"m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 "},"£":{"x_min":0,"x_max":704.484375,"ha":801,"o":"m 704 41 q 623 -10 664 5 q 543 -26 583 -26 q 359 15 501 -26 q 243 36 288 36 q 158 23 197 36 q 73 -21 119 10 l 6 76 q 125 195 90 150 q 175 331 175 262 q 147 443 175 383 l 0 443 l 0 512 l 108 512 q 43 734 43 623 q 120 929 43 854 q 358 1010 204 1010 q 579 936 487 1010 q 678 729 678 857 l 678 684 l 552 684 q 504 838 552 780 q 362 896 457 896 q 216 852 263 896 q 176 747 176 815 q 199 627 176 697 q 248 512 217 574 l 468 512 l 468 443 l 279 443 q 297 356 297 398 q 230 194 297 279 q 153 107 211 170 q 227 133 190 125 q 293 142 264 142 q 410 119 339 142 q 516 96 482 96 q 579 105 550 96 q 648 142 608 115 l 704 41 "},"t":{"x_min":0,"x_max":367,"ha":458,"o":"m 367 0 q 312 -5 339 -2 q 262 -8 284 -8 q 145 28 183 -8 q 108 143 108 64 l 108 638 l 0 638 l 0 738 l 108 738 l 108 944 l 232 944 l 232 738 l 367 738 l 367 638 l 232 638 l 232 185 q 248 121 232 140 q 307 102 264 102 q 345 104 330 102 q 367 107 360 107 l 367 0 "},"¬":{"x_min":0,"x_max":706,"ha":803,"o":"m 706 411 l 706 158 l 630 158 l 630 335 l 0 335 l 0 411 l 706 411 "},"λ":{"x_min":0,"x_max":750,"ha":803,"o":"m 750 -7 q 679 -15 716 -15 q 538 59 591 -15 q 466 214 512 97 l 336 551 l 126 0 l 0 0 l 270 705 q 223 837 247 770 q 116 899 190 899 q 90 898 100 899 l 90 1004 q 152 1011 125 1011 q 298 938 244 1011 q 373 783 326 901 l 605 192 q 649 115 629 136 q 716 95 669 95 l 736 95 q 750 97 745 97 l 750 -7 "},"W":{"x_min":0,"x_max":1263.890625,"ha":1351,"o":"m 1263 1013 l 995 0 l 859 0 l 627 837 l 405 0 l 265 0 l 0 1013 l 136 1013 l 342 202 l 556 1013 l 701 1013 l 921 207 l 1133 1012 l 1263 1013 "},">":{"x_min":18.0625,"x_max":774,"ha":792,"o":"m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 "},"v":{"x_min":0,"x_max":675.15625,"ha":761,"o":"m 675 738 l 404 0 l 272 0 l 0 738 l 133 737 l 340 147 l 541 737 l 675 738 "},"τ":{"x_min":0.28125,"x_max":644.5,"ha":703,"o":"m 644 628 l 382 628 l 382 179 q 388 120 382 137 q 436 91 401 91 q 474 94 447 91 q 504 97 501 97 l 504 0 q 454 -9 482 -5 q 401 -14 426 -14 q 278 67 308 -14 q 260 233 260 118 l 260 628 l 0 628 l 0 739 l 644 739 l 644 628 "},"ξ":{"x_min":0,"x_max":624.9375,"ha":699,"o":"m 624 -37 q 608 -153 624 -96 q 563 -278 593 -211 l 454 -278 q 491 -183 486 -200 q 511 -83 511 -126 q 484 -23 511 -44 q 370 1 452 1 q 323 0 354 1 q 283 -1 293 -1 q 84 76 169 -1 q 0 266 0 154 q 56 431 0 358 q 197 538 108 498 q 94 613 134 562 q 54 730 54 665 q 77 823 54 780 q 143 901 101 867 l 27 901 l 27 1012 l 576 1012 l 576 901 l 380 901 q 244 863 303 901 q 178 745 178 820 q 312 600 178 636 q 532 582 380 582 l 532 479 q 276 455 361 479 q 118 281 118 410 q 165 173 118 217 q 274 120 208 133 q 494 101 384 110 q 624 -37 624 76 "},"&":{"x_min":-3,"x_max":894.25,"ha":992,"o":"m 894 0 l 725 0 l 624 123 q 471 0 553 40 q 306 -41 390 -41 q 168 -7 231 -41 q 62 92 105 26 q 14 187 31 139 q -3 276 -3 235 q 55 433 -3 358 q 248 581 114 508 q 170 689 196 640 q 137 817 137 751 q 214 985 137 922 q 384 1041 284 1041 q 548 988 483 1041 q 622 824 622 928 q 563 666 622 739 q 431 556 516 608 l 621 326 q 649 407 639 361 q 663 493 653 426 l 781 493 q 703 229 781 352 l 894 0 m 504 818 q 468 908 504 877 q 384 940 433 940 q 293 907 331 940 q 255 818 255 875 q 289 714 255 767 q 363 628 313 678 q 477 729 446 682 q 504 818 504 771 m 556 209 l 314 499 q 179 395 223 449 q 135 283 135 341 q 146 222 135 253 q 183 158 158 192 q 333 80 241 80 q 556 209 448 80 "},"Λ":{"x_min":0,"x_max":862.5,"ha":942,"o":"m 862 0 l 719 0 l 426 847 l 143 0 l 0 0 l 356 1013 l 501 1013 l 862 0 "},"I":{"x_min":41,"x_max":180,"ha":293,"o":"m 180 0 l 41 0 l 41 1013 l 180 1013 l 180 0 "},"G":{"x_min":0,"x_max":921,"ha":1011,"o":"m 921 0 l 832 0 l 801 136 q 655 15 741 58 q 470 -28 568 -28 q 126 133 259 -28 q 0 499 0 284 q 125 881 0 731 q 486 1043 259 1043 q 763 957 647 1043 q 905 709 890 864 l 772 709 q 668 866 747 807 q 486 926 589 926 q 228 795 322 926 q 142 507 142 677 q 228 224 142 342 q 483 94 323 94 q 712 195 625 94 q 796 435 796 291 l 477 435 l 477 549 l 921 549 l 921 0 "},"ΰ":{"x_min":0,"x_max":617,"ha":725,"o":"m 524 800 l 414 800 l 414 925 l 524 925 l 524 800 m 183 800 l 73 800 l 73 925 l 183 925 l 183 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 489 1040 l 300 819 l 216 819 l 351 1040 l 489 1040 "},"`":{"x_min":0,"x_max":138.890625,"ha":236,"o":"m 138 699 l 0 699 l 0 861 q 36 974 0 929 q 138 1041 72 1020 l 138 977 q 82 931 95 969 q 69 839 69 893 l 138 839 l 138 699 "},"·":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 "},"Υ":{"x_min":0.328125,"x_max":819.515625,"ha":889,"o":"m 819 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 "},"r":{"x_min":0,"x_max":355.5625,"ha":432,"o":"m 355 621 l 343 621 q 179 569 236 621 q 122 411 122 518 l 122 0 l 0 0 l 0 737 l 117 737 l 117 604 q 204 719 146 686 q 355 753 262 753 l 355 621 "},"x":{"x_min":0,"x_max":675,"ha":764,"o":"m 675 0 l 525 0 l 331 286 l 144 0 l 0 0 l 256 379 l 12 738 l 157 737 l 336 473 l 516 738 l 661 738 l 412 380 l 675 0 "},"μ":{"x_min":0,"x_max":696.609375,"ha":747,"o":"m 696 -4 q 628 -14 657 -14 q 498 97 513 -14 q 422 8 470 41 q 313 -24 374 -24 q 207 3 258 -24 q 120 80 157 31 l 120 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 172 124 246 q 308 82 216 82 q 451 177 402 82 q 492 358 492 254 l 492 738 l 616 738 l 616 214 q 623 136 616 160 q 673 92 636 92 q 696 95 684 92 l 696 -4 "},"h":{"x_min":0,"x_max":615,"ha":724,"o":"m 615 472 l 615 0 l 490 0 l 490 454 q 456 590 490 535 q 338 654 416 654 q 186 588 251 654 q 122 436 122 522 l 122 0 l 0 0 l 0 1013 l 122 1013 l 122 633 q 218 727 149 694 q 362 760 287 760 q 552 676 484 760 q 615 472 615 600 "},".":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 "},"φ":{"x_min":-2,"x_max":878,"ha":974,"o":"m 496 -279 l 378 -279 l 378 -17 q 101 88 204 -17 q -2 367 -2 194 q 68 626 -2 510 q 283 758 151 758 l 283 646 q 167 537 209 626 q 133 373 133 462 q 192 177 133 254 q 378 93 259 93 l 378 758 q 445 764 426 763 q 476 765 464 765 q 765 659 653 765 q 878 377 878 553 q 771 96 878 209 q 496 -17 665 -17 l 496 -279 m 496 93 l 514 93 q 687 183 623 93 q 746 380 746 265 q 691 569 746 491 q 522 658 629 658 l 496 656 l 496 93 "},";":{"x_min":0,"x_max":142,"ha":239,"o":"m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 -12 q 105 -132 142 -82 q 0 -206 68 -182 l 0 -138 q 58 -82 43 -123 q 68 0 68 -56 l 0 0 l 0 151 l 142 151 l 142 -12 "},"f":{"x_min":0,"x_max":378,"ha":472,"o":"m 378 638 l 246 638 l 246 0 l 121 0 l 121 638 l 0 638 l 0 738 l 121 738 q 137 935 121 887 q 290 1028 171 1028 q 320 1027 305 1028 q 378 1021 334 1026 l 378 908 q 323 918 346 918 q 257 870 273 918 q 246 780 246 840 l 246 738 l 378 738 l 378 638 "},"“":{"x_min":1,"x_max":348.21875,"ha":454,"o":"m 140 670 l 1 670 l 1 830 q 37 943 1 897 q 140 1011 74 990 l 140 947 q 82 900 97 940 q 68 810 68 861 l 140 810 l 140 670 m 348 670 l 209 670 l 209 830 q 245 943 209 897 q 348 1011 282 990 l 348 947 q 290 900 305 940 q 276 810 276 861 l 348 810 l 348 670 "},"A":{"x_min":0.03125,"x_max":906.953125,"ha":1008,"o":"m 906 0 l 756 0 l 648 303 l 251 303 l 142 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 610 421 l 452 867 l 293 421 l 610 421 "},"6":{"x_min":53,"x_max":739,"ha":792,"o":"m 739 312 q 633 62 739 162 q 400 -31 534 -31 q 162 78 257 -31 q 53 439 53 206 q 178 859 53 712 q 441 986 284 986 q 643 912 559 986 q 732 713 732 833 l 601 713 q 544 830 594 786 q 426 875 494 875 q 268 793 331 875 q 193 517 193 697 q 301 597 240 570 q 427 624 362 624 q 643 540 552 624 q 739 312 739 451 m 603 298 q 540 461 603 400 q 404 516 484 516 q 268 461 323 516 q 207 300 207 401 q 269 137 207 198 q 405 83 325 83 q 541 137 486 83 q 603 298 603 197 "},"‘":{"x_min":1,"x_max":139.890625,"ha":236,"o":"m 139 670 l 1 670 l 1 830 q 37 943 1 897 q 139 1011 74 990 l 139 947 q 82 900 97 940 q 68 810 68 861 l 139 810 l 139 670 "},"ϊ":{"x_min":-70,"x_max":283,"ha":361,"o":"m 283 800 l 173 800 l 173 925 l 283 925 l 283 800 m 40 800 l -70 800 l -70 925 l 40 925 l 40 800 m 283 3 q 232 -10 257 -5 q 181 -15 206 -15 q 84 26 118 -15 q 41 200 41 79 l 41 737 l 166 737 l 167 215 q 171 141 167 157 q 225 101 182 101 q 247 103 238 101 q 283 112 256 104 l 283 3 "},"π":{"x_min":-0.21875,"x_max":773.21875,"ha":857,"o":"m 773 -7 l 707 -11 q 575 40 607 -11 q 552 174 552 77 l 552 226 l 552 626 l 222 626 l 222 0 l 97 0 l 97 626 l 0 626 l 0 737 l 773 737 l 773 626 l 676 626 l 676 171 q 695 103 676 117 q 773 90 714 90 l 773 -7 "},"ά":{"x_min":0,"x_max":765.5625,"ha":809,"o":"m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 727 407 760 q 563 637 524 695 l 563 738 l 685 738 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 95 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 m 604 1040 l 415 819 l 332 819 l 466 1040 l 604 1040 "},"O":{"x_min":0,"x_max":958,"ha":1057,"o":"m 485 1041 q 834 882 702 1041 q 958 512 958 734 q 834 136 958 287 q 481 -26 702 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 728 q 485 1041 263 1041 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 669 q 480 912 640 912 q 226 784 321 912 q 142 504 142 670 q 226 224 142 339 q 480 98 319 98 "},"n":{"x_min":0,"x_max":615,"ha":724,"o":"m 615 463 l 615 0 l 490 0 l 490 454 q 453 592 490 537 q 331 656 410 656 q 178 585 240 656 q 117 421 117 514 l 117 0 l 0 0 l 0 738 l 117 738 l 117 630 q 218 728 150 693 q 359 764 286 764 q 552 675 484 764 q 615 463 615 593 "},"3":{"x_min":54,"x_max":737,"ha":792,"o":"m 737 284 q 635 55 737 141 q 399 -25 541 -25 q 156 52 248 -25 q 54 308 54 140 l 185 308 q 245 147 185 202 q 395 96 302 96 q 539 140 484 96 q 602 280 602 190 q 510 429 602 390 q 324 454 451 454 l 324 565 q 487 584 441 565 q 565 719 565 617 q 515 835 565 791 q 395 879 466 879 q 255 824 307 879 q 203 661 203 769 l 78 661 q 166 909 78 822 q 387 992 250 992 q 603 921 513 992 q 701 723 701 844 q 669 607 701 656 q 578 524 637 558 q 696 434 655 499 q 737 284 737 369 "},"9":{"x_min":53,"x_max":739,"ha":792,"o":"m 739 524 q 619 94 739 241 q 362 -32 516 -32 q 150 47 242 -32 q 59 244 59 126 l 191 244 q 246 129 191 176 q 373 82 301 82 q 526 161 466 82 q 597 440 597 255 q 363 334 501 334 q 130 432 216 334 q 53 650 53 521 q 134 880 53 786 q 383 986 226 986 q 659 841 566 986 q 739 524 739 719 m 388 449 q 535 514 480 449 q 585 658 585 573 q 535 805 585 744 q 388 873 480 873 q 242 809 294 873 q 191 658 191 745 q 239 514 191 572 q 388 449 292 449 "},"l":{"x_min":41,"x_max":166,"ha":279,"o":"m 166 0 l 41 0 l 41 1013 l 166 1013 l 166 0 "},"¤":{"x_min":40.09375,"x_max":728.796875,"ha":825,"o":"m 728 304 l 649 224 l 512 363 q 383 331 458 331 q 256 363 310 331 l 119 224 l 40 304 l 177 441 q 150 553 150 493 q 184 673 150 621 l 40 818 l 119 898 l 267 749 q 321 766 291 759 q 384 773 351 773 q 447 766 417 773 q 501 749 477 759 l 649 898 l 728 818 l 585 675 q 612 618 604 648 q 621 553 621 587 q 591 441 621 491 l 728 304 m 384 682 q 280 643 318 682 q 243 551 243 604 q 279 461 243 499 q 383 423 316 423 q 487 461 449 423 q 525 553 525 500 q 490 641 525 605 q 384 682 451 682 "},"κ":{"x_min":0,"x_max":632.328125,"ha":679,"o":"m 632 0 l 482 0 l 225 384 l 124 288 l 124 0 l 0 0 l 0 738 l 124 738 l 124 446 l 433 738 l 596 738 l 312 466 l 632 0 "},"4":{"x_min":48,"x_max":742.453125,"ha":792,"o":"m 742 243 l 602 243 l 602 0 l 476 0 l 476 243 l 48 243 l 48 368 l 476 958 l 602 958 l 602 354 l 742 354 l 742 243 m 476 354 l 476 792 l 162 354 l 476 354 "},"p":{"x_min":0,"x_max":685,"ha":786,"o":"m 685 364 q 598 96 685 205 q 350 -23 504 -23 q 121 89 205 -23 l 121 -278 l 0 -278 l 0 738 l 121 738 l 121 633 q 220 726 159 691 q 351 761 280 761 q 598 636 504 761 q 685 364 685 522 m 557 371 q 501 560 557 481 q 330 651 437 651 q 162 559 223 651 q 108 366 108 479 q 162 177 108 254 q 333 87 224 87 q 502 178 441 87 q 557 371 557 258 "},"‡":{"x_min":0,"x_max":777,"ha":835,"o":"m 458 238 l 458 0 l 319 0 l 319 238 l 0 238 l 0 360 l 319 360 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 l 777 804 l 777 683 l 458 683 l 458 360 l 777 360 l 777 238 l 458 238 "},"ψ":{"x_min":0,"x_max":808,"ha":907,"o":"m 465 -278 l 341 -278 l 341 -15 q 87 102 180 -15 q 0 378 0 210 l 0 739 l 133 739 l 133 379 q 182 195 133 275 q 341 98 242 98 l 341 922 l 465 922 l 465 98 q 623 195 563 98 q 675 382 675 278 l 675 742 l 808 742 l 808 381 q 720 104 808 213 q 466 -13 627 -13 l 465 -278 "},"η":{"x_min":0.78125,"x_max":697,"ha":810,"o":"m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 720 124 755 q 200 630 193 686 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 "}},"cssFontWeight":"normal","ascender":1189,"underlinePosition":-100,"cssFontStyle":"normal","boundingBox":{"yMin":-334,"xMin":-111,"yMax":1189,"xMax":1672},"resolution":1000,"original_font_information":{"postscript_name":"Helvetiker-Regular","version_string":"Version 1.00 2004 initial release","vendor_url":"http://www.magenta.gr/","full_font_name":"Helvetiker","font_family_name":"Helvetiker","copyright":"Copyright (c) Μagenta ltd, 2004","description":"","trademark":"","designer":"","designer_url":"","unique_font_identifier":"Μagenta ltd:Helvetiker:22-10-104","license_url":"http://www.ellak.gr/fonts/MgOpen/license.html","license_description":"Copyright (c) 2004 by MAGENTA Ltd. All Rights Reserved.\\r\\n\\r\\nPermission is hereby granted, free of charge, to any person obtaining a copy of the fonts accompanying this license (\\"Fonts\\") and associated documentation files (the \\"Font Software\\"), to reproduce and distribute the Font Software, including without limitation the rights to use, copy, merge, publish, distribute, and/or sell copies of the Font Software, and to permit persons to whom the Font Software is furnished to do so, subject to the following conditions: \\r\\n\\r\\nThe above copyright and this permission notice shall be included in all copies of one or more of the Font Software typefaces.\\r\\n\\r\\nThe Font Software may be modified, altered, or added to, and in particular the designs of glyphs or characters in the Fonts may be modified and additional glyphs or characters may be added to the Fonts, only if the fonts are renamed to names not containing the word \\"MgOpen\\", or if the modifications are accepted for inclusion in the Font Software itself by the each appointed Administrator.\\r\\n\\r\\nThis License becomes null and void to the extent applicable to Fonts or Font Software that has been modified and is distributed under the \\"MgOpen\\" name.\\r\\n\\r\\nThe Font Software may be sold as part of a larger software package but no copy of one or more of the Font Software typefaces may be sold by itself. \\r\\n\\r\\nTHE FONT SOFTWARE IS PROVIDED \\"AS IS\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL MAGENTA OR PERSONS OR BODIES IN CHARGE OF ADMINISTRATION AND MAINTENANCE OF THE FONT SOFTWARE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.","manufacturer_name":"Μagenta ltd","font_sub_family_name":"Regular"},"descender":-334,"familyName":"Helvetiker","lineHeight":1522,"underlineThickness":50});};return Text3D;}(BaseObject);/**\r\n\t * @author pzx 2018.2.13\r\n\t * Json2MeshBuilderParser\r\n\t */var ubuilderLoadSceneKeys$2={id:"id",name:"name",userID:"userid",position:"position",rotation:"rotation",scale:"scale",properties:"properties",plans:"plans",walls:"walls",placements:"placements",videoprobes:"videoprobes",groups:"groups",corners:"corners",holesCorners:"holescorners",doorOrWindows:"doororwindows",curveLines:"curvelines",pipeLines:"pipelines",text3Ds:"text3ds",rooms:"rooms",height:"height",thick:"thick",texture:"texture",type:"type",model:"model",suspendPercent:"suspendpercent",leftTexture:"lefttexture",rightTexture:"righttexture",edgeTexture:"edgetexture",floorTexture:"floortexture",ceilingTexture:"ceilingtexture",roofTexture:"rooftexture",isOpen:"isopen",openDirIndex:"diridx",wallType:"type"};var loadKeys$2=ubuilderLoadSceneKeys$2;var UBuilderSceneDelayLoader=function(){function UBuilderSceneDelayLoader(){classCallCheck(this,UBuilderSceneDelayLoader);this.sceneJson=null;this.scale=1;//比例尺\nthis.curFloorPlan=null;this.enableCombine=true;this.defaultWallEdgeTextureUri="Textures/WallEdge.jpg";this.defaultWallTextureUri="Textures/RoomWall.jpg";this.defaultFloorTextureUri="Textures/FloorDefault.jpg";this.defaultCeilingTextureUri="Textures/CeilingDefault.jpg";this.defaultRoofTextureUri="Textures/RoofDefault.jpg";this.world=null;this.resourceManager=new ResourceManager();this.combineManager=new DelayCombineManager(this.resourceManager);this.combineParser=new UBuilderSceneDelayCombineParser(this);DefaultSetting.enableBuildMesh=false;}UBuilderSceneDelayLoader.prototype.disposeModels=function disposeModels(){this.resourceManager.disposeModels();};UBuilderSceneDelayLoader.prototype.disposeTextures=function disposeTextures(){this.resourceManager.disposeTextures();};UBuilderSceneDelayLoader.prototype._nestingLoopYield=function _nestingLoopYield(gen,success,fail){var _this=this;var item=gen.next();if(item.done){if(success){success();}return item.value;}var value=item.value,done=item.done;if(value instanceof Promise){value.then(function(e){return _this._nestingLoopYield(gen,success,fail);}).catch(function(error){fail(error);});}else{this._nestingLoopYield(gen,success,fail);}};UBuilderSceneDelayLoader.prototype.delayLoad=function delayLoad(map){var that=this;if(map){if(map["url"]){this.sceneURL=map["url"];this.resourceManager.localCustomModelBaseUrl=this.getParentRelativeUrl(this.sceneURL);}if(map["json"]){this.sceneJson=map["json"];}if(map.customModeBaseUrl){this.resourceManager.localCustomModelBaseUrl=map.customModeBaseUrl;}}else{console.error("load param can not be null");return null;}return new Promise(function(resolve,reject){// that.loadDefaultTexture().then(function () {\n//     return that.loadSceneJson();\n// }).\nthat.resourceManager.initLightMaps(function(){that.loadSceneJson().then(function(){// that.curFloorPlan = new FloorPlan();\nthat.parseSceneJson().then(function(){that.world.build();return new Promise(function(resolve,reject){if(DefaultSetting.enableCombine){that.combineParser.parseWorld(that.world);that.combineParser.buildWorld(that.world);}// console.log("finish combine parser");\n// console.log("finish combine parser");\nresolve(that.world);});});}).then(function(){resolve(that.world);}).catch(function(error){console.error(error);});});});};UBuilderSceneDelayLoader.prototype.loadFont=function loadFont(cb){var that=this;return new Promise(function(resolve,reject){var loader=new THREE.FontLoader();loader.load(\'./models/Font/Microsoft YaHei_Regular.json\',function(response){Text3D.font=response;cb();});});};UBuilderSceneDelayLoader.prototype.loadResources=function loadResources(){var that=this;// this.resourceManager.localCustomModelBaseUrl =this.getParentRelativeUrl(this.sceneURL);\nreturn new Promise(function(resolve,reject){// that.resourceManager.downloadResources(function () {\n//     console.log("finish downloadResources");\n//     // resolve();\n//     resolve(that.world);\n// });\nthat.resourceManager.downloadResourcesWithQueue(function(){// console.log("finish downloadResources");\n// resolve();\nresolve(that.world);});});};UBuilderSceneDelayLoader.prototype.getParentRelativeUrl=function getParentRelativeUrl(url){var list=url.split(\'/\');var parentUrl="";for(var i=0;i<list.length-1;i++){var obj=list[i];parentUrl+=obj+"/";}return parentUrl;};//pzx start\nUBuilderSceneDelayLoader.prototype.load=function load(map){var that=this;this.delayLoad(map).then(function(resolve,reject){return that.loadResources();});return;if(map){if(map["url"]){this.sceneURL=map["url"];this.resourceManager.localCustomModelBaseUrl=this.getParentRelativeUrl(this.sceneURL);}if(map["json"]){this.sceneJson=map["json"];}}else{console.error("load param can not be null");return null;}return new Promise(function(resolve,reject){// that.loadDefaultTexture().then(function () {\n//     return that.loadSceneJson();\n// }).\nthat.resourceManager.initLightMaps(function(){that.loadSceneJson().then(function(){// that.curFloorPlan = new FloorPlan();\nthat.parseSceneJson().then(function(){that.world.build();return new Promise(function(resolve,reject){that.combineParser.parseWorld(that.world);that.combineParser.buildWorld(that.world);// console.log("finish combine parser");\nthat.resourceManager.downloadResources(function(){// console.log("finish downloadResources");\n// resolve(that.world);\n});resolve(that.world);});});}).then(function(){resolve(that.world);}).catch(function(error){console.error(error);});});});};UBuilderSceneDelayLoader.prototype.loadSceneJson=function loadSceneJson(){var that=this;return new Promise(function(resolve,reject){if(that.sceneJson){resolve(that.sceneJson);}else if(that.sceneURL){var loader=new THREE.FileLoader();loader.load(that.sceneURL,function(data){that.sceneJson=JSON.parse(data);resolve();},function(){},function(error){reject("can not load "+that.sceneURL);});}else{reject("load scene json error");}});};UBuilderSceneDelayLoader.prototype.createTextureLoaderPromise=function createTextureLoaderPromise(texUri){var that=this;return new Promise(function(resolve,reject){var texLoader=new THREE.TextureLoader();// var that = this;\n// load a resource\ntexLoader.load(// resource URL\n// that.sceneURL+"/"+texUri,\ntexUri,// Function when resource is loaded\nfunction(texture){texture.wrapS=THREE.RepeatWrapping;texture.wrapT=THREE.RepeatWrapping;resolve(texture);},// Function called when download progresses\nfunction(xhr){console.log(texUri+" "+xhr.loaded/xhr.total*100+\'% loaded\');},// Function called when download errors\nfunction(xhr){resolve(null);console.log(texUri+\'load error\');});});};UBuilderSceneDelayLoader.prototype.parseSceneJson=function parseSceneJson(){var that=this;return new Promise(function(resolve,reject){that.resourceManager.delayDownload=true;that.resourceManager.loadTextures(that.sceneJson.textures);that.resourceManager.loadModels(that.sceneJson.models);// var id = setInterval(function () {\n//     if (that.resourceManager.checkAllResourcesIsReady()) {\n//         clearInterval(id);\nthat.parseWorld(that.sceneJson);resolve();//     }\n// }, 10);\n});};UBuilderSceneDelayLoader.prototype.parseWorld=function parseWorld(jsonData){var world=new World();this.world=world;// world.jsonData = jsonData;\nthis.parseBaseObject(jsonData,world);if(jsonData["buildings"]){var buildingsData=jsonData["buildings"];for(var i=0;i<buildingsData.length;i++){var buildingData=buildingsData[i];var bd=this.parseBuilding(buildingData);// bd.jsonData = buildingData;\nworld.buildings.push(bd);}}if(jsonData["outdoors"]){var outdoors=new Outdoors();this.parseFloorPlan(jsonData["outdoors"],outdoors);world.outdoors=outdoors;}};UBuilderSceneDelayLoader.prototype.parseBuilding=function parseBuilding(jsonData,parent){var buildingData=jsonData;var bd=new Building();this.parseBaseObject(jsonData,bd,parent);var plansData=buildingData[loadKeys$2.plans];if(plansData){for(var j=0;j<plansData.length;j++){var planData=plansData[j];var floorPlan=new FloorPlan();this.parseFloorPlan(planData,floorPlan,bd);bd.floorplans.push(floorPlan);}}var facadesData=buildingData.facades;if(facadesData){for(var i=0;i<facadesData.length;i++){var plcData=facadesData[i];this.parseFacade(plcData,bd);}}var facadeGroupsData=buildingData.facadegroups;if(facadeGroupsData){for(var i=0;i<facadeGroupsData.length;i++){var groupData=facadeGroupsData[i];this.parseFacadeGroup(groupData,bd);}}return bd;};UBuilderSceneDelayLoader.prototype.parseFloorPlan=function parseFloorPlan(jsonData,floorPlan,parent){// var floorPlan = new FloorPlan();\n// floorPlan.id = id;\n// floorPlan.name = name;\nthis.parseBaseObject(jsonData,floorPlan,parent);if(jsonData[loadKeys$2.height]){floorPlan.height=jsonData[loadKeys$2.height];}if(jsonData[loadKeys$2.corners]){var cornersData=jsonData[loadKeys$2.corners];for(var i=0;i<cornersData.length;i++){var cornerData=cornersData[i];var x=cornerData[0];var y=cornerData[1];var z=-cornerData[2];if(!floorPlan.existsCorner(x,y,z)){floorPlan.addCorner(x,y,z);}else{console.error("repeat corner");}}}if(jsonData[loadKeys$2.walls]){var wallsData=jsonData[loadKeys$2.walls];for(var i=0;i<wallsData.length;i++){var wallData=wallsData[i];this.parseWall(wallData,floorPlan);}}if(jsonData[loadKeys$2.rooms]){var roomsData=jsonData[loadKeys$2.rooms];for(var i=0;i<roomsData.length;i++){var roomData=roomsData[i];this.parseRoom(roomData,floorPlan);}}if(jsonData[loadKeys$2.placements]){var plcsData=jsonData[loadKeys$2.placements];for(var i=0;i<plcsData.length;i++){var plcData=plcsData[i];this.parsePlacement(plcData,floorPlan);}}if(jsonData[loadKeys$2.videoprobes]){var plcsData=jsonData[loadKeys$2.videoprobes];for(var i=0;i<plcsData.length;i++){var plcData=plcsData[i];this.parsePlacement(plcData,floorPlan);}}if(jsonData[loadKeys$2.groups]){var groupsData=jsonData[loadKeys$2.groups];for(var i=0;i<groupsData.length;i++){var groupData=groupsData[i];this.parseGroup(groupData,floorPlan);}}if(jsonData[loadKeys$2.doorOrWindows]){var doorOrWinsData=jsonData[loadKeys$2.doorOrWindows];for(var i=0;i<doorOrWinsData.length;i++){var doorOrWinData=doorOrWinsData[i];this.parseDoorOrWindow(doorOrWinData,floorPlan);}}if(jsonData[loadKeys$2.curveLines]){var linesData=jsonData[loadKeys$2.curveLines];for(var i=0;i<linesData.length;i++){var data=linesData[i];this.parseCurveLine(data,floorPlan);}}if(jsonData[loadKeys$2.pipeLines]){var linesData=jsonData[loadKeys$2.pipeLines];for(var i=0;i<linesData.length;i++){var data=linesData[i];this.parsePipeLine(data,floorPlan);}}// if (jsonData[loadKeys.text3Ds]) {\n//     var textsData = jsonData[loadKeys.text3Ds];\n//     for (var i = 0; i < textsData.length; i++) {\n//         var data = textsData[i];\n//         this.parseText3D(data, floorPlan)\n//     }\n// }\nreturn floorPlan;};UBuilderSceneDelayLoader.prototype.parseText3D=function parseText3D(jsonData,plan){var text3D=new Text3D();this.parseBaseObject(jsonData,text3D,plan);if(jsonData.color){var colorData=jsonData.color;text3D.color=new THREE.Color(colorData[0],colorData[1],colorData[2]);if(colorData.length===4){text3D.opacity=colorData[3];}}if(jsonData.font!==undefined){text3D.font=jsonData.font;}if(jsonData.text!==undefined){text3D.text=jsonData.text;}plan.text3Ds.push(text3D);};UBuilderSceneDelayLoader.prototype.parsePipeLine=function parsePipeLine(jsonData,plan){var line=new PipeLine();this.parseBaseObject(jsonData,line,plan);if(jsonData[loadKeys$2.texture]!==undefined){line.resource=this.resourceManager.textures[jsonData[loadKeys$2.texture]];}if(jsonData.color){var colorData=jsonData.color;line.color=new THREE.Color(colorData[0],colorData[1],colorData[2]);if(colorData.length===4){line.opacity=colorData[3];}}if(jsonData.sectionType){line.sectionType=jsonData.sectionType;}if(jsonData.rendermode!==undefined){line.renderMode=jsonData.rendermode;}if(jsonData.radius!==undefined){line.radius=jsonData.radius;}plan.pipelines.push(line);var points=jsonData.path;for(var i=0;i<points.length;i++){var point=points[i];var x=point[0];var y=point[1];var z=-point[2];var pos=new THREE.Vector3(x,y,z);line.points.push(pos);}};UBuilderSceneDelayLoader.prototype.parseCurveLine=function parseCurveLine(jsonData,plan){var line=new CurveLine();this.parseBaseObject(jsonData,line,plan);if(jsonData[loadKeys$2.texture]!==undefined){line.resource=this.resourceManager.textures[jsonData[loadKeys$2.texture]];}if(jsonData.color){var colorData=jsonData.color;line.color=new THREE.Color(colorData[0],colorData[1],colorData[2]);if(colorData.length===4){line.opacity=colorData[3];}}if(jsonData.width!==undefined){line.width=jsonData.width;}plan.curvelines.push(line);var points=jsonData.path;for(var i=0;i<points.length;i++){var point=points[i];var x=point[0];var y=point[1];var z=-point[2];var pos=new THREE.Vector3(x,y,z);line.points.push(pos);}};UBuilderSceneDelayLoader.prototype.parseDoorOrWindow=function parseDoorOrWindow(jsonData,wall){var doorOrWin=new DoorOrWindow();this.parseBaseObject(jsonData,doorOrWin,wall.parent);doorOrWin.resource=this.resourceManager.models[jsonData[loadKeys$2.model]];wall.doorOrWindows.push(doorOrWin);if(jsonData[loadKeys$2.suspendPercent]){doorOrWin.suspendPercent=jsonData[loadKeys$2.suspendPercent];}if(jsonData[loadKeys$2.isOpen]){doorOrWin.isOpen=jsonData[loadKeys$2.isOpen];}if(jsonData[loadKeys$2.openDirIndex]){doorOrWin.openDirIndex=jsonData[loadKeys$2.openDirIndex];}doorOrWin.attachWall=wall;};UBuilderSceneDelayLoader.prototype.parseFacade=function parseFacade(jsonData,bd){var facade=new Facade();this.parseBaseObject(jsonData,facade,bd);facade.resource=this.resourceManager.models[jsonData[loadKeys$2.model]];if(jsonData.texture!==undefined&&jsonData.texture!==null){facade.customTextureResource=this.resourceManager.textures[jsonData.texture];}if(jsonData.color){var colorData=jsonData.color;facade.customColor=new THREE.Color(colorData[0],colorData[1],colorData[2]);if(colorData.length===4){facade.opacity=colorData[3];}}if(jsonData.rendermode){facade.renderMode=jsonData.rendermode;}bd.facades.push(facade);};UBuilderSceneDelayLoader.prototype.parseFacadeGroup=function parseFacadeGroup(jsonData,bd){var group=new FacadeGroup();this.parseBaseObject(jsonData,group,bd);if(bd instanceof Building){bd.facadeGroups.push(group);}else{bd.groups.push(group);}if(jsonData[loadKeys$2.placements]){var plcsData=jsonData[loadKeys$2.placements];for(var i=0;i<plcsData.length;i++){var plcData=plcsData[i];this.parseFacadeGroupChild(plcData,group);}}if(jsonData[loadKeys$2.groups]){var groupsData=jsonData[loadKeys$2.groups];for(var i=0;i<groupsData.length;i++){var groupData=groupsData[i];this.parseFacadeGroup(groupData,group);}}};UBuilderSceneDelayLoader.prototype.parseFacadeGroupChild=function parseFacadeGroupChild(jsonData,group){var facade=new Facade();this.parseBaseObject(jsonData,facade,group);facade.resource=this.resourceManager.models[jsonData[loadKeys$2.model]];if(jsonData.texture!==undefined&&jsonData.texture!==null){facade.customTextureResource=this.resourceManager.textures[jsonData.texture];}if(jsonData.color){var colorData=jsonData.color;facade.customColor=new THREE.Color(colorData[0],colorData[1],colorData[2]);if(colorData.length===4){facade.opacity=colorData[3];}}if(jsonData.rendermode){facade.renderMode=jsonData.rendermode;}group.placements.push(facade);};UBuilderSceneDelayLoader.prototype.parsePlacement=function parsePlacement(jsonData,plan){var plc=new Placement();this.parseBaseObject(jsonData,plc,plan);plc.resource=this.resourceManager.models[jsonData[loadKeys$2.model]];if(jsonData.texture!==undefined&&jsonData.texture!==null){plc.customTextureResource=this.resourceManager.textures[jsonData.texture];}if(jsonData.color){var colorData=jsonData.color;plc.customColor=new THREE.Color(colorData[0],colorData[1],colorData[2]);if(colorData.length===4){plc.opacity=colorData[3];}}if(jsonData.rendermode){plc.renderMode=jsonData.rendermode;}if(jsonData.animinfo){plc.isPlayAnim=jsonData.animinfo.isplay;plc.animClip=jsonData.animinfo.clip;}plan.placements.push(plc);};UBuilderSceneDelayLoader.prototype.parseGroup=function parseGroup(jsonData,plan){var group=new PlacementGroup();this.parseBaseObject(jsonData,group,plan);plan.groups.push(group);if(jsonData[loadKeys$2.placements]){var plcsData=jsonData[loadKeys$2.placements];for(var i=0;i<plcsData.length;i++){var plcData=plcsData[i];this.parsePlacement(plcData,group);}}if(jsonData[loadKeys$2.groups]){var groupsData=jsonData[loadKeys$2.groups];for(var i=0;i<groupsData.length;i++){var groupData=groupsData[i];this.parseGroup(groupData,group);}}};UBuilderSceneDelayLoader.prototype.parseWall=function parseWall(jsonData,floorPlan){var type=jsonData[loadKeys$2.wallType];var wall=null;if(type===0){wall=new Wall();wall.lightMapResource=DefaultResource.wallLightMapResource;}else{wall=new ModelWall();}this.parseBaseObject(jsonData,wall,floorPlan);var cornersIndex=jsonData[loadKeys$2.corners];wall.startCorner=floorPlan.corners[cornersIndex[0]];// floorPlan.corners[cornersIndex[0]];\nwall.endCorner=floorPlan.corners[cornersIndex[1]];// floorPlan.corners[cornersIndex[1]];\nif(jsonData[loadKeys$2.leftTexture]!==undefined){// wall.rightResource = this.resourceManager.textures[jsonData[loadKeys.leftTexture]];\nwall.leftResource=this.resourceManager.textures[jsonData[loadKeys$2.leftTexture]];}if(jsonData[loadKeys$2.rightTexture]!==undefined){// wall.leftResource = this.resourceManager.textures[jsonData[loadKeys.rightTexture]];\nwall.rightResource=this.resourceManager.textures[jsonData[loadKeys$2.rightTexture]];}if(jsonData[loadKeys$2.edgeTexture]!==undefined){wall.edgeResource=this.resourceManager.textures[jsonData[loadKeys$2.edgeTexture]];}//处理模型墙\nif(jsonData[loadKeys$2.model]!==undefined){wall.resource=this.resourceManager.models[jsonData[loadKeys$2.model]];}if(jsonData.isshow!==undefined){wall.isShow=jsonData.isshow;}if(jsonData[loadKeys$2.doorOrWindows]){var doorOrWinsData=jsonData[loadKeys$2.doorOrWindows];for(var i=0;i<doorOrWinsData.length;i++){var doorOrWinData=doorOrWinsData[i];this.parseDoorOrWindow(doorOrWinData,wall,floorPlan);}}if(jsonData.height){wall.height=jsonData.height;}// this.parseDoorOrWindow(jsonData,wall)\nwall.startCorner.addWall(wall);wall.endCorner.addWall(wall);floorPlan.addWall(wall);// return wall;\n};UBuilderSceneDelayLoader.prototype.parseRoom=function parseRoom(jsonData,plan){var room=new Room();this.parseBaseObject(jsonData,room,plan);var cornersIndex=jsonData[loadKeys$2.corners];if(cornersIndex){this.parseRoomCornerIndexs(room,cornersIndex);}if(room.points.length===0){this.parseRoomPoints(room,jsonData.points);}if(room.points.length===0){console.error("room points is null");return;}var holesIndexs=jsonData[loadKeys$2.holesCorners];if(holesIndexs){this.parseRoomHoleIndexs(room,holesIndexs);}this.parseRoomBlockSize(room,jsonData);this.parseRoomTextureInfo(room,jsonData);this.parseRoomHeight(room,jsonData);this.parseRoomVisible(room,jsonData);this.parseCombineData(room);this.setOutdoorFloorHeight(room,plan);plan.rooms.push(room);};UBuilderSceneDelayLoader.prototype.parseRoomCornerIndexs=function parseRoomCornerIndexs(room,cornersIndex){// var cornersIndex = jsonData[loadKeys.corners];\nvar points=[];var plan=room.parent;for(var i=0;i<cornersIndex.length;i++){var idx=cornersIndex[i];var point=plan.corners[idx].position.clone();points.push(point);}room.points=points;};UBuilderSceneDelayLoader.prototype.parseRoomPoints=function parseRoomPoints(room,pointsData){// var pointsData = jsonData.points;\nif(!pointsData){return;}var len=pointsData.length;var points=[];for(var i=0;i<len;i++){var pointData=pointsData[i];var x=pointData[0];var y=pointData[1];var z=-pointData[2];var point=new THREE.Vector3(x,y,z);points.push(point);}room.points=points;};UBuilderSceneDelayLoader.prototype.parseRoomHoleIndexs=function parseRoomHoleIndexs(room,holesIndexs){var holes=[];var plan=room.parent;var pos=room.position;for(var i=0;i<holesIndexs.length;i++){var holeIndexs=holesIndexs[i];var hole=[];for(var j=0;j<holeIndexs.length;j++){var idx=holeIndexs[j];hole.push(plan.corners[idx].position.clone());}holes.push(hole);}room.holes=holes;};UBuilderSceneDelayLoader.prototype.parseRoomTextureInfo=function parseRoomTextureInfo(room,jsonData){if(jsonData[loadKeys$2.floorTexture]!==undefined){room.floorResource=this.resourceManager.textures[jsonData[loadKeys$2.floorTexture]];}if(jsonData[loadKeys$2.ceilingTexture]!==undefined){room.ceilingResource=this.resourceManager.textures[jsonData[loadKeys$2.ceilingTexture]];}if(jsonData[loadKeys$2.roofTexture]!==undefined){room.roofResource=this.resourceManager.textures[jsonData[loadKeys$2.roofTexture]];}};UBuilderSceneDelayLoader.prototype.parseRoomHeight=function parseRoomHeight(room,jsonData){if(jsonData.ceilingheight!==undefined){room.ceiling.height=jsonData.ceilingheight;}if(jsonData.roofheight!==undefined){room.roof.height=jsonData.roofheight;}if(jsonData.floorheight!==undefined){room.floor.height=jsonData.floorheight;}};UBuilderSceneDelayLoader.prototype.parseRoomVisible=function parseRoomVisible(room,jsonData){if(jsonData.isshowfloor!==undefined){room.floor.isShow=jsonData.isshowfloor;}if(jsonData.isshowceiling!==undefined){room.ceiling.isShow=jsonData.isshowceiling;}if(jsonData.isshowroof!==undefined){room.roof.isShow=jsonData.isshowroof;}};UBuilderSceneDelayLoader.prototype.parseRoomBlockSize=function parseRoomBlockSize(room,jsonData){if(jsonData.floorblocksize){var dataArray=jsonData.floorblocksize;room.floor.blockSize=new THREE.Vector2(dataArray[0],dataArray[1]);}if(jsonData.ceilingblocksize){var dataArray=jsonData.ceilingblocksize;room.ceiling.blockSize=new THREE.Vector2(dataArray[0],dataArray[1]);}if(jsonData.roofblocksize){var dataArray=jsonData.roofblocksize;room.roof.blockSize=new THREE.Vector2(dataArray[0],dataArray[1]);}};UBuilderSceneDelayLoader.prototype.parseCombineData=function parseCombineData(room){if(!this.isCombine(room)){var pos=this.calRoomPosition(room);room.position=pos;this.subRoomHolesPointsByPosition(room,pos);this.subRoomPointsByPosition(room,pos);}};UBuilderSceneDelayLoader.prototype.setOutdoorFloorHeight=function setOutdoorFloorHeight(room,plan){if(plan instanceof Outdoors&&!room.floor.height){room.floor.height=0;}};UBuilderSceneDelayLoader.prototype.isCombine=function isCombine(room){if(room.properties||room.userID||room.name||room.floor.height){return false;}else{return true;}};UBuilderSceneDelayLoader.prototype.calRoomPosition=function calRoomPosition(room){var points=room.points;var pos=new THREE.Vector3();for(var i=0;i<points.length;i++){var point=points[i];pos.add(point);}pos.divideScalar(points.length);return pos;};UBuilderSceneDelayLoader.prototype.subRoomPointsByPosition=function subRoomPointsByPosition(room,pos){var points=room.points;for(var i=0;i<points.length;i++){var point=points[i];point.sub(pos);}};UBuilderSceneDelayLoader.prototype.subRoomHolesPointsByPosition=function subRoomHolesPointsByPosition(room,pos){var holes=room.holes;for(var i=0;i<holes.length;i++){var hole=holes[i];for(var j=0;j<hole.length;j++){var point=hole[j];point.sub(pos);}}};UBuilderSceneDelayLoader.prototype.parseBaseObject=function parseBaseObject(jsonData,baseObj,parent){var id,name,userID;baseObj.parent=parent;if(jsonData[loadKeys$2.id]){id=jsonData[loadKeys$2.id];baseObj.id=id;}//如果有用户自己起的id，则用用户的，否则就用默认的\nif(jsonData[loadKeys$2.userID]){userID=jsonData[loadKeys$2.userID];// baseObj.id = userID;\nbaseObj.userID=userID;// baseObj.name = userID;\n}if(jsonData[loadKeys$2.name]){name=jsonData[loadKeys$2.name];baseObj.name=name;}baseObj.jsonData=jsonData;if(jsonData[loadKeys$2.position]){var posArray=jsonData[loadKeys$2.position];var position=baseObj.position;position.set(posArray[0],posArray[1],-posArray[2]);// position = new THREE.Vector3(posArray[0], posArray[1], posArray[2]);\n// baseObj.position = position;\n}if(jsonData[loadKeys$2.scale]){var scaleArray=jsonData[loadKeys$2.scale];var scale=baseObj.scale;if(scaleArray[0]===0){scaleArray[0]=0.01;}if(scaleArray[1]===0){scaleArray[1]=0.01;}if(scaleArray[2]===0){scaleArray[2]=0.01;}scale.set(scaleArray[0],scaleArray[1],scaleArray[2]);// position = new THREE.Vector3(posArray[0], posArray[1], posArray[2]);\n// baseObj.position = position;\n}if(jsonData[loadKeys$2.rotation]){var rotArray=jsonData[loadKeys$2.rotation];var rotation=baseObj.rotation;rotation.set(rotArray[0],rotArray[1],-rotArray[2],-rotArray[3]);// rotation = new THREE.Quaternion(rotArray[0], rotArray[1], rotArray[2],rotArray[3]);\n// baseObj.rotation = rotation;\n}if(jsonData[loadKeys$2.properties]){baseObj.properties=jsonData[loadKeys$2.properties];}if(jsonData.isshow!==undefined&&jsonData.isshow!==null){baseObj.isShow=jsonData.isshow;}};UBuilderSceneDelayLoader.prototype.createRooms=function createRooms(){var roomMeshs=[];for(var i=0;i<this.curFloorPlan.rooms.length;i++){var room=this.curFloorPlan.rooms[i];roomMeshs.push(room.meshGroup);}return roomMeshs;};UBuilderSceneDelayLoader.prototype.createWalls=function createWalls(){var wallMeshs=[];for(var i=0;i<this.world.buildings.length;i++){var bd=this.world.buildings[i];for(var j=0;j<bd.floorplans.length;j++){var plan=bd.floorplans[j];for(var k=0;k<plan.walls.length;k++){var wall=plan.walls[k];// var pos = wall.position;\n// var group = new THREE.Group("wall");\n// group.add(this.createWallMesh(wall.rightSideMeshInfo));\n// group.add(this.createWallMesh(wall.leftSideMeshInfo));\n// group.add(this.createWallMesh(wall.edgeSideMeshInfo));\n// group.position.set(pos.x, pos.y, pos.z);\nwallMeshs.push(wall.wallGroup);}}}return wallMeshs;};UBuilderSceneDelayLoader.prototype.createWallMesh=function createWallMesh(meshInfo){var geometry=new THREE.BufferGeometry();geometry.addAttribute(\'position\',new THREE.BufferAttribute(meshInfo.positionArray,3));geometry.addAttribute(\'normal\',new THREE.BufferAttribute(meshInfo.normalArray,3));geometry.addAttribute(\'uv\',new THREE.BufferAttribute(meshInfo.uvArray,2));var material=meshInfo.material;var mesh=new THREE.Mesh(geometry,material);return mesh;};createClass(UBuilderSceneDelayLoader,[{key:\'downloadResourceProgress\',get:function get(){return this.resourceManager.downloadResProgess;}}]);return UBuilderSceneDelayLoader;}();/**\r\n\t * @author pzx 2018.2.13\r\n\t * Json2MeshBuilderParser\r\n\t */var ubuilderLoadSceneKeys$3={id:"id",name:"name",userID:"userid",position:"position",rotation:"rotation",scale:"scale",properties:"properties",plans:"plans",walls:"walls",placements:"placements",videoprobes:"videoprobes",groups:"groups",corners:"corners",doorOrWindows:"doororwindows",curveLines:"curvelines",pipeLines:"pipelines",text3Ds:"text3ds",rooms:"rooms",height:"height",thick:"thick",texture:"texture",type:"type",model:"model",suspendPercent:"suspendpercent",leftTexture:"lefttexture",rightTexture:"righttexture",edgeTexture:"edgetexture",floorTexture:"floortexture",ceilingTexture:"ceilingtexture",roofTexture:"rooftexture",isOpen:"isopen",openDirIndex:"diridx",wallType:"type"};var loadKeys$3=ubuilderLoadSceneKeys$3;var UBuilderSceneSimpleLoader=function(){function UBuilderSceneSimpleLoader(){classCallCheck(this,UBuilderSceneSimpleLoader);this.sceneJson=null;this.scale=1;//比例尺\nthis.curFloorPlan=null;this.enableCombine=true;this.defaultWallEdgeTextureUri="Textures/WallEdge.jpg";this.defaultWallTextureUri="Textures/RoomWall.jpg";this.defaultFloorTextureUri="Textures/FloorDefault.jpg";this.defaultCeilingTextureUri="Textures/CeilingDefault.jpg";this.defaultRoofTextureUri="Textures/RoofDefault.jpg";this.world=null;this.resourceManager=new ResourceManager();this.combineManager=new DelayCombineManager(this.resourceManager);this.combineParser=new UBuilderSceneDelayCombineParser(this);DefaultSetting.enableBuildMesh=false;}UBuilderSceneSimpleLoader.prototype.disposeModels=function disposeModels(){this.resourceManager.disposeModels();};UBuilderSceneSimpleLoader.prototype.disposeTextures=function disposeTextures(){this.resourceManager.disposeTextures();};UBuilderSceneSimpleLoader.prototype._nestingLoopYield=function _nestingLoopYield(gen,success,fail){var _this=this;var item=gen.next();if(item.done){if(success){success();}return item.value;}var value=item.value,done=item.done;if(value instanceof Promise){value.then(function(e){return _this._nestingLoopYield(gen,success,fail);}).catch(function(error){fail(error);});}else{this._nestingLoopYield(gen,success,fail);}};UBuilderSceneSimpleLoader.prototype.delayLoad=function delayLoad(map){var that=this;if(map){if(map["url"]){this.sceneURL=map["url"];this.resourceManager.localCustomModelBaseUrl=this.getParentRelativeUrl(this.sceneURL);}if(map["json"]){this.sceneJson=map["json"];}if(map.customModeBaseUrl){this.resourceManager.localCustomModelBaseUrl=map.customModeBaseUrl;}}else{console.error("load param can not be null");return null;}return new Promise(function(resolve,reject){// that.loadDefaultTexture().then(function () {\n//     return that.loadSceneJson();\n// }).\nthat.resourceManager.initLightMaps(function(){that.loadSceneJson().then(function(){// that.curFloorPlan = new FloorPlan();\nthat.parseSceneJson().then(function(){that.world.build();return new Promise(function(resolve,reject){that.combineParser.parseWorld(that.world);that.combineParser.buildWorld(that.world);// console.log("finish combine parser");\n// console.log("finish combine parser");\nresolve(that.world);});});}).then(function(){resolve(that.world);}).catch(function(error){console.error(error);});});});};UBuilderSceneSimpleLoader.prototype.loadFont=function loadFont(cb){var that=this;return new Promise(function(resolve,reject){var loader=new THREE.FontLoader();loader.load(\'./models/Font/Microsoft YaHei_Regular.json\',function(response){Text3D.font=response;cb();});});};UBuilderSceneSimpleLoader.prototype.loadResources=function loadResources(){var that=this;// this.resourceManager.localCustomModelBaseUrl =this.getParentRelativeUrl(this.sceneURL);\nreturn new Promise(function(resolve,reject){// that.resourceManager.downloadResources(function () {\n//     console.log("finish downloadResources");\n//     // resolve();\n//     resolve(that.world);\n// });\nthat.resourceManager.downloadResourcesWithQueue(function(){// console.log("finish downloadResources");\n// resolve();\nresolve(that.world);});});};UBuilderSceneSimpleLoader.prototype.getParentRelativeUrl=function getParentRelativeUrl(url){var list=url.split(\'/\');var parentUrl="";for(var i=0;i<list.length-1;i++){var obj=list[i];parentUrl+=obj+"/";}return parentUrl;};//pzx start\nUBuilderSceneSimpleLoader.prototype.load=function load(map){var that=this;if(map){if(map["url"]){this.sceneURL=map["url"];this.resourceManager.localCustomModelBaseUrl=this.getParentRelativeUrl(this.sceneURL);}if(map["json"]){this.sceneJson=map["json"];}}else{console.error("load param can not be null");return null;}return new Promise(function(resolve,reject){that.loadSceneJson().then(function(){// that.curFloorPlan = new FloorPlan();\nthat.parseSceneJson().then(function(){// that.world.build();\nresolve(that.world);});}).then(function(){resolve(that.world);}).catch(function(error){console.error(error);});});};UBuilderSceneSimpleLoader.prototype.loadSceneJson=function loadSceneJson(){var that=this;return new Promise(function(resolve,reject){if(that.sceneJson){resolve(that.sceneJson);}else if(that.sceneURL){var loader=new THREE.FileLoader();loader.load(that.sceneURL,function(data){that.sceneJson=JSON.parse(data);resolve();},function(){},function(error){reject("can not load "+that.sceneURL);});}else{reject("load scene json error");}});};UBuilderSceneSimpleLoader.prototype.createTextureLoaderPromise=function createTextureLoaderPromise(texUri){var that=this;return new Promise(function(resolve,reject){var texLoader=new THREE.TextureLoader();// var that = this;\n// load a resource\ntexLoader.load(// resource URL\n// that.sceneURL+"/"+texUri,\ntexUri,// Function when resource is loaded\nfunction(texture){texture.wrapS=THREE.RepeatWrapping;texture.wrapT=THREE.RepeatWrapping;resolve(texture);},// Function called when download progresses\nfunction(xhr){console.log(texUri+" "+xhr.loaded/xhr.total*100+\'% loaded\');},// Function called when download errors\nfunction(xhr){resolve(null);console.log(texUri+\'load error\');});});};UBuilderSceneSimpleLoader.prototype.parseSceneJson=function parseSceneJson(){var that=this;return new Promise(function(resolve,reject){that.resourceManager.delayDownload=true;that.resourceManager.loadTextures(that.sceneJson.textures);that.resourceManager.loadModels(that.sceneJson.models);// var id = setInterval(function () {\n//     if (that.resourceManager.checkAllResourcesIsReady()) {\n//         clearInterval(id);\nthat.parseWorld(that.sceneJson);resolve();//     }\n// }, 10);\n});};UBuilderSceneSimpleLoader.prototype.parseWorld=function parseWorld(jsonData){var world=new World();this.world=world;// world.jsonData = jsonData;\nthis.parseBaseObject(jsonData,world);if(jsonData["buildings"]){var buildingsData=jsonData["buildings"];for(var i=0;i<buildingsData.length;i++){var buildingData=buildingsData[i];var bd=this.parseBuilding(buildingData);// bd.jsonData = buildingData;\nworld.buildings.push(bd);}}if(jsonData["outdoors"]){var outdoors=new Outdoors();this.parseFloorPlan(jsonData["outdoors"],outdoors);world.outdoors=outdoors;}};UBuilderSceneSimpleLoader.prototype.parseBuilding=function parseBuilding(jsonData,parent){var buildingData=jsonData;var bd=new Building();this.parseBaseObject(jsonData,bd,parent);var plansData=buildingData[loadKeys$3.plans];if(plansData){for(var j=0;j<plansData.length;j++){var planData=plansData[j];var floorPlan=new FloorPlan();this.parseFloorPlan(planData,floorPlan,bd);bd.floorplans.push(floorPlan);}}var facadesData=buildingData.facades;if(facadesData){for(var i=0;i<facadesData.length;i++){var plcData=facadesData[i];this.parseFacade(plcData,bd);}}var facadeGroupsData=buildingData.facadegroups;if(facadeGroupsData){for(var i=0;i<facadeGroupsData.length;i++){var groupData=facadeGroupsData[i];this.parseFacadeGroup(groupData,bd);}}return bd;};UBuilderSceneSimpleLoader.prototype.parseFloorPlan=function parseFloorPlan(jsonData,floorPlan,parent){// var floorPlan = new FloorPlan();\n// floorPlan.id = id;\n// floorPlan.name = name;\nthis.parseBaseObject(jsonData,floorPlan,parent);if(jsonData[loadKeys$3.height]){floorPlan.height=jsonData[loadKeys$3.height];}if(jsonData[loadKeys$3.corners]){var cornersData=jsonData[loadKeys$3.corners];for(var i=0;i<cornersData.length;i++){var cornerData=cornersData[i];var x=cornerData[0];var y=cornerData[1];var z=-cornerData[2];if(!floorPlan.existsCorner(x,y,z)){floorPlan.addCorner(x,y,z);}else{console.error("repeat corner");}}}if(jsonData[loadKeys$3.walls]){var wallsData=jsonData[loadKeys$3.walls];for(var i=0;i<wallsData.length;i++){var wallData=wallsData[i];this.parseWall(wallData,floorPlan);}}if(jsonData[loadKeys$3.rooms]){var roomsData=jsonData[loadKeys$3.rooms];for(var i=0;i<roomsData.length;i++){var roomData=roomsData[i];this.parseRoom(roomData,floorPlan);}}if(jsonData[loadKeys$3.placements]){var plcsData=jsonData[loadKeys$3.placements];for(var i=0;i<plcsData.length;i++){var plcData=plcsData[i];this.parsePlacement(plcData,floorPlan);}}if(jsonData[loadKeys$3.videoprobes]){var plcsData=jsonData[loadKeys$3.videoprobes];for(var i=0;i<plcsData.length;i++){var plcData=plcsData[i];this.parsePlacement(plcData,floorPlan);}}if(jsonData[loadKeys$3.groups]){var groupsData=jsonData[loadKeys$3.groups];for(var i=0;i<groupsData.length;i++){var groupData=groupsData[i];this.parseGroup(groupData,floorPlan);}}if(jsonData[loadKeys$3.doorOrWindows]){var doorOrWinsData=jsonData[loadKeys$3.doorOrWindows];for(var i=0;i<doorOrWinsData.length;i++){var doorOrWinData=doorOrWinsData[i];this.parseDoorOrWindow(doorOrWinData,floorPlan);}}if(jsonData[loadKeys$3.curveLines]){var linesData=jsonData[loadKeys$3.curveLines];for(var i=0;i<linesData.length;i++){var data=linesData[i];this.parseCurveLine(data,floorPlan);}}if(jsonData[loadKeys$3.pipeLines]){var linesData=jsonData[loadKeys$3.pipeLines];for(var i=0;i<linesData.length;i++){var data=linesData[i];this.parsePipeLine(data,floorPlan);}}if(jsonData[loadKeys$3.text3Ds]){var textsData=jsonData[loadKeys$3.text3Ds];for(var i=0;i<textsData.length;i++){var data=textsData[i];this.parseText3D(data,floorPlan);}}return floorPlan;};UBuilderSceneSimpleLoader.prototype.parseText3D=function parseText3D(jsonData,plan){var text3D=new Text3D();this.parseBaseObject(jsonData,text3D,plan);if(jsonData.color){var colorData=jsonData.color;text3D.color=new THREE.Color(colorData[0],colorData[1],colorData[2]);if(colorData.length===4){text3D.opacity=colorData[3];}}if(jsonData.font!==undefined){text3D.font=jsonData.font;}if(jsonData.text!==undefined){text3D.text=jsonData.text;}plan.text3Ds.push(text3D);};UBuilderSceneSimpleLoader.prototype.parsePipeLine=function parsePipeLine(jsonData,plan){var line=new PipeLine();this.parseBaseObject(jsonData,line,plan);if(jsonData[loadKeys$3.texture]!==undefined){line.resource=this.resourceManager.textures[jsonData[loadKeys$3.texture]];}if(jsonData.color){var colorData=jsonData.color;line.color=new THREE.Color(colorData[0],colorData[1],colorData[2]);if(colorData.length===4){line.opacity=colorData[3];}}if(jsonData.sectionType){line.sectionType=jsonData.sectionType;}if(jsonData.rendermode!==undefined){line.renderMode=jsonData.rendermode;}if(jsonData.radius!==undefined){line.radius=jsonData.radius;}plan.pipelines.push(line);var points=jsonData.path;for(var i=0;i<points.length;i++){var point=points[i];var x=point[0];var y=point[1];var z=-point[2];var pos=new THREE.Vector3(x,y,z);line.points.push(pos);}};UBuilderSceneSimpleLoader.prototype.parseCurveLine=function parseCurveLine(jsonData,plan){var line=new CurveLine();this.parseBaseObject(jsonData,line,plan);if(jsonData[loadKeys$3.texture]!==undefined){line.resource=this.resourceManager.textures[jsonData[loadKeys$3.texture]];}if(jsonData.color){var colorData=jsonData.color;line.color=new THREE.Color(colorData[0],colorData[1],colorData[2]);if(colorData.length===4){line.opacity=colorData[3];}}if(jsonData.width!==undefined){line.width=jsonData.width;}plan.curvelines.push(line);var points=jsonData.path;for(var i=0;i<points.length;i++){var point=points[i];var x=point[0];var y=point[1];var z=-point[2];var pos=new THREE.Vector3(x,y,z);line.points.push(pos);}};UBuilderSceneSimpleLoader.prototype.parseDoorOrWindow=function parseDoorOrWindow(jsonData,wall){var doorOrWin=new DoorOrWindow();this.parseBaseObject(jsonData,doorOrWin,wall.parent);doorOrWin.resource=this.resourceManager.models[jsonData[loadKeys$3.model]];wall.doorOrWindows.push(doorOrWin);if(jsonData[loadKeys$3.suspendPercent]){doorOrWin.suspendPercent=jsonData[loadKeys$3.suspendPercent];}if(jsonData[loadKeys$3.isOpen]){doorOrWin.isOpen=jsonData[loadKeys$3.isOpen];}if(jsonData[loadKeys$3.openDirIndex]){doorOrWin.openDirIndex=jsonData[loadKeys$3.openDirIndex];}doorOrWin.attachWall=wall;};UBuilderSceneSimpleLoader.prototype.parseFacade=function parseFacade(jsonData,bd){var facade=new Facade();this.parseBaseObject(jsonData,facade,bd);facade.resource=this.resourceManager.models[jsonData[loadKeys$3.model]];if(jsonData.texture!==undefined&&jsonData.texture!==null){facade.customTextureResource=this.resourceManager.textures[jsonData.texture];}if(jsonData.color){var colorData=jsonData.color;facade.customColor=new THREE.Color(colorData[0],colorData[1],colorData[2]);if(colorData.length===4){facade.opacity=colorData[3];}}if(jsonData.rendermode){facade.renderMode=jsonData.rendermode;}bd.facades.push(facade);};UBuilderSceneSimpleLoader.prototype.parseFacadeGroup=function parseFacadeGroup(jsonData,bd){var group=new FacadeGroup();this.parseBaseObject(jsonData,group,bd);if(bd instanceof Building){bd.facadeGroups.push(group);}else{bd.groups.push(group);}if(jsonData[loadKeys$3.placements]){var plcsData=jsonData[loadKeys$3.placements];for(var i=0;i<plcsData.length;i++){var plcData=plcsData[i];this.parseFacadeGroupChild(plcData,group);}}if(jsonData[loadKeys$3.groups]){var groupsData=jsonData[loadKeys$3.groups];for(var i=0;i<groupsData.length;i++){var groupData=groupsData[i];this.parseFacadeGroup(groupData,group);}}};UBuilderSceneSimpleLoader.prototype.parseFacadeGroupChild=function parseFacadeGroupChild(jsonData,group){var facade=new Facade();this.parseBaseObject(jsonData,facade,group);facade.resource=this.resourceManager.models[jsonData[loadKeys$3.model]];if(jsonData.texture!==undefined&&jsonData.texture!==null){facade.customTextureResource=this.resourceManager.textures[jsonData.texture];}if(jsonData.color){var colorData=jsonData.color;facade.customColor=new THREE.Color(colorData[0],colorData[1],colorData[2]);if(colorData.length===4){facade.opacity=colorData[3];}}if(jsonData.rendermode){facade.renderMode=jsonData.rendermode;}group.placements.push(facade);};UBuilderSceneSimpleLoader.prototype.parsePlacement=function parsePlacement(jsonData,plan){var plc=new Placement();this.parseBaseObject(jsonData,plc,plan);plc.resource=this.resourceManager.models[jsonData[loadKeys$3.model]];if(jsonData.texture!==undefined&&jsonData.texture!==null){plc.customTextureResource=this.resourceManager.textures[jsonData.texture];}if(jsonData.color){var colorData=jsonData.color;plc.customColor=new THREE.Color(colorData[0],colorData[1],colorData[2]);if(colorData.length===4){plc.opacity=colorData[3];}}if(jsonData.rendermode){plc.renderMode=jsonData.rendermode;}if(jsonData.animinfo){plc.isPlayAnim=jsonData.animinfo.isplay;plc.animClip=jsonData.animinfo.clip;}plan.placements.push(plc);};UBuilderSceneSimpleLoader.prototype.parseGroup=function parseGroup(jsonData,plan){var group=new PlacementGroup();this.parseBaseObject(jsonData,group,plan);plan.groups.push(group);if(jsonData[loadKeys$3.placements]){var plcsData=jsonData[loadKeys$3.placements];for(var i=0;i<plcsData.length;i++){var plcData=plcsData[i];this.parsePlacement(plcData,group);}}if(jsonData[loadKeys$3.groups]){var groupsData=jsonData[loadKeys$3.groups];for(var i=0;i<groupsData.length;i++){var groupData=groupsData[i];this.parseGroup(groupData,group);}}};UBuilderSceneSimpleLoader.prototype.parseWall=function parseWall(jsonData,floorPlan){var type=jsonData[loadKeys$3.wallType];var wall=null;if(type===0){wall=new Wall();wall.lightMapResource=DefaultResource.wallLightMapResource;}else{wall=new ModelWall();}this.parseBaseObject(jsonData,wall,floorPlan);var cornersIndex=jsonData[loadKeys$3.corners];wall.startCorner=floorPlan.corners[cornersIndex[0]];wall.endCorner=floorPlan.corners[cornersIndex[1]];if(jsonData[loadKeys$3.leftTexture]!==undefined){// wall.rightResource = this.resourceManager.textures[jsonData[loadKeys.leftTexture]];\nwall.rightResource=this.resourceManager.textures[jsonData[loadKeys$3.leftTexture]];}if(jsonData[loadKeys$3.rightTexture]!==undefined){// wall.leftResource = this.resourceManager.textures[jsonData[loadKeys.rightTexture]];\nwall.leftResource=this.resourceManager.textures[jsonData[loadKeys$3.rightTexture]];}if(jsonData[loadKeys$3.edgeTexture]!==undefined){wall.edgeResource=this.resourceManager.textures[jsonData[loadKeys$3.edgeTexture]];}//处理模型墙\nif(jsonData[loadKeys$3.model]!==undefined){wall.resource=this.resourceManager.models[jsonData[loadKeys$3.model]];}if(jsonData.isshow!==undefined){wall.isShow=jsonData.isshow;}if(jsonData[loadKeys$3.doorOrWindows]){var doorOrWinsData=jsonData[loadKeys$3.doorOrWindows];for(var i=0;i<doorOrWinsData.length;i++){var doorOrWinData=doorOrWinsData[i];this.parseDoorOrWindow(doorOrWinData,wall,floorPlan);}}if(jsonData.height){wall.height=jsonData.height;}// this.parseDoorOrWindow(jsonData,wall)\nwall.startCorner.addWall(wall);wall.endCorner.addWall(wall);floorPlan.addWall(wall);// return wall;\n};UBuilderSceneSimpleLoader.prototype.parseRoom=function parseRoom(jsonData,plan){var room=new Room();this.parseBaseObject(jsonData,room,plan);var cornersIndex=jsonData[loadKeys$3.corners];var points=[];if(cornersIndex){for(var i=0;i<cornersIndex.length;i++){var idx=cornersIndex[i];points.push(plan.corners[idx].position);}}if(points.length===0){var pointsData=jsonData.points;if(!pointsData){return;}for(var i=0;i<pointsData.length;i++){var pointData=pointsData[i];var x=pointData[0];var y=pointData[1];var z=-pointData[2];var point=new THREE.Vector3(x,y,z);points.push(point);}}if(points.length===0){console.error("room points is null");return;}if(jsonData[loadKeys$3.floorTexture]!==undefined){room.floorResource=this.resourceManager.textures[jsonData[loadKeys$3.floorTexture]];}if(jsonData[loadKeys$3.ceilingTexture]!==undefined){room.ceilingResource=this.resourceManager.textures[jsonData[loadKeys$3.ceilingTexture]];}if(jsonData[loadKeys$3.roofTexture]!==undefined){room.roofResource=this.resourceManager.textures[jsonData[loadKeys$3.roofTexture]];}if(jsonData.isshowfloor!==undefined){room.floor.isShow=jsonData.isshowfloor;}if(jsonData.isshowceiling!==undefined){room.ceiling.isShow=jsonData.isshowceiling;}if(jsonData.isshowroof!==undefined){room.roof.isShow=jsonData.isshowroof;}if(jsonData.ceilingheight!==undefined){room.ceiling.height=jsonData.ceilingheight;}if(jsonData.roofheight!==undefined){room.roof.height=jsonData.roofheight;}if(jsonData.floorheight!==undefined){room.floor.height=jsonData.floorheight;}if(jsonData.floorblocksize){var dataArray=jsonData.floorblocksize;room.floor.blockSize=new THREE.Vector2(dataArray[0],dataArray[1]);}if(jsonData.ceilingblocksize){var dataArray=jsonData.ceilingblocksize;room.ceiling.blockSize=new THREE.Vector2(dataArray[0],dataArray[1]);}if(jsonData.roofblocksize){var dataArray=jsonData.roofblocksize;room.roof.blockSize=new THREE.Vector2(dataArray[0],dataArray[1]);}room.points=points;if(room.properties||room.userID||room.name){plan.rooms.push(room);}};UBuilderSceneSimpleLoader.prototype.parseBaseObject=function parseBaseObject(jsonData,baseObj,parent){var id,name,userID;baseObj.parent=parent;if(jsonData[loadKeys$3.id]){id=jsonData[loadKeys$3.id];baseObj.id=id;}//如果有用户自己起的id，则用用户的，否则就用默认的\nif(jsonData[loadKeys$3.userID]){userID=jsonData[loadKeys$3.userID];// baseObj.id = userID;\nbaseObj.userID=userID;// baseObj.name = userID;\n}if(jsonData[loadKeys$3.name]){name=jsonData[loadKeys$3.name];baseObj.name=name;}baseObj.jsonData=jsonData;if(jsonData[loadKeys$3.position]){var posArray=jsonData[loadKeys$3.position];var position=baseObj.position;position.set(posArray[0],posArray[1],-posArray[2]);// position = new THREE.Vector3(posArray[0], posArray[1], posArray[2]);\n// baseObj.position = position;\n}if(jsonData[loadKeys$3.scale]){var scaleArray=jsonData[loadKeys$3.scale];var scale=baseObj.scale;if(scaleArray[0]===0){scaleArray[0]=0.01;}if(scaleArray[1]===0){scaleArray[1]=0.01;}if(scaleArray[2]===0){scaleArray[2]=0.01;}scale.set(scaleArray[0],scaleArray[1],scaleArray[2]);// position = new THREE.Vector3(posArray[0], posArray[1], posArray[2]);\n// baseObj.position = position;\n}if(jsonData[loadKeys$3.rotation]){var rotArray=jsonData[loadKeys$3.rotation];var rotation=baseObj.rotation;rotation.set(rotArray[0],rotArray[1],-rotArray[2],-rotArray[3]);// rotation = new THREE.Quaternion(rotArray[0], rotArray[1], rotArray[2],rotArray[3]);\n// baseObj.rotation = rotation;\n}if(jsonData[loadKeys$3.properties]){baseObj.properties=jsonData[loadKeys$3.properties];}if(jsonData.isshow!==undefined&&jsonData.isshow!==null){baseObj.isShow=jsonData.isshow;}};UBuilderSceneSimpleLoader.prototype.createRooms=function createRooms(){var roomMeshs=[];for(var i=0;i<this.curFloorPlan.rooms.length;i++){var room=this.curFloorPlan.rooms[i];roomMeshs.push(room.meshGroup);}return roomMeshs;};UBuilderSceneSimpleLoader.prototype.createWalls=function createWalls(){var wallMeshs=[];for(var i=0;i<this.world.buildings.length;i++){var bd=this.world.buildings[i];for(var j=0;j<bd.floorplans.length;j++){var plan=bd.floorplans[j];for(var k=0;k<plan.walls.length;k++){var wall=plan.walls[k];// var pos = wall.position;\n// var group = new THREE.Group("wall");\n// group.add(this.createWallMesh(wall.rightSideMeshInfo));\n// group.add(this.createWallMesh(wall.leftSideMeshInfo));\n// group.add(this.createWallMesh(wall.edgeSideMeshInfo));\n// group.position.set(pos.x, pos.y, pos.z);\nwallMeshs.push(wall.wallGroup);}}}return wallMeshs;};UBuilderSceneSimpleLoader.prototype.createWallMesh=function createWallMesh(meshInfo){var geometry=new THREE.BufferGeometry();geometry.addAttribute(\'position\',new THREE.BufferAttribute(meshInfo.positionArray,3));geometry.addAttribute(\'normal\',new THREE.BufferAttribute(meshInfo.normalArray,3));geometry.addAttribute(\'uv\',new THREE.BufferAttribute(meshInfo.uvArray,2));var material=meshInfo.material;var mesh=new THREE.Mesh(geometry,material);return mesh;};createClass(UBuilderSceneSimpleLoader,[{key:\'downloadResourceProgress\',get:function get(){return this.resourceManager.downloadResProgess;}}]);return UBuilderSceneSimpleLoader;}();/**\r\n\t * @author pzx 2018.2.13\r\n\t * Json2MeshBuilderParser\r\n\t */var ubuilderLoadSceneKeys$4={id:"id",name:"name",position:"position",rotation:"rotation",scale:"scale",properties:"properties",plans:"plans",walls:"walls",placements:"placements",videoprobes:"videoprobes",groups:"groups",corners:"corners",doorOrWindows:"doororwindows",curveLines:"curvelines",pipeLines:"pipelines",rooms:"rooms",height:"height",thick:"thick",texture:"texture",type:"type",model:"model",suspendPercent:"suspendpercent",leftTexture:"lefttexture",rightTexture:"righttexture",edgeTexture:"edgetexture",floorTexture:"floortexture",ceilingTexture:"ceilingtexture",roofTexture:"rooftexture",isOpen:"isopen",wallType:"type"};var loadKeys$4=ubuilderLoadSceneKeys$4;var ExportTestXSLoader=function(){function ExportTestXSLoader(){classCallCheck(this,ExportTestXSLoader);this.sceneJson=null;this.scale=1;//比例尺\nthis.curFloorPlan=null;this.enableCombine=true;this.defaultWallEdgeTextureUri="Textures/WallEdge.jpg";this.defaultWallTextureUri="Textures/RoomWall.jpg";this.defaultFloorTextureUri="Textures/FloorDefault.jpg";this.defaultCeilingTextureUri="Textures/CeilingDefault.jpg";this.defaultRoofTextureUri="Textures/RoofDefault.jpg";this.world=null;this.resourceManager=new ResourceManager();this.combineManager=new DelayCombineManager(this.resourceManager);this.combineParser=new UBuilderSceneDelayCombineParser(this);DefaultSetting.enableBuildMesh=false;}ExportTestXSLoader.prototype._nestingLoopYield=function _nestingLoopYield(gen,success,fail){var _this=this;var item=gen.next();if(item.done){if(success){success();}return item.value;}var value=item.value,done=item.done;if(value instanceof Promise){value.then(function(e){return _this._nestingLoopYield(gen,success,fail);}).catch(function(error){fail(error);});}else{this._nestingLoopYield(gen,success,fail);}};ExportTestXSLoader.prototype.delayLoad=function delayLoad(map){var that=this;if(map){if(map["url"]){this.sceneURL=map["url"];}if(map["json"]){this.sceneJson=map["json"];}}else{console.error("load param can not be null");return null;}return new Promise(function(resolve,reject){// that.loadDefaultTexture().then(function () {\n//     return that.loadSceneJson();\n// }).\nthat.loadSceneJson().then(function(){// that.curFloorPlan = new FloorPlan();\nthat.parseSceneJson().then(function(){that.world.build();return new Promise(function(resolve,reject){that.combineParser.parseWorld(that.world);that.combineParser.buildWorld(that.world);console.log("finish combine parser");// console.log("finish combine parser");\nresolve(that.world);});});}).then(function(){resolve(that.world);}).catch(function(error){console.error(error);});});};ExportTestXSLoader.prototype.loadResources=function loadResources(){var that=this;return new Promise(function(resolve,reject){// that.resourceManager.downloadResources(function () {\n//     console.log("finish downloadResources");\n//     // resolve();\n//     resolve(that.world);\n// });\nthat.resourceManager.downloadResourcesWithQueue(function(){console.log("finish downloadResources");// resolve();\nresolve(that.world);});});};//pzx start\nExportTestXSLoader.prototype.load=function load(map){var that=this;if(map){if(map["url"]){this.sceneURL=map["url"];}if(map["json"]){this.sceneJson=map["json"];}}else{console.error("load param can not be null");return null;}return new Promise(function(resolve,reject){// that.loadDefaultTexture().then(function () {\n//     return that.loadSceneJson();\n// }).\nthat.loadSceneJson().then(function(){// that.curFloorPlan = new FloorPlan();\nthat.parseSceneJson().then(function(){// that.world.build();\nresolve(that.world);});}).then(function(){resolve(that.world);}).catch(function(error){console.error(error);});});};ExportTestXSLoader.prototype.loadSceneJson=function loadSceneJson(){var that=this;return new Promise(function(resolve,reject){if(that.sceneJson){resolve(that.sceneJson);}else if(that.sceneURL){var loader=new THREE.FileLoader();loader.load(that.sceneURL,function(data){that.sceneJson=JSON.parse(data);resolve();},function(){},function(error){reject("can not load "+that.sceneURL);});}else{reject("load scene json error");}});};ExportTestXSLoader.prototype.createTextureLoaderPromise=function createTextureLoaderPromise(texUri){var that=this;return new Promise(function(resolve,reject){var texLoader=new THREE.TextureLoader();// var that = this;\n// load a resource\ntexLoader.load(// resource URL\n// that.sceneURL+"/"+texUri,\ntexUri,// Function when resource is loaded\nfunction(texture){texture.wrapS=THREE.RepeatWrapping;texture.wrapT=THREE.RepeatWrapping;resolve(texture);},// Function called when download progresses\nfunction(xhr){console.log(texUri+" "+xhr.loaded/xhr.total*100+\'% loaded\');},// Function called when download errors\nfunction(xhr){resolve(null);console.log(texUri+\'load error\');});});};ExportTestXSLoader.prototype.parseSceneJson=function parseSceneJson(){var that=this;return new Promise(function(resolve,reject){that.parseWorld(that.sceneJson);resolve();});};ExportTestXSLoader.prototype.parseWorld=function parseWorld(jsonData){var world=new World();this.world=world;// world.jsonData = jsonData;\nthis.parseBaseObject(jsonData,world);if(jsonData["buildings"]){var buildingsData=jsonData["buildings"];for(var i=0;i<buildingsData.length;i++){var buildingData=buildingsData[i];var bd=this.parseBuilding(buildingData);// bd.jsonData = buildingData;\nworld.buildings.push(bd);}}if(jsonData["outdoors"]){var outdoors=new Outdoors();this.parseFloorPlan(jsonData["outdoors"],outdoors);world.outdoors=outdoors;}};ExportTestXSLoader.prototype.parseBuilding=function parseBuilding(jsonData,parent){var buildingData=jsonData;var bd=new Building();this.parseBaseObject(jsonData,bd,parent);var plansData=buildingData[loadKeys$4.plans];if(plansData){for(var j=0;j<plansData.length;j++){var planData=plansData[j];var floorPlan=new FloorPlan();this.parseFloorPlan(planData,floorPlan,bd);bd.floorplans.push(floorPlan);}}var facadesData=buildingData.facades;if(facadesData){for(var i=0;i<facadesData.length;i++){var plcData=facadesData[i];this.parseFacade(plcData,bd);}}var facadeGroupsData=buildingData.facadegroups;if(facadeGroupsData){for(var i=0;i<facadeGroupsData.length;i++){var groupData=facadeGroupsData[i];this.parseFacadeGroup(groupData,bd);}}return bd;};ExportTestXSLoader.prototype.parseFloorPlan=function parseFloorPlan(jsonData,floorPlan,parent){// var floorPlan = new FloorPlan();\n// floorPlan.id = id;\n// floorPlan.name = name;\nthis.parseBaseObject(jsonData,floorPlan,parent);if(jsonData[loadKeys$4.height]){floorPlan.height=jsonData[loadKeys$4.height];}if(jsonData[loadKeys$4.corners]){var cornersData=jsonData[loadKeys$4.corners];for(var i=0;i<cornersData.length;i++){var cornerData=cornersData[i];var x=cornerData[0];var y=cornerData[1];var z=-cornerData[2];if(!floorPlan.existsCorner(x,y,z)){floorPlan.addCorner(x,y,z);}else{console.error("repeat corner");}}}if(jsonData[loadKeys$4.walls]){var wallsData=jsonData[loadKeys$4.walls];for(var i=0;i<wallsData.length;i++){var wallData=wallsData[i];this.parseWall(wallData,floorPlan);}}// if (jsonData[loadKeys.rooms]) {\n//     var roomsData = jsonData[loadKeys.rooms];\n//     for (var i = 0; i < roomsData.length; i++) {\n//         var roomData = roomsData[i];\n//         this.parseRoom(roomData, floorPlan);\n//     }\n// }\n//\n// if (jsonData[loadKeys.placements]) {\n//     var plcsData = jsonData[loadKeys.placements];\n//     for (var i = 0; i < plcsData.length; i++) {\n//         var plcData = plcsData[i];\n//         this.parsePlacement(plcData, floorPlan);\n//     }\n// }\n//\n// if (jsonData[loadKeys.videoprobes]) {\n//     var plcsData = jsonData[loadKeys.videoprobes];\n//     for (var i = 0; i < plcsData.length; i++) {\n//         var plcData = plcsData[i];\n//         this.parsePlacement(plcData, floorPlan);\n//     }\n// }\n//\n//\n// if (jsonData[loadKeys.groups]) {\n//     var groupsData = jsonData[loadKeys.groups];\n//     for (var i = 0; i < groupsData.length; i++) {\n//         var groupData = groupsData[i];\n//         this.parseGroup(groupData, floorPlan);\n//     }\n// }\n//\n// if (jsonData[loadKeys.doorOrWindows]) {\n//     var doorOrWinsData = jsonData[loadKeys.doorOrWindows];\n//     for (var i = 0; i < doorOrWinsData.length; i++) {\n//         var doorOrWinData = doorOrWinsData[i];\n//         this.parseDoorOrWindow(doorOrWinData, floorPlan);\n//     }\n// }\n//\n// if(jsonData[loadKeys.curveLines]){\n//     var linesData =jsonData[loadKeys.curveLines];\n//     for (var i = 0; i < linesData.length; i++) {\n//         var data = linesData[i];\n//         this.parseCurveLine(data,floorPlan)\n//     }\n// }\n//\n// if(jsonData[loadKeys.pipeLines]){\n//     var linesData =jsonData[loadKeys.pipeLines];\n//     for (var i = 0; i < linesData.length; i++) {\n//         var data = linesData[i];\n//         this.parsePipeLine(data,floorPlan)\n//     }\n// }\nreturn floorPlan;};ExportTestXSLoader.prototype.parsePipeLine=function parsePipeLine(jsonData,plan){var line=new PipeLine();this.parseBaseObject(jsonData,line,plan);if(jsonData[loadKeys$4.texture]!==undefined){line.resource=this.resourceManager.textures[jsonData[loadKeys$4.texture]];}if(jsonData.color){var colorData=jsonData.color;line.color=new THREE.Color(colorData[0],colorData[1],colorData[2]);if(colorData.length===4){line.opacity=colorData[3];}}if(jsonData.sectionType){line.sectionType=jsonData.sectionType;}if(jsonData.rendermode!==undefined){line.renderMode=jsonData.rendermode;}if(jsonData.radius!==undefined){line.radius=jsonData.radius;}plan.pipelines.push(line);var points=jsonData.path;for(var i=0;i<points.length;i++){var point=points[i];var x=point[0];var y=point[1];var z=-point[2];var pos=new THREE.Vector3(x,y,z);line.points.push(pos);}};ExportTestXSLoader.prototype.parseCurveLine=function parseCurveLine(jsonData,plan){var line=new CurveLine();this.parseBaseObject(jsonData,line,plan);if(jsonData[loadKeys$4.texture]!==undefined){line.resource=this.resourceManager.textures[jsonData[loadKeys$4.texture]];}if(jsonData.color){var colorData=jsonData.color;line.color=new THREE.Color(colorData[0],colorData[1],colorData[2]);if(colorData.length===4){line.opacity=colorData[3];}}if(jsonData.width!==undefined){line.width=jsonData.width;}plan.curvelines.push(line);var points=jsonData.path;for(var i=0;i<points.length;i++){var point=points[i];var x=point[0];var y=point[1];var z=-point[2];var pos=new THREE.Vector3(x,y,z);line.points.push(pos);}};ExportTestXSLoader.prototype.parseDoorOrWindow=function parseDoorOrWindow(jsonData,wall){var doorOrWin=new DoorOrWindow();this.parseBaseObject(jsonData,doorOrWin,wall.parent);doorOrWin.resource=this.resourceManager.models[jsonData[loadKeys$4.model]];wall.doorOrWindows.push(doorOrWin);if(jsonData[loadKeys$4.suspendPercent]){doorOrWin.suspendPercent=jsonData[loadKeys$4.suspendPercent];}if(jsonData[loadKeys$4.isOpen]){doorOrWin.isOpen=jsonData[loadKeys$4.isOpen];}doorOrWin.attachWall=wall;};ExportTestXSLoader.prototype.parseFacade=function parseFacade(jsonData,bd){var facade=new Facade();this.parseBaseObject(jsonData,facade,bd);facade.resource=this.resourceManager.models[jsonData[loadKeys$4.model]];if(jsonData.texture!==undefined&&jsonData.texture!==null){facade.customTextureResource=this.resourceManager.textures[jsonData.texture];}if(jsonData.color){var colorData=jsonData.color;facade.customColor=new THREE.Color(colorData[0],colorData[1],colorData[2]);if(colorData.length===4){facade.opacity=colorData[3];}}if(jsonData.rendermode){facade.renderMode=jsonData.rendermode;}bd.facades.push(facade);};ExportTestXSLoader.prototype.parseFacadeGroup=function parseFacadeGroup(jsonData,bd){var group=new FacadeGroup();this.parseBaseObject(jsonData,group,bd);if(bd instanceof Building){bd.facadeGroups.push(group);}else{bd.groups.push(group);}if(jsonData[loadKeys$4.placements]){var plcsData=jsonData[loadKeys$4.placements];for(var i=0;i<plcsData.length;i++){var plcData=plcsData[i];this.parseFacadeGroupChild(plcData,group);}}if(jsonData[loadKeys$4.groups]){var groupsData=jsonData[loadKeys$4.groups];for(var i=0;i<groupsData.length;i++){var groupData=groupsData[i];this.parseFacadeGroup(groupData,group);}}};ExportTestXSLoader.prototype.parseFacadeGroupChild=function parseFacadeGroupChild(jsonData,group){var facade=new Facade();this.parseBaseObject(jsonData,facade,group);facade.resource=this.resourceManager.models[jsonData[loadKeys$4.model]];if(jsonData.texture!==undefined&&jsonData.texture!==null){facade.customTextureResource=this.resourceManager.textures[jsonData.texture];}if(jsonData.color){var colorData=jsonData.color;facade.customColor=new THREE.Color(colorData[0],colorData[1],colorData[2]);if(colorData.length===4){facade.opacity=colorData[3];}}if(jsonData.rendermode){facade.renderMode=jsonData.rendermode;}group.placements.push(facade);};ExportTestXSLoader.prototype.parsePlacement=function parsePlacement(jsonData,plan){var plc=new Placement();this.parseBaseObject(jsonData,plc,plan);plc.resource=this.resourceManager.models[jsonData[loadKeys$4.model]];if(jsonData.texture!==undefined&&jsonData.texture!==null){plc.customTextureResource=this.resourceManager.textures[jsonData.texture];}if(jsonData.color){var colorData=jsonData.color;plc.customColor=new THREE.Color(colorData[0],colorData[1],colorData[2]);if(colorData.length===4){plc.opacity=colorData[3];}}if(jsonData.rendermode){plc.renderMode=jsonData.rendermode;}plan.placements.push(plc);};ExportTestXSLoader.prototype.parseGroup=function parseGroup(jsonData,plan){var group=new PlacementGroup();this.parseBaseObject(jsonData,group,plan);plan.groups.push(group);if(jsonData[loadKeys$4.placements]){var plcsData=jsonData[loadKeys$4.placements];for(var i=0;i<plcsData.length;i++){var plcData=plcsData[i];this.parsePlacement(plcData,group);}}if(jsonData[loadKeys$4.groups]){var groupsData=jsonData[loadKeys$4.groups];for(var i=0;i<groupsData.length;i++){var groupData=groupsData[i];this.parseGroup(groupData,group);}}};ExportTestXSLoader.prototype.parseWall=function parseWall(jsonData,floorPlan){var type=jsonData[loadKeys$4.wallType];var wall=null;if(type===0){wall=new Wall();}else{wall=new ModelWall();}this.parseBaseObject(jsonData,wall,floorPlan);var cornersIndex=jsonData[loadKeys$4.corners];wall.startCorner=floorPlan.corners[cornersIndex[0]];wall.endCorner=floorPlan.corners[cornersIndex[1]];if(jsonData[loadKeys$4.leftTexture]!==undefined){// wall.rightResource = this.resourceManager.textures[jsonData[loadKeys.leftTexture]];\nwall.rightResource=this.resourceManager.textures[jsonData[loadKeys$4.leftTexture]];}if(jsonData[loadKeys$4.rightTexture]!==undefined){// wall.leftResource = this.resourceManager.textures[jsonData[loadKeys.rightTexture]];\nwall.leftResource=this.resourceManager.textures[jsonData[loadKeys$4.rightTexture]];}if(jsonData[loadKeys$4.edgeTexture]!==undefined){wall.edgeResource=this.resourceManager.textures[jsonData[loadKeys$4.edgeTexture]];}//处理模型墙\nif(jsonData[loadKeys$4.model]!==undefined){wall.resource=this.resourceManager.models[jsonData[loadKeys$4.model]];}if(jsonData.isshow!==undefined){wall.isShow=jsonData.isshow;}if(jsonData[loadKeys$4.doorOrWindows]){var doorOrWinsData=jsonData[loadKeys$4.doorOrWindows];for(var i=0;i<doorOrWinsData.length;i++){var doorOrWinData=doorOrWinsData[i];this.parseDoorOrWindow(doorOrWinData,wall,floorPlan);}}if(jsonData.height){wall.height=jsonData.height;}// this.parseDoorOrWindow(jsonData,wall)\nwall.startCorner.addWall(wall);wall.endCorner.addWall(wall);floorPlan.addWall(wall);// return wall;\n};ExportTestXSLoader.prototype.parseRoom=function parseRoom(jsonData,plan){var room=new Room();this.parseBaseObject(jsonData,room,plan);var cornersIndex=jsonData[loadKeys$4.corners];var points=[];if(cornersIndex){for(var i=0;i<cornersIndex.length;i++){var idx=cornersIndex[i];points.push(plan.corners[idx].position);}}if(points.length===0){var pointsData=jsonData.points;if(!pointsData){return;}for(var i=0;i<pointsData.length;i++){var pointData=pointsData[i];var x=pointData[0];var y=pointData[1];var z=-pointData[2];var point=new THREE.Vector3(x,y,z);points.push(point);}}if(points.length===0){console.error("room points is null");return;}if(jsonData[loadKeys$4.floorTexture]!==undefined){room.floorResource=this.resourceManager.textures[jsonData[loadKeys$4.floorTexture]];}if(jsonData[loadKeys$4.ceilingTexture]!==undefined){room.ceilingResource=this.resourceManager.textures[jsonData[loadKeys$4.ceilingTexture]];}if(jsonData[loadKeys$4.roofTexture]!==undefined){room.roofResource=this.resourceManager.textures[jsonData[loadKeys$4.roofTexture]];}if(jsonData.isshowfloor!==undefined){room.floor.isShow=jsonData.isshowfloor;}if(jsonData.isshowceiling!==undefined){room.ceiling.isShow=jsonData.isshowceiling;}if(jsonData.isshowroof!==undefined){room.roof.isShow=jsonData.isshowroof;}if(jsonData.ceilingheight!==undefined){room.ceiling.height=jsonData.ceilingheight;}if(jsonData.roofheight!==undefined){room.roof.height=jsonData.roofheight;}if(jsonData.floorheight!==undefined){room.floor.height=jsonData.floorheight;}if(jsonData.floorblocksize){var dataArray=jsonData.floorblocksize;room.floor.blockSize=new THREE.Vector2(dataArray[0],dataArray[1]);}if(jsonData.ceilingblocksize){var dataArray=jsonData.ceilingblocksize;room.ceiling.blockSize=new THREE.Vector2(dataArray[0],dataArray[1]);}if(jsonData.roofblocksize){var dataArray=jsonData.roofblocksize;room.roof.blockSize=new THREE.Vector2(dataArray[0],dataArray[1]);}room.points=points;plan.rooms.push(room);};ExportTestXSLoader.prototype.parseBaseObject=function parseBaseObject(jsonData,baseObj,parent){var id,name;baseObj.parent=parent;if(jsonData[loadKeys$4.id]){id=jsonData[loadKeys$4.id];baseObj.id=id;}if(jsonData[loadKeys$4.name]){name=jsonData[loadKeys$4.name];baseObj.name=name;}baseObj.jsonData=jsonData;if(jsonData[loadKeys$4.position]){var posArray=jsonData[loadKeys$4.position];var position=baseObj.position;position.set(posArray[0],posArray[1],-posArray[2]);// position = new THREE.Vector3(posArray[0], posArray[1], posArray[2]);\n// baseObj.position = position;\n}if(jsonData[loadKeys$4.scale]){var scaleArray=jsonData[loadKeys$4.scale];var scale=baseObj.scale;scale.set(scaleArray[0],scaleArray[1],scaleArray[2]);// position = new THREE.Vector3(posArray[0], posArray[1], posArray[2]);\n// baseObj.position = position;\n}if(jsonData[loadKeys$4.rotation]){var rotArray=jsonData[loadKeys$4.rotation];var rotation=baseObj.rotation;rotation.set(rotArray[0],rotArray[1],-rotArray[2],-rotArray[3]);// rotation = new THREE.Quaternion(rotArray[0], rotArray[1], rotArray[2],rotArray[3]);\n// baseObj.rotation = rotation;\n}if(jsonData[loadKeys$4.properties]){baseObj.properties=jsonData[loadKeys$4.properties];}if(jsonData.isshow!==undefined&&jsonData.isshow!==null){baseObj.isShow=jsonData.isshow;}};ExportTestXSLoader.prototype.createRooms=function createRooms(){var roomMeshs=[];for(var i=0;i<this.curFloorPlan.rooms.length;i++){var room=this.curFloorPlan.rooms[i];roomMeshs.push(room.meshGroup);}return roomMeshs;};ExportTestXSLoader.prototype.createWalls=function createWalls(){var wallMeshs=[];for(var i=0;i<this.world.buildings.length;i++){var bd=this.world.buildings[i];for(var j=0;j<bd.floorplans.length;j++){var plan=bd.floorplans[j];for(var k=0;k<plan.walls.length;k++){var wall=plan.walls[k];// var pos = wall.position;\n// var group = new THREE.Group("wall");\n// group.add(this.createWallMesh(wall.rightSideMeshInfo));\n// group.add(this.createWallMesh(wall.leftSideMeshInfo));\n// group.add(this.createWallMesh(wall.edgeSideMeshInfo));\n// group.position.set(pos.x, pos.y, pos.z);\nwallMeshs.push(wall.wallGroup);}}}return wallMeshs;};ExportTestXSLoader.prototype.createWallMesh=function createWallMesh(meshInfo){var geometry=new THREE.BufferGeometry();geometry.addAttribute(\'position\',new THREE.BufferAttribute(meshInfo.positionArray,3));geometry.addAttribute(\'normal\',new THREE.BufferAttribute(meshInfo.normalArray,3));geometry.addAttribute(\'uv\',new THREE.BufferAttribute(meshInfo.uvArray,2));var material=meshInfo.material;var mesh=new THREE.Mesh(geometry,material);return mesh;};createClass(ExportTestXSLoader,[{key:\'downloadResourceProgress\',get:function get(){return this.resourceManager.downloadResProgess;}}]);return ExportTestXSLoader;}();/**\r\n\t * @author pzx 2018.2.13\r\n\t * Json2MeshBuilderParser\r\n\t */var ThingjsEditorSceneLoader=function(){function ThingjsEditorSceneLoader(){classCallCheck(this,ThingjsEditorSceneLoader);this.sceneJson=null;this.scale=1;//比例尺\n// plan = null;\nthis.enableCombine=true;this.pointInLineDeviation=0.001;// 检测点在墙上的误差阀值\nthis.world=null;this.resourceManager=new ResourceManager();this.combineManager=new DelayCombineManager(this.resourceManager);this.combineParser=new UBuilderSceneDelayCombineParser(this);this.defaultWallEdgeResource=new Resource(this.resourceManager);this.defaultWallEdgeResource.id="EB9ECFA1101C4A0ABB770ED3A9865441";this.defaultWallEdgeResource.ext="jpg";this.defaultWallEdgeResource.baseUrl=this.resourceManager.baseTextureUrl;this.defaultWallTextureResource=new Resource(this.resourceManager);this.defaultWallTextureResource.id="81FDB96B43D441C5B3C650BFA2B76CD4";this.defaultWallTextureResource.ext="jpg";this.defaultWallTextureResource.isDefault=true;this.defaultWallTextureResource.baseUrl=this.resourceManager.baseTextureUrl;this.defaultFloorTextureResource=new Resource(this.resourceManager);this.defaultFloorTextureResource.id="IQR8PZE2SGEV2H07WX3EJK22CA6ZS0YG";this.defaultFloorTextureResource.ext="jpg";this.defaultFloorTextureResource.baseUrl=this.resourceManager.baseTextureUrl;this.defaultCeilingTextureResource=new Resource(this.resourceManager);this.defaultCeilingTextureResource.id="UPEUIZIK19VMBPP9TLZJ3J3ILWK8V5ZB";this.defaultCeilingTextureResource.ext="jpg";this.defaultCeilingTextureResource.baseUrl=this.resourceManager.baseTextureUrl;this.defaultRoofTextureResource=new Resource(this.resourceManager);this.defaultRoofTextureResource.id="3OZVGE55PV0MY48FPRG5BELXKHV26NU5";this.defaultRoofTextureResource.ext="jpg";this.defaultRoofTextureResource.baseUrl=this.resourceManager.baseTextureUrl;DefaultSetting.enableBuildMesh=false;}ThingjsEditorSceneLoader.prototype.disposeModels=function disposeModels(){this.resourceManager.disposeModels();};ThingjsEditorSceneLoader.prototype.disposeTextures=function disposeTextures(){this.resourceManager.disposeTextures();};ThingjsEditorSceneLoader.prototype._nestingLoopYield=function _nestingLoopYield(gen,success,fail){var _this=this;var item=gen.next();if(item.done){if(success){success();}return item.value;}var value=item.value,done=item.done;if(value instanceof Promise){value.then(function(e){return _this._nestingLoopYield(gen,success,fail);}).catch(function(error){fail(error);});}else{this._nestingLoopYield(gen,success,fail);}};ThingjsEditorSceneLoader.prototype.delayLoad=function delayLoad(map){var that=this;if(map){if(map["url"]){this.sceneURL=map["url"];this.resourceManager.localCustomModelBaseUrl=this.getParentRelativeUrl(this.sceneURL);}if(map["json"]){this.sceneJson=map["json"];}if(map.customModeBaseUrl){this.resourceManager.localCustomModelBaseUrl=map.customModeBaseUrl;}}else{console.error("load param can not be null");return null;}return new Promise(function(resolve,reject){that.resourceManager.initLightMaps(function(){that.loadSceneJson().then(function(){that.parseSceneJson().then(function(){that.world.build();return new Promise(function(resolve,reject){that.combineParser.parseWorld(that.world);that.combineParser.buildWorld(that.world);resolve(that.world);});});}).then(function(){resolve(that.world);}).catch(function(error){console.error(error);});});});};ThingjsEditorSceneLoader.prototype.loadFont=function loadFont(cb){var that=this;return new Promise(function(resolve,reject){var loader=new THREE.FontLoader();loader.load(\'./models/Font/Microsoft YaHei_Regular.json\',function(response){Text3D.font=response;cb();});});};ThingjsEditorSceneLoader.prototype.loadResources=function loadResources(){var that=this;// this.resourceManager.localCustomModelBaseUrl =this.getParentRelativeUrl(this.sceneURL);\nreturn new Promise(function(resolve,reject){// that.resourceManager.downloadResources(function () {\n//     console.log("finish downloadResources");\n//     // resolve();\n//     resolve(that.world);\n// });\nthat.resourceManager.downloadResourcesWithQueue(function(){// console.log("finish downloadResources");\n// resolve();\nresolve(that.world);});});};ThingjsEditorSceneLoader.prototype.getParentRelativeUrl=function getParentRelativeUrl(url){var list=url.split(\'/\');var parentUrl="";for(var i=0;i<list.length-1;i++){var obj=list[i];parentUrl+=obj+"/";}return parentUrl;};//pzx start\nThingjsEditorSceneLoader.prototype.load=function load(map){var that=this;return this.delayLoad(map).then(function(resolve,reject){return that.loadResources();});if(map){if(map["url"]){this.sceneURL=map["url"];this.resourceManager.localCustomModelBaseUrl=this.getParentRelativeUrl(this.sceneURL);}if(map["json"]){this.sceneJson=map["json"];}}else{console.error("load param can not be null");return null;}return new Promise(function(resolve,reject){// that.loadDefaultTexture().then(function () {\n//     return that.loadSceneJson();\n// }).\nthat.resourceManager.initLightMaps(function(){that.loadSceneJson().then(function(){// that.curFloorPlan = new FloorPlan();\nthat.parseSceneJson().then(function(){that.world.build();return new Promise(function(resolve,reject){that.combineParser.parseWorld(that.world);that.combineParser.buildWorld(that.world);// console.log("finish combine parser");\nthat.resourceManager.downloadResources(function(){// console.log("finish downloadResources");\n// resolve(that.world);\n});resolve(that.world);});});}).then(function(){resolve(that.world);}).catch(function(error){console.error(error);});});});};ThingjsEditorSceneLoader.prototype.loadSceneJson=function loadSceneJson(){var that=this;return new Promise(function(resolve,reject){if(that.sceneJson){resolve(that.sceneJson);}else if(that.sceneURL){var loader=new THREE.FileLoader();loader.load(that.sceneURL,function(data){that.sceneJson=JSON.parse(data);resolve();},function(){},function(error){reject("can not load "+that.sceneURL);});}else{reject("load scene json error");}});};ThingjsEditorSceneLoader.prototype.createTextureLoaderPromise=function createTextureLoaderPromise(texUri){var that=this;return new Promise(function(resolve,reject){var texLoader=new THREE.TextureLoader();// var that = this;\n// load a resource\ntexLoader.load(// resource URL\n// that.sceneURL+"/"+texUri,\ntexUri,// Function when resource is loaded\nfunction(texture){texture.wrapS=THREE.RepeatWrapping;texture.wrapT=THREE.RepeatWrapping;resolve(texture);},// Function called when download progresses\nfunction(xhr){console.log(texUri+" "+xhr.loaded/xhr.total*100+\'% loaded\');},// Function called when download errors\nfunction(xhr){resolve(null);console.log(texUri+\'load error\');});});};ThingjsEditorSceneLoader.prototype.parseSceneJson=function parseSceneJson(){var that=this;return new Promise(function(resolve,reject){that.resourceManager.delayDownload=true;// that.resourceManager.loadTextures(that.sceneJson.textures);\n// that.resourceManager.loadModels(that.sceneJson.models);\n// var id = setInterval(function () {\n//     if (that.resourceManager.checkAllResourcesIsReady()) {\n//         clearInterval(id);\nthat.parseWorld(that.sceneJson);resolve();//     }\n// }, 10);\n});};ThingjsEditorSceneLoader.prototype.parseWorld=function parseWorld(jsonData){var world=new World();this.world=world;// world.jsonData = jsonData;\n// this.parseBaseObject(jsonData, world);\n// if (jsonData["buildings"]) {\n//     var buildingsData = jsonData["buildings"];\n//     for (var i = 0; i < buildingsData.length; i++) {\n//         var buildingData = buildingsData[i];\n//         var bd = this.parseBuilding(buildingData);\n//         // bd.jsonData = buildingData;\n//         world.buildings.push(bd);\n//     }\n// }\nif(jsonData["unit"]){this.scale=jsonData["unit"]*0.01;}if(jsonData.planheight){this.planHeight=jsonData.planheight;}var bd=this.parseBuilding(jsonData,world);world.buildings.push(bd);var outdoors=new Outdoors();// this.parseFloorPlan(jsonData, outdoors)\nworld.outdoors=outdoors;};ThingjsEditorSceneLoader.prototype.parseBuilding=function parseBuilding(jsonData,parent){var bd=new Building();var floorPlan=new FloorPlan();this.parseFloorPlan(jsonData,floorPlan,bd);bd.floorplans.push(floorPlan);return bd;};ThingjsEditorSceneLoader.prototype.parseFloorPlan=function parseFloorPlan(jsonData,floorPlan,parent){if(this.planHeight){floorPlan.height=this.planHeight;}if(jsonData["walls"]){this.parseWall(jsonData["walls"],floorPlan);}if(jsonData["rooms"]){this.parseRoom(jsonData["rooms"],floorPlan);}if(jsonData["doors"]){this.parseDoorJson(jsonData["doors"],floorPlan);}return floorPlan;};ThingjsEditorSceneLoader.prototype.parseDoorJson=function parseDoorJson(doorsJson,plan){for(var i=0,len=doorsJson.length;i<len;i++){var singleDoorData=doorsJson[i];var height=singleDoorData["height"]*this.scale;var width=singleDoorData["width"]*this.scale;var x=singleDoorData["pos"][0]*this.scale;var y=singleDoorData["pos"][1]*this.scale;var pos=new THREE.Vector3(x,0,y);var attachWall=this.getPointOnWhichWall(plan,pos);if(attachWall===null){console.warn("can not find door on which wall!");continue;}var door=new DoorOrWindow();if(singleDoorData["suspendpercent"]){door.suspendPercent=singleDoorData["suspendpercent"];}door.size.x=width;door.size.y=height;door.position=pos;attachWall.doorOrWindows.push(door);}};ThingjsEditorSceneLoader.prototype.getPointOnWhichWall=function getPointOnWhichWall(plan,point){var walls=plan.walls;for(var i=0;i<walls.length;i++){var wall=walls[i];if(this.isPointOnLineAndBetweenPoints(wall.startCorner.position,wall.endCorner.position,point)){return wall;}}return null;};ThingjsEditorSceneLoader.prototype.isPointOnLine=function isPointOnLine(pointA,pointB,pointToCheck){var c=new THREE.Vector3();c.crossVectors(pointA.clone().sub(pointToCheck),pointB.clone().sub(pointToCheck));return c.length()<this.pointInLineDeviation;};ThingjsEditorSceneLoader.prototype.isPointOnLineAndBetweenPoints=function isPointOnLineAndBetweenPoints(pointA,pointB,pointToCheck){if(!this.isPointOnLine(pointA,pointB,pointToCheck)){return false;}var dx=pointB.x-pointA.x;var dy=pointB.z-pointA.z;// if a line is a more horizontal than vertical:\nif(Math.abs(dx)>=Math.abs(dy)){if(dx>0){return pointA.x<=pointToCheck.x&&pointToCheck.x<=pointB.x;}else{return pointB.x<=pointToCheck.x&&pointToCheck.x<=pointA.x;}}else{if(dy>0){return pointA.z<=pointToCheck.z&&pointToCheck.z<=pointB.z;}else{return pointB.z<=pointToCheck.z&&pointToCheck.z<=pointA.z;}}};ThingjsEditorSceneLoader.prototype.parseWall=function parseWall(wallsJson,plan){for(var i=0,len=wallsJson.length;i<len;i++){var singleWallData=wallsJson[i];var x=singleWallData["start"][0]*this.scale;var y=singleWallData["start"][1]*this.scale;var startCorner=null;var endCorner=null;if(!plan.existsCorner(x,0,y)){startCorner=plan.addCorner(x,0,y);}else{startCorner=plan.getCorner(x,0,y);}x=singleWallData["end"][0]*this.scale;y=singleWallData["end"][1]*this.scale;if(!plan.existsCorner(x,0,y)){endCorner=plan.addCorner(x,0,y);}else{endCorner=plan.getCorner(x,0,y);}var wall=new Wall();if(singleWallData.height){wall.height=singleWallData.height;}else if(this.planHeight){wall.height=this.planHeight;}wall.leftResource=this.defaultWallTextureResource;wall.rightResource=this.defaultWallTextureResource;wall.edgeResource=this.defaultWallEdgeResource;wall.lightMapResource=DefaultResource.wallLightMapResource;wall.startCorner=startCorner;wall.endCorner=endCorner;wall.startCorner.addWall(wall);wall.endCorner.addWall(wall);plan.addWall(wall);}};ThingjsEditorSceneLoader.prototype.parseRoom=function parseRoom(roomsJson,plan){for(var i=0;i<roomsJson.length;i++){var singleRoomJson=roomsJson[i];var points=[];var holes=null;for(var j=0;j<singleRoomJson["points"].length;j++){var posArray=singleRoomJson["points"][j];points.push(new THREE.Vector3(posArray[0]*this.scale,0,posArray[1]*this.scale));}if(singleRoomJson["holes"]){holes=[];for(var j=0;j<singleRoomJson["holes"].length;j++){var hole=singleRoomJson["holes"][j];var holePoints=[];for(var k=0;k<hole.length;k++){var posArray=hole[k];holePoints.push(new THREE.Vector3(posArray[0]*this.scale,0,posArray[1]*this.scale));}holes.push(holePoints);}}var room=new Room();room.floorResource=this.defaultFloorTextureResource;room.ceilingResource=this.defaultCeilingTextureResource;room.roofResource=this.defaultRoofTextureResource;room.lightMapResource=DefaultResource.floorLightMapResource;room.points=points;if(holes){room.holes=holes;}if(singleRoomJson["center"]){var center=new THREE.Vector3();center.x=singleRoomJson["center"][0];center.y=0;center.z=singleRoomJson["center"][1];room.center=center;}if(singleRoomJson["offset"]){var offset=new THREE.Vector3();offset.x=singleRoomJson["offset"][0];offset.y=singleRoomJson["offset"][1];offset.z=singleRoomJson["offset"][2];room.offset=offset;}if(singleRoomJson["parentPosition"]){var parentPos=new THREE.Vector3();parentPos.x=singleRoomJson["parentPosition"][0];parentPos.y=singleRoomJson["parentPosition"][1];parentPos.z=singleRoomJson["parentPosition"][2];room.parentPosition=parentPos;}room.parent=plan;plan.rooms.push(room);}};ThingjsEditorSceneLoader.prototype.createRooms=function createRooms(){var roomMeshs=[];for(var i=0;i<plan.rooms.length;i++){var room=plan.rooms[i];roomMeshs.push(room.meshGroup);}return roomMeshs;};ThingjsEditorSceneLoader.prototype.createWalls=function createWalls(){var wallMeshs=[];for(var i=0;i<this.world.buildings.length;i++){var bd=this.world.buildings[i];for(var j=0;j<bd.floorplans.length;j++){var plan=bd.floorplans[j];for(var k=0;k<plan.walls.length;k++){var wall=plan.walls[k];// var pos = wall.position;\n// var group = new THREE.Group("wall");\n// group.add(this.createWallMesh(wall.rightSideMeshInfo));\n// group.add(this.createWallMesh(wall.leftSideMeshInfo));\n// group.add(this.createWallMesh(wall.edgeSideMeshInfo));\n// group.position.set(pos.x, pos.y, pos.z);\nwallMeshs.push(wall.wallGroup);}}}return wallMeshs;};ThingjsEditorSceneLoader.prototype.createWallMesh=function createWallMesh(meshInfo){var geometry=new THREE.BufferGeometry();geometry.addAttribute(\'position\',new THREE.BufferAttribute(meshInfo.positionArray,3));geometry.addAttribute(\'normal\',new THREE.BufferAttribute(meshInfo.normalArray,3));geometry.addAttribute(\'uv\',new THREE.BufferAttribute(meshInfo.uvArray,2));var material=meshInfo.material;var mesh=new THREE.Mesh(geometry,material);return mesh;};createClass(ThingjsEditorSceneLoader,[{key:\'downloadResourceProgress\',get:function get(){return this.resourceManager.downloadResProgess;}}]);return ThingjsEditorSceneLoader;}();/**\r\n\t * @author pzx 2018.2.13\r\n\t * Json2MeshBuilderParser\r\n\t */var ubuilderLoadSceneKeys$6={id:"id",name:"name",position:"position",rotation:"rotation",scale:"scale",properties:"properties",plans:"plans",walls:"walls",placements:"placements",videoprobes:"videoprobes",groups:"groups",corners:"corners",doorOrWindows:"doororwindows",curveLines:"curvelines",pipeLines:"pipelines",text3Ds:"text3ds",rooms:"rooms",height:"height",thick:"thick",texture:"texture",type:"type",model:"model",suspendPercent:"suspendpercent",leftTexture:"lefttexture",rightTexture:"righttexture",edgeTexture:"edgetexture",floorTexture:"floortexture",ceilingTexture:"ceilingtexture",roofTexture:"rooftexture",isOpen:"isopen",wallType:"type"};var loadKeys$6=ubuilderLoadSceneKeys$6;var ThingjsEditorSceneLoader_2_0=function(){function ThingjsEditorSceneLoader_2_0(){classCallCheck(this,ThingjsEditorSceneLoader_2_0);this.sceneJson=null;this.scale=1;//比例尺\n// plan = null;\nthis.enableCombine=true;this.pointInLineDeviation=0.001;// 检测点在墙上的误差阀值\nthis.world=null;this.resourceManager=new ResourceManager();this.combineManager=new DelayCombineManager(this.resourceManager);this.combineParser=new UBuilderSceneDelayCombineParser(this);// this.defaultWallEdgeResource = new Resource(this.resourceManager);\n// this.defaultWallEdgeResource.id = "EB9ECFA1101C4A0ABB770ED3A9865441";\n// this.defaultWallEdgeResource.ext = "jpg";\n// this.defaultWallEdgeResource.baseUrl = this.resourceManager.baseTextureUrl;\n//\n// this.defaultWallTextureResource = new Resource(this.resourceManager);\n// this.defaultWallTextureResource.id = "81FDB96B43D441C5B3C650BFA2B76CD4";\n// this.defaultWallTextureResource.ext = "jpg";\n// this.defaultWallTextureResource.isDefault = true;\n// this.defaultWallTextureResource.baseUrl = this.resourceManager.baseTextureUrl;\n//\nthis.defaultFloorTextureResource=new Resource(this.resourceManager);this.defaultFloorTextureResource.id="IQR8PZE2SGEV2H07WX3EJK22CA6ZS0YG";this.defaultFloorTextureResource.ext="jpg";this.defaultFloorTextureResource.baseUrl=this.resourceManager.baseTextureUrl;this.defaultCeilingTextureResource=new Resource(this.resourceManager);this.defaultCeilingTextureResource.id="UPEUIZIK19VMBPP9TLZJ3J3ILWK8V5ZB";this.defaultCeilingTextureResource.ext="jpg";this.defaultCeilingTextureResource.baseUrl=this.resourceManager.baseTextureUrl;this.defaultRoofTextureResource=new Resource(this.resourceManager);this.defaultRoofTextureResource.id="3OZVGE55PV0MY48FPRG5BELXKHV26NU5";this.defaultRoofTextureResource.ext="jpg";this.defaultRoofTextureResource.baseUrl=this.resourceManager.baseTextureUrl;DefaultSetting.enableBuildMesh=false;}ThingjsEditorSceneLoader_2_0.prototype.disposeModels=function disposeModels(){this.resourceManager.disposeModels();};ThingjsEditorSceneLoader_2_0.prototype.disposeTextures=function disposeTextures(){this.resourceManager.disposeTextures();};ThingjsEditorSceneLoader_2_0.prototype._nestingLoopYield=function _nestingLoopYield(gen,success,fail){var _this=this;var item=gen.next();if(item.done){if(success){success();}return item.value;}var value=item.value,done=item.done;if(value instanceof Promise){value.then(function(e){return _this._nestingLoopYield(gen,success,fail);}).catch(function(error){fail(error);});}else{this._nestingLoopYield(gen,success,fail);}};ThingjsEditorSceneLoader_2_0.prototype.delayLoad=function delayLoad(map){var that=this;if(map){if(map["url"]){this.sceneURL=map["url"];this.resourceManager.localCustomModelBaseUrl=this.getParentRelativeUrl(this.sceneURL);}if(map["json"]){this.sceneJson=map["json"];}if(map.customModeBaseUrl){this.resourceManager.localCustomModelBaseUrl=map.customModeBaseUrl;}}else{console.error("load param can not be null");return null;}return new Promise(function(resolve,reject){that.resourceManager.initLightMaps(function(){that.loadSceneJson().then(function(){that.parseSceneJson().then(function(){that.world.build();return new Promise(function(resolve,reject){that.combineParser.parseWorld(that.world);that.combineParser.buildWorld(that.world);resolve(that.world);});});}).then(function(){resolve(that.world);}).catch(function(error){console.error(error);});});});};ThingjsEditorSceneLoader_2_0.prototype.loadFont=function loadFont(cb){var that=this;return new Promise(function(resolve,reject){var loader=new THREE.FontLoader();loader.load(\'./models/Font/Microsoft YaHei_Regular.json\',function(response){Text3D.font=response;cb();});});};ThingjsEditorSceneLoader_2_0.prototype.loadResources=function loadResources(){var that=this;// this.resourceManager.localCustomModelBaseUrl =this.getParentRelativeUrl(this.sceneURL);\nreturn new Promise(function(resolve,reject){// that.resourceManager.downloadResources(function () {\n//     console.log("finish downloadResources");\n//     // resolve();\n//     resolve(that.world);\n// });\nthat.resourceManager.downloadResourcesWithQueue(function(){// console.log("finish downloadResources");\n// resolve();\nresolve(that.world);});});};ThingjsEditorSceneLoader_2_0.prototype.getParentRelativeUrl=function getParentRelativeUrl(url){var list=url.split(\'/\');var parentUrl="";for(var i=0;i<list.length-1;i++){var obj=list[i];parentUrl+=obj+"/";}return parentUrl;};//pzx start\nThingjsEditorSceneLoader_2_0.prototype.load=function load(map){var that=this;return this.delayLoad(map).then(function(resolve,reject){return that.loadResources();});if(map){if(map["url"]){this.sceneURL=map["url"];this.resourceManager.localCustomModelBaseUrl=this.getParentRelativeUrl(this.sceneURL);}if(map["json"]){this.sceneJson=map["json"];}}else{console.error("load param can not be null");return null;}return new Promise(function(resolve,reject){// that.loadDefaultTexture().then(function () {\n//     return that.loadSceneJson();\n// }).\nthat.resourceManager.initLightMaps(function(){that.loadSceneJson().then(function(){// that.curFloorPlan = new FloorPlan();\nthat.parseSceneJson().then(function(){that.world.build();return new Promise(function(resolve,reject){that.combineParser.parseWorld(that.world);that.combineParser.buildWorld(that.world);// console.log("finish combine parser");\nthat.resourceManager.downloadResources(function(){// console.log("finish downloadResources");\n// resolve(that.world);\n});resolve(that.world);});});}).then(function(){resolve(that.world);}).catch(function(error){console.error(error);});});});};ThingjsEditorSceneLoader_2_0.prototype.loadSceneJson=function loadSceneJson(){var that=this;return new Promise(function(resolve,reject){if(that.sceneJson){resolve(that.sceneJson);}else if(that.sceneURL){var loader=new THREE.FileLoader();loader.load(that.sceneURL,function(data){that.sceneJson=JSON.parse(data);resolve();},function(){},function(error){reject("can not load "+that.sceneURL);});}else{reject("load scene json error");}});};ThingjsEditorSceneLoader_2_0.prototype.createTextureLoaderPromise=function createTextureLoaderPromise(texUri){var that=this;return new Promise(function(resolve,reject){var texLoader=new THREE.TextureLoader();// var that = this;\n// load a resource\ntexLoader.load(// resource URL\n// that.sceneURL+"/"+texUri,\ntexUri,// Function when resource is loaded\nfunction(texture){texture.wrapS=THREE.RepeatWrapping;texture.wrapT=THREE.RepeatWrapping;resolve(texture);},// Function called when download progresses\nfunction(xhr){console.log(texUri+" "+xhr.loaded/xhr.total*100+\'% loaded\');},// Function called when download errors\nfunction(xhr){resolve(null);console.log(texUri+\'load error\');});});};ThingjsEditorSceneLoader_2_0.prototype.parseSceneJson=function parseSceneJson(){var that=this;return new Promise(function(resolve,reject){that.resourceManager.delayDownload=true;that.resourceManager.loadTextures(that.sceneJson.textures);that.resourceManager.loadModels(that.sceneJson.models);// var id = setInterval(function () {\n//     if (that.resourceManager.checkAllResourcesIsReady()) {\n//         clearInterval(id);\nthat.parseWorld(that.sceneJson);resolve();//     }\n// }, 10);\n});};ThingjsEditorSceneLoader_2_0.prototype.parseWorld=function parseWorld(jsonData){var world=new World();this.world=world;// world.jsonData = jsonData;\n// this.parseBaseObject(jsonData, world);\n// if (jsonData["buildings"]) {\n//     var buildingsData = jsonData["buildings"];\n//     for (var i = 0; i < buildingsData.length; i++) {\n//         var buildingData = buildingsData[i];\n//         var bd = this.parseBuilding(buildingData);\n//         // bd.jsonData = buildingData;\n//         world.buildings.push(bd);\n//     }\n// }\nif(jsonData["unit"]){this.scale=jsonData["unit"]*0.01;}if(jsonData.planheight){this.planHeight=jsonData.planheight;}var bd=this.parseBuilding(jsonData,world);world.buildings.push(bd);var outdoors=new Outdoors();// this.parseFloorPlan(jsonData, outdoors)\nworld.outdoors=outdoors;};ThingjsEditorSceneLoader_2_0.prototype.parseBuilding=function parseBuilding(jsonData,parent){var bd=new Building();var floorPlan=new FloorPlan();this.parseFloorPlan(jsonData,floorPlan,bd);bd.floorplans.push(floorPlan);return bd;};ThingjsEditorSceneLoader_2_0.prototype.parseFloorPlan=function parseFloorPlan(jsonData,floorPlan,parent){if(this.planHeight){floorPlan.height=this.planHeight;}if(jsonData["walls"]){this.parseWall(jsonData["walls"],floorPlan);}if(jsonData["rooms"]){this.parseRoom(jsonData["rooms"],floorPlan);}if(jsonData["doors"]){this.parseDoorJson(jsonData["doors"],floorPlan);}return floorPlan;};ThingjsEditorSceneLoader_2_0.prototype.parseDoorJson=function parseDoorJson(doorsJson,plan){for(var i=0,len=doorsJson.length;i<len;i++){var singleDoorData=doorsJson[i];var height=singleDoorData["height"]*this.scale;var width=singleDoorData["width"]*this.scale;var x=singleDoorData["pos"][0]*this.scale;var y=singleDoorData["pos"][1]*this.scale;var pos=new THREE.Vector3(x,0,y);var attachWall=this.getPointOnWhichWall(plan,pos);if(attachWall===null){console.warn("can not find door on which wall!");continue;}var door=new DoorOrWindow();if(singleDoorData["suspendpercent"]){door.suspendPercent=singleDoorData["suspendpercent"];}door.size.x=width;door.size.y=height;door.position=pos;attachWall.doorOrWindows.push(door);}};ThingjsEditorSceneLoader_2_0.prototype.getPointOnWhichWall=function getPointOnWhichWall(plan,point){var walls=plan.walls;for(var i=0;i<walls.length;i++){var wall=walls[i];if(this.isPointOnLineAndBetweenPoints(wall.startCorner.position,wall.endCorner.position,point)){return wall;}}return null;};ThingjsEditorSceneLoader_2_0.prototype.isPointOnLine=function isPointOnLine(pointA,pointB,pointToCheck){var c=new THREE.Vector3();c.crossVectors(pointA.clone().sub(pointToCheck),pointB.clone().sub(pointToCheck));return c.length()<this.pointInLineDeviation;};ThingjsEditorSceneLoader_2_0.prototype.isPointOnLineAndBetweenPoints=function isPointOnLineAndBetweenPoints(pointA,pointB,pointToCheck){if(!this.isPointOnLine(pointA,pointB,pointToCheck)){return false;}var dx=pointB.x-pointA.x;var dy=pointB.z-pointA.z;// if a line is a more horizontal than vertical:\nif(Math.abs(dx)>=Math.abs(dy)){if(dx>0){return pointA.x<=pointToCheck.x&&pointToCheck.x<=pointB.x;}else{return pointB.x<=pointToCheck.x&&pointToCheck.x<=pointA.x;}}else{if(dy>0){return pointA.z<=pointToCheck.z&&pointToCheck.z<=pointB.z;}else{return pointB.z<=pointToCheck.z&&pointToCheck.z<=pointA.z;}}};ThingjsEditorSceneLoader_2_0.prototype.parseWall=function parseWall(wallsJson,plan){for(var i=0,len=wallsJson.length;i<len;i++){var singleWallData=wallsJson[i];var type=singleWallData[loadKeys$6.wallType];var x=singleWallData["start"][0]*this.scale;var y=singleWallData["start"][1]*this.scale;var startCorner=null;var endCorner=null;if(!plan.existsCorner(x,0,y)){startCorner=plan.addCorner(x,0,y);}else{startCorner=plan.getCorner(x,0,y);}x=singleWallData["end"][0]*this.scale;y=singleWallData["end"][1]*this.scale;if(!plan.existsCorner(x,0,y)){endCorner=plan.addCorner(x,0,y);}else{endCorner=plan.getCorner(x,0,y);}var wall=null;if(type===0){wall=new Wall();wall.lightMapResource=DefaultResource.wallLightMapResource;}else{wall=new ModelWall();}if(singleWallData.height){wall.height=singleWallData.height;}else if(this.planHeight){wall.height=this.planHeight;}if(singleWallData[loadKeys$6.leftTexture]!==undefined){wall.leftResource=this.resourceManager.textures[singleWallData[loadKeys$6.leftTexture]];}if(singleWallData[loadKeys$6.rightTexture]!==undefined){wall.rightResource=this.resourceManager.textures[singleWallData[loadKeys$6.rightTexture]];}if(singleWallData[loadKeys$6.edgeTexture]!==undefined){wall.edgeResource=this.resourceManager.textures[singleWallData[loadKeys$6.edgeTexture]];}//处理模型墙\nif(singleWallData[loadKeys$6.model]!==undefined){wall.resource=this.resourceManager.models[singleWallData[loadKeys$6.model]];}wall.startCorner=startCorner;wall.endCorner=endCorner;wall.startCorner.addWall(wall);wall.endCorner.addWall(wall);plan.addWall(wall);}};ThingjsEditorSceneLoader_2_0.prototype.parseRoom=function parseRoom(roomsJson,plan){for(var i=0;i<roomsJson.length;i++){var singleRoomJson=roomsJson[i];var points=[];var holes=null;for(var j=0;j<singleRoomJson["points"].length;j++){var posArray=singleRoomJson["points"][j];points.push(new THREE.Vector3(posArray[0]*this.scale,0,posArray[1]*this.scale));}if(singleRoomJson["holes"]){holes=[];for(var j=0;j<singleRoomJson["holes"].length;j++){var hole=singleRoomJson["holes"][j];var holePoints=[];for(var k=0;k<hole.length;k++){var posArray=hole[k];holePoints.push(new THREE.Vector3(posArray[0]*this.scale,0,posArray[1]*this.scale));}holes.push(holePoints);}}var room=new Room();room.floorResource=this.defaultFloorTextureResource;room.ceilingResource=this.defaultCeilingTextureResource;room.roofResource=this.defaultRoofTextureResource;room.lightMapResource=DefaultResource.floorLightMapResource;room.points=points;if(holes){room.holes=holes;}if(singleRoomJson["center"]){var center=new THREE.Vector3();center.x=singleRoomJson["center"][0];center.y=0;center.z=singleRoomJson["center"][1];room.center=center;}if(singleRoomJson["offset"]){var offset=new THREE.Vector3();offset.x=singleRoomJson["offset"][0];offset.y=singleRoomJson["offset"][1];offset.z=singleRoomJson["offset"][2];room.offset=offset;}if(singleRoomJson["parentPosition"]){var parentPos=new THREE.Vector3();parentPos.x=singleRoomJson["parentPosition"][0];parentPos.y=singleRoomJson["parentPosition"][1];parentPos.z=singleRoomJson["parentPosition"][2];room.parentPosition=parentPos;}room.parent=plan;plan.rooms.push(room);}};ThingjsEditorSceneLoader_2_0.prototype.createRooms=function createRooms(){var roomMeshs=[];for(var i=0;i<plan.rooms.length;i++){var room=plan.rooms[i];roomMeshs.push(room.meshGroup);}return roomMeshs;};ThingjsEditorSceneLoader_2_0.prototype.createWalls=function createWalls(){var wallMeshs=[];for(var i=0;i<this.world.buildings.length;i++){var bd=this.world.buildings[i];for(var j=0;j<bd.floorplans.length;j++){var plan=bd.floorplans[j];for(var k=0;k<plan.walls.length;k++){var wall=plan.walls[k];// var pos = wall.position;\n// var group = new THREE.Group("wall");\n// group.add(this.createWallMesh(wall.rightSideMeshInfo));\n// group.add(this.createWallMesh(wall.leftSideMeshInfo));\n// group.add(this.createWallMesh(wall.edgeSideMeshInfo));\n// group.position.set(pos.x, pos.y, pos.z);\nwallMeshs.push(wall.wallGroup);}}}return wallMeshs;};ThingjsEditorSceneLoader_2_0.prototype.createWallMesh=function createWallMesh(meshInfo){var geometry=new THREE.BufferGeometry();geometry.addAttribute(\'position\',new THREE.BufferAttribute(meshInfo.positionArray,3));geometry.addAttribute(\'normal\',new THREE.BufferAttribute(meshInfo.normalArray,3));geometry.addAttribute(\'uv\',new THREE.BufferAttribute(meshInfo.uvArray,2));var material=meshInfo.material;var mesh=new THREE.Mesh(geometry,material);return mesh;};createClass(ThingjsEditorSceneLoader_2_0,[{key:\'downloadResourceProgress\',get:function get(){return this.resourceManager.downloadResProgess;}}]);return ThingjsEditorSceneLoader_2_0;}();exports.HUAWEILoader=HUAWEILoader;exports.HUAWEIWorldLoader=HUAWEIWorldLoader;exports.HUAWEIFloorPlanLoader=HUAWEIFloorPlanLoader;exports.Thing3DCadLoader=Thing3DCadLoader;exports.UBuilderSceneLoader=UBuilderSceneLoader;exports.UBuilderSceneDelayLoader=UBuilderSceneDelayLoader;exports.UBuilderSceneSimpleLoader=UBuilderSceneSimpleLoader;exports.ExportTestXSLoader=ExportTestXSLoader;exports.ThingjsEditorSceneLoader=ThingjsEditorSceneLoader;exports.ThingjsEditorSceneLoader_2_0=ThingjsEditorSceneLoader_2_0;exports.DefaultSetting=DefaultSetting;Object.defineProperty(exports,\'__esModule\',{value:true});});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))\n\n//# sourceURL=webpack:///./src/extra/json2mesh.js?')
        },
        "./src/extra/simpleheat.js": /*!*********************************!*\
  !*** ./src/extra/simpleheat.js ***!
  \*********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nif (true) module.exports = simpleheat;\n\nfunction simpleheat(canvas) {\n    if (!(this instanceof simpleheat)) return new simpleheat(canvas);\n\n    this._canvas = canvas = typeof canvas === 'string' ? document.getElementById(canvas) : canvas;\n\n    this._ctx = canvas.getContext('2d');\n    this._width = canvas.width;\n    this._height = canvas.height;\n\n    this._max = 40;\n    this._data = [];\n}\n\nsimpleheat.prototype = {\n\n    defaultRadius: 25,\n\n    defaultGradient: {\n        0.7: '#0203ff',\n        0.8: '#00ff03',\n        0.9: '#fff701',\n        1: '#fd0a05'\n    },\n\n    data: function data(_data) {\n        this._data = _data;\n        return this;\n    },\n\n    max: function max(_max) {\n        this._max = _max;\n        // this._max = 1;  //此处如果不写1，会出现云图初始化时变一下。（即，云图初始化时会先按this._max = 1画一次，未解之谜）\n        return this;\n    },\n\n    add: function add(point) {\n        this._data.push(point);\n        return this;\n    },\n\n    clear: function clear() {\n        this._data = [];\n        return this;\n    },\n\n    radius: function radius(r, blur) {\n        blur = blur === undefined ? 15 : blur;\n\n        // create a grayscale blurred circle image that we'll use for drawing points\n        var circle = this._circle = this._createCanvas(),\n            ctx = circle.getContext('2d'),\n            r2 = this._r = r + blur;\n\n        circle.width = circle.height = r2 * 2;\n\n        ctx.shadowOffsetX = ctx.shadowOffsetY = r2 * 2;\n        ctx.shadowBlur = blur;\n        ctx.shadowColor = 'black';\n\n        ctx.beginPath();\n        ctx.arc(-r2, -r2, r, 0, Math.PI * 2, true);\n        ctx.closePath();\n        ctx.fill();\n\n        return this;\n    },\n\n    resize: function resize() {\n        this._width = this._canvas.width;\n        this._height = this._canvas.height;\n    },\n\n    gradient: function gradient(grad) {\n        // create a 256x1 gradient that we'll use to turn a grayscale heatmap into a colored one\n        var canvas = this._createCanvas(),\n            ctx = canvas.getContext('2d'),\n            gradient = ctx.createLinearGradient(0, 0, 0, 256);\n\n        canvas.width = 1;\n        canvas.height = 256;\n\n        for (var i in grad) {\n            gradient.addColorStop(+i, grad[i]);\n        }\n\n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, 1, 256);\n\n        this._grad = ctx.getImageData(0, 0, 1, 256).data;\n\n        return this;\n    },\n\n    draw: function draw(minOpacity) {\n        if (!this._circle) this.radius(this.defaultRadius);\n        if (!this._grad) this.gradient(this.defaultGradient);\n\n        var ctx = this._ctx;\n\n        // \n        ctx.clearRect(0, 0, this._width, this._height);\n\n        ctx.fillStyle = 'rgba(0, 0, 255, 0.7)';\n        ctx.fillRect(0, 0, this._width, this._height);\n\n        // draw a grayscale heatmap by putting a blurred circle at each data point\n        for (var i = 0, len = this._data.length, p; i < len; i++) {\n            p = this._data[i];\n            ctx.globalAlpha = Math.min(Math.max(p[2] / this._max, minOpacity === undefined ? 0.05 : minOpacity), 1);\n            ctx.drawImage(this._circle, p[0] - this._r, p[1] - this._r);\n        }\n\n        // colorize the heatmap, using opacity value of each pixel to get the right color from our gradient\n        var colored = ctx.getImageData(0, 0, this._width, this._height);\n        this._colorize(colored.data, this._grad);\n        ctx.putImageData(colored, 0, 0);\n\n        return this;\n    },\n\n    _colorize: function _colorize(pixels, gradient) {\n        for (var i = 0, len = pixels.length, j; i < len; i += 4) {\n            j = pixels[i + 3] * 4; // get gradient color from opacity value\n\n            if (j) {\n                pixels[i] = gradient[j];\n                pixels[i + 1] = gradient[j + 1];\n                pixels[i + 2] = gradient[j + 2];\n            }\n        }\n    },\n\n    _createCanvas: function _createCanvas() {\n        if (typeof document !== 'undefined') {\n            return document.createElement('canvas');\n        } else {\n            // create a new canvas instance in node.js\n            // the canvas class needs to have a default constructor without any parameter\n            return new this._canvas.constructor();\n        }\n    }\n};\n\nexports.default = simpleheat;\n\n//# sourceURL=webpack:///./src/extra/simpleheat.js?")
        },
        "./src/extra/three.path.js": /*!*********************************!*\
  !*** ./src/extra/three.path.js ***!
  \*********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n// github.com/shawn0326/three.path\n(function (global, factory) {\n\t( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);\n})(undefined, function (exports) {\n\t'use strict';\n\n\t/**\r\n  * PathPoint\r\n  */\n\n\tvar PathPoint = /*#__PURE__*/function () {\n\t\tfunction PathPoint() {\n\t\t\tthis.pos = new THREE.Vector3();\n\t\t\tthis.dir = new THREE.Vector3();\n\t\t\tthis.right = new THREE.Vector3();\n\t\t\tthis.up = new THREE.Vector3(); // normal\n\n\t\t\tthis.dist = 0; // distance from start\n\n\t\t\tthis.widthScale = 1; // for corner\n\n\t\t\tthis.sharp = false; // marks as sharp corner\n\t\t}\n\n\t\tvar _proto = PathPoint.prototype;\n\n\t\t_proto.lerpPathPoints = function lerpPathPoints(p1, p2, alpha) {\n\t\t\tthis.pos.lerpVectors(p1.pos, p2.pos, alpha);\n\t\t\tthis.dir.lerpVectors(p1.dir, p2.dir, alpha);\n\t\t\tthis.up.lerpVectors(p1.up, p2.up, alpha);\n\t\t\tthis.right.lerpVectors(p1.right, p2.right, alpha);\n\t\t\tthis.dist = (p2.dist - p1.dist) * alpha + p1.dist;\n\t\t\tthis.widthScale = (p2.widthScale - p1.widthScale) * alpha + p1.widthScale;\n\t\t};\n\n\t\t_proto.copy = function copy(source) {\n\t\t\tthis.pos.copy(source.pos);\n\t\t\tthis.dir.copy(source.dir);\n\t\t\tthis.up.copy(source.up);\n\t\t\tthis.right.copy(source.right);\n\t\t\tthis.dist = source.dist;\n\t\t\tthis.widthScale = source.widthScale;\n\t\t};\n\n\t\treturn PathPoint;\n\t}();\n\n\tvar helpVec3_1 = new THREE.Vector3();\n\tvar helpVec3_2 = new THREE.Vector3();\n\tvar helpVec3_3 = new THREE.Vector3();\n\tvar helpMat4 = new THREE.Matrix4();\n\tvar helpCurve = new THREE.QuadraticBezierCurve3();\n\n\tfunction _getCornerBezierCurve(last, current, next, cornerRadius, firstCorner, out) {\n\t\tvar lastDir = helpVec3_1.subVectors(current, last);\n\t\tvar nextDir = helpVec3_2.subVectors(next, current);\n\t\tvar lastDirLength = lastDir.length();\n\t\tvar nextDirLength = nextDir.length();\n\t\tlastDir.normalize();\n\t\tnextDir.normalize(); // cornerRadius can not bigger then lineDistance / 2, auto fix this\n\n\t\tvar v0Dist = Math.min((firstCorner ? lastDirLength / 2 : lastDirLength) * 0.999999, cornerRadius);\n\t\tout.v0.copy(current).sub(lastDir.multiplyScalar(v0Dist));\n\t\tout.v1.copy(current);\n\t\tvar v2Dist = Math.min(nextDirLength / 2 * 0.999999, cornerRadius);\n\t\tout.v2.copy(current).add(nextDir.multiplyScalar(v2Dist));\n\t\treturn out;\n\t}\n\t/**\r\n  * PathPointList\r\n  * input points to generate a PathPoint list\r\n  */\n\n\tvar PathPointList = /*#__PURE__*/function () {\n\t\tfunction PathPointList() {\n\t\t\tthis.array = []; // path point array\n\n\t\t\tthis.count = 0;\n\t\t}\n\t\t/**\r\n   * Set points\r\n   * @param {THREE.Vector3[]} points key points array\r\n   * @param {number} cornerRadius? the corner radius. set 0 to disable round corner. default is 0.1\r\n   * @param {number} cornerSplit? the corner split. default is 10.\r\n   * @param {number} up? force up. default is auto up (calculate by tangent).\r\n   * @param {boolean} close? close path. default is false.\r\n   */\n\n\t\tvar _proto = PathPointList.prototype;\n\n\t\t_proto.set = function set(points, cornerRadius, cornerSplit, up, close) {\n\t\t\tif (cornerRadius === void 0) {\n\t\t\t\tcornerRadius = 0.1;\n\t\t\t}\n\n\t\t\tif (cornerSplit === void 0) {\n\t\t\t\tcornerSplit = 10;\n\t\t\t}\n\n\t\t\tif (up === void 0) {\n\t\t\t\tup = null;\n\t\t\t}\n\n\t\t\tif (close === void 0) {\n\t\t\t\tclose = false;\n\t\t\t}\n\n\t\t\tpoints = points.slice(0);\n\n\t\t\tif (points.length < 2) {\n\t\t\t\tconsole.warn(\"PathPointList: points length less than 2.\");\n\t\t\t\tthis.count = 0;\n\t\t\t\treturn;\n\t\t\t} // Auto close\n\n\n\t\t\tif (close && !points[0].equals(points[points.length - 1])) {\n\t\t\t\tpoints.push(new THREE.Vector3().copy(points[0]));\n\t\t\t} // Generate path point list\n\n\n\t\t\tfor (var i = 0, l = points.length; i < l; i++) {\n\t\t\t\tif (i === 0) {\n\t\t\t\t\tthis._start(points[i], points[i + 1], up);\n\t\t\t\t} else if (i === l - 1) {\n\t\t\t\t\tif (close) {\n\t\t\t\t\t\t// Connect end point and start point\n\t\t\t\t\t\tthis._corner(points[i], points[1], cornerRadius, cornerSplit, up); // Fix start point\n\n\n\t\t\t\t\t\tvar dist = this.array[0].dist; // should not copy dist\n\n\t\t\t\t\t\tthis.array[0].copy(this.array[this.count - 1]);\n\t\t\t\t\t\tthis.array[0].dist = dist;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._end(points[i]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._corner(points[i], points[i + 1], cornerRadius, cornerSplit, up);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/**\r\n   * Get distance of this path\r\n   * @return {number}\r\n   */\n\t\t;\n\n\t\t_proto.distance = function distance() {\n\t\t\tif (this.count > 0) {\n\t\t\t\treturn this.array[this.count - 1].dist;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t};\n\n\t\t_proto._getByIndex = function _getByIndex(index) {\n\t\t\tif (!this.array[index]) {\n\t\t\t\tthis.array[index] = new PathPoint();\n\t\t\t}\n\n\t\t\treturn this.array[index];\n\t\t};\n\n\t\t_proto._start = function _start(current, next, up) {\n\t\t\tthis.count = 0;\n\n\t\t\tvar point = this._getByIndex(this.count);\n\n\t\t\tpoint.pos.copy(current);\n\t\t\tpoint.dir.subVectors(next, current); // init start up dir\n\n\t\t\tif (up) {\n\t\t\t\tpoint.up.copy(up);\n\t\t\t} else {\n\t\t\t\t// select an initial normal vector perpendicular to the first tangent vector\n\t\t\t\tvar min = Number.MAX_VALUE;\n\t\t\t\tvar tx = Math.abs(point.dir.x);\n\t\t\t\tvar ty = Math.abs(point.dir.y);\n\t\t\t\tvar tz = Math.abs(point.dir.z);\n\n\t\t\t\tif (tx < min) {\n\t\t\t\t\tmin = tx;\n\t\t\t\t\tpoint.up.set(1, 0, 0);\n\t\t\t\t}\n\n\t\t\t\tif (ty < min) {\n\t\t\t\t\tmin = ty;\n\t\t\t\t\tpoint.up.set(0, 1, 0);\n\t\t\t\t}\n\n\t\t\t\tif (tz < min) {\n\t\t\t\t\tpoint.up.set(0, 0, 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpoint.right.crossVectors(point.dir, point.up).normalize();\n\t\t\tpoint.up.crossVectors(point.right, point.dir).normalize();\n\t\t\tpoint.dist = 0;\n\t\t\tpoint.widthScale = 1;\n\t\t\tpoint.sharp = false;\n\t\t\tpoint.dir.normalize();\n\t\t\tthis.count++;\n\t\t};\n\n\t\t_proto._end = function _end(current) {\n\t\t\tvar lastPoint = this.array[this.count - 1];\n\n\t\t\tvar point = this._getByIndex(this.count);\n\n\t\t\tpoint.pos.copy(current);\n\t\t\tpoint.dir.subVectors(current, lastPoint.pos);\n\t\t\tvar dist = point.dir.length();\n\t\t\tpoint.dir.normalize();\n\t\t\tpoint.up.copy(lastPoint.up); // copy last up\n\n\t\t\tvar vec = helpVec3_1.crossVectors(lastPoint.dir, point.dir);\n\n\t\t\tif (vec.length() > Number.EPSILON) {\n\t\t\t\tvec.normalize();\n\t\t\t\tvar theta = Math.acos(Math.min(Math.max(lastPoint.dir.dot(point.dir), -1), 1)); // clamp for floating pt errors\n\n\t\t\t\tpoint.up.applyMatrix4(helpMat4.makeRotationAxis(vec, theta));\n\t\t\t}\n\n\t\t\tpoint.right.crossVectors(point.dir, point.up).normalize();\n\t\t\tpoint.dist = lastPoint.dist + dist;\n\t\t\tpoint.widthScale = 1;\n\t\t\tpoint.sharp = false;\n\t\t\tthis.count++;\n\t\t};\n\n\t\t_proto._corner = function _corner(current, next, cornerRadius, cornerSplit, up) {\n\t\t\tif (cornerRadius > 0 && cornerSplit > 0) {\n\t\t\t\tvar lastPoint = this.array[this.count - 1];\n\n\t\t\t\tvar curve = _getCornerBezierCurve(lastPoint.pos, current, next, cornerRadius, this.count - 1 === 0, helpCurve);\n\n\t\t\t\tvar samplerPoints = curve.getPoints(cornerSplit); // TODO optimize\n\n\t\t\t\tfor (var f = 0; f < cornerSplit; f++) {\n\t\t\t\t\tthis._sharpCorner(samplerPoints[f], samplerPoints[f + 1], up, f === 0 ? 1 : 0);\n\t\t\t\t}\n\n\t\t\t\tif (!samplerPoints[cornerSplit].equals(next)) {\n\t\t\t\t\tthis._sharpCorner(samplerPoints[cornerSplit], next, up, 2);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._sharpCorner(current, next, up, 0, true);\n\t\t\t}\n\t\t} // dirType: 0 - use middle dir / 1 - use last dir / 2- use next dir\n\t\t;\n\n\t\t_proto._sharpCorner = function _sharpCorner(current, next, up, dirType, sharp) {\n\t\t\tif (dirType === void 0) {\n\t\t\t\tdirType = 0;\n\t\t\t}\n\n\t\t\tif (sharp === void 0) {\n\t\t\t\tsharp = false;\n\t\t\t}\n\n\t\t\tvar lastPoint = this.array[this.count - 1];\n\n\t\t\tvar point = this._getByIndex(this.count);\n\n\t\t\tvar lastDir = helpVec3_1.subVectors(current, lastPoint.pos);\n\t\t\tvar nextDir = helpVec3_2.subVectors(next, current);\n\t\t\tvar lastDirLength = lastDir.length();\n\t\t\tlastDir.normalize();\n\t\t\tnextDir.normalize();\n\t\t\tpoint.pos.copy(current);\n\n\t\t\tif (dirType === 1) {\n\t\t\t\tpoint.dir.copy(lastDir);\n\t\t\t} else if (dirType === 2) {\n\t\t\t\tpoint.dir.copy(nextDir);\n\t\t\t} else {\n\t\t\t\tpoint.dir.addVectors(lastDir, nextDir);\n\t\t\t\tpoint.dir.normalize();\n\t\t\t}\n\n\t\t\tif (up) {\n\t\t\t\tif (point.dir.dot(up) === 1) {\n\t\t\t\t\tpoint.right.crossVectors(nextDir, up).normalize();\n\t\t\t\t} else {\n\t\t\t\t\tpoint.right.crossVectors(point.dir, up).normalize();\n\t\t\t\t}\n\n\t\t\t\tpoint.up.crossVectors(point.right, point.dir).normalize();\n\t\t\t} else {\n\t\t\t\tpoint.up.copy(lastPoint.up);\n\t\t\t\tvar vec = helpVec3_3.crossVectors(lastPoint.dir, point.dir);\n\n\t\t\t\tif (vec.length() > Number.EPSILON) {\n\t\t\t\t\tvec.normalize();\n\t\t\t\t\tvar theta = Math.acos(Math.min(Math.max(lastPoint.dir.dot(point.dir), -1), 1)); // clamp for floating pt errors\n\n\t\t\t\t\tpoint.up.applyMatrix4(helpMat4.makeRotationAxis(vec, theta));\n\t\t\t\t}\n\n\t\t\t\tpoint.right.crossVectors(point.dir, point.up).normalize();\n\t\t\t}\n\n\t\t\tpoint.dist = lastPoint.dist + lastDirLength;\n\n\t\t\tvar _cos = lastDir.dot(nextDir);\n\n\t\t\tpoint.widthScale = Math.min(1 / Math.sqrt((1 + _cos) / 2), 1.415) || 1;\n\t\t\tpoint.sharp = Math.abs(_cos - 1) > 0.05 && sharp;\n\t\t\tthis.count++;\n\t\t};\n\n\t\treturn PathPointList;\n\t}();\n\n\tfunction _inheritsLoose(subClass, superClass) {\n\t\tsubClass.prototype = Object.create(superClass.prototype);\n\t\tsubClass.prototype.constructor = subClass;\n\n\t\t_setPrototypeOf(subClass, superClass);\n\t}\n\n\tfunction _setPrototypeOf(o, p) {\n\t\t_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n\t\t\to.__proto__ = p;\n\t\t\treturn o;\n\t\t};\n\n\t\treturn _setPrototypeOf(o, p);\n\t}\n\n\t/**\r\n  * PathGeometry\r\n  */\n\n\tvar PathGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {\n\t\t_inheritsLoose(PathGeometry, _THREE$BufferGeometry);\n\n\t\t/**\r\n   * @param {Object|Number} initData - If initData is number, geometry init by empty data and set it as the max vertex. If initData is Object, it contains pathPointList and options.\r\n   * @param {Boolean} [generateUv2=false]\r\n   */\n\t\tfunction PathGeometry(initData, generateUv2) {\n\t\t\tvar _this;\n\n\t\t\tif (initData === void 0) {\n\t\t\t\tinitData = 3000;\n\t\t\t}\n\n\t\t\tif (generateUv2 === void 0) {\n\t\t\t\tgenerateUv2 = false;\n\t\t\t}\n\n\t\t\t_this = _THREE$BufferGeometry.call(this) || this;\n\n\t\t\tif (isNaN(initData)) {\n\t\t\t\t_this._initByData(initData.pathPointList, initData.options, initData.usage, generateUv2);\n\t\t\t} else {\n\t\t\t\t_this._initByMaxVertex(initData, generateUv2);\n\t\t\t}\n\n\t\t\treturn _this;\n\t\t}\n\n\t\tvar _proto = PathGeometry.prototype;\n\n\t\t_proto._initByMaxVertex = function _initByMaxVertex(maxVertex, generateUv2) {\n\t\t\tthis.setAttribute('position', new THREE.BufferAttribute(new Float32Array(maxVertex * 3), 3).setUsage(THREE.DynamicDrawUsage));\n\t\t\tthis.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(maxVertex * 3), 3).setUsage(THREE.DynamicDrawUsage));\n\t\t\tthis.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(maxVertex * 2), 2).setUsage(THREE.DynamicDrawUsage));\n\n\t\t\tif (generateUv2) {\n\t\t\t\tthis.setAttribute('uv2', new THREE.BufferAttribute(new Float32Array(maxVertex * 2), 2).setUsage(THREE.DynamicDrawUsage));\n\t\t\t}\n\n\t\t\tthis.drawRange.start = 0;\n\t\t\tthis.drawRange.count = 0;\n\t\t\tthis.setIndex(new Array(maxVertex * 3));\n\t\t};\n\n\t\t_proto._initByData = function _initByData(pathPointList, options, usage, generateUv2) {\n\t\t\tif (options === void 0) {\n\t\t\t\toptions = {};\n\t\t\t}\n\n\t\t\tvar vertexData = generatePathVertexData(pathPointList, options, generateUv2);\n\n\t\t\tif (vertexData && vertexData.count !== 0) {\n\t\t\t\tthis.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertexData.position), 3).setUsage(usage || THREE.StaticDrawUsage));\n\t\t\t\tthis.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(vertexData.normal), 3).setUsage(usage || THREE.StaticDrawUsage));\n\t\t\t\tthis.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(vertexData.uv), 2).setUsage(usage || THREE.StaticDrawUsage));\n\n\t\t\t\tif (generateUv2) {\n\t\t\t\t\tthis.setAttribute('uv2', new THREE.BufferAttribute(new Float32Array(vertexData.uv2), 2).setUsage(usage || THREE.StaticDrawUsage));\n\t\t\t\t}\n\n\t\t\t\tthis.setIndex(vertexData.indices);\n\t\t\t} else {\n\t\t\t\tthis._initByMaxVertex(2, generateUv2);\n\t\t\t}\n\t\t}\n\t\t/**\r\n   * Update geometry by PathPointList instance\r\n   * @param {PathPointList} pathPointList\r\n   * @param {Object} options\r\n   * @param {Number} [options.width=0.1]\r\n   * @param {Number} [options.progress=1]\r\n   * @param {Boolean} [options.arrow=true]\r\n   * @param {String} [options.side='both'] - \"left\"/\"right\"/\"both\"\r\n   */\n\t\t;\n\n\t\t_proto.update = function update(pathPointList, options) {\n\t\t\tif (options === void 0) {\n\t\t\t\toptions = {};\n\t\t\t}\n\n\t\t\tvar generateUv2 = !!this.getAttribute('uv2');\n\t\t\tvar vertexData = generatePathVertexData(pathPointList, options, generateUv2);\n\n\t\t\tif (vertexData) {\n\t\t\t\tthis._updateAttributes(vertexData.position, vertexData.normal, vertexData.uv, generateUv2 ? vertexData.uv2 : null, vertexData.indices);\n\n\t\t\t\tthis.drawRange.count = vertexData.count;\n\t\t\t} else {\n\t\t\t\tthis.drawRange.count = 0;\n\t\t\t}\n\t\t};\n\n\t\t_proto._resizeAttribute = function _resizeAttribute(name, len) {\n\t\t\tvar attribute = this.getAttribute(name);\n\n\t\t\twhile (attribute.array.length < len) {\n\t\t\t\tvar oldLength = attribute.array.length;\n\t\t\t\tvar newAttribute = new THREE.BufferAttribute(new Float32Array(oldLength * 2), attribute.itemSize, attribute.normalized);\n\t\t\t\tnewAttribute.name = attribute.name;\n\t\t\t\tnewAttribute.usage = attribute.usage;\n\t\t\t\tthis.setAttribute(name, newAttribute);\n\t\t\t\tattribute = newAttribute;\n\t\t\t}\n\t\t};\n\n\t\t_proto._resizeIndex = function _resizeIndex(len) {\n\t\t\tvar index = this.getIndex();\n\n\t\t\twhile (index.array.length < len) {\n\t\t\t\tvar oldLength = index.array.length;\n\t\t\t\tvar newIndex = new THREE.BufferAttribute(oldLength * 2 > 65535 ? new Uint32Array(oldLength * 2) : new Uint16Array(oldLength * 2), 1);\n\t\t\t\tnewIndex.name = index.name;\n\t\t\t\tnewIndex.usage = index.usage;\n\t\t\t\tthis.setIndex(newIndex);\n\t\t\t\tindex = newIndex;\n\t\t\t}\n\t\t};\n\n\t\t_proto._updateAttributes = function _updateAttributes(position, normal, uv, uv2, indices) {\n\t\t\tthis._resizeAttribute('position', position.length);\n\n\t\t\tvar positionAttribute = this.getAttribute('position');\n\t\t\tpositionAttribute.array.set(position, 0);\n\t\t\tpositionAttribute.updateRange.count = position.length;\n\t\t\tpositionAttribute.needsUpdate = true;\n\n\t\t\tthis._resizeAttribute('normal', normal.length);\n\n\t\t\tvar normalAttribute = this.getAttribute('normal');\n\t\t\tnormalAttribute.array.set(normal, 0);\n\t\t\tnormalAttribute.updateRange.count = normal.length;\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t\tthis._resizeAttribute('uv', uv.length);\n\n\t\t\tvar uvAttribute = this.getAttribute('uv');\n\t\t\tuvAttribute.array.set(uv, 0);\n\t\t\tuvAttribute.updateRange.count = uv.length;\n\t\t\tuvAttribute.needsUpdate = true;\n\n\t\t\tif (uv2) {\n\t\t\t\tthis._resizeAttribute('uv2', uv2.length);\n\n\t\t\t\tvar uv2Attribute = this.getAttribute('uv2');\n\t\t\t\tuv2Attribute.array.set(uv2, 0);\n\t\t\t\tuv2Attribute.updateRange.count = uv2.length;\n\t\t\t\tuv2Attribute.needsUpdate = true;\n\t\t\t}\n\n\t\t\tthis._resizeIndex(indices.length);\n\n\t\t\tvar indexAttribute = this.getIndex();\n\t\t\tindexAttribute.set(indices, 0);\n\t\t\tindexAttribute.updateRange.count = indices.length;\n\t\t\tindexAttribute.needsUpdate = true;\n\t\t};\n\n\t\treturn PathGeometry;\n\t}(THREE.BufferGeometry);\n\n\tfunction generatePathVertexData(pathPointList, options, generateUv2) {\n\t\tif (generateUv2 === void 0) {\n\t\t\tgenerateUv2 = false;\n\t\t}\n\n\t\tvar width = options.width || 0.1;\n\t\tvar progress = options.progress !== undefined ? options.progress : 1;\n\t\tvar arrow = options.arrow !== undefined ? options.arrow : true;\n\t\tvar side = options.side !== undefined ? options.side : \"both\";\n\t\tvar halfWidth = width / 2;\n\t\tvar sideWidth = side !== \"both\" ? width / 2 : width;\n\t\tvar totalDistance = pathPointList.distance();\n\t\tvar progressDistance = progress * totalDistance;\n\n\t\tif (totalDistance == 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar sharpUvOffset = halfWidth / sideWidth;\n\t\tvar sharpUvOffset2 = halfWidth / totalDistance;\n\t\tvar count = 0; // modify data\n\n\t\tvar position = [];\n\t\tvar normal = [];\n\t\tvar uv = [];\n\t\tvar uv2 = [];\n\t\tvar indices = [];\n\t\tvar verticesCount = 0;\n\t\tvar right = new THREE.Vector3();\n\t\tvar left = new THREE.Vector3(); // for sharp corners\n\n\t\tvar leftOffset = new THREE.Vector3();\n\t\tvar rightOffset = new THREE.Vector3();\n\t\tvar tempPoint1 = new THREE.Vector3();\n\t\tvar tempPoint2 = new THREE.Vector3();\n\n\t\tfunction addVertices(pathPoint) {\n\t\t\tvar first = position.length === 0;\n\t\t\tvar sharpCorner = pathPoint.sharp && !first;\n\t\t\tvar uvDist = pathPoint.dist / sideWidth;\n\t\t\tvar uvDist2 = pathPoint.dist / totalDistance;\n\t\t\tvar dir = pathPoint.dir;\n\t\t\tvar up = pathPoint.up;\n\t\t\tvar _right = pathPoint.right;\n\n\t\t\tif (side !== \"left\") {\n\t\t\t\tright.copy(_right).multiplyScalar(halfWidth * pathPoint.widthScale);\n\t\t\t} else {\n\t\t\t\tright.set(0, 0, 0);\n\t\t\t}\n\n\t\t\tif (side !== \"right\") {\n\t\t\t\tleft.copy(_right).multiplyScalar(-halfWidth * pathPoint.widthScale);\n\t\t\t} else {\n\t\t\t\tleft.set(0, 0, 0);\n\t\t\t}\n\n\t\t\tright.add(pathPoint.pos);\n\t\t\tleft.add(pathPoint.pos);\n\n\t\t\tif (sharpCorner) {\n\t\t\t\tleftOffset.fromArray(position, position.length - 6).sub(left);\n\t\t\t\trightOffset.fromArray(position, position.length - 3).sub(right);\n\t\t\t\tvar leftDist = leftOffset.length();\n\t\t\t\tvar rightDist = rightOffset.length();\n\t\t\t\tvar sideOffset = leftDist - rightDist;\n\t\t\t\tvar longerOffset, longEdge;\n\n\t\t\t\tif (sideOffset > 0) {\n\t\t\t\t\tlongerOffset = leftOffset;\n\t\t\t\t\tlongEdge = left;\n\t\t\t\t} else {\n\t\t\t\t\tlongerOffset = rightOffset;\n\t\t\t\t\tlongEdge = right;\n\t\t\t\t}\n\n\t\t\t\ttempPoint1.copy(longerOffset).setLength(Math.abs(sideOffset)).add(longEdge);\n\n\t\t\t\tvar _cos = tempPoint2.copy(longEdge).sub(tempPoint1).normalize().dot(dir);\n\n\t\t\t\tvar _len = tempPoint2.copy(longEdge).sub(tempPoint1).length();\n\n\t\t\t\tvar _dist = _cos * _len * 2;\n\n\t\t\t\ttempPoint2.copy(dir).setLength(_dist).add(tempPoint1);\n\n\t\t\t\tif (sideOffset > 0) {\n\t\t\t\t\tposition.push(tempPoint1.x, tempPoint1.y, tempPoint1.z, // 6\n\t\t\t\t\tright.x, right.y, right.z, // 5\n\t\t\t\t\tleft.x, left.y, left.z, // 4\n\t\t\t\t\tright.x, right.y, right.z, // 3\n\t\t\t\t\ttempPoint2.x, tempPoint2.y, tempPoint2.z, // 2\n\t\t\t\t\tright.x, right.y, right.z // 1\n\t\t\t\t\t);\n\t\t\t\t\tverticesCount += 6;\n\t\t\t\t\tindices.push(verticesCount - 6, verticesCount - 8, verticesCount - 7, verticesCount - 6, verticesCount - 7, verticesCount - 5, verticesCount - 4, verticesCount - 6, verticesCount - 5, verticesCount - 2, verticesCount - 4, verticesCount - 1);\n\t\t\t\t\tcount += 12;\n\t\t\t\t} else {\n\t\t\t\t\tposition.push(left.x, left.y, left.z, // 6\n\t\t\t\t\ttempPoint1.x, tempPoint1.y, tempPoint1.z, // 5\n\t\t\t\t\tleft.x, left.y, left.z, // 4\n\t\t\t\t\tright.x, right.y, right.z, // 3\n\t\t\t\t\tleft.x, left.y, left.z, // 2\n\t\t\t\t\ttempPoint2.x, tempPoint2.y, tempPoint2.z // 1\n\t\t\t\t\t);\n\t\t\t\t\tverticesCount += 6;\n\t\t\t\t\tindices.push(verticesCount - 6, verticesCount - 8, verticesCount - 7, verticesCount - 6, verticesCount - 7, verticesCount - 5, verticesCount - 6, verticesCount - 5, verticesCount - 3, verticesCount - 2, verticesCount - 3, verticesCount - 1);\n\t\t\t\t\tcount += 12;\n\t\t\t\t}\n\n\t\t\t\tnormal.push(up.x, up.y, up.z, up.x, up.y, up.z, up.x, up.y, up.z, up.x, up.y, up.z, up.x, up.y, up.z, up.x, up.y, up.z);\n\t\t\t\tuv.push(uvDist - sharpUvOffset, 0, uvDist - sharpUvOffset, 1, uvDist, 0, uvDist, 1, uvDist + sharpUvOffset, 0, uvDist + sharpUvOffset, 1);\n\n\t\t\t\tif (generateUv2) {\n\t\t\t\t\tuv2.push(uvDist2 - sharpUvOffset2, 0, uvDist2 - sharpUvOffset2, 1, uvDist2, 0, uvDist2, 1, uvDist2 + sharpUvOffset2, 0, uvDist2 + sharpUvOffset2, 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tposition.push(left.x, left.y, left.z, right.x, right.y, right.z);\n\t\t\t\tnormal.push(up.x, up.y, up.z, up.x, up.y, up.z);\n\t\t\t\tuv.push(uvDist, 0, uvDist, 1);\n\n\t\t\t\tif (generateUv2) {\n\t\t\t\t\tuv2.push(uvDist2, 0, uvDist2, 1);\n\t\t\t\t}\n\n\t\t\t\tverticesCount += 2;\n\n\t\t\t\tif (!first) {\n\t\t\t\t\tindices.push(verticesCount - 2, verticesCount - 4, verticesCount - 3, verticesCount - 2, verticesCount - 3, verticesCount - 1);\n\t\t\t\t\tcount += 6;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar sharp = new THREE.Vector3();\n\n\t\tfunction addStart(pathPoint) {\n\t\t\tvar dir = pathPoint.dir;\n\t\t\tvar up = pathPoint.up;\n\t\t\tvar _right = pathPoint.right;\n\t\t\tvar uvDist = pathPoint.dist / sideWidth;\n\t\t\tvar uvDist2 = pathPoint.dist / totalDistance;\n\n\t\t\tif (side !== \"left\") {\n\t\t\t\tright.copy(_right).multiplyScalar(halfWidth * 2);\n\t\t\t} else {\n\t\t\t\tright.set(0, 0, 0);\n\t\t\t}\n\n\t\t\tif (side !== \"right\") {\n\t\t\t\tleft.copy(_right).multiplyScalar(-halfWidth * 2);\n\t\t\t} else {\n\t\t\t\tleft.set(0, 0, 0);\n\t\t\t}\n\n\t\t\tsharp.copy(dir).setLength(halfWidth * 3);\n\t\t\tright.add(pathPoint.pos);\n\t\t\tleft.add(pathPoint.pos);\n\t\t\tsharp.add(pathPoint.pos);\n\t\t\tposition.push(left.x, left.y, left.z, right.x, right.y, right.z, sharp.x, sharp.y, sharp.z);\n\t\t\tnormal.push(up.x, up.y, up.z, up.x, up.y, up.z, up.x, up.y, up.z);\n\t\t\tuv.push(uvDist, side !== \"both\" ? side !== \"right\" ? -2 : 0 : -0.5, uvDist, side !== \"both\" ? side !== \"left\" ? 2 : 0 : 1.5, uvDist + 1.5, side !== \"both\" ? 0 : 0.5);\n\n\t\t\tif (generateUv2) {\n\t\t\t\tuv2.push(uvDist2, side !== \"both\" ? side !== \"right\" ? -2 : 0 : -0.5, uvDist2, side !== \"both\" ? side !== \"left\" ? 2 : 0 : 1.5, uvDist2 + 1.5 * width / totalDistance, side !== \"both\" ? 0 : 0.5);\n\t\t\t}\n\n\t\t\tverticesCount += 3;\n\t\t\tindices.push(verticesCount - 1, verticesCount - 3, verticesCount - 2);\n\t\t\tcount += 3;\n\t\t}\n\n\t\tvar lastPoint;\n\n\t\tif (progressDistance > 0) {\n\t\t\tfor (var i = 0; i < pathPointList.count; i++) {\n\t\t\t\tvar pathPoint = pathPointList.array[i];\n\n\t\t\t\tif (pathPoint.dist > progressDistance) {\n\t\t\t\t\tvar prevPoint = pathPointList.array[i - 1];\n\t\t\t\t\tlastPoint = new PathPoint(); // linear lerp for progress\n\n\t\t\t\t\tvar alpha = (progressDistance - prevPoint.dist) / (pathPoint.dist - prevPoint.dist);\n\t\t\t\t\tlastPoint.lerpPathPoints(prevPoint, pathPoint, alpha);\n\t\t\t\t\taddVertices(lastPoint);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\taddVertices(pathPoint);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlastPoint = pathPointList.array[0];\n\t\t} // build arrow geometry\n\n\n\t\tif (arrow) {\n\t\t\tlastPoint = lastPoint || pathPointList.array[pathPointList.count - 1];\n\t\t\taddStart(lastPoint);\n\t\t}\n\n\t\treturn {\n\t\t\tposition: position,\n\t\t\tnormal: normal,\n\t\t\tuv: uv,\n\t\t\tuv2: uv2,\n\t\t\tindices: indices,\n\t\t\tcount: count\n\t\t};\n\t}\n\n\t/**\r\n  * PathTubeGeometry\r\n  */\n\n\tvar PathTubeGeometry = /*#__PURE__*/function (_PathGeometry) {\n\t\t_inheritsLoose(PathTubeGeometry, _PathGeometry);\n\n\t\t/**\r\n   * @param {Object|Number} initData - If initData is number, geometry init by empty data and set it as the max vertex. If initData is Object, it contains pathPointList and options.\r\n   * @param {Boolean} [generateUv2=false]\r\n   */\n\t\tfunction PathTubeGeometry(initData, generateUv2) {\n\t\t\tif (initData === void 0) {\n\t\t\t\tinitData = 1000;\n\t\t\t}\n\n\t\t\tif (generateUv2 === void 0) {\n\t\t\t\tgenerateUv2 = false;\n\t\t\t}\n\n\t\t\treturn _PathGeometry.call(this, initData, generateUv2) || this;\n\t\t}\n\n\t\tvar _proto = PathTubeGeometry.prototype;\n\n\t\t_proto._initByData = function _initByData(pathPointList, options, usage, generateUv2) {\n\t\t\tif (options === void 0) {\n\t\t\t\toptions = {};\n\t\t\t}\n\n\t\t\tvar vertexData = generateTubeVertexData(pathPointList, options, generateUv2);\n\n\t\t\tif (vertexData && vertexData.count !== 0) {\n\t\t\t\tthis.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertexData.position), 3).setUsage(usage || THREE.StaticDrawUsage));\n\t\t\t\tthis.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(vertexData.normal), 3).setUsage(usage || THREE.StaticDrawUsage));\n\t\t\t\tthis.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(vertexData.uv), 2).setUsage(usage || THREE.StaticDrawUsage));\n\n\t\t\t\tif (generateUv2) {\n\t\t\t\t\tthis.setAttribute('uv2', new THREE.BufferAttribute(new Float32Array(vertexData.uv2), 2).setUsage(usage || THREE.StaticDrawUsage));\n\t\t\t\t}\n\n\t\t\t\tthis.setIndex(vertexData.indices);\n\t\t\t} else {\n\t\t\t\tthis._initByMaxVertex(2, generateUv2);\n\t\t\t}\n\t\t}\n\t\t/**\r\n   * Update geometry by PathPointList instance\r\n   * @param {PathPointList} pathPointList\r\n   * @param {Object} options\r\n   * @param {Number} [options.radius=0.1]\r\n   * @param {Number} [options.progress=1]\r\n   * @param {Boolean} [options.radialSegments=8]\r\n   * @param {String} [options.startRad=0]\r\n   */\n\t\t;\n\n\t\t_proto.update = function update(pathPointList, options) {\n\t\t\tif (options === void 0) {\n\t\t\t\toptions = {};\n\t\t\t}\n\n\t\t\tvar generateUv2 = !!this.getAttribute('uv2');\n\t\t\tvar vertexData = generateTubeVertexData(pathPointList, options, generateUv2);\n\n\t\t\tif (vertexData) {\n\t\t\t\tthis._updateAttributes(vertexData.position, vertexData.normal, vertexData.uv, generateUv2 ? vertexData.uv2 : null, vertexData.indices);\n\n\t\t\t\tthis.drawRange.count = vertexData.count;\n\t\t\t} else {\n\t\t\t\tthis.drawRange.count = 0;\n\t\t\t}\n\t\t};\n\n\t\treturn PathTubeGeometry;\n\t}(PathGeometry);\n\n\tfunction generateTubeVertexData(pathPointList, options, generateUv2) {\n\t\tif (generateUv2 === void 0) {\n\t\t\tgenerateUv2 = false;\n\t\t}\n\n\t\tvar radius = options.radius || 0.1;\n\t\tvar progress = options.progress !== undefined ? options.progress : 1;\n\t\tvar radialSegments = Math.max(2, options.radialSegments || 8);\n\t\tvar startRad = options.startRad || 0;\n\t\tvar circum = radius * 2 * Math.PI;\n\t\tvar totalDistance = pathPointList.distance();\n\t\tvar progressDistance = progress * totalDistance;\n\n\t\tif (progressDistance == 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar count = 0; // modify data\n\n\t\tvar position = [];\n\t\tvar normal = [];\n\t\tvar uv = [];\n\t\tvar uv2 = [];\n\t\tvar indices = [];\n\t\tvar verticesCount = 0;\n\t\tvar normalDir = new THREE.Vector3();\n\n\t\tfunction addVertices(pathPoint, radius, radialSegments) {\n\t\t\tvar first = position.length === 0;\n\t\t\tvar uvDist = pathPoint.dist / circum;\n\t\t\tvar uvDist2 = pathPoint.dist / totalDistance;\n\n\t\t\tfor (var r = 0; r <= radialSegments; r++) {\n\t\t\t\tvar _r = r;\n\n\t\t\t\tif (_r == radialSegments) {\n\t\t\t\t\t_r = 0;\n\t\t\t\t}\n\n\t\t\t\tnormalDir.copy(pathPoint.up).applyAxisAngle(pathPoint.dir, startRad + Math.PI * 2 * _r / radialSegments).normalize();\n\t\t\t\tposition.push(pathPoint.pos.x + normalDir.x * radius * pathPoint.widthScale, pathPoint.pos.y + normalDir.y * radius * pathPoint.widthScale, pathPoint.pos.z + normalDir.z * radius * pathPoint.widthScale);\n\t\t\t\tnormal.push(normalDir.x, normalDir.y, normalDir.z);\n\t\t\t\tuv.push(uvDist, r / radialSegments);\n\n\t\t\t\tif (generateUv2) {\n\t\t\t\t\tuv2.push(uvDist2, r / radialSegments);\n\t\t\t\t}\n\n\t\t\t\tverticesCount++;\n\t\t\t}\n\n\t\t\tif (!first) {\n\t\t\t\tvar begin1 = verticesCount - (radialSegments + 1) * 2;\n\t\t\t\tvar begin2 = verticesCount - (radialSegments + 1);\n\n\t\t\t\tfor (var i = 0; i < radialSegments; i++) {\n\t\t\t\t\tindices.push(begin2 + i, begin1 + i, begin1 + i + 1, begin2 + i, begin1 + i + 1, begin2 + i + 1);\n\t\t\t\t\tcount += 6;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (progressDistance > 0) {\n\t\t\tfor (var i = 0; i < pathPointList.count; i++) {\n\t\t\t\tvar pathPoint = pathPointList.array[i];\n\n\t\t\t\tif (pathPoint.dist > progressDistance) {\n\t\t\t\t\tvar prevPoint = pathPointList.array[i - 1];\n\t\t\t\t\tvar lastPoint = new PathPoint(); // linear lerp for progress\n\n\t\t\t\t\tvar alpha = (progressDistance - prevPoint.dist) / (pathPoint.dist - prevPoint.dist);\n\t\t\t\t\tlastPoint.lerpPathPoints(prevPoint, pathPoint, alpha);\n\t\t\t\t\taddVertices(lastPoint, radius, radialSegments);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\taddVertices(pathPoint, radius, radialSegments);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tposition: position,\n\t\t\tnormal: normal,\n\t\t\tuv: uv,\n\t\t\tuv2: uv2,\n\t\t\tindices: indices,\n\t\t\tcount: count\n\t\t};\n\t}\n\n\tTHREE.PathGeometry = PathGeometry;\n\tTHREE.PathPointList = PathPointList;\n\tTHREE.PathTubeGeometry = PathTubeGeometry;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n});\n\n//# sourceURL=webpack:///./src/extra/three.path.js?")
        },
        "./src/extra/tween.js": /*!****************************!*\
  !*** ./src/extra/tween.js ***!
  \****************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n/*\r\n * Tween.js\r\n * t: current time（当前时间）；\r\n * b: beginning value（初始值）；\r\n * c: change in value（变化量）；\r\n * d: duration（持续时间）。\r\n * you can visit 'http://easings.net/zh-cn' to get effect\r\n*/\nexports.default = {\n    Linear: function Linear(t, b, c, d) {\n        return c * t / d + b;\n    },\n    Quad: {\n        easeIn: function easeIn(t, b, c, d) {\n            return c * (t /= d) * t + b;\n        },\n        easeOut: function easeOut(t, b, c, d) {\n            return -c * (t /= d) * (t - 2) + b;\n        },\n        easeInOut: function easeInOut(t, b, c, d) {\n            if ((t /= d / 2) < 1) return c / 2 * t * t + b;\n            return -c / 2 * (--t * (t - 2) - 1) + b;\n        }\n    },\n    Cubic: {\n        easeIn: function easeIn(t, b, c, d) {\n            return c * (t /= d) * t * t + b;\n        },\n        easeOut: function easeOut(t, b, c, d) {\n            return c * ((t = t / d - 1) * t * t + 1) + b;\n        },\n        easeInOut: function easeInOut(t, b, c, d) {\n            if ((t /= d / 2) < 1) return c / 2 * t * t * t + b;\n            return c / 2 * ((t -= 2) * t * t + 2) + b;\n        }\n    },\n    Quart: {\n        easeIn: function easeIn(t, b, c, d) {\n            return c * (t /= d) * t * t * t + b;\n        },\n        easeOut: function easeOut(t, b, c, d) {\n            return -c * ((t = t / d - 1) * t * t * t - 1) + b;\n        },\n        easeInOut: function easeInOut(t, b, c, d) {\n            if ((t /= d / 2) < 1) return c / 2 * t * t * t * t + b;\n            return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\n        }\n    },\n    Quint: {\n        easeIn: function easeIn(t, b, c, d) {\n            return c * (t /= d) * t * t * t * t + b;\n        },\n        easeOut: function easeOut(t, b, c, d) {\n            return c * ((t = t / d - 1) * t * t * t * t + 1) + b;\n        },\n        easeInOut: function easeInOut(t, b, c, d) {\n            if ((t /= d / 2) < 1) return c / 2 * t * t * t * t * t + b;\n            return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;\n        }\n    },\n    Sine: {\n        easeIn: function easeIn(t, b, c, d) {\n            return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\n        },\n        easeOut: function easeOut(t, b, c, d) {\n            return c * Math.sin(t / d * (Math.PI / 2)) + b;\n        },\n        easeInOut: function easeInOut(t, b, c, d) {\n            return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;\n        }\n    },\n    Expo: {\n        easeIn: function easeIn(t, b, c, d) {\n            return t == 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;\n        },\n        easeOut: function easeOut(t, b, c, d) {\n            return t == d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;\n        },\n        easeInOut: function easeInOut(t, b, c, d) {\n            if (t == 0) return b;\n            if (t == d) return b + c;\n            if ((t /= d / 2) < 1) return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\n            return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\n        }\n    },\n    Circ: {\n        easeIn: function easeIn(t, b, c, d) {\n            return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;\n        },\n        easeOut: function easeOut(t, b, c, d) {\n            return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;\n        },\n        easeInOut: function easeInOut(t, b, c, d) {\n            if ((t /= d / 2) < 1) return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;\n            return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;\n        }\n    },\n    Elastic: {\n        easeIn: function easeIn(t, b, c, d, a, p) {\n            var s;\n            if (t == 0) return b;\n            if ((t /= d) == 1) return b + c;\n            if (typeof p == 'undefined') p = d * .3;\n            if (!a || a < Math.abs(c)) {\n                s = p / 4;\n                a = c;\n            } else {\n                s = p / (2 * Math.PI) * Math.asin(c / a);\n            }\n            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n        },\n        easeOut: function easeOut(t, b, c, d, a, p) {\n            var s;\n            if (t == 0) return b;\n            if ((t /= d) == 1) return b + c;\n            if (typeof p == 'undefined') p = d * .3;\n            if (!a || a < Math.abs(c)) {\n                a = c;\n                s = p / 4;\n            } else {\n                s = p / (2 * Math.PI) * Math.asin(c / a);\n            }\n            return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;\n        },\n        easeInOut: function easeInOut(t, b, c, d, a, p) {\n            var s;\n            if (t == 0) return b;\n            if ((t /= d / 2) == 2) return b + c;\n            if (typeof p == 'undefined') p = d * (.3 * 1.5);\n            if (!a || a < Math.abs(c)) {\n                a = c;\n                s = p / 4;\n            } else {\n                s = p / (2 * Math.PI) * Math.asin(c / a);\n            }\n            if (t < 1) return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b;\n        }\n    },\n    Back: {\n        easeIn: function easeIn(t, b, c, d, s) {\n            if (typeof s == 'undefined') s = 1.70158;\n            return c * (t /= d) * t * ((s + 1) * t - s) + b;\n        },\n        easeOut: function easeOut(t, b, c, d, s) {\n            if (typeof s == 'undefined') s = 1.70158;\n            return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\n        },\n        easeInOut: function easeInOut(t, b, c, d, s) {\n            if (typeof s == 'undefined') s = 1.70158;\n            if ((t /= d / 2) < 1) return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;\n            return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;\n        }\n    },\n    Bounce: {\n        easeIn: function easeIn(t, b, c, d) {\n            return c - Tween.Bounce.easeOut(d - t, 0, c, d) + b;\n        },\n        easeOut: function easeOut(t, b, c, d) {\n            if ((t /= d) < 1 / 2.75) {\n                return c * (7.5625 * t * t) + b;\n            } else if (t < 2 / 2.75) {\n                return c * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + b;\n            } else if (t < 2.5 / 2.75) {\n                return c * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + b;\n            } else {\n                return c * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + b;\n            }\n        },\n        easeInOut: function easeInOut(t, b, c, d) {\n            if (t < d / 2) {\n                return Tween.Bounce.easeIn(t * 2, 0, c, d) * .5 + b;\n            } else {\n                return Tween.Bounce.easeOut(t * 2 - d, 0, c, d) * .5 + c * .5 + b;\n            }\n        }\n    }\n};\n\n//# sourceURL=webpack:///./src/extra/tween.js?")
        },
        "./src/geometry/GeometryManager.js": /*!*****************************************!*\
  !*** ./src/geometry/GeometryManager.js ***!
  \*****************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _createBigBuildingByUearthWorker = __webpack_require__(/*! ../../lib/threejs/createBigBuildingByUearth.worker.js */ \"./lib/threejs/createBigBuildingByUearth.worker.js\");\n\nvar _createBigBuildingByUearthWorker2 = _interopRequireDefault(_createBigBuildingByUearthWorker);\n\nvar _SynchroGeometryManager = __webpack_require__(/*! ./SynchroGeometryManager.js */ \"./src/geometry/SynchroGeometryManager.js\");\n\nvar _SynchroGeometryManager2 = _interopRequireDefault(_SynchroGeometryManager);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * GeometryManager主要是为了维护异步逻辑,每一个manager可以\r\n * 自动创建一个自己对worker\r\n * TODO 目前还是没有做到可以最大化使用电脑的线程，每次创建只是多启了两个线程而已,依然还有很大的优化空间\r\n * changed by zhgu\r\n * **/\nvar GeometryManager = function (_SynchroGeometryManag) {\n    _inherits(GeometryManager, _SynchroGeometryManag);\n\n    function GeometryManager(name, workerNums) {\n        _classCallCheck(this, GeometryManager);\n\n        var _this = _possibleConstructorReturn(this, (GeometryManager.__proto__ || Object.getPrototypeOf(GeometryManager)).call(this, name));\n\n        _this.type = 'GeometryManager';\n        _this._startID = 0;\n        workerNums = workerNums || 1;\n        var maxWorkerNums = navigator.hardwareConcurrency || 4;\n        if (workerNums >= maxWorkerNums - 2) {\n            //目前先预留四个线程\n            console.warn('你创建的线程数超过cpu最大线程数');\n            workerNums = maxWorkerNums - 2 || 1;\n        }\n        _this._workers = [];\n        for (var i = 0; i < workerNums; i++) {\n            _this._workers.push(new _createBigBuildingByUearthWorker2.default());\n        }\n        return _this;\n    }\n    //使用geometryManager必须使用finish接口，再callback中创建最终的mesh\n\n\n    _createClass(GeometryManager, [{\n        key: 'finish',\n        value: function finish(callback, progress, completeCallBack) {\n            var scope = this;\n            var data = scope.data;\n            for (var _i = 0; _i < this.data.length; _i++) {\n                this.data[_i].offsetHeight = this._offsetHeightList[_i];\n                this.data[_i].refenenceNode = this._referenceNodeList[_i];\n            }\n            var res = scope._processData(data, scope._workers.length);\n            scope.mergeTotal = scope._getMergeTotal(res, scope.nums);\n            var useAroundUV = false;\n            if (this._renderer && this._renderer.windowTextureWrap === 'around') {\n                useAroundUV = true;\n            }\n            for (var i = 0; i < scope._workers.length; i++) {\n                var worker = scope._workers[i];\n                //res[i]中存放了拔楼时基于的参考点的matrix和离地高度\n                //要将建筑父节点的matrix传到worker中 用于相对坐标重新计算\n                var featureLength = res[i].length;\n                scope._postMessage(worker, { matrix: this._tempParent.matrix.elements, data: res[i], startId: this._startID, useAroundUV: useAroundUV });\n                this._startID += featureLength;\n                worker.onmessage = function (event) {\n                    var position = event.data.position;\n                    var normal = event.data.normal;\n                    var uv = event.data.uv;\n                    var uv2 = event.data.uv2;\n                    var uv3 = event.data.uv3;\n                    var uv8 = event.data.uv8;\n                    var index = event.data.index;\n                    var groups = event.data.groups;\n                    var id = event.data.id;\n                    var vis = event.data.vis;\n                    var _needMerge = event.data._needMerge;\n                    var geometry = scope.createGeometry(position, normal, uv, index, uv2, uv3, uv8, groups, id, vis);\n                    geometry._needMerge = _needMerge; //处理其他需要merge的信息\n                    scope.mergedGeometry.push(geometry);\n                    scope.mergeNums++;\n                    if (progress) {\n                        progress.call(scope, scope.mergeNums / scope.mergeTotal);\n                    }\n                    //继续处理id，生成idBuffer\n                    scope._processIdBuffer(geometry);\n                    scope.eventManager.dispatchEvent({ type: 'progress', data: { manager: scope, progress: scope.mergeNums / scope.mergeTotal, geometry: geometry } });\n                    if (callback) {\n                        callback.call(scope, geometry);\n                    }\n                    if (scope.mergeNums >= scope.mergeTotal) {\n                        scope.eventManager.dispatchEvent({ type: 'complete', data: { manager: scope, geometry: scope.mergedGeometry } });\n                        if (completeCallBack) {\n                            completeCallBack.call(scope, scope);\n                        }\n                        //关闭worker\n                        scope.dispose();\n                        //console.log('finish');\n                    }\n                };\n\n                worker.onerror = function (e) {\n                    console.log(['ERROR: Line ', e.lineno, ' in ', e.filename, ': ', e.message].join(''));\n                };\n            }\n        }\n        //TODO 目前只是释放所有worker，没有释放所有挂载的资源\n\n    }, {\n        key: 'dispose',\n        value: function dispose() {\n            this._workers.map(function (v) {\n                v.terminate();\n            });\n            this.data = [];\n            this.mergedGeometry = [];\n            this._offsetHeightList = [];\n            this._referenceNodeList = [];\n            this.geometryArr = [];\n        }\n\n        //获取一共要执行的merge次数,必须传入分割好的数据\n\n    }, {\n        key: '_getMergeTotal',\n        value: function _getMergeTotal(resData, nums) {\n            var total = 0;\n            for (var i = 0; i < resData.length; i++) {\n                total += Math.ceil(resData[i].length / nums);\n            }\n            return total;\n        }\n\n        //发送message,需传入一个worker\n\n    }, {\n        key: '_postMessage',\n        value: function _postMessage(worker, data) {\n            var scope = this;\n            // var data = scope.data;\n            var nums = scope.nums;\n            var i = data.startId;\n            while (data.data.length > 0) {\n                var resData = data.data.splice(0, nums);\n                //data.matrix 建筑父节点的matrix\n                worker.postMessage({ data: resData, idStartNum: scope.idStartNum, start: i, matrix: data.matrix, useAroundUV: data.useAroundUV });\n                i += resData.length;\n            }\n        }\n    }, {\n        key: 'createGeometry',\n        value: function createGeometry(position, normal, uv, index, uv2, uv3, uv8, groups, id, vis) {\n            var geometry = new THREE.BufferGeometry();\n            geometry.addAttribute('position', new THREE.BufferAttribute(position, 3));\n            geometry.addAttribute('normal', new THREE.BufferAttribute(normal, 3));\n            geometry.addAttribute('uv', new THREE.BufferAttribute(uv, 2));\n            if (index) {\n                geometry.setIndex(new THREE.BufferAttribute(index, 1));\n            }\n            if (uv2) {\n                geometry.addAttribute('uv2', new THREE.BufferAttribute(uv2, 2));\n            }\n            if (uv3) {\n                geometry.addAttribute('uv3', new THREE.BufferAttribute(uv3, 2));\n            }\n            if (uv8) {\n                geometry.addAttribute('uv8', new THREE.BufferAttribute(uv8, 2));\n            }\n            if (groups) {\n                geometry.groups = groups;\n            }\n            if (id) {\n                geometry.addAttribute('id', new THREE.BufferAttribute(id, 1));\n            }\n            if (vis) {\n                geometry.addAttribute('vis', new THREE.BufferAttribute(vis, 1));\n            }\n            return geometry;\n        }\n    }]);\n\n    return GeometryManager;\n}(_SynchroGeometryManager2.default);\n\nexports.default = GeometryManager;\n\n//# sourceURL=webpack:///./src/geometry/GeometryManager.js?")
        },
        "./src/geometry/ManualObject.js": /*!**************************************!*\
  !*** ./src/geometry/ManualObject.js ***!
  \**************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _buffer = __webpack_require__(/*! ../util/buffer.js */ \"./src/util/buffer.js\");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _helper = __webpack_require__(/*! ../util/helper.js */ \"./src/util/helper.js\");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nvar _materialManager = __webpack_require__(/*! ../material/materialManager.js */ \"./src/material/materialManager.js\");\n\nvar _materialManager2 = _interopRequireDefault(_materialManager);\n\nvar _materialFactory = __webpack_require__(/*! ../material/materialFactory.js */ \"./src/material/materialFactory.js\");\n\nvar _materialFactory2 = _interopRequireDefault(_materialFactory);\n\nvar _sourceThreeFunction = __webpack_require__(/*! ../material/sourceThreeFunction.js */ \"./src/material/sourceThreeFunction.js\");\n\nvar _sourceThreeFunction2 = _interopRequireDefault(_sourceThreeFunction);\n\nvar _MeshLine = __webpack_require__(/*! ../extra/MeshLine.js */ \"./src/extra/MeshLine.js\");\n\nvar _math = __webpack_require__(/*! ../util/math.js */ \"./src/util/math.js\");\n\nvar _math2 = _interopRequireDefault(_math);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ManualObject = function () {\n  function ManualObject(name) {\n    _classCallCheck(this, ManualObject);\n\n    this.options = {\n      'colour': 4,\n      'position': 3,\n      'normal': 3,\n      'textureCoord': 2\n    };\n    this.name = name || _helper2.default.getUUID();\n  }\n\n  /**\r\n   * [beginVertexesAndIndexsStringEndString description]\r\n   * @param  {[type]} matName [description]\r\n   * @param  {[type]} type    [description]\r\n   * @param  {[type]} data    [description]\r\n   * @param  {[type]} index   [description]\r\n   * @param  {[type]} pos     [description]\r\n   * @return {[type]}         [description]\r\n   *\r\n   * @example beginVertexesAndIndexsStringEndString(\"xxx\", t3djs.RenderOperationType.TRIANGLE_LIST, data, index, \"position,colour\");\r\n   */\n\n\n  _createClass(ManualObject, [{\n    key: 'beginVertexesAndIndexsStringEndString',\n    value: function beginVertexesAndIndexsStringEndString(matName, type, data, index, pos) {\n\n      var indexArr = index;\n      if (typeof indexArr === 'string') {\n        indexArr = this._stringReader(index);\n      }\n      //var indexArr = this._stringReader(index);\n      if (type == 'LINE_STRIP') {\n        //console.log('LINE_STRIP稍后实现');\n      } else if (type == 'TRIANGLE_LIST') {\n        //console.log('TRIANGLE_LIST稍后实现');\n      }\n      var myData = this._separateData(data, pos);\n      var geometry = new THREE.Geometry();\n      geometry.vertices = myData.position.data;\n\n      if (myData.colour) {\n        geometry.colors = myData.colour.data;\n      }\n\n      var faceIndices = ['a', 'b', 'c', 'd'];\n      for (var i = 0; i < indexArr.length; i += 3) {\n        var face = new THREE.Face3(indexArr[i], indexArr[i + 1], indexArr[i + 2]);\n        geometry.faces.push(face);\n        if (geometry.colors) {\n          var numberOfSides = face instanceof THREE.Face3 ? 3 : 4;\n          for (var j = 0; j < numberOfSides; j++) {\n            var vertexIndex = face[faceIndices[j]];\n            face.vertexColors[j] = geometry.colors[vertexIndex];\n          }\n        }\n        if (myData.textureCoord) {\n          var uv1 = myData.textureCoord.data[indexArr[i]];\n          var uv2 = myData.textureCoord.data[indexArr[i + 1]];\n          var uv3 = myData.textureCoord.data[indexArr[i + 2]];\n          geometry.faceVertexUvs[0].push([uv1, uv2, uv3]);\n        }\n      }\n\n      var t3dMat = _buffer2.default.materialBuffer.get(matName);\n\n      if (!t3dMat) {\n        t3dMat = _materialManager2.default.createMaterial('_UNDEFINED_');\n        console.log('没有找到材质');\n      }\n\n      var pass = t3dMat.getTechnique(0).getPass(0);\n      if (myData.colour) {\n        pass.setLighting(false);\n        pass.material.vertexColors = THREE.VertexColors;\n      }\n\n      // var mat = pass.material;\n      geometry.computeFaceNormals();\n      geometry.computeVertexNormals();\n\n      var myEntity = new THREE.Mesh(geometry);\n      myEntity.setMaterial(t3dMat);\n\n      this.name = this.name || _helper2.default.getUUID();\n      _buffer2.default.entityBuffer.add(this.name, myEntity);\n    }\n  }, {\n    key: 'beginVertexesAndIndexsArrayEndArray',\n    value: function beginVertexesAndIndexsArrayEndArray(matName, type, args, indexs, vertextype) {\n      this.beginVertexesAndIndexsStringEndString(matName, type, args, indexs, vertextype);\n    }\n  }, {\n    key: 'beginPositionNormalColourTexCoordListEndString',\n    value: function beginPositionNormalColourTexCoordListEndString(matName, type, data, width, up) {\n      this.type = type;\n      var myData = this._separateData(data, 'position,normal,colour,textureCoord');\n      var geometry;\n      var mat;\n      width = width || 20;\n      up = up || [0, 1, 0];\n      if (matName) {\n        mat = _buffer2.default.materialBuffer.get(matName);\n      }\n      if (type == 'TRIANGLE_STRIP' || type == 'TRIANGLE_LIST' || type == 4) {\n        geometry = new THREE.Geometry();\n        geometry.vertices = myData.position.data;\n        // geometry.colors = myData.colour.data;\n        var length = geometry.vertices.length - 2;\n\n        for (var i = 0; i < length; i++) {\n          var face = new THREE.Face3(i, i + 1, i + 2);\n          geometry.faces.push(face);\n        }\n\n        geometry.computeFaceNormals();\n        geometry.computeVertexNormals();\n\n        // mat.getTechnique(0).getPass(0).material.side = THREE.DoubleSide;\n        var myEntity = new THREE.Mesh(geometry);\n        myEntity.setMaterial(mat);\n        myEntity.toString = function () {\n          return this.name;\n        };\n\n        this.name = this.name || _helper2.default.getUUID();\n        _buffer2.default.entityBuffer.add(this.name, myEntity);\n        this._mesh = myEntity;\n      } else if (type == 'LINE_LIST') {\n        this.name = this.name || _helper2.default.getUUID();\n        var _line = void 0;\n        var positions = myData.buffer.position.data;\n        var uvs = myData.buffer.textureCoord.data;\n        geometry = new THREE.BufferGeometry();\n        geometry.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n        geometry.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));\n        _line = new THREE.LineSegments(geometry);\n        if (!mat) {\n          mat = _materialManager2.default.createMaterial(this.name, 'MeshBasicMaterial');\n        } else {\n          var pass = mat.getTechnique(0).getPass(0);\n          var params = _sourceThreeFunction2.default.copyParams(pass.material);\n          var lineMaterial = _materialFactory2.default.createMaterial('MeshBasicMaterial', params);\n          pass.setMaterial(lineMaterial);\n        }\n        _line.setMaterial(mat);\n        _line.toString = function () {\n          return this.name;\n        };\n        _buffer2.default.entityBuffer.add(this.name, _line);\n        this._mesh = _line;\n      } else if (type == 'LINE_STRIP') {\n        this.name = this.name || _helper2.default.getUUID();\n        var _line2 = void 0;\n        var _positions = myData.buffer.position.data;\n        var _uvs = myData.buffer.textureCoord.data;\n        geometry = new THREE.BufferGeometry();\n        geometry.addAttribute('position', new THREE.Float32BufferAttribute(_positions, 3));\n        geometry.addAttribute('uv', new THREE.Float32BufferAttribute(_uvs, 2));\n        _line2 = new THREE.Line(geometry);\n        if (!mat) {\n          mat = _materialManager2.default.createMaterial(this.name, 'MeshBasicMaterial');\n        } else {\n          var _pass = mat.getTechnique(0).getPass(0);\n          var _params = _sourceThreeFunction2.default.copyParams(_pass.material);\n          var _lineMaterial = _materialFactory2.default.createMaterial('MeshBasicMaterial', _params);\n          _pass.setMaterial(_lineMaterial);\n        }\n        _line2.setMaterial(mat);\n        _line2.toString = function () {\n          return this.name;\n        };\n        _buffer2.default.entityBuffer.add(this.name, _line2);\n        this._mesh = _line2;\n      } else if (type == 'LINE_LOFT') {\n        geometry = new THREE.Geometry();\n        geometry.vertices = myData.position.data;\n        this.name = this.name || _helper2.default.getUUID();\n        var path = this.path = new THREE.CatmullRomCurve3(geometry.vertices);\n        var material = new THREE.MeshBasicMaterial({ color: new THREE.Color(1, 1, 1) });\n        var tubeGeometry = new THREE.TubeBufferGeometry(path, 64, width, 8, false);\n        var line = new THREE.Mesh(tubeGeometry);\n        if (!mat) {\n          mat = _materialManager2.default.createMaterial(this.name, 'MeshBasicMaterial');\n        } else {\n          var _pass2 = mat.getTechnique(0).getPass(0);\n          var _params2 = _sourceThreeFunction2.default.copyParams(_pass2.material);\n          var _lineMaterial2 = _materialFactory2.default.createMaterial('MeshBasicMaterial', _params2);\n          _pass2.setMaterial(_lineMaterial2);\n        }\n        line.setMaterial(mat);\n        line.toString = function () {\n          return this.name;\n        };\n        _buffer2.default.entityBuffer.add(this.name, line);\n        this._mesh = line;\n        this._mesh._path = this.path;\n      } else if (type == 'LINE_PLANE_SPRITE') {\n        geometry = new THREE.Geometry();\n        geometry.vertices = myData.position.data;\n        geometry.textureCoord = myData.textureCoord.data;\n\n        this._geometry = new THREE.Geometry().copy(geometry);\n\n        this.name = this.name || _helper2.default.getUUID();\n        var _line3 = void 0,\n            _lineMaterial3 = void 0,\n            lineObj = void 0;\n        if (!mat) {\n          _line3 = new THREE.Line(geometry);\n          var _material = _materialManager2.default.createMaterial('', 'LineBasicMaterial');\n          _line3.setMaterial(_material);\n          _buffer2.default.entityBuffer.add(this.name, _line3);\n          this._mesh = _line3;\n          return;\n        }\n        var _pass3 = mat.getTechnique(0).getPass(0);\n        if (_pass3.getMaterial().type !== 'MeshLineMaterial') {\n          lineObj = new _MeshLine.MeshLine();\n          lineObj.setGeometry(geometry);\n          _line3 = new THREE.Mesh(lineObj.geometry);\n          var texture = _pass3.getMaterial().map;\n          //texture.anisotropy = 16;\n          _lineMaterial3 = _materialFactory2.default.createMaterial('MeshLineMaterial');\n          _lineMaterial3.uniforms.lineWidth.value = width;\n          _lineMaterial3.uniforms.color.value = _pass3.getMaterial().color;\n          _lineMaterial3.uniforms.opacity.value = _pass3.getMaterial().opacity;\n          if (texture) {\n            _lineMaterial3.uniforms.useMap.value = 1;\n            _lineMaterial3.uniforms.map.value = texture;\n            _lineMaterial3.uniforms.repeat.value = texture.repeat;\n          } else {\n            _lineMaterial3.uniforms.useMap.value = 0;\n          }\n          _lineMaterial3.depthTest = _pass3.getMaterial().depthTest;\n          _lineMaterial3.transparent = _pass3.getMaterial().transparent;\n          _lineMaterial3.blending = _pass3.getMaterial().blending;\n          _lineMaterial3.polygonOffset = _pass3.getMaterial().polygonOffset;\n          _lineMaterial3.polygonOffsetFactor = _pass3.getMaterial().polygonOffsetFactor;\n          _lineMaterial3.polygonOffsetUnits = _pass3.getMaterial().polygonOffsetUnits;\n          _pass3.setMaterial(_lineMaterial3);\n        } else {\n          lineObj = new _MeshLine.MeshLine();\n          lineObj.setGeometry(geometry);\n          _line3 = new THREE.Mesh(lineObj.geometry);\n          var _mat = _pass3.getMaterial();\n          _mat.uniforms.lineWidth.value = width;\n          _mat.uniforms.growPer.value = 1.0;\n        }\n        _line3.setMaterial(mat);\n        _line3.type = 'LINE_PLANE_SPRITE';\n        _line3.toString = function () {\n          return this.name;\n        };\n        _buffer2.default.entityBuffer.add(this.name, _line3);\n        this._mesh = _line3;\n      } else if (type == 'FOG') {\n        this.name = this.name || _helper2.default.getUUID();\n        var _line4 = void 0;\n\n        var _positions2 = [2187245, 2628220, 5383985, 7187245, 2628220, 5383985, 2187245, 7628220, 5383985, 2187245, 7628220, 5383985, 7187245, 2628220, 5383985, 7187245, 7628220, 5383985];\n\n        var _uvs2 = [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1];\n\n        geometry = new THREE.BufferGeometry();\n        geometry.addAttribute('position', new THREE.Float32BufferAttribute(_positions2, 3));\n        geometry.addAttribute('uv', new THREE.Float32BufferAttribute(_uvs2, 2));\n\n        _line4 = new THREE.Mesh(geometry);\n\n        mat = _materialManager2.default.getMaterial('fog');\n\n        _line4.setMaterial(mat);\n        _line4.toString = function () {\n          return this.name;\n        };\n        _buffer2.default.entityBuffer.add(this.name, _line4);\n        this._mesh = _line4;\n      } else if (type == 'LINE_PLANE') {\n        this.name = this.name || _helper2.default.getUUID();\n        var _positions3 = myData.position.data;\n        var path3D = new THREE.Path3D();\n        var _geometry = new THREE.PathGeometry();\n        var pList = path3D.getPathPointList();\n        pList.set(_positions3, 0.0, 0.0, new THREE.Vector3(up[0], up[1], up[2]));\n        _geometry.update(path3D.getPathPointList(), {\n          width: width,\n          arrow: false,\n          uvRatio: 10\n          // uvOffset: params.scrollUV ? scrollingY : 0\n        });\n        var _line5 = new THREE.Mesh(_geometry);\n        _line5.drawMode = THREE.TriangleStripDrawMode;\n        if (!mat) {\n          mat = _materialManager2.default.createMaterial(this.name, 'MeshBasicMaterial');\n        } else {\n          var _pass4 = mat.getTechnique(0).getPass(0);\n          var _params3 = _sourceThreeFunction2.default.copyParams(_pass4.material);\n          var _lineMaterial4 = _materialFactory2.default.createMaterial('MeshBasicMaterial', _params3);\n          _pass4.setMaterial(_lineMaterial4);\n        }\n        _line5.setMaterial(mat);\n        _line5.toString = function () {\n          return this.name;\n        };\n        _buffer2.default.entityBuffer.add(this.name, _line5);\n        this._mesh = _line5;\n      }\n      // scene.add(line);\n    }\n  }, {\n    key: 'stopLineGrow',\n    value: function stopLineGrow() {\n      var that = this;\n\n      var name = this._mesh.uuid;\n      _buffer2.default._renderList.delete(name);\n      that._mesh.t3dMaterial.techniques[0].passes[0].material.uniforms.growPer.value = 1.0;\n    }\n  }, {\n    key: 'playLineGrow',\n    value: function playLineGrow(parm) {\n      if (parm.speed === undefined) {\n        parm.speed = 2;\n      }\n      var that = this;\n      var task = {\n        speed: parm.speed / 200,\n        growLoop: parm.growLoop,\n        per: 0,\n\n        update: function update() {\n\n          this.per += this.speed;\n          if (this.per > 1) {\n            if (this.growLoop == false) {\n              var name = that._mesh.uuid;\n              _buffer2.default._renderList.delete(name);\n              return;\n            }\n            this.per = 0;\n          }\n\n          var per = this.per;\n\n          that._mesh.t3dMaterial.techniques[0].passes[0].material.uniforms.growPer.value = per;\n        }\n      };\n\n      var name = this._mesh.uuid;\n      _buffer2.default._renderList.add(name, task);\n    }\n  }, {\n    key: 'setLineWidth',\n    value: function setLineWidth(width) {\n      if (this.type == 'LINE_LOFT') {\n        _buffer2.default.entityBuffer.get(this.name).geometry = new THREE.TubeBufferGeometry(this.path, 64, width, 8, false);\n      } else if (this.type == 'LINE_PLANE_SPRITE') {\n        var lineWidth = _buffer2.default.entityBuffer.get(this.name).t3dMaterial.getTechnique(0).getPass(0).material.uniforms.lineWidth;\n        lineWidth.value = width;\n      }\n    }\n  }, {\n    key: 'convertToMesh',\n    value: function convertToMesh(name, options) {\n      return _buffer2.default.entityBuffer.get(name);\n    }\n  }, {\n    key: '_separateData',\n    value: function _separateData(data, sign) {\n      var result = { 'buffer': {} },\n          pointer = 0;\n\n      var dataArr = [];\n      if (Array.isArray(data)) {\n        dataArr = data;\n      } else {\n        dataArr = data.split(',');\n      }\n      var signArr = [];\n      if (Array.isArray(sign)) {\n        signArr = sign;\n      } else {\n        signArr = sign.split(',');\n      }\n      //第一次循环找出data中存在的属性以及位置\n      for (var i = 0; i < signArr.length; i++) {\n        var typeName = signArr[i];\n\n        var type = undefined;\n        switch (typeName) {\n          case 'colour':\n            type = 'Color';\n            break;\n          case 'position':\n          case 'normal':\n            type = 'Vector3';\n            break;\n          case 'textureCoord':\n            type = 'Vector2';\n            break;\n        }\n\n        result[typeName] = {\n          pointer: pointer,\n          type: type,\n          data: []\n        };\n\n        result['buffer'][typeName] = {\n          pointer: pointer,\n          data: []\n        };\n        pointer += this.options[typeName];\n      }\n\n      for (var j = 0; j < dataArr.length; j += pointer) {\n        var collection = {};\n        for (var ri in result) {\n          var starI = result[ri].pointer,\n              item;\n          if (ri == 'textureCoord') {\n            item = new THREE[result[ri].type](Number(dataArr[j + starI]), 1.0 - Number(dataArr[j + starI + 1]));\n            result[ri].data.push(item);\n            result.buffer[ri].data.push(Number(dataArr[j + starI]), 1.0 - Number(dataArr[j + starI + 1]));\n          } else if (ri != 'buffer') {\n            item = new THREE[result[ri].type](Number(dataArr[j + starI]), Number(dataArr[j + starI + 1]), Number(dataArr[j + starI + 2]));\n            result[ri].data.push(item);\n            result.buffer[ri].data.push(Number(dataArr[j + starI]), Number(dataArr[j + starI + 1]), Number(dataArr[j + starI + 2]));\n          }\n        }\n      }\n      if (!result.colour) {\n        result.colour = {\n          data: new Array(dataArr.length)\n        };\n        //TODO 这里明显有问题\n        for (var _i = 0; _i < result.colour.data.length; _i++) {\n          result.colour.data[_i] = new THREE.Color();\n        }\n      }\n      return result;\n    }\n  }, {\n    key: '_stringReader',\n    value: function _stringReader(str) {\n      return str.split(',');\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.name;\n    }\n  }, {\n    key: 'setRenderQueueGroup',\n    value: function setRenderQueueGroup() {}\n  }, {\n    key: 'setUseIdentityProjection',\n    value: function setUseIdentityProjection() {}\n  }, {\n    key: 'setUseIdentityView',\n    value: function setUseIdentityView() {}\n  }, {\n    key: 'setQueryFlags',\n    value: function setQueryFlags() {}\n  }, {\n    key: 'setMaterialName',\n    value: function setMaterialName() {}\n  }, {\n    key: 'setSchemeName',\n    value: function setSchemeName() {}\n  }, {\n    key: 'getMaterial',\n    value: function getMaterial() {\n      var object3d = _buffer2.default.entityBuffer.get(this.name);\n      return object3d.getMaterial();\n    }\n  }]);\n\n  return ManualObject;\n}();\n\nexports.default = ManualObject;\n\n//# sourceURL=webpack:///./src/geometry/ManualObject.js?")
        },
        "./src/geometry/SynchroGeometryManager.js": /*!************************************************!*\
  !*** ./src/geometry/SynchroGeometryManager.js ***!
  \************************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _buffer = __webpack_require__(/*! ../util/buffer.js */ \"./src/util/buffer.js\");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _helper = __webpack_require__(/*! ../util/helper.js */ \"./src/util/helper.js\");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nvar _util = __webpack_require__(/*! ../util/util.js */ \"./src/util/util.js\");\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * GeometryManager主要是为了维护异步逻辑,每一个manager可以\r\n * 自动创建一个自己对worker\r\n * TODO 目前还是没有做到可以最大化使用电脑的线程，每次创建只是多启了两个线程而已,依然还有很大的优化空间\r\n * changed by zhgu\r\n * **/\nvar SynchroGeometryManager = function () {\n    function SynchroGeometryManager(name) {\n        _classCallCheck(this, SynchroGeometryManager);\n\n        this.name = name || _helper2.default.getUUID();\n        _buffer2.default.managerBuffer.add(name, this);\n        this.total = 0;\n        this.nums = 1000; //默认对1000个geometry进行一次处理\n        this.curNums = 0; //当前处理了多少个geometry\n        this.mergeNums = 0; //当前merge完的数量\n        this.mergeTotal = 0; //一共需要merge的数量\n        this.geometryArr = []; //当前处理对geometry数据\n        this.mergedGeometry = []; //所有merged完的geometry数量\n        this.data = [];\n        this.idStartNum = 0;\n        this.type = 'SynchroGeometryManager';\n        this.eventManager = new THREE.EventDispatcher();\n    }\n    //设置数据\n\n\n    _createClass(SynchroGeometryManager, [{\n        key: 'addData',\n        value: function addData(data) {\n            this.data.push(data);\n        }\n        //设置计算id的方法\n\n    }, {\n        key: 'setIdStartNum',\n        value: function setIdStartNum(num) {\n            this.idStartNum = num || 0;\n        }\n        //设置自动合并的数量\n\n    }, {\n        key: 'setMergeNums',\n        value: function setMergeNums(nums) {\n            if (nums > 2000) {\n                console.warn('合并数量不能超过2000');\n                nums = 2000;\n            }\n            this.nums = nums;\n        }\n    }, {\n        key: 'on',\n        value: function on(type, callback) {\n            this.eventManager.addEventListener(type, callback);\n        }\n        //使用geometryManager必须使用finish接口，再callback中创建最终的mesh\n\n    }, {\n        key: 'finish',\n        value: function finish(callback, progress, completeCallBack) {\n            //分割数据\n            this.mergeTotal = Math.ceil(this.total / this.nums);\n            var resData = this._processData(this.data, this.mergeTotal);\n            var id = this.idStartNum | 0;\n            for (var i = 0, len0 = resData.length; i < len0; i++) {\n                var curDatas = resData[i];\n                var geometryArr = [];\n                for (var k = 0, len = curDatas.length; k < len; k++) {\n                    id++;\n                    var curData = curDatas[k];\n                    var geometry = _util2.default._createBuilding(curData.positions, curData.holes, curData.height, curData.buildingTextureSize, curData.buildingMaskTextureSize, id);\n                    geometryArr.push(geometry);\n                }\n                var mergedGeometry = _util2.default.mergeBufferGeometry1(geometryArr, 10000000, true)[0];\n                this._processIdBuffer(mergedGeometry);\n                if (callback) {\n                    callback.call(this, mergedGeometry);\n                }\n                this.eventManager.dispatchEvent({ type: 'progress', data: { manager: this, progress: (i + 1) / len0, geometry: mergedGeometry } });\n                if (progress) {\n                    progress.call(this, (i + 1) / len0);\n                }\n                this.mergedGeometry.push(mergedGeometry);\n            }\n            if (completeCallBack) {\n                this.eventManager.dispatchEvent({ type: 'complete', data: { manager: this, geometry: this.mergedGeometry } });\n                completeCallBack.call(this, this);\n            }\n        }\n    }, {\n        key: '_processIdBuffer',\n        value: function _processIdBuffer(geometry) {\n            var idArr = geometry.attributes.id.array;\n            //TODO 目前id都是从小到大进行排列\n            if (idArr.length) {\n                var count = idArr[idArr.length - 1] - idArr[0] + 1;\n                var start = idArr[0];\n                geometry._idBuffer = { start: start, count: count };\n            } else {\n                geometry._idBuffer = { start: 0, count: 0 };\n            }\n        }\n        //\n\n    }, {\n        key: '_processData',\n        value: function _processData(data, nums) {\n            var res = [];\n            var len = data.length;\n            var delt = Math.ceil(len / nums);\n            for (var i = 0; i < nums; i++) {\n                var curData = [];\n                if (i === nums - 1) {\n                    curData = data.slice(i * delt, len);\n                } else {\n                    curData = data.slice(i * delt, (i + 1) * delt);\n                }\n                res.push(curData);\n            }\n            return res;\n        }\n    }]);\n\n    return SynchroGeometryManager;\n}();\n\nexports.default = SynchroGeometryManager;\n\n//# sourceURL=webpack:///./src/geometry/SynchroGeometryManager.js?")
        },
        "./src/geometry/geometry.js": /*!**********************************!*\
  !*** ./src/geometry/geometry.js ***!
  \**********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n\tvalue: true\n});\n\nvar _buffer = __webpack_require__(/*! ../util/buffer.js */ "./src/util/buffer.js");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _cache = __webpack_require__(/*! ../loader/cache.js */ "./src/loader/cache.js");\n\nvar _cache2 = _interopRequireDefault(_cache);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n\tcreateCubeMesh: function createCubeMesh() {\n\t\tvar geometry;\n\t\tif (arguments.length == 4) {\n\t\t\tgeometry = new THREE.BoxGeometry(arguments[1], arguments[2], arguments[3]);\n\t\t\tgeometry.name = arguments[0];\n\t\t} else if (arguments.length == 3) {\n\t\t\tgeometry = new THREE.BoxGeometry(arguments[0], arguments[1], arguments[2]);\n\t\t} else if (arguments.length == 1) {\n\t\t\tgeometry = new THREE.BoxGeometry(arguments[0], arguments[0], arguments[0]);\n\t\t} else if (arguments.length === 0) {\n\t\t\tgeometry = new THREE.BoxGeometry(1, 1, 1);\n\t\t}\n\t\tgeometry.name = geometry.name || geometry.uuid;\n\t\t_cache2.default.add(geometry.name, geometry);\n\t\treturn geometry;\n\t},\n\tcreateCircleMesh: function createCircleMesh(r, seg) {\n\t\tvar geometry;\n\t\tr = r || 1;\n\t\tseg = seg || 8;\n\t\tgeometry = new THREE.CircleGeometry(r, seg);\n\t\tgeometry.name = geometry.name || geometry.uuid;\n\t\t_cache2.default.add(geometry.name, geometry);\n\t\treturn geometry;\n\t},\n\tcreateSphereMesh: function createSphereMesh() {\n\t\tvar geometry;\n\t\tif (arguments.length == 4) {\n\t\t\tgeometry = new THREE.SphereGeometry(arguments[1], arguments[2], arguments[3]);\n\t\t\tgeometry.name = arguments[0];\n\t\t} else if (arguments.length == 3) {\n\t\t\tgeometry = new THREE.SphereGeometry(arguments[0], arguments[1], arguments[2]);\n\t\t} else if (arguments.length == 1) {\n\t\t\tgeometry = new THREE.SphereGeometry(arguments[0], arguments[0], arguments[0]);\n\t\t}\n\t\tgeometry.name = geometry.name || geometry.uuid;\n\t\t_cache2.default.add(geometry.name, geometry);\n\t\treturn geometry;\n\t}\n};\n\n//# sourceURL=webpack:///./src/geometry/geometry.js?')
        },
        "./src/interactive/picking.js": /*!************************************!*\
  !*** ./src/interactive/picking.js ***!
  \************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _buffer = __webpack_require__(/*! ../util/buffer.js */ \"./src/util/buffer.js\");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n  init: function init(scene, camera, width, height) {\n    this.camera = camera;\n    this.scene = scene;\n    this.raycaster = new THREE.Raycaster();\n    // this.raycaster.linePrecision = 0.001;\n    this.raycaster.params.Line.threshold = 0.001;\n    this.width = width;\n    this.height = height;\n\n    this.lastPick = {};\n    this.lastOri = '';\n    this.lastDir = '';\n    this.lastFlag = '';\n    // this.helperInit();\n  },\n  helperInit: function helperInit() {\n    var sphereGeometry = new THREE.SphereGeometry(0.1, 32, 32);\n    var sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });\n\n    this.sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);\n\n    this.scene.add(this.sphere);\n  },\n  pick: function pick(mouse) {\n    var mask = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    if (!isNaN(mouse) && !isNaN(mask)) {\n      return {};\n    }\n    var pickedInfo = {\n      picked: false\n    };\n    var x = mouse[0];\n    var y = mouse[1];\n    var myMouse = new THREE.Vector2();\n    myMouse.x = x / this.width * 2 - 1;\n    myMouse.y = -(y / this.height) * 2 + 1;\n\n    this.camera.updateMatrixWorld();\n    this.raycaster.setFromCamera(myMouse, this.camera);\n    // buffer.eneityBuffer.get(\"\")\n    var intersects = this.raycaster.intersectObject(this.scene.getObjectByName('rootNode'), true);\n    if (intersects.length > 0) {\n      pickedInfo.picked = true;\n      pickedInfo.node = intersects[0].object;\n      pickedInfo.dis = intersects[0].distance;\n      // pickedInfo.norm = [intersects[0].face.normal.x, intersects[0].face.normal.y, intersects[0].face.normal.z];\n      pickedInfo.tri = [];\n\n      // var searchNode = pickedInfo.node;\n      // while (searchNode) {\n      //     if (searchNode.type == \"Scene\") {\n      //         break;\n      //     }\n      //     searchNode = searchNode.parent;\n      // }\n\n      for (var i = 0; i < intersects.length; i++) {\n        if (intersects[i].object.queryFlag & mask && intersects[i].object.pickEnabled == true) {\n          pickedInfo.picked = true;\n          pickedInfo.node = intersects[i].object;\n          pickedInfo.dis = intersects[i].distance;\n          pickedInfo.pos = [intersects[i].point.x, intersects[i].point.y, intersects[i].point.z];\n          if (intersects[i].face) {\n            pickedInfo.norm = [intersects[i].face.normal.x, intersects[i].face.normal.y, intersects[i].face.normal.z];\n          }\n          break;\n        } else {\n          pickedInfo.picked = false;\n        }\n        if (pickedInfo.node.type == 'LineSegments') {\n          pickedInfo.picked = false;\n        }\n      }\n\n      // for (var i = 0; i < intersects.length; i++) {\n      //  console.log(intersects[i].object.queryFlag);\n      //  // intersects[i].object.material.color.set(0x000000);\n\n      // }\n    }\n\n    return pickedInfo;\n  },\n  setQueryTypeMask: function setQueryTypeMask() {\n    // debugger\n  },\n  raycast: function raycast(ori, dir) {\n    var mQueryFlags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n\n    // debugger;\n    // if (this.lastPickBuffer[ori.toString() + dir.toString()]) {\n    //     return this.lastPickBuffer[ori.toString() + dir.toString()];\n    // }\n\n    if (this.lastOri.toString() == ori.toString() && this.lastDir.toString() == dir.toString() && this.lastFlag == mQueryFlags) {\n      // console.log(\"cool\")\n      return this.lastPick;\n    }\n\n    this.lastOri = ori;\n    this.lastDir = dir;\n    this.lastFlag = mQueryFlags;\n\n    var pickedInfo = {};\n    var oriVector = new THREE.Vector3(ori[0], ori[1], ori[2]);\n    var dirVector = new THREE.Vector3(dir[0], dir[1], dir[2]);\n    this.raycaster.set(oriVector, dirVector);\n    var intersects = this.raycaster.intersectObject(this.scene.getObjectByName('rootNode'), true);\n    if (intersects.length > 0) {\n\n      pickedInfo.picked = true;\n      pickedInfo.node = intersects[0].object;\n      pickedInfo.dis = intersects[0].distance;\n      // pickedInfo.norm = [intersects[0].face.normal.x, intersects[0].face.normal.y, intersects[0].face.normal.z];\n      pickedInfo.tri = [];\n\n      if (this.pointData) {\n        this.pointData = intersects[0].point.clone();\n      }\n\n      // if (intersects[0].object.queryFlag & mQueryFlags) {\n      //     pickedInfo.picked = true;\n      // } else {\n      //     pickedInfo.picked = false;\n      // }\n\n\n      for (var i = 0; i < intersects.length; i++) {\n\n        // if (intersects[i].object.parent.name == \"BackgroundNode\") {\n        //     continue;\n        // }\n        //如果不传，默认返回所有\n        if (intersects[i].object.type == 'LineSegments') {\n          pickedInfo.picked = false;\n          pickedInfo.node = null;\n          continue;\n        }\n        if ((intersects[i].object.queryFlag & mQueryFlags || mQueryFlags == undefined) && intersects[i].object.pickEnabled == true) {\n          pickedInfo.picked = true;\n          pickedInfo.node = intersects[i].object;\n          pickedInfo.dis = intersects[i].distance;\n          pickedInfo.pos = [intersects[i].point.x, intersects[i].point.y, intersects[i].point.z];\n          if (intersects[i].face) {\n            pickedInfo.norm = [intersects[i].face.normal.x, intersects[i].face.normal.y, intersects[i].face.normal.z];\n          }\n          break;\n        } else {\n          pickedInfo.picked = false;\n        }\n      }\n\n      // for (var i = 0; i < intersects.length; i++) {\n      //  console.log(intersects[i].object.queryFlag);\n      //  // intersects[i].object.material.color.set(0x000000);\n\n      // }\n    }\n    // this.lastPickBuffer[ori.toString() + dir.toString()] = pickedInfo;\n    this.lastPick = pickedInfo;\n    return pickedInfo;\n  }\n};\n\n//# sourceURL=webpack:///./src/interactive/picking.js?")
        },
        "./src/light/defaultLight.js": /*!***********************************!*\
  !*** ./src/light/defaultLight.js ***!
  \***********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.default = {\n    directionalLight: {\n        color: [0.796079, 0.796079, 0.796079],\n        intensity: 0.0,\n        position: [5000, 5000, 5000],\n        target: [0, 0, 0]\n    },\n    directionalLight1: {\n        color: [0.682353, 0.682353, 0.682353],\n        intensity: 0.0,\n        position: [-5000, 5000, 5000],\n        target: [0, 0, 0]\n    },\n    directionalLight2: {\n        color: [0.662745, 0.662745, 0.662745],\n        intensity: 0.0,\n        position: [-5000, 5000, -5000],\n        target: [0, 0, 0]\n    },\n    directionalLight3: {\n        color: [0.639216, 0.639216, 0.639216],\n        intensity: 0.0,\n        position: [5000, 5000, -5000],\n        target: [0, 0, 0]\n    },\n    ambient: {\n        color: 0xFFFFFF,\n        intensity: 0.4\n    }\n};\n\n//# sourceURL=webpack:///./src/light/defaultLight.js?')
        },
        "./src/light/lightManager.js": /*!***********************************!*\
  !*** ./src/light/lightManager.js ***!
  \***********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _defaultLight = __webpack_require__(/*! ./defaultLight.js */ "./src/light/defaultLight.js");\n\nvar _defaultLight2 = _interopRequireDefault(_defaultLight);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n    //初始化一个环境光，加上三个平行光\n    init: function init(scene) {\n        this.scene = scene;\n        this.ambient = null;\n        this.dirLight = [];\n        this._createLight();\n    },\n    _createLight: function _createLight() {\n        var pos = [0, 0, 0];\n        var ambientLight = _defaultLight2.default.ambient;\n        var directionalLight = _defaultLight2.default.directionalLight;\n        var directionalLight1 = _defaultLight2.default.directionalLight1;\n\n        this.ambient = new THREE.AmbientLight(ambientLight.color, ambientLight.intensity);\n        this.scene.add(this.ambient);\n\n        //平行光1\n        var dLight = new THREE.DirectionalLight(directionalLight.color, directionalLight.intensity);\n        dLight.position.set(directionalLight.position[0], directionalLight.position[1], directionalLight.position[2]);\n        dLight.target.position.set(pos[0], pos[1], pos[2]);\n        this.scene.add(dLight);\n        this.dirLight.push(dLight);\n\n        //平行光2\n        var dLight1 = new THREE.DirectionalLight(directionalLight1.color, directionalLight1.intensity);\n        dLight1.position.set(directionalLight1.position[0], directionalLight1.position[1], directionalLight1.position[2]);\n        dLight1.target.position.set(pos[0], pos[1], pos[2]);\n        this.scene.add(dLight1);\n        this.dirLight.push(dLight1);\n    },\n    getDirectionalLight: function getDirectionalLight() {\n        return this.dirLight;\n    },\n    getAmbientLight: function getAmbientLight() {\n        return this.ambient;\n    }\n}; /**\r\n    * 构造函数\r\n    * @author zhuguang <zhuguang@uinnova.com>\r\n    * @param  {Object} param 参数列表\r\n    *\r\n    */\n\n//# sourceURL=webpack:///./src/light/lightManager.js?')
        },
        "./src/loader/DracoXLoader.js": /*!************************************!*\
  !*** ./src/loader/DracoXLoader.js ***!
  \************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.DracoXLoader = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Version = __webpack_require__(/*! ./Version.js */ \"./src/loader/Version.js\");\n\nvar _GLTFDecoder = __webpack_require__(/*! ./GLTFDecoder.js */ \"./src/loader/GLTFDecoder.js\");\n\nvar _helper = __webpack_require__(/*! ../util/helper.js */ \"./src/util/helper.js\");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * @private\r\n * @class DracoXLoader\r\n * JSON 模型解码数据存放点\r\n */\nvar DracoXLoader = function () {\n    function DracoXLoader(jsonData, out) {\n        _classCallCheck(this, DracoXLoader);\n\n        // 解密方案\n        this._decoder = {};\n        this._nameDecoder = {};\n\n        // 如果提供了输出 json 数据，则不要替换原始数据\n        if (out) {\n            out['data'] = _helper2.default.objectKeysToLowerCase(_helper2.default.clone(jsonData, true));\n            this._init(out['data']);\n        } else {\n            this._init(jsonData);\n        }\n    }\n\n    _createClass(DracoXLoader, [{\n        key: '_initDecoder',\n        value: function _initDecoder(json) {\n            var createtime = json['createtime'];\n            if (!createtime) {\n                return;\n            }\n\n            var date = new Date(createtime);\n            var seconds = date.getSeconds();\n            this._decoder['version'] = Math.floor(seconds / 10);\n\n            var size = json['size'];\n\n            var randomWeight = 1;\n            for (var i = 0; i < size.length; i++) {\n                var sizeString = size[i].toString();\n                if (sizeString.indexOf('.') !== -1) {\n                    randomWeight += Math.toInteger(sizeString.substring(sizeString.length - 1));\n                }\n            }\n            this._decoder['randomWeight'] = randomWeight;\n\n            this._decoder['randomRanges'] = [date.getHours() + 1, date.getDate() + 1, date.getSeconds() % 13 + 1, date.getMinutes() % 13 + 1, randomWeight % 5 * (randomWeight % 5) + 1, json['verts'] % 13 + 1, json['faces'] % 13 + 1, json['nodes'] % 13 + 1];\n        }\n\n        //2.1版本名字解析策略，TODO 后续版本有不同策略\n\n    }, {\n        key: '_decode21_name',\n        value: function _decode21_name(name, codeLength) {\n            var nameTables = ['F7WD3HNR2OPYV6AUS5TKM018ZBJL4EQXIGC9F', 'A0JQM9PSLXF18647URV3DNHOCY52TEZBWIGKA', 'B0IE6Q4S3C7OA28UHTPXDW9NYMGLF1K5VJRZB', 'EQ72MKL3DYNF5RU1PWBT64X9CIZVJHS8G0OAE'];\n\n            // 查找第一位字符所在位置\n            var firstCode = name.charAt(0);\n            var index = nameTables[1].indexOf(firstCode);\n            if (index === -1) {\n                return;\n            }\n\n            index++;\n            index = Math.floor(index / 2) + 1;\n\n            // 删除对应位置的字符\n            // name = name.removeAt(index);\n            name = removeAt(name, index);\n\n            // 获取名字和扩展名数据\n            var extensionName = getExtension(name);\n            name = getFileName(name, false);\n\n            // 开始解码资源名字\n            var _name = '';\n            for (var i = 0; i < name.length; i++) {\n                var c = name[i];\n                var nameTable = nameTables[(i + 1 + codeLength) % 4];\n\n                var _index = nameTable.indexOf(c);\n                if (_index === 0) {\n                    _index = 35;\n                } else {\n                    _index--;\n                }\n\n                _name += nameTable[_index];\n            }\n\n            if (extensionName) {\n                return _name + '.' + extensionName;\n            } else {\n                return _name;\n            }\n        }\n    }, {\n        key: '_initResourceDecoder',\n        value: function _initResourceDecoder(version, json) {\n            var texFiles = json['texfiles'];\n            if (!texFiles) {\n                return;\n            }\n\n            var _version = new _Version.Version(version);\n            var decodeFunc = null;\n            //2.1版本名字解析策略\n            if (_version.major == 2 && _version.minor == 1) {\n                decodeFunc = this._decode21_name;\n            } else {\n                console.error('目前不支持该版本的gltf' + version);\n                return;\n            }\n\n            var texLength = Object.keys(texFiles).length;\n\n            var gltfFiles = json['gltffiles'];\n            if (gltfFiles) {\n                for (var i = 0; i < gltfFiles.length; i++) {\n                    gltfFiles[i] = decodeFunc(gltfFiles[i], texLength);\n                }\n            }\n\n            var lod = json['lod'];\n            if (lod) {\n                var keys = Object.keys(lod);\n                for (var k = 0; k < keys.length; k++) {\n                    var key = keys[k];\n\n                    var newKey = decodeFunc(key, texLength);\n                    lod[newKey] = lod[key];\n                    delete lod[key];\n                }\n            }\n\n            this._nameDecoder['version'] = _version;\n            this._nameDecoder['decodeFunc'] = decodeFunc;\n        }\n    }, {\n        key: '_init',\n        value: function _init(json) {\n            if (!json) {\n                return;\n            }\n\n            var version = json['version'];\n            if (!version) {\n                return;\n            }\n\n            var _version = new _Version.Version(version);\n            if (_version.compare('2.0') <= 0) {\n                return;\n            }\n\n            // 开始解码\n            this._initDecoder(json);\n            this._initResourceDecoder(version, json);\n        }\n    }, {\n        key: 'decode',\n        value: function decode(loader, key, data) {\n            // 获取解码入口\n            var gltf_decoder = new _GLTFDecoder.GLTFDecoder();\n\n            // 缓冲区偏移量和长度解码\n            var decoderVersion = this._decoder['version'];\n            switch (decoderVersion) {\n                case 0:\n                case 3:\n                    var randomWeight = this._decoder['randomWeight'];\n                    this.processCase03(key, data, loader, gltf_decoder, randomWeight);\n                    break;\n\n                case 1:\n                case 4:\n                    var randomRanges = this._decoder['randomRanges'];\n                    this.processCase14(key, data, loader, gltf_decoder, randomRanges);\n                    break;\n\n                case 2:\n                case 5:\n                    this._decoder['randomRanges3'] = [this._decoder['randomRanges'][7], loader.materials.length * 7 % 10];\n                    var lengthString = (loader.buffers[0].byteLength - 999).toString();\n                    for (var i = 0; i < lengthString.length; i++) {\n                        var code = 10 - Math.toInteger(lengthString[i]);\n                        this._decoder['randomRanges3'].push(code);\n                    }\n                    this._decoder['randomRanges3'].push(this._decoder['randomRanges'][3]);\n                    var randomRanges0 = this._decoder['randomRanges3'];\n                    this.processCase25(key, data, loader, gltf_decoder, randomRanges0);\n                    break;\n\n                default:\n                    break;\n            }\n\n            // 名字解码\n            var decodeFunc = this._nameDecoder['decodeFunc'];\n            if (decodeFunc) {\n                if (key == '_buffers' || key == '_images') {\n                    var length = loader.buffers.length + loader.images.length;\n                    for (var k = 0; k < data.length; k++) {\n                        data[k]['uri'] = decodeFunc(data[k]['uri'], length);\n                    }\n                }\n            }\n        }\n\n        // decodeDracoFile (bufferView, resolve, threeAttributeMap) {\n        //\n        // }\n        //03的解析策略\n\n    }, {\n        key: 'processCase03',\n        value: function processCase03(key, data, loader, gltf_decoder, randomWeight) {\n            if (key == '_accessors') {\n                for (var i = 0; i < data.length; i++) {\n                    var accessor = data[i];\n                    var bufferView = loader.bufferViews[accessor['bufferView']];\n                    bufferView['factor'] = Math.floor(bufferView.byteLength / accessor['count']);\n                    bufferView['opFactor'] = accessor['byteType'];\n\n                    accessor['count'] = gltf_decoder.GLTF_decoder_1_count(i, randomWeight, accessor['byteType'], accessor['count']);\n\n                    delete accessor['byteType'];\n                }\n            } else if (key == '_bufferViews') {\n                for (var k = 0; k < data.length; k++) {\n                    var bufferView0 = data[k];\n                    var factor = bufferView0['factor'];\n                    bufferView0['byteOffset'] = gltf_decoder.GLTF_decoder_1_offset(k, randomWeight, factor, bufferView0['byteOffset']);\n                    bufferView0['byteLength'] = gltf_decoder.GLTF_decoder_1_length(k, randomWeight, factor, bufferView0['opFactor'], bufferView0['byteLength']);\n\n                    delete bufferView0['factor'];\n                    delete bufferView0['opFactor'];\n                }\n            }\n        }\n        //14的解析策略\n\n    }, {\n        key: 'processCase14',\n        value: function processCase14(key, data, loader, gltf_decoder, randomRanges) {\n            if (key == '_accessors') {\n                for (var i = 0; i < data.length; i++) {\n                    var accessor = data[i];\n                    var bufferView = loader.bufferViews[accessor['bufferView']];\n                    bufferView['factor'] = Math.floor(bufferView.byteLength / accessor['count']);\n                    bufferView['opFactor'] = accessor['byteType'];\n\n                    var _index = Math.floor(i / 2) % 8;\n                    var randomWeight = randomRanges[_index] + (i + 1) % 7;\n\n                    accessor['count'] = gltf_decoder.GLTF_decoder_1_count(i, randomWeight, accessor['byteType'], accessor['count']);\n\n                    delete accessor['byteType'];\n                }\n            } else if (key == '_bufferViews') {\n                for (var k = 0; k < data.length; k++) {\n                    var bufferView0 = data[k];\n                    var _index0 = Math.floor(k / 2) % 8;\n                    var _rangeValue = randomRanges[_index0] + (k + 1) % 7;\n                    var factor = bufferView0['factor'];\n                    bufferView0['byteOffset'] = gltf_decoder.GLTF_decoder_2_offset(k, _rangeValue, factor, bufferView0['byteOffset']);\n                    bufferView0['byteLength'] = gltf_decoder.GLTF_decoder_2_length(k, _rangeValue, factor, bufferView0['opFactor'], bufferView0['byteLength']);\n\n                    delete bufferView0['factor'];\n                    delete bufferView0['opFactor'];\n                }\n            }\n        }\n    }, {\n        key: 'processCase25',\n        value: function processCase25(key, data, loader, gltf_decoder, randomRanges) {\n            if (key == '_accessors') {\n                for (var i = 0; i < data.length; i++) {\n                    var accessor = data[i];\n                    var bufferView = loader.bufferViews[accessor['bufferView']];\n                    var _index = Math.floor(i / 2) % randomRanges.length;\n                    var randomWeight = randomRanges[_index] + Math.floor(i + 1) % 7;\n\n                    bufferView['factor'] = Math.floor(bufferView.byteLength / accessor['count']);\n                    bufferView['opFactor'] = accessor['byteType'];\n\n                    accessor['count'] = gltf_decoder.GLTF_decoder_1_count(i, randomWeight, accessor['byteType'], accessor['count']);\n\n                    delete accessor['byteType'];\n                }\n            } else if (key == '_bufferViews') {\n                for (var k = 0; k < data.length; k++) {\n                    var bufferView0 = data[k];\n                    var _index0 = Math.floor(k / 2) % randomRanges.length;\n                    var _rangeValue = randomRanges[_index0] + Math.floor(k + 1) % 7;\n                    var factor = bufferView0['factor'];\n                    bufferView0['byteOffset'] = gltf_decoder.GLTF_decoder_3_offset(k, _rangeValue, factor, bufferView0['byteOffset']);\n                    bufferView0['byteLength'] = gltf_decoder.GLTF_decoder_3_length(k, _rangeValue, factor, bufferView0['opFactor'], bufferView0['byteLength']);\n\n                    delete bufferView0['factor'];\n                    delete bufferView0['opFactor'];\n                }\n            }\n        }\n    }]);\n\n    return DracoXLoader;\n}();\n/**\r\n * 数值取整\r\n * @memberof Math\r\n * @param {Number} n 数值\r\n * @return {Number}\r\n */\n\n\nMath.toInteger = function (n) {\n    n = +n;\n    if (n !== n) {\n        // isNaN\n        n = 0;\n    } else if (n !== 0 && n !== 1 / 0 && n !== -(1 / 0)) {\n        n = (n > 0 || -1) * Math.floor(Math.abs(n));\n    }\n    return n;\n};\n// String.prototype.removeAt = function (index) {\n//     let string = this.substring(0);\n//     if (index >= this.length) {\n//         return string;\n//     }\n//\n//     return string.slice(0, index) + string.slice(index + 1);\n// }\n\nfunction removeAt(str, index) {\n    var string = str.substring(0);\n    if (index >= str.length) {\n        return string;\n    }\n\n    return string.slice(0, index) + string.slice(index + 1);\n}\nfunction getExtension(str) {\n    var strings = str.split('.');\n    if (strings.length > 1) {\n        return strings.pop();\n    }\n\n    return '';\n}\nfunction getFileName(str) {\n    var withExtension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    var startIndex = str.indexOf('\\\\') >= 0 ? str.lastIndexOf('\\\\') : str.lastIndexOf('/');\n    if (startIndex === -1) {\n        if (withExtension) {\n            return str;\n        } else {\n            return str.split('.')[0];\n        }\n    } else {\n        var filename = str.substring(startIndex);\n        if (filename.indexOf('\\\\') === 0 || filename.indexOf('/') === 0) {\n            filename = filename.substring(1);\n        }\n\n        if (withExtension) {\n            return filename;\n        } else {\n            return filename.split('.')[0];\n        }\n    }\n}\n\nexports.DracoXLoader = DracoXLoader;\n\n//# sourceURL=webpack:///./src/loader/DracoXLoader.js?")
        },
        "./src/loader/GLTFDecoder.js": /*!***********************************!*\
  !*** ./src/loader/GLTFDecoder.js ***!
  \***********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar GLTFDecoder = function () {\n    function GLTFDecoder() {\n        _classCallCheck(this, GLTFDecoder);\n    }\n\n    _createClass(GLTFDecoder, [{\n        key: "GLTF_decoder_1_count",\n        value: function GLTF_decoder_1_count(index, v, factor, length) {\n            if (index == 0) {\n                return length - v;\n            }\n\n            if (index % 2) {\n                if (factor % 2) {\n                    return length + v;\n                } else {\n                    return length;\n                }\n            } else {\n                return length - v;\n            }\n        }\n    }, {\n        key: "GLTF_decoder_1_offset",\n        value: function GLTF_decoder_1_offset(index, v, factor, offset) {\n            v *= factor;\n\n            if (index == 0) {\n                return offset;\n            }\n\n            if (index % 2) {\n                return offset - v;\n            } else {\n                return offset;\n            }\n        }\n    }, {\n        key: "GLTF_decoder_1_length",\n        value: function GLTF_decoder_1_length(index, v, factor, opFactor, length) {\n            v *= factor;\n\n            if (index == 0) {\n                return length - v;\n            }\n\n            if (index % 2) {\n                if (opFactor % 2) {\n                    return length + v;\n                } else {\n                    return length;\n                }\n            } else {\n                return length - v;\n            }\n        }\n\n        // 第二方案\n\n    }, {\n        key: "GLTF_decoder_2_offset",\n        value: function GLTF_decoder_2_offset(index, v, factor, offset) {\n            v *= factor;\n\n            if (index % 2) {\n                return offset - v;\n            } else {\n                return offset;\n            }\n        }\n    }, {\n        key: "GLTF_decoder_2_length",\n        value: function GLTF_decoder_2_length(index, v, factor, opFactor, length) {\n            v *= factor;\n\n            if (index % 2) {\n                if (opFactor % 2) {\n                    return length + v;\n                } else {\n                    return length;\n                }\n            } else {\n                return length - v;\n            }\n        }\n\n        // 第三方案\n\n    }, {\n        key: "GLTF_decoder_3_offset",\n        value: function GLTF_decoder_3_offset(index, v, factor, offset) {\n            v *= factor;\n\n            if (index % 2) {\n                return offset - v;\n            } else {\n                return offset;\n            }\n        }\n    }, {\n        key: "GLTF_decoder_3_length",\n        value: function GLTF_decoder_3_length(index, v, factor, opFactor, length) {\n            v *= factor;\n\n            if (index % 2) {\n                if (opFactor % 2) {\n                    return length + v;\n                } else {\n                    return length;\n                }\n            } else {\n                return length - v;\n            }\n        }\n    }]);\n\n    return GLTFDecoder;\n}();\n\nexports.GLTFDecoder = GLTFDecoder;\n\n//# sourceURL=webpack:///./src/loader/GLTFDecoder.js?')
        },
        "./src/loader/Loader.js": /*!******************************!*\
  !*** ./src/loader/Loader.js ***!
  \******************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _LoaderClosure = __webpack_require__(/*! ./LoaderClosure.js */ "./src/loader/LoaderClosure.js");\n\nvar _LoaderClosure2 = _interopRequireDefault(_LoaderClosure);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Loader = {\n    init: function init(scene) {\n        _LoaderClosure2.default.setScene(scene);\n        return _LoaderClosure2.default;\n    }\n};\n\nexports.default = Loader;\n\n//# sourceURL=webpack:///./src/loader/Loader.js?')
        },
        "./src/loader/LoaderClosure.js": /*!*************************************!*\
  !*** ./src/loader/LoaderClosure.js ***!
  \*************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; // import '../extra/GLTFLoader.js';\n\n//added to decode the gltf\n\n\nvar _buffer = __webpack_require__(/*! ../util/buffer.js */ \"./src/util/buffer.js\");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _helper = __webpack_require__(/*! ../util/helper.js */ \"./src/util/helper.js\");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nvar _util = __webpack_require__(/*! ../util/util */ \"./src/util/util.js\");\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar _storage = __webpack_require__(/*! ./storage.js */ \"./src/loader/storage.js\");\n\nvar _storage2 = _interopRequireDefault(_storage);\n\nvar _cache = __webpack_require__(/*! ./cache.js */ \"./src/loader/cache.js\");\n\nvar _cache2 = _interopRequireDefault(_cache);\n\nvar _Material = __webpack_require__(/*! ../material/Material.js */ \"./src/material/Material.js\");\n\nvar _Material2 = _interopRequireDefault(_Material);\n\nvar _animationState = __webpack_require__(/*! ../animation/animationState.js */ \"./src/animation/animationState.js\");\n\nvar _animationState2 = _interopRequireDefault(_animationState);\n\nvar _animation = __webpack_require__(/*! ../animation/animation.js */ \"./src/animation/animation.js\");\n\nvar _animation2 = _interopRequireDefault(_animation);\n\nvar _sceneManager = __webpack_require__(/*! ../scene/sceneManager.js */ \"./src/scene/sceneManager.js\");\n\nvar _sceneManager2 = _interopRequireDefault(_sceneManager);\n\nvar _gltfConstant = __webpack_require__(/*! ./gltfConstant.js */ \"./src/loader/gltfConstant.js\");\n\nvar _gltfConstant2 = _interopRequireDefault(_gltfConstant);\n\nvar _textureManager = __webpack_require__(/*! ../material/textureManager.js */ \"./src/material/textureManager.js\");\n\nvar _textureManager2 = _interopRequireDefault(_textureManager);\n\nvar _json2mesh = __webpack_require__(/*! ../extra/json2mesh.js */ \"./src/extra/json2mesh.js\");\n\n__webpack_require__(/*! ../extra/TGALoader.js */ \"./src/extra/TGALoader.js\");\n\nvar _DracoXLoader = __webpack_require__(/*! ./DracoXLoader.js */ \"./src/loader/DracoXLoader.js\");\n\nvar _sourceThreeFunction = __webpack_require__(/*! ../material/sourceThreeFunction.js */ \"./src/material/sourceThreeFunction.js\");\n\nvar _sourceThreeFunction2 = _interopRequireDefault(_sourceThreeFunction);\n\nvar _MaterialAnimationManager = __webpack_require__(/*! ../animation/MaterialAnimationManager.js */ \"./src/animation/MaterialAnimationManager.js\");\n\nvar _MaterialAnimationManager2 = _interopRequireDefault(_MaterialAnimationManager);\n\nvar _ScrollAnimation = __webpack_require__(/*! ../animation/ScrollAnimation */ \"./src/animation/ScrollAnimation.js\");\n\nvar _ScrollAnimation2 = _interopRequireDefault(_ScrollAnimation);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n__webpack_require__(/*! ../extra/cansvg.js */ \"./src/extra/cansvg.js\");\nvar imageCanvas2 = document.createElement('canvas');\n\nvar textureKey = { 'baseColorTexture': 'map', 'emissiveTexture': 'emissiveMap', 'normalTexture': 'normalMap', 'maskTexture': 'alphaMap1' };\n\n// var gltfLoader = new THREE.GLTFLoader();\n//记录递归遍历的值，目前主要为gltfLoader的处理使用\nvar loopMap = [];\nvar _gltfPending = [];\n\nvar scene;\n\nvar LoaderClosure = function LoaderClosure(callback, status) {\n    this.callback = callback;\n    this.status = status;\n    this.path = '';\n\n    this.event = new THREE.EventDispatcher();\n    this.requestSign = 0;\n    this.responseSign = 0;\n\n    this.requestList = {};\n\n    this.huaweiLoader = new _json2mesh.HUAWEILoader();\n    this.huaweiWorldLoader = new _json2mesh.HUAWEIWorldLoader();\n    this.huaweiFloorLoader = new _json2mesh.HUAWEIFloorPlanLoader();\n    this.uBuilderSceneDelayLoader = new _json2mesh.UBuilderSceneDelayLoader();\n\n    // this.event = new THREE.EventDispatcher();\n    // debugger\n};\n\nLoaderClosure.prototype = {\n    resourcePath: '',\n    loadTextureUrl: function loadTextureUrl(name, urlTex, callBack) {\n        this.requestSign += 1;\n        var event = this.event;\n        var loader = new THREE.TextureLoader();\n        loader.load(this.path + urlTex, function (texture) {\n            // texture.name = name;\n            // var mat = buffer.textureUnitStateBuffer.get(name);\n            var id = name || _helper2.default.getUUID();\n            _buffer2.default.textureBuffer.add(id, texture);\n            texture.image.name = name;\n            // mat.setTextureName(id);\n            //解决异步问题\n            event.dispatchEvent({ type: 'done', message: this });\n            // buffer.textureBuffer.add(name, texture);\n            // callback(texture, \"succeed\");\n            if (typeof callBack === 'function') {\n                callBack(texture.image);\n            }\n        }, function (xhr) {\n            //console.log((xhr.loaded / xhr.total * 100) + '% loaded');\n        }, function (xhr) {\n            callBack(false);\n            //callBack(new Error(\"An error happened when load \" + urlTex));\n            //throw new Error(\"An error happened when load \" + urlTex);\n        });\n    },\n    loadHuaweiWorld: function loadHuaweiWorld(localPath, urlGltf) {\n        if (typeof urlGltf == 'string') {\n            this.huaweiWorldLoader.load({\n                url: urlGltf\n            }).then(function (world) {\n                _storage2.default.addFile(localPath, world.buildings);\n            });\n        } else {\n            this.huaweiWorldLoader.load({\n                json: urlGltf\n            }).then(function (world) {\n                _storage2.default.addFile(localPath, world.buildings);\n            });\n        }\n    },\n    loadHuaweiFloor: function loadHuaweiFloor(localPath, urlGltf) {\n        var that = this;\n        if (typeof urlGltf == 'string') {\n            this.huaweiFloorLoader.load({\n                url: urlGltf\n            }).then(function (map) {\n                that._huaweiRoomReader(map, localPath, that);\n            });\n        } else {\n            this.huaweiFloorLoader.load({\n                json: urlGltf\n            }).then(function (map) {\n                that._huaweiRoomReader(map, localPath, that);\n            });\n        }\n    },\n    /**\r\n     * 加载udcb场景\r\n     * @param {String} localPath 存储到local中的路径\r\n     * @param {Object} params 例：{baseUrl:'', json:{}, url:''}\r\n     * @author jw\r\n     * @date 2019-03-21\r\n     */\n    _loadUBuilderResourcesUrl: function _loadUBuilderResourcesUrl(localPath, params) {\n        var _this = this;\n\n        var event = this.event;\n        var param = void 0;\n        if (typeof params === 'string') {\n            param = { url: params };\n        } else {\n            var baseTextureUrl = params.baseTextureUrl,\n                json = params.json,\n                url = params.url;\n\n            if (!baseTextureUrl && !json && !url) {\n                param = { json: params };\n            } else {\n                if (baseTextureUrl) {\n                    // if (!baseUrl.endsWith('/')) {\n                    //   baseUrl += '/';\n                    // }\n                    this.uBuilderSceneDelayLoader.resourceManager.baseTextureUrl = baseTextureUrl;\n                    // this.uBuilderSceneDelayLoader.resourceManager.baseModelUrl = `${baseUrl}model/`;\n                }\n                if (url) {\n                    param = { url: url };\n                } else {\n                    if (json) {\n                        param = { json: json };\n                    } else {\n                        param = { json: params };\n                    }\n                }\n            }\n            this.requestSign += 1;\n        }\n        this.uBuilderSceneDelayLoader.delayLoad(param).then(function (map) {\n            return _this.uBuilderSceneDelayLoader.loadResources();\n        }).then(function (map) {\n            _this.uBuilderSceneMap = map;\n            event.dispatchEvent({ type: 'done', message: _this });\n        }).catch(function (err) {\n            console.error(err);\n            event.dispatchEvent({ type: 'done', message: this });\n        });\n    },\n    _loadHuaweiResourcesUrl: function _loadHuaweiResourcesUrl(localPath, urlGltf, wrap) {\n        var event = this.event;\n        var that = this;\n        if (typeof urlGltf == 'string') {\n            this.huaweiLoader.load({\n                url: urlGltf\n            }).then(function (map) {\n                that._huaweiRoomReader(map, localPath, that);\n                event.dispatchEvent({ type: 'done', message: this });\n            });\n        } else {\n            this.huaweiLoader.load({\n                json: urlGltf\n            }).then(function (map) {\n                that._huaweiRoomReader(map, localPath, that);\n                event.dispatchEvent({ type: 'done', message: this });\n            });\n        }\n    },\n    _huaweiRoomReader: function _huaweiRoomReader(map, localPath, that) {\n        var walls = map.walls;\n        var rooms = map.rooms;\n        for (var i = 0; i < walls.length; i++) {\n            var wall = walls[i];\n            wall.type = 'Scene';\n            wall.name = 'wall@@' + i;\n            that._recursionNode(wall, that._recursionNode);\n            _storage2.default.addFile(localPath + '/' + wall.name, wall);\n            // scene.add(wall);\n        }\n        for (var _i = 0; _i < rooms.length; _i++) {\n            var room = rooms[_i];\n            var floor = room.children[0];\n            floor.type = 'Scene';\n            floor.name = 'floor@@' + _i;\n            that._recursionNode(floor, that._recursionNode);\n            _storage2.default.addFile(localPath + '/' + floor.name, floor);\n\n            var ceiling = room.children[1];\n            ceiling.type = 'Scene';\n            ceiling.name = 'ceiling@@' + _i;\n            that._recursionNode(ceiling, that._recursionNode);\n            _storage2.default.addFile(localPath + '/' + ceiling.name, ceiling);\n            // scene.add(room);\n        }\n    },\n\n    _loadGltfResourcesUrl: function _loadGltfResourcesUrl(gltfLoader, localPath, urlGltf, lod, jsonLod, wrap) {\n\n        var event = this.event;\n        // var _recursionNode = this._recursionNode;\n        var that = this;\n        gltfLoader.load(urlGltf, function (gltf) {\n            //var accessor = gltf.parser.cache.get('accessor');\n            //var gltfcCache = gltf.parser.cache.get('material:0');\n            // Promise.resolve(accessor).then(function (gltfcCache) {\n            //      console.log(gltfcCache);\n            var title = _util2.default.getUrlFileTitle(localPath);\n            var filePath = _util2.default.getFilePath(localPath);\n            gltf.type = 'Scene';\n            gltf.name = title;\n            // buffer.meshBuffer.add(title, gltf.scene);\n            // debugger;\n            var curScene = gltf.scene;\n            curScene.parser = gltf.parser;\n            if (lod) {\n                lod.addLevel(curScene, jsonLod);\n            } else {\n                _storage2.default.addFile(localPath, curScene);\n            }\n            that._recursionNode(curScene, that._recursionNode, '', gltf.parser);\n            //再次处理冗余的node节点\n            var uselessNode = [];\n            curScene.traverse(function (v) {\n                if (v._wireFrameHide && !v.visible) {\n                    uselessNode.push(v);\n                }\n            });\n            uselessNode.map(function (v) {\n                v.parent.remove(v);\n            });\n\n            for (var i in gltf.animations) {\n                var index = filePath + '/' + gltf.animations[i].name + '.animation';\n                if (lod) {\n                    index = filePath + '/' + 'lod' + jsonLod + '@-' + gltf.animations[i].name + '.animation';\n                    gltf.animations[i].name = 'lod' + jsonLod + '@-' + gltf.animations[i].name;\n                }\n                _storage2.default.addFile(index, gltf.animations[i]);\n            }\n            // var b = { type: 'done', message: this };\n            //解决异步问题\n            event.dispatchEvent({ type: 'done', message: this });\n            // callback(gltf.scene);\n\n            // });\n\n        }, function () {}, function (e) {\n            //console.error(e.stack);\n            var error = new Error('An error happened when load ' + urlGltf);\n            error.stack = e;\n            console.error(e);\n            throw error;\n        });\n    },\n    //哇卡卡\n    _recursionNode: function _recursionNode(node, func, prefix, parser, isAddEffect, isAnimation) {\n        //解析node的extensions\n        _handleObject(node);\n        _handleWireFame(node);\n        _handleNodeExtension(node);\n        loopMap = [];\n        //将所有节点添加到buffer里面去\n        if (node.material) {\n            var USE_ALPHAINDEX = false;\n            //为所有导入的mesh加入反射图\n            var envMap = _buffer2.default.textureBuffer.get('_defaultEnvMap');\n            if (envMap && node.isMesh) {\n                node.material.envMap = envMap;\n                node.material.envMapIntensity = _buffer2.default.envMapIntensity;\n            }\n            //调整aoMap的强度\n            node.material.aoMapIntensity = _buffer2.default.aoMapIntensity;\n            //解析gltf扩展,首先把所有材质包装成t3d材质\n            var material = node.material;\n            var data = material.userData;\n            var name = _helper2.default.getUUID();\n            var t3dMaterial = new _Material2.default(name, 'default', false);\n            var pass = t3dMaterial.getTechnique(0).getPass(0);\n            var texture = material.map;\n            //解析effect,由于clone会触发两遍事件计数，因此需要判断\n            if (isAddEffect) {\n                if (node._effect) {\n                    node._effect.map(function (v) {\n                        if (node.setEffectName) {\n                            node.setEffectName(v.name);\n                        }\n                    });\n                }\n            }\n            pass.setMaterial(material);\n            if (texture) {\n                var texUnit = pass.createTextureUnitState(texture);\n            }\n            //处理渐变的alphaIndex，需要shader支持\n            if (node.geometry && node.geometry.attributes && node.geometry.attributes.color) {\n                //console.log(node.geometry.attributes.color);\n                var attributeColor = node.geometry.attributes.color;\n                if (attributeColor.itemSize === 4) {\n                    // node.geometry.addAttribute( 'color1', attributeColor);\n                    // material.defines.USE_COLOR1 = true;\n                    var size = attributeColor.count;\n                    var alphaArr = new Float32Array(size);\n                    for (var num = 0; num < size; num++) {\n                        alphaArr.set([attributeColor.getW(num)], num);\n                    }\n                    //if(_isAlphaArray(alphaArr)){\n                    var attributeAlpha = new THREE.BufferAttribute(alphaArr, 1);\n                    node.geometry.addAttribute('alphaIndex', attributeAlpha);\n                    if (!material.defines) {\n                        material.defines = {};\n                    }\n                    material.defines.USE_ALPHAINDEX = true;\n                    USE_ALPHAINDEX = true;\n                    //既然你想用渐变alpha，材质自动支持透明\n                    // material.transparent = true;\n                    material.needsUpdate = true;\n                    //}\n                }\n            }\n\n            //处理所有extensions参数\n            var id = node.name + '_' + node.uuid;\n            var animationManager;\n            // if(isAnimation){\n            //     if(node.material) {\n            //         animationManager = new AnimationManager(id);\n            //     }\n            // }\n            _parseExtensions(node, node.material, t3dMaterial, parser, envMap, USE_ALPHAINDEX, loopMap, _gltfPending, isAnimation);\n            // if(isAnimation) {\n            //     animationManager.start();\n            // }\n            node.setMaterial(t3dMaterial);\n        }\n        var myName = '';\n        var children = node.children;\n        if (children.length !== 0) {\n            for (var i in children) {\n                func(children[i], func, prefix, parser, isAddEffect, isAnimation);\n                // var myName = node.name;\n            }\n\n            if (prefix) {\n                myName = prefix + node.name;\n                // node.name = prefix + node.name;\n                _buffer2.default.nodeBuffer.add(myName, node);\n                node.name = myName;\n            } else {\n                _buffer2.default.nodeBuffer.add(node.name, node);\n            }\n        } else {\n            // var myName = node.name;\n            if (prefix) {\n                myName = prefix + node.name;\n                node.name = prefix + node.name;\n                _buffer2.default.nodeBuffer.add(myName, node);\n            } else {\n                _buffer2.default.nodeBuffer.add(node.name, node);\n            }\n        }\n        if (node.isMesh) {\n            _buffer2.default.entityBuffer.add(node.name, node);\n        }\n        node.queryFlag = 1;\n    },\n\n\n    _loadImageResourcesUrl: function _loadImageResourcesUrl(localPath, urlImg, success, error) {\n        var loader = new THREE.ImageLoader();\n        var event = this.event;\n        loader.load(urlImg, function (img) {\n            if (!img) {\n                error && error();\n                throw new Error('An error happened when load ' + urlImg);\n            } else {\n                _storage2.default.addFile(localPath, img);\n                event.dispatchEvent({ type: 'done', message: this });\n                success && success();\n            }\n        }, function (xhr) {\n            //console.log((xhr.loaded / xhr.total * 100) + '% loaded');\n        }, function (xhr) {\n            error && error();\n            throw new Error('An error happened when load ' + urlImg);\n        });\n    },\n    _loadTGAResourcesUrl: function _loadTGAResourcesUrl(localPath, urlImg, success, error) {\n        var loader = new THREE.TGALoader();\n        var event = this.event;\n        loader.load(urlImg, function (img) {\n            if (!img) {\n                error && error();\n                throw new Error('An error happened when load ' + urlImg);\n            } else {\n                _storage2.default.addFile(localPath, img);\n                event.dispatchEvent({ type: 'done', message: this });\n                success && success();\n            }\n        }, function (xhr) {\n            //console.log((xhr.loaded / xhr.total * 100) + '% loaded');\n        }, function (xhr) {\n            error && error();\n            throw new Error('An error happened when load ' + urlImg);\n        });\n    },\n    _loadFileResourcesUrl: function _loadFileResourcesUrl(localPath, urlJson) {\n        var loader = new THREE.FileLoader();\n        var event = this.event;\n        loader.load(urlJson, function (text) {\n            _storage2.default.addFile(localPath, text);\n            event.dispatchEvent({ type: 'done', message: this });\n            if (!text) {\n                throw new Error('An error happened when load ' + urlJson);\n            }\n        }, function (xhr) {\n            //console.log((xhr.loaded / xhr.total * 100) + '% loaded');\n        }, function (xhr) {\n            throw new Error('An error happened when load ' + urlJson);\n        });\n    },\n    preparePathUrl: function preparePathUrl(pathName, url, opt_callback, version) {\n        if ((typeof url === 'undefined' ? 'undefined' : _typeof(url)) == 'object') {\n            this.requestList[pathName] = [url];\n        } else {\n            url = version ? url + '#' + version : url;\n            // pathName 这个是要存在本地的name\n            if (this.requestList[pathName]) {\n                this.requestList[pathName].push(url);\n            } else {\n                this.requestList[pathName] = [url];\n            }\n        }\n    },\n    finish: function finish() {\n        //这里的设计比较特别，preparePath记录要请求的，finish才开始请求\n        for (var i in this.requestList) {\n            // var fileName = util.getUrlFileName(url);\n            for (var j in this.requestList[i]) {\n\n                if (_typeof(this.requestList[i][j]) == 'object') {\n                    this._downLoadScene(i, this.requestList[i][j]);\n                } else {\n                    var items = this.requestList[i][j].split('#');\n                    this._downLoadScene(i, items[0], items[1]);\n                    this.requestSign += 1;\n                }\n            }\n        }\n        var doing = this.callback;\n        var status = this.status;\n        var that = this;\n        this.event.addEventListener('done', function (e) {\n            that.responseSign += 1;\n            //TODO SFH 下载进度回调预留\n            // console.log(`now: ${that.responseSign} ,total: ${that.requestSign}`);\n            if (typeof status === 'function') {\n                status({\n                    percent: (that.responseSign / that.requestSign).toFixed(2) * 100\n                }, that);\n            }\n            if (that.requestSign === that.responseSign) {\n                if (typeof doing === 'function') doing(that);\n            }\n        });\n        //如果没有请求直接就进回调\n        if (!i && this.requestSign === 0) {\n            if (typeof doing === 'function') doing(that);\n        }\n        //this.callback(this);\n    },\n    loadResourcePath: function loadResourcePath(pathName, opt_resPrefix, opt_group) {\n        // console.log(\"load资源:\" + pathName);\n        var data = _storage2.default.getFile(pathName);\n        if (data) {\n            data = data.children;\n        }\n        // var cacheGroup = cache[pathName];\n        for (var i in data) {\n            var temName = (opt_resPrefix || '') + i;\n            _cache2.default.add(temName, data[i], pathName);\n            // cacheGroup[temName] = data[i];\n        }\n\n        //这里应该是从scene中找出所有资源\n        //此处因该有一个资源记录的\n        // resource.load(path);\n        // buffer.resourcePath = this.resourcePath = path;\n    },\n    _downLoadScene: function _downLoadScene(pathName, url, version) {\n\n        var that = this;\n        var match = /\\.[^\\\\.]+$/;\n        if (typeof url === 'string') {\n            url = url.replace(/\\\\/g, '/');\n        }\n        // var wrap = storage.addFile(pathName, {});\n        if ((typeof url === 'undefined' ? 'undefined' : _typeof(url)) === 'object' || url.indexOf('.json') > -1) {\n            if (pathName === 'udcb') {\n                that._loadUBuilderResourcesUrl(pathName, url);\n            } else {\n                that._loadHuaweiResourcesUrl(pathName, url);\n            }\n            return;\n        }\n\n        if (url.indexOf('.zip') > -1) {\n            url = url.substr(0, url.lastIndexOf('.')) + '/';\n        } else if (url.substr(-1) === '/') {\n            // console.log('111');\n        } else {\n            url = url + '/';\n        }\n\n        var promise_json = new Promise(function (resolve, reject) {\n            var loader = new THREE.FileLoader();\n            var fileIndex = url + 'index.json' + '?ver=' + version;\n            //TODO 警告警告 如果要恢复index.file，一定要把【that.requestSign--;】去掉，否则会导致不可预料的问题\n            that.requestSign--;\n            loader.load(fileIndex, function (data) {\n                resolve(JSON.parse(data));\n            }, function () {}, function (err) {\n                console.log('down load index.json error,url:' + fileIndex);\n                reject(err);\n            });\n        });\n\n        promise_json.then(function (json) {\n            //added to decode\n            var out = {};\n            var dracoXLoader = new _DracoXLoader.DracoXLoader(json, out);\n            var gltfLoader = new THREE.GLTFLoader();\n            gltfLoader.setDRACOLoader(dracoXLoader);\n            gltfLoader.setCrossOrigin('anonymous'); // loader可以跨域，GLTFLoader的跨域\n            //第一步先解密json数据，找到请求的gltf文件，这个工作对于破解来说简直轻而易举啊，但是这是第一步嘛\n            //第二步bin数据的解密还是应该放在webassembly中进行,这样破解起来将会很麻烦\n            //解密后的json数据\n            json = out['data'];\n            if (json.version === '2.1') {\n                console.log('解密后的json数据，目前用于测试-----------');\n                console.log(json);\n            }\n            var gltfArray = json.gltffiles || json.gltfFiles || [];\n            var jsonArray = json.jsonfiles || json.jsonFiles || [];\n\n            for (var i = 0; i < jsonArray.length; i++) {\n                that.requestSign++;\n                that._downLoadScene(pathName, url + jsonArray[i], version);\n            }\n\n            that.requestSign += gltfArray.length;\n\n            //支持LOD\n            var lod;\n            var jsonLod;\n            if (json.lod) {\n                lod = new THREE.LOD();\n                var nameArr = url.split('/');\n                var lodName = nameArr[nameArr.length - 1] || nameArr[nameArr.length - 2] || nameArr[nameArr.length - 3];\n                lodName += '.lod';\n                if (!_storage2.default.getFile(pathName + '/' + lodName)) {\n                    _storage2.default.addFile(pathName + '/' + lodName, lod);\n                }\n                jsonLod = json.lod;\n            }\n\n            for (var _i2 = 0; _i2 < gltfArray.length; _i2++) {\n                var ext = match.exec(gltfArray[_i2])[0];\n                var path = url + gltfArray[_i2];\n                var name = gltfArray[_i2];\n                /*if (ext === '.gltf') {\r\n                  that._loadGltfResourcesUrl(pathName + '/' + name, path);\r\n                }*/\n                switch (ext) {\n                    case '.json':\n                        that._loadHuaweiResourcesUrl(pathName + '/' + name, path);\n                        break;\n                    /*that._loadHuaweiResourcesUrl(pathName +\" + name, path);\r\n                      break;*/\n                    case '.geojson':\n                        that._loadFileResourcesUrl(pathName + '/' + name, path);\n                        break;\n                    case '.gltf':\n                        if (lod && jsonLod) {\n                            that._loadGltfResourcesUrl(gltfLoader, pathName + '/' + name, path + '?ver=' + version, lod, jsonLod[name.split('.gltf')[0]]);\n                        } else {\n                            that._loadGltfResourcesUrl(gltfLoader, pathName + '/' + name, path + '?ver=' + version);\n                        }\n                        break;\n                    case '.glb':\n                        if (lod && jsonLod) {\n                            that._loadGltfResourcesUrl(gltfLoader, pathName + '/' + name, path + '?ver=' + version, lod, jsonLod[name.split('.gltf')[0]]);\n                        } else {\n                            that._loadGltfResourcesUrl(gltfLoader, pathName + '/' + name, path + '?ver=' + version);\n                        }\n                        break;\n                    case '.jpg':\n                    case '.png':\n                    case '.JPG':\n                    case '.PNG':\n                    case '.svg':\n                        that._loadImageResourcesUrl(pathName + '/' + name, path);\n                        break;\n                    case '.tga':\n                        that._loadTGAResourcesUrl(pathName + '/' + name, path);\n                        break;\n                    case '':\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }, function (error) {});\n    },\n    //TODO: 第三个第四个参数搞不明白\n    loadScenePath: function loadScenePath(path, node, option, prefix) {\n        // debugger\n        //TODO: 多个 scene加载\n        // var scene = storage.getFile(path);\n        //debugger;\n\n        var cacheGroup = _cache2.default.cache[path];\n        for (var i in cacheGroup) {\n            if (i.indexOf('.gltf') >= 1 || i.indexOf('.lod') >= 1 || i.indexOf('.glb') >= 1) {\n                var scene = cacheGroup[i].clone(true);\n                _cloneSkinned(scene, cacheGroup[i]);\n\n                //var scene = cacheGroup[i]\n                // debugger;\n                //将所有节点添加到buffer里面去，uinv是需要这么做的\n                this._recursionNode(scene, this._recursionNode, prefix, cacheGroup[i].parser, true, true);\n                scene.position.copy(new THREE.Vector3(0, 0, 0));\n                //名字这块落实一下\n                // debugger;\n                // var myName = helper.getUUID();\n                // if(scene.name == \"20180103105855491202843_200\"){\n                //   debugger;\n                // }\n                // if (prefix) {\n                //   myName = prefix + scene.name;\n                // }\n                // scene.name = myName;\n                scene.isRoot = true;\n                var scale = new THREE.Vector3(1, 1, 1);\n                scene.scale.copy(scale);\n                scene.toString = function () {\n                    return this.name;\n                };\n                _buffer2.default.entityBuffer.add(scene.name, scene);\n                // console.log(\"load场景:\" + scene.name);\n                node.attachObject(scene);\n\n                //LOD渲染需要依赖摄影机\n                if (i.indexOf('.lod') >= 1) {\n                    var task = {\n                        update: function update() {\n                            scene.update(THREE._t3dCamera);\n                        }\n                    };\n                    //更新lod中其他模型的名字\n                    scene.levels.map(function (v) {\n                        var preName = 'lod' + v.distance + '@-';\n                        v.object.traverse(function (v1) {\n                            v1.name = preName + v1.name;\n                        });\n                    });\n                    var name = _helper2.default.getUUID();\n                    _buffer2.default._renderList.add(name, task);\n                }\n            }\n        }\n\n        //TODO 清除多余的动画\n        var pending = _gltfPending;\n        Promise.all(pending).then(function () {\n            setTimeout(function () {\n                var animationManagers = _buffer2.default._animationManager.getAll();\n                for (var k in animationManagers) {\n                    if (!hasAnimation(animationManagers[k])) {\n                        _buffer2.default._animationManager.delete(k);\n                    } else {\n                        animationManagers[k].start();\n                    }\n                }\n\n                // node.traverse(function (v) {\n                //     if(v.isLineSegments){\n                //         let curMat = v.material;\n                //         v.material = curMat.clone();\n                //         v.material.envMap = null;\n                //         v.material.defines = {};\n                //         v.material.needsUpdate = true;\n                //     }\n                // });\n\n                //处理一下线框把\n            }, 100);\n        });\n        //保证下载好的场景的世界矩阵是正确的,这里带来的后果是下载时候有几帧会比较卡\n        if (THREE.EventCenter !== undefined) {\n            THREE.EventCenter.dispatchEvent({ type: 'immediateChanged', obj: _buffer2.default.sceneBuffer.get('_3DScene') });\n        }\n    },\n    loadResourceFile: function loadResourceFile(name, path, group) {\n\n        var img = _storage2.default.getFile(path);\n        var texture = new THREE.Texture(img);\n        if (texture.image) texture.needsUpdate = true;\n        _buffer2.default.textureBuffer.add(name, texture);\n        return texture;\n    },\n    loadAnimationFile: function loadAnimationFile(path, prefix, lod, _lodNamePre) {\n        var _this2 = this;\n\n        if (lod) {\n            lod.levels.map(function (v) {\n                path = path.replace(/\\\\/g, '/');\n                var path1 = _util2.default.getFilePath(path) + '/' + 'lod' + v.distance + '@-' + _util2.default.getUrlFileName(path);\n                _this2.loadAnimationFile(path1, prefix, null, 'lod' + v.distance + '@-');\n            });\n            return;\n        }\n        // console.log(\"动画加载的路径:\" + path);\n        var myName = (prefix || '') + _util2.default.getUrlFileTitle(path);\n        if (path.indexOf('.animation') == -1) {\n            path += '.animation';\n        }\n        var animate = _storage2.default.getFile(path);\n        var animateJson = THREE.AnimationClip.toJSON(animate);\n        var curNode = scene;\n\n        if (prefix) {\n            var nodeName = prefix.substr(0, prefix.indexOf('_@@_'));\n            curNode = _buffer2.default.nodeBuffer.get(nodeName);\n            for (var i = 0; i < animateJson.tracks.length; i++) {\n                var nodeId = animateJson.tracks[i].name.substr(0, animateJson.tracks[i].name.indexOf('.'));\n                var type = animateJson.tracks[i].name.substr(animateJson.tracks[i].name.indexOf('.'));\n                nodeId = prefix + nodeId;\n                if (_lodNamePre) {\n                    nodeId = _lodNamePre + nodeId;\n                }\n                nodeId = curNode.getObjectByName(nodeId).uuid;\n                animateJson.tracks[i].name = nodeId + type;\n            }\n            animate = THREE.AnimationClip.parse(animateJson);\n            animate.name = myName;\n        } else {\n            if (_lodNamePre) {\n                // var animateJson1 = THREE.AnimationClip.toJSON(animate);\n                for (var _i3 = 0; _i3 < animateJson.tracks.length; _i3++) {\n                    animateJson.tracks[_i3].name = _lodNamePre + animateJson.tracks[_i3].name;\n                }\n                animate = THREE.AnimationClip.parse(animateJson);\n                //animate.name = lod + animate.name;\n            }\n        }\n\n        var am = _sceneManager2.default.createAnimation(animate.name, animate.duration);\n        am.createNodeTrackList(animate, false);\n        var as = _sceneManager2.default.createAnimationState(animate.name);\n        as.setEnabled(true);\n        // animate.zeroSlopeAtEnd = false;\n    },\n    setFinishedCB: function setFinishedCB(func) {},\n    setProgressCB: function setProgressCB() {},\n    getFile: function getFile(pathName) {\n        // console.log(\"load资源:\" + pathName);\n        var result = {};\n        var data = _storage2.default.getFile(pathName);\n        if (data) {\n            data = data.children;\n        }\n        // var cacheGroup = cache[pathName];\n        for (var i in data) {\n            // var temName = (opt_resPrefix || \"\") + i;\n            result[data[i].name] = data[i];\n            // cacheGroup[temName] = data[i];\n        }\n        return result;\n    },\n    addToEntity: function addToEntity(name, obj) {\n        _buffer2.default.entityBuffer.add(name, obj);\n    }\n};\nfunction getLineMat(material) {\n    var lineMat = new THREE.MeshBasicMaterial();\n    lineMat.color = material.color;\n    lineMat.map = material.map;\n    lineMat.transparent = material.transparent;\n    lineMat.depthWrite = material.depthWrite;\n    return lineMat;\n}\nfunction _handleWireFame(node) {\n    if (!node.userData) return;\n    var nodeUserData = node.userData.gltfExtensions;\n    if (!nodeUserData) return;\n    var line;\n    var geometry;\n    //使用wireFrame\n    if (nodeUserData.wireframe) {\n        if (nodeUserData.wireframe.type == 2) {\n            var verts = nodeUserData.wireframe.wireframeVerts;\n            geometry = new THREE.BufferGeometry();\n            var position = [];\n            var uv = [];\n            var normal = [];\n            for (var i = 0, len = verts.length; i < len; i++) {\n                verts[i].pos1 = parseArr(verts[i].pos1);\n                verts[i].pos2 = parseArr(verts[i].pos2);\n                verts[i].uv1 = parseArr(verts[i].uv1);\n                verts[i].uv2 = parseArr(verts[i].uv2);\n                position.push(verts[i].pos1[0]);\n                position.push(verts[i].pos1[1]);\n                position.push(verts[i].pos1[2]);\n                position.push(verts[i].pos2[0]);\n                position.push(verts[i].pos2[1]);\n                position.push(verts[i].pos2[2]);\n                //法线\n                normal.push(0);\n                normal.push(0);\n                normal.push(1);\n                normal.push(0);\n                normal.push(0);\n                normal.push(1);\n                uv.push(verts[i].uv1[0]);\n                uv.push(verts[i].uv1[1]);\n                uv.push(verts[i].uv2[0]);\n                uv.push(verts[i].uv2[1]);\n            }\n            geometry.addAttribute('position', new THREE.Float32BufferAttribute(position, 3));\n            geometry.addAttribute('normal', new THREE.Float32BufferAttribute(normal, 3));\n            geometry.addAttribute('uv', new THREE.Float32BufferAttribute(uv, 2));\n            if (node.material) {\n\n                line = new THREE.LineSegments(geometry, getLineMat(node.material));\n                line.name = node.name;\n                node.parent.add(line);\n                //node.parent.remove(node);\n            } else {\n                //如果是空node\n                var mat = node.children[0].material;\n                line = new THREE.LineSegments(geometry, getLineMat(mat));\n                line.name = node.name;\n                node.parent.add(line);\n                //node.parent.remove(node);\n            }\n            line.userData = _helper2.default.clone(node.userData, true);\n            line.userData.gltfExtensions.wireframe = null;\n            node.userData = {};\n            node.show(false);\n            node._wireFrameHide = true;\n            //node.parent.remove(node);\n        } else if (nodeUserData.wireframe.type == 3) {\n            var threshold = nodeUserData.wireframe.wireframeThreshold || 1;\n            threshold = parseFloat(threshold);\n            if (node.material) {\n                geometry = new THREE.EdgesGeometry(node.geometry, threshold);\n                _processWireFrameGeometry(geometry);\n                line = new THREE.LineSegments(geometry, getLineMat(node.material));\n                copyNodeMatrix(node, line);\n                line.name = node.name;\n                line.userData = _helper2.default.clone(node.userData, true);\n                line.userData.gltfExtensions.wireframe = null;\n                node.userData = {};\n                node.parent.add(line);\n                node.show(false);\n                node._wireFrameHide = true;\n                //node.parent.remove(node);\n            } else {\n                node.children.map(function (v) {\n                    if (v.material) {\n                        geometry = new THREE.EdgesGeometry(v.geometry, threshold);\n                        _processWireFrameGeometry(geometry);\n                        line = new THREE.LineSegments(geometry, getLineMat(v.material));\n                        copyNodeMatrix(v, line);\n                        line.name = v.name;\n                        v.parent.add(line);\n                        v.show(false);\n                        v._wireFrameHide = true;\n                        //v.parent.remove(v);\n                    }\n                });\n                node.userData.gltfExtensions.wireframe = null;\n            }\n        } else {\n            console.warn('wireFrame:type:' + nodeUserData.wireframe.type + '暂不支持');\n        }\n    }\n    return line;\n}\n\nfunction _processWireFrameGeometry(geometry) {\n    var pos = geometry.attributes.position.array;\n    var len = pos.length / 3;\n    var uv = new Float32Array(len * 2);\n    var normal = new Float32Array(len * 3);\n    for (var i = 0; i < len; i++) {\n        uv[2 * i] = 0;\n        uv[2 * i + 1] = 0;\n        normal[3 * i] = 0;\n        normal[3 * i + 1] = 0;\n        normal[3 * i + 2] = 1;\n    }\n    geometry.addAttribute('uv', new THREE.BufferAttribute(uv, 2));\n    geometry.addAttribute('normal', new THREE.BufferAttribute(normal, 3));\n}\n\nfunction copyNodeMatrix(source, res) {\n    source.updateMatrix();\n    res.applyMatrix(source.matrix);\n}\n\nfunction parseArr(data) {\n    if (data instanceof Array) {\n        return data;\n    } else {\n        return JSON.parse(data);\n    }\n}\n\nfunction _handleObject(node) {\n    var nodeUserData = node.userData.gltfExtensions;\n    if (nodeUserData) {\n        //billboard和wireframe模式下不能产生阴影\n        if (nodeUserData.billboard) {\n            if (nodeUserData.billboard.type === 'axis') {\n                //树\n                node.followCameraFixY();\n            } else if (nodeUserData.billboard.type === 'point') {\n                //精灵\n                if (nodeUserData.billboard.axis) {\n                    node.lookAtCamera(nodeUserData.billboard.axis);\n                }\n            }\n        }\n    }\n}\n\nfunction _handleNodeExtension(node) {\n    var nodeUserData = node.userData.gltfExtensions;\n    var cloneFlag = false;\n    //阴影 默认开启\n    if (node.material) {\n        node.castShadow = true;\n        node.receiveShadow = true;\n    }\n    if (nodeUserData) {\n        //阴影\n        if (nodeUserData.castShadows == 'false') {\n            if (node.material) {\n                node.castShadow = false;\n            } else {\n                node.children.map(function (v) {\n                    v.castShadow = false;\n                });\n            }\n            cloneFlag = true;\n        }\n        if (nodeUserData.receiveShadows == 'false') {\n            if (node.material) {\n                node.receiveShadow = false;\n            } else {\n                node.children.map(function (v) {\n                    v.receiveShadow = false;\n                });\n            }\n            cloneFlag = true;\n        }\n        if (cloneFlag) {\n            if (node.material) {\n                node.material = node.material.clone();\n            } else {\n                node.children.map(function (v) {\n                    v.material = v.material.clone();\n                });\n            }\n        }\n\n        //后处理\n        if (nodeUserData.effects) {\n            var effect = nodeUserData.effects;\n            //处理skip逻辑\n            //处理scheme逻辑\n            for (var k in effect) {\n                _processSkipEffectNode(node, k);\n            }\n\n            //处理scheme逻辑\n\n            var _loop = function _loop(_k) {\n                var effectName = _processEffectData(_k);\n                if (effectName) {\n                    if (node.material) {\n                        node.setEffectName(effectName);\n                    } else {\n                        node.children.map(function (v) {\n                            v.setEffectName(effectName);\n                        });\n                    }\n                }\n            };\n\n            for (var _k in effect) {\n                _loop(_k);\n            }\n        }\n\n        //如果设置了renderOrder\n        if (nodeUserData.renderOrder) {\n            if (node.material) {\n                node.renderOrder = parseInt(nodeUserData.renderOrder);\n            } else {\n                node.children.map(function (v) {\n                    v.renderOrder = parseInt(nodeUserData.renderOrder);\n                });\n            }\n        }\n    }\n}\nfunction _processSkipEffectNode(node, k) {\n    var res = _processSkipEffectData(k);\n    if (!res) return;\n    if (node.material) {\n        if (!node.technique) {\n            node.technique = {};\n        }\n        node.technique[res] = 'skip';\n    } else {\n        node.children.map(function (v) {\n            if (!v.technique) {\n                v.technique = {};\n            }\n            v.technique[res] = 'skip';\n        });\n    }\n}\n\nfunction _processSkipEffectData(k) {\n    var res = '';\n    if (k == 'skipGlow') {\n        res = 'glow';\n    } else if (k == 'skipInnerGlow') {\n        res = 'innerGlow';\n    }\n    return res;\n}\nfunction _processEffectData(k) {\n    var res = '';\n    if (k == 'bloom' || k == 'glow') {\n        res = 'glow';\n    } else if (k == 'outLine') {\n        res = 'outline';\n    } else if (k == 'glowInset' || k == 'innerGlow') {\n        res = 'innerGlow';\n    }\n    return res;\n}\n\n/**\r\n *@description  解析材质blend参数\r\n *@author zhuguang <zhuguang@uinnova.com>\r\n *@param {Object} param参数列表\r\n *@param {String}\r\n *@date 2018/11/08 14:00:48\r\n */\nfunction _parseScenenBlend(material) {\n    var data = material.userData;\n    if (!data) return;\n    var gltfData = data.gltfExtensions;\n    if (!gltfData) return;\n    if (gltfData.sceneBlend) {\n        material.blending = THREE[gltfData.sceneBlend + 'Blending'] === undefined ? 1 : THREE[gltfData.sceneBlend + 'Blending'];\n        material.transparent = true;\n        material.needsUpdate = true;\n    }\n    if (gltfData.depthWrite) {\n        if (gltfData.depthWrite === 'false') {\n            material.depthWrite = false;\n        } else if (gltfData.depthWrite === 'true') {\n            material.depthWrite = true;\n        }\n    }\n}\n\n/**\r\n *@description 解析材质扩展\r\n *@author zhuguang <zhuguang@uinnova.com>\r\n *@param {Object} param参数列表\r\n *@param {String}\r\n *@date 2018/11/08 14:01:22\r\n */\nfunction _parseExtensions(node, material, t3dMaterial, parser, envMap, USE_ALPHAINDEX, loopMap, pending, isAnimation) {\n    var data = material.userData;\n    if (!data) return;\n    var gltfData = data.gltfExtensions;\n    if (!gltfData) return;\n    //如果是线框渲染模式，直接渲染线框就行了\n    if (gltfData.wireframe) {\n        material.wireframe = true;\n        material.depthWrite = false;\n        //return;\n    }\n    _parseUv2(node, material);\n    _parseScenenBlend(material);\n    _textureAnisotropy(material);\n    _parseAnimation(material, isAnimation, parser, pending);\n\n    //混合操作，这里可能比较复杂, 必须传入材质解析器才能进行blend混合\n    if (gltfData.blend && parser) {\n        //先创建好t3dMaterial的pass,为了不影响体验将opacity设置为0\n        gltfData.blend.map(function (v0) {\n            var _p = t3dMaterial.getTechnique(0).createPass();\n            _p.material.transparent = true;\n            _p.material.opacity = 0.0;\n        });\n        gltfData.blend.map(function (v, k) {\n            //如果不在loopMap中\n            if (loopMap.indexOf(v.subMaterial) === -1) {\n                pending.push(new Promise(function (resolve) {\n                    parser.getDependency('material', v.subMaterial).then(function (subMat) {\n                        loopMap.push(v.subMaterial);\n                        //混合材质默认认为材质类型是透明\n                        subMat.transparent = true;\n                        //多材质depthWrite为false\n                        subMat.depthWrite = false;\n                        //处理subMat基本参数\n                        subMat.aoMapIntensity = _buffer2.default.aoMapIntensity;\n                        if (envMap) {\n                            subMat.envMap = envMap;\n                            subMat.envMapIntensity = _buffer2.default.envMapIntensity;\n                        }\n                        var texCoord = v.texCoord;\n                        var diffuseUv = void 0;\n                        //TODO 使用diffuseUv存在一个小问题是多个混合材质依然很难解决\n                        // if(texCoord === 1){\n                        //     subMat.defines.USE_DIFFUSE_UV = true;\n                        //     diffuseUv = node.geometry.attributes.uv2;\n                        //     node.geometry.addAttribute('diffuseUv', diffuseUv);\n                        //     subMat.needsUpdate = true;\n                        //\n                        // }else if(texCoord === 2){\n                        //     subMat.defines.USE_DIFFUSE_UV = true;\n                        //     diffuseUv = node.geometry.attributes.uv3;\n                        //     node.geometry.addAttribute('diffuseUv', diffuseUv);\n                        //     subMat.needsUpdate = true;\n                        // }\n                        parser.getDependency('texture', v.maskTexture.index).then(function (maskMap0) {\n                            var maskMap = maskMap0.clone();\n                            maskMap.needsUpdate = true;\n                            if (subMat.map) subMat.map.needsUpdate = true;\n                            if (maskMap) maskMap.needsUpdate = true;\n                            //处理uv3\n                            var texCoord;\n                            if (v.maskTexture.texCoord === 0 || v.maskTexture.texCoord === undefined) {\n                                texCoord = node.geometry.attributes.uv;\n                            } else if (v.maskTexture.texCoord === 1) {\n                                texCoord = node.geometry.attributes.uv2;\n                            } else if (v.maskTexture.texCoord === 2) {\n                                texCoord = node.geometry.attributes.uv3;\n                            }\n                            var pass1 = t3dMaterial.getTechnique(0).getPass(k + 1);\n                            pass1.setMaterial(subMat);\n                            if (texCoord) pass1.setTexCoord3(texCoord);\n                            pass1.setMaskMap(maskMap);\n\n                            if (USE_ALPHAINDEX) {\n                                if (!pass1.material.defines) {\n                                    pass1.material.defines = {};\n                                }\n                                pass1.material.defines.USE_ALPHAINDEX = true;\n                                pass1.material.needsUpdate = true;\n                            }\n                            //pass1.material.needsUpdate=true;\n                            //继续解析sceneBlend\n                            // _parseScenenBlend(subMat);\n                            // //需要再次解析subMaterial的材质动画\n                            // _parseAnimation(subMat);\n\n                            //单独解析maskTexture动画\n                            if (v.maskTexture.extensions) {\n                                var extensions = v.maskTexture.extensions;\n                                if (isAnimation) {\n                                    var materialAnimationManager = pass1.material._materialAnimationManager;\n                                    if (!materialAnimationManager) {\n                                        materialAnimationManager = pass1.material._materialAnimationManager = new _MaterialAnimationManager2.default(pass1.material.name + '_' + pass1.material.uuid);\n                                    }\n                                    var task, animationManager;\n                                    if (extensions.textureExtensions) {\n                                        var newData = extensions.textureExtensions[0].extensions;\n                                        for (var kk1 in newData) {\n                                            task = _textureManager2.default.setAnimation('maskTexture', pass1.material, kk1, newData[kk1]);\n                                            //materialAnimationManager.add(task, 'maskTexture');\n                                            animationManager = materialAnimationManager.get(textureKey['maskTexture']);\n                                            animationManager.add(task);\n                                        }\n                                    } else {\n                                        for (var kk in extensions) {\n                                            task = _textureManager2.default.setAnimation('maskTexture', pass1.material, kk, extensions[kk]);\n                                            //materialAnimationManager.add(task, 'maskTexture');\n                                            animationManager = materialAnimationManager.get(textureKey['maskTexture']);\n                                            animationManager.add(task);\n                                        }\n                                    }\n                                }\n                            }\n                            resolve('success');\n                            //TODO 继续解析subMat中的blend\n                            _parseExtensions(node, subMat, t3dMaterial, parser, envMap, USE_ALPHAINDEX, loopMap, pending, isAnimation);\n                        });\n                    });\n                }));\n            } else {\n                console.error('材质' + v.subMaterial + '扩展存在死循环!!!');\n            }\n        });\n    }\n}\n\nfunction _textureAnisotropy(material) {\n    //默认使用clamp模式\n    if (material.map) {\n        material.map.anisotropy = 16;\n        material.map.needsUpdate = true;\n        //material.map.wrapS = material.map.wrapT = THREE.ClampToEdgeWrapping;\n        //material.map.center.set(0.5,0.5);\n    }\n}\n\nfunction _parseUv2(node, material) {\n    // var material = node.material;\n    var data = material.userData;\n    if (!data) return;\n    var gltfData = data.gltfExtensions;\n    if (!gltfData) return;\n    if (gltfData['useDiffuseUV']) {\n        if (material.map) {\n            material.defines.USE_DIFFUSE_UV = true;\n            var texCoord;\n            if (gltfData['useDiffuseUV'] === 1) {\n                texCoord = node.geometry.attributes.uv2;\n            } else if (gltfData['useDiffuseUV'] === 2) {\n                texCoord = node.geometry.attributes.uv3;\n            }\n            node.geometry.addAttribute('diffuseUv', texCoord);\n            material.needsUpdate = true;\n        }\n    }\n}\n\nfunction _parseAnimation(material, isAnimation, parser, newPending) {\n    if (!isAnimation) return;\n    //解析动画\n    var materialAnimationManager = material._materialAnimationManager;\n    if (!materialAnimationManager) {\n        materialAnimationManager = material._materialAnimationManager = new _MaterialAnimationManager2.default(material.name + '_' + material.uuid);\n    }\n    var data = material.userData;\n    if (!data) return;\n    var gltfData = material.userData.gltfExtensions;\n    if (!gltfData) return;\n    //return new Promise(function (resolve, reject) {\n    for (var kk in gltfData) {\n        if (gltfData[kk]) {\n            var curData = gltfData[kk];\n            if (curData.textureExtensions) {\n                //如果是新格式\n                if (textureKey[kk]) {\n                    var texture = material[textureKey[kk]];\n                    _parseTexture(curData.textureExtensions[0].extensions, texture);\n                    material.userData.gltfExtensions[kk] = {};\n                }\n                _parseTextureAnimation(curData.textureExtensions[0].extensions, material, kk, materialAnimationManager);\n                var pending = [];\n                if (curData.textureExtensions) {\n                    var subTexture = curData.textureExtensions;\n                    for (var i = 0; i < subTexture.length; i++) {\n                        var tex = subTexture[i];\n                        pending.push(parser.getDependency('texture', tex.index));\n                    }\n                    newPending.push(new Promise(function (resolve) {\n                        Promise.all(pending).then(function (texArr) {\n                            for (var k = 1; k < texArr.length; k++) {\n                                texArr[k] = texArr[k].clone();\n                                texArr[k].needsUpdate = true;\n                                if (!subTexture[k].extensions) {\n                                    //这里需要特殊处理，直接换图\n                                    var task = new _ScrollAnimation2.default(material, texArr[k], [0, 0]);\n                                    task.changeTexture(textureKey[kk], texArr[k]);\n                                    task.pause = true;\n                                    var animationManager = materialAnimationManager.get(textureKey[kk]);\n                                    animationManager.add(task);\n                                } else {\n                                    _parseTexture(subTexture[k].extensions, texArr[k]);\n                                    _parseTextureAnimation(subTexture[k].extensions, material, kk, materialAnimationManager, texArr[k]);\n                                }\n                            }\n                            resolve('success');\n                        });\n                    }));\n                }\n            } //如果是旧格式\n            else {\n                    _parseTextureAnimation(curData, material, kk, materialAnimationManager);\n                }\n        }\n    }\n    //});\n}\n\nfunction _parseTexture(curData, texture) {\n    if (!curData) return;\n    if (curData.repeat) {\n        texture.repeat.set(curData.repeat[0], curData.repeat[1]);\n    }\n    if (curData.wrapMode && curData.wrapMode == 2) {\n        texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;\n        texture.needsUpdate = true;\n        // texture.center.set(0.5,0.5);\n    }\n}\n\nfunction _parseTextureAnimation(gltfData, material, texName, materialAnimationManager, tex) {\n    for (var ks in gltfData) {\n        // texUnit.setAnimation(ks, animationData[ks]);\n        if (ks.indexOf('Anim') !== -1) {\n            var task = _textureManager2.default.setAnimation(texName, material, ks, gltfData[ks], tex);\n            if (task) {\n                var animationManager = materialAnimationManager.get(textureKey[texName]);\n                animationManager.add(task, tex);\n            } else {\n                console.warn(ks + '动画暂不支持!');\n            }\n        }\n    }\n}\n\n// 因为目前 THREEJS 的 SkinnedMesh 有 BUG 所以这里需要特殊处理\n// 1. 获取对应的 SkinnedMesh.\n// 2. 根据 mesh 中的 skeleton bones 获取对应克隆体的 bones 序列.\n// 3. 根据新的bones和原来的bones逆矩阵创建新的skeleton.\n// 4. 重新绑定到克隆体 SkinnedMesh 中.\nfunction _cloneSkinned(clonedNode, source) {\n    if (clonedNode.hasSkinnedMesh()) {\n        // 获取数据源\n        var fromSkinnedMeshes = source.getSkinnedMeshes();\n        for (var i = 0; i < fromSkinnedMeshes.length; i++) {\n            var fromSkinnedMesh = fromSkinnedMeshes[i];\n            var fromSkeleton = fromSkinnedMeshes[i].skeleton;\n            // 获取克隆体的bones信息\n            var bones = clonedNode.getBones(source, fromSkinnedMeshes[i].skeleton);\n            // 获取克隆后的SkinnedMesh\n            var skinnedMeshes = clonedNode.getSkinnedMeshes();\n            var skinnedMesh = skinnedMeshes[i];\n            // 创建骨骼并且重新绑定到SkinnedMesh中\n            var skeleton = new THREE.Skeleton(bones, fromSkeleton.boneInverses);\n            skinnedMesh.bind(skeleton, fromSkinnedMesh.bindMatrix);\n        }\n    }\n}\n\nfunction hasAnimation(animationManager) {\n    if (!animationManager._textureAnimation) {\n        return false;\n    }\n    var textureAnimation = animationManager._textureAnimation;\n    for (var k in textureAnimation) {\n        var texAnim = textureAnimation[k];\n        if (texAnim) {\n            if (texAnim._textureAnimation && texAnim._textureAnimation.length > 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nfunction _isAlphaArray(arr) {\n    for (var i = 0; i < arr.length; i++) {\n        if (arr[i] != 1) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// function _decodeGltf (loader, jsonData){\n// }\nLoaderClosure.setScene = function (_scene) {\n    scene = _scene;\n};\n\nexports.default = LoaderClosure;\n\n//# sourceURL=webpack:///./src/loader/LoaderClosure.js?")
        },
        "./src/loader/ResourceGroupName.js": /*!*****************************************!*\
  !*** ./src/loader/ResourceGroupName.js ***!
  \*****************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = {\n    /** the 'General' group */\n    DEFAULT: 'General',\n    /** the 'Internal' group */\n    INTERNAL: 'Internal',\n    /** the 'Autodetect' group */\n    AUTODETECT: 'Autodetect'\n};\n\n//# sourceURL=webpack:///./src/loader/ResourceGroupName.js?")
        },
        "./src/loader/Version.js": /*!*******************************!*\
  !*** ./src/loader/Version.js ***!
  \*******************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * @class Version\r\n * 标记封装类\r\n * @author WJH 2018.09.12\r\n * @memberof THING\r\n */\nvar Version = function () {\n    function Version(version) {\n        _classCallCheck(this, Version);\n\n        this._major = 0;\n        this._minor = 0;\n        this._modified = 0;\n\n        var strings = version.split('.');\n        this._major = parseInt(strings.length >= 1 ? strings[0] : 0);\n        this._minor = parseInt(strings.length >= 2 ? strings[1] : 0);\n        this._modified = parseInt(strings.length >= 3 ? strings[2] : 0);\n    }\n\n    _createClass(Version, [{\n        key: 'compare',\n        value: function compare(version) {\n            if (typeof version === 'string') {\n                version = new Version(version);\n            }\n\n            if (this._major != version._major) {\n                return this._major > version._major ? 1 : -1;\n            }\n\n            if (this._minor != version._minor) {\n                return this._minor > version._minor ? 1 : -1;\n            }\n\n            if (this._modified != version._modified) {\n                return this._modified > version._modified ? 1 : -1;\n            }\n\n            return 0;\n        }\n    }, {\n        key: 'major',\n        get: function get() {\n            return this._major;\n        }\n    }, {\n        key: 'minor',\n        get: function get() {\n            return this._minor;\n        }\n    }, {\n        key: 'modified',\n        get: function get() {\n            return this._modified;\n        }\n    }]);\n\n    return Version;\n}();\n\nexports.Version = Version;\n\n//# sourceURL=webpack:///./src/loader/Version.js?")
        },
        "./src/loader/cache.js": /*!*****************************!*\
  !*** ./src/loader/cache.js ***!
  \*****************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.default = {\n    cache: {},\n    get: function get(name) {\n        return this.cache[name];\n    },\n    add: function add(name, data, groupName) {\n        if (groupName) {\n            if (this.cache[groupName]) {\n                this.cache[groupName][name] = data;\n            } else {\n                this.cache[groupName] = {};\n                this.cache[groupName][name] = data;\n            }\n        }\n        this.cache[name] = data;\n    }\n};\n\n//# sourceURL=webpack:///./src/loader/cache.js?')
        },
        "./src/loader/gltfConstant.js": /*!************************************!*\
  !*** ./src/loader/gltfConstant.js ***!
  \************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = {\n    'baseColorTexture': 'map',\n    'normalTexture': 'normalMap',\n    'occlusionTexture': 'aoMap',\n    'emissiveTexture': 'emissiveMap',\n    'specularGlossinessTexture': 'specularMap'\n};\n\n//# sourceURL=webpack:///./src/loader/gltfConstant.js?")
        },
        "./src/loader/path.js": /*!****************************!*\
  !*** ./src/loader/path.js ***!
  \****************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * 没有什么用，设计失败的产物, 想法总是太美好\r\n */\nvar path = function () {\n    function path(_path) {\n        _classCallCheck(this, path);\n\n        this.path = '';\n        if (this._isString(_path)) {\n            _path = _path.replace(/\\\\/g, '/').trim();\n            if (_path.substr(0) === '/') {\n                _path = _path.substr(1);\n            }\n        } else {\n            throw new Error('path is invalid');\n        }\n        this.path = _path;\n        this.folderPath = _path;\n        this.fileName = _path;\n        //初始化文件名称和文件夹名称\n        if (this.path.indexOf('/') > -1) {\n            var sp = this.path.lastIndexOf('/');\n            this.folderPath = this.path.substr(0, sp);\n            this.fileName = this.path.substr(sp + 1);\n        }\n    }\n\n    _createClass(path, [{\n        key: '_isString',\n        value: function _isString(str) {\n            if (typeof str === 'string') {\n                return true;\n            }\n            return false;\n        }\n    }, {\n        key: 'isFile',\n        value: function isFile() {\n            if (this.path.substr(-1) === '/') return false;\n            var pathArr = this.path.split('/');\n            return pathArr[pathArr.length - 1].indexOf('.') > -1;\n        }\n    }, {\n        key: 'isfolder',\n        value: function isfolder() {\n            return !this.isFile(path);\n        }\n\n        /**\r\n         * 文件获取文件名，文件夹则返回空\r\n         * @return {[type]} [description]\r\n         */\n\n    }, {\n        key: 'getFileName',\n        value: function getFileName() {\n\n            return this.fileName;\n        }\n    }, {\n        key: 'split',\n        value: function split() {\n            return this.folderPath.split('/');\n        }\n\n        /**\r\n         * 返回文件夹名，如果是文件则返回所在文件夹名\r\n         * @return {[type]} [description]\r\n         */\n\n    }, {\n        key: 'getFolderPath',\n        value: function getFolderPath() {\n            return this.folderPath;\n        }\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return this.path;\n        }\n    }]);\n\n    return path;\n}();\n\nexports.default = path;\n\n//# sourceURL=webpack:///./src/loader/path.js?")
        },
        "./src/loader/resourceGroupManager.js": /*!********************************************!*\
  !*** ./src/loader/resourceGroupManager.js ***!
  \********************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.default = {\n    addResourceLocation: function addResourceLocation() {},\n    createResourceGroup: function createResourceGroup() {},\n    resourceGroupExists: function resourceGroupExists() {},\n    loadPath: function loadPath() {},\n    clearResourceGroup: function clearResourceGroup() {}\n};\n\n//# sourceURL=webpack:///./src/loader/resourceGroupManager.js?')
        },
        "./src/loader/sceneLoader.js": /*!***********************************!*\
  !*** ./src/loader/sceneLoader.js ***!
  \***********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n\tvalue: true\n});\nexports.default = {\n\tloadFile: function loadFile() {},\n\tcreateOptimizeLighting: function createOptimizeLighting() {}\n};\n\n//# sourceURL=webpack:///./src/loader/sceneLoader.js?')
        },
        "./src/loader/storage.js": /*!*******************************!*\
  !*** ./src/loader/storage.js ***!
  \*******************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _storageItem = __webpack_require__(/*! ./storageItem.js */ "./src/loader/storageItem.js");\n\nvar _storageItem2 = _interopRequireDefault(_storageItem);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Stroage = new _storageItem2.default(\'Cache\');\n\nexports.default = Stroage;\n\n//# sourceURL=webpack:///./src/loader/storage.js?')
        },
        "./src/loader/storageItem.js": /*!***********************************!*\
  !*** ./src/loader/storageItem.js ***!
  \***********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _path = __webpack_require__(/*! ./path.js */ \"./src/loader/path.js\");\n\nvar _path2 = _interopRequireDefault(_path);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar storageItem = function () {\n    function storageItem(name) {\n        _classCallCheck(this, storageItem);\n\n        this.name = name || '';\n        this.children = {};\n        this.parent = undefined;\n    }\n\n    _createClass(storageItem, [{\n        key: '_loopSearch',\n        value: function _loopSearch(path) {\n            var pathArr = path.split('/');\n            var resourcedata = this;\n            for (var i = 0; i < pathArr.length; i++) {\n                // debugger\n                // 如果是文件夹的情况走下面\n                if (pathArr[i] === '') {\n                    return resourcedata;\n                }\n\n                var _rd = resourcedata.children[pathArr[i]];\n\n                if (_rd === undefined) {\n                    // throw new Error(\"get directory error\");\n                    // console.error(\"resource directory:\" + this._getPath() + path + \" is not exist\");\n                    return undefined;\n                }\n                resourcedata = _rd;\n            }\n            return resourcedata;\n            // if (resourcedata instanceof storageItem) {\n            //     return resourcedata;\n            // } else {\n            //     // console.error(\"resource directory: \" + this._getPath() + path + \" is not exist\");\n            //     return undefined;\n            // }\n        }\n    }, {\n        key: '_createFolder',\n        value: function _createFolder(path) {\n            var pathArr = path.split('/');\n            var resourcedata = this;\n            for (var i = 0; i < pathArr.length; i++) {\n                var _rd = resourcedata.children[pathArr[i]];\n\n                if (_rd === undefined) {\n                    _rd = new storageItem(pathArr[i]);\n                    _rd.parent = this;\n                    resourcedata.children[pathArr[i]] = _rd;\n                }\n                resourcedata = _rd;\n            }\n            if (resourcedata instanceof storageItem) {\n                return resourcedata;\n            }\n        }\n    }, {\n        key: 'addFile',\n        value: function addFile(path, data) {\n            var myPath = new _path2.default(path);\n\n            var folder = this._createFolder(myPath);\n            folder.children[myPath.getFileName()] = data;\n            return folder;\n        }\n    }, {\n        key: 'getFile',\n        value: function getFile(path) {\n            path = path.replace(/\\\\/g, '/').replace(/\\/\\//g, '/');\n            var resourcedata = this._loopSearch(path);\n\n            return resourcedata;\n        }\n    }, {\n        key: 'deleteFile',\n        value: function deleteFile(path) {\n            // resourcedata = this._loopSearch(path);\n            // delete resourcedata.children[file];\n        }\n    }, {\n        key: 'isExist',\n        value: function isExist(path) {\n            var resourcedata = this._loopSearch(path);\n            if (resourcedata) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }]);\n\n    return storageItem;\n}();\n\nexports.default = storageItem;\n\n//# sourceURL=webpack:///./src/loader/storageItem.js?")
        },
        "./src/main_uEarth.js": /*!****************************!*\
  !*** ./src/main_uEarth.js ***!
  \****************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\n__webpack_require__(/*! ./extra/SceneUtils.js */ "./src/extra/SceneUtils.js");\n\n__webpack_require__(/*! ./extra/three.path.js */ "./src/extra/three.path.js");\n\n__webpack_require__(/*! ./node/Object3D.Extend.js */ "./src/node/Object3D.Extend.js");\n\nvar _renderWindow = __webpack_require__(/*! ./scene/renderWindow.js */ "./src/scene/renderWindow.js");\n\nvar _renderWindow2 = _interopRequireDefault(_renderWindow);\n\nvar _util = __webpack_require__(/*! ./util/util.js */ "./src/util/util.js");\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar _constant = __webpack_require__(/*! ./util/constant.js */ "./src/util/constant.js");\n\nvar _constant2 = _interopRequireDefault(_constant);\n\nvar _sceneManager = __webpack_require__(/*! ./scene/sceneManager.js */ "./src/scene/sceneManager.js");\n\nvar _sceneManager2 = _interopRequireDefault(_sceneManager);\n\nvar _camera = __webpack_require__(/*! ./camera/camera.js */ "./src/camera/camera.js");\n\nvar _camera2 = _interopRequireDefault(_camera);\n\nvar _geometry = __webpack_require__(/*! ./geometry/geometry.js */ "./src/geometry/geometry.js");\n\nvar _geometry2 = _interopRequireDefault(_geometry);\n\nvar _GeometryManager = __webpack_require__(/*! ./geometry/GeometryManager.js */ "./src/geometry/GeometryManager.js");\n\nvar _GeometryManager2 = _interopRequireDefault(_GeometryManager);\n\nvar _SynchroGeometryManager = __webpack_require__(/*! ./geometry/SynchroGeometryManager.js */ "./src/geometry/SynchroGeometryManager.js");\n\nvar _SynchroGeometryManager2 = _interopRequireDefault(_SynchroGeometryManager);\n\nvar _rootNode = __webpack_require__(/*! ./node/rootNode.js */ "./src/node/rootNode.js");\n\nvar _rootNode2 = _interopRequireDefault(_rootNode);\n\nvar _viewport = __webpack_require__(/*! ./scene/viewport.js */ "./src/scene/viewport.js");\n\nvar _viewport2 = _interopRequireDefault(_viewport);\n\nvar _SceneQueryTypeMask = __webpack_require__(/*! ./scene/SceneQueryTypeMask.js */ "./src/scene/SceneQueryTypeMask.js");\n\nvar _SceneQueryTypeMask2 = _interopRequireDefault(_SceneQueryTypeMask);\n\nvar _Loader = __webpack_require__(/*! ./loader/Loader.js */ "./src/loader/Loader.js");\n\nvar _Loader2 = _interopRequireDefault(_Loader);\n\nvar _resourceGroupManager = __webpack_require__(/*! ./loader/resourceGroupManager.js */ "./src/loader/resourceGroupManager.js");\n\nvar _resourceGroupManager2 = _interopRequireDefault(_resourceGroupManager);\n\nvar _ResourceGroupName = __webpack_require__(/*! ./loader/ResourceGroupName.js */ "./src/loader/ResourceGroupName.js");\n\nvar _ResourceGroupName2 = _interopRequireDefault(_ResourceGroupName);\n\nvar _sceneLoader = __webpack_require__(/*! ./loader/sceneLoader.js */ "./src/loader/sceneLoader.js");\n\nvar _sceneLoader2 = _interopRequireDefault(_sceneLoader);\n\nvar _SceneLoadOptions = __webpack_require__(/*! ./scene/SceneLoadOptions.js */ "./src/scene/SceneLoadOptions.js");\n\nvar _SceneLoadOptions2 = _interopRequireDefault(_SceneLoadOptions);\n\nvar _BillboardType = __webpack_require__(/*! ./billboard/BillboardType.js */ "./src/billboard/BillboardType.js");\n\nvar _BillboardType2 = _interopRequireDefault(_BillboardType);\n\nvar _meshManager = __webpack_require__(/*! ./scene/meshManager.js */ "./src/scene/meshManager.js");\n\nvar _meshManager2 = _interopRequireDefault(_meshManager);\n\nvar _RenderOperationType = __webpack_require__(/*! ./scene/RenderOperationType.js */ "./src/scene/RenderOperationType.js");\n\nvar _RenderOperationType2 = _interopRequireDefault(_RenderOperationType);\n\nvar _SceneBlendType = __webpack_require__(/*! ./scene/SceneBlendType.js */ "./src/scene/SceneBlendType.js");\n\nvar _SceneBlendType2 = _interopRequireDefault(_SceneBlendType);\n\nvar _SceneBlendFactor = __webpack_require__(/*! ./scene/SceneBlendFactor.js */ "./src/scene/SceneBlendFactor.js");\n\nvar _SceneBlendFactor2 = _interopRequireDefault(_SceneBlendFactor);\n\nvar _TextureAddressingMode = __webpack_require__(/*! ./material/TextureAddressingMode.js */ "./src/material/TextureAddressingMode.js");\n\nvar _TextureAddressingMode2 = _interopRequireDefault(_TextureAddressingMode);\n\nvar _textureManager = __webpack_require__(/*! ./material/textureManager.js */ "./src/material/textureManager.js");\n\nvar _textureManager2 = _interopRequireDefault(_textureManager);\n\nvar _materialManager = __webpack_require__(/*! ./material/materialManager.js */ "./src/material/materialManager.js");\n\nvar _materialManager2 = _interopRequireDefault(_materialManager);\n\nvar _textureFilterOptions = __webpack_require__(/*! ./material/textureFilterOptions.js */ "./src/material/textureFilterOptions.js");\n\nvar _textureFilterOptions2 = _interopRequireDefault(_textureFilterOptions);\n\nvar _GpuProgramType = __webpack_require__(/*! ./material/GpuProgramType.js */ "./src/material/GpuProgramType.js");\n\nvar _GpuProgramType2 = _interopRequireDefault(_GpuProgramType);\n\nvar _paramsDataType = __webpack_require__(/*! ./material/paramsDataType.js */ "./src/material/paramsDataType.js");\n\nvar _paramsDataType2 = _interopRequireDefault(_paramsDataType);\n\nvar _math = __webpack_require__(/*! ./util/math.js */ "./src/util/math.js");\n\nvar _math2 = _interopRequireDefault(_math);\n\nvar _arrayUtil = __webpack_require__(/*! ./util/arrayUtil.js */ "./src/util/arrayUtil.js");\n\nvar _arrayUtil2 = _interopRequireDefault(_arrayUtil);\n\nvar _MouseButtonID = __webpack_require__(/*! ./event/MouseButtonID.js */ "./src/event/MouseButtonID.js");\n\nvar _MouseButtonID2 = _interopRequireDefault(_MouseButtonID);\n\nvar _KeyCode = __webpack_require__(/*! ./event/KeyCode.js */ "./src/event/KeyCode.js");\n\nvar _KeyCode2 = _interopRequireDefault(_KeyCode);\n\nvar _input = __webpack_require__(/*! ./event/input.js */ "./src/event/input.js");\n\nvar _input2 = _interopRequireDefault(_input);\n\nvar _CursorType = __webpack_require__(/*! ./event/CursorType.js */ "./src/event/CursorType.js");\n\nvar _CursorType2 = _interopRequireDefault(_CursorType);\n\nvar _CameraController = __webpack_require__(/*! ./camera/CameraController.js */ "./src/camera/CameraController.js");\n\nvar _CameraController2 = _interopRequireDefault(_CameraController);\n\nvar _CameraControlMode = __webpack_require__(/*! ./camera/CameraControlMode.js */ "./src/camera/CameraControlMode.js");\n\nvar _CameraControlMode2 = _interopRequireDefault(_CameraControlMode);\n\nvar _picking = __webpack_require__(/*! ./interactive/picking.js */ "./src/interactive/picking.js");\n\nvar _picking2 = _interopRequireDefault(_picking);\n\nvar _SelectConstant = __webpack_require__(/*! ./selection/SelectConstant.js */ "./src/selection/SelectConstant.js");\n\nvar _SelectConstant2 = _interopRequireDefault(_SelectConstant);\n\nvar _SceneNodeSelection = __webpack_require__(/*! ./selection/SceneNodeSelection.js */ "./src/selection/SceneNodeSelection.js");\n\nvar _SceneNodeSelection2 = _interopRequireDefault(_SceneNodeSelection);\n\nvar _MaterialModifier = __webpack_require__(/*! ./selection/MaterialModifier.js */ "./src/selection/MaterialModifier.js");\n\nvar _MaterialModifier2 = _interopRequireDefault(_MaterialModifier);\n\nvar _modifierManager = __webpack_require__(/*! ./selection/modifierManager.js */ "./src/selection/modifierManager.js");\n\nvar _modifierManager2 = _interopRequireDefault(_modifierManager);\n\nvar _canvasManager = __webpack_require__(/*! ./canvas/canvasManager.js */ "./src/canvas/canvasManager.js");\n\nvar _canvasManager2 = _interopRequireDefault(_canvasManager);\n\nvar _overlayManager = __webpack_require__(/*! ./overlay/overlayManager.js */ "./src/overlay/overlayManager.js");\n\nvar _overlayManager2 = _interopRequireDefault(_overlayManager);\n\nvar _OverlayElementType = __webpack_require__(/*! ./overlay/OverlayElementType.js */ "./src/overlay/OverlayElementType.js");\n\nvar _OverlayElementType2 = _interopRequireDefault(_OverlayElementType);\n\nvar _GuiConstant = __webpack_require__(/*! ./overlay/GuiConstant.js */ "./src/overlay/GuiConstant.js");\n\nvar _GuiConstant2 = _interopRequireDefault(_GuiConstant);\n\nvar _RenderQueueGroupID = __webpack_require__(/*! ./scene/RenderQueueGroupID.js */ "./src/scene/RenderQueueGroupID.js");\n\nvar _RenderQueueGroupID2 = _interopRequireDefault(_RenderQueueGroupID);\n\nvar _EventButton = __webpack_require__(/*! ./event/EventButton.js */ "./src/event/EventButton.js");\n\nvar _EventButton2 = _interopRequireDefault(_EventButton);\n\nvar _CullingMode = __webpack_require__(/*! ./material/CullingMode.js */ "./src/material/CullingMode.js");\n\nvar _CullingMode2 = _interopRequireDefault(_CullingMode);\n\nvar _buffer = __webpack_require__(/*! ./util/buffer.js */ "./src/util/buffer.js");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _GeoBuild = __webpack_require__(/*! ./util/GeoBuild.js */ "./src/util/GeoBuild.js");\n\nvar _GeoBuild2 = _interopRequireDefault(_GeoBuild);\n\nvar _InterpolationMode = __webpack_require__(/*! ./util/InterpolationMode.js */ "./src/util/InterpolationMode.js");\n\nvar _InterpolationMode2 = _interopRequireDefault(_InterpolationMode);\n\nvar _RenderManager = __webpack_require__(/*! ./renderer/RenderManager.js */ "./src/renderer/RenderManager.js");\n\nvar _RenderManager2 = _interopRequireDefault(_RenderManager);\n\nvar _grid = __webpack_require__(/*! ./util/grid.js */ "./src/util/grid.js");\n\nvar _grid2 = _interopRequireDefault(_grid);\n\nvar _game = __webpack_require__(/*! ./util/game.js */ "./src/util/game.js");\n\nvar _game2 = _interopRequireDefault(_game);\n\nvar _TransformSpace = __webpack_require__(/*! ./util/TransformSpace.js */ "./src/util/TransformSpace.js");\n\nvar _TransformSpace2 = _interopRequireDefault(_TransformSpace);\n\nvar _event = __webpack_require__(/*! ./event/event.js */ "./src/event/event.js");\n\nvar _event2 = _interopRequireDefault(_event);\n\nvar _base = __webpack_require__(/*! ./util/base.js */ "./src/util/base.js");\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _TextOptions = __webpack_require__(/*! ./util/TextOptions.js */ "./src/util/TextOptions.js");\n\nvar _TextOptions2 = _interopRequireDefault(_TextOptions);\n\nvar _LayerOptions = __webpack_require__(/*! ./util/LayerOptions.js */ "./src/util/LayerOptions.js");\n\nvar _LayerOptions2 = _interopRequireDefault(_LayerOptions);\n\nvar _QueryFlags = __webpack_require__(/*! ./scene/QueryFlags.js */ "./src/scene/QueryFlags.js");\n\nvar _QueryFlags2 = _interopRequireDefault(_QueryFlags);\n\nvar _sideOptions = __webpack_require__(/*! ./material/sideOptions.js */ "./src/material/sideOptions.js");\n\nvar _sideOptions2 = _interopRequireDefault(_sideOptions);\n\nvar _volumeDataManager = __webpack_require__(/*! ./volume/volumeDataManager.js */ "./src/volume/volumeDataManager.js");\n\nvar _volumeDataManager2 = _interopRequireDefault(_volumeDataManager);\n\nvar _Initialization = __webpack_require__(/*! ./Initialization.js */ "./src/Initialization.js");\n\nvar _Initialization2 = _interopRequireDefault(_Initialization);\n\nvar _storage = __webpack_require__(/*! ./loader/storage.js */ "./src/loader/storage.js");\n\nvar _storage2 = _interopRequireDefault(_storage);\n\nvar _cache = __webpack_require__(/*! ./loader/cache.js */ "./src/loader/cache.js");\n\nvar _cache2 = _interopRequireDefault(_cache);\n\nvar _ForceEdgeBunding = __webpack_require__(/*! ./extra/ForceEdgeBunding.js */ "./src/extra/ForceEdgeBunding.js");\n\nvar _ForceEdgeBunding2 = _interopRequireDefault(_ForceEdgeBunding);\n\nvar _version = __webpack_require__(/*! ./version.json */ "./src/version.json");\n\nvar _version2 = _interopRequireDefault(_version);\n\nvar _TexUnit = __webpack_require__(/*! ./material/TexUnit.js */ "./src/material/TexUnit.js");\n\nvar _TexUnit2 = _interopRequireDefault(_TexUnit);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//t3djs注册对象\n\n\n// import textureManager from \'./material/textureManager.js\';\n\n// 性能工具\n\n// import CompositorManager from \'./compositor/compositorManager.js\';\n// import compositorBuffer from \'./compositor/compositorBuffer.js\';\n\n// import Scene from "../lib/threejs/three.min.js"\n\n//import \'./extra/GLTFLoader.js\';\nvar t3djs = {\n    util: _util2.default,\n    game: _game2.default,\n    event: _event2.default,\n    EventButton: _EventButton2.default,\n    renderWindow: _renderWindow2.default,\n\n    GuiVerticalAlignment: _GuiConstant2.default.VerticalAlignment,\n    GuiHorizontalAlignment: _GuiConstant2.default.HorizontalAlignment,\n    GuiMetricsMode: _GuiConstant2.default.MetricsMode,\n\n    overlayManager: _overlayManager2.default,\n    camera: _camera2.default,\n    sceneManager: _sceneManager2.default,\n    BillboardType: _BillboardType2.default,\n    meshManager: _meshManager2.default,\n    geometry: _geometry2.default,\n    GeometryManager: _GeometryManager2.default,\n    SynchroGeometryManager: _SynchroGeometryManager2.default,\n    rootNode: _rootNode2.default,\n\n    viewport: _viewport2.default,\n    Loader: _Loader2.default,\n    resourceGroupManager: _resourceGroupManager2.default,\n    sceneLoader: _sceneLoader2.default,\n    SceneLoadOptions: _SceneLoadOptions2.default,\n    SceneQueryTypeMask: _SceneQueryTypeMask2.default,\n    // webManager: webManager,\n    RenderOperationType: _RenderOperationType2.default,\n    RenderQueueGroupID: _RenderQueueGroupID2.default,\n    SceneBlendType: _SceneBlendType2.default,\n    SceneBlendFactor: _SceneBlendFactor2.default,\n    TextureAddressingMode: _TextureAddressingMode2.default,\n    textureManager: _textureManager2.default,\n    ResourceGroupName: _ResourceGroupName2.default,\n\n    paramsDataType: _paramsDataType2.default,\n    GpuProgramType: _GpuProgramType2.default,\n    materialManager: _materialManager2.default,\n    input: _input2.default,\n    CursorType: _CursorType2.default,\n    grid: _grid2.default,\n    CameraController: _CameraController2.default,\n    CameraControlMode: _CameraControlMode2.default,\n    math: _math2.default,\n    arrayUtil: _arrayUtil2.default,\n    /** 描述类型 **/\n    MouseButtonID: _MouseButtonID2.default,\n    KeyCode: _KeyCode2.default,\n    TextureFilterOptions: _textureFilterOptions2.default,\n    FilterOptions: _textureFilterOptions2.default,\n    QueryFlags: _QueryFlags2.default,\n    OverlayElementType: _OverlayElementType2.default,\n    SideOptions: _sideOptions2.default,\n\n    picking: _picking2.default,\n\n    SelectionMark: _SelectConstant2.default.SelectionMark,\n    ModifierType: _SelectConstant2.default.ModifierType,\n    SceneNodeSelection: _SceneNodeSelection2.default,\n    MaterialModifier: _MaterialModifier2.default,\n    modifierManager: _modifierManager2.default,\n\n    TextAlignment: _TextOptions2.default.TextAlignment,\n    FontStyle: _TextOptions2.default.FontStyle,\n    TextureMipmap: _constant2.default.TextureMipmap,\n    TexUnit: _TexUnit2.default,\n    canvasManager: _canvasManager2.default,\n\n    LayerBlendOperationEx: _LayerOptions2.default.LayerBlendOperationEx,\n    LayerBlendSource: _LayerOptions2.default.LayerBlendSource,\n    TransformSpace: _TransformSpace2.default,\n    base: _base2.default,\n\n    volumeDataManager: _volumeDataManager2.default,\n\n    CullingMode: _CullingMode2.default,\n    basePath: \'\',\n    client: null,\n    species: \'t3dwebgl\',\n\n    buffer: _buffer2.default,\n\n    Storage: _storage2.default,\n    Cache: _cache2.default,\n\n    GeoBuild: _GeoBuild2.default,\n    ForceEdgeBundling: _ForceEdgeBunding2.default,\n    RenderManager: _RenderManager2.default,\n    InterpolationMode: _InterpolationMode2.default,\n    version: _version2.default.version\n};\n// import webManager from \'./web/webManager.js\';\n\n\nt3djs.go = function (id, app) {\n    var dom = document.getElementById(id);\n    t3djs.client = dom;\n    t3djs.client.setGestureCallback = function () {};\n    if (!dom) {\n        console.error(\'Cant find element by \' + id);\n    }\n    _Initialization2.default.init({\n        t3djs: t3djs,\n        dom: dom\n    });\n    _Initialization2.default.initEnvironment(app);\n};\n\nwindow.t3djs = t3djs;\n\n//# sourceURL=webpack:///./src/main_uEarth.js?')
        },
        "./src/material/CullingMode.js": /*!*************************************!*\
  !*** ./src/material/CullingMode.js ***!
  \*************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.default = {\n    /** Hardware never culls triangles and renders everything it receives. */\n    NONE: 1,\n    /** Hardware culls triangles whose vertices are listed clockwise in the view (default). */\n    CLOCKWISE: 2,\n    /** Hardware culls triangles whose vertices are listed anticlockwise in the view. */\n    ANTICLOCKWISE: 3\n};\n\n//# sourceURL=webpack:///./src/material/CullingMode.js?')
        },
        "./src/material/GpuProgramType.js": /*!****************************************!*\
  !*** ./src/material/GpuProgramType.js ***!
  \****************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = {\n    VERTEX_PROGRAM: 'VERTEX_PROGRAM',\n    FRAGMENT_PROGRAM: 'FRAGMENT_PROGRAM',\n    GEOMETRY_PROGRAM: 'GEOMETRY_PROGRAM',\n    SHADOW_CASTER_VERTEX_PROGRAM: 'SHADOW_CASTER_VERTEX_PROGRAM',\n    SHADOW_RECEIVER_FRAGMENT_PROGRAM: 'SHADOW_RECEIVER_FRAGMENT_PROGRAM',\n    SHADOW_RECEIVER_VERTEX_PROGRAM: 'SHADOW_RECEIVER_VERTEX_PROGRAM'\n};\n\n//# sourceURL=webpack:///./src/material/GpuProgramType.js?")
        },
        "./src/material/Material.js": /*!**********************************!*\
  !*** ./src/material/Material.js ***!
  \**********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Technique = __webpack_require__(/*! ./Technique.js */ \"./src/material/Technique.js\");\n\nvar _Technique2 = _interopRequireDefault(_Technique);\n\nvar _helper = __webpack_require__(/*! ../util/helper.js */ \"./src/util/helper.js\");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nvar _buffer2 = __webpack_require__(/*! ../util/buffer.js */ \"./src/util/buffer.js\");\n\nvar _buffer3 = _interopRequireDefault(_buffer2);\n\nvar _specialMaterialManager = __webpack_require__(/*! ./specialMaterial/specialMaterialManager.js */ \"./src/material/specialMaterial/specialMaterialManager.js\");\n\nvar _specialMaterialManager2 = _interopRequireDefault(_specialMaterialManager);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Material = function () {\n    function Material(name, _option, _buffer) {\n        _classCallCheck(this, Material);\n\n        _buffer = _buffer === undefined || _buffer === true;\n        var option = _option || 'default';\n        this.name = name || _helper2.default.getUUID();\n        var curName = this.name;\n        this.option = option;\n        this.techniques = [];\n        this.techniques[0] = new _Technique2.default(curName, option);\n        this.techniques[0].parent = this;\n        if (_buffer) {\n            // if(buffer.materialBuffer.get(curName)){\n            //     console.warn('该材质名字:'+curName +'重复了，请重新命名');\n            // } else{\n            _buffer3.default.materialBuffer.add(curName, this);\n            //}\n        }\n    }\n    //TODO 特殊材质不能改option\n\n\n    _createClass(Material, [{\n        key: 'setOption',\n        value: function setOption(option) {\n            if (_specialMaterialManager2.default.isSpecialMaterial(this.option)) {\n                console.warn('不允许改变特殊材质的类型');\n                return;\n            }\n            this.option = option;\n            this.getTechnique().map(function (v) {\n                v.option = option;\n                v.getPass().map(function (p) {\n                    p.option = option;\n                    p.getTextureUnitState().map(function (t) {\n                        if (t) {\n                            t.option = option;\n                        }\n                    });\n                });\n            });\n        }\n    }, {\n        key: 'getTechnique',\n        value: function getTechnique(id) {\n            if (!id && id !== 0) {\n                return this.techniques;\n            } else {\n                return this.techniques[id];\n            }\n        }\n    }, {\n        key: 'createTechnique',\n        value: function createTechnique(name) {\n            name = name || _helper2.default.getUUID();\n            var technique = new _Technique2.default(name, this.option);\n            technique.parent = this;\n            this.techniques.push(technique);\n            return technique;\n        }\n    }, {\n        key: 'toString',\n        value: function toString() {\n            return this.name;\n        }\n    }, {\n        key: 'clone',\n        value: function clone(name) {\n            var flag = name === undefined;\n            name = name || _helper2.default.getUUID();\n            var newMaterial = new Material(name, this.option, !flag);\n            newMaterial.techniques = [];\n            var origin = this;\n            var teches = origin.getTechnique();\n            if (teches.length > 0) {\n                for (var i = 0; i < teches.length; i++) {\n                    var newTech = teches[i].clone(name);\n                    newMaterial.techniques.push(newTech);\n                }\n            }\n            return newMaterial;\n        }\n    }, {\n        key: 'getMaterial',\n        value: function getMaterial() {\n            var material = [];\n            var tech = this.getTechnique(0);\n            var pass = tech.getPass();\n            for (var i = 0; i < pass.length; i++) {\n                material.push(pass[i].getMaterial());\n            }\n            return material;\n        }\n    }, {\n        key: 'cloneTechnique',\n        value: function cloneTechnique() {}\n    }, {\n        key: 'destroy',\n        value: function destroy() {\n            if (_buffer3.default.materialBuffer.get(this.name)) {\n                _buffer3.default.materialBuffer.delete(this.name);\n            }\n            var mats = this.getMaterial();\n            for (var i = 0; i < mats.length; i++) {\n                mats[i].dispose();\n            }\n        }\n        //added 深度删除接口，因为uinv的原因，destroy不能真正释放掉材质和贴图，因此需要增加这个接口\n\n    }, {\n        key: 'dispose',\n        value: function dispose() {\n            var mat = _buffer3.default.materialBuffer.get(this.name);\n            if (mat) {\n                _buffer3.default.materialBuffer.delete(this.name);\n                var mats = this.getMaterial();\n                for (var i = 0; i < mats.length; i++) {\n                    mats[i].dispose();\n                    if (mats[i].map) {\n                        _buffer3.default._renderList.delete(mats[i].map.uuid);\n                        mats[i].map = null;\n                    }\n                }\n            }\n        }\n    }]);\n\n    return Material;\n}();\n\nexports.default = Material;\n\n//# sourceURL=webpack:///./src/material/Material.js?")
        },
        "./src/material/Pass.js": /*!******************************!*\
  !*** ./src/material/Pass.js ***!
  \******************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _TexUnit = __webpack_require__(/*! ./TexUnit.js */ \"./src/material/TexUnit.js\");\n\nvar _TexUnit2 = _interopRequireDefault(_TexUnit);\n\nvar _helper = __webpack_require__(/*! ../util/helper.js */ \"./src/util/helper.js\");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nvar _materialFactory = __webpack_require__(/*! ./materialFactory.js */ \"./src/material/materialFactory.js\");\n\nvar _materialFactory2 = _interopRequireDefault(_materialFactory);\n\nvar _sourceThreeFunction = __webpack_require__(/*! ./sourceThreeFunction.js */ \"./src/material/sourceThreeFunction.js\");\n\nvar _sourceThreeFunction2 = _interopRequireDefault(_sourceThreeFunction);\n\nvar _buffer = __webpack_require__(/*! ../util/buffer.js */ \"./src/util/buffer.js\");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Pass = function () {\n    //add option you can get other actual material\n    function Pass(name, _option) {\n        _classCallCheck(this, Pass);\n\n        var option = _option || 'default';\n        this.texUnits = [];\n        var material = _materialFactory2.default.createMaterial(option);\n        //this.texUnits[0] = new TexUnit(material, \"\", option, 0);\n        material.name = name;\n        material.transparent = true;\n        material.parent = this;\n        this.name = name;\n        this.option = option;\n        this.material = material;\n        this.renderOrder = 0;\n    }\n\n    _createClass(Pass, [{\n        key: 'setValues',\n        value: function setValues(params) {\n            this.material.setValues(params);\n        }\n    }, {\n        key: 'setMaterial',\n        value: function setMaterial(material) {\n            this.material = material;\n            var texunits = this.texUnits;\n            texunits.map(function (v) {\n                v.material = material;\n                //if(v.params.scrollAnimation.length > 1){\n                // v.setScrollAnimation(v.params.scrollAnimation[0], v.params.scrollAnimation[1]);\n                if (v.material.map) {\n                    var texture = v.material.map;\n                    v.texture = texture;\n                    v.name = texture.name;\n                    _buffer2.default.textureBuffer.add(texture.name, texture);\n                }\n                v.setTextureName();\n                //}\n            });\n            _buffer2.default.bigDirty = true;\n        }\n    }, {\n        key: 'getMaterial',\n        value: function getMaterial() {\n            return this.material;\n        }\n    }, {\n        key: 'createTextureUnitState',\n        value: function createTextureUnitState(name) {\n            if (name === undefined) {\n                name = _helper2.default.getUUID();\n            }\n            var texUnit = new _TexUnit2.default(this.material, name, this.option, this.texUnits.length);\n            this.texUnits.push(texUnit);\n            _buffer2.default.bigDirty = true;\n            return texUnit;\n        }\n    }, {\n        key: 'setDiffuse',\n        value: function setDiffuse(color) {\n            if (color.length == 3) {\n                var myColor = new THREE.Color(color[0], color[1], color[2]);\n                if (this.material.type == 'MeshLineMaterial' || this.material.type == 'BuildingMaterial') {\n                    this.material.uniforms.color.value.copy(myColor);\n                } else {\n                    this.material.color.copy(myColor);\n                }\n            } else if (color.length == 4) {\n                var myColor = new THREE.Color(color[0], color[1], color[2]);\n                if (this.material.type == 'MeshLineMaterial' || this.material.type == 'BuildingMaterial') {\n                    this.material.uniforms.color.value.copy(myColor);\n                    this.material.uniforms.opacity.value = color[3];\n                } else {\n                    this.material.opacity = color[3];\n                    this.material.color.copy(myColor);\n                }\n\n                // this.material.alphaColor = new THREE.Vector4(color[0], color[1], color[2], color[3]);\n                // if(this.material.shader){\n                //     this.material.shader.uniforms.alphaColor.value = new THREE.Vector4(color[0], color[1], color[2], color[3]);\n                // }\n            }\n            _buffer2.default.bigDirty = true;\n        }\n    }, {\n        key: 'setEmissive',\n        value: function setEmissive(r, g, b, a) {\n            this.material.emissive = new THREE.Color(r, g, b);\n            this.material.emissiveIntensity = a;\n            _buffer2.default.bigDirty = true;\n        }\n    }, {\n        key: 'getTextureUnitState',\n        value: function getTextureUnitState(id) {\n            if (id === undefined) return this.texUnits;else if (!this.texUnits[id]) {\n                //this.texUnits[id] = new TexUnit(this.material, \"\", this.option, this.texUnits.length);\n                console.log('there is not a texture in texUnits[' + id + ']');\n                return '';\n            } else {\n                return this.texUnits[id];\n            }\n        }\n        //now doing this. default is addEquation .src is srcAlpha, and dst is dstAlpha\n\n    }, {\n        key: 'setSceneBlending',\n        value: function setSceneBlending(sceneBlendType, sceneBlendFactor) {\n            sceneBlendType = sceneBlendType || THREE.NormalBlending;\n            var material = this.material;\n            // test combine, it does not work well\n            //material.combine = THREE.MultiplyOperation;\n            material.blending = sceneBlendType;\n            material.blendEquation = THREE.AddEquation; //default\n            material.blendSrc = sceneBlendFactor || THREE.SrcAlphaFactor; //default\n            material.blendDst = THREE.DstAlphaFactor; //default\n            _buffer2.default.bigDirty = true;\n        }\n        //let the material not affected by the light, I am rendering and copy only one texuint now.\n\n    }, {\n        key: 'setLighting',\n        value: function setLighting(bool) {\n            if (!bool && this.option === 'default') {\n                var materialName = '';\n                if (this.material) {\n                    var oldMaterial = this.material;\n                    materialName = this.material.name;\n                    var material = _materialFactory2.default.createMaterial('MeshBasicMaterial', _sourceThreeFunction2.default.copyParams(this.material));\n                    material.name = materialName;\n                    oldMaterial.dispose();\n                    this.material = material;\n                }\n            }\n            _buffer2.default.bigDirty = true;\n        }\n        //it is changed opacity to 0 or 1\n\n    }, {\n        key: 'setAlphaRejectSettings',\n        value: function setAlphaRejectSettings(nums) {\n            if (!this.material.transparent) {\n                this.material.transparent = true;\n            }\n            if (nums == 0.0) {\n                this.material.opacity = 0.0;\n            } else if (nums == 1.0) {\n                this.material.opacity = nums;\n                this.material.transparent = false;\n            } else {\n                this.material.opacity = nums;\n            }\n            _buffer2.default.bigDirty = true;\n        }\n    }, {\n        key: 'setTransparent',\n        value: function setTransparent(val) {\n            this.material.opacity = 1 - val;\n            _buffer2.default.bigDirty = true;\n        }\n    }, {\n        key: 'setOpacity',\n        value: function setOpacity(val) {\n            if (this.material.type == 'MeshLineMaterial' || this.material.type == 'BuildingMaterial') {\n                this.material.uniforms.opacity.value = val;\n                this.material.opacity = val;\n            } else {\n                this.material.opacity = val;\n            }\n        }\n\n        //加上噪声 防止闪屏\n\n    }, {\n        key: 'getUniformRandom',\n        value: function getUniformRandom() {\n            return 0.0001 * Math.random();\n        }\n    }, {\n        key: 'setGpuProgramParameter',\n        value: function setGpuProgramParameter(programType, parameterName, val, valCount, valType) {\n            var mat = this.material;\n            if (mat.uniforms && mat.uniforms[parameterName] === undefined) {\n                mat.uniforms[parameterName] = { value: 0 };\n            }\n            if (mat.uniforms && mat.uniforms[parameterName]) {\n\n                if (parameterName == 'grayFilterColorBar') {\n                    var colorBar = [];\n                    for (var i in val) {\n                        colorBar.push(new THREE.Color(val[i][0] + this.getUniformRandom(), val[i][1] + this.getUniformRandom(), val[i][2] + this.getUniformRandom()));\n                    }\n                    while (colorBar.length < 10) {\n                        colorBar.push(colorBar[colorBar.length - 1]);\n                    }\n                    mat.uniforms[parameterName].value = colorBar;\n\n                    // var grayFilterPerBar = [];\n                    // for(var i=0; i<val.length; i++){\n                    //     grayFilterPerBar.push(i/(val.length - 1));\n                    // }\n                    // while (grayFilterPerBar.length <10) {\n                    //     grayFilterPerBar.push( -1.0 );\n                    // }\n                    // mat.uniforms['grayFilterPerBar'].value = grayFilterPerBar;\n\n                } else if (parameterName == 'grayFilterEnable') {\n                    mat.uniforms[parameterName].value = val == undefined ? false : val;\n                } else if (parameterName == 'grayFilterPerBar') {\n                    var grayFilterPerBar = [];\n                    for (var i = 0; i < val.length; i++) {\n                        grayFilterPerBar.push(val[i] + this.getUniformRandom());\n                    }\n                    while (grayFilterPerBar.length < 10) {\n                        grayFilterPerBar.push(grayFilterPerBar[grayFilterPerBar.length - 1]);\n                    }\n\n                    mat.uniforms[parameterName].value = grayFilterPerBar;\n                } else {\n                    //color\n                    if (mat.uniforms[parameterName].type && mat.uniforms[parameterName].type == 'c') {\n                        if (val.length < 3) {\n                            console.log('there are less than 3 factors in your color array');\n                            return;\n                        }\n                        mat.uniforms[parameterName].value = new THREE.Color(val[0], val[1], val[2]);\n                    } else {\n                        if (valCount == 2) {\n                            mat.uniforms[parameterName].value = new THREE.Vector2(val[0], val[1]);\n                        } else if (valCount == 3) {\n                            mat.uniforms[parameterName].value = new THREE.Vector3(val[0], val[1], val[2]);\n                        } else if (valCount == 4) {\n                            mat.uniforms[parameterName].value = new THREE.Vector4(val[0], val[1], val[2], val[3]);\n                        } else {\n                            mat.uniforms[parameterName].value = val;\n                        }\n                    }\n                }\n            }\n            mat.needsUpdate = true;\n            _buffer2.default.bigDirty = true;\n        }\n    }, {\n        key: 'setGpuProgramParameters',\n        value: function setGpuProgramParameters(strList) {\n            if (strList.length >= 5) {\n                for (var i = 0; i < strList.length; i += 5) {\n                    this.setGpuProgramParameter(strList[i], strList[i + 1], strList[i + 2], strList[i + 3], strList[i + 4]);\n                }\n            }\n            _buffer2.default.bigDirty = true;\n        }\n    }, {\n        key: 'parseScriptLine',\n        value: function parseScriptLine(arr) {\n            if (arr === 'depth_check off') {\n                this.setDepthCheck(false);\n            }\n            if (arr.split('diffuse ').length > 1) {\n                var diffuse = arr.split('diffuse ')[1];\n                var colorArr = diffuse.split(' ');\n                var r = colorArr[0] ? parseFloat(colorArr[0]) : 0;\n                var g = colorArr[1] ? parseFloat(colorArr[1]) : 0;\n                var b = colorArr[2] ? parseFloat(colorArr[2]) : 0;\n                var a = colorArr[3] ? parseFloat(colorArr[3]) : 1;\n                var color = new THREE.Color(r, g, b);\n                if (this.material.type === 'MeshLineMaterial') {\n                    this.material.uniforms.color.value = color;\n                    this.material.uniforms.opacity.value = a;\n                } else {\n                    this.material.color = color;\n                    this.material.opacity = a;\n                }\n            }\n            _buffer2.default.bigDirty = true;\n        }\n    }, {\n        key: 'setCullingMode',\n        value: function setCullingMode() {}\n    }, {\n        key: 'clone',\n        value: function clone(name) {\n            name = name || _helper2.default.getUUID();\n            var newPass = new Pass(name, this.option);\n            newPass.material = this.material.clone();\n            //MaterialBuffer.materialBuffer.add(newPass.material.uuid, newPass.material);\n            //newPass.material.onBeforeCompile = this.material.onBeforeCompile;\n            newPass.material.name = name;\n            newPass.texCoord3 = this.texCoord3;\n            newPass.texUnits = [];\n            var oldTexUnit = this.texUnits;\n            for (var i = 0; i < oldTexUnit.length; i++) {\n                var newTexUnit = oldTexUnit[i]._clone(newPass.material);\n                newPass.texUnits.push(newTexUnit);\n            }\n            return newPass;\n        }\n    }, {\n        key: 'setDepthWrite',\n        value: function setDepthWrite(bool) {\n            this.material.depthWrite = bool;\n            _buffer2.default.bigDirty = true;\n        }\n    }, {\n        key: 'setMaskMap',\n        value: function setMaskMap(name) {\n            // if(this.material.type === 'default' || this.material.type === 'MeshStandardMaterial'){\n            var tex;\n            if (typeof name === 'string') {\n                tex = _buffer2.default.textureBuffer.get(name);\n            } else {\n                tex = name;\n            }\n            if (tex) {\n                // this.material.defines.USE_ALPHAMAP1 = true;\n                //这里需要clone下，不要影响其他公用该材质的物体，这里需要注意，只要是新增的defines最好要clone下\n                this.material = this.material.clone();\n                this.material.alphaMap1 = tex;\n                if (this.material.defines === undefined) {\n                    this.material.defines = {};\n                }\n                this.material.defines.USE_UV3 = true;\n                //this.material.alphaMap = tex;\n                this.material.needsUpdate = true;\n            }\n            // }\n            _buffer2.default.bigDirty = true;\n        }\n    }, {\n        key: 'setAlphaMap',\n        value: function setAlphaMap(name) {\n            var tex;\n            if (typeof name === 'string') {\n                tex = _buffer2.default.textureBuffer.get(name);\n            } else {\n                tex = name;\n            }\n            if (tex) {\n                this.material.alphaMap = tex;\n                this.material.needsUpdate = true;\n            }\n            _buffer2.default.bigDirty = true;\n        }\n    }, {\n        key: 'setDepthCheck',\n        value: function setDepthCheck(bool) {\n            this.material.depthTest = bool;\n            _buffer2.default.bigDirty = true;\n        }\n    }, {\n        key: 'setSides',\n        value: function setSides(side) {\n            var material = this.material;\n            material.side = side;\n            _buffer2.default.bigDirty = true;\n        }\n    }, {\n        key: 'setTexCoord3',\n        value: function setTexCoord3(texCoord) {\n            this.texCoord3 = texCoord;\n        }\n    }, {\n        key: 'setPolygonOffset',\n        value: function setPolygonOffset(offset, unit, flag) {\n            flag = flag === undefined ? true : flag;\n            offset = offset || 0;\n            unit = unit || 0;\n            this.material.polygonOffset = flag;\n            this.material.polygonOffsetFactor = offset;\n            this.material.polygonOffsetUnits = unit;\n        }\n    }, {\n        key: 'removeTexUnit',\n        value: function removeTexUnit(index) {\n            //目前只支持一个texunit\n            if (!this.material) return;\n            if (this.material.type === 'MeshLineMaterial' || this.material.type === 'BuildingMaterial') {\n                this.material.uniforms.useMap.value = 0;\n                this.material.uniforms.map.value = null;\n            } else {\n                this.material.map = null;\n                this.material.needsUpdate = true;\n            }\n            this.material.needsUpdate = true;\n            // //删除buffer中的数据\n            // buffer.textureBuffer.delete(texUnit);\n        }\n        //added you can use encoding to ignore gamma or exposure;\n\n    }, {\n        key: 'setEncoding',\n        value: function setEncoding(encoding) {\n            this.material.map.encoding = encoding || THREE.LinearEncoding;\n            this.material.needsUpdate = true;\n        }\n        //renderOrder最好不要设置负值不然可能会出错\n\n    }, {\n        key: 'setRenderOrder',\n        value: function setRenderOrder(order) {\n            this.renderOrder = order;\n        }\n    }]);\n\n    return Pass;\n}();\n\nexports.default = Pass;\n\n//# sourceURL=webpack:///./src/material/Pass.js?")
        },
        "./src/material/Technique.js": /*!***********************************!*\
  !*** ./src/material/Technique.js ***!
  \***********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Pass = __webpack_require__(/*! ./Pass.js */ \"./src/material/Pass.js\");\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _helper = __webpack_require__(/*! ../util/helper.js */ \"./src/util/helper.js\");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Technique = function () {\n    function Technique(name, _option) {\n        _classCallCheck(this, Technique);\n\n        var option = _option || 'default';\n        this.name = name;\n        this.option = option;\n        this.passes = [];\n        this.passes[0] = new _Pass2.default(name, option);\n        this.passes[0].parent = this;\n        this.schemeName = '';\n    }\n\n    _createClass(Technique, [{\n        key: 'createPass',\n        value: function createPass(name) {\n            name = name || _helper2.default.getUUID();\n            var pass = new _Pass2.default(name, this.option);\n            pass.parent = this;\n            //pass.setSceneBlending();\n            this.passes.push(pass);\n            return pass;\n        }\n    }, {\n        key: 'updatePass',\n        value: function updatePass(index, pass) {\n            this.passes.splice(index, 1, pass);\n        }\n    }, {\n        key: 'getPass',\n        value: function getPass(id) {\n            if (!id && id !== 0) {\n                return this.passes;\n            } else {\n                return this.passes[id];\n            }\n        }\n    }, {\n        key: 'removePass',\n        value: function removePass(id) {\n            return this.passes.splice(id, 1);\n        }\n    }, {\n        key: 'getNumPasses',\n        value: function getNumPasses() {\n            return this.passes.length;\n        }\n    }, {\n        key: 'setSchemeName',\n        value: function setSchemeName(name) {\n            this.schemeName = name;\n        }\n    }, {\n        key: 'getSchemeName',\n        value: function getSchemeName() {\n            return this.schemeName;\n        }\n    }, {\n        key: 'clone',\n        value: function clone(name) {\n            name = name || _helper2.default.getUUID();\n            var passes = this.getPass();\n            var newTech = new Technique(name, this.option);\n            newTech.passes = [];\n            if (passes.length > 0) {\n                for (var i = 0; i < passes.length; i++) {\n                    var newPass = passes[i].clone(name);\n                    newTech.passes.push(newPass);\n                }\n            }\n            return newTech;\n        }\n    }]);\n\n    return Technique;\n}();\n\nexports.default = Technique;\n\n//# sourceURL=webpack:///./src/material/Technique.js?")
        },
        "./src/material/TexUnit.js": /*!*********************************!*\
  !*** ./src/material/TexUnit.js ***!
  \*********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _buffer = __webpack_require__(/*! ../util/buffer.js */ \"./src/util/buffer.js\");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _helper = __webpack_require__(/*! ../util/helper.js */ \"./src/util/helper.js\");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nvar _specialMaterialManager = __webpack_require__(/*! ./specialMaterial/specialMaterialManager.js */ \"./src/material/specialMaterial/specialMaterialManager.js\");\n\nvar _specialMaterialManager2 = _interopRequireDefault(_specialMaterialManager);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TexUnit = function () {\n    function TexUnit(mat, name, option, index) {\n        _classCallCheck(this, TexUnit);\n\n        this.material = mat;\n        this.texture = '';\n        this.index = index || 0;\n        this.params = {\n            offset: '',\n            rotation: 0,\n            scale: '',\n            TextureAddressingMode: '',\n            TextureFilterOption: '',\n            anisotropy: '',\n            scrollAnimation: []\n        };\n        option = option || 'default';\n        name = name || _helper2.default.getUUID();\n        this.option = option;\n        if (typeof name === 'string') {\n            this.name = name;\n        } else {\n            // this.name = name.uuid;\n            this.texture = name;\n            this.name = name.uuid;\n        }\n        this._updateTexture(name);\n    }\n\n    _createClass(TexUnit, [{\n        key: 'getName',\n        value: function getName() {\n            return this.name;\n        }\n    }, {\n        key: 'setTexture',\n        value: function setTexture(tex) {\n            tex.needsUpdate = true;\n            this.texture = tex;\n            this.material.map = tex;\n            this.material.needsUpdate = true;\n        }\n    }, {\n        key: 'setImage',\n        value: function setImage(image) {\n            if (!this.texture) {\n                this.texture = new THREE.Texture();\n                this.material.map = this.texture;\n            }\n            this.texture.image = image;\n            this.texture.needsUpdate = true;\n        }\n    }, {\n        key: 'setImageUrl',\n        value: function setImageUrl(url) {\n            var textureLoader = new THREE.TextureLoader();\n            this.texture = textureLoader.load(url);\n            this.material.map = this.texture;\n        }\n    }, {\n        key: 'setTextureName',\n        value: function setTextureName(name) {\n            this._updateTexture(name);\n            if (this.params.offset) {\n                this.setTextureScroll(this.params.offset[0], this.params.offset[1]);\n            }\n            if (this.params.rotation) {\n                this.setTextureRotate(this.params.rotation);\n            }\n            if (this.params.scale) {\n                this.setTextureScale(this.params.scale[0], this.params.scale[1]);\n            }\n            if (this.params.TextureAddressingMode !== '') {\n                this.setTextureAddressingMode(this.params.TextureAddressingMode);\n            }\n            if (this.params.TextureFilterOption) {\n                this.setTextureFiltering(this.params.TextureFilterOption);\n            }\n            if (this.params.anisotropy) {\n                this.setTextureAnisotropy(this.params.anisotropy);\n            }\n            if (this.params.scrollAnimation.length > 1) {\n                this.setScrollAnimation(this.params.scrollAnimation[0], this.params.scrollAnimation[1]);\n            }\n            _buffer2.default.bigDirty = true;\n        }\n    }, {\n        key: '_updateTexture',\n        value: function _updateTexture(name) {\n            if (name === undefined) return;\n\n            var texture = name;\n            if (typeof name === 'string') {\n                texture = _buffer2.default.textureBuffer.get(name);\n                this.name = name;\n            }\n            if (!texture) {\n                return;\n            }\n            //this.texture = texture.clone();\n            this.texture = texture;\n            // var cp = new THREE.Vector2(0.5, 0.5);\n            // this.texture.center = cp;\n            if (this.texture.image) {\n                this.texture.needsUpdate = true;\n            }\n            this.material.dispose();\n            if (this.material.type === 'MeshLineMaterial' || this.material.type === 'BuildingMaterial') {\n                this.texture.wrapS = THREE.RepeatWrapping;\n                this.texture.wrapT = THREE.RepeatWrapping;\n                if (this.material.uniforms) {\n                    this.material.uniforms['useMap'].value = 1;\n                    this.material.uniforms['map'].value = this.texture;\n                }\n            } else if (_specialMaterialManager2.default.isSpecialMaterial(this.option)) {\n                if (!this.material.uniforms) {\n                    console.log('you should make sure the uniforms exist in specialMaterial');\n                    return;\n                }\n                var textureName = _specialMaterialManager2.default.getTextureName(this.option, this.index);\n                // this.texture.magFilter = THREE.LinearFilter;\n                // this.texture.minFilter = THREE.LinearFilter;\n\n                if (textureName) {\n                    this.material.uniforms[textureName].value = this.texture;\n                    //this.material.needsUpdate = true;\n                }\n            } else {\n                this.texture.wrapS = THREE.RepeatWrapping;\n                this.texture.wrapT = THREE.RepeatWrapping;\n                this.material.setValues({\n                    map: this.texture\n                });\n            }\n            this.material.needsUpdate = true;\n        }\n    }, {\n        key: 'update',\n        value: function update() {\n            this.texture = this.material.map;\n            _buffer2.default.bigDirty = true;\n        }\n    }, {\n        key: 'setTextureScroll',\n        value: function setTextureScroll(u, v) {\n            if (!this.texture) {\n                this.params.offset = [u, v];\n                return;\n            }\n            var offset = new THREE.Vector2(0, 0);\n            //offset.x += 1 - (2 * u + 1);\n            offset.y = 1 - (2 * v + 1);\n            //offset.x += u;\n            //offset.y -= v;\n            this.texture.offset = offset;\n            _buffer2.default.bigDirty = true;\n        }\n    }, {\n        key: 'setTextureScroll2',\n        value: function setTextureScroll2(u, v) {\n            if (!this.texture) {\n                this.params.offset = [u, v];\n                return;\n            }\n            var offset = new THREE.Vector2(0, 0);\n            offset.x += u;\n            offset.y += v;\n            this.texture.offset = offset;\n            _buffer2.default.bigDirty = true;\n        }\n    }, {\n        key: 'setScrollAnimation',\n        value: function setScrollAnimation() {\n            var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n            var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n            var name = arguments[2];\n            var keepSpeed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n            // debugger;\n            name = name !== undefined ? name : _helper2.default.getUUID();\n            x = -x / 50;\n            y = -y / 50;\n            var material = this.material;\n            if (!this.texture) {\n                return;\n            }\n            var tex = this.material.map;\n            var task = {\n                x: x,\n                y: y,\n                offset: new THREE.Vector2(0, 0),\n                texture: tex,\n                update: function update() {\n                    var deltaX = this.x;\n                    var deltaY = this.y;\n                    if (keepSpeed) {\n                        var deltaTime = THING.App.current.deltaTime;\n                        deltaX = deltaTime / 16 * this.x;\n                        deltaY = deltaTime / 16 * this.y;\n                    }\n                    if (material.type === 'MeshLineMaterial' || material.type === 'BuildingMaterial') {\n                        material.uniforms.offset.value.x += deltaX;\n                        material.uniforms.offset.value.y += deltaY;\n                    } else {\n                        this.offset.x += deltaX;\n                        this.offset.y += deltaY;\n                        this.texture.offset = this.offset;\n                    }\n                    _buffer2.default.bigDirty = true;\n                }\n            };\n            _buffer2.default._renderList.add(name, task);\n        }\n    }, {\n        key: 'setTextureRotate',\n        value: function setTextureRotate(angle) {\n            angle = angle / 180 * Math.PI;\n            if (!this.texture) {\n                this.params.rotation = angle;\n                return;\n            }\n            if (this.material.type === 'SpriteMaterial') {\n                this.material.rotation = angle;\n            } else {\n                this.texture.rotation = angle;\n            }\n            _buffer2.default.bigDirty = true;\n        }\n    }, {\n        key: 'setRotateAnimation',\n        value: function setRotateAnimation(angle) {\n            angle = angle / 50;\n            if (!this.texture) {\n                if (this.material.map) {\n                    this.texture = this.material.map;\n                } else {\n                    return;\n                }\n            }\n            var mat = this.material;\n            var tex = this.material.map;\n            tex.center = new THREE.Vector2(0.5, 0.5);\n            var task = {\n                angle: angle,\n                texture: tex,\n                update: function update() {\n                    // debugger;\n                    if (mat.type === 'SpriteMaterial') {\n                        mat.rotation += angle;\n                    } else {\n                        tex.rotation += this.angle;\n                    }\n                    _buffer2.default.bigDirty = true;\n                }\n            };\n            var name = _helper2.default.getUUID();\n            _buffer2.default._renderList.add(name, task);\n        }\n        //材质动画\n\n    }, {\n        key: 'setTextureAnimation',\n        value: function setTextureAnimation(tilesHoriz, tilesVert, numTiles, tileDispDuration, onlyOnce) {\n            onlyOnce = onlyOnce === undefined ? false : onlyOnce;\n            tileDispDuration = tileDispDuration || 1;\n            var tilesHorizontal = tilesHoriz;\n            var tilesVertical = tilesVert;\n            var numberOfTiles = numTiles;\n            var texture = this.texture;\n            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n            texture.repeat.set(1 / tilesHorizontal, 1 / tilesVertical);\n            var tileDisplayDuration = tileDispDuration;\n            var currentDisplayTime = 0;\n            var currentTile = 0;\n            var task = {\n                update: function update(sec) {\n                    currentDisplayTime += sec;\n                    while (currentDisplayTime > tileDisplayDuration) {\n                        currentDisplayTime -= tileDisplayDuration;\n                        currentTile++;\n                        if (currentTile === numberOfTiles) {\n                            if (onlyOnce) {\n                                return;\n                            } else {\n                                currentTile = 0;\n                            }\n                        }\n\n                        var currentColumn = currentTile % tilesHorizontal;\n                        texture.offset.x = currentColumn / tilesHorizontal;\n                        var currentRow = Math.floor(currentTile / tilesHorizontal);\n                        texture.offset.y = currentRow / tilesVertical;\n                    }\n                    _buffer2.default.bigDirty = true;\n                }\n            };\n            var name = texture.uuid;\n            _buffer2.default._renderList.add(name, task);\n        }\n    }, {\n        key: 'setAnimation',\n        value: function setAnimation(name, data) {\n            switch (name) {\n                case \"scrollAnim\":\n                    this.setScrollAnimation(data[0], data[1]);\n                    break;\n                case \"rotateAnim\":\n                    this.setRotateAnimation(data);\n                    break;\n                case \"multiFramesAnim\":\n                    var nums = data.tilesX * data.tilesY;\n                    var tileDispDuration = 1.0 / data.animSpeed;\n                    this.setTextureAnimation(data.tilesX, data.tilesY, nums, tileDispDuration);\n            }\n        }\n        //we use reapting instead of it\n        //THREE.RepeatWrapping or THREE.MirroredRepeatWrapping works well\n\n    }, {\n        key: 'setTextureScale',\n        value: function setTextureScale(u, v) {\n            if (!this.texture) {\n                this.params.scale = [u, v];\n                return;\n            }\n            if (this.material.type === 'MeshLineMaterial' || this.material.type === 'BuildingMaterial') {\n                this.material.uniforms.repeat.value.x = 1.0 / u;\n                this.material.uniforms.repeat.value.y = 1.0 / v;\n            } else {\n                this.texture.wrapS = THREE.RepeatWrapping;\n                this.texture.wrapT = THREE.RepeatWrapping;\n                var xScal = 1.0 / u;\n                var yScal = 1.0 / v;\n                if (xScal && yScal) {\n                    this.texture.repeat.set(xScal, yScal);\n                } else {\n                    console.warn('传入的缩放参数不正常');\n                }\n            }\n            _buffer2.default.bigDirty = true;\n        }\n        //todo\n\n    }, {\n        key: 'setTextureAddressingMode',\n        value: function setTextureAddressingMode() {\n            var TextureAddressingMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n            if (!this.texture) {\n                this.params.TextureAddressingMode = TextureAddressingMode;\n                return;\n            }\n            var tex = this.texture;\n\n            switch (TextureAddressingMode) {\n                case 1:\n                    tex.wrapS = THREE.MirroredRepeatWrapping;\n                    tex.wrapT = THREE.MirroredRepeatWrapping;\n                    break;\n                case 2:\n                    tex.wrapS = THREE.ClampToEdgeWrapping;\n                    tex.wrapT = THREE.ClampToEdgeWrapping;\n                    break;\n                default:\n                    tex.wrapS = THREE.RepeatWrapping;\n                    tex.wrapT = THREE.RepeatWrapping;\n                    break;\n            }\n            _buffer2.default.bigDirty = true;\n        }\n        //todo mipmap is not used\n\n    }, {\n        key: 'setTextureFiltering',\n        value: function setTextureFiltering() {\n            var TextureFilterOption = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n            if (!this.texture) {\n                this.params.TextureFilterOption = TextureFilterOption;\n                return;\n            }\n            var tex = this.texture;\n\n            switch (TextureFilterOption) {\n                case 1:\n                    tex.minFilter = THREE.LinearFilter;\n                    tex.magFilter = THREE.LinearFilter;\n                    break;\n                case 2:\n                    tex.minFilter = THREE.LinearFilter;\n                    tex.magFilter = THREE.LinearFilter;\n                    break;\n                default:\n                    tex.minFilter = THREE.NearestFilter;\n                    tex.magFilter = THREE.NearestFilter;\n                    break;\n            }\n            _buffer2.default.bigDirty = true;\n        }\n    }, {\n        key: 'setAlphaOperation',\n        value: function setAlphaOperation(operation, source1, source2, alphaArg1, alphaArg2, factor) {\n            if (alphaArg1 === undefined) {\n                return;\n            }\n            this.material.opacity = alphaArg1;\n            _buffer2.default.bigDirty = true;\n        }\n    }, {\n        key: 'setTextureAnisotropy',\n        value: function setTextureAnisotropy(nums) {\n            if (!this.texture) {\n                this.params.anisotropy = nums;\n                return;\n            }\n            var maxNums = _buffer2.default.maxAnisotropy;\n            if (nums > maxNums) {\n                this.texture.anisotropy = maxNums;\n            } else {\n                this.texture.anisotropy = nums;\n            }\n            _buffer2.default.bigDirty = true;\n        }\n        //_mat is from the pass\n\n    }, {\n        key: '_clone',\n        value: function _clone(_mat) {\n            var texture = _mat.map;\n            if (texture) {\n                var newTex = texture.clone();\n            }\n            var newTexUnit = new TexUnit(_mat, newTex, this.option, this.index);\n            return newTexUnit;\n        }\n    }, {\n        key: 'getTextureName',\n        value: function getTextureName() {\n            return this.name ? this.name : '';\n        }\n    }, {\n        key: 'setColourOperationEx',\n        value: function setColourOperationEx(operation, source1, source2, colourArg1, colourArg2, factor) {\n            if (colourArg1 && colourArg1.length) {\n                this.material.color = new THREE.Color(colourArg1[0], colourArg1[1], colourArg1[2]);\n            }\n        }\n    }, {\n        key: 'setColourOperation',\n        value: function setColourOperation() {}\n        //TODO 目前只支持scroll_anim\n\n    }, {\n        key: 'parseScriptLine',\n        value: function parseScriptLine(arr) {\n            if (typeof arr !== 'string') return;\n            if (arr.split('scroll_anim').length > 1) {\n                var data = arr.split('scroll_anim')[1];\n                var u = parseFloat(data.split(' ')[1]);\n                var v = parseFloat(data.split(' ')[2]);\n                this.params.scrollAnimation.push(u);\n                this.params.scrollAnimation.push(v);\n                this.setScrollAnimation(u, v);\n            } else if (arr.indexOf('colour_op_ex') !== -1) {\n                var res = arr.split(' ');\n                this.setColourOperationEx(res[1], res[2], res[3], [res[4], res[5], res[6]]);\n            }\n            _buffer2.default.bigDirty = true;\n        }\n    }]);\n\n    return TexUnit;\n}();\n\nexports.default = TexUnit;\n\n//# sourceURL=webpack:///./src/material/TexUnit.js?")
        },
        "./src/material/TextureAddressingMode.js": /*!***********************************************!*\
  !*** ./src/material/TextureAddressingMode.js ***!
  \***********************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.default = {\n    /** Texture wraps at values over 1.0 */\n    WRAP: 0,\n    /** Texture mirrors (flips) at joins over 1.0 */\n    MIRROR: 1,\n    /** Texture clamps at 1.0 */\n    CLAMP: 2,\n    /** Texture coordinates outside the range [0.0, 1.0] are set to the border colour */\n    BORDER: 3\n};\n\n//# sourceURL=webpack:///./src/material/TextureAddressingMode.js?')
        },
        "./src/material/materialCache.js": /*!***************************************!*\
  !*** ./src/material/materialCache.js ***!
  \***************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _Material = __webpack_require__(/*! ./Material.js */ \"./src/material/Material.js\");\n\nvar _Material2 = _interopRequireDefault(_Material);\n\nvar _specialTextures = __webpack_require__(/*! ./specialMaterial/specialTextures.json */ \"./src/material/specialMaterial/specialTextures.json\");\n\nvar _specialTextures2 = _interopRequireDefault(_specialTextures);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n    createMaterialCache: function createMaterialCache() {\n        //创建一些特殊材质\n        var blackSpriteMaterial = new _Material2.default('_sprite_black', 'SpriteMaterial');\n        blackSpriteMaterial.getTechnique(0).getPass(0).setDiffuse([0, 0, 0, 1]);\n        // Material cache\n        var mats = _specialTextures2.default.materials;\n        for (var key in mats) {\n            var textures = mats[key];\n            var material = new _Material2.default(key, key);\n            //特殊材质默认不透明\n            var orginMat = material.getTechnique(0).getPass(0).material;\n            orginMat.transparent = false;\n            if (key === 'test') {\n                var testMat = material.clone('test2');\n                testMat.getTechnique(0).getPass(0).material.transparent = true;\n                var testMat1 = material.clone('test3');\n                testMat1.getTechnique(0).getPass(0).material.uniforms.color.value = new THREE.Color(1, 1, 1);\n                var BaseRedNoLightingMat = material.clone('BaseRedNoLighting');\n                BaseRedNoLightingMat.getTechnique(0).getPass(0).material.uniforms.color.value = new THREE.Color(1, 0, 0);\n            }\n            if (key === 'fog') {\n                orginMat.transparent = true;\n            }\n            if (key === \"AtmosphereFromSpace\") {\n                material.getTechnique(0).getPass(0).material.transparent = true;\n            }\n            if (textures && textures.length > 0) {\n                var pass = material.getTechnique(0).getPass(0);\n                for (var i = 0; i < textures.length; i++) {\n                    pass.createTextureUnitState();\n                }\n            }\n        }\n    }\n};\n\n//# sourceURL=webpack:///./src/material/materialCache.js?")
        },
        "./src/material/materialFactory.js": /*!*****************************************!*\
  !*** ./src/material/materialFactory.js ***!
  \*****************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _multMaterial = __webpack_require__(/*! ./specialMaterial/multMaterial.js */ \"./src/material/specialMaterial/multMaterial.js\");\n\nvar _multMaterial2 = _interopRequireDefault(_multMaterial);\n\nvar _scanningMaterial = __webpack_require__(/*! ./specialMaterial/scanningMaterial.js */ \"./src/material/specialMaterial/scanningMaterial.js\");\n\nvar _scanningMaterial2 = _interopRequireDefault(_scanningMaterial);\n\nvar _testMaterial = __webpack_require__(/*! ./specialMaterial/testMaterial.js */ \"./src/material/specialMaterial/testMaterial.js\");\n\nvar _testMaterial2 = _interopRequireDefault(_testMaterial);\n\nvar _MeshLine = __webpack_require__(/*! ../extra/MeshLine.js */ \"./src/extra/MeshLine.js\");\n\nvar _BuildingMaterial = __webpack_require__(/*! ../extra/BuildingMaterial.js */ \"./src/extra/BuildingMaterial.js\");\n\nvar _FaceIDMeshLine = __webpack_require__(/*! ../extra/FaceIDMeshLine.js */ \"./src/extra/FaceIDMeshLine.js\");\n\nvar _buffer = __webpack_require__(/*! ../util/buffer.js */ \"./src/util/buffer.js\");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//all the materials in threejs\nexports.default = {\n    createMaterial: function createMaterial(option, params) {\n        var material;\n        //params = params || {side: THREE.DoubleSide};\n        params = params || {};\n        switch (option) {\n            case 'ScanningMaterial':\n                material = new THREE.ScanningMaterial(params);\n                break;\n            case 'MeshStandardMaterial':\n                material = new THREE.MeshStandardMaterial(params);\n                //material = T3dMaterial.createT3dMaterial(params);\n                break;\n            case 'MeshBasicMaterial':\n                material = new THREE.MeshBasicMaterial(params);\n                break;\n            case 'MeshDepthMaterial':\n                material = new THREE.MeshDepthMaterial(params);\n                break;\n            case 'MeshLambertMaterial':\n                material = new THREE.MeshLambertMaterial(params);\n                break;\n            case 'MeshPhysicalMaterial':\n                material = new THREE.MeshPhysicalMaterial(params);\n                break;\n            case 'MeshPhongMaterial':\n                material = new THREE.MeshPhongMaterial(params);\n                break;\n            case 'SpriteMaterial':\n                material = new THREE.SpriteMaterial(params);\n                break;\n            case 'LineBasicMaterial':\n                material = new THREE.LineBasicMaterial();\n                break;\n            case 'Material1':\n                material = _multMaterial2.default.createMultMaterial(1);\n                material.fog = true;\n                material.lights = true;\n                break;\n            case 'Material2':\n                material = _multMaterial2.default.createMultMaterial(2);\n                material.fog = true;\n                material.lights = true;\n                break;\n            case 'Material3':\n                material = _multMaterial2.default.createMultMaterial(3);\n                material.fog = true;\n                material.lights = true;\n                break;\n            case 'Material4':\n                material = _multMaterial2.default.createMultMaterial(4);\n                material.fog = true;\n                material.lights = true;\n                break;\n            case 'Material5':\n                material = _multMaterial2.default.createMultMaterial(5);\n                material.fog = true;\n                material.lights = true;\n                break;\n            case 'Material6':\n                material = _multMaterial2.default.createMultMaterial(6);\n                material.fog = true;\n                material.lights = true;\n                break;\n            case 'Material7':\n                material = _multMaterial2.default.createMultMaterial(7);\n                material.fog = true;\n                material.lights = true;\n                break;\n            case 'Material8':\n                material = _multMaterial2.default.createMultMaterial(8);\n                material.fog = true;\n                material.lights = true;\n                break;\n            case 'Material9':\n                material = _multMaterial2.default.createMultMaterial(9);\n                material.fog = true;\n                material.lights = true;\n                break;\n            case 'Material10':\n                material = _multMaterial2.default.createMultMaterial(10);\n                material.fog = true;\n                material.lights = true;\n                break;\n            case 'Material11':\n                material = _multMaterial2.default.createMultMaterial(11);\n                material.fog = true;\n                material.lights = true;\n                break;\n            case 'Material12':\n                material = _multMaterial2.default.createMultMaterial(12);\n                material.fog = true;\n                material.lights = true;\n                break;\n            case 'AtmosphereFromSpace':\n                material = _multMaterial2.default.createAtmosphereMaterial();\n                material.fog = true;\n                break;\n            case 'test':\n                material = _testMaterial2.default.createTestMaterial();\n                break;\n            case 'fog':\n                material = _testMaterial2.default.createFogMaterial();\n                break;\n            case 'test1':\n                material = _testMaterial2.default.createTest1Material();\n                break;\n            case 'projector':\n                material = _testMaterial2.default.createProjectorMaterial();\n                break;\n            case 'MeshLineMaterial':\n                material = new _MeshLine.MeshLineMaterial({\n                    color: new THREE.Color(1, 1, 1),\n                    opacity: 1, //params.strokes ? .5 : 1,\n                    sizeAttenuation: false,\n                    lineWidth: 10,\n                    //transparent:true,\n                    resolution: new THREE.Vector2(window.innerWidth, window.innerHeight),\n                    near: THREE._t3dCamera.near,\n                    far: THREE._t3dCamera.far,\n                    side: THREE.DoubleSide\n                });\n                if (params.map) {\n                    material.uniforms.map.value = params.map;\n                    material.uniforms.useMap.value = 1;\n                }\n                material.defines = {\n                    USE_LOGDEPTHBUF: _buffer2.default.logDepth,\n                    USE_LOGDEPTHBUF_EXT: _buffer2.default.logDepth\n                };\n                break;\n            case 'FaceIDMeshLineMaterial':\n                material = new _FaceIDMeshLine.FaceIDMeshLineMaterial({\n                    color: new THREE.Color(1, 1, 1),\n                    opacity: 1, //params.strokes ? .5 : 1,\n                    sizeAttenuation: false,\n                    lineWidth: 10,\n                    //transparent:true,\n                    resolution: new THREE.Vector2(window.innerWidth, window.innerHeight),\n                    near: THREE._t3dCamera.near,\n                    far: THREE._t3dCamera.far,\n                    side: THREE.DoubleSide,\n                    baseId: 0\n                });\n                break;\n            case 'gpuMaterial':\n                material = _testMaterial2.default.createGpuMaterial();\n                break;\n\n            case 'BuildingMaterial':\n                material = new _BuildingMaterial.BuildingMaterial({\n                    color: new THREE.Color(1, 0, 1),\n                    opacity: 1, //params.strokes ? .5 : 1,\n                    sizeAttenuation: false,\n                    lineWidth: 10,\n                    //transparent:true,\n                    resolution: new THREE.Vector2(window.innerWidth, window.innerHeight),\n                    near: THREE._t3dCamera.near,\n                    far: THREE._t3dCamera.far,\n                    side: THREE.DoubleSide\n                });\n                if (params.map) {\n                    material.uniforms.map.value = params.map;\n                    material.uniforms.useMap.value = 1;\n                }\n                break;\n\n            case 'bigPointMaterial':\n                material = _testMaterial2.default.createBigPointMaterial();\n                break;\n\n            case 'interpolantMaterial':\n                material = _testMaterial2.default.createInterpolantMaterial();\n                break;\n\n            case 'frustumMaterial':\n                material = _testMaterial2.default.createFrustumMaterial();\n                break;\n            case 'scanningCityMaterial':\n                material = _testMaterial2.default.createScanningCityMaterial();\n                break;\n            case 'standardScanningMaterial':\n                material = _testMaterial2.default.createStandardScanningMaterial();\n                break;\n\n            default:\n                material = new THREE.MeshStandardMaterial(params);\n                //material = T3dMaterial.createT3dMaterial(params);\n                break;\n        }\n        return material;\n    }\n};\n\n//# sourceURL=webpack:///./src/material/materialFactory.js?")
        },
        "./src/material/materialManager.js": /*!*****************************************!*\
  !*** ./src/material/materialManager.js ***!
  \*****************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();\n\nvar _buffer = __webpack_require__(/*! ../util/buffer.js */ "./src/util/buffer.js");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _helper = __webpack_require__(/*! ../util/helper.js */ "./src/util/helper.js");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nvar _Material = __webpack_require__(/*! ./Material.js */ "./src/material/Material.js");\n\nvar _Material2 = _interopRequireDefault(_Material);\n\nvar _materialCache = __webpack_require__(/*! ./materialCache.js */ "./src/material/materialCache.js");\n\nvar _materialCache2 = _interopRequireDefault(_materialCache);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n    createSprite: function createSprite(_ref) {\n        var _ref2 = _slicedToArray(_ref, 3),\n            x = _ref2[0],\n            y = _ref2[1],\n            z = _ref2[2];\n\n        var name = _helper2.default.getUUID();\n        var sprite = new THREE.Sprite();\n        sprite.name = name;\n        sprite.position.set(x, y, z);\n        _buffer2.default.entityBuffer.add(sprite.name, sprite);\n        return sprite;\n    },\n    createMaterial: function createMaterial(name, option) {\n        return new _Material2.default(name, option);\n    },\n    getMaterial: function getMaterial(name) {\n        return _buffer2.default.materialBuffer.get(name);\n    },\n    getByName: function getByName(name) {\n        return _buffer2.default.materialBuffer.get(name);\n    },\n    destroyMaterial: function destroyMaterial(name) {\n        return _buffer2.default.materialBuffer.delete(name);\n    },\n    loadCache: function loadCache() {\n        _materialCache2.default.createMaterialCache();\n    },\n    parseScript: function parseScript() {}\n};\n\n//# sourceURL=webpack:///./src/material/materialManager.js?')
        },
        "./src/material/paramsDataType.js": /*!****************************************!*\
  !*** ./src/material/paramsDataType.js ***!
  \****************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n/**\r\n *some dataType in threejs\r\n */\nexports.default = {\n    Vector2: 'Vector2',\n    Vector3: 'Vector3',\n    Vector4: 'Vector4',\n    COLOR: 'COLOR',\n    TEXTURE: 'TEXTURE',\n    FLOAT: 'FLOAT',\n    INT: 'INT'\n};\n\n//# sourceURL=webpack:///./src/material/paramsDataType.js?")
        },
        "./src/material/shaders/AtmosphereFromSpace.glsl": /*!*******************************************************!*\
  !*** ./src/material/shaders/AtmosphereFromSpace.glsl ***!
  \*******************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval("module.exports = \"        #include <fog_pars_fragment>\\r\\n        #include <logdepthbuf_pars_fragment>\\r\\n\\t\\tvarying vec3 PositionWS;\\r\\n//\\t\\tconst float Km = 0.0015;\\r\\n//\\t\\tconst float Kr = 0.0025;\\r\\n//\\t\\tconst float ESun = 15.0;\\r\\n        varying float v_distance;\\r\\n        uniform float Km;\\r\\n\\t\\tuniform float Kr;\\r\\n\\t\\tuniform float ESun;\\r\\n\\t\\tuniform float fSamples;\\r\\n\\r\\n\\t\\tuniform float g;\\r\\n\\t\\tuniform\\tvec3 v3LightPosInput;\\r\\n\\r\\n\\t\\tuniform\\tfloat fInnerRadius;\\r\\n\\t\\tuniform\\tfloat fOuterRadius;\\r\\n        uniform float night;\\r\\n        uniform float czm_fogDensity;\\r\\n\\t\\tconst float fScaleDepth = 0.25;\\r\\n\\t\\t#define saturate(a) clamp( a, 0.0, 1.0 )\\r\\n        #define whiteCompliment(a) ( 1.0 - saturate( a ) )\\r\\n        #define LOG2 1.442695\\r\\n\\r\\n\\t\\t//varying float v_distance;\\r\\n\\r\\n// The scale equation calculated by Vernier's Graphical Analysis\\r\\nfloat scale(float fCos, float fScaleDepth)\\r\\n{\\r\\n\\tfloat x = 1.0 - fCos;\\r\\n\\treturn fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\\r\\n}\\r\\n\\r\\n// Calculates the Mie phase function\\r\\nfloat getMiePhase(float fCos, float fCos2, float g, float g2)\\r\\n{\\r\\n\\treturn 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCos2) / pow(abs(1.0 + g2 - 2.0*g*fCos), 1.5);\\r\\n}\\r\\n// Calculates the Rayleigh phase function\\r\\nfloat getRayleighPhase(float fCos2)\\r\\n{\\r\\n\\t//return 1.0;\\r\\n\\treturn 0.75 + 0.75*fCos2;\\r\\n}\\r\\n// Returns the near intersection point of a line and a sphere\\r\\nfloat getNearIntersection(vec3 v3Pos, vec3 v3Ray, float fDistance2, float fRadius2)\\r\\n{\\r\\n\\tfloat B = 2.0 * dot(v3Pos, v3Ray);\\r\\n\\tfloat C = fDistance2 - fRadius2;\\r\\n\\tfloat fDet = max(0.0, B*B - 4.0 * C);\\r\\n\\treturn 0.5 * (-B - sqrt(fDet));\\r\\n}\\r\\n// Returns the far intersection point of a line and a sphere\\r\\nfloat getFarIntersection(vec3 v3Pos, vec3 v3Ray, float fDistance2, float fRadius2)\\r\\n{\\r\\n\\tfloat B = 2.0 * dot(v3Pos, v3Ray);\\r\\n\\tfloat C = fDistance2 - fRadius2;\\r\\n\\tfloat fDet = max(0.0, B*B - 4.0 * C);\\r\\n\\treturn 0.5 * (-B + sqrt(fDet));\\r\\n}\\r\\n\\r\\n\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor) {\\r\\n    float scalar = distanceToCamera * czm_fogDensity;\\r\\n    float fog = 1.0 - exp(-(scalar * scalar));\\r\\n    return mix(color, fogColor, fog);\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nvoid main()\\r\\n{\\r\\n    #include <logdepthbuf_fragment>\\r\\n\\tfloat PI = 3.14159265;\\r\\n\\tfloat g2 =  g * g;\\r\\n\\r\\n\\tvec3 v3InvWavelength = vec3(1.0 / pow(0.650, 4.0), 1.0 / pow(0.570, 4.0), 1.0 / pow(0.475, 4.0));\\r\\n\\r\\n\\t//vec4 v3CameraPos = -vec4(0,0,20,1);\\r\\n\\t//vec3 v3LightPosInput = vec4(0.5773502691896258f,0.5773502691896258f,0.5773502691896258f,1);\\r\\n\\tvec3 v3CameraPos = cameraPosition;\\r\\n    //vec3 v3CameraPos = cameraPosition;\\r\\n\\tvec3 v3LightPos = v3LightPosInput / length(v3LightPosInput);\\r\\n\\r\\n\\tfloat fCameraHeight = length(v3CameraPos);\\r\\n\\tfloat fCameraHeight2 = fCameraHeight * fCameraHeight;\\r\\n\\r\\n\\t//float inOutFactor = 1.05;\\r\\n\\r\\n\\tfloat fInnerRadius2 = fInnerRadius * fInnerRadius;\\r\\n\\tfloat fOuterRadius2 = fOuterRadius * fOuterRadius;\\r\\n\\r\\n\\r\\n\\tfloat fKrESun = Kr * ESun;\\r\\n\\tfloat fKmESun = Km * ESun;\\r\\n\\tfloat fKr4PI = Kr * 4.0 * PI;\\r\\n\\tfloat fKm4PI = Km * 4.0 * PI;\\r\\n\\t//float fScaleDepth = 0.25f;\\r\\n\\tfloat fInvScaleDepth = 1.0 / fScaleDepth;\\r\\n\\tfloat fScale = 1.0 / (fOuterRadius - fInnerRadius);\\r\\n\\tfloat fScaleOverScaleDepth = fScale / fScaleDepth;\\r\\n\\r\\n\\t////////////////////////////////////////////////////////////////////\\r\\n\\t//return vec4(0, 1, 0, 1);\\r\\n\\t// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\\r\\n//\\tvec3 v3Pos = PositionWS;\\r\\n    vec3 v3Pos = PositionWS;\\r\\n\\tvec3 v3Ray = v3Pos - v3CameraPos;\\r\\n\\tfloat fFar = length(v3Ray);\\r\\n\\tv3Ray /= fFar;\\r\\n\\r\\n\\tvec3 v3Start;\\r\\n\\tfloat fStartAngle;\\r\\n\\tfloat fStartOffset;\\r\\n\\tfloat fHeight;\\r\\n\\tfloat fDepth;\\r\\n\\tif(fCameraHeight > fOuterRadius){\\r\\n\\t\\t// Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\\r\\n\\t\\tfloat fNear = getNearIntersection(v3CameraPos, v3Ray, fCameraHeight2, fOuterRadius2);\\r\\n\\t\\t// Calculate the ray's start and end positions in the atmosphere, then calculate its scattering offset\\r\\n\\t\\tv3Start = v3CameraPos + v3Ray * fNear;\\r\\n\\t\\tfFar -= fNear;\\r\\n\\t\\tfStartAngle = dot(v3Ray, v3Start ) / fOuterRadius;\\r\\n\\t\\tfloat fStartDepth = exp(-fInvScaleDepth);\\r\\n\\t\\tfStartOffset = fStartDepth*scale(fStartAngle, fScaleDepth);\\r\\n\\t}\\r\\n\\telse{\\r\\n\\t\\t// Calculate the ray's starting position, then calculate its scattering offset\\r\\n\\t\\tv3Start = v3CameraPos;\\r\\n\\t\\tfHeight = length(v3Start);\\r\\n\\t\\tfDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fCameraHeight));\\r\\n\\t\\tfStartAngle = dot(v3Ray, v3Start) / fHeight;\\r\\n\\t\\tfStartOffset = fDepth*scale(fStartAngle, fScaleDepth);\\r\\n\\t}\\r\\n\\r\\n\\t// Initialize the scattering loop variables\\r\\n\\tfloat fSampleLength = fFar / fSamples;\\r\\n\\tfloat fScaledLength = fSampleLength * fScale;\\r\\n\\tvec3 v3SampleRay = v3Ray * fSampleLength;\\r\\n\\tvec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\\r\\n\\t// Now loop through the sample rays\\r\\n\\tvec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\\r\\n\\tfor(int i=0; i<2; i++)\\r\\n\\t{\\r\\n\\t  fHeight = length(v3SamplePoint);\\r\\n\\t  fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\\r\\n//\\t  float fLightAngle = dot(v3LightPos, v3SamplePoint ) / fHeight;\\r\\n       float fLightAngle = night > 0.0 ? dot(v3LightPos, v3SamplePoint ) / fHeight : 1.0;\\r\\n\\t  float fCameraAngle = dot(v3Ray, v3SamplePoint  ) / fHeight;\\r\\n\\t  float fScatter = (fStartOffset + fDepth*(scale(fLightAngle, fScaleDepth) - scale(fCameraAngle, fScaleDepth)));\\r\\n\\t  vec3 v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\\r\\n\\t  v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\\r\\n\\t  v3SamplePoint += v3SampleRay;\\r\\n\\t}\\r\\n\\t// Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\\r\\n\\tvec3 c0 = v3FrontColor * (v3InvWavelength * fKrESun);\\r\\n\\tvec3 c1 = v3FrontColor * fKmESun;\\r\\n\\tvec3 v3Direction = v3CameraPos - v3Pos;\\r\\n\\tfloat fCos = dot(v3LightPos, v3Direction ) / length(v3Direction);\\r\\n\\tfloat fCos2 = fCos*fCos;\\r\\n\\tvec3 color = getRayleighPhase(fCos2) * c0 + getMiePhase(fCos, fCos2, g, g2) * c1;\\r\\n\\tvec4 AtmoColor = vec4(color, color.b);\\r\\n\\r\\n\\r\\n\\t const float fExposure = 2.0;\\r\\n    vec3 fogColor1 = vec3(1.0) - exp(-fExposure * AtmoColor.rgb);\\r\\n     AtmoColor = vec4(czm_fog(v_distance, AtmoColor.rgb, fogColor1), AtmoColor.a);\\r\\n\\tgl_FragColor = vec4(fogColor1, AtmoColor.a);\\r\\n\\t#include <fog_fragment>\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"\n\n//# sourceURL=webpack:///./src/material/shaders/AtmosphereFromSpace.glsl?")
        },
        "./src/material/shaders/alphamap_fragment.glsl": /*!*****************************************************!*\
  !*** ./src/material/shaders/alphamap_fragment.glsl ***!
  \*****************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "\\r\\n\\r\\n\\r\\n#ifdef USE_ALPHAMAP\\r\\n\\r\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv).g;\\r\\n\\r\\n#endif\\r\\n#ifdef USE_UV3\\r\\n\\r\\n\\tdiffuseColor.a *= texture2D( alphaMap1, vUv3).g;\\r\\n\\r\\n#endif\\r\\n\\r\\n//#ifdef USE_ALPHAMAP1\\r\\n//\\r\\n//\\tdiffuseColor.a *= texture2D( alphaMap, vUv3).g;\\r\\n//\\r\\n//#endif\\r\\n\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/alphamap_fragment.glsl?')
        },
        "./src/material/shaders/alphamap_pars_fragment.glsl": /*!**********************************************************!*\
  !*** ./src/material/shaders/alphamap_pars_fragment.glsl ***!
  \**********************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "#ifdef USE_ALPHAMAP\\r\\n\\r\\n\\tuniform sampler2D alphaMap;\\r\\n\\r\\n\\r\\n\\r\\n#endif\\r\\nuniform float aoMapFactor;\\r\\nuniform float aoFactor;\\r\\n//uniform float gamma;\\r\\n\\r\\n\\r\\n\\r\\n#ifdef USE_UV3\\r\\n\\r\\n\\tuniform sampler2D alphaMap1;\\r\\n\\r\\n#endif"\n\n//# sourceURL=webpack:///./src/material/shaders/alphamap_pars_fragment.glsl?')
        },
        "./src/material/shaders/aomap_fragment.glsl": /*!**************************************************!*\
  !*** ./src/material/shaders/aomap_fragment.glsl ***!
  \**************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "#ifdef USE_AOMAP\\r\\n        #ifdef WALL_AO\\r\\n\\t\\t\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity * 0.5 + 1.5;\\r\\n\\t    \\t#else\\r\\n        \\t\\t\\t#ifdef FLOOR_AO\\r\\n        \\t\\t\\t\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\r\\n        \\t\\t\\t#else\\r\\n        \\t\\t\\t\\t float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + (aoMapFactor -1.0)/2.0+1.0;\\r\\n        \\t\\t\\t#endif\\r\\n        \\t#endif\\r\\n\\r\\n        //float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * 1.6 + 2.4;\\r\\n\\t    //reflectedLight.indirectDiffuse *= ambientOcclusion;\\r\\n\\r\\n\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\r\\n\\r\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\r\\n\\r\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\r\\n\\r\\n\\t#endif\\r\\n#else\\r\\n    float ambientOcclusion = (aoFactor -1.0)/2.0+1.0;\\r\\n#endif"\n\n//# sourceURL=webpack:///./src/material/shaders/aomap_fragment.glsl?')
        },
        "./src/material/shaders/atmosphere_vs.glsl": /*!*************************************************!*\
  !*** ./src/material/shaders/atmosphere_vs.glsl ***!
  \*************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "//顶点稍后再说\\r\\nprecision highp float;\\r\\nvarying vec3 PositionWS;\\r\\n//varying vec3 ModelPostion;\\r\\nvarying float v_distance;\\r\\nuniform vec4 objectPos;\\r\\n#include <fog_pars_vertex>\\r\\n#include <logdepthbuf_pars_vertex>\\r\\n#include <common>\\r\\n\\r\\n\\r\\nvoid main( )\\r\\n{\\r\\n        vec3 czm_position = vec3(0.0);\\r\\n             czm_position = position;\\r\\n     vec4 worldPosition = modelMatrix * vec4( czm_position, 1.0 );\\r\\n                PositionWS =  czm_position.xyz + objectPos.xyz;\\r\\n                v_distance = length((modelViewMatrix * vec4(czm_position.xyz, 1.0)).xyz);\\r\\n\\t vec4 mvPosition = modelViewMatrix * vec4( czm_position, 1.0 );\\r\\n        #include <fog_vertex>\\r\\n    \\tgl_Position = projectionMatrix * mvPosition;\\r\\n    \\t#include <logdepthbuf_vertex>\\r\\n}"\n\n//# sourceURL=webpack:///./src/material/shaders/atmosphere_vs.glsl?')
        },
        "./src/material/shaders/bigpoint_fragment.glsl": /*!*****************************************************!*\
  !*** ./src/material/shaders/bigpoint_fragment.glsl ***!
  \*****************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "#ifdef USE_MAP\\r\\n\\tuniform sampler2D tex;\\r\\n\\tuniform vec2 imageSize;\\r\\n#endif\\r\\nuniform float size;\\r\\nvarying vec2 vUv;\\r\\nvarying vec4 vColor;\\r\\nuniform vec3 ptColor;\\r\\nuniform float opacity;\\r\\n#ifdef USE_UVMAP\\r\\n\\tuniform sampler2D uvMap;\\r\\n\\tuniform vec2 offset;\\r\\n#endif\\r\\n#ifdef USE_GPUPICKER\\r\\n\\tvarying vec4 worldId;\\t\\r\\n#endif\\r\\nuniform float strength;\\r\\n#include <logdepthbuf_pars_fragment>\\r\\nvoid main() {\\r\\n\\t#include <logdepthbuf_fragment>\\r\\n\\tif(size <= 0.0){\\r\\n\\t\\tdiscard;\\r\\n\\t}\\r\\n\\tgl_FragColor = vColor;\\r\\n\\t#ifdef USE_MAP\\r\\n\\t\\tfloat ratio = imageSize[1] / imageSize[0];\\r\\n\\t\\tvec2 texCoord;\\r\\n\\t\\t//调整图片宽高比\\r\\n\\t\\tif(ratio > 1.0){\\r\\n\\t\\t\\ttexCoord = vec2(gl_PointCoord.x*ratio + (1.0-ratio)/2.0, 1.0-gl_PointCoord.y);\\r\\n\\t\\t}\\r\\n\\t\\telse{\\r\\n\\t\\t\\ttexCoord = vec2(gl_PointCoord.x, 1.0-gl_PointCoord.y/ratio - (1.0 - 1.0/ratio )/2.0);\\r\\n\\t\\t}\\r\\n\\t\\tgl_FragColor = gl_FragColor * texture2D( tex, texCoord );\\r\\n\\t\\t\\r\\n\\t\\tif(texCoord[0]<0.0 || texCoord[0] >1.0 ||texCoord[1]<0.0 || texCoord[1] >1.0){\\r\\n\\t\\t\\tdiscard;\\r\\n\\t\\t}\\r\\n\\t#endif\\r\\n\\t#ifdef USE_GPUPICKER\\r\\n\\t\\tgl_FragColor = worldId;\\r\\n\\t\\treturn;\\r\\n\\t#endif\\r\\n\\r\\n\\t#ifdef USE_UVMAP\\r\\n\\t\\t\\tgl_FragColor.a *= opacity;\\r\\n\\t\\t\\tgl_FragColor.a *= texture2D( uvMap, vUv + offset ).r;\\r\\n\\t#endif\\r\\n\\t\\t\\tgl_FragColor *= vec4(ptColor,opacity);\\r\\n\\t\\t\\tgl_FragColor *= strength;\\r\\n}\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/bigpoint_fragment.glsl?')
        },
        "./src/material/shaders/bigpoint_vertex.glsl": /*!***************************************************!*\
  !*** ./src/material/shaders/bigpoint_vertex.glsl ***!
  \***************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "\\r\\n\\t\\t\\tuniform float size;\\r\\n\\t\\t\\tattribute vec4 color;\\r\\n\\t\\t\\tvarying vec4 vColor;\\r\\n\\t\\t\\tvarying vec2 vUv;\\r\\n\\t\\t\\tattribute float vis;\\r\\n\\t\\t\\t#ifdef USE_GPUPICKER\\r\\n\\t\\t\\t\\tattribute float id;\\r\\n\\t\\t\\t\\tvarying vec4 worldId;\\r\\n\\t\\t\\t#endif\\r\\n\\t\\t\\t#include <common>\\r\\n\\t\\t\\t#include <logdepthbuf_pars_vertex>\\r\\n\\r\\n\\t\\t\\tvoid main() {\\r\\n\\r\\n\\t\\t\\t\\tvColor = color;\\r\\n\\r\\n\\t\\t\\t\\tvUv = uv;\\r\\n\\r\\n\\t\\t\\t\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\r\\n\\r\\n\\t\\t\\t\\tgl_PointSize = size;\\r\\n\\r\\n\\t\\t\\t\\t#ifdef USE_GPUPICKER\\r\\n\\t\\t\\t\\tfloat baseId = id;\\r\\n                vec3 a = fract(vec3(1.0/255.0, 1.0/(255.0*255.0), 1.0/(255.0*255.0*255.0)) * baseId);\\r\\n                a -= a.xxy * vec3(0.0, 1.0/255.0, 1.0/255.0);\\r\\n                worldId = vec4(a,1);\\r\\n                #endif\\r\\n\\r\\n\\t\\t\\t\\tgl_Position = projectionMatrix * mvPosition * vis;\\r\\n\\t\\t\\t\\t#include <logdepthbuf_vertex>\\r\\n\\r\\n\\t\\t\\t}\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/bigpoint_vertex.glsl?')
        },
        "./src/material/shaders/color_fragment.glsl": /*!**************************************************!*\
  !*** ./src/material/shaders/color_fragment.glsl ***!
  \**************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "\\r\\n//diffuseColor.rgb = diffuseColor.rgb*(1.0-alphaColor.a)+alphaColor.rgb*alphaColor.a;\\r\\n#ifdef USE_COLOR\\r\\n\\r\\n\\tdiffuseColor.rgb *= vColor;\\r\\n\\r\\n#endif\\r\\n\\r\\n#ifdef USE_ALPHAINDEX\\r\\n\\r\\n\\tdiffuseColor.a *= vAlpha;\\r\\n\\r\\n#endif\\r\\n\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/color_fragment.glsl?')
        },
        "./src/material/shaders/color_pars_fragment.glsl": /*!*******************************************************!*\
  !*** ./src/material/shaders/color_pars_fragment.glsl ***!
  \*******************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "#ifdef USE_COLOR\\r\\n\\r\\n\\tvarying vec3 vColor;\\r\\n//varying vec4 vColor;\\r\\n\\r\\n#endif\\r\\n\\r\\n//uniform vec4 alphaColor;\\r\\n//#ifdef USE_COLOR1\\r\\n//\\r\\n//\\tvarying vec4 vColor1;\\r\\n//\\r\\n//#endif\\r\\n\\r\\n#ifdef USE_ALPHAINDEX\\r\\n\\r\\n\\tvarying float vAlpha;\\r\\n\\r\\n#endif"\n\n//# sourceURL=webpack:///./src/material/shaders/color_pars_fragment.glsl?')
        },
        "./src/material/shaders/color_pars_vertex.glsl": /*!*****************************************************!*\
  !*** ./src/material/shaders/color_pars_vertex.glsl ***!
  \*****************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "#ifdef USE_COLOR\\r\\n\\r\\n\\tvarying vec3 vColor;\\r\\n//varying vec4 vColor;\\r\\n\\r\\n#endif\\r\\n\\r\\n//#ifdef USE_COLOR1\\r\\n//    attribute vec4 color1;\\r\\n//\\tvarying vec4 vColor1;\\r\\n//\\r\\n//#endif\\r\\n\\r\\n#ifdef USE_ALPHAINDEX\\r\\n\\r\\n    attribute float alphaIndex;\\r\\n    varying float vAlpha;\\r\\n\\r\\n#endif"\n\n//# sourceURL=webpack:///./src/material/shaders/color_pars_vertex.glsl?')
        },
        "./src/material/shaders/color_vertex.glsl": /*!************************************************!*\
  !*** ./src/material/shaders/color_vertex.glsl ***!
  \************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "#ifdef USE_COLOR\\r\\n\\r\\n\\tvColor.xyz = color.xyz;\\r\\n//vColor.xyzw = color.xyzw;\\r\\n\\r\\n#endif\\r\\n\\r\\n//#ifdef USE_COLOR1\\r\\n//\\r\\n//\\r\\n//\\tvColor1.xyzw = color1.xyzw;\\r\\n//\\r\\n//#endif\\r\\n\\r\\n#ifdef USE_ALPHAINDEX\\r\\n\\r\\n    vAlpha = alphaIndex;\\r\\n\\r\\n#endif\\r\\n\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/color_vertex.glsl?')
        },
        "./src/material/shaders/emissivemap_fragment.glsl": /*!********************************************************!*\
  !*** ./src/material/shaders/emissivemap_fragment.glsl ***!
  \********************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "#ifdef USE_EMISSIVEMAP\\r\\n\\r\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\r\\n\\r\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\r\\n\\r\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\r\\n\\r\\n#endif\\r\\n\\r\\n#ifdef STANDARD\\r\\n    totalEmissiveRadiance = vec3(0.0,0.0,0.0);\\r\\n    vec3 newEmissiveColor = emissive;\\r\\n      #ifdef USE_EMISSIVEMAP\\r\\n         newEmissiveColor = emissive * emissiveColor.rgb;\\r\\n    #endif\\r\\n\\r\\n  #endif"\n\n//# sourceURL=webpack:///./src/material/shaders/emissivemap_fragment.glsl?')
        },
        "./src/material/shaders/encodings_fragment.glsl": /*!******************************************************!*\
  !*** ./src/material/shaders/encodings_fragment.glsl ***!
  \******************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\\r\\n//  gl_FragColor = LinearToGamma( gl_FragColor, gamma );\\r\\n//  #ifdef USE_AOMAP\\r\\n#ifdef STANDARD\\r\\n  gl_FragColor.rgb *= ambientOcclusion;\\r\\n  #endif\\r\\n\\r\\n#ifdef STANDARD\\r\\n  gl_FragColor.rgb += newEmissiveColor;\\r\\n#endif\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/encodings_fragment.glsl?')
        },
        "./src/material/shaders/frustum_fragment.glsl": /*!****************************************************!*\
  !*** ./src/material/shaders/frustum_fragment.glsl ***!
  \****************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "\\r\\nuniform vec4 boundingBox[6];\\r\\nvarying vec3 vWorldPosition;\\r\\nuniform vec4 color;\\r\\nfloat distanceToPoint(vec4 boundingBox0, vec3 pt){\\r\\n    vec3 normal = vec3(boundingBox0.x, boundingBox0.y, boundingBox0.z);\\r\\n    normal = normalize(normal);\\r\\n    float constant = boundingBox0.w;\\r\\n    float dis0 = -dot(normal, pt) + constant;\\r\\n    return dis0;\\r\\n}\\r\\nvoid main() {\\r\\n\\r\\n                   float res = 1.0;\\r\\n                    for(int j = 0; j < 6; j++){\\r\\n                        float dis = distanceToPoint(boundingBox[j], vWorldPosition);\\r\\n                        if(dis <= 0.0){\\r\\n                            res = 0.0;\\r\\n                            break;\\r\\n                        }\\r\\n                    }\\r\\n\\r\\n\\r\\n        gl_FragColor = sign(res) * color;\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/frustum_fragment.glsl?')
        },
        "./src/material/shaders/frustum_vertex.glsl": /*!**************************************************!*\
  !*** ./src/material/shaders/frustum_vertex.glsl ***!
  \**************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "varying vec2 vUv;\\r\\nvarying vec3 vWorldPosition;\\r\\nvoid main()\\r\\n{\\r\\n\\t//使用插值矩阵进行处理\\r\\n    vUv = uv;\\r\\n     vWorldPosition = (modelMatrix * vec4( position, 1.0 )).xyz;\\r\\n    //gl_Position = ftransform();\\r\\n   gl_Position = projectionMatrix * (modelViewMatrix * vec4( position, 1.0 ));\\r\\n}"\n\n//# sourceURL=webpack:///./src/material/shaders/frustum_vertex.glsl?')
        },
        "./src/material/shaders/gpu_fragment.glsl": /*!************************************************!*\
  !*** ./src/material/shaders/gpu_fragment.glsl ***!
  \************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "\\r\\n    varying vec4 worldId;\\r\\n    void main() {\\r\\n      gl_FragColor = worldId;\\r\\n    }\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/gpu_fragment.glsl?')
        },
        "./src/material/shaders/gpu_vertex.glsl": /*!**********************************************!*\
  !*** ./src/material/shaders/gpu_vertex.glsl ***!
  \**********************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "    uniform float rotation;\\r\\n    uniform vec2 center;\\r\\n    uniform float baseId;\\r\\n    varying vec4 worldId;\\r\\n    void main() {\\r\\n\\r\\n\\r\\n        vec3 a = fract(vec3(1.0/255.0, 1.0/(255.0*255.0), 1.0/(255.0*255.0*255.0)) * baseId);\\r\\n        a -= a.xxy * vec3(0.0, 1.0/255.0, 1.0/255.0);\\r\\n        worldId = vec4(a,1);\\r\\n\\r\\n        vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\r\\n\\r\\n      \\tvec2 rotatedPosition;\\r\\n      \\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\r\\n      \\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\r\\n\\r\\n      \\tmvPosition.xy += rotatedPosition;\\r\\n\\r\\n      \\tgl_Position = projectionMatrix * mvPosition;\\r\\n    }"\n\n//# sourceURL=webpack:///./src/material/shaders/gpu_vertex.glsl?')
        },
        "./src/material/shaders/interpolate_fs.glsl": /*!**************************************************!*\
  !*** ./src/material/shaders/interpolate_fs.glsl ***!
  \**************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "#include <common>\\r\\n#include <packing>\\r\\n#include <fog_pars_fragment>\\r\\n#include <logdepthbuf_pars_fragment>\\r\\n#include <lightmap_pars_fragment>\\r\\n#include <bsdfs>\\r\\n#include <lights_pars_begin>\\r\\n#include <lights_physical_pars_fragment>\\r\\n#ifdef USE_LIGHT\\r\\n        varying vec3 vNormal;\\r\\n        varying vec3 vViewPosition;\\r\\n#endif\\r\\nuniform sampler2D tDiffuse;\\r\\nuniform sampler2D colorMapping;\\r\\nuniform vec2 colorRange;\\r\\nuniform vec3 color;\\r\\nvarying vec2 vUV;\\r\\nuniform float opacity;\\r\\n//lights\\r\\nuniform float metalness;\\r\\nuniform float roughness;\\r\\n#ifdef USE_MOSAIC\\r\\nuniform vec2 texSize;\\r\\nuniform vec2 mosaicSize;\\r\\n#endif\\r\\nvec3 filterColor (vec3 texColor){\\r\\n    float range = colorRange.y- colorRange.x;\\r\\n    float gray = (texColor.r*256.0 - colorRange.x)/ range;\\r\\n    vec3 final = texture2D( colorMapping, vec2( gray, 0.5 ) ).rgb;\\r\\n    return final;\\r\\n}\\r\\nvoid main() {\\r\\n   vec4 texColor = texture2D(tDiffuse, vUV);\\r\\n   vec3 diffuseColor = texColor.rgb;\\r\\n   vec3 final = vec3(0.0);\\r\\n   vec4 centerColor = vec4(0.0);\\r\\n   vec2 uvMosaic = vec2(0.0);\\r\\n   if (texColor.a < 0.0001) discard;\\r\\n   #include <logdepthbuf_fragment>\\r\\n   //mosaic\\r\\n    #ifdef USE_MOSAIC\\r\\n        vec2 xy = vec2(vUV.x * texSize.x, vUV.y * texSize.y);\\r\\n        vec2 xyMosaic = vec2(floor(xy.x / mosaicSize.x) * mosaicSize.x,\\r\\n        floor(xy.y / mosaicSize.y) * mosaicSize.y )+ .5*mosaicSize;\\r\\n        vec2 delXY = xyMosaic - xy;\\r\\n        float delL = length(delXY);\\r\\n        uvMosaic = vec2(xyMosaic.x / texSize.x, xyMosaic.y / texSize.y);\\r\\n        float percent = smoothstep(0., 1., 1. - delL * 2.4 / mosaicSize.x) * 0.7 + 0.3;\\r\\n    #endif\\r\\n    #ifdef USE_GrayFilter\\r\\n    final = filterColor(texColor.rgb);\\r\\n    centerColor = texture2D(tDiffuse, uvMosaic);\\r\\n    centerColor.rgb = filterColor(centerColor.rgb);\\r\\n    #else\\r\\n        final = texColor.rgb;\\r\\n        centerColor = texture2D(tDiffuse, uvMosaic);\\r\\n    #endif\\r\\n    // 叠加颜色\\r\\n    final *= vec3(color);\\r\\n    #ifdef USE_LIGHT\\r\\n        vec3 normal = vNormal;\\r\\n        vec3 geometryNormal = normal;\\r\\n        float specularFactor = 1.0;\\r\\n        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\r\\n        float metalnessFactor = metalness;\\r\\n        float roughnessFactor = roughness;\\r\\n        #include <lights_physical_fragment>\\r\\n        #include <lights_fragment_begin>\\r\\n        #include <lights_fragment_maps>\\r\\n        #include <lights_fragment_end>\\r\\n        vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;\\r\\n        final = mix( outgoingLight, final.rgb, 0.5 );\\r\\n    #endif\\r\\n    #ifdef USE_MOSAIC\\r\\n        vec4 originColor =  vec4(final.rgb, 1.0);//background\\r\\n        vec4 resultColor = vec4(mix(originColor.rgb, centerColor.rgb, percent), centerColor.a * percent);\\r\\n        gl_FragColor = resultColor;\\r\\n    #else\\r\\n        gl_FragColor = vec4(final.rgb, texColor.a);\\r\\n    #endif\\r\\n    gl_FragColor.a*=opacity;\\r\\n    #include <fog_fragment>\\r\\n}\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/interpolate_fs.glsl?')
        },
        "./src/material/shaders/interpolate_vs.glsl": /*!**************************************************!*\
  !*** ./src/material/shaders/interpolate_vs.glsl ***!
  \**************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "\\t    #include <common>\\r\\n\\t\\t#include <logdepthbuf_pars_vertex>\\r\\n\\t\\t#include <fog_pars_vertex>\\r\\n\\t\\tvarying vec2 vUV;\\r\\n\\t\\t #ifdef USE_LIGHT\\r\\n\\t\\t        varying vec3 vNormal;\\r\\n                varying vec3 vViewPosition;\\r\\n         #endif\\r\\n        void main() {\\r\\n\\t\\t\\tvUV = uv;\\r\\n\\t\\t\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\r\\n\\t\\t\\t#ifdef USE_LIGHT\\r\\n                    vViewPosition = - mvPosition.xyz;\\r\\n                    vNormal = normal;\\r\\n            #endif\\r\\n\\t\\t\\tgl_Position = projectionMatrix * mvPosition;\\r\\n\\t\\t\\t#include <logdepthbuf_vertex>\\r\\n\\t\\t\\t#include <fog_vertex>\\r\\n        }\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/interpolate_vs.glsl?')
        },
        "./src/material/shaders/map_fragment.glsl": /*!************************************************!*\
  !*** ./src/material/shaders/map_fragment.glsl ***!
  \************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "#ifdef USE_MAP\\r\\n    //add uv2 by zhgu\\r\\n    #ifdef USE_DIFFUSE_UV\\r\\n        vec4 texelColor = texture2D( map, vDiffuseUv );\\r\\n    #else\\r\\n\\t    vec4 texelColor = texture2D( map, vUv );\\r\\n    #endif\\r\\n//        float dark = (texelColor.r + texelColor.g + texelColor.b)/3.0;\\r\\n//         if(dark < 0.1){\\r\\n////            texelColor.rgb =  (2.0 - darkFactor) * texelColor.rgb + (1.0 - darkFactor);\\r\\n//             texelColor.rgb =  pow( texelColor.rgb, vec3( darkFactor ) );\\r\\n//\\r\\n//         }\\r\\n\\t    texelColor = mapTexelToLinear( texelColor );\\r\\n\\t    diffuseColor *= texelColor;\\r\\n#endif\\r\\ndiffuseColor.rgb = diffuseColor.rgb*(1.0-alphaColor.a)+alphaColor.rgb*alphaColor.a;\\r\\n\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/map_fragment.glsl?')
        },
        "./src/material/shaders/map_pars_fragment.glsl": /*!*****************************************************!*\
  !*** ./src/material/shaders/map_pars_fragment.glsl ***!
  \*****************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "#ifdef USE_MAP\\r\\n\\r\\n\\tuniform sampler2D map;\\r\\n\\r\\n#endif\\r\\n\\r\\n    uniform vec4 alphaColor;\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/map_pars_fragment.glsl?')
        },
        "./src/material/shaders/mult_texture1.glsl": /*!*************************************************!*\
  !*** ./src/material/shaders/mult_texture1.glsl ***!
  \*************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "//varying vec4 Position;\\r\\n//precision highp float;\\r\\n//varying vec3 ModelPostion;\\r\\n#include <common>\\r\\n#include <packing>\\r\\n#include <fog_pars_fragment>\\r\\n#include <bsdfs>\\r\\n#include <lights_pars_begin>\\r\\n#include <shadowmap_pars_fragment>\\r\\n#include <shadowmask_pars_fragment>\\r\\n#include <logdepthbuf_pars_fragment>\\r\\nvarying float v_distance;\\r\\nvarying vec3 PositionWS;\\r\\nvarying vec2 texCoords;\\r\\n\\r\\nuniform bool grayFilterEnable;\\r\\nuniform float grayFilterIndex;\\r\\n//uniform float grayMinMax[2];\\r\\n//uniform float grayFilterPerBar[10];\\r\\n//uniform vec3 grayFilterColorBar[10];\\r\\nuniform float shadowOpacity;\\r\\n\\r\\nuniform sampler2D TexSampler0;\\r\\n\\r\\nuniform\\tvec4 textureRectangle0;\\r\\n\\r\\nuniform\\tvec4 textureTransAndScale0;\\r\\n\\r\\nuniform float brightness0;\\r\\n\\r\\nuniform float alphaIndex0;\\r\\n\\r\\nuniform float isAddEffect0;\\r\\nuniform vec4 earthColor0;\\r\\nuniform vec4 earthAddColor0;\\r\\n\\r\\nuniform float south1;\\r\\nuniform float north1;\\r\\nuniform float southMercatorY1;\\r\\nuniform float oneOverMercatorHeight1;\\r\\nuniform float isReProjection;\\r\\n\\r\\n\\r\\n\\r\\nuniform\\tfloat Km;\\r\\nuniform\\tfloat Kr;\\r\\nuniform\\tfloat ESun;\\r\\n\\r\\nuniform int nSamples;\\r\\nuniform float fSamples;\\r\\n\\r\\n//uniform float g,\\r\\n\\r\\n//uniform\\tvec3 v3CameraPosInput;\\r\\nuniform\\tvec3 v3LightPosInput;\\r\\n\\r\\nuniform\\tfloat fInnerRadius;\\r\\nuniform\\tfloat fOuterRadius;\\r\\n\\r\\nuniform float fScaleDepth;\\r\\nuniform\\tvec4 inputColor;\\r\\nuniform vec4 alphaValue;\\r\\n\\r\\nuniform float night;\\r\\n\\r\\nuniform float contrast;\\r\\nuniform float hue;\\r\\nuniform float saturation;\\r\\nuniform float textureGamma;\\r\\n\\r\\nuniform vec4 u_initialColor;\\r\\nuniform float nightfadeIn;\\r\\nuniform float nightfadeOut;\\r\\nuniform float fadeInDist;\\r\\nuniform float fadeOutDist;\\r\\n\\r\\nuniform float czm_fogDensity;\\r\\nuniform sampler2D colorMapping;\\r\\n\\r\\n// 是否开启颜色叠加 0 关闭 1 开启\\r\\nuniform float gradientColorOverlayEnable;\\r\\n// 颜色叠加方向\\r\\nuniform vec3 mapDirection;\\r\\n// 叠加使用的渐变纹理\\r\\nuniform sampler2D gradientColorMap;\\r\\n// 叠加使用的透明度\\r\\nuniform float gradientOpacity;\\r\\n\\r\\n//#define saturate(a) clamp( a, 0.0, 1.0 )\\r\\n//#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\r\\n//#define LOG2 1.442695\\r\\n\\r\\nstruct czm_ellipsoid\\r\\n{\\r\\n    vec3 center;\\r\\n    vec3 radii;\\r\\n    vec3 inverseRadii;\\r\\n    vec3 inverseRadiiSquared;\\r\\n};\\r\\nstruct AtmosphereColor\\r\\n{\\r\\n    vec3 mie;\\r\\n    vec3 rayleigh;\\r\\n};\\r\\n//uniform vec4 earthColor;\\r\\n//uniform vec4 earthAddColor;\\r\\n//uniform float isAddEffect;\\r\\n//搞定\\r\\nfloat scale(float fCos, float fScaleDepth)\\r\\n{\\r\\n\\tfloat x = 1.0 - fCos;\\r\\n\\treturn fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\\r\\n}\\r\\n\\r\\n\\r\\nvec4 depthColor(vec4 color)\\r\\n{\\r\\n     color.r = color.r * color.r * color.r;\\r\\n     color.g = color.g * color.g * color.g;\\r\\n     color.b = color.b * color.b;\\r\\n     return color;\\r\\n}\\r\\n\\r\\n\\r\\n//搞定\\r\\n// Returns the near intersection point of a line and a sphere\\r\\nfloat getNearIntersection(vec3 v3Pos, vec3 v3Ray, float fDistance2, float fRadius2)\\r\\n{\\r\\n\\tfloat B = 2.0 * dot(v3Pos, v3Ray);\\r\\n\\tfloat C = fDistance2 - fRadius2;\\r\\n\\tfloat fDet = max(0.0, B*B - 4.0 * C);\\r\\n\\treturn 0.5 * (-B - sqrt(fDet));\\r\\n}\\r\\n\\r\\n//contrast added by zhgu. we must convert rgb to a right factor.\\r\\nvec3 czm_contrast(vec3 rgb, float contrast){\\r\\n   vec3 color = mix(vec3(0.5), rgb, contrast);\\r\\n    color = clamp(color , 0.0, 1.0);\\r\\n    return color;\\r\\n}\\r\\n\\r\\n//hue added by zhgu\\r\\nvec3 czm_hue(vec3 rgb, float adjustment)\\r\\n{\\r\\n    const mat3 toYIQ = mat3(0.299,     0.587,     0.114,\\r\\n                            0.595716, -0.274453, -0.321263,\\r\\n                            0.211456, -0.522591,  0.311135);\\r\\n    const mat3 toRGB = mat3(1.0,  0.9563,  0.6210,\\r\\n                            1.0, -0.2721, -0.6474,\\r\\n                            1.0, -1.107,   1.7046);\\r\\n    vec3 yiq = toYIQ * rgb;\\r\\n    float hue = atan(yiq.z, yiq.y) + adjustment;\\r\\n    float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\\r\\n    vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\\r\\n    vec3 final = toRGB * color;\\r\\n    final = clamp(final , 0.0, 1.0);\\r\\n    return final;\\r\\n}\\r\\n//saturation added by zhgu\\r\\nvec3 czm_saturation(vec3 rgb, float adjustment)\\r\\n{\\r\\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\\r\\n    vec3 intensity = vec3(dot(rgb, W));\\r\\n    vec3 color = mix(intensity, rgb, adjustment);\\r\\n    color = clamp(color , 0.0, 1.0);\\r\\n    return color;\\r\\n\\r\\n}\\r\\n\\r\\nvec4 sampleAndBlend(\\r\\n    float addEffect,\\r\\n    vec4 eColor,\\r\\n    vec4 addColor,\\r\\n    vec4 previousColor,\\r\\n\\tsampler2D sampler_texture,\\r\\n\\tvec2 tileTextureCoordinates,\\r\\n\\tvec4 textureCoordinateRectangle,\\r\\n\\tvec4 textureCoordinateTranslationAndScale,\\r\\n\\tfloat textureAlphaIndex,\\r\\n\\tfloat brightness,\\r\\n\\tfloat south,\\r\\n\\tfloat north,\\r\\n\\tfloat southMercatorY,\\r\\n\\tfloat oneOverMercatorHeight,\\r\\n\\tfloat isReProjection,\\r\\n\\tvec4 alphaValue,\\r\\n\\t float contrast,\\r\\n     float hue,\\r\\n     float saturation,\\r\\n     float gamma)\\r\\n{\\r\\n\\r\\n    float textureAlpha = 1.0;\\r\\n\\r\\n\\tvec2 alphaMultiplier = step(textureCoordinateRectangle.xy, tileTextureCoordinates);\\r\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n    alphaMultiplier = step(vec2(0.0,0.0), textureCoordinateRectangle.zw - tileTextureCoordinates);\\r\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n\\tvec2 translation = textureCoordinateTranslationAndScale.xy;\\r\\n    vec2 scale = textureCoordinateTranslationAndScale.zw;\\r\\n    vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\\r\\n\\r\\n\\t// 如果瓦片是墨卡托投影 uniform中会传这个参数，并且这个参数肯定不为0 如果是地理投影，不需要再次更新uv\\r\\n    if(oneOverMercatorHeight!=0.0){\\r\\n        float latitude = mix(south, north , textureCoordinates.y);\\r\\n        float sinLatitude = sin(latitude);\\r\\n        float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\\r\\n        float mercatorFraction = (mercatorY - southMercatorY) * oneOverMercatorHeight;\\r\\n        textureCoordinates.y =  mercatorFraction;\\r\\n\\r\\n        if( isReProjection == 0.0){\\r\\n            textureCoordinates.y =  (tileTextureCoordinates * scale + translation).y;\\r\\n        }\\r\\n    }\\r\\n    vec4 value = texture2D(sampler_texture, textureCoordinates);\\r\\n    if(addEffect == 1.0){\\r\\n            value = depthColor(value);\\r\\n      }\\r\\n\\r\\n       value.rgb *=eColor.rgb;\\r\\n//      if(eColor.a==1.0){\\r\\n//        value *=eColor;\\r\\n//      }\\r\\n//      else{\\r\\n////        value.rgb = (value.rgb + eColor.rgb * eColor.a)/(1.0 + eColor.a);\\r\\n//        value.rgb = value.rgb * (1.0-eColor.a) + eColor.rgb * eColor.a;\\r\\n//      }\\r\\n\\r\\n     value.rgb = (value.rgb + addColor.rgb * addColor.a)/(1.0 + addColor.a);\\r\\n    vec3 color = value.rgb;\\r\\n    float alpha = value.a;\\r\\n\\t//brightness\\r\\n\\tcolor = mix(vec3(0.0,0.0,0.0), color, brightness);\\r\\n\\t    //contrast\\r\\n\\t    color = czm_contrast(color, contrast);\\r\\n        //hue\\r\\n        color = czm_hue(color, hue);\\r\\n        // saturation\\r\\n        color = czm_saturation(color, saturation);\\r\\n    // gamma\\r\\n    color = pow(color, vec3(gamma));\\r\\n\\tfloat sourceAlpha = alpha * textureAlpha;\\r\\n    float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\\r\\n    vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\\r\\n    return vec4(outColor, outAlpha);\\r\\n}\\r\\n\\r\\n//czm_ellipsoid czm_getWgs84EllipsoidEC()\\r\\n//{\\r\\n//    vec3 radii = vec3(6378137.0, 6378137.0, 6356752.314245);\\r\\n//    vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\\r\\n//    vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\\r\\n//    czm_ellipsoid temp = czm_ellipsoid(viewMatrix[3].xyz, radii, inverseRadii, inverseRadiiSquared);\\r\\n//    return temp;\\r\\n//}\\r\\nfloat czm_fade(float cameraDist, float fadeInDist,float fadeOutDist){\\r\\n    float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\\r\\n    return fade;\\r\\n}\\r\\nAtmosphereColor computeGroundAtmosphereFromSpace(vec3 v3Pos, bool useSunLighting){\\r\\n//        float PI = 3.14159265;\\r\\n    \\t//float g2 =  g * g;\\r\\n\\r\\n    \\tvec3 v3InvWavelength = vec3(1.0 / pow(0.650, 4.0), 1.0 / pow(0.570, 4.0), 1.0 / pow(0.475, 4.0));\\r\\n\\r\\n    \\tvec3 v3CameraPos =  vec3(0.0, 0.0, 0.0);\\r\\n    \\tv3CameraPos = cameraPosition;\\r\\n\\r\\n    \\t// vec3 v3LightPos = v3LightPosInput / length(v3LightPosInput);\\r\\n        vec3 v3LightPos = v3LightPosInput;\\r\\n\\r\\n    \\tfloat fCameraHeight = length(v3CameraPos);\\r\\n\\r\\n    \\tfloat fCameraHeight2 = fCameraHeight * fCameraHeight;\\r\\n\\r\\n            \\tfloat inOutFactor = 1.05;\\r\\n            \\tfloat fInnerRadius2 = fInnerRadius * fInnerRadius;\\r\\n            \\tfloat fOuterRadius2 = fOuterRadius * fOuterRadius;\\r\\n\\r\\n            \\tfloat fKrESun = Kr * ESun;\\r\\n            \\tfloat fKmESun = Km * ESun;\\r\\n            \\tfloat fKr4PI = Kr * 4.0 * PI;\\r\\n            \\tfloat fKm4PI = Km * 4.0 * PI;\\r\\n\\r\\n            \\tfloat fInvScaleDepth = 1.0 / fScaleDepth;\\r\\n            \\tfloat fScale = 1.0 / (fOuterRadius - fInnerRadius);\\r\\n            \\tfloat fScaleOverScaleDepth = fScale / fScaleDepth;\\r\\n\\r\\n            \\t////////////////////////////////////////////////\\r\\n            \\t// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\\r\\n//            \\tvec3 v3Pos = PositionWS;\\r\\n            \\tvec3 v3Ray = v3Pos - v3CameraPos;\\r\\n            \\tv3Pos = normalize(v3Pos);\\r\\n            \\tfloat fFar = length(v3Ray);\\r\\n            \\tv3Ray /= fFar;\\r\\n            \\t// Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\\r\\n            \\tfloat fNear = getNearIntersection(v3CameraPos, v3Ray, fCameraHeight2, fOuterRadius2);\\r\\n            \\t// Calculate the ray\'s starting position, then calculate its scattering offset\\r\\n            \\tvec3 v3Start = v3CameraPos + v3Ray * fNear;\\r\\n            \\tfFar -= fNear;\\r\\n            \\tfloat fDepth = exp((fInnerRadius - fOuterRadius) * fInvScaleDepth);\\r\\n\\r\\n\\r\\n            \\t//changed by zhgu if you donnot want night make it 1.0\\r\\n            \\tfloat fLightAngle = useSunLighting ? dot(v3LightPos, v3Pos)/length(v3Pos) : 1.0;\\r\\n            \\tfloat fCameraAngle = dot(-v3Ray, v3Pos)/length(v3Pos);\\r\\n            \\t//float fLightAngle = dot(v3LightPos, v3Pos);\\r\\n            \\tfloat fCameraScale = scale(fCameraAngle, fScaleDepth);\\r\\n            \\tfloat fLightScale = scale(fLightAngle, fScaleDepth);\\r\\n            \\tfloat fCameraOffset = fDepth*fCameraScale;\\r\\n            \\tfloat fTemp = (fLightScale + fCameraScale);\\r\\n            \\t// Initialize the scattering loop variables\\r\\n            \\t//gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);\\r\\n            \\tfloat fSampleLength = fFar / fSamples;\\r\\n            \\tfloat fScaledLength = fSampleLength * fScale;\\r\\n            \\tvec3 v3SampleRay = v3Ray * fSampleLength;\\r\\n            \\tvec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\\r\\n            \\t// Now loop through the sample rays\\r\\n            \\tvec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\\r\\n            \\tvec3 v3Attenuate = vec3(0.0,0.0,0.0);\\r\\n            \\tfor(int i=0; i<2; i++)\\r\\n            \\t{\\r\\n            \\t  float fHeight = length(v3SamplePoint);\\r\\n            \\t  float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\\r\\n            \\t  float fScatter = fDepth*fTemp - fCameraOffset;\\r\\n            \\t  v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\\r\\n            \\t  v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\\r\\n            \\t  v3SamplePoint += v3SampleRay;\\r\\n            \\t}\\r\\n            \\tAtmosphereColor color;\\r\\n            \\tcolor.mie = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\\r\\n            \\tcolor.rayleigh = v3Attenuate;\\r\\n            \\treturn color;\\r\\n\\r\\n}\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor) {\\r\\n    float scalar = distanceToCamera * czm_fogDensity;\\r\\n    float fog = 1.0 - exp(-(scalar * scalar));\\r\\n    return mix(color, fogColor, fog);\\r\\n}\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant) {\\r\\n    float scalar = distanceToCamera * czm_fogDensity;\\r\\n    float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));\\r\\n    return mix(color, fogColor, fog);\\r\\n}\\r\\n\\r\\n\\r\\nvec4 czm_FilterColor (vec4 finalColor){\\r\\n    vec4 finalColor1 = vec4(0);\\r\\n    if(grayFilterEnable){\\r\\n         float gray = clamp( dot( finalColor.rgb, vec3(0.333, 0.333, 0.333) ), 0.0, 1.0 );\\r\\n         finalColor1.rgb = texture2D( colorMapping, vec2( gray, 0.5 ) ).rgb;\\r\\n         finalColor1.a = finalColor.a;\\r\\n    }else{\\r\\n        finalColor1 = finalColor;\\r\\n    }\\r\\n    return finalColor1;\\r\\n}\\r\\nfloat czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC)\\r\\n{\\r\\n    return max(dot(lightDirectionEC, normalEC), 0.0);\\r\\n}\\r\\nvarying float dotValue;\\r\\nvarying vec3 sunDirectionEC;\\r\\nvarying vec3 normalEC;\\r\\nvoid main(\\t)\\r\\n{\\r\\n    #include <logdepthbuf_fragment>\\r\\n\\t//vec2 texCoords =  vec2( gl_TexCoord[0] );\\r\\n\\tvec2 webglUv = texCoords;\\r\\n    // webglUv.y =1.0 - webglUv.y;\\r\\n    webglUv = clamp(webglUv , 0.0, 1.0);\\r\\n    vec4 lastColor = sampleAndBlend(isAddEffect0,earthColor0,earthAddColor0,u_initialColor,TexSampler0,webglUv,textureRectangle0,textureTransAndScale0,alphaIndex0,brightness0,south1,north1,southMercatorY1,oneOverMercatorHeight1,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n    //added fade by zhgu to caculate fog\\r\\n    //float cameraDist = length(viewMatrix[3]);\\r\\n    float cameraDist = length(cameraPosition);\\r\\n    float fade = czm_fade(cameraDist, fadeInDist, fadeOutDist);\\r\\n    //added lambertDiffuse TODO is it effective? 这个很一般，先忽略吧，毕竟咱们性能不太好啊\\r\\n    //float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_sunDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);\\r\\n    //diffuseIntensity = mix(1.0, diffuseIntensity, fade);\\r\\n    //vec4 finalColor = vec4(color.rgb * diffuseIntensity, color.a);\\r\\n    vec4 finalColor = lastColor;\\r\\n    //added fogColor and hdr\\r\\n    AtmosphereColor atmosFogColor = computeGroundAtmosphereFromSpace(PositionWS, false);\\r\\n    vec3 c0 = atmosFogColor.mie;\\r\\n    vec3 c1 = atmosFogColor.rayleigh;\\r\\n    vec3 fogColor1 = c0 + finalColor.rgb * c1;\\r\\n    //we should use hdr\\r\\n    const float fExposure = 2.0;\\r\\n    fogColor1 = vec3(1.0) - exp(-fExposure * fogColor1);\\r\\n    //fog added, use my fog istead of cesium\\r\\n    // const float modifier = 0.15;\\r\\n    finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor1), finalColor.a);\\r\\n\\r\\n    // ---------------------------------------------------------------------------\\r\\n    //ground\\r\\n    //SUN 这个sun的计算处理了下，我们不能和cesium用一样的参数，这样可能无法模拟真实太阳的位置\\r\\n    // changed by ztf 此处太阳光照计算废弃\\r\\n    // vec3 groundAtmosphereColor = vec3(0.0);\\r\\n    // if(night == 1.0){\\r\\n    //         AtmosphereColor atmosColor = computeGroundAtmosphereFromSpace(PositionWS, true);\\r\\n    //         groundAtmosphereColor = atmosColor.mie + finalColor.rgb * atmosColor.rayleigh;\\r\\n    //         groundAtmosphereColor = vec3(1.0) - exp(-fExposure * groundAtmosphereColor);\\r\\n    //         //TODO 这个可能要弱一点才行\\r\\n    //         float sunlitAtmosphereIntensity = clamp((cameraDist - nightfadeOut) / (nightfadeIn - nightfadeOut), 0.0, 1.0);//caculate sun\\r\\n    //         // used hdr to make HDR look better\\r\\n    //         sunlitAtmosphereIntensity = max(sunlitAtmosphereIntensity * sunlitAtmosphereIntensity, 0.03);\\r\\n    //         //mix sun\\r\\n    //         groundAtmosphereColor = mix(groundAtmosphereColor, fogColor1, sunlitAtmosphereIntensity);\\r\\n    // }\\r\\n    // else{\\r\\n    //         groundAtmosphereColor = fogColor1;\\r\\n    // }\\r\\n    vec3 groundAtmosphereColor = fogColor1;\\r\\n    // ---------------------------------------------------------------------------\\r\\n\\r\\n    //use saturation to look better\\r\\n    groundAtmosphereColor = czm_saturation(groundAtmosphereColor, 1.6);\\r\\n    //mix\\r\\n    finalColor = vec4(mix(finalColor.rgb, groundAtmosphereColor, fade), finalColor.a);\\r\\n    finalColor.rgb *= vec3(earthColor0.a);\\r\\n    //finally you get the color\\r\\n    finalColor = czm_FilterColor(finalColor);\\r\\n    gl_FragColor = finalColor;\\r\\n    //now we get the shadow\\r\\n//         gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), (1.0-getShadowMask()));\\r\\n    vec4 shadow = vec4(vec3(0.0), shadowOpacity * ( 1.0 - getShadowMask() ) );\\r\\n\\r\\n    gl_FragColor.rgb = mix(gl_FragColor.rgb, shadow.rgb, shadow.a);\\r\\n\\r\\n    // 昼夜和线性颜色叠加 互斥 开启\\r\\n    if(night == 1.0){\\r\\n\\r\\n        float diffuseIntensity = czm_getLambertDiffuse(sunDirectionEC, normalize(normalEC)) * 0.9 + 0.2;\\r\\n        gl_FragColor = vec4(gl_FragColor.rgb * diffuseIntensity, gl_FragColor.a);\\r\\n\\r\\n    }else {\\r\\n\\r\\n        // // 是否开启颜色叠加 0 关闭 1 开启\\r\\n        // uniform float gradientColorOverlayEnable;\\r\\n        // // 颜色叠加方向\\r\\n        // uniform vec3 mapDirection;\\r\\n        // // 叠加使用的渐变纹理\\r\\n        // uniform sampler2D gradientColorMap;\\r\\n\\r\\n        if(gradientColorOverlayEnable == 1.0){\\r\\n\\r\\n            float diffuseIntensity = dot(mapDirection, normalize(normalEC));\\r\\n            float uv_U = (diffuseIntensity + 1.0) / 2.0;// -1 ——> 1 映射到 0 —— 1\\r\\n            float uv_V = 0.1;\\r\\n\\r\\n            vec4 gradientColor = texture2D(gradientColorMap, vec2(uv_U, uv_V));\\r\\n\\r\\n            float tempR = gradientColor.r + (1.0 - gradientColor.r) * (1.0 - gradientOpacity);\\r\\n            float tempG = gradientColor.g + (1.0 - gradientColor.g) * (1.0 - gradientOpacity);\\r\\n            float tempB = gradientColor.b + (1.0 - gradientColor.b) * (1.0 - gradientOpacity);\\r\\n\\r\\n            gl_FragColor = vec4(gl_FragColor.rgb * vec3(tempR,tempG,tempB), gl_FragColor.a);\\r\\n\\r\\n        }\\r\\n\\r\\n    }\\r\\n    \\r\\n    #include <fog_fragment>\\r\\n}\\r\\n\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/mult_texture1.glsl?')
        },
        "./src/material/shaders/mult_texture10.glsl": /*!**************************************************!*\
  !*** ./src/material/shaders/mult_texture10.glsl ***!
  \**************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "//varying vec4 Position;\\r\\n#include <common>\\r\\n#include <packing>\\r\\n#include <fog_pars_fragment>\\r\\n#include <bsdfs>\\r\\n#include <lights_pars_begin>\\r\\n#include <shadowmap_pars_fragment>\\r\\n#include <shadowmask_pars_fragment>\\r\\n#include <logdepthbuf_pars_fragment>\\r\\nvarying vec3 PositionWS;\\r\\nvarying vec2 texCoords;\\r\\n//varying vec3 ModelPostion;\\r\\nvarying float v_distance;\\r\\n\\r\\nuniform bool grayFilterEnable;\\r\\nuniform float grayFilterIndex;\\r\\nuniform float shadowOpacity;\\r\\n//uniform float grayMinMax[2];\\r\\n//uniform float grayFilterPerBar[10];\\r\\n//uniform vec3 grayFilterColorBar[10];\\r\\n\\r\\nuniform sampler2D TexSampler0;\\r\\nuniform sampler2D TexSampler1;\\r\\nuniform sampler2D TexSampler2;\\r\\nuniform sampler2D TexSampler3;\\r\\nuniform sampler2D TexSampler4;\\r\\nuniform sampler2D TexSampler5;\\r\\nuniform sampler2D TexSampler6;\\r\\nuniform sampler2D TexSampler7;\\r\\nuniform sampler2D TexSampler8;\\r\\nuniform sampler2D TexSampler9;\\r\\n\\r\\nuniform\\tvec4 textureRectangle0;\\r\\nuniform\\tvec4 textureRectangle1;\\r\\nuniform\\tvec4 textureRectangle2;\\r\\nuniform\\tvec4 textureRectangle3;\\r\\nuniform\\tvec4 textureRectangle4;\\r\\nuniform\\tvec4 textureRectangle5;\\r\\nuniform\\tvec4 textureRectangle6;\\r\\nuniform\\tvec4 textureRectangle7;\\r\\nuniform\\tvec4 textureRectangle8;\\r\\nuniform\\tvec4 textureRectangle9;\\r\\n\\r\\nuniform\\tvec4 textureTransAndScale0;\\r\\nuniform\\tvec4 textureTransAndScale1;\\r\\nuniform\\tvec4 textureTransAndScale2;\\r\\nuniform\\tvec4 textureTransAndScale3;\\r\\nuniform\\tvec4 textureTransAndScale4;\\r\\nuniform\\tvec4 textureTransAndScale5;\\r\\nuniform\\tvec4 textureTransAndScale6;\\r\\nuniform\\tvec4 textureTransAndScale7;\\r\\nuniform\\tvec4 textureTransAndScale8;\\r\\nuniform\\tvec4 textureTransAndScale9;\\r\\n\\r\\nuniform float brightness0;\\r\\nuniform float brightness1;\\r\\nuniform float brightness2;\\r\\nuniform float brightness3;\\r\\nuniform float brightness4;\\r\\nuniform float brightness5;\\r\\nuniform float brightness6;\\r\\nuniform float brightness7;\\r\\nuniform float brightness8;\\r\\nuniform float brightness9;\\r\\n\\r\\nuniform float alphaIndex0;\\r\\nuniform float alphaIndex1;\\r\\nuniform float alphaIndex2;\\r\\nuniform float alphaIndex3;\\r\\nuniform float alphaIndex4;\\r\\nuniform float alphaIndex5;\\r\\nuniform float alphaIndex6;\\r\\nuniform float alphaIndex7;\\r\\nuniform float alphaIndex8;\\r\\nuniform float alphaIndex9;\\r\\n\\r\\nuniform float isAddEffect0;\\r\\nuniform float isAddEffect1;\\r\\nuniform float isAddEffect2;\\r\\nuniform float isAddEffect3;\\r\\nuniform float isAddEffect4;\\r\\nuniform float isAddEffect5;\\r\\nuniform float isAddEffect6;\\r\\nuniform float isAddEffect7;\\r\\nuniform float isAddEffect8;\\r\\nuniform float isAddEffect9;\\r\\n\\r\\nuniform vec4 earthColor0;\\r\\nuniform vec4 earthColor1;\\r\\nuniform vec4 earthColor2;\\r\\nuniform vec4 earthColor3;\\r\\nuniform vec4 earthColor4;\\r\\nuniform vec4 earthColor5;\\r\\nuniform vec4 earthColor6;\\r\\nuniform vec4 earthColor7;\\r\\nuniform vec4 earthColor8;\\r\\nuniform vec4 earthColor9;\\r\\n\\r\\nuniform vec4 earthAddColor0;\\r\\nuniform vec4 earthAddColor1;\\r\\nuniform vec4 earthAddColor2;\\r\\nuniform vec4 earthAddColor3;\\r\\nuniform vec4 earthAddColor4;\\r\\nuniform vec4 earthAddColor5;\\r\\nuniform vec4 earthAddColor6;\\r\\nuniform vec4 earthAddColor7;\\r\\nuniform vec4 earthAddColor8;\\r\\nuniform vec4 earthAddColor9;\\r\\n\\r\\nuniform float south1;\\r\\nuniform float north1;\\r\\nuniform float southMercatorY1;\\r\\nuniform float oneOverMercatorHeight1;\\r\\nuniform float isReProjection;\\r\\n\\r\\nuniform float south2;\\r\\nuniform float north2;\\r\\nuniform float southMercatorY2;\\r\\nuniform float oneOverMercatorHeight2;\\r\\n\\r\\nuniform float south3;\\r\\nuniform float north3;\\r\\nuniform float southMercatorY3;\\r\\nuniform float oneOverMercatorHeight3;\\r\\n\\r\\nuniform float south4;\\r\\nuniform float north4;\\r\\nuniform float southMercatorY4;\\r\\nuniform float oneOverMercatorHeight4;\\r\\n\\r\\nuniform float south5;\\r\\nuniform float north5;\\r\\nuniform float southMercatorY5;\\r\\nuniform float oneOverMercatorHeight5;\\r\\n\\r\\nuniform float south6;\\r\\nuniform float north6;\\r\\nuniform float southMercatorY6;\\r\\nuniform float oneOverMercatorHeight6;\\r\\n\\r\\n\\r\\nuniform float south7;\\r\\nuniform float north7;\\r\\nuniform float southMercatorY7;\\r\\nuniform float oneOverMercatorHeight7;\\r\\n\\r\\n\\r\\nuniform float south8;\\r\\nuniform float north8;\\r\\nuniform float southMercatorY8;\\r\\nuniform float oneOverMercatorHeight8;\\r\\n\\r\\n\\r\\nuniform float south9;\\r\\nuniform float north9;\\r\\nuniform float southMercatorY9;\\r\\nuniform float oneOverMercatorHeight9;\\r\\n\\r\\nuniform float south10;\\r\\nuniform float north10;\\r\\nuniform float southMercatorY10;\\r\\nuniform float oneOverMercatorHeight10;\\r\\n\\r\\nuniform\\tfloat Km;\\r\\nuniform\\tfloat Kr;\\r\\nuniform\\tfloat ESun;\\r\\n\\r\\nuniform int nSamples;\\r\\nuniform float fSamples;\\r\\n\\r\\n//uniform float g,\\r\\n\\r\\n//uniform\\tvec3 v3CameraPosInput;\\r\\nuniform\\tvec3 v3LightPosInput;\\r\\n\\r\\nuniform\\tfloat fInnerRadius;\\r\\nuniform\\tfloat fOuterRadius;\\r\\n\\r\\nuniform float fScaleDepth;\\r\\nuniform\\tvec4 inputColor;\\r\\nuniform vec4 alphaValue;\\r\\nuniform float night;\\r\\n\\r\\nuniform float contrast;\\r\\nuniform float hue;\\r\\nuniform float saturation;\\r\\nuniform float textureGamma;\\r\\n//uniform vec4 earthColor;\\r\\n//uniform vec4 earthAddColor;\\r\\n//uniform float isAddEffect;\\r\\n\\r\\nuniform vec4 u_initialColor;\\r\\nuniform float nightfadeIn;\\r\\nuniform float nightfadeOut;\\r\\nuniform float fadeInDist;\\r\\nuniform float fadeOutDist;\\r\\n\\r\\nuniform float czm_fogDensity;\\r\\nuniform sampler2D colorMapping;\\r\\n\\r\\n// 是否开启颜色叠加 0 关闭 1 开启\\r\\nuniform float gradientColorOverlayEnable;\\r\\n// 颜色叠加方向\\r\\nuniform vec3 mapDirection;\\r\\n// 叠加使用的渐变纹理\\r\\nuniform sampler2D gradientColorMap;\\r\\n// 叠加使用的透明度\\r\\nuniform float gradientOpacity;\\r\\n\\r\\n//#define saturate(a) clamp( a, 0.0, 1.0 )\\r\\n//#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\r\\n//#define LOG2 1.442695\\r\\nstruct czm_ellipsoid\\r\\n{\\r\\n    vec3 center;\\r\\n    vec3 radii;\\r\\n    vec3 inverseRadii;\\r\\n    vec3 inverseRadiiSquared;\\r\\n};\\r\\nstruct AtmosphereColor\\r\\n{\\r\\n    vec3 mie;\\r\\n    vec3 rayleigh;\\r\\n};\\r\\n//搞定\\r\\nfloat scale(float fCos, float fScaleDepth)\\r\\n{\\r\\n\\tfloat x = 1.0 - fCos;\\r\\n\\treturn fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\\r\\n}\\r\\nvec4 depthColor(vec4 color)\\r\\n{\\r\\n     color.r = color.r * color.r * color.r;\\r\\n     color.g = color.g * color.g * color.g;\\r\\n     color.b = color.b * color.b;\\r\\n     return color;\\r\\n}\\r\\n\\r\\n//搞定\\r\\n// Returns the near intersection point of a line and a sphere\\r\\nfloat getNearIntersection(vec3 v3Pos, vec3 v3Ray, float fDistance2, float fRadius2)\\r\\n{\\r\\n\\tfloat B = 2.0 * dot(v3Pos, v3Ray);\\r\\n\\tfloat C = fDistance2 - fRadius2;\\r\\n\\tfloat fDet = max(0.0, B*B - 4.0 * C);\\r\\n\\treturn 0.5 * (-B - sqrt(fDet));\\r\\n}\\r\\n\\r\\n//contrast added by zhgu\\r\\nvec3 czm_contrast(vec3 rgb, float contrast){\\r\\n   vec3 color = mix(vec3(0.5), rgb, contrast);\\r\\n    color = clamp(color , 0.0, 1.0);\\r\\n    return color;\\r\\n}\\r\\n\\r\\n//hue added by zhgu\\r\\nvec3 czm_hue(vec3 rgb, float adjustment)\\r\\n{\\r\\n    const mat3 toYIQ = mat3(0.299,     0.587,     0.114,\\r\\n                            0.595716, -0.274453, -0.321263,\\r\\n                            0.211456, -0.522591,  0.311135);\\r\\n    const mat3 toRGB = mat3(1.0,  0.9563,  0.6210,\\r\\n                            1.0, -0.2721, -0.6474,\\r\\n                            1.0, -1.107,   1.7046);\\r\\n    vec3 yiq = toYIQ * rgb;\\r\\n    float hue = atan(yiq.z, yiq.y) + adjustment;\\r\\n    float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\\r\\n    vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\\r\\n    vec3 final = toRGB * color;\\r\\n    final = clamp(final , 0.0, 1.0);\\r\\n    return final;\\r\\n}\\r\\n//saturation added by zhgu\\r\\nvec3 czm_saturation(vec3 rgb, float adjustment)\\r\\n{\\r\\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\\r\\n    vec3 intensity = vec3(dot(rgb, W));\\r\\n    vec3 color = mix(intensity, rgb, adjustment);\\r\\n    color = clamp(color , 0.0, 1.0);\\r\\n    return color;\\r\\n\\r\\n}\\r\\nvec4 czm_FilterColor (vec4 finalColor){\\r\\n    vec4 finalColor1 = vec4(0);\\r\\n    if(grayFilterEnable){\\r\\n         float gray = clamp( dot( finalColor.rgb, vec3(0.333, 0.333, 0.333) ), 0.0, 1.0 );\\r\\n         finalColor1.rgb = texture2D( colorMapping, vec2( gray, 0.5 ) ).rgb;\\r\\n         finalColor1.a = finalColor.a;\\r\\n    }else{\\r\\n        finalColor1 = finalColor;\\r\\n    }\\r\\n    return finalColor1;\\r\\n}\\r\\nvec4 sampleAndBlend(\\r\\n    float addEffect,\\r\\n    vec4 eColor,\\r\\n    vec4 addColor,\\r\\n    vec4 previousColor,\\r\\n\\tsampler2D sampler_texture,\\r\\n\\tvec2 tileTextureCoordinates,\\r\\n\\tvec4 textureCoordinateRectangle,\\r\\n\\tvec4 textureCoordinateTranslationAndScale,\\r\\n\\tfloat textureAlphaIndex,\\r\\n\\tfloat brightness,\\r\\n\\tfloat south,\\r\\n\\tfloat north,\\r\\n\\tfloat southMercatorY,\\r\\n\\tfloat oneOverMercatorHeight,\\r\\n\\tfloat isReProjection,\\r\\n\\tvec4 alphaValue,\\r\\n\\t float contrast,\\r\\n     float hue,\\r\\n     float saturation,\\r\\n     float gamma)\\r\\n{\\r\\n\\r\\n\\tfloat textureAlpha = 1.0;\\r\\n\\r\\n\\tvec2 alphaMultiplier = step(textureCoordinateRectangle.xy, tileTextureCoordinates);\\r\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n    alphaMultiplier = step(vec2(0.0,0.0), textureCoordinateRectangle.zw - tileTextureCoordinates);\\r\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n\\tvec2 translation = textureCoordinateTranslationAndScale.xy;\\r\\n    vec2 scale = textureCoordinateTranslationAndScale.zw;\\r\\n    vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\\r\\n\\r\\n\\t//再投影\\r\\n\\r\\n    if(oneOverMercatorHeight!=0.0){\\r\\n        float latitude = mix(south, north , textureCoordinates.y);\\r\\n        float sinLatitude = sin(latitude);\\r\\n        float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\\r\\n        float mercatorFraction = (mercatorY - southMercatorY) * oneOverMercatorHeight;\\r\\n        textureCoordinates.y =  mercatorFraction;\\r\\n        if( isReProjection == 0.0){\\r\\n            textureCoordinates.y = (tileTextureCoordinates * scale + translation).y;\\r\\n        }\\r\\n    }\\r\\n    vec4 value = texture2D(sampler_texture, textureCoordinates);\\r\\n     if(addEffect == 1.0){\\r\\n            value = depthColor(value);\\r\\n        }\\r\\n        value.rgb *=eColor.rgb;\\r\\n//         if(eColor.a==1.0){\\r\\n//               value *=eColor;\\r\\n//             }\\r\\n//             else{\\r\\n//               //value.rgb = (value.rgb + eColor.rgb * eColor.a)/(1.0 + eColor.a);\\r\\n//                value.rgb = value.rgb * (1.0-eColor.a) + eColor.rgb * eColor.a;\\r\\n//             }\\r\\n          value.rgb = (value.rgb + addColor.rgb * addColor.a)/(1.0 + addColor.a);\\r\\n    vec3 color = value.rgb;\\r\\n    float alpha = value.a;\\r\\n\\r\\n\\tcolor = mix(vec3(0.0,0.0,0.0), color, brightness);\\r\\n    //contrast\\r\\n    color = czm_contrast(color, contrast);\\r\\n    //hue\\r\\n    color = czm_hue(color, hue);\\r\\n    // saturation\\r\\n    color = czm_saturation(color, saturation);\\r\\n    // gamma\\r\\n    color = pow(color, vec3(gamma));\\r\\n    //filter\\r\\n    if(grayFilterIndex == textureAlphaIndex){\\r\\n        color = czm_FilterColor(vec4(color,alpha)).rgb;\\r\\n    }\\r\\n\\tfloat sourceAlpha = alpha * textureAlpha;\\r\\n    float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\\r\\n    vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\\r\\n    return vec4(outColor, outAlpha);\\r\\n}\\r\\n//czm_ellipsoid czm_getWgs84EllipsoidEC()\\r\\n//{\\r\\n//    vec3 radii = vec3(6378137.0, 6378137.0, 6356752.314245);\\r\\n//    vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\\r\\n//    vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\\r\\n//    czm_ellipsoid temp = czm_ellipsoid(viewMatrix[3].xyz, radii, inverseRadii, inverseRadiiSquared);\\r\\n//    return temp;\\r\\n//}\\r\\nfloat czm_fade(float cameraDist, float fadeInDist,float fadeOutDist){\\r\\n    float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\\r\\n    return fade;\\r\\n}\\r\\nAtmosphereColor computeGroundAtmosphereFromSpace(vec3 v3Pos, bool useSunLighting){\\r\\n        //float PI = 3.14159265;\\r\\n    \\t//float g2 =  g * g;\\r\\n\\r\\n    \\tvec3 v3InvWavelength = vec3(1.0 / pow(0.650, 4.0), 1.0 / pow(0.570, 4.0), 1.0 / pow(0.475, 4.0));\\r\\n\\r\\n    \\tvec3 v3CameraPos =  vec3(0.0, 0.0, 0.0);\\r\\n    \\tv3CameraPos = cameraPosition;\\r\\n\\r\\n    \\t// vec3 v3LightPos = v3LightPosInput / length(v3LightPosInput);\\r\\n        vec3 v3LightPos = v3LightPosInput;\\r\\n\\r\\n    \\tfloat fCameraHeight = length(v3CameraPos);\\r\\n\\r\\n    \\tfloat fCameraHeight2 = fCameraHeight * fCameraHeight;\\r\\n\\r\\n            \\tfloat inOutFactor = 1.05;\\r\\n            \\tfloat fInnerRadius2 = fInnerRadius * fInnerRadius;\\r\\n            \\tfloat fOuterRadius2 = fOuterRadius * fOuterRadius;\\r\\n\\r\\n            \\tfloat fKrESun = Kr * ESun;\\r\\n            \\tfloat fKmESun = Km * ESun;\\r\\n            \\tfloat fKr4PI = Kr * 4.0 * PI;\\r\\n            \\tfloat fKm4PI = Km * 4.0 * PI;\\r\\n\\r\\n            \\tfloat fInvScaleDepth = 1.0 / fScaleDepth;\\r\\n            \\tfloat fScale = 1.0 / (fOuterRadius - fInnerRadius);\\r\\n            \\tfloat fScaleOverScaleDepth = fScale / fScaleDepth;\\r\\n\\r\\n            \\t////////////////////////////////////////////////\\r\\n            \\t// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\\r\\n//            \\tvec3 v3Pos = PositionWS;\\r\\n            \\tvec3 v3Ray = v3Pos - v3CameraPos;\\r\\n            \\tv3Pos = normalize(v3Pos);\\r\\n            \\tfloat fFar = length(v3Ray);\\r\\n            \\tv3Ray /= fFar;\\r\\n            \\t// Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\\r\\n            \\tfloat fNear = getNearIntersection(v3CameraPos, v3Ray, fCameraHeight2, fOuterRadius2);\\r\\n            \\t// Calculate the ray\'s starting position, then calculate its scattering offset\\r\\n            \\tvec3 v3Start = v3CameraPos + v3Ray * fNear;\\r\\n            \\tfFar -= fNear;\\r\\n            \\tfloat fDepth = exp((fInnerRadius - fOuterRadius) * fInvScaleDepth);\\r\\n\\r\\n\\r\\n            \\t//changed by zhgu if you donnot want night make it 1.0\\r\\n            \\tfloat fLightAngle = useSunLighting ? dot(v3LightPos, v3Pos)/length(v3Pos) : 1.0;\\r\\n            \\tfloat fCameraAngle = dot(-v3Ray, v3Pos)/length(v3Pos);\\r\\n            \\t//float fLightAngle = dot(v3LightPos, v3Pos);\\r\\n            \\tfloat fCameraScale = scale(fCameraAngle, fScaleDepth);\\r\\n            \\tfloat fLightScale = scale(fLightAngle, fScaleDepth);\\r\\n            \\tfloat fCameraOffset = fDepth*fCameraScale;\\r\\n            \\tfloat fTemp = (fLightScale + fCameraScale);\\r\\n            \\t// Initialize the scattering loop variables\\r\\n            \\t//gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);\\r\\n            \\tfloat fSampleLength = fFar / fSamples;\\r\\n            \\tfloat fScaledLength = fSampleLength * fScale;\\r\\n            \\tvec3 v3SampleRay = v3Ray * fSampleLength;\\r\\n            \\tvec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\\r\\n            \\t// Now loop through the sample rays\\r\\n            \\tvec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\\r\\n            \\tvec3 v3Attenuate = vec3(0.0,0.0,0.0);\\r\\n            \\tfor(int i=0; i<2; i++)\\r\\n            \\t{\\r\\n            \\t  float fHeight = length(v3SamplePoint);\\r\\n            \\t  float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\\r\\n            \\t  float fScatter = fDepth*fTemp - fCameraOffset;\\r\\n            \\t  v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\\r\\n            \\t  v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\\r\\n            \\t  v3SamplePoint += v3SampleRay;\\r\\n            \\t}\\r\\n            \\tAtmosphereColor color;\\r\\n            \\tcolor.mie = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\\r\\n            \\tcolor.rayleigh = v3Attenuate;\\r\\n            \\treturn color;\\r\\n\\r\\n}\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor) {\\r\\n    float scalar = distanceToCamera * czm_fogDensity;\\r\\n    float fog = 1.0 - exp(-(scalar * scalar));\\r\\n    return mix(color, fogColor, fog);\\r\\n}\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant) {\\r\\n    float scalar = distanceToCamera * czm_fogDensity;\\r\\n    float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));\\r\\n    return mix(color, fogColor, fog);\\r\\n}\\r\\n\\r\\n\\r\\nfloat czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC)\\r\\n{\\r\\n    return max(dot(lightDirectionEC, normalEC), 0.0);\\r\\n}\\r\\nvarying float dotValue;\\r\\nvarying vec3 sunDirectionEC;\\r\\nvarying vec3 normalEC;\\r\\nvoid main(\\t)\\r\\n{\\r\\n    #include <logdepthbuf_fragment>\\r\\n\\t//vec2 texCoords =  vec2( gl_TexCoord[0] );\\r\\n\\tvec2 webglUv = texCoords;\\r\\n//    webglUv.y =1.0 - webglUv.y;\\r\\n    webglUv = clamp(webglUv , 0.0, 1.0);\\r\\n\\tvec4 lastColor = sampleAndBlend(isAddEffect0,earthColor0,earthAddColor0,u_initialColor,TexSampler0,webglUv,textureRectangle0,textureTransAndScale0,alphaIndex0,brightness0,south1,north1,southMercatorY1,oneOverMercatorHeight1,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect1,earthColor1,earthAddColor1,lastColor,TexSampler1,webglUv,textureRectangle1,textureTransAndScale1,alphaIndex1,brightness1,south2,north2,southMercatorY2,oneOverMercatorHeight2,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect2,earthColor2,earthAddColor2,lastColor,TexSampler2,webglUv,textureRectangle2,textureTransAndScale2,alphaIndex2,brightness2,south3,north3,southMercatorY3,oneOverMercatorHeight3,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect3,earthColor3,earthAddColor3,lastColor,TexSampler3,webglUv,textureRectangle3,textureTransAndScale3,alphaIndex3,brightness3,south4,north4,southMercatorY4,oneOverMercatorHeight4,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect4,earthColor4,earthAddColor4,lastColor,TexSampler4,webglUv,textureRectangle4,textureTransAndScale4,alphaIndex4,brightness4,south5,north5,southMercatorY5,oneOverMercatorHeight5,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect5,earthColor5,earthAddColor5,lastColor,TexSampler5,webglUv,textureRectangle5,textureTransAndScale5,alphaIndex5,brightness5,south6,north6,southMercatorY6,oneOverMercatorHeight6,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n   \\tlastColor = sampleAndBlend(isAddEffect6,earthColor6,earthAddColor6,lastColor,TexSampler6,webglUv,textureRectangle6,textureTransAndScale6,alphaIndex6,brightness6,south7,north7,southMercatorY7,oneOverMercatorHeight7,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect7,earthColor7,earthAddColor7,lastColor,TexSampler7,webglUv,textureRectangle7,textureTransAndScale7,alphaIndex7,brightness7,south8,north8,southMercatorY8,oneOverMercatorHeight8,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect8,earthColor8,earthAddColor8,lastColor,TexSampler8,webglUv,textureRectangle8,textureTransAndScale8,alphaIndex8,brightness8,south9,north9,southMercatorY9,oneOverMercatorHeight9,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect9,earthColor9,earthAddColor9,lastColor,TexSampler9,webglUv,textureRectangle9,textureTransAndScale9,alphaIndex9,brightness9,south10,north10,southMercatorY10,oneOverMercatorHeight10,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\r\\n    //added fade by zhgu to caculate fog\\r\\n            //float cameraDist = length(viewMatrix[3]);\\r\\n            float cameraDist = length(cameraPosition);\\r\\n        \\tfloat fade = czm_fade(cameraDist, fadeInDist, fadeOutDist);\\r\\n\\r\\n            //added lambertDiffuse TODO is it effective? 这个很一般，先忽略吧，毕竟咱们性能不太好啊\\r\\n            //float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_sunDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);\\r\\n            //diffuseIntensity = mix(1.0, diffuseIntensity, fade);\\r\\n            //vec4 finalColor = vec4(color.rgb * diffuseIntensity, color.a);\\r\\n            vec4 finalColor = lastColor;\\r\\n            //added fogColor and hdr\\r\\n            //added fogColor and hdr\\r\\n                     AtmosphereColor atmosFogColor = computeGroundAtmosphereFromSpace(PositionWS, false);\\r\\n                     vec3 c0 = atmosFogColor.mie;\\r\\n                     vec3 c1 = atmosFogColor.rayleigh;\\r\\n                    vec3 fogColor1 = c0 + finalColor.rgb * c1;\\r\\n                    //we should use hdr\\r\\n                    const float fExposure = 2.0;\\r\\n                    fogColor1 = vec3(1.0) - exp(-fExposure * fogColor1);\\r\\n\\r\\n                    //fog added\\r\\n                    //const float modifier = 0.15;\\r\\n                     finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor1), finalColor.a);\\r\\n\\r\\n            // ---------------------------------------------------------------------------\\r\\n            //ground\\r\\n            //SUN 这个sun的计算处理了下，我们不能和cesium用一样的参数，这样可能无法模拟真实太阳的位置\\r\\n            // changed by ztf 此处太阳光照计算废弃\\r\\n            // vec3 groundAtmosphereColor = vec3(0.0);\\r\\n            // if(night == 1.0){\\r\\n            //         AtmosphereColor atmosColor = computeGroundAtmosphereFromSpace(PositionWS, true);\\r\\n            //         groundAtmosphereColor = atmosColor.mie + finalColor.rgb * atmosColor.rayleigh;\\r\\n            //         groundAtmosphereColor = vec3(1.0) - exp(-fExposure * groundAtmosphereColor);\\r\\n            //         //TODO 这个可能要弱一点才行\\r\\n            //         float sunlitAtmosphereIntensity = clamp((cameraDist - nightfadeOut) / (nightfadeIn - nightfadeOut), 0.0, 1.0);//caculate sun\\r\\n            //         // used hdr to make HDR look better\\r\\n            //         sunlitAtmosphereIntensity = max(sunlitAtmosphereIntensity * sunlitAtmosphereIntensity, 0.03);\\r\\n            //         //mix sun\\r\\n            //         groundAtmosphereColor = mix(groundAtmosphereColor, fogColor1, sunlitAtmosphereIntensity);\\r\\n            // }\\r\\n            // else{\\r\\n            //         groundAtmosphereColor = fogColor1;\\r\\n            // }\\r\\n            vec3 groundAtmosphereColor = fogColor1;\\r\\n            // ---------------------------------------------------------------------------\\r\\n            //use saturation to look better\\r\\n            groundAtmosphereColor = czm_saturation(groundAtmosphereColor, 1.6);\\r\\n            //mix\\r\\n            finalColor = vec4(mix(finalColor.rgb, groundAtmosphereColor, fade), finalColor.a);\\r\\n            finalColor.rgb *= vec3(earthColor0.a);\\r\\n            //finally you get the color\\r\\n             if(grayFilterIndex==-1.0){\\r\\n                finalColor = czm_FilterColor(finalColor);\\r\\n             }\\r\\n             gl_FragColor = finalColor;\\r\\n            //now we get the shadow\\r\\n//             gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), (1.0-getShadowMask()));\\r\\n        vec4 shadow = vec4(vec3(0.0), shadowOpacity * ( 1.0 - getShadowMask() ) );\\r\\n         gl_FragColor.rgb = mix(gl_FragColor.rgb, shadow.rgb, shadow.a);\\r\\n         \\r\\n    // 昼夜和线性颜色叠加 互斥 开启\\r\\n    if(night == 1.0){\\r\\n\\r\\n        float diffuseIntensity = czm_getLambertDiffuse(sunDirectionEC, normalize(normalEC)) * 0.9 + 0.2;\\r\\n        gl_FragColor = vec4(gl_FragColor.rgb * diffuseIntensity, gl_FragColor.a);\\r\\n\\r\\n    }else {\\r\\n\\r\\n        // // 是否开启颜色叠加 0 关闭 1 开启\\r\\n        // uniform float gradientColorOverlayEnable;\\r\\n        // // 颜色叠加方向\\r\\n        // uniform vec3 mapDirection;\\r\\n        // // 叠加使用的渐变纹理\\r\\n        // uniform sampler2D gradientColorMap;\\r\\n\\r\\n        if(gradientColorOverlayEnable == 1.0){\\r\\n\\r\\n            float diffuseIntensity = dot(mapDirection, normalize(normalEC));\\r\\n            float uv_U = (diffuseIntensity + 1.0) / 2.0;// -1 ——> 1 映射到 0 —— 1\\r\\n            float uv_V = 0.1;\\r\\n\\r\\n            vec4 gradientColor = texture2D(gradientColorMap, vec2(uv_U, uv_V));\\r\\n\\r\\n            float tempR = gradientColor.r + (1.0 - gradientColor.r) * (1.0 - gradientOpacity);\\r\\n            float tempG = gradientColor.g + (1.0 - gradientColor.g) * (1.0 - gradientOpacity);\\r\\n            float tempB = gradientColor.b + (1.0 - gradientColor.b) * (1.0 - gradientOpacity);\\r\\n\\r\\n            gl_FragColor = vec4(gl_FragColor.rgb * vec3(tempR,tempG,tempB), gl_FragColor.a);\\r\\n\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n        #include <fog_fragment>\\r\\n}\\r\\n\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/mult_texture10.glsl?')
        },
        "./src/material/shaders/mult_texture11.glsl": /*!**************************************************!*\
  !*** ./src/material/shaders/mult_texture11.glsl ***!
  \**************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "//varying vec4 Position;\\r\\n#include <common>\\r\\n#include <packing>\\r\\n#include <fog_pars_fragment>\\r\\n#include <bsdfs>\\r\\n#include <lights_pars_begin>\\r\\n#include <shadowmap_pars_fragment>\\r\\n#include <shadowmask_pars_fragment>\\r\\n#include <logdepthbuf_pars_fragment>\\r\\nvarying vec3 PositionWS;\\r\\nvarying vec2 texCoords;\\r\\n//varying vec3 ModelPostion;\\r\\nvarying float v_distance;\\r\\n\\r\\nuniform bool grayFilterEnable;\\r\\nuniform float grayFilterIndex;\\r\\nuniform float shadowOpacity;\\r\\n//uniform float grayMinMax[2];\\r\\n//uniform float grayFilterPerBar[10];\\r\\n//uniform vec3 grayFilterColorBar[10];\\r\\n\\r\\nuniform sampler2D TexSampler0;\\r\\nuniform sampler2D TexSampler1;\\r\\nuniform sampler2D TexSampler2;\\r\\nuniform sampler2D TexSampler3;\\r\\nuniform sampler2D TexSampler4;\\r\\nuniform sampler2D TexSampler5;\\r\\nuniform sampler2D TexSampler6;\\r\\nuniform sampler2D TexSampler7;\\r\\nuniform sampler2D TexSampler8;\\r\\nuniform sampler2D TexSampler9;\\r\\nuniform sampler2D TexSampler10;\\r\\n\\r\\nuniform vec4 textureRectangle0;\\r\\nuniform vec4 textureRectangle1;\\r\\nuniform vec4 textureRectangle2;\\r\\nuniform vec4 textureRectangle3;\\r\\nuniform vec4 textureRectangle4;\\r\\nuniform vec4 textureRectangle5;\\r\\nuniform vec4 textureRectangle6;\\r\\nuniform vec4 textureRectangle7;\\r\\nuniform vec4 textureRectangle8;\\r\\nuniform vec4 textureRectangle9;\\r\\nuniform vec4 textureRectangle10;\\r\\n\\r\\nuniform vec4 textureTransAndScale0;\\r\\nuniform vec4 textureTransAndScale1;\\r\\nuniform vec4 textureTransAndScale2;\\r\\nuniform vec4 textureTransAndScale3;\\r\\nuniform vec4 textureTransAndScale4;\\r\\nuniform vec4 textureTransAndScale5;\\r\\nuniform vec4 textureTransAndScale6;\\r\\nuniform vec4 textureTransAndScale7;\\r\\nuniform vec4 textureTransAndScale8;\\r\\nuniform vec4 textureTransAndScale9;\\r\\nuniform vec4 textureTransAndScale10;\\r\\n\\r\\nuniform float brightness0;\\r\\nuniform float brightness1;\\r\\nuniform float brightness2;\\r\\nuniform float brightness3;\\r\\nuniform float brightness4;\\r\\nuniform float brightness5;\\r\\nuniform float brightness6;\\r\\nuniform float brightness7;\\r\\nuniform float brightness8;\\r\\nuniform float brightness9;\\r\\nuniform float brightness10;\\r\\n\\r\\nuniform float alphaIndex0;\\r\\nuniform float alphaIndex1;\\r\\nuniform float alphaIndex2;\\r\\nuniform float alphaIndex3;\\r\\nuniform float alphaIndex4;\\r\\nuniform float alphaIndex5;\\r\\nuniform float alphaIndex6;\\r\\nuniform float alphaIndex7;\\r\\nuniform float alphaIndex8;\\r\\nuniform float alphaIndex9;\\r\\nuniform float alphaIndex10;\\r\\n\\r\\nuniform float isAddEffect0;\\r\\nuniform float isAddEffect1;\\r\\nuniform float isAddEffect2;\\r\\nuniform float isAddEffect3;\\r\\nuniform float isAddEffect4;\\r\\nuniform float isAddEffect5;\\r\\nuniform float isAddEffect6;\\r\\nuniform float isAddEffect7;\\r\\nuniform float isAddEffect8;\\r\\nuniform float isAddEffect9;\\r\\nuniform float isAddEffect10;\\r\\n\\r\\nuniform vec4 earthColor0;\\r\\nuniform vec4 earthColor1;\\r\\nuniform vec4 earthColor2;\\r\\nuniform vec4 earthColor3;\\r\\nuniform vec4 earthColor4;\\r\\nuniform vec4 earthColor5;\\r\\nuniform vec4 earthColor6;\\r\\nuniform vec4 earthColor7;\\r\\nuniform vec4 earthColor8;\\r\\nuniform vec4 earthColor9;\\r\\nuniform vec4 earthColor10;\\r\\n\\r\\nuniform vec4 earthAddColor0;\\r\\nuniform vec4 earthAddColor1;\\r\\nuniform vec4 earthAddColor2;\\r\\nuniform vec4 earthAddColor3;\\r\\nuniform vec4 earthAddColor4;\\r\\nuniform vec4 earthAddColor5;\\r\\nuniform vec4 earthAddColor6;\\r\\nuniform vec4 earthAddColor7;\\r\\nuniform vec4 earthAddColor8;\\r\\nuniform vec4 earthAddColor9;\\r\\nuniform vec4 earthAddColor10;\\r\\n\\r\\nuniform float south1;\\r\\nuniform float north1;\\r\\nuniform float southMercatorY1;\\r\\nuniform float oneOverMercatorHeight1;\\r\\nuniform float isReProjection;\\r\\n\\r\\nuniform float south2;\\r\\nuniform float north2;\\r\\nuniform float southMercatorY2;\\r\\nuniform float oneOverMercatorHeight2;\\r\\n\\r\\nuniform float south3;\\r\\nuniform float north3;\\r\\nuniform float southMercatorY3;\\r\\nuniform float oneOverMercatorHeight3;\\r\\n\\r\\nuniform float south4;\\r\\nuniform float north4;\\r\\nuniform float southMercatorY4;\\r\\nuniform float oneOverMercatorHeight4;\\r\\n\\r\\nuniform float south5;\\r\\nuniform float north5;\\r\\nuniform float southMercatorY5;\\r\\nuniform float oneOverMercatorHeight5;\\r\\n\\r\\nuniform float south6;\\r\\nuniform float north6;\\r\\nuniform float southMercatorY6;\\r\\nuniform float oneOverMercatorHeight6;\\r\\n\\r\\nuniform float south7;\\r\\nuniform float north7;\\r\\nuniform float southMercatorY7;\\r\\nuniform float oneOverMercatorHeight7;\\r\\n\\r\\nuniform float south8;\\r\\nuniform float north8;\\r\\nuniform float southMercatorY8;\\r\\nuniform float oneOverMercatorHeight8;\\r\\n\\r\\nuniform float south9;\\r\\nuniform float north9;\\r\\nuniform float southMercatorY9;\\r\\nuniform float oneOverMercatorHeight9;\\r\\n\\r\\nuniform float south10;\\r\\nuniform float north10;\\r\\nuniform float southMercatorY10;\\r\\nuniform float oneOverMercatorHeight10;\\r\\n\\r\\nuniform float south11;\\r\\nuniform float north11;\\r\\nuniform float southMercatorY11;\\r\\nuniform float oneOverMercatorHeight11;\\r\\n\\r\\nuniform float Km;\\r\\nuniform float Kr;\\r\\nuniform float ESun;\\r\\n\\r\\nuniform int nSamples;\\r\\nuniform float fSamples;\\r\\n\\r\\n//uniform float g,\\r\\n\\r\\n//uniform\\tvec3 v3CameraPosInput;\\r\\nuniform vec3 v3LightPosInput;\\r\\n\\r\\nuniform float fInnerRadius;\\r\\nuniform float fOuterRadius;\\r\\n\\r\\nuniform float fScaleDepth;\\r\\nuniform vec4 inputColor;\\r\\nuniform vec4 alphaValue;\\r\\nuniform float night;\\r\\n\\r\\nuniform float contrast;\\r\\nuniform float hue;\\r\\nuniform float saturation;\\r\\nuniform float textureGamma;\\r\\n//uniform vec4 earthColor;\\r\\n//uniform vec4 earthAddColor;\\r\\n//uniform float isAddEffect;\\r\\n\\r\\nuniform vec4 u_initialColor;\\r\\nuniform float nightfadeIn;\\r\\nuniform float nightfadeOut;\\r\\nuniform float fadeInDist;\\r\\nuniform float fadeOutDist;\\r\\n\\r\\nuniform float czm_fogDensity;\\r\\nuniform sampler2D colorMapping;\\r\\n\\r\\n// 是否开启颜色叠加 0 关闭 1 开启\\r\\nuniform float gradientColorOverlayEnable;\\r\\n// 颜色叠加方向\\r\\nuniform vec3 mapDirection;\\r\\n// 叠加使用的渐变纹理\\r\\nuniform sampler2D gradientColorMap;\\r\\n// 叠加使用的透明度\\r\\nuniform float gradientOpacity;\\r\\n\\r\\n//#define saturate(a) clamp( a, 0.0, 1.0 )\\r\\n//#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\r\\n//#define LOG2 1.442695\\r\\nstruct czm_ellipsoid\\r\\n  {\\r\\n    vec3 center;\\r\\n    vec3 radii;\\r\\n    vec3 inverseRadii;\\r\\n    vec3 inverseRadiiSquared;\\r\\n  };\\r\\nstruct AtmosphereColor\\r\\n  {\\r\\n    vec3 mie;\\r\\n    vec3 rayleigh;\\r\\n  };\\r\\n//搞定\\r\\nfloat scale(float fCos, float fScaleDepth)\\r\\n{\\r\\n  float x = 1.0 - fCos;\\r\\n  return fScaleDepth * exp(-0.00287 + x * (0.459 + x * (3.83 + x * (-6.80 + x * 5.25))));\\r\\n}\\r\\nvec4 depthColor(vec4 color)\\r\\n{\\r\\n  color.r = color.r * color.r * color.r;\\r\\n  color.g = color.g * color.g * color.g;\\r\\n  color.b = color.b * color.b;\\r\\n  return color;\\r\\n}\\r\\n\\r\\n//搞定\\r\\n// Returns the near intersection point of a line and a sphere\\r\\nfloat getNearIntersection(vec3 v3Pos, vec3 v3Ray, float fDistance2, float fRadius2)\\r\\n{\\r\\n  float B = 2.0 * dot(v3Pos, v3Ray);\\r\\n  float C = fDistance2 - fRadius2;\\r\\n  float fDet = max(0.0, B * B - 4.0 * C);\\r\\n  return 0.5 * (-B - sqrt(fDet));\\r\\n}\\r\\n\\r\\n//contrast added by zhgu\\r\\nvec3 czm_contrast(vec3 rgb, float contrast) {\\r\\n  vec3 color = mix(vec3(0.5), rgb, contrast);\\r\\n  color = clamp(color, 0.0, 1.0);\\r\\n  return color;\\r\\n}\\r\\n\\r\\n//hue added by zhgu\\r\\nvec3 czm_hue(vec3 rgb, float adjustment)\\r\\n{\\r\\n  const mat3 toYIQ = mat3(0.299, 0.587, 0.114,\\r\\n    0.595716, -0.274453, -0.321263,\\r\\n    0.211456, -0.522591, 0.311135);\\r\\n  const mat3 toRGB = mat3(1.0, 0.9563, 0.6210,\\r\\n    1.0, -0.2721, -0.6474,\\r\\n    1.0, -1.107, 1.7046);\\r\\n  vec3 yiq = toYIQ * rgb;\\r\\n  float hue = atan(yiq.z, yiq.y) + adjustment;\\r\\n  float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\\r\\n  vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\\r\\n  vec3 final = toRGB * color;\\r\\n  final = clamp(final, 0.0, 1.0);\\r\\n  return final;\\r\\n}\\r\\n//saturation added by zhgu\\r\\nvec3 czm_saturation(vec3 rgb, float adjustment)\\r\\n{\\r\\n  const vec3 W = vec3(0.2125, 0.7154, 0.0721);\\r\\n  vec3 intensity = vec3(dot(rgb, W));\\r\\n  vec3 color = mix(intensity, rgb, adjustment);\\r\\n  color = clamp(color, 0.0, 1.0);\\r\\n  return color;\\r\\n}\\r\\nvec4 czm_FilterColor(vec4 finalColor) {\\r\\n  vec4 finalColor1 = vec4(0);\\r\\n  if (grayFilterEnable) {\\r\\n    float gray = clamp(dot(finalColor.rgb, vec3(0.333, 0.333, 0.333)), 0.0, 1.0);\\r\\n    finalColor1.rgb = texture2D(colorMapping, vec2(gray, 0.5)).rgb;\\r\\n    finalColor1.a = finalColor.a;\\r\\n  } else {\\r\\n    finalColor1 = finalColor;\\r\\n  }\\r\\n  return finalColor1;\\r\\n}\\r\\nvec4 sampleAndBlend(\\r\\n  float addEffect,\\r\\n  vec4 eColor,\\r\\n  vec4 addColor,\\r\\n  vec4 previousColor,\\r\\n  sampler2D sampler_texture,\\r\\n  vec2 tileTextureCoordinates,\\r\\n  vec4 textureCoordinateRectangle,\\r\\n  vec4 textureCoordinateTranslationAndScale,\\r\\n  float textureAlphaIndex,\\r\\n  float brightness,\\r\\n  float south,\\r\\n  float north,\\r\\n  float southMercatorY,\\r\\n  float oneOverMercatorHeight,\\r\\n  float isReProjection,\\r\\n  vec4 alphaValue,\\r\\n  float contrast,\\r\\n  float hue,\\r\\n  float saturation,\\r\\n  float gamma)\\r\\n{\\r\\n  float textureAlpha = 1.0;\\r\\n\\r\\n  vec2 alphaMultiplier = step(textureCoordinateRectangle.xy, tileTextureCoordinates);\\r\\n  textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n  alphaMultiplier = step(vec2(0.0, 0.0), textureCoordinateRectangle.zw - tileTextureCoordinates);\\r\\n  textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n  vec2 translation = textureCoordinateTranslationAndScale.xy;\\r\\n  vec2 scale = textureCoordinateTranslationAndScale.zw;\\r\\n  vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\\r\\n\\r\\n  //再投影\\r\\n  if(oneOverMercatorHeight!=0.0){\\r\\n    float latitude = mix(south, north, textureCoordinates.y);\\r\\n    float sinLatitude = sin(latitude);\\r\\n    float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\\r\\n    float mercatorFraction = (mercatorY - southMercatorY) * oneOverMercatorHeight;\\r\\n    textureCoordinates.y = mercatorFraction;\\r\\n\\r\\n    if (isReProjection == 0.0) {\\r\\n        textureCoordinates.y = (tileTextureCoordinates * scale + translation).y;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  //textureCoordinates.y = 1.0f - textureCoordinates.y;\\r\\n  //textureCoordinates.y = textureCoordinates.y;\\r\\n  vec4 value = texture2D(sampler_texture, textureCoordinates);\\r\\n  if (addEffect == 1.0) {\\r\\n    value = depthColor(value);\\r\\n  }\\r\\n  value.rgb *= eColor.rgb;\\r\\n  //         if(eColor.a==1.0){\\r\\n  //               value *=eColor;\\r\\n  //             }\\r\\n  //             else{\\r\\n  //               //value.rgb = (value.rgb + eColor.rgb * eColor.a)/(1.0 + eColor.a);\\r\\n  //                value.rgb = value.rgb * (1.0-eColor.a) + eColor.rgb * eColor.a;\\r\\n  //             }\\r\\n  value.rgb = (value.rgb + addColor.rgb * addColor.a) / (1.0 + addColor.a);\\r\\n  vec3 color = value.rgb;\\r\\n  float alpha = value.a;\\r\\n\\r\\n  color = mix(vec3(0.0, 0.0, 0.0), color, brightness);\\r\\n  //contrast\\r\\n  color = czm_contrast(color, contrast);\\r\\n  //hue\\r\\n  color = czm_hue(color, hue);\\r\\n  // saturation\\r\\n  color = czm_saturation(color, saturation);\\r\\n  // gamma\\r\\n  color = pow(color, vec3(gamma));\\r\\n  //filter\\r\\n  if (grayFilterIndex == textureAlphaIndex) {\\r\\n    color = czm_FilterColor(vec4(color, alpha)).rgb;\\r\\n  }\\r\\n  float sourceAlpha = alpha * textureAlpha;\\r\\n  float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\\r\\n  vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\\r\\n  return vec4(outColor, outAlpha);\\r\\n}\\r\\n//czm_ellipsoid czm_getWgs84EllipsoidEC()\\r\\n//{\\r\\n//    vec3 radii = vec3(6378137.0, 6378137.0, 6356752.314245);\\r\\n//    vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\\r\\n//    vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\\r\\n//    czm_ellipsoid temp = czm_ellipsoid(viewMatrix[3].xyz, radii, inverseRadii, inverseRadiiSquared);\\r\\n//    return temp;\\r\\n//}\\r\\nfloat czm_fade(float cameraDist, float fadeInDist, float fadeOutDist) {\\r\\n  float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\\r\\n  return fade;\\r\\n}\\r\\nAtmosphereColor computeGroundAtmosphereFromSpace(vec3 v3Pos, bool useSunLighting) {\\r\\n  //float PI = 3.14159265;\\r\\n  //float g2 =  g * g;\\r\\n\\r\\n  vec3 v3InvWavelength = vec3(1.0 / pow(0.650, 4.0), 1.0 / pow(0.570, 4.0), 1.0 / pow(0.475, 4.0));\\r\\n\\r\\n  vec3 v3CameraPos = vec3(0.0, 0.0, 0.0);\\r\\n  v3CameraPos = cameraPosition;\\r\\n\\r\\n  // vec3 v3LightPos = v3LightPosInput / length(v3LightPosInput);\\r\\n  vec3 v3LightPos = v3LightPosInput;\\r\\n\\r\\n  float fCameraHeight = length(v3CameraPos);\\r\\n\\r\\n  float fCameraHeight2 = fCameraHeight * fCameraHeight;\\r\\n\\r\\n  float inOutFactor = 1.05;\\r\\n  float fInnerRadius2 = fInnerRadius * fInnerRadius;\\r\\n  float fOuterRadius2 = fOuterRadius * fOuterRadius;\\r\\n\\r\\n  float fKrESun = Kr * ESun;\\r\\n  float fKmESun = Km * ESun;\\r\\n  float fKr4PI = Kr * 4.0 * PI;\\r\\n  float fKm4PI = Km * 4.0 * PI;\\r\\n\\r\\n  float fInvScaleDepth = 1.0 / fScaleDepth;\\r\\n  float fScale = 1.0 / (fOuterRadius - fInnerRadius);\\r\\n  float fScaleOverScaleDepth = fScale / fScaleDepth;\\r\\n\\r\\n  ////////////////////////////////////////////////\\r\\n  // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\\r\\n  //            \\tvec3 v3Pos = PositionWS;\\r\\n  vec3 v3Ray = v3Pos - v3CameraPos;\\r\\n  v3Pos = normalize(v3Pos);\\r\\n  float fFar = length(v3Ray);\\r\\n  v3Ray /= fFar;\\r\\n  // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\\r\\n  float fNear = getNearIntersection(v3CameraPos, v3Ray, fCameraHeight2, fOuterRadius2);\\r\\n  // Calculate the ray\'s starting position, then calculate its scattering offset\\r\\n  vec3 v3Start = v3CameraPos + v3Ray * fNear;\\r\\n  fFar -= fNear;\\r\\n  float fDepth = exp((fInnerRadius - fOuterRadius) * fInvScaleDepth);\\r\\n\\r\\n  //changed by zhgu if you donnot want night make it 1.0\\r\\n  float fLightAngle = useSunLighting ? dot(v3LightPos, v3Pos) / length(v3Pos) : 1.0;\\r\\n  float fCameraAngle = dot(-v3Ray, v3Pos) / length(v3Pos);\\r\\n  //float fLightAngle = dot(v3LightPos, v3Pos);\\r\\n  float fCameraScale = scale(fCameraAngle, fScaleDepth);\\r\\n  float fLightScale = scale(fLightAngle, fScaleDepth);\\r\\n  float fCameraOffset = fDepth * fCameraScale;\\r\\n  float fTemp = (fLightScale + fCameraScale);\\r\\n  // Initialize the scattering loop variables\\r\\n  //gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);\\r\\n  float fSampleLength = fFar / fSamples;\\r\\n  float fScaledLength = fSampleLength * fScale;\\r\\n  vec3 v3SampleRay = v3Ray * fSampleLength;\\r\\n  vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\\r\\n  // Now loop through the sample rays\\r\\n  vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\\r\\n  vec3 v3Attenuate = vec3(0.0, 0.0, 0.0);\\r\\n  for (int i = 0; i < 2; i++)\\r\\n  {\\r\\n    float fHeight = length(v3SamplePoint);\\r\\n    float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\\r\\n    float fScatter = fDepth * fTemp - fCameraOffset;\\r\\n    v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\\r\\n    v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\\r\\n    v3SamplePoint += v3SampleRay;\\r\\n  }\\r\\n  AtmosphereColor color;\\r\\n  color.mie = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\\r\\n  color.rayleigh = v3Attenuate;\\r\\n  return color;\\r\\n}\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor) {\\r\\n  float scalar = distanceToCamera * czm_fogDensity;\\r\\n  float fog = 1.0 - exp(-(scalar * scalar));\\r\\n  return mix(color, fogColor, fog);\\r\\n}\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant) {\\r\\n  float scalar = distanceToCamera * czm_fogDensity;\\r\\n  float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));\\r\\n  return mix(color, fogColor, fog);\\r\\n}\\r\\n\\r\\nfloat czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC)\\r\\n{\\r\\n  return max(dot(lightDirectionEC, normalEC), 0.0);\\r\\n}\\r\\nvarying float dotValue;\\r\\nvarying vec3 sunDirectionEC;\\r\\nvarying vec3 normalEC;\\r\\nvoid main()\\r\\n{\\r\\n  #include <logdepthbuf_fragment>\\r\\n  //vec2 texCoords =  vec2( gl_TexCoord[0] );\\r\\n  vec2 webglUv = texCoords;\\r\\n  //    webglUv.y =1.0 - webglUv.y;\\r\\n  webglUv = clamp(webglUv, 0.0, 1.0);\\r\\n  vec4 lastColor = sampleAndBlend(isAddEffect0, earthColor0, earthAddColor0, u_initialColor, TexSampler0, webglUv, textureRectangle0, textureTransAndScale0, alphaIndex0, brightness0, south1, north1, southMercatorY1, oneOverMercatorHeight1, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect1, earthColor1, earthAddColor1, lastColor, TexSampler1, webglUv, textureRectangle1, textureTransAndScale1, alphaIndex1, brightness1, south2, north2, southMercatorY2, oneOverMercatorHeight2, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect2, earthColor2, earthAddColor2, lastColor, TexSampler2, webglUv, textureRectangle2, textureTransAndScale2, alphaIndex2, brightness2, south3, north3, southMercatorY3, oneOverMercatorHeight3, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect3, earthColor3, earthAddColor3, lastColor, TexSampler3, webglUv, textureRectangle3, textureTransAndScale3, alphaIndex3, brightness3, south4, north4, southMercatorY4, oneOverMercatorHeight4, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect4, earthColor4, earthAddColor4, lastColor, TexSampler4, webglUv, textureRectangle4, textureTransAndScale4, alphaIndex4, brightness4, south5, north5, southMercatorY5, oneOverMercatorHeight5, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect5, earthColor5, earthAddColor5, lastColor, TexSampler5, webglUv, textureRectangle5, textureTransAndScale5, alphaIndex5, brightness5, south6, north6, southMercatorY6, oneOverMercatorHeight6, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect6, earthColor6, earthAddColor6, lastColor, TexSampler6, webglUv, textureRectangle6, textureTransAndScale6, alphaIndex6, brightness6, south7, north7, southMercatorY7, oneOverMercatorHeight7, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect7, earthColor7, earthAddColor7, lastColor, TexSampler7, webglUv, textureRectangle7, textureTransAndScale7, alphaIndex7, brightness7, south8, north8, southMercatorY8, oneOverMercatorHeight8, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect8, earthColor8, earthAddColor8, lastColor, TexSampler8, webglUv, textureRectangle8, textureTransAndScale8, alphaIndex8, brightness8, south9, north9, southMercatorY9, oneOverMercatorHeight9, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect9, earthColor9, earthAddColor9, lastColor, TexSampler9, webglUv, textureRectangle9, textureTransAndScale9, alphaIndex9, brightness9, south10, north10, southMercatorY10, oneOverMercatorHeight10, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect10, earthColor10, earthAddColor10, lastColor, TexSampler10, webglUv, textureRectangle10, textureTransAndScale10, alphaIndex10, brightness10, south11, north11, southMercatorY11, oneOverMercatorHeight11, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n\\r\\n  //added fade by zhgu to caculate fog\\r\\n  //float cameraDist = length(viewMatrix[3]);\\r\\n  float cameraDist = length(cameraPosition);\\r\\n  float fade = czm_fade(cameraDist, fadeInDist, fadeOutDist);\\r\\n\\r\\n  //added lambertDiffuse TODO is it effective? 这个很一般，先忽略吧，毕竟咱们性能不太好啊\\r\\n  //float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_sunDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);\\r\\n  //diffuseIntensity = mix(1.0, diffuseIntensity, fade);\\r\\n  //vec4 finalColor = vec4(color.rgb * diffuseIntensity, color.a);\\r\\n  vec4 finalColor = lastColor;\\r\\n  //added fogColor and hdr\\r\\n  //added fogColor and hdr\\r\\n  AtmosphereColor atmosFogColor = computeGroundAtmosphereFromSpace(PositionWS, false);\\r\\n  vec3 c0 = atmosFogColor.mie;\\r\\n  vec3 c1 = atmosFogColor.rayleigh;\\r\\n  vec3 fogColor1 = c0 + finalColor.rgb * c1;\\r\\n  //we should use hdr\\r\\n  const float fExposure = 2.0;\\r\\n  fogColor1 = vec3(1.0) - exp(-fExposure * fogColor1);\\r\\n\\r\\n  //fog added\\r\\n  //const float modifier = 0.15;\\r\\n  finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor1), finalColor.a);\\r\\n\\r\\n  // ---------------------------------------------------------------------------\\r\\n  //ground\\r\\n  //SUN 这个sun的计算处理了下，我们不能和cesium用一样的参数，这样可能无法模拟真实太阳的位置\\r\\n  // changed by ztf 此处太阳光照计算废弃\\r\\n  // vec3 groundAtmosphereColor = vec3(0.0);\\r\\n  // if(night == 1.0){\\r\\n  //         AtmosphereColor atmosColor = computeGroundAtmosphereFromSpace(PositionWS, true);\\r\\n  //         groundAtmosphereColor = atmosColor.mie + finalColor.rgb * atmosColor.rayleigh;\\r\\n  //         groundAtmosphereColor = vec3(1.0) - exp(-fExposure * groundAtmosphereColor);\\r\\n  //         //TODO 这个可能要弱一点才行\\r\\n  //         float sunlitAtmosphereIntensity = clamp((cameraDist - nightfadeOut) / (nightfadeIn - nightfadeOut), 0.0, 1.0);//caculate sun\\r\\n  //         // used hdr to make HDR look better\\r\\n  //         sunlitAtmosphereIntensity = max(sunlitAtmosphereIntensity * sunlitAtmosphereIntensity, 0.03);\\r\\n  //         //mix sun\\r\\n  //         groundAtmosphereColor = mix(groundAtmosphereColor, fogColor1, sunlitAtmosphereIntensity);\\r\\n  // }\\r\\n  // else{\\r\\n  //         groundAtmosphereColor = fogColor1;\\r\\n  // }\\r\\n  vec3 groundAtmosphereColor = fogColor1;\\r\\n  // ---------------------------------------------------------------------------\\r\\n  //use saturation to look better\\r\\n  groundAtmosphereColor = czm_saturation(groundAtmosphereColor, 1.6);\\r\\n  //mix\\r\\n  finalColor = vec4(mix(finalColor.rgb, groundAtmosphereColor, fade), finalColor.a);\\r\\n  finalColor.rgb *= vec3(earthColor0.a);\\r\\n  //finally you get the color\\r\\n  if (grayFilterIndex == -1.0) {\\r\\n    finalColor = czm_FilterColor(finalColor);\\r\\n  }\\r\\n  gl_FragColor = finalColor;\\r\\n  //now we get the shadow\\r\\n  //             gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), (1.0-getShadowMask()));\\r\\n  vec4 shadow = vec4(vec3(0.0), shadowOpacity * (1.0 - getShadowMask()));\\r\\n  gl_FragColor.rgb = mix(gl_FragColor.rgb, shadow.rgb, shadow.a);\\r\\n\\r\\n  // 昼夜和线性颜色叠加 互斥 开启\\r\\n  if (night == 1.0) {\\r\\n    float diffuseIntensity = czm_getLambertDiffuse(sunDirectionEC, normalize(normalEC)) * 0.9 + 0.2;\\r\\n    gl_FragColor = vec4(gl_FragColor.rgb * diffuseIntensity, gl_FragColor.a);\\r\\n  } else {\\r\\n    // // 是否开启颜色叠加 0 关闭 1 开启\\r\\n    // uniform float gradientColorOverlayEnable;\\r\\n    // // 颜色叠加方向\\r\\n    // uniform vec3 mapDirection;\\r\\n    // // 叠加使用的渐变纹理\\r\\n    // uniform sampler2D gradientColorMap;\\r\\n\\r\\n    if (gradientColorOverlayEnable == 1.0) {\\r\\n      float diffuseIntensity = dot(mapDirection, normalize(normalEC));\\r\\n      float uv_U = (diffuseIntensity + 1.0) / 2.0; // -1 ——> 1 映射到 0 —— 1\\r\\n      float uv_V = 0.1;\\r\\n\\r\\n      vec4 gradientColor = texture2D(gradientColorMap, vec2(uv_U, uv_V));\\r\\n\\r\\n      float tempR = gradientColor.r + (1.0 - gradientColor.r) * (1.0 - gradientOpacity);\\r\\n      float tempG = gradientColor.g + (1.0 - gradientColor.g) * (1.0 - gradientOpacity);\\r\\n      float tempB = gradientColor.b + (1.0 - gradientColor.b) * (1.0 - gradientOpacity);\\r\\n\\r\\n      gl_FragColor = vec4(gl_FragColor.rgb * vec3(tempR, tempG, tempB), gl_FragColor.a);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  #include <fog_fragment>\\r\\n}\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/mult_texture11.glsl?')
        },
        "./src/material/shaders/mult_texture12.glsl": /*!**************************************************!*\
  !*** ./src/material/shaders/mult_texture12.glsl ***!
  \**************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "//varying vec4 Position;\\r\\n#include <common>\\r\\n#include <packing>\\r\\n#include <fog_pars_fragment>\\r\\n#include <bsdfs>\\r\\n#include <lights_pars_begin>\\r\\n#include <shadowmap_pars_fragment>\\r\\n#include <shadowmask_pars_fragment>\\r\\n#include <logdepthbuf_pars_fragment>\\r\\nvarying vec3 PositionWS;\\r\\nvarying vec2 texCoords;\\r\\n//varying vec3 ModelPostion;\\r\\nvarying float v_distance;\\r\\n\\r\\nuniform bool grayFilterEnable;\\r\\nuniform float grayFilterIndex;\\r\\nuniform float shadowOpacity;\\r\\n//uniform float grayMinMax[2];\\r\\n//uniform float grayFilterPerBar[10];\\r\\n//uniform vec3 grayFilterColorBar[10];\\r\\n\\r\\nuniform sampler2D TexSampler0;\\r\\nuniform sampler2D TexSampler1;\\r\\nuniform sampler2D TexSampler2;\\r\\nuniform sampler2D TexSampler3;\\r\\nuniform sampler2D TexSampler4;\\r\\nuniform sampler2D TexSampler5;\\r\\nuniform sampler2D TexSampler6;\\r\\nuniform sampler2D TexSampler7;\\r\\nuniform sampler2D TexSampler8;\\r\\nuniform sampler2D TexSampler9;\\r\\nuniform sampler2D TexSampler10;\\r\\nuniform sampler2D TexSampler11;\\r\\n\\r\\nuniform vec4 textureRectangle0;\\r\\nuniform vec4 textureRectangle1;\\r\\nuniform vec4 textureRectangle2;\\r\\nuniform vec4 textureRectangle3;\\r\\nuniform vec4 textureRectangle4;\\r\\nuniform vec4 textureRectangle5;\\r\\nuniform vec4 textureRectangle6;\\r\\nuniform vec4 textureRectangle7;\\r\\nuniform vec4 textureRectangle8;\\r\\nuniform vec4 textureRectangle9;\\r\\nuniform vec4 textureRectangle10;\\r\\nuniform vec4 textureRectangle11;\\r\\n\\r\\nuniform vec4 textureTransAndScale0;\\r\\nuniform vec4 textureTransAndScale1;\\r\\nuniform vec4 textureTransAndScale2;\\r\\nuniform vec4 textureTransAndScale3;\\r\\nuniform vec4 textureTransAndScale4;\\r\\nuniform vec4 textureTransAndScale5;\\r\\nuniform vec4 textureTransAndScale6;\\r\\nuniform vec4 textureTransAndScale7;\\r\\nuniform vec4 textureTransAndScale8;\\r\\nuniform vec4 textureTransAndScale9;\\r\\nuniform vec4 textureTransAndScale10;\\r\\nuniform vec4 textureTransAndScale11;\\r\\n\\r\\nuniform float brightness0;\\r\\nuniform float brightness1;\\r\\nuniform float brightness2;\\r\\nuniform float brightness3;\\r\\nuniform float brightness4;\\r\\nuniform float brightness5;\\r\\nuniform float brightness6;\\r\\nuniform float brightness7;\\r\\nuniform float brightness8;\\r\\nuniform float brightness9;\\r\\nuniform float brightness10;\\r\\nuniform float brightness11;\\r\\n\\r\\nuniform float alphaIndex0;\\r\\nuniform float alphaIndex1;\\r\\nuniform float alphaIndex2;\\r\\nuniform float alphaIndex3;\\r\\nuniform float alphaIndex4;\\r\\nuniform float alphaIndex5;\\r\\nuniform float alphaIndex6;\\r\\nuniform float alphaIndex7;\\r\\nuniform float alphaIndex8;\\r\\nuniform float alphaIndex9;\\r\\nuniform float alphaIndex10;\\r\\nuniform float alphaIndex11;\\r\\n\\r\\nuniform float isAddEffect0;\\r\\nuniform float isAddEffect1;\\r\\nuniform float isAddEffect2;\\r\\nuniform float isAddEffect3;\\r\\nuniform float isAddEffect4;\\r\\nuniform float isAddEffect5;\\r\\nuniform float isAddEffect6;\\r\\nuniform float isAddEffect7;\\r\\nuniform float isAddEffect8;\\r\\nuniform float isAddEffect9;\\r\\nuniform float isAddEffect10;\\r\\nuniform float isAddEffect11;\\r\\n\\r\\nuniform vec4 earthColor0;\\r\\nuniform vec4 earthColor1;\\r\\nuniform vec4 earthColor2;\\r\\nuniform vec4 earthColor3;\\r\\nuniform vec4 earthColor4;\\r\\nuniform vec4 earthColor5;\\r\\nuniform vec4 earthColor6;\\r\\nuniform vec4 earthColor7;\\r\\nuniform vec4 earthColor8;\\r\\nuniform vec4 earthColor9;\\r\\nuniform vec4 earthColor10;\\r\\nuniform vec4 earthColor11;\\r\\n\\r\\nuniform vec4 earthAddColor0;\\r\\nuniform vec4 earthAddColor1;\\r\\nuniform vec4 earthAddColor2;\\r\\nuniform vec4 earthAddColor3;\\r\\nuniform vec4 earthAddColor4;\\r\\nuniform vec4 earthAddColor5;\\r\\nuniform vec4 earthAddColor6;\\r\\nuniform vec4 earthAddColor7;\\r\\nuniform vec4 earthAddColor8;\\r\\nuniform vec4 earthAddColor9;\\r\\nuniform vec4 earthAddColor10;\\r\\nuniform vec4 earthAddColor11;\\r\\n\\r\\nuniform float south1;\\r\\nuniform float north1;\\r\\nuniform float southMercatorY1;\\r\\nuniform float oneOverMercatorHeight1;\\r\\nuniform float isReProjection;\\r\\n\\r\\nuniform float south2;\\r\\nuniform float north2;\\r\\nuniform float southMercatorY2;\\r\\nuniform float oneOverMercatorHeight2;\\r\\n\\r\\nuniform float south3;\\r\\nuniform float north3;\\r\\nuniform float southMercatorY3;\\r\\nuniform float oneOverMercatorHeight3;\\r\\n\\r\\nuniform float south4;\\r\\nuniform float north4;\\r\\nuniform float southMercatorY4;\\r\\nuniform float oneOverMercatorHeight4;\\r\\n\\r\\nuniform float south5;\\r\\nuniform float north5;\\r\\nuniform float southMercatorY5;\\r\\nuniform float oneOverMercatorHeight5;\\r\\n\\r\\nuniform float south6;\\r\\nuniform float north6;\\r\\nuniform float southMercatorY6;\\r\\nuniform float oneOverMercatorHeight6;\\r\\n\\r\\nuniform float south7;\\r\\nuniform float north7;\\r\\nuniform float southMercatorY7;\\r\\nuniform float oneOverMercatorHeight7;\\r\\n\\r\\nuniform float south8;\\r\\nuniform float north8;\\r\\nuniform float southMercatorY8;\\r\\nuniform float oneOverMercatorHeight8;\\r\\n\\r\\nuniform float south9;\\r\\nuniform float north9;\\r\\nuniform float southMercatorY9;\\r\\nuniform float oneOverMercatorHeight9;\\r\\n\\r\\nuniform float south10;\\r\\nuniform float north10;\\r\\nuniform float southMercatorY10;\\r\\nuniform float oneOverMercatorHeight10;\\r\\n\\r\\nuniform float south11;\\r\\nuniform float north11;\\r\\nuniform float southMercatorY11;\\r\\nuniform float oneOverMercatorHeight11;\\r\\n\\r\\nuniform float south12;\\r\\nuniform float north12;\\r\\nuniform float southMercatorY12;\\r\\nuniform float oneOverMercatorHeight12;\\r\\n\\r\\nuniform float Km;\\r\\nuniform float Kr;\\r\\nuniform float ESun;\\r\\n\\r\\nuniform int nSamples;\\r\\nuniform float fSamples;\\r\\n\\r\\n//uniform float g,\\r\\n\\r\\n//uniform\\tvec3 v3CameraPosInput;\\r\\nuniform vec3 v3LightPosInput;\\r\\n\\r\\nuniform float fInnerRadius;\\r\\nuniform float fOuterRadius;\\r\\n\\r\\nuniform float fScaleDepth;\\r\\nuniform vec4 inputColor;\\r\\nuniform vec4 alphaValue;\\r\\nuniform float night;\\r\\n\\r\\nuniform float contrast;\\r\\nuniform float hue;\\r\\nuniform float saturation;\\r\\nuniform float textureGamma;\\r\\n//uniform vec4 earthColor;\\r\\n//uniform vec4 earthAddColor;\\r\\n//uniform float isAddEffect;\\r\\n\\r\\nuniform vec4 u_initialColor;\\r\\nuniform float nightfadeIn;\\r\\nuniform float nightfadeOut;\\r\\nuniform float fadeInDist;\\r\\nuniform float fadeOutDist;\\r\\n\\r\\nuniform float czm_fogDensity;\\r\\nuniform sampler2D colorMapping;\\r\\n\\r\\n// 是否开启颜色叠加 0 关闭 1 开启\\r\\nuniform float gradientColorOverlayEnable;\\r\\n// 颜色叠加方向\\r\\nuniform vec3 mapDirection;\\r\\n// 叠加使用的渐变纹理\\r\\nuniform sampler2D gradientColorMap;\\r\\n// 叠加使用的透明度\\r\\nuniform float gradientOpacity;\\r\\n\\r\\n//#define saturate(a) clamp( a, 0.0, 1.0 )\\r\\n//#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\r\\n//#define LOG2 1.442695\\r\\nstruct czm_ellipsoid\\r\\n  {\\r\\n    vec3 center;\\r\\n    vec3 radii;\\r\\n    vec3 inverseRadii;\\r\\n    vec3 inverseRadiiSquared;\\r\\n  };\\r\\nstruct AtmosphereColor\\r\\n  {\\r\\n    vec3 mie;\\r\\n    vec3 rayleigh;\\r\\n  };\\r\\n//搞定\\r\\nfloat scale(float fCos, float fScaleDepth)\\r\\n{\\r\\n  float x = 1.0 - fCos;\\r\\n  return fScaleDepth * exp(-0.00287 + x * (0.459 + x * (3.83 + x * (-6.80 + x * 5.25))));\\r\\n}\\r\\nvec4 depthColor(vec4 color)\\r\\n{\\r\\n  color.r = color.r * color.r * color.r;\\r\\n  color.g = color.g * color.g * color.g;\\r\\n  color.b = color.b * color.b;\\r\\n  return color;\\r\\n}\\r\\n\\r\\n//搞定\\r\\n// Returns the near intersection point of a line and a sphere\\r\\nfloat getNearIntersection(vec3 v3Pos, vec3 v3Ray, float fDistance2, float fRadius2)\\r\\n{\\r\\n  float B = 2.0 * dot(v3Pos, v3Ray);\\r\\n  float C = fDistance2 - fRadius2;\\r\\n  float fDet = max(0.0, B * B - 4.0 * C);\\r\\n  return 0.5 * (-B - sqrt(fDet));\\r\\n}\\r\\n\\r\\n//contrast added by zhgu\\r\\nvec3 czm_contrast(vec3 rgb, float contrast) {\\r\\n  vec3 color = mix(vec3(0.5), rgb, contrast);\\r\\n  color = clamp(color, 0.0, 1.0);\\r\\n  return color;\\r\\n}\\r\\n\\r\\n//hue added by zhgu\\r\\nvec3 czm_hue(vec3 rgb, float adjustment)\\r\\n{\\r\\n  const mat3 toYIQ = mat3(0.299, 0.587, 0.114,\\r\\n    0.595716, -0.274453, -0.321263,\\r\\n    0.211456, -0.522591, 0.311135);\\r\\n  const mat3 toRGB = mat3(1.0, 0.9563, 0.6210,\\r\\n    1.0, -0.2721, -0.6474,\\r\\n    1.0, -1.107, 1.7046);\\r\\n  vec3 yiq = toYIQ * rgb;\\r\\n  float hue = atan(yiq.z, yiq.y) + adjustment;\\r\\n  float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\\r\\n  vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\\r\\n  vec3 final = toRGB * color;\\r\\n  final = clamp(final, 0.0, 1.0);\\r\\n  return final;\\r\\n}\\r\\n//saturation added by zhgu\\r\\nvec3 czm_saturation(vec3 rgb, float adjustment)\\r\\n{\\r\\n  const vec3 W = vec3(0.2125, 0.7154, 0.0721);\\r\\n  vec3 intensity = vec3(dot(rgb, W));\\r\\n  vec3 color = mix(intensity, rgb, adjustment);\\r\\n  color = clamp(color, 0.0, 1.0);\\r\\n  return color;\\r\\n}\\r\\nvec4 czm_FilterColor(vec4 finalColor) {\\r\\n  vec4 finalColor1 = vec4(0);\\r\\n  if (grayFilterEnable) {\\r\\n    float gray = clamp(dot(finalColor.rgb, vec3(0.333, 0.333, 0.333)), 0.0, 1.0);\\r\\n    finalColor1.rgb = texture2D(colorMapping, vec2(gray, 0.5)).rgb;\\r\\n    finalColor1.a = finalColor.a;\\r\\n  } else {\\r\\n    finalColor1 = finalColor;\\r\\n  }\\r\\n  return finalColor1;\\r\\n}\\r\\nvec4 sampleAndBlend(\\r\\n  float addEffect,\\r\\n  vec4 eColor,\\r\\n  vec4 addColor,\\r\\n  vec4 previousColor,\\r\\n  sampler2D sampler_texture,\\r\\n  vec2 tileTextureCoordinates,\\r\\n  vec4 textureCoordinateRectangle,\\r\\n  vec4 textureCoordinateTranslationAndScale,\\r\\n  float textureAlphaIndex,\\r\\n  float brightness,\\r\\n  float south,\\r\\n  float north,\\r\\n  float southMercatorY,\\r\\n  float oneOverMercatorHeight,\\r\\n  float isReProjection,\\r\\n  vec4 alphaValue,\\r\\n  float contrast,\\r\\n  float hue,\\r\\n  float saturation,\\r\\n  float gamma)\\r\\n{\\r\\n  float textureAlpha = 1.0;\\r\\n\\r\\n  vec2 alphaMultiplier = step(textureCoordinateRectangle.xy, tileTextureCoordinates);\\r\\n  textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n  alphaMultiplier = step(vec2(0.0, 0.0), textureCoordinateRectangle.zw - tileTextureCoordinates);\\r\\n  textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n  vec2 translation = textureCoordinateTranslationAndScale.xy;\\r\\n  vec2 scale = textureCoordinateTranslationAndScale.zw;\\r\\n  vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\\r\\n\\r\\n  //再投影\\r\\n  if(oneOverMercatorHeight!=0.0){\\r\\n    float latitude = mix(south, north, textureCoordinates.y);\\r\\n    float sinLatitude = sin(latitude);\\r\\n    float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\\r\\n    float mercatorFraction = (mercatorY - southMercatorY) * oneOverMercatorHeight;\\r\\n    textureCoordinates.y = mercatorFraction;\\r\\n    if (isReProjection == 0.0) {\\r\\n      textureCoordinates.y = (tileTextureCoordinates * scale + translation).y;\\r\\n    }\\r\\n  }\\r\\n  vec4 value = texture2D(sampler_texture, textureCoordinates);\\r\\n  if (addEffect == 1.0) {\\r\\n    value = depthColor(value);\\r\\n  }\\r\\n  value.rgb *= eColor.rgb;\\r\\n  value.rgb = (value.rgb + addColor.rgb * addColor.a) / (1.0 + addColor.a);\\r\\n  vec3 color = value.rgb;\\r\\n  float alpha = value.a;\\r\\n\\r\\n  color = mix(vec3(0.0, 0.0, 0.0), color, brightness);\\r\\n  //contrast\\r\\n  color = czm_contrast(color, contrast);\\r\\n  //hue\\r\\n  color = czm_hue(color, hue);\\r\\n  // saturation\\r\\n  color = czm_saturation(color, saturation);\\r\\n  // gamma\\r\\n  color = pow(color, vec3(gamma));\\r\\n  //filter\\r\\n  if (grayFilterIndex == textureAlphaIndex) {\\r\\n    color = czm_FilterColor(vec4(color, alpha)).rgb;\\r\\n  }\\r\\n  float sourceAlpha = alpha * textureAlpha;\\r\\n  float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\\r\\n  vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\\r\\n  return vec4(outColor, outAlpha);\\r\\n}\\r\\n//czm_ellipsoid czm_getWgs84EllipsoidEC()\\r\\n//{\\r\\n//    vec3 radii = vec3(6378137.0, 6378137.0, 6356752.314245);\\r\\n//    vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\\r\\n//    vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\\r\\n//    czm_ellipsoid temp = czm_ellipsoid(viewMatrix[3].xyz, radii, inverseRadii, inverseRadiiSquared);\\r\\n//    return temp;\\r\\n//}\\r\\nfloat czm_fade(float cameraDist, float fadeInDist, float fadeOutDist) {\\r\\n  float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\\r\\n  return fade;\\r\\n}\\r\\nAtmosphereColor computeGroundAtmosphereFromSpace(vec3 v3Pos, bool useSunLighting) {\\r\\n  //float PI = 3.14159265;\\r\\n  //float g2 =  g * g;\\r\\n\\r\\n  vec3 v3InvWavelength = vec3(1.0 / pow(0.650, 4.0), 1.0 / pow(0.570, 4.0), 1.0 / pow(0.475, 4.0));\\r\\n\\r\\n  vec3 v3CameraPos = vec3(0.0, 0.0, 0.0);\\r\\n  v3CameraPos = cameraPosition;\\r\\n\\r\\n  // vec3 v3LightPos = v3LightPosInput / length(v3LightPosInput);\\r\\n  vec3 v3LightPos = v3LightPosInput;\\r\\n\\r\\n  float fCameraHeight = length(v3CameraPos);\\r\\n\\r\\n  float fCameraHeight2 = fCameraHeight * fCameraHeight;\\r\\n\\r\\n  float inOutFactor = 1.05;\\r\\n  float fInnerRadius2 = fInnerRadius * fInnerRadius;\\r\\n  float fOuterRadius2 = fOuterRadius * fOuterRadius;\\r\\n\\r\\n  float fKrESun = Kr * ESun;\\r\\n  float fKmESun = Km * ESun;\\r\\n  float fKr4PI = Kr * 4.0 * PI;\\r\\n  float fKm4PI = Km * 4.0 * PI;\\r\\n\\r\\n  float fInvScaleDepth = 1.0 / fScaleDepth;\\r\\n  float fScale = 1.0 / (fOuterRadius - fInnerRadius);\\r\\n  float fScaleOverScaleDepth = fScale / fScaleDepth;\\r\\n\\r\\n  ////////////////////////////////////////////////\\r\\n  // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\\r\\n  //            \\tvec3 v3Pos = PositionWS;\\r\\n  vec3 v3Ray = v3Pos - v3CameraPos;\\r\\n  v3Pos = normalize(v3Pos);\\r\\n  float fFar = length(v3Ray);\\r\\n  v3Ray /= fFar;\\r\\n  // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\\r\\n  float fNear = getNearIntersection(v3CameraPos, v3Ray, fCameraHeight2, fOuterRadius2);\\r\\n  // Calculate the ray\'s starting position, then calculate its scattering offset\\r\\n  vec3 v3Start = v3CameraPos + v3Ray * fNear;\\r\\n  fFar -= fNear;\\r\\n  float fDepth = exp((fInnerRadius - fOuterRadius) * fInvScaleDepth);\\r\\n\\r\\n  //changed by zhgu if you donnot want night make it 1.0\\r\\n  float fLightAngle = useSunLighting ? dot(v3LightPos, v3Pos) / length(v3Pos) : 1.0;\\r\\n  float fCameraAngle = dot(-v3Ray, v3Pos) / length(v3Pos);\\r\\n  //float fLightAngle = dot(v3LightPos, v3Pos);\\r\\n  float fCameraScale = scale(fCameraAngle, fScaleDepth);\\r\\n  float fLightScale = scale(fLightAngle, fScaleDepth);\\r\\n  float fCameraOffset = fDepth * fCameraScale;\\r\\n  float fTemp = (fLightScale + fCameraScale);\\r\\n  // Initialize the scattering loop variables\\r\\n  //gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);\\r\\n  float fSampleLength = fFar / fSamples;\\r\\n  float fScaledLength = fSampleLength * fScale;\\r\\n  vec3 v3SampleRay = v3Ray * fSampleLength;\\r\\n  vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\\r\\n  // Now loop through the sample rays\\r\\n  vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\\r\\n  vec3 v3Attenuate = vec3(0.0, 0.0, 0.0);\\r\\n  for (int i = 0; i < 2; i++)\\r\\n  {\\r\\n    float fHeight = length(v3SamplePoint);\\r\\n    float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\\r\\n    float fScatter = fDepth * fTemp - fCameraOffset;\\r\\n    v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\\r\\n    v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\\r\\n    v3SamplePoint += v3SampleRay;\\r\\n  }\\r\\n  AtmosphereColor color;\\r\\n  color.mie = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\\r\\n  color.rayleigh = v3Attenuate;\\r\\n  return color;\\r\\n}\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor) {\\r\\n  float scalar = distanceToCamera * czm_fogDensity;\\r\\n  float fog = 1.0 - exp(-(scalar * scalar));\\r\\n  return mix(color, fogColor, fog);\\r\\n}\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant) {\\r\\n  float scalar = distanceToCamera * czm_fogDensity;\\r\\n  float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));\\r\\n  return mix(color, fogColor, fog);\\r\\n}\\r\\n\\r\\nfloat czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC)\\r\\n{\\r\\n  return max(dot(lightDirectionEC, normalEC), 0.0);\\r\\n}\\r\\nvarying float dotValue;\\r\\nvarying vec3 sunDirectionEC;\\r\\nvarying vec3 normalEC;\\r\\nvoid main()\\r\\n{\\r\\n  #include <logdepthbuf_fragment>\\r\\n  //vec2 texCoords =  vec2( gl_TexCoord[0] );\\r\\n  vec2 webglUv = texCoords;\\r\\n  //    webglUv.y =1.0 - webglUv.y;\\r\\n  webglUv = clamp(webglUv, 0.0, 1.0);\\r\\n  vec4 lastColor = sampleAndBlend(isAddEffect0, earthColor0, earthAddColor0, u_initialColor, TexSampler0, webglUv, textureRectangle0, textureTransAndScale0, alphaIndex0, brightness0, south1, north1, southMercatorY1, oneOverMercatorHeight1, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect1, earthColor1, earthAddColor1, lastColor, TexSampler1, webglUv, textureRectangle1, textureTransAndScale1, alphaIndex1, brightness1, south2, north2, southMercatorY2, oneOverMercatorHeight2, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect2, earthColor2, earthAddColor2, lastColor, TexSampler2, webglUv, textureRectangle2, textureTransAndScale2, alphaIndex2, brightness2, south3, north3, southMercatorY3, oneOverMercatorHeight3, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect3, earthColor3, earthAddColor3, lastColor, TexSampler3, webglUv, textureRectangle3, textureTransAndScale3, alphaIndex3, brightness3, south4, north4, southMercatorY4, oneOverMercatorHeight4, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect4, earthColor4, earthAddColor4, lastColor, TexSampler4, webglUv, textureRectangle4, textureTransAndScale4, alphaIndex4, brightness4, south5, north5, southMercatorY5, oneOverMercatorHeight5, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect5, earthColor5, earthAddColor5, lastColor, TexSampler5, webglUv, textureRectangle5, textureTransAndScale5, alphaIndex5, brightness5, south6, north6, southMercatorY6, oneOverMercatorHeight6, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect6, earthColor6, earthAddColor6, lastColor, TexSampler6, webglUv, textureRectangle6, textureTransAndScale6, alphaIndex6, brightness6, south7, north7, southMercatorY7, oneOverMercatorHeight7, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect7, earthColor7, earthAddColor7, lastColor, TexSampler7, webglUv, textureRectangle7, textureTransAndScale7, alphaIndex7, brightness7, south8, north8, southMercatorY8, oneOverMercatorHeight8, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect8, earthColor8, earthAddColor8, lastColor, TexSampler8, webglUv, textureRectangle8, textureTransAndScale8, alphaIndex8, brightness8, south9, north9, southMercatorY9, oneOverMercatorHeight9, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect9, earthColor9, earthAddColor9, lastColor, TexSampler9, webglUv, textureRectangle9, textureTransAndScale9, alphaIndex9, brightness9, south10, north10, southMercatorY10, oneOverMercatorHeight10, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect10, earthColor10, earthAddColor10, lastColor, TexSampler10, webglUv, textureRectangle10, textureTransAndScale10, alphaIndex10, brightness10, south11, north11, southMercatorY11, oneOverMercatorHeight11, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect11, earthColor11, earthAddColor11, lastColor, TexSampler11, webglUv, textureRectangle11, textureTransAndScale11, alphaIndex11, brightness11, south12, north12, southMercatorY12, oneOverMercatorHeight12, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n\\r\\n  //added fade by zhgu to caculate fog\\r\\n  //float cameraDist = length(viewMatrix[3]);\\r\\n  float cameraDist = length(cameraPosition);\\r\\n  float fade = czm_fade(cameraDist, fadeInDist, fadeOutDist);\\r\\n\\r\\n  //added lambertDiffuse TODO is it effective? 这个很一般，先忽略吧，毕竟咱们性能不太好啊\\r\\n  //float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_sunDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);\\r\\n  //diffuseIntensity = mix(1.0, diffuseIntensity, fade);\\r\\n  //vec4 finalColor = vec4(color.rgb * diffuseIntensity, color.a);\\r\\n  vec4 finalColor = lastColor;\\r\\n  //added fogColor and hdr\\r\\n  //added fogColor and hdr\\r\\n  AtmosphereColor atmosFogColor = computeGroundAtmosphereFromSpace(PositionWS, false);\\r\\n  vec3 c0 = atmosFogColor.mie;\\r\\n  vec3 c1 = atmosFogColor.rayleigh;\\r\\n  vec3 fogColor1 = c0 + finalColor.rgb * c1;\\r\\n  //we should use hdr\\r\\n  const float fExposure = 2.0;\\r\\n  fogColor1 = vec3(1.0) - exp(-fExposure * fogColor1);\\r\\n\\r\\n  //fog added\\r\\n  //const float modifier = 0.15;\\r\\n  finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor1), finalColor.a);\\r\\n\\r\\n  // ---------------------------------------------------------------------------\\r\\n  //ground\\r\\n  //SUN 这个sun的计算处理了下，我们不能和cesium用一样的参数，这样可能无法模拟真实太阳的位置\\r\\n  // changed by ztf 此处太阳光照计算废弃\\r\\n  // vec3 groundAtmosphereColor = vec3(0.0);\\r\\n  // if(night == 1.0){\\r\\n  //         AtmosphereColor atmosColor = computeGroundAtmosphereFromSpace(PositionWS, true);\\r\\n  //         groundAtmosphereColor = atmosColor.mie + finalColor.rgb * atmosColor.rayleigh;\\r\\n  //         groundAtmosphereColor = vec3(1.0) - exp(-fExposure * groundAtmosphereColor);\\r\\n  //         //TODO 这个可能要弱一点才行\\r\\n  //         float sunlitAtmosphereIntensity = clamp((cameraDist - nightfadeOut) / (nightfadeIn - nightfadeOut), 0.0, 1.0);//caculate sun\\r\\n  //         // used hdr to make HDR look better\\r\\n  //         sunlitAtmosphereIntensity = max(sunlitAtmosphereIntensity * sunlitAtmosphereIntensity, 0.03);\\r\\n  //         //mix sun\\r\\n  //         groundAtmosphereColor = mix(groundAtmosphereColor, fogColor1, sunlitAtmosphereIntensity);\\r\\n  // }\\r\\n  // else{\\r\\n  //         groundAtmosphereColor = fogColor1;\\r\\n  // }\\r\\n  vec3 groundAtmosphereColor = fogColor1;\\r\\n  // ---------------------------------------------------------------------------\\r\\n  //use saturation to look better\\r\\n  groundAtmosphereColor = czm_saturation(groundAtmosphereColor, 1.6);\\r\\n  //mix\\r\\n  finalColor = vec4(mix(finalColor.rgb, groundAtmosphereColor, fade), finalColor.a);\\r\\n  finalColor.rgb *= vec3(earthColor0.a);\\r\\n  //finally you get the color\\r\\n  if (grayFilterIndex == -1.0) {\\r\\n    finalColor = czm_FilterColor(finalColor);\\r\\n  }\\r\\n  gl_FragColor = finalColor;\\r\\n  //now we get the shadow\\r\\n  //             gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), (1.0-getShadowMask()));\\r\\n  vec4 shadow = vec4(vec3(0.0), shadowOpacity * (1.0 - getShadowMask()));\\r\\n  gl_FragColor.rgb = mix(gl_FragColor.rgb, shadow.rgb, shadow.a);\\r\\n\\r\\n  // 昼夜和线性颜色叠加 互斥 开启\\r\\n  if (night == 1.0) {\\r\\n    float diffuseIntensity = czm_getLambertDiffuse(sunDirectionEC, normalize(normalEC)) * 0.9 + 0.2;\\r\\n    gl_FragColor = vec4(gl_FragColor.rgb * diffuseIntensity, gl_FragColor.a);\\r\\n  } else {\\r\\n    // // 是否开启颜色叠加 0 关闭 1 开启\\r\\n    // uniform float gradientColorOverlayEnable;\\r\\n    // // 颜色叠加方向\\r\\n    // uniform vec3 mapDirection;\\r\\n    // // 叠加使用的渐变纹理\\r\\n    // uniform sampler2D gradientColorMap;\\r\\n\\r\\n    if (gradientColorOverlayEnable == 1.0) {\\r\\n      float diffuseIntensity = dot(mapDirection, normalize(normalEC));\\r\\n      float uv_U = (diffuseIntensity + 1.0) / 2.0; // -1 ——> 1 映射到 0 —— 1\\r\\n      float uv_V = 0.1;\\r\\n\\r\\n      vec4 gradientColor = texture2D(gradientColorMap, vec2(uv_U, uv_V));\\r\\n\\r\\n      float tempR = gradientColor.r + (1.0 - gradientColor.r) * (1.0 - gradientOpacity);\\r\\n      float tempG = gradientColor.g + (1.0 - gradientColor.g) * (1.0 - gradientOpacity);\\r\\n      float tempB = gradientColor.b + (1.0 - gradientColor.b) * (1.0 - gradientOpacity);\\r\\n\\r\\n      gl_FragColor = vec4(gl_FragColor.rgb * vec3(tempR, tempG, tempB), gl_FragColor.a);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  #include <fog_fragment>\\r\\n}\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/mult_texture12.glsl?')
        },
        "./src/material/shaders/mult_texture2.glsl": /*!*************************************************!*\
  !*** ./src/material/shaders/mult_texture2.glsl ***!
  \*************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "//varying vec4 Position;\\r\\n//precision highp float;\\r\\n#include <common>\\r\\n#include <packing>\\r\\n#include <fog_pars_fragment>\\r\\n#include <bsdfs>\\r\\n#include <lights_pars_begin>\\r\\n#include <shadowmap_pars_fragment>\\r\\n#include <shadowmask_pars_fragment>\\r\\n#include <logdepthbuf_pars_fragment>\\r\\nvarying vec3 PositionWS;\\r\\nvarying vec2 texCoords;\\r\\n//varying vec3 ModelPostion;\\r\\nvarying float v_distance;\\r\\n\\r\\nuniform bool grayFilterEnable;\\r\\nuniform float grayFilterIndex;\\r\\nuniform float shadowOpacity;\\r\\n//uniform float grayMinMax[2];\\r\\n//uniform float grayFilterPerBar[10];\\r\\n//uniform vec3 grayFilterColorBar[10];\\r\\n\\r\\nuniform sampler2D TexSampler0;\\r\\nuniform sampler2D TexSampler1;\\r\\n\\r\\nuniform\\tvec4 textureRectangle0;\\r\\nuniform\\tvec4 textureRectangle1;\\r\\n\\r\\nuniform\\tvec4 textureTransAndScale0;\\r\\nuniform\\tvec4 textureTransAndScale1;\\r\\n\\r\\nuniform float brightness0;\\r\\nuniform float brightness1;\\r\\n\\r\\nuniform float alphaIndex0;\\r\\nuniform float alphaIndex1;\\r\\n\\r\\nuniform float isAddEffect0;\\r\\nuniform float isAddEffect1;\\r\\n\\r\\n\\r\\nuniform vec4 earthColor0;\\r\\nuniform vec4 earthColor1;\\r\\n\\r\\nuniform vec4 earthAddColor0;\\r\\nuniform vec4 earthAddColor1;\\r\\n\\r\\n\\r\\nuniform float south1;\\r\\nuniform float north1;\\r\\nuniform float southMercatorY1;\\r\\nuniform float oneOverMercatorHeight1;\\r\\nuniform float isReProjection;\\r\\n\\r\\nuniform float south2;\\r\\nuniform float north2;\\r\\nuniform float southMercatorY2;\\r\\nuniform float oneOverMercatorHeight2;\\r\\n\\r\\nuniform\\tfloat Km;\\r\\nuniform\\tfloat Kr;\\r\\nuniform\\tfloat ESun;\\r\\n\\r\\nuniform int nSamples;\\r\\nuniform float fSamples;\\r\\n\\r\\n//uniform float g,\\r\\n\\r\\n//uniform\\tvec3 v3CameraPosInput;\\r\\nuniform\\tvec3 v3LightPosInput;\\r\\n\\r\\nuniform\\tfloat fInnerRadius;\\r\\nuniform\\tfloat fOuterRadius;\\r\\n\\r\\nuniform float fScaleDepth;\\r\\nuniform\\tvec4 inputColor;\\r\\nuniform vec4 alphaValue;\\r\\nuniform float night;\\r\\n\\r\\nuniform float contrast;\\r\\nuniform float hue;\\r\\nuniform float saturation;\\r\\nuniform float textureGamma;\\r\\n\\r\\nuniform vec4 u_initialColor;\\r\\nuniform float nightfadeIn;\\r\\nuniform float nightfadeOut;\\r\\nuniform float fadeInDist;\\r\\nuniform float fadeOutDist;\\r\\n\\r\\nuniform float czm_fogDensity;\\r\\nuniform sampler2D colorMapping;\\r\\n\\r\\n// 是否开启颜色叠加 0 关闭 1 开启\\r\\nuniform float gradientColorOverlayEnable;\\r\\n// 颜色叠加方向\\r\\nuniform vec3 mapDirection;\\r\\n// 叠加使用的渐变纹理\\r\\nuniform sampler2D gradientColorMap;\\r\\n// 叠加使用的透明度\\r\\nuniform float gradientOpacity;\\r\\n\\r\\n//#define saturate(a) clamp( a, 0.0, 1.0 )\\r\\n//#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\r\\n//#define LOG2 1.442695\\r\\nstruct czm_ellipsoid\\r\\n{\\r\\n    vec3 center;\\r\\n    vec3 radii;\\r\\n    vec3 inverseRadii;\\r\\n    vec3 inverseRadiiSquared;\\r\\n};\\r\\nstruct AtmosphereColor\\r\\n{\\r\\n    vec3 mie;\\r\\n    vec3 rayleigh;\\r\\n};\\r\\n\\r\\n//uniform vec4 earthColor;\\r\\n//uniform vec4 earthAddColor;\\r\\n//uniform float isAddEffect;\\r\\n//搞定\\r\\nfloat scale(float fCos, float fScaleDepth)\\r\\n{\\r\\n\\tfloat x = 1.0 - fCos;\\r\\n\\treturn fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\\r\\n}\\r\\n\\r\\nvec4 depthColor(vec4 color)\\r\\n{\\r\\n     color.r = color.r * color.r * color.r;\\r\\n     color.g = color.g * color.g * color.g;\\r\\n     color.b = color.b * color.b;\\r\\n     return color;\\r\\n}\\r\\n\\r\\n//搞定\\r\\n// Returns the near intersection point of a line and a sphere\\r\\nfloat getNearIntersection(vec3 v3Pos, vec3 v3Ray, float fDistance2, float fRadius2)\\r\\n{\\r\\n\\tfloat B = 2.0 * dot(v3Pos, v3Ray);\\r\\n\\tfloat C = fDistance2 - fRadius2;\\r\\n\\tfloat fDet = max(0.0, B*B - 4.0 * C);\\r\\n\\treturn 0.5 * (-B - sqrt(fDet));\\r\\n}\\r\\n\\r\\n//contrast added by zhgu\\r\\nvec3 czm_contrast(vec3 rgb, float contrast){\\r\\n   vec3 color = mix(vec3(0.5), rgb, contrast);\\r\\n    color = clamp(color , 0.0, 1.0);\\r\\n    return color;\\r\\n}\\r\\n\\r\\n//hue added by zhgu\\r\\nvec3 czm_hue(vec3 rgb, float adjustment)\\r\\n{\\r\\n    const mat3 toYIQ = mat3(0.299,     0.587,     0.114,\\r\\n                            0.595716, -0.274453, -0.321263,\\r\\n                            0.211456, -0.522591,  0.311135);\\r\\n    const mat3 toRGB = mat3(1.0,  0.9563,  0.6210,\\r\\n                            1.0, -0.2721, -0.6474,\\r\\n                            1.0, -1.107,   1.7046);\\r\\n    vec3 yiq = toYIQ * rgb;\\r\\n    float hue = atan(yiq.z, yiq.y) + adjustment;\\r\\n    float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\\r\\n    vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\\r\\n    vec3 final = toRGB * color;\\r\\n    final = clamp(final , 0.0, 1.0);\\r\\n    return final;\\r\\n}\\r\\n//saturation added by zhgu\\r\\nvec3 czm_saturation(vec3 rgb, float adjustment)\\r\\n{\\r\\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\\r\\n    vec3 intensity = vec3(dot(rgb, W));\\r\\n    vec3 color = mix(intensity, rgb, adjustment);\\r\\n    color = clamp(color , 0.0, 1.0);\\r\\n    return color;\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\nvec4 sampleAndBlend(\\r\\n     float addEffect,\\r\\n     vec4 eColor,\\r\\n     vec4 addColor,\\r\\n    vec4 previousColor,\\r\\n\\tsampler2D sampler_texture,\\r\\n\\tvec2 tileTextureCoordinates,\\r\\n\\tvec4 textureCoordinateRectangle,\\r\\n\\tvec4 textureCoordinateTranslationAndScale,\\r\\n\\tfloat textureAlphaIndex,\\r\\n\\tfloat brightness,\\r\\n\\tfloat south,\\r\\n\\tfloat north,\\r\\n\\tfloat southMercatorY,\\r\\n\\tfloat oneOverMercatorHeight,\\r\\n\\tfloat isReProjection,\\r\\n\\tvec4 alphaValue,\\r\\n\\t float contrast,\\r\\n         float hue,\\r\\n         float saturation,\\r\\n         float gamma)\\r\\n{\\r\\n\\tfloat textureAlpha = 1.0;\\r\\n\\tvec2 alphaMultiplier = step(textureCoordinateRectangle.xy, tileTextureCoordinates);\\r\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n    alphaMultiplier = step(vec2(0.0,0.0), textureCoordinateRectangle.zw - tileTextureCoordinates);\\r\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n\\tvec2 translation = textureCoordinateTranslationAndScale.xy;\\r\\n    vec2 scale = textureCoordinateTranslationAndScale.zw;\\r\\n    vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\\r\\n\\r\\n\\t//再投影\\r\\n    if(oneOverMercatorHeight!=0.0){\\r\\n        float latitude = mix(south, north , textureCoordinates.y);\\r\\n        float sinLatitude = sin(latitude);\\r\\n        float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\\r\\n        float mercatorFraction = (mercatorY - southMercatorY) * oneOverMercatorHeight;\\r\\n        textureCoordinates.y =   mercatorFraction;\\r\\n\\r\\n        if( isReProjection == 0.0){\\r\\n            textureCoordinates.y =  (tileTextureCoordinates * scale + translation).y;\\r\\n        }\\r\\n    }\\r\\n    vec4 value = texture2D(sampler_texture, textureCoordinates);\\r\\n       if(addEffect == 1.0){\\r\\n            value = depthColor(value);\\r\\n        }\\r\\n          value.rgb *=eColor.rgb;\\r\\n//           if(eColor.a==1.0){\\r\\n//                 value *=eColor;\\r\\n//               }\\r\\n//               else{\\r\\n//                 //value.rgb = (value.rgb + eColor.rgb * eColor.a)/(1.0 + eColor.a);\\r\\n//                  value.rgb = value.rgb * (1.0-eColor.a) + eColor.rgb * eColor.a;\\r\\n//               }\\r\\n         value.rgb = (value.rgb + addColor.rgb * addColor.a)/(1.0 + addColor.a);\\r\\n    vec3 color = value.rgb;\\r\\n    float alpha = value.a;\\r\\n//\\r\\n\\tcolor = mix(vec3(0.0,0.0,0.0), color, brightness);\\r\\n\\t    //contrast\\r\\n\\t    color = czm_contrast(color, contrast);\\r\\n        //hue\\r\\n        color = czm_hue(color, hue);\\r\\n        // saturation\\r\\n        color = czm_saturation(color, saturation);\\r\\n        // gamma\\r\\n        color = pow(color, vec3(gamma));\\r\\n\\r\\n\\tfloat sourceAlpha = alpha * textureAlpha;\\r\\n    float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\\r\\n    vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\\r\\n\\r\\n\\r\\n             return vec4(outColor, outAlpha);\\r\\n\\r\\n\\r\\n}\\r\\n\\r\\n//czm_ellipsoid czm_getWgs84EllipsoidEC()\\r\\n//{\\r\\n//    vec3 radii = vec3(6378137.0, 6378137.0, 6356752.314245);\\r\\n//    vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\\r\\n//    vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\\r\\n//    czm_ellipsoid temp = czm_ellipsoid(viewMatrix[3].xyz, radii, inverseRadii, inverseRadiiSquared);\\r\\n//    return temp;\\r\\n//}\\r\\nfloat czm_fade(float cameraDist, float fadeInDist,float fadeOutDist){\\r\\n    float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\\r\\n    return fade;\\r\\n}\\r\\nAtmosphereColor computeGroundAtmosphereFromSpace(vec3 v3Pos, bool useSunLighting){\\r\\n        //float PI = 3.14159265;\\r\\n    \\t//float g2 =  g * g;\\r\\n\\r\\n    \\tvec3 v3InvWavelength = vec3(1.0 / pow(0.650, 4.0), 1.0 / pow(0.570, 4.0), 1.0 / pow(0.475, 4.0));\\r\\n\\r\\n    \\tvec3 v3CameraPos =  vec3(0.0, 0.0, 0.0);\\r\\n    \\tv3CameraPos = cameraPosition;\\r\\n\\r\\n    \\t// vec3 v3LightPos = v3LightPosInput / length(v3LightPosInput);\\r\\n        vec3 v3LightPos = v3LightPosInput;\\r\\n\\r\\n    \\tfloat fCameraHeight = length(v3CameraPos);\\r\\n\\r\\n    \\tfloat fCameraHeight2 = fCameraHeight * fCameraHeight;\\r\\n\\r\\n            \\tfloat inOutFactor = 1.05;\\r\\n            \\tfloat fInnerRadius2 = fInnerRadius * fInnerRadius;\\r\\n            \\tfloat fOuterRadius2 = fOuterRadius * fOuterRadius;\\r\\n\\r\\n            \\tfloat fKrESun = Kr * ESun;\\r\\n            \\tfloat fKmESun = Km * ESun;\\r\\n            \\tfloat fKr4PI = Kr * 4.0 * PI;\\r\\n            \\tfloat fKm4PI = Km * 4.0 * PI;\\r\\n\\r\\n            \\tfloat fInvScaleDepth = 1.0 / fScaleDepth;\\r\\n            \\tfloat fScale = 1.0 / (fOuterRadius - fInnerRadius);\\r\\n            \\tfloat fScaleOverScaleDepth = fScale / fScaleDepth;\\r\\n\\r\\n            \\t////////////////////////////////////////////////\\r\\n            \\t// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\\r\\n//            \\tvec3 v3Pos = PositionWS;\\r\\n            \\tvec3 v3Ray = v3Pos - v3CameraPos;\\r\\n            \\tv3Pos = normalize(v3Pos);\\r\\n            \\tfloat fFar = length(v3Ray);\\r\\n            \\tv3Ray /= fFar;\\r\\n            \\t// Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\\r\\n            \\tfloat fNear = getNearIntersection(v3CameraPos, v3Ray, fCameraHeight2, fOuterRadius2);\\r\\n            \\t// Calculate the ray\'s starting position, then calculate its scattering offset\\r\\n            \\tvec3 v3Start = v3CameraPos + v3Ray * fNear;\\r\\n            \\tfFar -= fNear;\\r\\n            \\tfloat fDepth = exp((fInnerRadius - fOuterRadius) * fInvScaleDepth);\\r\\n\\r\\n\\r\\n            \\t//changed by zhgu if you donnot want night make it 1.0\\r\\n            \\tfloat fLightAngle = useSunLighting ? dot(v3LightPos, v3Pos)/length(v3Pos) : 1.0;\\r\\n            \\tfloat fCameraAngle = dot(-v3Ray, v3Pos)/length(v3Pos);\\r\\n            \\t//float fLightAngle = dot(v3LightPos, v3Pos);\\r\\n            \\tfloat fCameraScale = scale(fCameraAngle, fScaleDepth);\\r\\n            \\tfloat fLightScale = scale(fLightAngle, fScaleDepth);\\r\\n            \\tfloat fCameraOffset = fDepth*fCameraScale;\\r\\n            \\tfloat fTemp = (fLightScale + fCameraScale);\\r\\n            \\t// Initialize the scattering loop variables\\r\\n            \\t//gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);\\r\\n            \\tfloat fSampleLength = fFar / fSamples;\\r\\n            \\tfloat fScaledLength = fSampleLength * fScale;\\r\\n            \\tvec3 v3SampleRay = v3Ray * fSampleLength;\\r\\n            \\tvec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\\r\\n            \\t// Now loop through the sample rays\\r\\n            \\tvec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\\r\\n            \\tvec3 v3Attenuate = vec3(0.0,0.0,0.0);\\r\\n            \\tfor(int i=0; i<2; i++)\\r\\n            \\t{\\r\\n            \\t  float fHeight = length(v3SamplePoint);\\r\\n            \\t  float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\\r\\n            \\t  float fScatter = fDepth*fTemp - fCameraOffset;\\r\\n            \\t  v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\\r\\n            \\t  v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\\r\\n            \\t  v3SamplePoint += v3SampleRay;\\r\\n            \\t}\\r\\n            \\tAtmosphereColor color;\\r\\n            \\tcolor.mie = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\\r\\n            \\tcolor.rayleigh = v3Attenuate;\\r\\n            \\treturn color;\\r\\n\\r\\n}\\r\\n\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor) {\\r\\n    float scalar = distanceToCamera * czm_fogDensity;\\r\\n    float fog = 1.0 - exp(-(scalar * scalar));\\r\\n    return mix(color, fogColor, fog);\\r\\n}\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant) {\\r\\n    float scalar = distanceToCamera * czm_fogDensity;\\r\\n    float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));\\r\\n    return mix(color, fogColor, fog);\\r\\n}\\r\\n\\r\\nvec4 czm_FilterColor (vec4 finalColor){\\r\\n    vec4 finalColor1 = vec4(0);\\r\\n    if(grayFilterEnable){\\r\\n         float gray = clamp( dot( finalColor.rgb, vec3(0.333, 0.333, 0.333) ), 0.0, 1.0 );\\r\\n         finalColor1.rgb = texture2D( colorMapping, vec2( gray, 0.5 ) ).rgb;\\r\\n         finalColor1.a = finalColor.a;\\r\\n    }else{\\r\\n        finalColor1 = finalColor;\\r\\n    }\\r\\n    return finalColor1;\\r\\n}\\r\\nfloat czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC)\\r\\n{\\r\\n    return max(dot(lightDirectionEC, normalEC), 0.0);\\r\\n}\\r\\nvarying float dotValue;\\r\\nvarying vec3 sunDirectionEC;\\r\\nvarying vec3 normalEC;\\r\\nvoid main(\\t)\\r\\n{\\r\\n        #include <logdepthbuf_fragment>\\r\\n\\t    //vec2 texCoords =  vec2( gl_TexCoord[0] );\\r\\n\\t\\tvec2 webglUv = texCoords;\\r\\n//        webglUv.y =1.0 - webglUv.y;\\r\\n         webglUv = clamp(webglUv , 0.0, 1.0);\\r\\n\\t    vec4 lastColor = sampleAndBlend(isAddEffect0,earthColor0,earthAddColor0,u_initialColor,TexSampler0,webglUv,textureRectangle0,textureTransAndScale0,alphaIndex0,brightness0,south1,north1,southMercatorY1,oneOverMercatorHeight1,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\t    lastColor = sampleAndBlend(isAddEffect1,earthColor1,earthAddColor1,lastColor,TexSampler1,webglUv,textureRectangle1,textureTransAndScale1,alphaIndex1,brightness1,south2,north2,southMercatorY2,oneOverMercatorHeight2,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n    \\t//added fade by zhgu to caculate fog\\r\\n        //    \\tfloat cameraDist = length(viewMatrix[3]);\\r\\n        float cameraDist = length(cameraPosition);\\r\\n    \\tfloat fade = czm_fade(cameraDist, fadeInDist, fadeOutDist);\\r\\n\\r\\n        //added lambertDiffuse TODO is it effective? 这个很一般，先忽略吧，毕竟咱们性能不太好啊\\r\\n        //float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_sunDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);\\r\\n        //diffuseIntensity = mix(1.0, diffuseIntensity, fade);\\r\\n        //vec4 finalColor = vec4(color.rgb * diffuseIntensity, color.a);\\r\\n        vec4 finalColor = lastColor;\\r\\n        //added fogColor and hdr\\r\\n         AtmosphereColor atmosFogColor = computeGroundAtmosphereFromSpace(PositionWS, false);\\r\\n         vec3 c0 = atmosFogColor.mie;\\r\\n         vec3 c1 = atmosFogColor.rayleigh;\\r\\n        vec3 fogColor1 = c0 + finalColor.rgb * c1;\\r\\n        //we should use hdr\\r\\n        const float fExposure = 2.0;\\r\\n        fogColor1 = vec3(1.0) - exp(-fExposure * fogColor1);\\r\\n\\r\\n        //fog added\\r\\n        //const float modifier = 0.15;\\r\\n        //finalColor = vec4(czm_fog(length(ModelPostion), finalColor.rgb, fogColor), finalColor.a);\\r\\n        finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor1), finalColor.a);\\r\\n\\r\\n        // ---------------------------------------------------------------------------\\r\\n        //ground\\r\\n        //SUN 这个sun的计算处理了下，我们不能和cesium用一样的参数，这样可能无法模拟真实太阳的位置\\r\\n        // changed by ztf 此处太阳光照计算废弃\\r\\n        // vec3 groundAtmosphereColor = vec3(0.0);\\r\\n        // if(night == 1.0){\\r\\n        //         AtmosphereColor atmosColor = computeGroundAtmosphereFromSpace(PositionWS, true);\\r\\n        //         groundAtmosphereColor = atmosColor.mie + finalColor.rgb * atmosColor.rayleigh;\\r\\n        //         groundAtmosphereColor = vec3(1.0) - exp(-fExposure * groundAtmosphereColor);\\r\\n        //         //TODO 这个可能要弱一点才行\\r\\n        //         float sunlitAtmosphereIntensity = clamp((cameraDist - nightfadeOut) / (nightfadeIn - nightfadeOut), 0.0, 1.0);//caculate sun\\r\\n        //         // used hdr to make HDR look better\\r\\n        //         sunlitAtmosphereIntensity = max(sunlitAtmosphereIntensity * sunlitAtmosphereIntensity, 0.03);\\r\\n        //         //mix sun\\r\\n        //         groundAtmosphereColor = mix(groundAtmosphereColor, fogColor1, sunlitAtmosphereIntensity);\\r\\n        // }\\r\\n        // else{\\r\\n        //         groundAtmosphereColor = fogColor1;\\r\\n        // }\\r\\n        vec3 groundAtmosphereColor = fogColor1;\\r\\n        // ---------------------------------------------------------------------------\\r\\n\\r\\n        //use saturation to look better\\r\\n        groundAtmosphereColor = czm_saturation(groundAtmosphereColor, 1.6);\\r\\n        //mix\\r\\n        finalColor = vec4(mix(finalColor.rgb, groundAtmosphereColor, fade), finalColor.a);\\r\\n        finalColor.rgb *= vec3(earthColor0.a);\\r\\n        //finally you get the color\\r\\n        finalColor = czm_FilterColor(finalColor);\\r\\n        gl_FragColor = finalColor;\\r\\n         //now we get the shadow\\r\\n//          gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), (1.0-getShadowMask()));\\r\\n        vec4 shadow = vec4(vec3(0.0), shadowOpacity * ( 1.0 - getShadowMask() ) );\\r\\n         gl_FragColor.rgb = mix(gl_FragColor.rgb, shadow.rgb, shadow.a);\\r\\n\\r\\n    // 昼夜和线性颜色叠加 互斥 开启\\r\\n    if(night == 1.0){\\r\\n\\r\\n        float diffuseIntensity = czm_getLambertDiffuse(sunDirectionEC, normalize(normalEC)) * 0.9 + 0.2;\\r\\n        gl_FragColor = vec4(gl_FragColor.rgb * diffuseIntensity, gl_FragColor.a);\\r\\n\\r\\n    }else {\\r\\n\\r\\n        // // 是否开启颜色叠加 0 关闭 1 开启\\r\\n        // uniform float gradientColorOverlayEnable;\\r\\n        // // 颜色叠加方向\\r\\n        // uniform vec3 mapDirection;\\r\\n        // // 叠加使用的渐变纹理\\r\\n        // uniform sampler2D gradientColorMap;\\r\\n        \\r\\n        if(gradientColorOverlayEnable == 1.0){\\r\\n\\r\\n            float diffuseIntensity = dot(mapDirection, normalize(normalEC));\\r\\n            float uv_U = (diffuseIntensity + 1.0) / 2.0;// -1 ——> 1 映射到 0 —— 1\\r\\n            float uv_V = 0.1;\\r\\n\\r\\n            vec4 gradientColor = texture2D(gradientColorMap, vec2(uv_U, uv_V));\\r\\n\\r\\n            float tempR = gradientColor.r + (1.0 - gradientColor.r) * (1.0 - gradientOpacity);\\r\\n            float tempG = gradientColor.g + (1.0 - gradientColor.g) * (1.0 - gradientOpacity);\\r\\n            float tempB = gradientColor.b + (1.0 - gradientColor.b) * (1.0 - gradientOpacity);\\r\\n\\r\\n            gl_FragColor = vec4(gl_FragColor.rgb * vec3(tempR,tempG,tempB), gl_FragColor.a);\\r\\n\\r\\n        }\\r\\n    }\\r\\n\\r\\n          #include <fog_fragment>\\r\\n}\\r\\n\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/mult_texture2.glsl?')
        },
        "./src/material/shaders/mult_texture2_vs.glsl": /*!****************************************************!*\
  !*** ./src/material/shaders/mult_texture2_vs.glsl ***!
  \****************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval("module.exports = \"//顶点稍后再说\\r\\nprecision highp float;\\r\\nvarying vec2 texCoords;\\r\\nvarying vec3 PositionWS;\\r\\n//varying vec3 ModelPostion;\\r\\nvarying float v_distance;\\r\\nuniform vec4 objectPos;\\r\\n#include <shadowmap_pars_vertex>\\r\\n#include <fog_pars_vertex>\\r\\n#include <logdepthbuf_pars_vertex>\\r\\n#ifdef QUANTIZATION_BITS12\\r\\n    uniform mat4 u_scaleAndBias;\\r\\n#endif\\r\\n#include <common>\\r\\n\\r\\n// attribute float normalB;\\r\\n// 是否开启地形\\r\\n// uniform float isEnableTerrain;\\r\\n// 太阳光方向\\r\\nuniform vec3 sunDirection;\\r\\n// 法线与方向光点积\\r\\nvarying float dotValue;\\r\\nvarying vec3 sunDirectionEC;\\r\\nvarying vec3 normalEC;\\r\\n\\r\\n//之前的逻辑有问题，大尺度下需要时刻思考精度问题\\r\\nvec3 czm_decodePos(vec3 encoded, mat4 fromScaledENU, vec4 pos) {\\r\\n      float temp = encoded.x / 4096.0;\\r\\n        float temp_x = floor(temp) /4096.0;\\r\\n        float temp_y =temp - floor(temp);\\r\\n        float temp_z = encoded.y / 4096.0;\\r\\n        temp_z = floor(temp_z) / 4096.0;\\r\\n        vec4 temp_result = vec4(temp_x, temp_y, temp_z,1.0);\\r\\n        vec4 o_pos = fromScaledENU*temp_result;\\r\\n        vec3 final = o_pos.xyz;\\r\\n        return final;\\r\\n}\\r\\n vec2 czm_decodeUv(vec3 encoded){\\r\\n     float tempuv = encoded.z / 4096.0;\\r\\n     float  u = floor(tempuv) / 4096.0;\\r\\n     float  v = tempuv - floor(tempuv);\\r\\n     return vec2(u,v);\\r\\n }\\r\\n\\r\\n float czm_signNotZero(float value)\\r\\n{\\r\\n    return value >= 0.0 ? 1.0 : -1.0;\\r\\n}\\r\\n\\r\\nvec2 czm_signNotZero(vec2 value)\\r\\n{\\r\\n    return vec2(czm_signNotZero(value.x), czm_signNotZero(value.y));\\r\\n}\\r\\n\\r\\n  /**\\r\\n  * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component Cartesian vector.\\r\\n  * The 'oct' encoding is described in \\\"A Survey of Efficient Representations of Independent Unit Vectors\\\",\\r\\n  * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\\r\\n  *\\r\\n  * @name czm_octDecode\\r\\n  * @param {vec2} encoded The oct-encoded, unit-length vector\\r\\n  * @param {float} range The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\\r\\n  * @returns {vec3} The decoded and normalized vector\\r\\n  */\\r\\n  vec3 czm_octDecode(vec2 encoded, float range)\\r\\n  {\\r\\n      if (encoded.x == 0.0 && encoded.y == 0.0) {\\r\\n          return vec3(0.0, 0.0, 0.0);\\r\\n      }\\r\\n\\r\\n     encoded = encoded / range * 2.0 - 1.0;\\r\\n     vec3 v = vec3(encoded.x, encoded.y, 1.0 - abs(encoded.x) - abs(encoded.y));\\r\\n     if (v.z < 0.0)\\r\\n     {\\r\\n         v.xy = (1.0 - abs(v.yx)) * czm_signNotZero(v.xy);\\r\\n     }\\r\\n\\r\\n     return normalize(v);\\r\\n  }\\r\\n\\r\\n /**\\r\\n * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component Cartesian vector.\\r\\n * The 'oct' encoding is described in \\\"A Survey of Efficient Representations of Independent Unit Vectors\\\",\\r\\n * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\\r\\n *\\r\\n * @name czm_octDecode\\r\\n * @param {vec2} encoded The oct-encoded, unit-length vector\\r\\n * @returns {vec3} The decoded and normalized vector\\r\\n */\\r\\n vec3 czm_octDecode(vec2 encoded)\\r\\n {\\r\\n    return czm_octDecode(encoded, 255.0);\\r\\n }\\r\\n\\r\\n /**\\r\\n * Decodes a unit-length vector in 'oct' encoding packed into a floating-point number to a normalized 3-component Cartesian vector.\\r\\n * The 'oct' encoding is described in \\\"A Survey of Efficient Representations of Independent Unit Vectors\\\",\\r\\n * Cigolle et al 2014: http://jcgt.org/published/0003/02/01/\\r\\n *\\r\\n * @name czm_octDecode\\r\\n * @param {float} encoded The oct-encoded, unit-length vector\\r\\n * @returns {vec3} The decoded and normalized vector\\r\\n */\\r\\n vec3 czm_octDecode(float encoded)\\r\\n {\\r\\n    float temp = encoded / 256.0;\\r\\n    float x = floor(temp);\\r\\n    float y = (temp - x) * 256.0;\\r\\n    return czm_octDecode(vec2(x, y));\\r\\n }\\r\\n\\r\\nvoid main( )\\r\\n{\\r\\n        vec3 czm_position = vec3(0.0);\\r\\n        vec2 textureCoordinates = vec2(0.0);\\r\\n     #ifdef QUANTIZATION_BITS12\\r\\n            czm_position = czm_decodePos(position, u_scaleAndBias, objectPos);\\r\\n            textureCoordinates = czm_decodeUv(position);\\r\\n            //czm_position = position;\\r\\n    #else\\r\\n             czm_position = position;\\r\\n             textureCoordinates = uv;\\r\\n    #endif\\r\\n    //czm_position = czm_converPosition(czm_position);\\r\\n     vec4 worldPosition = modelMatrix * vec4( czm_position, 1.0 );\\r\\n    PositionWS =  czm_position.xyz + objectPos.xyz;\\r\\n    v_distance = length((modelViewMatrix * vec4(czm_position.xyz, 1.0)).xyz);\\r\\n    texCoords = textureCoordinates;\\r\\n\\r\\n\\tvec4 mvPosition = modelViewMatrix * vec4( czm_position, 1.0 );\\r\\n\\r\\n        vec3 transformedNormal = transformDirection(worldPosition.xyz, viewMatrix);\\r\\n        #include <shadowmap_vertex>\\r\\n        #include <fog_vertex>\\r\\n\\r\\n    gl_Position = projectionMatrix * mvPosition;\\r\\n    #include <logdepthbuf_vertex>\\r\\n\\r\\n\\r\\n    normalEC = (modelMatrix * vec4( czm_position, 1.0 )).xyz;\\r\\n    sunDirectionEC = sunDirection;\\r\\n\\r\\n    // if( isEnableTerrain == 1.0 ){// 开启地形\\r\\n\\r\\n    //     vec3 n = czm_octDecode(normalB);\\r\\n\\r\\n    //     n = vec3( -n.x, n.z, n.y );\\r\\n\\r\\n    //     normalEC = normalMatrix * n;\\r\\n\\r\\n    //     sunDirectionEC = normalMatrix * sunDirection;\\r\\n\\r\\n    //     // dotValue = dot( sunDirection,normalize( temp.xyz ) );\\r\\n\\r\\n    // }else{// 关闭地形\\r\\n\\r\\n    //     normalEC = (modelMatrix * vec4( czm_position, 1.0 )).xyz;\\r\\n\\r\\n    //     sunDirectionEC = sunDirection;\\r\\n\\r\\n    //     // dotValue = dot( sunDirection,normalize( PositionWS.xyz ) );\\r\\n\\r\\n    // }\\r\\n\\r\\n}\"\n\n//# sourceURL=webpack:///./src/material/shaders/mult_texture2_vs.glsl?")
        },
        "./src/material/shaders/mult_texture3.glsl": /*!*************************************************!*\
  !*** ./src/material/shaders/mult_texture3.glsl ***!
  \*************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "//varying vec4 Position;\\r\\n//precision highp float;\\r\\n#include <common> \\r\\n#include <packing> \\r\\n#include <fog_pars_fragment> \\r\\n#include <bsdfs> \\r\\n#include <lights_pars_begin> \\r\\n#include <shadowmap_pars_fragment> \\r\\n#include <shadowmask_pars_fragment> \\r\\n#include <logdepthbuf_pars_fragment>\\r\\n//varying vec3 ModelPostion;\\r\\nvarying float v_distance;\\r\\nvarying vec3 PositionWS;\\r\\nvarying vec2 texCoords;\\r\\n\\r\\nuniform bool grayFilterEnable;\\r\\nuniform float grayFilterIndex;\\r\\nuniform float shadowOpacity;\\r\\n//uniform float grayMinMax[2];\\r\\n//uniform float grayFilterPerBar[10];\\r\\n//uniform vec3 grayFilterColorBar[10];\\r\\nuniform sampler2D TexSampler0;\\r\\nuniform sampler2D TexSampler1;\\r\\nuniform sampler2D TexSampler2;\\r\\n\\r\\nuniform vec4 textureRectangle0;\\r\\nuniform vec4 textureRectangle1;\\r\\nuniform vec4 textureRectangle2;\\r\\n\\r\\nuniform vec4 textureTransAndScale0;\\r\\nuniform vec4 textureTransAndScale1;\\r\\nuniform vec4 textureTransAndScale2;\\r\\n\\r\\nuniform float brightness0;\\r\\nuniform float brightness1;\\r\\nuniform float brightness2;\\r\\n\\r\\nuniform float alphaIndex0;\\r\\nuniform float alphaIndex1;\\r\\nuniform float alphaIndex2;\\r\\n\\r\\nuniform float isAddEffect0;\\r\\nuniform float isAddEffect1;\\r\\nuniform float isAddEffect2;\\r\\n\\r\\nuniform vec4 earthColor0;\\r\\nuniform vec4 earthColor1;\\r\\nuniform vec4 earthColor2;\\r\\n\\r\\nuniform vec4 earthAddColor0;\\r\\nuniform vec4 earthAddColor1;\\r\\nuniform vec4 earthAddColor2;\\r\\n\\r\\nuniform float south1;\\r\\nuniform float north1;\\r\\nuniform float southMercatorY1;\\r\\nuniform float oneOverMercatorHeight1;\\r\\nuniform float isReProjection;\\r\\n\\r\\nuniform float south2;\\r\\nuniform float north2;\\r\\nuniform float southMercatorY2;\\r\\nuniform float oneOverMercatorHeight2;\\r\\n\\r\\nuniform float south3;\\r\\nuniform float north3;\\r\\nuniform float southMercatorY3;\\r\\nuniform float oneOverMercatorHeight3;\\r\\n\\r\\nuniform float Km;\\r\\nuniform float Kr;\\r\\nuniform float ESun;\\r\\n\\r\\nuniform int nSamples;\\r\\nuniform float fSamples;\\r\\n\\r\\n//uniform float g,\\r\\n//uniform\\tvec3 v3CameraPosInput;\\r\\nuniform vec3 v3LightPosInput;\\r\\n\\r\\nuniform float fInnerRadius;\\r\\nuniform float fOuterRadius;\\r\\n\\r\\nuniform float fScaleDepth;\\r\\nuniform vec4 inputColor;\\r\\nuniform vec4 alphaValue;\\r\\nuniform float night;\\r\\n\\r\\nuniform float contrast;\\r\\nuniform float hue;\\r\\nuniform float saturation;\\r\\nuniform float textureGamma;\\r\\n//uniform vec4 earthColor;\\r\\n//uniform vec4 earthAddColor;\\r\\n//uniform float isAddEffect;\\r\\nuniform vec4 u_initialColor;\\r\\nuniform float nightfadeIn;\\r\\nuniform float nightfadeOut;\\r\\nuniform float fadeInDist;\\r\\nuniform float fadeOutDist;\\r\\n\\r\\nuniform float czm_fogDensity;\\r\\nuniform sampler2D colorMapping;\\r\\n\\r\\n// 是否开启颜色叠加 0 关闭 1 开启\\r\\nuniform float gradientColorOverlayEnable;\\r\\n// 颜色叠加方向\\r\\nuniform vec3 mapDirection;\\r\\n// 叠加使用的渐变纹理\\r\\nuniform sampler2D gradientColorMap;\\r\\n// 叠加使用的透明度\\r\\nuniform float gradientOpacity;\\r\\n\\r\\n//#define saturate(a) clamp( a, 0.0, 1.0 )\\r\\n//#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\r\\n//#define LOG2 1.442695\\r\\nstruct czm_ellipsoid {\\r\\n\\tvec3 center;\\r\\n\\tvec3 radii;\\r\\n\\tvec3 inverseRadii;\\r\\n\\tvec3 inverseRadiiSquared;\\r\\n};\\r\\nstruct AtmosphereColor {\\r\\n\\tvec3 mie;\\r\\n\\tvec3 rayleigh;\\r\\n};\\r\\n\\r\\n//搞定\\r\\nfloat scale(float fCos, float fScaleDepth) {\\r\\n\\tfloat x = 1.0 - fCos;\\r\\n\\treturn fScaleDepth * exp( - 0.00287 + x * (0.459 + x * (3.83 + x * ( - 6.80 + x * 5.25))));\\r\\n}\\r\\nvec4 depthColor(vec4 color) {\\r\\n\\tcolor.r = color.r * color.r * color.r;\\r\\n\\tcolor.g = color.g * color.g * color.g;\\r\\n\\tcolor.b = color.b * color.b;\\r\\n\\treturn color;\\r\\n}\\r\\n//搞定\\r\\n// Returns the near intersection point of a line and a sphere\\r\\nfloat getNearIntersection(vec3 v3Pos, vec3 v3Ray, float fDistance2, float fRadius2) {\\r\\n\\tfloat B = 2.0 * dot(v3Pos, v3Ray);\\r\\n\\tfloat C = fDistance2 - fRadius2;\\r\\n\\tfloat fDet = max(0.0, B * B - 4.0 * C);\\r\\n\\treturn 0.5 * ( - B - sqrt(fDet));\\r\\n}\\r\\n\\r\\n//contrast added by zhgu\\r\\nvec3 czm_contrast(vec3 rgb, float contrast) {\\r\\n\\tvec3 color = mix(vec3(0.5), rgb, contrast);\\r\\n\\tcolor = clamp(color, 0.0, 1.0);\\r\\n\\treturn color;\\r\\n}\\r\\n\\r\\n//hue added by zhgu\\r\\nvec3 czm_hue(vec3 rgb, float adjustment) {\\r\\n\\tconst mat3 toYIQ = mat3(0.299, 0.587, 0.114, 0.595716, -0.274453, -0.321263, 0.211456, -0.522591, 0.311135);\\r\\n\\tconst mat3 toRGB = mat3(1.0, 0.9563, 0.6210, 1.0, -0.2721, -0.6474, 1.0, -1.107, 1.7046);\\r\\n\\tvec3 yiq = toYIQ * rgb;\\r\\n\\tfloat hue = atan(yiq.z, yiq.y) + adjustment;\\r\\n\\tfloat chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\\r\\n\\tvec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\\r\\n\\tvec3 final = toRGB * color;\\r\\n\\tfinal = clamp(final, 0.0, 1.0);\\r\\n\\treturn final;\\r\\n}\\r\\n//saturation added by zhgu\\r\\nvec3 czm_saturation(vec3 rgb, float adjustment) {\\r\\n\\tconst vec3 W = vec3(0.2125, 0.7154, 0.0721);\\r\\n\\tvec3 intensity = vec3(dot(rgb, W));\\r\\n\\tvec3 color = mix(intensity, rgb, adjustment);\\r\\n\\tcolor = clamp(color, 0.0, 1.0);\\r\\n\\treturn color;\\r\\n\\r\\n}\\r\\n\\r\\nvec4 sampleAndBlend(float addEffect, vec4 eColor, vec4 addColor, vec4 previousColor, sampler2D sampler_texture, vec2 tileTextureCoordinates, vec4 textureCoordinateRectangle, vec4 textureCoordinateTranslationAndScale, float textureAlphaIndex, float brightness, float south, float north, float southMercatorY, float oneOverMercatorHeight, float isReProjection, vec4 alphaValue, float contrast, float hue, float saturation, float gamma) {\\r\\n\\r\\n\\tfloat textureAlpha = 1.0;\\r\\n\\r\\n\\tvec2 alphaMultiplier = step(textureCoordinateRectangle.xy, tileTextureCoordinates);\\r\\n\\ttextureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n\\talphaMultiplier = step(vec2(0.0, 0.0), textureCoordinateRectangle.zw - tileTextureCoordinates);\\r\\n\\ttextureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n\\tvec2 translation = textureCoordinateTranslationAndScale.xy;\\r\\n\\tvec2 scale = textureCoordinateTranslationAndScale.zw;\\r\\n\\tvec2 textureCoordinates = tileTextureCoordinates * scale + translation;\\r\\n\\r\\n    if(oneOverMercatorHeight!=0.0){\\r\\n        //再投影\\r\\n        float latitude = mix(south, north, textureCoordinates.y);\\r\\n        float sinLatitude = sin(latitude);\\r\\n        float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\\r\\n        float mercatorFraction = (mercatorY - southMercatorY) * oneOverMercatorHeight;\\r\\n        textureCoordinates.y = mercatorFraction;\\r\\n\\r\\n        if (isReProjection == 0.0) {\\r\\n            textureCoordinates.y = (tileTextureCoordinates * scale + translation).y;\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\t//textureCoordinates = clamp(textureCoordinates, 1.0/256.0, 255.0/256.0);\\r\\n\\tvec4 value = texture2D(sampler_texture, textureCoordinates);\\r\\n\\tif (addEffect == 1.0) {\\r\\n\\t\\tvalue = depthColor(value);\\r\\n\\t}\\r\\n\\tvalue.rgb *= eColor.rgb;\\r\\n\\t//          if(eColor.a==1.0){\\r\\n\\t//                value *=eColor;\\r\\n\\t//              }\\r\\n\\t//              else{\\r\\n\\t//                //value.rgb = (value.rgb + eColor.rgb * eColor.a)/(1.0 + eColor.a);\\r\\n\\t//                 value.rgb = value.rgb * (1.0-eColor.a) + eColor.rgb * eColor.a;\\r\\n\\t//              }\\r\\n\\tvalue.rgb = (value.rgb + addColor.rgb * addColor.a) / (1.0 + addColor.a);\\r\\n\\tvec3 color = value.rgb;\\r\\n\\tfloat alpha = value.a;\\r\\n\\r\\n\\tcolor = mix(vec3(0.0, 0.0, 0.0), color, brightness);\\r\\n\\t//contrast\\r\\n\\tcolor = czm_contrast(color, contrast);\\r\\n\\t//hue\\r\\n\\tcolor = czm_hue(color, hue);\\r\\n\\t// saturation\\r\\n\\tcolor = czm_saturation(color, saturation);\\r\\n\\t// gamma\\r\\n\\tcolor = pow(color, vec3(gamma));\\r\\n\\r\\n\\tfloat sourceAlpha = alpha * textureAlpha;\\r\\n\\tfloat outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\\r\\n\\tvec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\\r\\n\\treturn vec4(outColor, outAlpha);\\r\\n}\\r\\n\\r\\n//czm_ellipsoid czm_getWgs84EllipsoidEC()\\r\\n//{\\r\\n//    vec3 radii = vec3(6378137.0, 6378137.0, 6356752.314245);\\r\\n//    vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\\r\\n//    vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\\r\\n//    czm_ellipsoid temp = czm_ellipsoid(viewMatrix[3].xyz, radii, inverseRadii, inverseRadiiSquared);\\r\\n//    return temp;\\r\\n//}\\r\\nfloat czm_fade(float cameraDist, float fadeInDist, float fadeOutDist) {\\r\\n\\tfloat fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\\r\\n\\treturn fade;\\r\\n}\\r\\nAtmosphereColor computeGroundAtmosphereFromSpace(vec3 v3Pos, bool useSunLighting) {\\r\\n\\t//float PI = 3.14159265;\\r\\n\\t//float g2 =  g * g;\\r\\n\\tvec3 v3InvWavelength = vec3(1.0 / pow(0.650, 4.0), 1.0 / pow(0.570, 4.0), 1.0 / pow(0.475, 4.0));\\r\\n\\r\\n\\tvec3 v3CameraPos = vec3(0.0, 0.0, 0.0);\\r\\n\\tv3CameraPos = cameraPosition;\\r\\n\\r\\n\\t// vec3 v3LightPos = v3LightPosInput / length(v3LightPosInput);\\r\\n\\tvec3 v3LightPos = v3LightPosInput;\\r\\n\\r\\n\\tfloat fCameraHeight = length(v3CameraPos);\\r\\n\\r\\n\\tfloat fCameraHeight2 = fCameraHeight * fCameraHeight;\\r\\n\\r\\n\\tfloat inOutFactor = 1.05;\\r\\n\\tfloat fInnerRadius2 = fInnerRadius * fInnerRadius;\\r\\n\\tfloat fOuterRadius2 = fOuterRadius * fOuterRadius;\\r\\n\\r\\n\\tfloat fKrESun = Kr * ESun;\\r\\n\\tfloat fKmESun = Km * ESun;\\r\\n\\tfloat fKr4PI = Kr * 4.0 * PI;\\r\\n\\tfloat fKm4PI = Km * 4.0 * PI;\\r\\n\\r\\n\\tfloat fInvScaleDepth = 1.0 / fScaleDepth;\\r\\n\\tfloat fScale = 1.0 / (fOuterRadius - fInnerRadius);\\r\\n\\tfloat fScaleOverScaleDepth = fScale / fScaleDepth;\\r\\n\\r\\n\\t////////////////////////////////////////////////\\r\\n\\t// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\\r\\n\\t//            \\tvec3 v3Pos = PositionWS;\\r\\n\\tvec3 v3Ray = v3Pos - v3CameraPos;\\r\\n\\tv3Pos = normalize(v3Pos);\\r\\n\\tfloat fFar = length(v3Ray);\\r\\n\\tv3Ray /= fFar;\\r\\n\\t// Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\\r\\n\\tfloat fNear = getNearIntersection(v3CameraPos, v3Ray, fCameraHeight2, fOuterRadius2);\\r\\n\\t// Calculate the ray\'s starting position, then calculate its scattering offset\\r\\n\\tvec3 v3Start = v3CameraPos + v3Ray * fNear;\\r\\n\\tfFar -= fNear;\\r\\n\\tfloat fDepth = exp((fInnerRadius - fOuterRadius) * fInvScaleDepth);\\r\\n\\r\\n\\t//changed by zhgu if you donnot want night make it 1.0\\r\\n\\tfloat fLightAngle = useSunLighting ? dot(v3LightPos, v3Pos) / length(v3Pos) : 1.0;\\r\\n\\tfloat fCameraAngle = dot( - v3Ray, v3Pos) / length(v3Pos);\\r\\n\\t//float fLightAngle = dot(v3LightPos, v3Pos);\\r\\n\\tfloat fCameraScale = scale(fCameraAngle, fScaleDepth);\\r\\n\\tfloat fLightScale = scale(fLightAngle, fScaleDepth);\\r\\n\\tfloat fCameraOffset = fDepth * fCameraScale;\\r\\n\\tfloat fTemp = (fLightScale + fCameraScale);\\r\\n\\t// Initialize the scattering loop variables\\r\\n\\t//gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);\\r\\n\\tfloat fSampleLength = fFar / fSamples;\\r\\n\\tfloat fScaledLength = fSampleLength * fScale;\\r\\n\\tvec3 v3SampleRay = v3Ray * fSampleLength;\\r\\n\\tvec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\\r\\n\\t// Now loop through the sample rays\\r\\n\\tvec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\\r\\n\\tvec3 v3Attenuate = vec3(0.0, 0.0, 0.0);\\r\\n\\tfor (int i = 0; i < 2; i++) {\\r\\n\\t\\tfloat fHeight = length(v3SamplePoint);\\r\\n\\t\\tfloat fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\\r\\n\\t\\tfloat fScatter = fDepth * fTemp - fCameraOffset;\\r\\n\\t\\tv3Attenuate = exp( - fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\\r\\n\\t\\tv3FrontColor += v3Attenuate * (fDepth * fScaledLength);\\r\\n\\t\\tv3SamplePoint += v3SampleRay;\\r\\n\\t}\\r\\n\\tAtmosphereColor color;\\r\\n\\tcolor.mie = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\\r\\n\\tcolor.rayleigh = v3Attenuate;\\r\\n\\treturn color;\\r\\n\\r\\n}\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor) {\\r\\n\\tfloat scalar = distanceToCamera * czm_fogDensity;\\r\\n\\tfloat fog = 1.0 - exp( - (scalar * scalar));\\r\\n\\treturn mix(color, fogColor, fog);\\r\\n}\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant) {\\r\\n\\tfloat scalar = distanceToCamera * czm_fogDensity;\\r\\n\\tfloat fog = 1.0 - exp( - ((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));\\r\\n\\treturn mix(color, fogColor, fog);\\r\\n}\\r\\n\\r\\nvec4 czm_FilterColor(vec4 finalColor) {\\r\\n\\tvec4 finalColor1 = vec4(0);\\r\\n\\tif (grayFilterEnable) {\\r\\n\\t\\tfloat gray = clamp(dot(finalColor.rgb, vec3(0.333, 0.333, 0.333)), 0.0, 1.0);\\r\\n\\t\\tfinalColor1.rgb = texture2D(colorMapping, vec2(gray, 0.5)).rgb;\\r\\n\\t\\tfinalColor1.a = finalColor.a;\\r\\n\\t} else {\\r\\n\\t\\tfinalColor1 = finalColor;\\r\\n\\t}\\r\\n\\treturn finalColor1;\\r\\n}\\r\\nfloat czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC) {\\r\\n\\treturn max(dot(lightDirectionEC, normalEC), 0.0);\\r\\n}\\r\\nvarying float dotValue;\\r\\nvarying vec3 sunDirectionEC;\\r\\nvarying vec3 normalEC;\\r\\nvoid main() {\\r\\n    #include <logdepthbuf_fragment>\\r\\n\\t//vec2 texCoords =  vec2( gl_TexCoord[0] );\\r\\n\\tvec2 webglUv = texCoords;\\r\\n\\t//        webglUv.y =1.0 - webglUv.y;\\r\\n\\twebglUv = clamp(webglUv, 0.0, 1.0);\\r\\n\\tvec4 lastColor = sampleAndBlend(isAddEffect0, earthColor0, earthAddColor0, u_initialColor, TexSampler0, webglUv, textureRectangle0, textureTransAndScale0, alphaIndex0, brightness0, south1, north1, southMercatorY1, oneOverMercatorHeight1, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect1, earthColor1, earthAddColor1, lastColor, TexSampler1, webglUv, textureRectangle1, textureTransAndScale1, alphaIndex1, brightness1, south2, north2, southMercatorY2, oneOverMercatorHeight2, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect2, earthColor2, earthAddColor2, lastColor, TexSampler2, webglUv, textureRectangle2, textureTransAndScale2, alphaIndex2, brightness2, south3, north3, southMercatorY3, oneOverMercatorHeight3, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n\\t//added fade by zhgu to caculate fog\\r\\n\\t//float cameraDist = length(viewMatrix[3]);\\r\\n\\tfloat cameraDist = length(cameraPosition);\\r\\n\\tfloat fade = czm_fade(cameraDist, fadeInDist, fadeOutDist);\\r\\n\\r\\n\\t//added lambertDiffuse TODO is it effective? 这个很一般，先忽略吧，毕竟咱们性能不太好啊\\r\\n\\t//float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_sunDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);\\r\\n\\t//diffuseIntensity = mix(1.0, diffuseIntensity, fade);\\r\\n\\t//vec4 finalColor = vec4(color.rgb * diffuseIntensity, color.a);\\r\\n\\tvec4 finalColor = lastColor;\\r\\n\\t//added fogColor and hdr\\r\\n\\t//added fogColor and hdr\\r\\n\\tAtmosphereColor atmosFogColor = computeGroundAtmosphereFromSpace(PositionWS, false);\\r\\n\\tvec3 c0 = atmosFogColor.mie;\\r\\n\\tvec3 c1 = atmosFogColor.rayleigh;\\r\\n\\tvec3 fogColor1 = c0 + finalColor.rgb * c1;\\r\\n\\t//we should use hdr\\r\\n\\tconst float fExposure = 2.0;\\r\\n\\tfogColor1 = vec3(1.0) - exp( - fExposure * fogColor1);\\r\\n\\r\\n\\t//fog added\\r\\n\\t// const float modifier = 0.15;\\r\\n\\tfinalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor1), finalColor.a);\\r\\n\\r\\n\\t// ---------------------------------------------------------------------------\\r\\n\\t//ground\\r\\n\\t//SUN 这个sun的计算处理了下，我们不能和cesium用一样的参数，这样可能无法模拟真实太阳的位置\\r\\n\\t// changed by ztf 此处太阳光照计算废弃\\r\\n\\t// vec3 groundAtmosphereColor = vec3(0.0);\\r\\n\\t// if(night == 1.0){\\r\\n\\t//         AtmosphereColor atmosColor = computeGroundAtmosphereFromSpace(PositionWS, true);\\r\\n\\t//         groundAtmosphereColor = atmosColor.mie + finalColor.rgb * atmosColor.rayleigh;\\r\\n\\t//         groundAtmosphereColor = vec3(1.0) - exp(-fExposure * groundAtmosphereColor);\\r\\n\\t//         //TODO 这个可能要弱一点才行\\r\\n\\t//         float sunlitAtmosphereIntensity = clamp((cameraDist - nightfadeOut) / (nightfadeIn - nightfadeOut), 0.0, 1.0);//caculate sun\\r\\n\\t//         // used hdr to make HDR look better\\r\\n\\t//         sunlitAtmosphereIntensity = max(sunlitAtmosphereIntensity * sunlitAtmosphereIntensity, 0.03);\\r\\n\\t//         //mix sun\\r\\n\\t//         groundAtmosphereColor = mix(groundAtmosphereColor, fogColor1, sunlitAtmosphereIntensity);\\r\\n\\t// }\\r\\n\\t// else{\\r\\n\\t//         groundAtmosphereColor = fogColor1;\\r\\n\\t// }\\r\\n\\tvec3 groundAtmosphereColor = fogColor1;\\r\\n\\t// ---------------------------------------------------------------------------\\r\\n\\t//use saturation to look better\\r\\n\\tgroundAtmosphereColor = czm_saturation(groundAtmosphereColor, 1.6);\\r\\n\\t//mix\\r\\n\\tfinalColor = vec4(mix(finalColor.rgb, groundAtmosphereColor, fade), finalColor.a);\\r\\n\\tfinalColor.rgb *= vec3(earthColor0.a);\\r\\n\\t//finally you get the color\\r\\n\\tfinalColor = czm_FilterColor(finalColor);\\r\\n\\tgl_FragColor = finalColor;\\r\\n\\t//now we get the shadow\\r\\n\\t//                gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), (1.0-getShadowMask()));\\r\\n\\tvec4 shadow = vec4(vec3(0.0), shadowOpacity * (1.0 - getShadowMask()));\\r\\n\\tgl_FragColor.rgb = mix(gl_FragColor.rgb, shadow.rgb, shadow.a);\\r\\n\\r\\n\\t// 昼夜和线性颜色叠加 互斥 开启\\r\\n\\tif (night == 1.0) {\\r\\n\\r\\n\\t\\tfloat diffuseIntensity = czm_getLambertDiffuse(sunDirectionEC, normalize(normalEC)) * 0.9 + 0.2;\\r\\n\\t\\tgl_FragColor = vec4(gl_FragColor.rgb * diffuseIntensity, gl_FragColor.a);\\r\\n\\r\\n\\t} else {\\r\\n\\r\\n\\t\\t// // 是否开启颜色叠加 0 关闭 1 开启\\r\\n\\t\\t// uniform float gradientColorOverlayEnable;\\r\\n\\t\\t// // 颜色叠加方向\\r\\n\\t\\t// uniform vec3 mapDirection;\\r\\n\\t\\t// // 叠加使用的渐变纹理\\r\\n\\t\\t// uniform sampler2D gradientColorMap;\\r\\n\\t\\tif (gradientColorOverlayEnable == 1.0) {\\r\\n\\r\\n\\t\\t\\tfloat diffuseIntensity = dot(mapDirection, normalize(normalEC));\\r\\n\\t\\t\\tfloat uv_U = (diffuseIntensity + 1.0) / 2.0; // -1 ——> 1 映射到 0 —— 1\\r\\n\\t\\t\\tfloat uv_V = 0.1;\\r\\n\\r\\n\\t\\t\\tvec4 gradientColor = texture2D(gradientColorMap, vec2(uv_U, uv_V));\\r\\n\\r\\n\\t\\t\\tfloat tempR = gradientColor.r + (1.0 - gradientColor.r) * (1.0 - gradientOpacity);\\r\\n\\t\\t\\tfloat tempG = gradientColor.g + (1.0 - gradientColor.g) * (1.0 - gradientOpacity);\\r\\n\\t\\t\\tfloat tempB = gradientColor.b + (1.0 - gradientColor.b) * (1.0 - gradientOpacity);\\r\\n\\r\\n\\t\\t\\tgl_FragColor = vec4(gl_FragColor.rgb * vec3(tempR, tempG, tempB), gl_FragColor.a);\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t#include <fog_fragment>\\r\\n}"\n\n//# sourceURL=webpack:///./src/material/shaders/mult_texture3.glsl?')
        },
        "./src/material/shaders/mult_texture4.glsl": /*!*************************************************!*\
  !*** ./src/material/shaders/mult_texture4.glsl ***!
  \*************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "//varying vec4 Position;\\r\\n//precision highp float;\\r\\n//varying vec3 ModelPostion;\\r\\n#include <common>\\r\\n#include <packing>\\r\\n#include <fog_pars_fragment>\\r\\n#include <bsdfs>\\r\\n#include <lights_pars_begin>\\r\\n#include <shadowmap_pars_fragment>\\r\\n#include <shadowmask_pars_fragment>\\r\\n#include <logdepthbuf_pars_fragment>\\r\\nvarying float v_distance;\\r\\nvarying vec3 PositionWS;\\r\\nvarying vec2 texCoords;\\r\\n\\r\\nuniform bool grayFilterEnable;\\r\\nuniform float grayFilterIndex;\\r\\nuniform float shadowOpacity;\\r\\n//uniform float grayMinMax[2];\\r\\n//uniform float grayFilterPerBar[10];\\r\\n//uniform vec3 grayFilterColorBar[10];\\r\\n\\r\\nuniform sampler2D TexSampler0;\\r\\nuniform sampler2D TexSampler1;\\r\\nuniform sampler2D TexSampler2;\\r\\nuniform sampler2D TexSampler3;\\r\\n\\r\\nuniform vec4 textureRectangle0;\\r\\nuniform vec4 textureRectangle1;\\r\\nuniform vec4 textureRectangle2;\\r\\nuniform vec4 textureRectangle3;\\r\\n\\r\\nuniform vec4 textureTransAndScale0;\\r\\nuniform vec4 textureTransAndScale1;\\r\\nuniform vec4 textureTransAndScale2;\\r\\nuniform vec4 textureTransAndScale3;\\r\\n\\r\\nuniform float brightness0;\\r\\nuniform float brightness1;\\r\\nuniform float brightness2;\\r\\nuniform float brightness3;\\r\\n\\r\\nuniform float alphaIndex0;\\r\\nuniform float alphaIndex1;\\r\\nuniform float alphaIndex2;\\r\\nuniform float alphaIndex3;\\r\\n\\r\\nuniform float isAddEffect0;\\r\\nuniform float isAddEffect1;\\r\\nuniform float isAddEffect2;\\r\\nuniform float isAddEffect3;\\r\\n\\r\\nuniform vec4 earthColor0;\\r\\nuniform vec4 earthColor1;\\r\\nuniform vec4 earthColor2;\\r\\nuniform vec4 earthColor3;\\r\\n\\r\\nuniform vec4 earthAddColor0;\\r\\nuniform vec4 earthAddColor1;\\r\\nuniform vec4 earthAddColor2;\\r\\nuniform vec4 earthAddColor3;\\r\\n\\r\\nuniform float south1;\\r\\nuniform float north1;\\r\\nuniform float southMercatorY1;\\r\\nuniform float oneOverMercatorHeight1;\\r\\nuniform float isReProjection;\\r\\n\\r\\nuniform float south2;\\r\\nuniform float north2;\\r\\nuniform float southMercatorY2;\\r\\nuniform float oneOverMercatorHeight2;\\r\\n\\r\\nuniform float south3;\\r\\nuniform float north3;\\r\\nuniform float southMercatorY3;\\r\\nuniform float oneOverMercatorHeight3;\\r\\n\\r\\nuniform float south4;\\r\\nuniform float north4;\\r\\nuniform float southMercatorY4;\\r\\nuniform float oneOverMercatorHeight4;\\r\\n\\r\\nuniform float Km;\\r\\nuniform float Kr;\\r\\nuniform float ESun;\\r\\n\\r\\nuniform int nSamples;\\r\\nuniform float fSamples;\\r\\n\\r\\n//uniform float g,\\r\\n\\r\\n//uniform\\tvec3 v3CameraPosInput;\\r\\nuniform vec3 v3LightPosInput;\\r\\n\\r\\nuniform float fInnerRadius;\\r\\nuniform float fOuterRadius;\\r\\n\\r\\nuniform float fScaleDepth;\\r\\nuniform vec4 inputColor;\\r\\nuniform vec4 alphaValue;\\r\\nuniform float night;\\r\\n\\r\\nuniform float contrast;\\r\\nuniform float hue;\\r\\nuniform float saturation;\\r\\nuniform float textureGamma;\\r\\n//uniform vec4 earthColor;\\r\\n//uniform vec4 earthAddColor;\\r\\n//uniform float isAddEffect;\\r\\n\\r\\nuniform vec4 u_initialColor;\\r\\nuniform float nightfadeIn;\\r\\nuniform float nightfadeOut;\\r\\nuniform float fadeInDist;\\r\\nuniform float fadeOutDist;\\r\\n\\r\\nuniform float czm_fogDensity;\\r\\nuniform sampler2D colorMapping;\\r\\n\\r\\n// 是否开启颜色叠加 0 关闭 1 开启\\r\\nuniform float gradientColorOverlayEnable;\\r\\n// 颜色叠加方向\\r\\nuniform vec3 mapDirection;\\r\\n// 叠加使用的渐变纹理\\r\\nuniform sampler2D gradientColorMap;\\r\\n// 叠加使用的透明度\\r\\nuniform float gradientOpacity;\\r\\n\\r\\n//#define saturate(a) clamp( a, 0.0, 1.0 )\\r\\n//#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\r\\n//#define LOG2 1.442695\\r\\nstruct czm_ellipsoid\\r\\n  {\\r\\n    vec3 center;\\r\\n    vec3 radii;\\r\\n    vec3 inverseRadii;\\r\\n    vec3 inverseRadiiSquared;\\r\\n  };\\r\\nstruct AtmosphereColor\\r\\n  {\\r\\n    vec3 mie;\\r\\n    vec3 rayleigh;\\r\\n  };\\r\\n\\r\\n//搞定\\r\\nfloat scale(float fCos, float fScaleDepth)\\r\\n{\\r\\n  float x = 1.0 - fCos;\\r\\n  return fScaleDepth * exp(-0.00287 + x * (0.459 + x * (3.83 + x * (-6.80 + x * 5.25))));\\r\\n}\\r\\n\\r\\nvec4 depthColor(vec4 color)\\r\\n{\\r\\n  color.r = color.r * color.r * color.r;\\r\\n  color.g = color.g * color.g * color.g;\\r\\n  color.b = color.b * color.b;\\r\\n  return color;\\r\\n}\\r\\n\\r\\n//搞定\\r\\n// Returns the near intersection point of a line and a sphere\\r\\nfloat getNearIntersection(vec3 v3Pos, vec3 v3Ray, float fDistance2, float fRadius2)\\r\\n{\\r\\n  float B = 2.0 * dot(v3Pos, v3Ray);\\r\\n  float C = fDistance2 - fRadius2;\\r\\n  float fDet = max(0.0, B * B - 4.0 * C);\\r\\n  return 0.5 * (-B - sqrt(fDet));\\r\\n}\\r\\n\\r\\n//contrast added by zhgu\\r\\nvec3 czm_contrast(vec3 rgb, float contrast) {\\r\\n  vec3 color = mix(vec3(0.5), rgb, contrast);\\r\\n  color = clamp(color, 0.0, 1.0);\\r\\n  return color;\\r\\n}\\r\\n\\r\\n//hue added by zhgu\\r\\nvec3 czm_hue(vec3 rgb, float adjustment)\\r\\n{\\r\\n  const mat3 toYIQ = mat3(0.299, 0.587, 0.114,\\r\\n    0.595716, -0.274453, -0.321263,\\r\\n    0.211456, -0.522591, 0.311135);\\r\\n  const mat3 toRGB = mat3(1.0, 0.9563, 0.6210,\\r\\n    1.0, -0.2721, -0.6474,\\r\\n    1.0, -1.107, 1.7046);\\r\\n  vec3 yiq = toYIQ * rgb;\\r\\n  float hue = atan(yiq.z, yiq.y) + adjustment;\\r\\n  float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\\r\\n  vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\\r\\n  vec3 final = toRGB * color;\\r\\n  final = clamp(final, 0.0, 1.0);\\r\\n  return final;\\r\\n}\\r\\n//saturation added by zhgu\\r\\nvec3 czm_saturation(vec3 rgb, float adjustment)\\r\\n{\\r\\n  const vec3 W = vec3(0.2125, 0.7154, 0.0721);\\r\\n  vec3 intensity = vec3(dot(rgb, W));\\r\\n  vec3 color = mix(intensity, rgb, adjustment);\\r\\n  color = clamp(color, 0.0, 1.0);\\r\\n  return color;\\r\\n}\\r\\n\\r\\nvec4 czm_FilterColor(vec4 finalColor) {\\r\\n  vec4 finalColor1 = vec4(0);\\r\\n  if (grayFilterEnable) {\\r\\n    float gray = clamp(dot(finalColor.rgb, vec3(0.333, 0.333, 0.333)), 0.0, 1.0);\\r\\n    finalColor1.rgb = texture2D(colorMapping, vec2(gray, 0.5)).rgb;\\r\\n    finalColor1.a = finalColor.a;\\r\\n  } else {\\r\\n    finalColor1 = finalColor;\\r\\n  }\\r\\n  return finalColor1;\\r\\n}\\r\\nvec4 sampleAndBlend(\\r\\n  float addEffect,\\r\\n  vec4 eColor,\\r\\n  vec4 addColor,\\r\\n  vec4 previousColor,\\r\\n  sampler2D sampler_texture,\\r\\n  vec2 tileTextureCoordinates,\\r\\n  vec4 textureCoordinateRectangle,\\r\\n  vec4 textureCoordinateTranslationAndScale,\\r\\n  float textureAlphaIndex,\\r\\n  float brightness,\\r\\n  float south,\\r\\n  float north,\\r\\n  float southMercatorY,\\r\\n  float oneOverMercatorHeight,\\r\\n  float isReProjection,\\r\\n  vec4 alphaValue,\\r\\n  float contrast,\\r\\n  float hue,\\r\\n  float saturation,\\r\\n  float gamma,\\r\\n  float index)\\r\\n{\\r\\n  float textureAlpha = 1.0;\\r\\n\\r\\n  vec2 alphaMultiplier = step(textureCoordinateRectangle.xy, tileTextureCoordinates);\\r\\n  textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n  alphaMultiplier = step(vec2(0.0, 0.0), textureCoordinateRectangle.zw - tileTextureCoordinates);\\r\\n  textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n  vec2 translation = textureCoordinateTranslationAndScale.xy;\\r\\n  vec2 scale = textureCoordinateTranslationAndScale.zw;\\r\\n  vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\\r\\n\\r\\n  //再投影\\r\\n  if(oneOverMercatorHeight!=0.0){\\r\\n    float latitude = mix(south, north, textureCoordinates.y);\\r\\n    float sinLatitude = sin(latitude);\\r\\n    float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\\r\\n    float mercatorFraction = (mercatorY - southMercatorY) * oneOverMercatorHeight;\\r\\n    textureCoordinates.y = mercatorFraction;\\r\\n    if (isReProjection == 0.0) {\\r\\n        textureCoordinates.y = (tileTextureCoordinates * scale + translation).y;\\r\\n    }\\r\\n  }\\r\\n  vec4 value = texture2D(sampler_texture, textureCoordinates);\\r\\n  if (addEffect == 1.0) {\\r\\n    value = depthColor(value);\\r\\n  }\\r\\n  value.rgb *= eColor.rgb;\\r\\n  //      if(eColor.a==1.0){\\r\\n  //            value *=eColor;\\r\\n  //          }\\r\\n  //          else{\\r\\n  //            //value.rgb = (value.rgb + eColor.rgb * eColor.a)/(1.0 + eColor.a);\\r\\n  //             value.rgb = value.rgb * (1.0-eColor.a) + eColor.rgb * eColor.a;\\r\\n  //          }\\r\\n  value.rgb = (value.rgb + addColor.rgb * addColor.a) / (1.0 + addColor.a);\\r\\n  vec3 color = value.rgb;\\r\\n  float alpha = value.a;\\r\\n\\r\\n  color = mix(vec3(0.0, 0.0, 0.0), color, brightness);\\r\\n  //contrast\\r\\n  color = czm_contrast(color, contrast);\\r\\n  //hue\\r\\n  color = czm_hue(color, hue);\\r\\n  // saturation\\r\\n  color = czm_saturation(color, saturation);\\r\\n  // gamma\\r\\n  color = pow(color, vec3(gamma));\\r\\n  //finally you get the color\\r\\n  if (grayFilterIndex == textureAlphaIndex) {\\r\\n    color = czm_FilterColor(vec4(color, alpha)).rgb;\\r\\n  }\\r\\n\\r\\n  float sourceAlpha = alpha * textureAlpha;\\r\\n  float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\\r\\n  vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\\r\\n  return vec4(outColor, outAlpha);\\r\\n}\\r\\n\\r\\n//czm_ellipsoid czm_getWgs84EllipsoidEC()\\r\\n//{\\r\\n//    vec3 radii = vec3(6378137.0, 6378137.0, 6356752.314245);\\r\\n//    vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\\r\\n//    vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\\r\\n//    czm_ellipsoid temp = czm_ellipsoid(viewMatrix[3].xyz, radii, inverseRadii, inverseRadiiSquared);\\r\\n//    return temp;\\r\\n//}\\r\\nfloat czm_fade(float cameraDist, float fadeInDist, float fadeOutDist) {\\r\\n  float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\\r\\n  return fade;\\r\\n}\\r\\nAtmosphereColor computeGroundAtmosphereFromSpace(vec3 v3Pos, bool useSunLighting) {\\r\\n  //float PI = 3.14159265;\\r\\n  //float g2 =  g * g;\\r\\n\\r\\n  vec3 v3InvWavelength = vec3(1.0 / pow(0.650, 4.0), 1.0 / pow(0.570, 4.0), 1.0 / pow(0.475, 4.0));\\r\\n\\r\\n  vec3 v3CameraPos = vec3(0.0, 0.0, 0.0);\\r\\n  v3CameraPos = cameraPosition;\\r\\n\\r\\n  // vec3 v3LightPos = v3LightPosInput / length(v3LightPosInput);\\r\\n  vec3 v3LightPos = v3LightPosInput;\\r\\n\\r\\n  float fCameraHeight = length(v3CameraPos);\\r\\n\\r\\n  float fCameraHeight2 = fCameraHeight * fCameraHeight;\\r\\n\\r\\n  float inOutFactor = 1.05;\\r\\n  float fInnerRadius2 = fInnerRadius * fInnerRadius;\\r\\n  float fOuterRadius2 = fOuterRadius * fOuterRadius;\\r\\n\\r\\n  float fKrESun = Kr * ESun;\\r\\n  float fKmESun = Km * ESun;\\r\\n  float fKr4PI = Kr * 4.0 * PI;\\r\\n  float fKm4PI = Km * 4.0 * PI;\\r\\n\\r\\n  float fInvScaleDepth = 1.0 / fScaleDepth;\\r\\n  float fScale = 1.0 / (fOuterRadius - fInnerRadius);\\r\\n  float fScaleOverScaleDepth = fScale / fScaleDepth;\\r\\n\\r\\n  ////////////////////////////////////////////////\\r\\n  // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\\r\\n  //            \\tvec3 v3Pos = PositionWS;\\r\\n  vec3 v3Ray = v3Pos - v3CameraPos;\\r\\n  v3Pos = normalize(v3Pos);\\r\\n  float fFar = length(v3Ray);\\r\\n  v3Ray /= fFar;\\r\\n  // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\\r\\n  float fNear = getNearIntersection(v3CameraPos, v3Ray, fCameraHeight2, fOuterRadius2);\\r\\n  // Calculate the ray\'s starting position, then calculate its scattering offset\\r\\n  vec3 v3Start = v3CameraPos + v3Ray * fNear;\\r\\n  fFar -= fNear;\\r\\n  float fDepth = exp((fInnerRadius - fOuterRadius) * fInvScaleDepth);\\r\\n\\r\\n  //changed by zhgu if you donnot want night make it 1.0\\r\\n  float fLightAngle = useSunLighting ? dot(v3LightPos, v3Pos) / length(v3Pos) : 1.0;\\r\\n  float fCameraAngle = dot(-v3Ray, v3Pos) / length(v3Pos);\\r\\n  //float fLightAngle = dot(v3LightPos, v3Pos);\\r\\n  float fCameraScale = scale(fCameraAngle, fScaleDepth);\\r\\n  float fLightScale = scale(fLightAngle, fScaleDepth);\\r\\n  float fCameraOffset = fDepth * fCameraScale;\\r\\n  float fTemp = (fLightScale + fCameraScale);\\r\\n  // Initialize the scattering loop variables\\r\\n  //gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);\\r\\n  float fSampleLength = fFar / fSamples;\\r\\n  float fScaledLength = fSampleLength * fScale;\\r\\n  vec3 v3SampleRay = v3Ray * fSampleLength;\\r\\n  vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\\r\\n  // Now loop through the sample rays\\r\\n  vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\\r\\n  vec3 v3Attenuate = vec3(0.0, 0.0, 0.0);\\r\\n  for (int i = 0; i <2; i++)\\r\\n  {\\r\\n    float fHeight = length(v3SamplePoint);\\r\\n    float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\\r\\n    float fScatter = fDepth * fTemp - fCameraOffset;\\r\\n    v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\\r\\n    v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\\r\\n    v3SamplePoint += v3SampleRay;\\r\\n  }\\r\\n  AtmosphereColor color;\\r\\n  color.mie = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\\r\\n  color.rayleigh = v3Attenuate;\\r\\n  return color;\\r\\n}\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor) {\\r\\n  float scalar = distanceToCamera * czm_fogDensity;\\r\\n  float fog = 1.0 - exp(-(scalar * scalar));\\r\\n  return mix(color, fogColor, fog);\\r\\n}\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant) {\\r\\n  float scalar = distanceToCamera * czm_fogDensity;\\r\\n  float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));\\r\\n  return mix(color, fogColor, fog);\\r\\n}\\r\\n\\r\\nfloat czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC)\\r\\n{\\r\\n  return max(dot(lightDirectionEC, normalEC), 0.0);\\r\\n}\\r\\nvarying float dotValue;\\r\\nvarying vec3 sunDirectionEC;\\r\\nvarying vec3 normalEC;\\r\\nvoid main()\\r\\n{\\r\\n  #include <logdepthbuf_fragment>\\r\\n  //vec2 texCoords =  vec2( gl_TexCoord[0] );\\r\\n  vec2 webglUv = texCoords;\\r\\n  //         webglUv.y =1.0 - webglUv.y;\\r\\n  webglUv = clamp(webglUv, 0.0, 1.0);\\r\\n  vec4 lastColor = sampleAndBlend(isAddEffect0, earthColor0, earthAddColor0, u_initialColor, TexSampler0, webglUv, textureRectangle0, textureTransAndScale0, alphaIndex0, brightness0, south1, north1, southMercatorY1, oneOverMercatorHeight1, isReProjection, alphaValue, contrast, hue, saturation, textureGamma, 0.0);\\r\\n  lastColor = sampleAndBlend(isAddEffect1, earthColor1, earthAddColor1, lastColor, TexSampler1, webglUv, textureRectangle1, textureTransAndScale1, alphaIndex1, brightness1, south2, north2, southMercatorY2, oneOverMercatorHeight2, isReProjection, alphaValue, contrast, hue, saturation, textureGamma, 1.0);\\r\\n  lastColor = sampleAndBlend(isAddEffect2, earthColor2, earthAddColor2, lastColor, TexSampler2, webglUv, textureRectangle2, textureTransAndScale2, alphaIndex2, brightness2, south3, north3, southMercatorY3, oneOverMercatorHeight3, isReProjection, alphaValue, contrast, hue, saturation, textureGamma, 2.0);\\r\\n  lastColor = sampleAndBlend(isAddEffect3, earthColor3, earthAddColor3, lastColor, TexSampler3, webglUv, textureRectangle3, textureTransAndScale3, alphaIndex3, brightness3, south4, north4, southMercatorY4, oneOverMercatorHeight4, isReProjection, alphaValue, contrast, hue, saturation, textureGamma, 3.0);\\r\\n  //added fade by zhgu to caculate fog\\r\\n  //float cameraDist = length(viewMatrix[3]);\\r\\n  float cameraDist = length(cameraPosition);\\r\\n  float fade = czm_fade(cameraDist, fadeInDist, fadeOutDist);\\r\\n\\r\\n  //added lambertDiffuse TODO is it effective? 这个很一般，先忽略吧，毕竟咱们性能不太好啊\\r\\n  //float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_sunDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);\\r\\n  //diffuseIntensity = mix(1.0, diffuseIntensity, fade);\\r\\n  //vec4 finalColor = vec4(color.rgb * diffuseIntensity, color.a);\\r\\n  vec4 finalColor = lastColor;\\r\\n  //added fogColor and hdr\\r\\n  //added fogColor and hdr\\r\\n  AtmosphereColor atmosFogColor = computeGroundAtmosphereFromSpace(PositionWS, false);\\r\\n  vec3 c0 = atmosFogColor.mie;\\r\\n  vec3 c1 = atmosFogColor.rayleigh;\\r\\n  vec3 fogColor1 = c0 + finalColor.rgb * c1;\\r\\n  //we should use hdr\\r\\n  const float fExposure = 2.0;\\r\\n  fogColor1 = vec3(1.0) - exp(-fExposure * fogColor1);\\r\\n\\r\\n  //fog added\\r\\n  //const float modifier = 0.15;\\r\\n  finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor1), finalColor.a);\\r\\n\\r\\n  // ---------------------------------------------------------------------------\\r\\n  //ground\\r\\n  //SUN 这个sun的计算处理了下，我们不能和cesium用一样的参数，这样可能无法模拟真实太阳的位置\\r\\n  // changed by ztf 此处太阳光照计算废弃\\r\\n  // vec3 groundAtmosphereColor = vec3(0.0);\\r\\n  // if(night == 1.0){\\r\\n  //         AtmosphereColor atmosColor = computeGroundAtmosphereFromSpace(PositionWS, true);\\r\\n  //         groundAtmosphereColor = atmosColor.mie + finalColor.rgb * atmosColor.rayleigh;\\r\\n  //         groundAtmosphereColor = vec3(1.0) - exp(-fExposure * groundAtmosphereColor);\\r\\n  //         //TODO 这个可能要弱一点才行\\r\\n  //         float sunlitAtmosphereIntensity = clamp((cameraDist - nightfadeOut) / (nightfadeIn - nightfadeOut), 0.0, 1.0);//caculate sun\\r\\n  //         // used hdr to make HDR look better\\r\\n  //         sunlitAtmosphereIntensity = max(sunlitAtmosphereIntensity * sunlitAtmosphereIntensity, 0.03);\\r\\n  //         //mix sun\\r\\n  //         groundAtmosphereColor = mix(groundAtmosphereColor, fogColor1, sunlitAtmosphereIntensity);\\r\\n  // }\\r\\n  // else{\\r\\n  //         groundAtmosphereColor = fogColor1;\\r\\n  // }\\r\\n  vec3 groundAtmosphereColor = fogColor1;\\r\\n  // ---------------------------------------------------------------------------\\r\\n  //use saturation to look better\\r\\n  groundAtmosphereColor = czm_saturation(groundAtmosphereColor, 1.6);\\r\\n  //mix\\r\\n  finalColor = vec4(mix(finalColor.rgb, groundAtmosphereColor, fade), finalColor.a);\\r\\n  finalColor.rgb *= vec3(earthColor0.a);\\r\\n  //finally you get the color\\r\\n  if (grayFilterIndex == -1.0) {\\r\\n    finalColor = czm_FilterColor(finalColor);\\r\\n  }\\r\\n  gl_FragColor = finalColor;\\r\\n  //now we get the shadow\\r\\n  //            gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), (1.0-getShadowMask()));\\r\\n  vec4 shadow = vec4(vec3(0.0), shadowOpacity * (1.0 - getShadowMask()));\\r\\n  gl_FragColor.rgb = mix(gl_FragColor.rgb, shadow.rgb, shadow.a);\\r\\n\\r\\n  // 昼夜和线性颜色叠加 互斥 开启\\r\\n  if (night == 1.0) {\\r\\n    float diffuseIntensity = czm_getLambertDiffuse(sunDirectionEC, normalize(normalEC)) * 0.9 + 0.2;\\r\\n    gl_FragColor = vec4(gl_FragColor.rgb * diffuseIntensity, gl_FragColor.a);\\r\\n  } else {\\r\\n    // // 是否开启颜色叠加 0 关闭 1 开启\\r\\n    // uniform float gradientColorOverlayEnable;\\r\\n    // // 颜色叠加方向\\r\\n    // uniform vec3 mapDirection;\\r\\n    // // 叠加使用的渐变纹理\\r\\n    // uniform sampler2D gradientColorMap;\\r\\n\\r\\n    if (gradientColorOverlayEnable == 1.0) {\\r\\n      float diffuseIntensity = dot(mapDirection, normalize(normalEC));\\r\\n      float uv_U = (diffuseIntensity + 1.0) / 2.0; // -1 ——> 1 映射到 0 —— 1\\r\\n      float uv_V = 0.1;\\r\\n\\r\\n      vec4 gradientColor = texture2D(gradientColorMap, vec2(uv_U, uv_V));\\r\\n\\r\\n      float tempR = gradientColor.r + (1.0 - gradientColor.r) * (1.0 - gradientOpacity);\\r\\n      float tempG = gradientColor.g + (1.0 - gradientColor.g) * (1.0 - gradientOpacity);\\r\\n      float tempB = gradientColor.b + (1.0 - gradientColor.b) * (1.0 - gradientOpacity);\\r\\n\\r\\n      gl_FragColor = vec4(gl_FragColor.rgb * vec3(tempR, tempG, tempB), gl_FragColor.a);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  #include <fog_fragment>\\r\\n}\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/mult_texture4.glsl?')
        },
        "./src/material/shaders/mult_texture5.glsl": /*!*************************************************!*\
  !*** ./src/material/shaders/mult_texture5.glsl ***!
  \*************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "//varying vec4 Position;\\r\\n#include <common>\\r\\n#include <packing>\\r\\n#include <fog_pars_fragment>\\r\\n#include <bsdfs>\\r\\n#include <lights_pars_begin>\\r\\n#include <shadowmap_pars_fragment>\\r\\n#include <shadowmask_pars_fragment>\\r\\n#include <logdepthbuf_pars_fragment>\\r\\nvarying vec3 PositionWS;\\r\\n//varying vec3 ModelPostion;\\r\\nvarying float v_distance;\\r\\nvarying vec2 texCoords;\\r\\n\\r\\nuniform bool grayFilterEnable;\\r\\nuniform float grayFilterIndex;\\r\\nuniform float shadowOpacity;\\r\\n//uniform float grayMinMax[2];\\r\\n//uniform float grayFilterPerBar[10];\\r\\n//uniform vec3 grayFilterColorBar[10];\\r\\n\\r\\nuniform sampler2D TexSampler0;\\r\\nuniform sampler2D TexSampler1;\\r\\nuniform sampler2D TexSampler2;\\r\\nuniform sampler2D TexSampler3;\\r\\nuniform sampler2D TexSampler4;\\r\\n\\r\\nuniform vec4 textureRectangle0;\\r\\nuniform vec4 textureRectangle1;\\r\\nuniform vec4 textureRectangle2;\\r\\nuniform vec4 textureRectangle3;\\r\\nuniform vec4 textureRectangle4;\\r\\n\\r\\nuniform vec4 textureTransAndScale0;\\r\\nuniform vec4 textureTransAndScale1;\\r\\nuniform vec4 textureTransAndScale2;\\r\\nuniform vec4 textureTransAndScale3;\\r\\nuniform vec4 textureTransAndScale4;\\r\\n\\r\\nuniform float brightness0;\\r\\nuniform float brightness1;\\r\\nuniform float brightness2;\\r\\nuniform float brightness3;\\r\\nuniform float brightness4;\\r\\n\\r\\nuniform float alphaIndex0;\\r\\nuniform float alphaIndex1;\\r\\nuniform float alphaIndex2;\\r\\nuniform float alphaIndex3;\\r\\nuniform float alphaIndex4;\\r\\n\\r\\nuniform float isAddEffect0;\\r\\nuniform float isAddEffect1;\\r\\nuniform float isAddEffect2;\\r\\nuniform float isAddEffect3;\\r\\nuniform float isAddEffect4;\\r\\n\\r\\nuniform vec4 earthColor0;\\r\\nuniform vec4 earthColor1;\\r\\nuniform vec4 earthColor2;\\r\\nuniform vec4 earthColor3;\\r\\nuniform vec4 earthColor4;\\r\\n\\r\\nuniform vec4 earthAddColor0;\\r\\nuniform vec4 earthAddColor1;\\r\\nuniform vec4 earthAddColor2;\\r\\nuniform vec4 earthAddColor3;\\r\\nuniform vec4 earthAddColor4;\\r\\n\\r\\nuniform float south1;\\r\\nuniform float north1;\\r\\nuniform float southMercatorY1;\\r\\nuniform float oneOverMercatorHeight1;\\r\\nuniform float isReProjection;\\r\\n\\r\\nuniform float south2;\\r\\nuniform float north2;\\r\\nuniform float southMercatorY2;\\r\\nuniform float oneOverMercatorHeight2;\\r\\n\\r\\nuniform float south3;\\r\\nuniform float north3;\\r\\nuniform float southMercatorY3;\\r\\nuniform float oneOverMercatorHeight3;\\r\\n\\r\\nuniform float south4;\\r\\nuniform float north4;\\r\\nuniform float southMercatorY4;\\r\\nuniform float oneOverMercatorHeight4;\\r\\n\\r\\nuniform float south5;\\r\\nuniform float north5;\\r\\nuniform float southMercatorY5;\\r\\nuniform float oneOverMercatorHeight5;\\r\\n\\r\\nuniform float Km;\\r\\nuniform float Kr;\\r\\nuniform float ESun;\\r\\n\\r\\nuniform int nSamples;\\r\\nuniform float fSamples;\\r\\n\\r\\n//uniform float g,\\r\\n\\r\\n//uniform\\tvec3 v3CameraPosInput;\\r\\nuniform vec3 v3LightPosInput;\\r\\n\\r\\nuniform float fInnerRadius;\\r\\nuniform float fOuterRadius;\\r\\n\\r\\nuniform float fScaleDepth;\\r\\nuniform vec4 inputColor;\\r\\nuniform vec4 alphaValue;\\r\\nuniform float night;\\r\\n\\r\\nuniform float contrast;\\r\\nuniform float hue;\\r\\nuniform float saturation;\\r\\nuniform float textureGamma;\\r\\n\\r\\n//uniform vec4 earthColor;\\r\\n//uniform vec4 earthAddColor;\\r\\n//uniform float isAddEffect;\\r\\n\\r\\nuniform vec4 u_initialColor;\\r\\nuniform float nightfadeIn;\\r\\nuniform float nightfadeOut;\\r\\nuniform float fadeInDist;\\r\\nuniform float fadeOutDist;\\r\\n\\r\\nuniform float czm_fogDensity;\\r\\nuniform sampler2D colorMapping;\\r\\n\\r\\n// 是否开启颜色叠加 0 关闭 1 开启\\r\\nuniform float gradientColorOverlayEnable;\\r\\n// 颜色叠加方向\\r\\nuniform vec3 mapDirection;\\r\\n// 叠加使用的渐变纹理\\r\\nuniform sampler2D gradientColorMap;\\r\\n// 叠加使用的透明度\\r\\nuniform float gradientOpacity;\\r\\n\\r\\n//#define saturate(a) clamp( a, 0.0, 1.0 )\\r\\n//#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\r\\n//#define LOG2 1.442695\\r\\nstruct czm_ellipsoid\\r\\n  {\\r\\n    vec3 center;\\r\\n    vec3 radii;\\r\\n    vec3 inverseRadii;\\r\\n    vec3 inverseRadiiSquared;\\r\\n  };\\r\\nstruct AtmosphereColor\\r\\n  {\\r\\n    vec3 mie;\\r\\n    vec3 rayleigh;\\r\\n  };\\r\\n\\r\\n//搞定\\r\\nfloat scale(float fCos, float fScaleDepth)\\r\\n{\\r\\n  float x = 1.0 - fCos;\\r\\n  return fScaleDepth * exp(-0.00287 + x * (0.459 + x * (3.83 + x * (-6.80 + x * 5.25))));\\r\\n}\\r\\nvec4 depthColor(vec4 color)\\r\\n{\\r\\n  color.r = color.r * color.r * color.r;\\r\\n  color.g = color.g * color.g * color.g;\\r\\n  color.b = color.b * color.b;\\r\\n  return color;\\r\\n}\\r\\n//搞定\\r\\n// Returns the near intersection point of a line and a sphere\\r\\nfloat getNearIntersection(vec3 v3Pos, vec3 v3Ray, float fDistance2, float fRadius2)\\r\\n{\\r\\n  float B = 2.0 * dot(v3Pos, v3Ray);\\r\\n  float C = fDistance2 - fRadius2;\\r\\n  float fDet = max(0.0, B * B - 4.0 * C);\\r\\n  return 0.5 * (-B - sqrt(fDet));\\r\\n}\\r\\n\\r\\n//contrast added by zhgu\\r\\nvec3 czm_contrast(vec3 rgb, float contrast) {\\r\\n  vec3 color = mix(vec3(0.5), rgb, contrast);\\r\\n  color = clamp(color, 0.0, 1.0);\\r\\n  return color;\\r\\n}\\r\\n\\r\\n//hue added by zhgu\\r\\nvec3 czm_hue(vec3 rgb, float adjustment)\\r\\n{\\r\\n  const mat3 toYIQ = mat3(0.299, 0.587, 0.114,\\r\\n    0.595716, -0.274453, -0.321263,\\r\\n    0.211456, -0.522591, 0.311135);\\r\\n  const mat3 toRGB = mat3(1.0, 0.9563, 0.6210,\\r\\n    1.0, -0.2721, -0.6474,\\r\\n    1.0, -1.107, 1.7046);\\r\\n  vec3 yiq = toYIQ * rgb;\\r\\n  float hue = atan(yiq.z, yiq.y) + adjustment;\\r\\n  float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\\r\\n  vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\\r\\n  vec3 final = toRGB * color;\\r\\n  final = clamp(final, 0.0, 1.0);\\r\\n  return final;\\r\\n}\\r\\n//saturation added by zhgu\\r\\nvec3 czm_saturation(vec3 rgb, float adjustment)\\r\\n{\\r\\n  const vec3 W = vec3(0.2125, 0.7154, 0.0721);\\r\\n  vec3 intensity = vec3(dot(rgb, W));\\r\\n  vec3 color = mix(intensity, rgb, adjustment);\\r\\n  color = clamp(color, 0.0, 1.0);\\r\\n  return color;\\r\\n}\\r\\n\\r\\nvec4 czm_FilterColor(vec4 finalColor) {\\r\\n  vec4 finalColor1 = vec4(0);\\r\\n  if (grayFilterEnable) {\\r\\n    float gray = clamp(dot(finalColor.rgb, vec3(0.333, 0.333, 0.333)), 0.0, 1.0);\\r\\n    finalColor1.rgb = texture2D(colorMapping, vec2(gray, 0.5)).rgb;\\r\\n    finalColor1.a = finalColor.a;\\r\\n  } else {\\r\\n    finalColor1 = finalColor;\\r\\n  }\\r\\n  return finalColor1;\\r\\n}\\r\\nvec4 sampleAndBlend(\\r\\n  float addEffect,\\r\\n  vec4 eColor,\\r\\n  vec4 addColor,\\r\\n  vec4 previousColor,\\r\\n  sampler2D sampler_texture,\\r\\n  vec2 tileTextureCoordinates,\\r\\n  vec4 textureCoordinateRectangle,\\r\\n  vec4 textureCoordinateTranslationAndScale,\\r\\n  float textureAlphaIndex,\\r\\n  float brightness,\\r\\n  float south,\\r\\n  float north,\\r\\n  float southMercatorY,\\r\\n  float oneOverMercatorHeight,\\r\\n  float isReProjection,\\r\\n  vec4 alphaValue,\\r\\n  float contrast,\\r\\n  float hue,\\r\\n  float saturation,\\r\\n  float gamma)\\r\\n{\\r\\n  float textureAlpha = 1.0;\\r\\n\\r\\n  vec2 alphaMultiplier = step(textureCoordinateRectangle.xy, tileTextureCoordinates);\\r\\n  textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n  alphaMultiplier = step(vec2(0.0, 0.0), textureCoordinateRectangle.zw - tileTextureCoordinates);\\r\\n  textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n  vec2 translation = textureCoordinateTranslationAndScale.xy;\\r\\n  vec2 scale = textureCoordinateTranslationAndScale.zw;\\r\\n  vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\\r\\n\\r\\n  //再投影\\r\\n  if(oneOverMercatorHeight!=0.0){\\r\\n    float latitude = mix(south, north, textureCoordinates.y);\\r\\n    float sinLatitude = sin(latitude);\\r\\n    float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\\r\\n    float mercatorFraction = (mercatorY - southMercatorY) * oneOverMercatorHeight;\\r\\n    textureCoordinates.y = mercatorFraction;\\r\\n\\r\\n    if (isReProjection == 0.0) {\\r\\n        textureCoordinates.y = (tileTextureCoordinates * scale + translation).y;\\r\\n    }\\r\\n  }\\r\\n  vec4 value = texture2D(sampler_texture, textureCoordinates);\\r\\n  if (addEffect == 1.0) {\\r\\n    value = depthColor(value);\\r\\n  }\\r\\n  value.rgb *= eColor.rgb;\\r\\n  //         if(eColor.a==1.0){\\r\\n  //               value *=eColor;\\r\\n  //             }\\r\\n  //             else{\\r\\n  //               //value.rgb = (value.rgb + eColor.rgb * eColor.a)/(1.0 + eColor.a);\\r\\n  //                value.rgb = value.rgb * (1.0-eColor.a) + eColor.rgb * eColor.a;\\r\\n  //             }\\r\\n  value.rgb = (value.rgb + addColor.rgb * addColor.a) / (1.0 + addColor.a);\\r\\n  vec3 color = value.rgb;\\r\\n  float alpha = value.a;\\r\\n\\r\\n  color = mix(vec3(0.0, 0.0, 0.0), color, brightness);\\r\\n  //contrast\\r\\n  color = czm_contrast(color, contrast);\\r\\n  //hue\\r\\n  color = czm_hue(color, hue);\\r\\n  // saturation\\r\\n  color = czm_saturation(color, saturation);\\r\\n  // gamma\\r\\n  color = pow(color, vec3(gamma));\\r\\n  //filter\\r\\n  if (grayFilterIndex == textureAlphaIndex) {\\r\\n    color = czm_FilterColor(vec4(color, alpha)).rgb;\\r\\n  }\\r\\n  float sourceAlpha = alpha * textureAlpha;\\r\\n  float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\\r\\n  vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\\r\\n  return vec4(outColor, outAlpha);\\r\\n}\\r\\n//czm_ellipsoid czm_getWgs84EllipsoidEC()\\r\\n//{\\r\\n//    vec3 radii = vec3(6378137.0, 6378137.0, 6356752.314245);\\r\\n//    vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\\r\\n//    vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\\r\\n//    czm_ellipsoid temp = czm_ellipsoid(viewMatrix[3].xyz, radii, inverseRadii, inverseRadiiSquared);\\r\\n//    return temp;\\r\\n//}\\r\\nfloat czm_fade(float cameraDist, float fadeInDist, float fadeOutDist) {\\r\\n  float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\\r\\n  return fade;\\r\\n}\\r\\nAtmosphereColor computeGroundAtmosphereFromSpace(vec3 v3Pos, bool useSunLighting) {\\r\\n  //float PI = 3.14159265;\\r\\n  //float g2 =  g * g;\\r\\n\\r\\n  vec3 v3InvWavelength = vec3(1.0 / pow(0.650, 4.0), 1.0 / pow(0.570, 4.0), 1.0 / pow(0.475, 4.0));\\r\\n\\r\\n  vec3 v3CameraPos = vec3(0.0, 0.0, 0.0);\\r\\n  v3CameraPos = cameraPosition;\\r\\n\\r\\n  // vec3 v3LightPos = v3LightPosInput / length(v3LightPosInput);\\r\\n  vec3 v3LightPos = v3LightPosInput;\\r\\n\\r\\n  float fCameraHeight = length(v3CameraPos);\\r\\n\\r\\n  float fCameraHeight2 = fCameraHeight * fCameraHeight;\\r\\n\\r\\n  float inOutFactor = 1.05;\\r\\n  float fInnerRadius2 = fInnerRadius * fInnerRadius;\\r\\n  float fOuterRadius2 = fOuterRadius * fOuterRadius;\\r\\n\\r\\n  float fKrESun = Kr * ESun;\\r\\n  float fKmESun = Km * ESun;\\r\\n  float fKr4PI = Kr * 4.0 * PI;\\r\\n  float fKm4PI = Km * 4.0 * PI;\\r\\n\\r\\n  float fInvScaleDepth = 1.0 / fScaleDepth;\\r\\n  float fScale = 1.0 / (fOuterRadius - fInnerRadius);\\r\\n  float fScaleOverScaleDepth = fScale / fScaleDepth;\\r\\n\\r\\n  ////////////////////////////////////////////////\\r\\n  // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\\r\\n  //            \\tvec3 v3Pos = PositionWS;\\r\\n  vec3 v3Ray = v3Pos - v3CameraPos;\\r\\n  v3Pos = normalize(v3Pos);\\r\\n  float fFar = length(v3Ray);\\r\\n  v3Ray /= fFar;\\r\\n  // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\\r\\n  float fNear = getNearIntersection(v3CameraPos, v3Ray, fCameraHeight2, fOuterRadius2);\\r\\n  // Calculate the ray\'s starting position, then calculate its scattering offset\\r\\n  vec3 v3Start = v3CameraPos + v3Ray * fNear;\\r\\n  fFar -= fNear;\\r\\n  float fDepth = exp((fInnerRadius - fOuterRadius) * fInvScaleDepth);\\r\\n\\r\\n  //changed by zhgu if you donnot want night make it 1.0\\r\\n  float fLightAngle = useSunLighting ? dot(v3LightPos, v3Pos) / length(v3Pos) : 1.0;\\r\\n  float fCameraAngle = dot(-v3Ray, v3Pos) / length(v3Pos);\\r\\n  //float fLightAngle = dot(v3LightPos, v3Pos);\\r\\n  float fCameraScale = scale(fCameraAngle, fScaleDepth);\\r\\n  float fLightScale = scale(fLightAngle, fScaleDepth);\\r\\n  float fCameraOffset = fDepth * fCameraScale;\\r\\n  float fTemp = (fLightScale + fCameraScale);\\r\\n  // Initialize the scattering loop variables\\r\\n  //gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);\\r\\n  float fSampleLength = fFar / fSamples;\\r\\n  float fScaledLength = fSampleLength * fScale;\\r\\n  vec3 v3SampleRay = v3Ray * fSampleLength;\\r\\n  vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\\r\\n  // Now loop through the sample rays\\r\\n  vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\\r\\n  vec3 v3Attenuate = vec3(0.0, 0.0, 0.0);\\r\\n  for (int i = 0; i <2; i++)\\r\\n  {\\r\\n    float fHeight = length(v3SamplePoint);\\r\\n    float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\\r\\n    float fScatter = fDepth * fTemp - fCameraOffset;\\r\\n    v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\\r\\n    v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\\r\\n    v3SamplePoint += v3SampleRay;\\r\\n  }\\r\\n  AtmosphereColor color;\\r\\n  color.mie = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\\r\\n  color.rayleigh = v3Attenuate;\\r\\n  return color;\\r\\n}\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor) {\\r\\n  float scalar = distanceToCamera * czm_fogDensity;\\r\\n  float fog = 1.0 - exp(-(scalar * scalar));\\r\\n  return mix(color, fogColor, fog);\\r\\n}\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant) {\\r\\n  float scalar = distanceToCamera * czm_fogDensity;\\r\\n  float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));\\r\\n  return mix(color, fogColor, fog);\\r\\n}\\r\\n\\r\\nfloat czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC)\\r\\n{\\r\\n  return max(dot(lightDirectionEC, normalEC), 0.0);\\r\\n}\\r\\nvarying float dotValue;\\r\\nvarying vec3 sunDirectionEC;\\r\\nvarying vec3 normalEC;\\r\\nvoid main()\\r\\n{\\r\\n  #include <logdepthbuf_fragment>\\r\\n  //vec2 texCoords =  vec2( gl_TexCoord[0] );\\r\\n  vec2 webglUv = texCoords;\\r\\n  //    webglUv.y =1.0 - webglUv.y;\\r\\n  webglUv = clamp(webglUv, 0.0, 1.0);\\r\\n  vec4 lastColor = sampleAndBlend(isAddEffect0, earthColor0, earthAddColor0, u_initialColor, TexSampler0, webglUv, textureRectangle0, textureTransAndScale0, alphaIndex0, brightness0, south1, north1, southMercatorY1, oneOverMercatorHeight1, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect1, earthColor1, earthAddColor1, lastColor, TexSampler1, webglUv, textureRectangle1, textureTransAndScale1, alphaIndex1, brightness1, south2, north2, southMercatorY2, oneOverMercatorHeight2, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect2, earthColor2, earthAddColor2, lastColor, TexSampler2, webglUv, textureRectangle2, textureTransAndScale2, alphaIndex2, brightness2, south3, north3, southMercatorY3, oneOverMercatorHeight3, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect3, earthColor3, earthAddColor3, lastColor, TexSampler3, webglUv, textureRectangle3, textureTransAndScale3, alphaIndex3, brightness3, south4, north4, southMercatorY4, oneOverMercatorHeight4, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  lastColor = sampleAndBlend(isAddEffect4, earthColor4, earthAddColor4, lastColor, TexSampler4, webglUv, textureRectangle4, textureTransAndScale4, alphaIndex4, brightness4, south5, north5, southMercatorY5, oneOverMercatorHeight5, isReProjection, alphaValue, contrast, hue, saturation, textureGamma);\\r\\n  //added fade by zhgu to caculate fog\\r\\n  //float cameraDist = length(viewMatrix[3]);\\r\\n  float cameraDist = length(cameraPosition);\\r\\n  float fade = czm_fade(cameraDist, fadeInDist, fadeOutDist);\\r\\n\\r\\n  //added lambertDiffuse TODO is it effective? 这个很一般，先忽略吧，毕竟咱们性能不太好啊\\r\\n  //float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_sunDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);\\r\\n  //diffuseIntensity = mix(1.0, diffuseIntensity, fade);\\r\\n  //vec4 finalColor = vec4(color.rgb * diffuseIntensity, color.a);\\r\\n  vec4 finalColor = lastColor;\\r\\n  //added fogColor and hdr\\r\\n  //added fogColor and hdr\\r\\n  AtmosphereColor atmosFogColor = computeGroundAtmosphereFromSpace(PositionWS, false);\\r\\n  vec3 c0 = atmosFogColor.mie;\\r\\n  vec3 c1 = atmosFogColor.rayleigh;\\r\\n  vec3 fogColor1 = c0 + finalColor.rgb * c1;\\r\\n  //we should use hdr\\r\\n  const float fExposure = 2.0;\\r\\n  fogColor1 = vec3(1.0) - exp(-fExposure * fogColor1);\\r\\n\\r\\n  //fog added\\r\\n  //const float modifier = 0.15;\\r\\n  finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor1), finalColor.a);\\r\\n\\r\\n  // ---------------------------------------------------------------------------\\r\\n  //ground\\r\\n  //SUN 这个sun的计算处理了下，我们不能和cesium用一样的参数，这样可能无法模拟真实太阳的位置\\r\\n  // changed by ztf 此处太阳光照计算废弃\\r\\n  // vec3 groundAtmosphereColor = vec3(0.0);\\r\\n  // if(night == 1.0){\\r\\n  //         AtmosphereColor atmosColor = computeGroundAtmosphereFromSpace(PositionWS, true);\\r\\n  //         groundAtmosphereColor = atmosColor.mie + finalColor.rgb * atmosColor.rayleigh;\\r\\n  //         groundAtmosphereColor = vec3(1.0) - exp(-fExposure * groundAtmosphereColor);\\r\\n  //         //TODO 这个可能要弱一点才行\\r\\n  //         float sunlitAtmosphereIntensity = clamp((cameraDist - nightfadeOut) / (nightfadeIn - nightfadeOut), 0.0, 1.0);//caculate sun\\r\\n  //         // used hdr to make HDR look better\\r\\n  //         sunlitAtmosphereIntensity = max(sunlitAtmosphereIntensity * sunlitAtmosphereIntensity, 0.03);\\r\\n  //         //mix sun\\r\\n  //         groundAtmosphereColor = mix(groundAtmosphereColor, fogColor1, sunlitAtmosphereIntensity);\\r\\n  // }\\r\\n  // else{\\r\\n  //         groundAtmosphereColor = fogColor1;\\r\\n  // }\\r\\n  vec3 groundAtmosphereColor = fogColor1;\\r\\n  // ---------------------------------------------------------------------------\\r\\n  //use saturation to look better\\r\\n  groundAtmosphereColor = czm_saturation(groundAtmosphereColor, 1.6);\\r\\n  //mix\\r\\n  finalColor = vec4(mix(finalColor.rgb, groundAtmosphereColor, fade), finalColor.a);\\r\\n  finalColor.rgb *= vec3(earthColor0.a);\\r\\n  //finally you get the color\\r\\n  if (grayFilterIndex == -1.0)\\r\\n    finalColor = czm_FilterColor(finalColor);\\r\\n\\r\\n  gl_FragColor = finalColor;\\r\\n  //now we get the shadow\\r\\n  //              gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), (1.0-getShadowMask()));\\r\\n  vec4 shadow = vec4(vec3(0.0), shadowOpacity * (1.0 - getShadowMask()));\\r\\n  gl_FragColor.rgb = mix(gl_FragColor.rgb, shadow.rgb, shadow.a);\\r\\n\\r\\n  // 昼夜和线性颜色叠加 互斥 开启\\r\\n  if (night == 1.0) {\\r\\n    float diffuseIntensity = czm_getLambertDiffuse(sunDirectionEC, normalize(normalEC)) * 0.9 + 0.2;\\r\\n    gl_FragColor = vec4(gl_FragColor.rgb * diffuseIntensity, gl_FragColor.a);\\r\\n  } else {\\r\\n    // // 是否开启颜色叠加 0 关闭 1 开启\\r\\n    // uniform float gradientColorOverlayEnable;\\r\\n    // // 颜色叠加方向\\r\\n    // uniform vec3 mapDirection;\\r\\n    // // 叠加使用的渐变纹理\\r\\n    // uniform sampler2D gradientColorMap;\\r\\n\\r\\n    if (gradientColorOverlayEnable == 1.0) {\\r\\n      float diffuseIntensity = dot(mapDirection, normalize(normalEC));\\r\\n      float uv_U = (diffuseIntensity + 1.0) / 2.0; // -1 ——> 1 映射到 0 —— 1\\r\\n      float uv_V = 0.1;\\r\\n\\r\\n      vec4 gradientColor = texture2D(gradientColorMap, vec2(uv_U, uv_V));\\r\\n\\r\\n      float tempR = gradientColor.r + (1.0 - gradientColor.r) * (1.0 - gradientOpacity);\\r\\n      float tempG = gradientColor.g + (1.0 - gradientColor.g) * (1.0 - gradientOpacity);\\r\\n      float tempB = gradientColor.b + (1.0 - gradientColor.b) * (1.0 - gradientOpacity);\\r\\n\\r\\n      gl_FragColor = vec4(gl_FragColor.rgb * vec3(tempR, tempG, tempB), gl_FragColor.a);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  #include <fog_fragment>\\r\\n}\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/mult_texture5.glsl?')
        },
        "./src/material/shaders/mult_texture6.glsl": /*!*************************************************!*\
  !*** ./src/material/shaders/mult_texture6.glsl ***!
  \*************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "//varying vec4 Position;\\r\\n#include <common>\\r\\n#include <packing>\\r\\n#include <fog_pars_fragment>\\r\\n#include <bsdfs>\\r\\n#include <lights_pars_begin>\\r\\n#include <shadowmap_pars_fragment>\\r\\n#include <shadowmask_pars_fragment>\\r\\n#include <logdepthbuf_pars_fragment>\\r\\nvarying vec3 PositionWS;\\r\\nvarying vec2 texCoords;\\r\\n//varying vec3 ModelPostion;\\r\\nvarying float v_distance;\\r\\n\\r\\nuniform bool grayFilterEnable;\\r\\nuniform float grayFilterIndex;\\r\\nuniform float shadowOpacity;\\r\\n//uniform float grayMinMax[2];\\r\\n//uniform float grayFilterPerBar[10];\\r\\n//uniform vec3 grayFilterColorBar[10];\\r\\n\\r\\nuniform sampler2D TexSampler0;\\r\\nuniform sampler2D TexSampler1;\\r\\nuniform sampler2D TexSampler2;\\r\\nuniform sampler2D TexSampler3;\\r\\nuniform sampler2D TexSampler4;\\r\\nuniform sampler2D TexSampler5;\\r\\n\\r\\nuniform\\tvec4 textureRectangle0;\\r\\nuniform\\tvec4 textureRectangle1;\\r\\nuniform\\tvec4 textureRectangle2;\\r\\nuniform\\tvec4 textureRectangle3;\\r\\nuniform\\tvec4 textureRectangle4;\\r\\nuniform\\tvec4 textureRectangle5;\\r\\n\\r\\nuniform\\tvec4 textureTransAndScale0;\\r\\nuniform\\tvec4 textureTransAndScale1;\\r\\nuniform\\tvec4 textureTransAndScale2;\\r\\nuniform\\tvec4 textureTransAndScale3;\\r\\nuniform\\tvec4 textureTransAndScale4;\\r\\nuniform\\tvec4 textureTransAndScale5;\\r\\n\\r\\nuniform float brightness0;\\r\\nuniform float brightness1;\\r\\nuniform float brightness2;\\r\\nuniform float brightness3;\\r\\nuniform float brightness4;\\r\\nuniform float brightness5;\\r\\n\\r\\nuniform float alphaIndex0;\\r\\nuniform float alphaIndex1;\\r\\nuniform float alphaIndex2;\\r\\nuniform float alphaIndex3;\\r\\nuniform float alphaIndex4;\\r\\nuniform float alphaIndex5;\\r\\n\\r\\nuniform float isAddEffect0;\\r\\nuniform float isAddEffect1;\\r\\nuniform float isAddEffect2;\\r\\nuniform float isAddEffect3;\\r\\nuniform float isAddEffect4;\\r\\nuniform float isAddEffect5;\\r\\n\\r\\nuniform vec4 earthColor0;\\r\\nuniform vec4 earthColor1;\\r\\nuniform vec4 earthColor2;\\r\\nuniform vec4 earthColor3;\\r\\nuniform vec4 earthColor4;\\r\\nuniform vec4 earthColor5;\\r\\n\\r\\nuniform vec4 earthAddColor0;\\r\\nuniform vec4 earthAddColor1;\\r\\nuniform vec4 earthAddColor2;\\r\\nuniform vec4 earthAddColor3;\\r\\nuniform vec4 earthAddColor4;\\r\\nuniform vec4 earthAddColor5;\\r\\n\\r\\nuniform float south1;\\r\\nuniform float north1;\\r\\nuniform float southMercatorY1;\\r\\nuniform float oneOverMercatorHeight1;\\r\\nuniform float isReProjection;\\r\\n\\r\\nuniform float south2;\\r\\nuniform float north2;\\r\\nuniform float southMercatorY2;\\r\\nuniform float oneOverMercatorHeight2;\\r\\n\\r\\nuniform float south3;\\r\\nuniform float north3;\\r\\nuniform float southMercatorY3;\\r\\nuniform float oneOverMercatorHeight3;\\r\\n\\r\\nuniform float south4;\\r\\nuniform float north4;\\r\\nuniform float southMercatorY4;\\r\\nuniform float oneOverMercatorHeight4;\\r\\n\\r\\nuniform float south5;\\r\\nuniform float north5;\\r\\nuniform float southMercatorY5;\\r\\nuniform float oneOverMercatorHeight5;\\r\\n\\r\\nuniform float south6;\\r\\nuniform float north6;\\r\\nuniform float southMercatorY6;\\r\\nuniform float oneOverMercatorHeight6;\\r\\n\\r\\nuniform\\tfloat Km;\\r\\nuniform\\tfloat Kr;\\r\\nuniform\\tfloat ESun;\\r\\n\\r\\nuniform int nSamples;\\r\\nuniform float fSamples;\\r\\n\\r\\n//uniform float g,\\r\\n\\r\\n//uniform\\tvec3 v3CameraPosInput;\\r\\nuniform\\tvec3 v3LightPosInput;\\r\\n\\r\\nuniform\\tfloat fInnerRadius;\\r\\nuniform\\tfloat fOuterRadius;\\r\\n\\r\\nuniform float fScaleDepth;\\r\\nuniform\\tvec4 inputColor;\\r\\nuniform vec4 alphaValue;\\r\\nuniform float night;\\r\\n\\r\\nuniform float contrast;\\r\\nuniform float hue;\\r\\nuniform float saturation;\\r\\nuniform float textureGamma;\\r\\n//uniform vec4 earthColor;\\r\\n//uniform vec4 earthAddColor;\\r\\n//uniform float isAddEffect;\\r\\n\\r\\nuniform vec4 u_initialColor;\\r\\nuniform float nightfadeIn;\\r\\nuniform float nightfadeOut;\\r\\nuniform float fadeInDist;\\r\\nuniform float fadeOutDist;\\r\\n\\r\\nuniform float czm_fogDensity;\\r\\nuniform sampler2D colorMapping;\\r\\n\\r\\n// 是否开启颜色叠加 0 关闭 1 开启\\r\\nuniform float gradientColorOverlayEnable;\\r\\n// 颜色叠加方向\\r\\nuniform vec3 mapDirection;\\r\\n// 叠加使用的渐变纹理\\r\\nuniform sampler2D gradientColorMap;\\r\\n// 叠加使用的透明度\\r\\nuniform float gradientOpacity;\\r\\n\\r\\n//#define saturate(a) clamp( a, 0.0, 1.0 )\\r\\n//#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\r\\n//#define LOG2 1.442695\\r\\nstruct czm_ellipsoid\\r\\n{\\r\\n    vec3 center;\\r\\n    vec3 radii;\\r\\n    vec3 inverseRadii;\\r\\n    vec3 inverseRadiiSquared;\\r\\n};\\r\\nstruct AtmosphereColor\\r\\n{\\r\\n    vec3 mie;\\r\\n    vec3 rayleigh;\\r\\n};\\r\\n//搞定\\r\\nfloat scale(float fCos, float fScaleDepth)\\r\\n{\\r\\n\\tfloat x = 1.0 - fCos;\\r\\n\\treturn fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\\r\\n}\\r\\nvec4 depthColor(vec4 color)\\r\\n{\\r\\n     color.r = color.r * color.r * color.r;\\r\\n     color.g = color.g * color.g * color.g;\\r\\n     color.b = color.b * color.b;\\r\\n     return color;\\r\\n}\\r\\n\\r\\n//搞定\\r\\n// Returns the near intersection point of a line and a sphere\\r\\nfloat getNearIntersection(vec3 v3Pos, vec3 v3Ray, float fDistance2, float fRadius2)\\r\\n{\\r\\n\\tfloat B = 2.0 * dot(v3Pos, v3Ray);\\r\\n\\tfloat C = fDistance2 - fRadius2;\\r\\n\\tfloat fDet = max(0.0, B*B - 4.0 * C);\\r\\n\\treturn 0.5 * (-B - sqrt(fDet));\\r\\n}\\r\\n\\r\\n//contrast added by zhgu\\r\\nvec3 czm_contrast(vec3 rgb, float contrast){\\r\\n   vec3 color = mix(vec3(0.5), rgb, contrast);\\r\\n    color = clamp(color , 0.0, 1.0);\\r\\n    return color;\\r\\n}\\r\\n\\r\\n//hue added by zhgu\\r\\nvec3 czm_hue(vec3 rgb, float adjustment)\\r\\n{\\r\\n    const mat3 toYIQ = mat3(0.299,     0.587,     0.114,\\r\\n                            0.595716, -0.274453, -0.321263,\\r\\n                            0.211456, -0.522591,  0.311135);\\r\\n    const mat3 toRGB = mat3(1.0,  0.9563,  0.6210,\\r\\n                            1.0, -0.2721, -0.6474,\\r\\n                            1.0, -1.107,   1.7046);\\r\\n    vec3 yiq = toYIQ * rgb;\\r\\n    float hue = atan(yiq.z, yiq.y) + adjustment;\\r\\n    float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\\r\\n    vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\\r\\n    vec3 final = toRGB * color;\\r\\n    final = clamp(final , 0.0, 1.0);\\r\\n    return final;\\r\\n}\\r\\n//saturation added by zhgu\\r\\nvec3 czm_saturation(vec3 rgb, float adjustment)\\r\\n{\\r\\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\\r\\n    vec3 intensity = vec3(dot(rgb, W));\\r\\n    vec3 color = mix(intensity, rgb, adjustment);\\r\\n    color = clamp(color , 0.0, 1.0);\\r\\n    return color;\\r\\n\\r\\n}\\r\\nvec4 czm_FilterColor (vec4 finalColor){\\r\\n    vec4 finalColor1 = vec4(0);\\r\\n    if(grayFilterEnable){\\r\\n         float gray = clamp( dot( finalColor.rgb, vec3(0.333, 0.333, 0.333) ), 0.0, 1.0 );\\r\\n         finalColor1.rgb = texture2D( colorMapping, vec2( gray, 0.5 ) ).rgb;\\r\\n         finalColor1.a = finalColor.a;\\r\\n    }else{\\r\\n        finalColor1 = finalColor;\\r\\n    }\\r\\n    return finalColor1;\\r\\n}\\r\\nvec4 sampleAndBlend(\\r\\n    float addEffect,\\r\\n    vec4 eColor,\\r\\n    vec4 addColor,\\r\\n    vec4 previousColor,\\r\\n\\tsampler2D sampler_texture,\\r\\n\\tvec2 tileTextureCoordinates,\\r\\n\\tvec4 textureCoordinateRectangle,\\r\\n\\tvec4 textureCoordinateTranslationAndScale,\\r\\n\\tfloat textureAlphaIndex,\\r\\n\\tfloat brightness,\\r\\n\\tfloat south,\\r\\n\\tfloat north,\\r\\n\\tfloat southMercatorY,\\r\\n\\tfloat oneOverMercatorHeight,\\r\\n\\tfloat isReProjection,\\r\\n\\tvec4 alphaValue,\\r\\n\\t float contrast,\\r\\n     float hue,\\r\\n     float saturation,\\r\\n     float gamma)\\r\\n{\\r\\n\\r\\n\\tfloat textureAlpha = 1.0;\\r\\n\\r\\n\\tvec2 alphaMultiplier = step(textureCoordinateRectangle.xy, tileTextureCoordinates);\\r\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n    alphaMultiplier = step(vec2(0.0,0.0), textureCoordinateRectangle.zw - tileTextureCoordinates);\\r\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n\\tvec2 translation = textureCoordinateTranslationAndScale.xy;\\r\\n    vec2 scale = textureCoordinateTranslationAndScale.zw;\\r\\n    vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\\r\\n\\r\\n\\t//再投影\\r\\n\\r\\n    if(oneOverMercatorHeight!=0.0){\\r\\n        float latitude = mix(south, north , textureCoordinates.y);\\r\\n        float sinLatitude = sin(latitude);\\r\\n        float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\\r\\n        float mercatorFraction = (mercatorY - southMercatorY) * oneOverMercatorHeight;\\r\\n        textureCoordinates.y =  mercatorFraction;\\r\\n        if( isReProjection == 0.0){\\r\\n            textureCoordinates.y =   (tileTextureCoordinates * scale + translation).y;\\r\\n        }\\r\\n    }\\r\\n    vec4 value = texture2D(sampler_texture, textureCoordinates);\\r\\n     if(addEffect == 1.0){\\r\\n            value = depthColor(value);\\r\\n        }\\r\\n        value.rgb *=eColor.rgb;\\r\\n//         if(eColor.a==1.0){\\r\\n//               value *=eColor;\\r\\n//             }\\r\\n//             else{\\r\\n//               //value.rgb = (value.rgb + eColor.rgb * eColor.a)/(1.0 + eColor.a);\\r\\n//                value.rgb = value.rgb * (1.0-eColor.a) + eColor.rgb * eColor.a;\\r\\n//             }\\r\\n          value.rgb = (value.rgb + addColor.rgb * addColor.a)/(1.0 + addColor.a);\\r\\n    vec3 color = value.rgb;\\r\\n    float alpha = value.a;\\r\\n\\r\\n\\tcolor = mix(vec3(0.0,0.0,0.0), color, brightness);\\r\\n    //contrast\\r\\n    color = czm_contrast(color, contrast);\\r\\n    //hue\\r\\n    color = czm_hue(color, hue);\\r\\n    // saturation\\r\\n    color = czm_saturation(color, saturation);\\r\\n    // gamma\\r\\n    color = pow(color, vec3(gamma));\\r\\n    //filter\\r\\n    if(grayFilterIndex == textureAlphaIndex){\\r\\n        color = czm_FilterColor(vec4(color,alpha)).rgb;\\r\\n    }\\r\\n\\tfloat sourceAlpha = alpha * textureAlpha;\\r\\n    float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\\r\\n    vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\\r\\n    return vec4(outColor, outAlpha);\\r\\n}\\r\\n//czm_ellipsoid czm_getWgs84EllipsoidEC()\\r\\n//{\\r\\n//    vec3 radii = vec3(6378137.0, 6378137.0, 6356752.314245);\\r\\n//    vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\\r\\n//    vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\\r\\n//    czm_ellipsoid temp = czm_ellipsoid(viewMatrix[3].xyz, radii, inverseRadii, inverseRadiiSquared);\\r\\n//    return temp;\\r\\n//}\\r\\nfloat czm_fade(float cameraDist, float fadeInDist,float fadeOutDist){\\r\\n    float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\\r\\n    return fade;\\r\\n}\\r\\nAtmosphereColor computeGroundAtmosphereFromSpace(vec3 v3Pos, bool useSunLighting){\\r\\n        //float PI = 3.14159265;\\r\\n    \\t//float g2 =  g * g;\\r\\n\\r\\n    \\tvec3 v3InvWavelength = vec3(1.0 / pow(0.650, 4.0), 1.0 / pow(0.570, 4.0), 1.0 / pow(0.475, 4.0));\\r\\n\\r\\n    \\tvec3 v3CameraPos =  vec3(0.0, 0.0, 0.0);\\r\\n    \\tv3CameraPos = cameraPosition;\\r\\n\\r\\n    \\t// vec3 v3LightPos = v3LightPosInput / length(v3LightPosInput);\\r\\n        vec3 v3LightPos = v3LightPosInput;\\r\\n\\r\\n    \\tfloat fCameraHeight = length(v3CameraPos);\\r\\n\\r\\n    \\tfloat fCameraHeight2 = fCameraHeight * fCameraHeight;\\r\\n\\r\\n            \\tfloat inOutFactor = 1.05;\\r\\n            \\tfloat fInnerRadius2 = fInnerRadius * fInnerRadius;\\r\\n            \\tfloat fOuterRadius2 = fOuterRadius * fOuterRadius;\\r\\n\\r\\n            \\tfloat fKrESun = Kr * ESun;\\r\\n            \\tfloat fKmESun = Km * ESun;\\r\\n            \\tfloat fKr4PI = Kr * 4.0 * PI;\\r\\n            \\tfloat fKm4PI = Km * 4.0 * PI;\\r\\n\\r\\n            \\tfloat fInvScaleDepth = 1.0 / fScaleDepth;\\r\\n            \\tfloat fScale = 1.0 / (fOuterRadius - fInnerRadius);\\r\\n            \\tfloat fScaleOverScaleDepth = fScale / fScaleDepth;\\r\\n\\r\\n            \\t////////////////////////////////////////////////\\r\\n            \\t// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\\r\\n//            \\tvec3 v3Pos = PositionWS;\\r\\n            \\tvec3 v3Ray = v3Pos - v3CameraPos;\\r\\n            \\tv3Pos = normalize(v3Pos);\\r\\n            \\tfloat fFar = length(v3Ray);\\r\\n            \\tv3Ray /= fFar;\\r\\n            \\t// Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\\r\\n            \\tfloat fNear = getNearIntersection(v3CameraPos, v3Ray, fCameraHeight2, fOuterRadius2);\\r\\n            \\t// Calculate the ray\'s starting position, then calculate its scattering offset\\r\\n            \\tvec3 v3Start = v3CameraPos + v3Ray * fNear;\\r\\n            \\tfFar -= fNear;\\r\\n            \\tfloat fDepth = exp((fInnerRadius - fOuterRadius) * fInvScaleDepth);\\r\\n\\r\\n\\r\\n            \\t//changed by zhgu if you donnot want night make it 1.0\\r\\n            \\tfloat fLightAngle = useSunLighting ? dot(v3LightPos, v3Pos)/length(v3Pos) : 1.0;\\r\\n            \\tfloat fCameraAngle = dot(-v3Ray, v3Pos)/length(v3Pos);\\r\\n            \\t//float fLightAngle = dot(v3LightPos, v3Pos);\\r\\n            \\tfloat fCameraScale = scale(fCameraAngle, fScaleDepth);\\r\\n            \\tfloat fLightScale = scale(fLightAngle, fScaleDepth);\\r\\n            \\tfloat fCameraOffset = fDepth*fCameraScale;\\r\\n            \\tfloat fTemp = (fLightScale + fCameraScale);\\r\\n            \\t// Initialize the scattering loop variables\\r\\n            \\t//gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);\\r\\n            \\tfloat fSampleLength = fFar / fSamples;\\r\\n            \\tfloat fScaledLength = fSampleLength * fScale;\\r\\n            \\tvec3 v3SampleRay = v3Ray * fSampleLength;\\r\\n            \\tvec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\\r\\n            \\t// Now loop through the sample rays\\r\\n            \\tvec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\\r\\n            \\tvec3 v3Attenuate = vec3(0.0,0.0,0.0);\\r\\n            \\tfor(int i=0; i<2; i++)\\r\\n            \\t{\\r\\n            \\t  float fHeight = length(v3SamplePoint);\\r\\n            \\t  float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\\r\\n            \\t  float fScatter = fDepth*fTemp - fCameraOffset;\\r\\n            \\t  v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\\r\\n            \\t  v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\\r\\n            \\t  v3SamplePoint += v3SampleRay;\\r\\n            \\t}\\r\\n            \\tAtmosphereColor color;\\r\\n            \\tcolor.mie = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\\r\\n            \\tcolor.rayleigh = v3Attenuate;\\r\\n            \\treturn color;\\r\\n\\r\\n}\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor) {\\r\\n    float scalar = distanceToCamera * czm_fogDensity;\\r\\n    float fog = 1.0 - exp(-(scalar * scalar));\\r\\n    return mix(color, fogColor, fog);\\r\\n}\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant) {\\r\\n    float scalar = distanceToCamera * czm_fogDensity;\\r\\n    float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));\\r\\n    return mix(color, fogColor, fog);\\r\\n}\\r\\n\\r\\n\\r\\nfloat czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC)\\r\\n{\\r\\n    return max(dot(lightDirectionEC, normalEC), 0.0);\\r\\n}\\r\\nvarying float dotValue;\\r\\nvarying vec3 sunDirectionEC;\\r\\nvarying vec3 normalEC;\\r\\nvoid main(\\t)\\r\\n{\\r\\n    #include <logdepthbuf_fragment>\\r\\n\\t//vec2 texCoords =  vec2( gl_TexCoord[0] );\\r\\n\\tvec2 webglUv = texCoords;\\r\\n//    webglUv.y =1.0 - webglUv.y;\\r\\n    webglUv = clamp(webglUv , 0.0, 1.0);\\r\\n\\tvec4 lastColor = sampleAndBlend(isAddEffect0,earthColor0,earthAddColor0,u_initialColor,TexSampler0,webglUv,textureRectangle0,textureTransAndScale0,alphaIndex0,brightness0,south1,north1,southMercatorY1,oneOverMercatorHeight1,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect1,earthColor1,earthAddColor1,lastColor,TexSampler1,webglUv,textureRectangle1,textureTransAndScale1,alphaIndex1,brightness1,south2,north2,southMercatorY2,oneOverMercatorHeight2,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect2,earthColor2,earthAddColor2,lastColor,TexSampler2,webglUv,textureRectangle2,textureTransAndScale2,alphaIndex2,brightness2,south3,north3,southMercatorY3,oneOverMercatorHeight3,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect3,earthColor3,earthAddColor3,lastColor,TexSampler3,webglUv,textureRectangle3,textureTransAndScale3,alphaIndex3,brightness3,south4,north4,southMercatorY4,oneOverMercatorHeight4,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect4,earthColor4,earthAddColor4,lastColor,TexSampler4,webglUv,textureRectangle4,textureTransAndScale4,alphaIndex4,brightness4,south5,north5,southMercatorY5,oneOverMercatorHeight5,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect5,earthColor5,earthAddColor5,lastColor,TexSampler5,webglUv,textureRectangle5,textureTransAndScale5,alphaIndex5,brightness5,south6,north6,southMercatorY6,oneOverMercatorHeight6,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n    //added fade by zhgu to caculate fog\\r\\n            //float cameraDist = length(viewMatrix[3]);\\r\\n            float cameraDist = length(cameraPosition);\\r\\n        \\tfloat fade = czm_fade(cameraDist, fadeInDist, fadeOutDist);\\r\\n\\r\\n            //added lambertDiffuse TODO is it effective? 这个很一般，先忽略吧，毕竟咱们性能不太好啊\\r\\n            //float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_sunDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);\\r\\n            //diffuseIntensity = mix(1.0, diffuseIntensity, fade);\\r\\n            //vec4 finalColor = vec4(color.rgb * diffuseIntensity, color.a);\\r\\n            vec4 finalColor = lastColor;\\r\\n            //added fogColor and hdr\\r\\n            //added fogColor and hdr\\r\\n                     AtmosphereColor atmosFogColor = computeGroundAtmosphereFromSpace(PositionWS, false);\\r\\n                     vec3 c0 = atmosFogColor.mie;\\r\\n                     vec3 c1 = atmosFogColor.rayleigh;\\r\\n                    vec3 fogColor1 = c0 + finalColor.rgb * c1;\\r\\n                    //we should use hdr\\r\\n                    const float fExposure = 2.0;\\r\\n                    fogColor1 = vec3(1.0) - exp(-fExposure * fogColor1);\\r\\n\\r\\n                    //fog added\\r\\n                    //const float modifier = 0.15;\\r\\n                     finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor1), finalColor.a);\\r\\n\\r\\n            // ---------------------------------------------------------------------------\\r\\n            //ground\\r\\n            //SUN 这个sun的计算处理了下，我们不能和cesium用一样的参数，这样可能无法模拟真实太阳的位置\\r\\n            // changed by ztf 此处太阳光照计算废弃\\r\\n            // vec3 groundAtmosphereColor = vec3(0.0);\\r\\n            // if(night == 1.0){\\r\\n            //         AtmosphereColor atmosColor = computeGroundAtmosphereFromSpace(PositionWS, true);\\r\\n            //         groundAtmosphereColor = atmosColor.mie + finalColor.rgb * atmosColor.rayleigh;\\r\\n            //         groundAtmosphereColor = vec3(1.0) - exp(-fExposure * groundAtmosphereColor);\\r\\n            //         //TODO 这个可能要弱一点才行\\r\\n            //         float sunlitAtmosphereIntensity = clamp((cameraDist - nightfadeOut) / (nightfadeIn - nightfadeOut), 0.0, 1.0);//caculate sun\\r\\n            //         // used hdr to make HDR look better\\r\\n            //         sunlitAtmosphereIntensity = max(sunlitAtmosphereIntensity * sunlitAtmosphereIntensity, 0.03);\\r\\n            //         //mix sun\\r\\n            //         groundAtmosphereColor = mix(groundAtmosphereColor, fogColor1, sunlitAtmosphereIntensity);\\r\\n            // }\\r\\n            // else{\\r\\n            //         groundAtmosphereColor = fogColor1;\\r\\n            // }\\r\\n            vec3 groundAtmosphereColor = fogColor1;\\r\\n            // ---------------------------------------------------------------------------\\r\\n            //use saturation to look better\\r\\n            groundAtmosphereColor = czm_saturation(groundAtmosphereColor, 1.6);\\r\\n            //mix\\r\\n            finalColor = vec4(mix(finalColor.rgb, groundAtmosphereColor, fade), finalColor.a);\\r\\n            finalColor.rgb *= vec3(earthColor0.a);\\r\\n            //finally you get the color\\r\\n             if(grayFilterIndex==-1.0){\\r\\n                finalColor = czm_FilterColor(finalColor);\\r\\n             }\\r\\n             gl_FragColor = finalColor;\\r\\n            //now we get the shadow\\r\\n//             gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), (1.0-getShadowMask()));\\r\\n        vec4 shadow = vec4(vec3(0.0), shadowOpacity * ( 1.0 - getShadowMask() ) );\\r\\n         gl_FragColor.rgb = mix(gl_FragColor.rgb, shadow.rgb, shadow.a);\\r\\n         \\r\\n    // 昼夜和线性颜色叠加 互斥 开启\\r\\n    if(night == 1.0){\\r\\n\\r\\n        float diffuseIntensity = czm_getLambertDiffuse(sunDirectionEC, normalize(normalEC)) * 0.9 + 0.2;\\r\\n        gl_FragColor = vec4(gl_FragColor.rgb * diffuseIntensity, gl_FragColor.a);\\r\\n\\r\\n    }else {\\r\\n\\r\\n        // // 是否开启颜色叠加 0 关闭 1 开启\\r\\n        // uniform float gradientColorOverlayEnable;\\r\\n        // // 颜色叠加方向\\r\\n        // uniform vec3 mapDirection;\\r\\n        // // 叠加使用的渐变纹理\\r\\n        // uniform sampler2D gradientColorMap;\\r\\n\\r\\n        if(gradientColorOverlayEnable == 1.0){\\r\\n\\r\\n            float diffuseIntensity = dot(mapDirection, normalize(normalEC));\\r\\n            float uv_U = (diffuseIntensity + 1.0) / 2.0;// -1 ——> 1 映射到 0 —— 1\\r\\n            float uv_V = 0.1;\\r\\n\\r\\n            vec4 gradientColor = texture2D(gradientColorMap, vec2(uv_U, uv_V));\\r\\n\\r\\n            float tempR = gradientColor.r + (1.0 - gradientColor.r) * (1.0 - gradientOpacity);\\r\\n            float tempG = gradientColor.g + (1.0 - gradientColor.g) * (1.0 - gradientOpacity);\\r\\n            float tempB = gradientColor.b + (1.0 - gradientColor.b) * (1.0 - gradientOpacity);\\r\\n\\r\\n            gl_FragColor = vec4(gl_FragColor.rgb * vec3(tempR,tempG,tempB), gl_FragColor.a);\\r\\n\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n        #include <fog_fragment>\\r\\n}\\r\\n\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/mult_texture6.glsl?')
        },
        "./src/material/shaders/mult_texture7.glsl": /*!*************************************************!*\
  !*** ./src/material/shaders/mult_texture7.glsl ***!
  \*************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "//varying vec4 Position;\\r\\n//precision highp float;\\r\\n//varying vec3 ModelPostion;\\r\\n#include <common>\\r\\n#include <packing>\\r\\n#include <fog_pars_fragment>\\r\\n#include <bsdfs>\\r\\n#include <lights_pars_begin>\\r\\n#include <shadowmap_pars_fragment>\\r\\n#include <shadowmask_pars_fragment>\\r\\n#include <logdepthbuf_pars_fragment>\\r\\nvarying float v_distance;\\r\\nvarying vec3 PositionWS;\\r\\nvarying vec2 texCoords;\\r\\n\\r\\nuniform bool grayFilterEnable;\\r\\nuniform float grayFilterIndex;\\r\\nuniform float shadowOpacity;\\r\\n//uniform float grayMinMax[2];\\r\\n//uniform float grayFilterPerBar[10];\\r\\n//uniform vec3 grayFilterColorBar[10];\\r\\n\\r\\nuniform sampler2D TexSampler0;\\r\\nuniform sampler2D TexSampler1;\\r\\nuniform sampler2D TexSampler2;\\r\\nuniform sampler2D TexSampler3;\\r\\nuniform sampler2D TexSampler4;\\r\\nuniform sampler2D TexSampler5;\\r\\nuniform sampler2D TexSampler6;\\r\\n\\r\\n\\r\\nuniform\\tvec4 textureRectangle0;\\r\\nuniform\\tvec4 textureRectangle1;\\r\\nuniform\\tvec4 textureRectangle2;\\r\\nuniform\\tvec4 textureRectangle3;\\r\\nuniform\\tvec4 textureRectangle4;\\r\\nuniform\\tvec4 textureRectangle5;\\r\\nuniform\\tvec4 textureRectangle6;\\r\\n\\r\\n\\r\\nuniform\\tvec4 textureTransAndScale0;\\r\\nuniform\\tvec4 textureTransAndScale1;\\r\\nuniform\\tvec4 textureTransAndScale2;\\r\\nuniform\\tvec4 textureTransAndScale3;\\r\\nuniform\\tvec4 textureTransAndScale4;\\r\\nuniform\\tvec4 textureTransAndScale5;\\r\\nuniform\\tvec4 textureTransAndScale6;\\r\\n\\r\\n\\r\\nuniform float brightness0;\\r\\nuniform float brightness1;\\r\\nuniform float brightness2;\\r\\nuniform float brightness3;\\r\\nuniform float brightness4;\\r\\nuniform float brightness5;\\r\\nuniform float brightness6;\\r\\n\\r\\n\\r\\nuniform float alphaIndex0;\\r\\nuniform float alphaIndex1;\\r\\nuniform float alphaIndex2;\\r\\nuniform float alphaIndex3;\\r\\nuniform float alphaIndex4;\\r\\nuniform float alphaIndex5;\\r\\nuniform float alphaIndex6;\\r\\n\\r\\nuniform float isAddEffect0;\\r\\nuniform float isAddEffect1;\\r\\nuniform float isAddEffect2;\\r\\nuniform float isAddEffect3;\\r\\nuniform float isAddEffect4;\\r\\nuniform float isAddEffect5;\\r\\nuniform float isAddEffect6;\\r\\n\\r\\nuniform vec4 earthColor0;\\r\\nuniform vec4 earthColor1;\\r\\nuniform vec4 earthColor2;\\r\\nuniform vec4 earthColor3;\\r\\nuniform vec4 earthColor4;\\r\\nuniform vec4 earthColor5;\\r\\nuniform vec4 earthColor6;\\r\\n\\r\\nuniform vec4 earthAddColor0;\\r\\nuniform vec4 earthAddColor1;\\r\\nuniform vec4 earthAddColor2;\\r\\nuniform vec4 earthAddColor3;\\r\\nuniform vec4 earthAddColor4;\\r\\nuniform vec4 earthAddColor5;\\r\\nuniform vec4 earthAddColor6;\\r\\n\\r\\n\\r\\nuniform float south1;\\r\\nuniform float north1;\\r\\nuniform float southMercatorY1;\\r\\nuniform float oneOverMercatorHeight1;\\r\\nuniform float isReProjection;\\r\\n\\r\\n\\r\\nuniform float south2;\\r\\nuniform float north2;\\r\\nuniform float southMercatorY2;\\r\\nuniform float oneOverMercatorHeight2;\\r\\n\\r\\nuniform float south3;\\r\\nuniform float north3;\\r\\nuniform float southMercatorY3;\\r\\nuniform float oneOverMercatorHeight3;\\r\\n\\r\\nuniform float south4;\\r\\nuniform float north4;\\r\\nuniform float southMercatorY4;\\r\\nuniform float oneOverMercatorHeight4;\\r\\n\\r\\nuniform float south5;\\r\\nuniform float north5;\\r\\nuniform float southMercatorY5;\\r\\nuniform float oneOverMercatorHeight5;\\r\\n\\r\\nuniform float south6;\\r\\nuniform float north6;\\r\\nuniform float southMercatorY6;\\r\\nuniform float oneOverMercatorHeight6;\\r\\n\\r\\nuniform float south7;\\r\\nuniform float north7;\\r\\nuniform float southMercatorY7;\\r\\nuniform float oneOverMercatorHeight7;\\r\\n\\r\\nuniform\\tfloat Km;\\r\\nuniform\\tfloat Kr;\\r\\nuniform\\tfloat ESun;\\r\\n\\r\\nuniform int nSamples;\\r\\nuniform float fSamples;\\r\\n\\r\\n//uniform float g,\\r\\n\\r\\n//uniform\\tvec3 v3CameraPosInput;\\r\\nuniform\\tvec3 v3LightPosInput;\\r\\n\\r\\nuniform\\tfloat fInnerRadius;\\r\\nuniform\\tfloat fOuterRadius;\\r\\n\\r\\nuniform float fScaleDepth;\\r\\nuniform\\tvec4 inputColor;\\r\\nuniform vec4 alphaValue;\\r\\nuniform float night;\\r\\n\\r\\nuniform float contrast;\\r\\nuniform float hue;\\r\\nuniform float saturation;\\r\\nuniform float textureGamma;\\r\\n//uniform vec4 earthColor;\\r\\n//uniform vec4 earthAddColor;\\r\\n//uniform float isAddEffect;\\r\\n\\r\\nuniform vec4 u_initialColor;\\r\\nuniform float nightfadeIn;\\r\\nuniform float nightfadeOut;\\r\\nuniform float fadeInDist;\\r\\nuniform float fadeOutDist;\\r\\n\\r\\nuniform float czm_fogDensity;\\r\\nuniform sampler2D colorMapping;\\r\\n\\r\\n// 是否开启颜色叠加 0 关闭 1 开启\\r\\nuniform float gradientColorOverlayEnable;\\r\\n// 颜色叠加方向\\r\\nuniform vec3 mapDirection;\\r\\n// 叠加使用的渐变纹理\\r\\nuniform sampler2D gradientColorMap;\\r\\n// 叠加使用的透明度\\r\\nuniform float gradientOpacity;\\r\\n\\r\\n//#define saturate(a) clamp( a, 0.0, 1.0 )\\r\\n//#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\r\\n//#define LOG2 1.442695\\r\\nstruct czm_ellipsoid\\r\\n{\\r\\n    vec3 center;\\r\\n    vec3 radii;\\r\\n    vec3 inverseRadii;\\r\\n    vec3 inverseRadiiSquared;\\r\\n};\\r\\nstruct AtmosphereColor\\r\\n{\\r\\n    vec3 mie;\\r\\n    vec3 rayleigh;\\r\\n};\\r\\n\\r\\n//搞定\\r\\nfloat scale(float fCos, float fScaleDepth)\\r\\n{\\r\\n\\tfloat x = 1.0 - fCos;\\r\\n\\treturn fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\\r\\n}\\r\\n\\r\\nvec4 depthColor(vec4 color)\\r\\n{\\r\\n     color.r = color.r * color.r * color.r;\\r\\n     color.g = color.g * color.g * color.g;\\r\\n     color.b = color.b * color.b;\\r\\n     return color;\\r\\n}\\r\\n\\r\\n//搞定\\r\\n// Returns the near intersection point of a line and a sphere\\r\\nfloat getNearIntersection(vec3 v3Pos, vec3 v3Ray, float fDistance2, float fRadius2)\\r\\n{\\r\\n\\tfloat B = 2.0 * dot(v3Pos, v3Ray);\\r\\n\\tfloat C = fDistance2 - fRadius2;\\r\\n\\tfloat fDet = max(0.0, B*B - 4.0 * C);\\r\\n\\treturn 0.5 * (-B - sqrt(fDet));\\r\\n}\\r\\n\\r\\n//contrast added by zhgu\\r\\nvec3 czm_contrast(vec3 rgb, float contrast){\\r\\n   vec3 color = mix(vec3(0.5), rgb, contrast);\\r\\n    color = clamp(color , 0.0, 1.0);\\r\\n    return color;\\r\\n}\\r\\n\\r\\n//hue added by zhgu\\r\\nvec3 czm_hue(vec3 rgb, float adjustment)\\r\\n{\\r\\n    const mat3 toYIQ = mat3(0.299,     0.587,     0.114,\\r\\n                            0.595716, -0.274453, -0.321263,\\r\\n                            0.211456, -0.522591,  0.311135);\\r\\n    const mat3 toRGB = mat3(1.0,  0.9563,  0.6210,\\r\\n                            1.0, -0.2721, -0.6474,\\r\\n                            1.0, -1.107,   1.7046);\\r\\n    vec3 yiq = toYIQ * rgb;\\r\\n    float hue = atan(yiq.z, yiq.y) + adjustment;\\r\\n    float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\\r\\n    vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\\r\\n    vec3 final = toRGB * color;\\r\\n    final = clamp(final , 0.0, 1.0);\\r\\n    return final;\\r\\n}\\r\\n//saturation added by zhgu\\r\\nvec3 czm_saturation(vec3 rgb, float adjustment)\\r\\n{\\r\\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\\r\\n    vec3 intensity = vec3(dot(rgb, W));\\r\\n    vec3 color = mix(intensity, rgb, adjustment);\\r\\n    color = clamp(color , 0.0, 1.0);\\r\\n    return color;\\r\\n\\r\\n}\\r\\n\\r\\nvec4 czm_FilterColor (vec4 finalColor){\\r\\n    vec4 finalColor1 = vec4(0);\\r\\n    if(grayFilterEnable){\\r\\n         float gray = clamp( dot( finalColor.rgb, vec3(0.333, 0.333, 0.333) ), 0.0, 1.0 );\\r\\n         finalColor1.rgb = texture2D( colorMapping, vec2( gray, 0.5 ) ).rgb;\\r\\n         finalColor1.a = finalColor.a;\\r\\n    }else{\\r\\n        finalColor1 = finalColor;\\r\\n    }\\r\\n    return finalColor1;\\r\\n}\\r\\nvec4 sampleAndBlend(\\r\\n    float addEffect,\\r\\n    vec4 eColor,\\r\\n    vec4 addColor,\\r\\n    vec4 previousColor,\\r\\n\\tsampler2D sampler_texture,\\r\\n\\tvec2 tileTextureCoordinates,\\r\\n\\tvec4 textureCoordinateRectangle,\\r\\n\\tvec4 textureCoordinateTranslationAndScale,\\r\\n\\tfloat textureAlphaIndex,\\r\\n\\tfloat brightness,\\r\\n\\tfloat south,\\r\\n\\tfloat north,\\r\\n\\tfloat southMercatorY,\\r\\n\\tfloat oneOverMercatorHeight,\\r\\n\\tfloat isReProjection,\\r\\n\\tvec4 alphaValue,\\r\\n\\t float contrast,\\r\\n     float hue,\\r\\n     float saturation,\\r\\n     float gamma)\\r\\n{\\r\\n\\r\\n\\tfloat textureAlpha = 1.0;\\r\\n\\r\\n\\tvec2 alphaMultiplier = step(textureCoordinateRectangle.xy, tileTextureCoordinates);\\r\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n    alphaMultiplier = step(vec2(0.0,0.0), textureCoordinateRectangle.zw - tileTextureCoordinates);\\r\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n\\tvec2 translation = textureCoordinateTranslationAndScale.xy;\\r\\n    vec2 scale = textureCoordinateTranslationAndScale.zw;\\r\\n    vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\\r\\n\\r\\n\\t//再投影\\r\\n\\r\\n    if(oneOverMercatorHeight!=0.0){\\r\\n        float latitude = mix(south, north , textureCoordinates.y);\\r\\n        float sinLatitude = sin(latitude);\\r\\n        float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\\r\\n        float mercatorFraction = (mercatorY - southMercatorY) * oneOverMercatorHeight;\\r\\n        textureCoordinates.y =  mercatorFraction;\\r\\n        if( isReProjection == 0.0){\\r\\n            textureCoordinates.y =   (tileTextureCoordinates * scale + translation).y;\\r\\n        }\\r\\n    }\\r\\n    vec4 value = texture2D(sampler_texture, textureCoordinates);\\r\\n    if(addEffect == 1.0){\\r\\n        value = depthColor(value);\\r\\n    }\\r\\n    value.rgb *=eColor.rgb;\\r\\n//      if(eColor.a==1.0){\\r\\n//            value *=eColor;\\r\\n//          }\\r\\n//          else{\\r\\n//            //value.rgb = (value.rgb + eColor.rgb * eColor.a)/(1.0 + eColor.a);\\r\\n//             value.rgb = value.rgb * (1.0-eColor.a) + eColor.rgb * eColor.a;\\r\\n//          }\\r\\n      value.rgb = (value.rgb + addColor.rgb * addColor.a)/(1.0 + addColor.a);\\r\\n    vec3 color = value.rgb;\\r\\n    float alpha = value.a;\\r\\n\\r\\n\\tcolor = mix(vec3(0.0,0.0,0.0), color, brightness);\\r\\n\\t    //contrast\\r\\n\\t    color = czm_contrast(color, contrast);\\r\\n        //hue\\r\\n        color = czm_hue(color, hue);\\r\\n        // saturation\\r\\n        color = czm_saturation(color, saturation);\\r\\n        // gamma\\r\\n        color = pow(color, vec3(gamma));\\r\\n        //finally you get the color\\r\\n        if(grayFilterIndex ==textureAlphaIndex){\\r\\n            color = czm_FilterColor(vec4(color,alpha)).rgb;\\r\\n        }\\r\\n\\r\\n\\tfloat sourceAlpha = alpha * textureAlpha;\\r\\n    float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\\r\\n    vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\\r\\n    return vec4(outColor, outAlpha);\\r\\n}\\r\\n\\r\\n//czm_ellipsoid czm_getWgs84EllipsoidEC()\\r\\n//{\\r\\n//    vec3 radii = vec3(6378137.0, 6378137.0, 6356752.314245);\\r\\n//    vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\\r\\n//    vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\\r\\n//    czm_ellipsoid temp = czm_ellipsoid(viewMatrix[3].xyz, radii, inverseRadii, inverseRadiiSquared);\\r\\n//    return temp;\\r\\n//}\\r\\nfloat czm_fade(float cameraDist, float fadeInDist,float fadeOutDist){\\r\\n    float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\\r\\n    return fade;\\r\\n}\\r\\nAtmosphereColor computeGroundAtmosphereFromSpace(vec3 v3Pos, bool useSunLighting){\\r\\n        //float PI = 3.14159265;\\r\\n    \\t//float g2 =  g * g;\\r\\n\\r\\n    \\tvec3 v3InvWavelength = vec3(1.0 / pow(0.650, 4.0), 1.0 / pow(0.570, 4.0), 1.0 / pow(0.475, 4.0));\\r\\n\\r\\n    \\tvec3 v3CameraPos =  vec3(0.0, 0.0, 0.0);\\r\\n    \\tv3CameraPos = cameraPosition;\\r\\n\\r\\n    \\t// vec3 v3LightPos = v3LightPosInput / length(v3LightPosInput);\\r\\n        vec3 v3LightPos = v3LightPosInput;\\r\\n\\r\\n    \\tfloat fCameraHeight = length(v3CameraPos);\\r\\n\\r\\n    \\tfloat fCameraHeight2 = fCameraHeight * fCameraHeight;\\r\\n\\r\\n            \\tfloat inOutFactor = 1.05;\\r\\n            \\tfloat fInnerRadius2 = fInnerRadius * fInnerRadius;\\r\\n            \\tfloat fOuterRadius2 = fOuterRadius * fOuterRadius;\\r\\n\\r\\n            \\tfloat fKrESun = Kr * ESun;\\r\\n            \\tfloat fKmESun = Km * ESun;\\r\\n            \\tfloat fKr4PI = Kr * 4.0 * PI;\\r\\n            \\tfloat fKm4PI = Km * 4.0 * PI;\\r\\n\\r\\n            \\tfloat fInvScaleDepth = 1.0 / fScaleDepth;\\r\\n            \\tfloat fScale = 1.0 / (fOuterRadius - fInnerRadius);\\r\\n            \\tfloat fScaleOverScaleDepth = fScale / fScaleDepth;\\r\\n\\r\\n            \\t////////////////////////////////////////////////\\r\\n            \\t// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\\r\\n//            \\tvec3 v3Pos = PositionWS;\\r\\n            \\tvec3 v3Ray = v3Pos - v3CameraPos;\\r\\n            \\tv3Pos = normalize(v3Pos);\\r\\n            \\tfloat fFar = length(v3Ray);\\r\\n            \\tv3Ray /= fFar;\\r\\n            \\t// Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\\r\\n            \\tfloat fNear = getNearIntersection(v3CameraPos, v3Ray, fCameraHeight2, fOuterRadius2);\\r\\n            \\t// Calculate the ray\'s starting position, then calculate its scattering offset\\r\\n            \\tvec3 v3Start = v3CameraPos + v3Ray * fNear;\\r\\n            \\tfFar -= fNear;\\r\\n            \\tfloat fDepth = exp((fInnerRadius - fOuterRadius) * fInvScaleDepth);\\r\\n\\r\\n\\r\\n            \\t//changed by zhgu if you donnot want night make it 1.0\\r\\n            \\tfloat fLightAngle = useSunLighting ? dot(v3LightPos, v3Pos)/length(v3Pos) : 1.0;\\r\\n            \\tfloat fCameraAngle = dot(-v3Ray, v3Pos)/length(v3Pos);\\r\\n            \\t//float fLightAngle = dot(v3LightPos, v3Pos);\\r\\n            \\tfloat fCameraScale = scale(fCameraAngle, fScaleDepth);\\r\\n            \\tfloat fLightScale = scale(fLightAngle, fScaleDepth);\\r\\n            \\tfloat fCameraOffset = fDepth*fCameraScale;\\r\\n            \\tfloat fTemp = (fLightScale + fCameraScale);\\r\\n            \\t// Initialize the scattering loop variables\\r\\n            \\t//gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);\\r\\n            \\tfloat fSampleLength = fFar / fSamples;\\r\\n            \\tfloat fScaledLength = fSampleLength * fScale;\\r\\n            \\tvec3 v3SampleRay = v3Ray * fSampleLength;\\r\\n            \\tvec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\\r\\n            \\t// Now loop through the sample rays\\r\\n            \\tvec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\\r\\n            \\tvec3 v3Attenuate = vec3(0.0,0.0,0.0);\\r\\n            \\tfor(int i=0; i<2; i++)\\r\\n            \\t{\\r\\n            \\t  float fHeight = length(v3SamplePoint);\\r\\n            \\t  float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\\r\\n            \\t  float fScatter = fDepth*fTemp - fCameraOffset;\\r\\n            \\t  v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\\r\\n            \\t  v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\\r\\n            \\t  v3SamplePoint += v3SampleRay;\\r\\n            \\t}\\r\\n            \\tAtmosphereColor color;\\r\\n            \\tcolor.mie = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\\r\\n            \\tcolor.rayleigh = v3Attenuate;\\r\\n            \\treturn color;\\r\\n\\r\\n}\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor) {\\r\\n    float scalar = distanceToCamera * czm_fogDensity;\\r\\n    float fog = 1.0 - exp(-(scalar * scalar));\\r\\n    return mix(color, fogColor, fog);\\r\\n}\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant) {\\r\\n    float scalar = distanceToCamera * czm_fogDensity;\\r\\n    float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));\\r\\n    return mix(color, fogColor, fog);\\r\\n}\\r\\n\\r\\nfloat czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC)\\r\\n{\\r\\n    return max(dot(lightDirectionEC, normalEC), 0.0);\\r\\n}\\r\\nvarying float dotValue;\\r\\nvarying vec3 sunDirectionEC;\\r\\nvarying vec3 normalEC;\\r\\nvoid main(\\t)\\r\\n{\\r\\n#include <logdepthbuf_fragment>\\r\\n\\t//vec2 texCoords =  vec2( gl_TexCoord[0] );\\r\\n\\t\\tvec2 webglUv = texCoords;\\r\\n//         webglUv.y =1.0 - webglUv.y;\\r\\n         webglUv = clamp(webglUv , 0.0, 1.0);\\r\\n\\tvec4 lastColor = sampleAndBlend(isAddEffect0,earthColor0,earthAddColor0,u_initialColor,TexSampler0,webglUv,textureRectangle0,textureTransAndScale0,alphaIndex0,brightness0,south1,north1,southMercatorY1,oneOverMercatorHeight1,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect1,earthColor1,earthAddColor1,lastColor,TexSampler1,webglUv,textureRectangle1,textureTransAndScale1,alphaIndex1,brightness1,south2,north2,southMercatorY2,oneOverMercatorHeight2,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n    lastColor = sampleAndBlend(isAddEffect2,earthColor2,earthAddColor2,lastColor,TexSampler2,webglUv,textureRectangle2,textureTransAndScale2,alphaIndex2,brightness2,south3,north3,southMercatorY3,oneOverMercatorHeight3,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect3,earthColor3,earthAddColor3,lastColor,TexSampler3,webglUv,textureRectangle3,textureTransAndScale3,alphaIndex3,brightness3,south4,north4,southMercatorY4,oneOverMercatorHeight4,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n    lastColor = sampleAndBlend(isAddEffect4,earthColor4,earthAddColor4,lastColor,TexSampler4,webglUv,textureRectangle4,textureTransAndScale4,alphaIndex4,brightness4,south5,north5,southMercatorY5,oneOverMercatorHeight5,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect5,earthColor5,earthAddColor5,lastColor,TexSampler5,webglUv,textureRectangle5,textureTransAndScale5,alphaIndex5,brightness5,south6,north6,southMercatorY6,oneOverMercatorHeight6,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n   \\tlastColor = sampleAndBlend(isAddEffect6,earthColor6,earthAddColor6,lastColor,TexSampler6,webglUv,textureRectangle6,textureTransAndScale6,alphaIndex6,brightness6,south7,north7,southMercatorY7,oneOverMercatorHeight7,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\t//added fade by zhgu to caculate fog\\r\\n           //float cameraDist = length(viewMatrix[3]);\\r\\n           float cameraDist = length(cameraPosition);\\r\\n       \\tfloat fade = czm_fade(cameraDist, fadeInDist, fadeOutDist);\\r\\n\\r\\n           //added lambertDiffuse TODO is it effective? 这个很一般，先忽略吧，毕竟咱们性能不太好啊\\r\\n           //float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_sunDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);\\r\\n           //diffuseIntensity = mix(1.0, diffuseIntensity, fade);\\r\\n           //vec4 finalColor = vec4(color.rgb * diffuseIntensity, color.a);\\r\\n           vec4 finalColor = lastColor;\\r\\n           //added fogColor and hdr\\r\\n           //added fogColor and hdr\\r\\n                    AtmosphereColor atmosFogColor = computeGroundAtmosphereFromSpace(PositionWS, false);\\r\\n                    vec3 c0 = atmosFogColor.mie;\\r\\n                    vec3 c1 = atmosFogColor.rayleigh;\\r\\n                   vec3 fogColor1 = c0 + finalColor.rgb * c1;\\r\\n                   //we should use hdr\\r\\n                   const float fExposure = 2.0;\\r\\n                   fogColor1 = vec3(1.0) - exp(-fExposure * fogColor1);\\r\\n\\r\\n                   //fog added\\r\\n                   //const float modifier = 0.15;\\r\\n                    finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor1), finalColor.a);\\r\\n\\r\\n                // ---------------------------------------------------------------------------\\r\\n                //ground\\r\\n                //SUN 这个sun的计算处理了下，我们不能和cesium用一样的参数，这样可能无法模拟真实太阳的位置\\r\\n                // changed by ztf 此处太阳光照计算废弃\\r\\n                // vec3 groundAtmosphereColor = vec3(0.0);\\r\\n                // if(night == 1.0){\\r\\n                //         AtmosphereColor atmosColor = computeGroundAtmosphereFromSpace(PositionWS, true);\\r\\n                //         groundAtmosphereColor = atmosColor.mie + finalColor.rgb * atmosColor.rayleigh;\\r\\n                //         groundAtmosphereColor = vec3(1.0) - exp(-fExposure * groundAtmosphereColor);\\r\\n                //         //TODO 这个可能要弱一点才行\\r\\n                //         float sunlitAtmosphereIntensity = clamp((cameraDist - nightfadeOut) / (nightfadeIn - nightfadeOut), 0.0, 1.0);//caculate sun\\r\\n                //         // used hdr to make HDR look better\\r\\n                //         sunlitAtmosphereIntensity = max(sunlitAtmosphereIntensity * sunlitAtmosphereIntensity, 0.03);\\r\\n                //         //mix sun\\r\\n                //         groundAtmosphereColor = mix(groundAtmosphereColor, fogColor1, sunlitAtmosphereIntensity);\\r\\n                // }\\r\\n                // else{\\r\\n                //         groundAtmosphereColor = fogColor1;\\r\\n                // }\\r\\n                vec3 groundAtmosphereColor = fogColor1;\\r\\n                // ---------------------------------------------------------------------------\\r\\n           //use saturation to look better\\r\\n           groundAtmosphereColor = czm_saturation(groundAtmosphereColor, 1.6);\\r\\n           //mix\\r\\n           finalColor = vec4(mix(finalColor.rgb, groundAtmosphereColor, fade), finalColor.a);\\r\\n            finalColor.rgb *= vec3(earthColor0.a);\\r\\n            //finally you get the color\\r\\n             if(grayFilterIndex==-1.0){\\r\\n                finalColor = czm_FilterColor(finalColor);\\r\\n             }\\r\\n           gl_FragColor = finalColor;\\r\\n           //now we get the shadow\\r\\n//            gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), (1.0-getShadowMask()));\\r\\n        vec4 shadow = vec4(vec3(0.0), shadowOpacity * ( 1.0 - getShadowMask() ) );\\r\\n         gl_FragColor.rgb = mix(gl_FragColor.rgb, shadow.rgb, shadow.a);\\r\\n\\r\\n    // 昼夜和线性颜色叠加 互斥 开启\\r\\n    if(night == 1.0){\\r\\n\\r\\n        float diffuseIntensity = czm_getLambertDiffuse(sunDirectionEC, normalize(normalEC)) * 0.9 + 0.2;\\r\\n        gl_FragColor = vec4(gl_FragColor.rgb * diffuseIntensity, gl_FragColor.a);\\r\\n\\r\\n    }else {\\r\\n\\r\\n        // // 是否开启颜色叠加 0 关闭 1 开启\\r\\n        // uniform float gradientColorOverlayEnable;\\r\\n        // // 颜色叠加方向\\r\\n        // uniform vec3 mapDirection;\\r\\n        // // 叠加使用的渐变纹理\\r\\n        // uniform sampler2D gradientColorMap;\\r\\n\\r\\n        if(gradientColorOverlayEnable == 1.0){\\r\\n\\r\\n            float diffuseIntensity = dot(mapDirection, normalize(normalEC));\\r\\n            float uv_U = (diffuseIntensity + 1.0) / 2.0;// -1 ——> 1 映射到 0 —— 1\\r\\n            float uv_V = 0.1;\\r\\n\\r\\n            vec4 gradientColor = texture2D(gradientColorMap, vec2(uv_U, uv_V));\\r\\n\\r\\n            float tempR = gradientColor.r + (1.0 - gradientColor.r) * (1.0 - gradientOpacity);\\r\\n            float tempG = gradientColor.g + (1.0 - gradientColor.g) * (1.0 - gradientOpacity);\\r\\n            float tempB = gradientColor.b + (1.0 - gradientColor.b) * (1.0 - gradientOpacity);\\r\\n\\r\\n            gl_FragColor = vec4(gl_FragColor.rgb * vec3(tempR,tempG,tempB), gl_FragColor.a);\\r\\n\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n           #include <fog_fragment>\\r\\n}\\r\\n\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/mult_texture7.glsl?')
        },
        "./src/material/shaders/mult_texture8.glsl": /*!*************************************************!*\
  !*** ./src/material/shaders/mult_texture8.glsl ***!
  \*************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "//varying vec4 Position;\\r\\n#include <common>\\r\\n#include <packing>\\r\\n#include <fog_pars_fragment>\\r\\n#include <bsdfs>\\r\\n#include <lights_pars_begin>\\r\\n#include <shadowmap_pars_fragment>\\r\\n#include <shadowmask_pars_fragment>\\r\\n#include <logdepthbuf_pars_fragment>\\r\\nvarying vec3 PositionWS;\\r\\n//varying vec3 ModelPostion;\\r\\nvarying float v_distance;\\r\\nvarying vec2 texCoords;\\r\\n\\r\\nuniform bool grayFilterEnable;\\r\\nuniform float grayFilterIndex;\\r\\nuniform float shadowOpacity;\\r\\n//uniform float grayMinMax[2];\\r\\n//uniform float grayFilterPerBar[10];\\r\\n//uniform vec3 grayFilterColorBar[10];\\r\\n\\r\\n\\r\\nuniform sampler2D TexSampler0;\\r\\nuniform sampler2D TexSampler1;\\r\\nuniform sampler2D TexSampler2;\\r\\nuniform sampler2D TexSampler3;\\r\\nuniform sampler2D TexSampler4;\\r\\nuniform sampler2D TexSampler5;\\r\\nuniform sampler2D TexSampler6;\\r\\nuniform sampler2D TexSampler7;\\r\\n\\r\\nuniform\\tvec4 textureRectangle0;\\r\\nuniform\\tvec4 textureRectangle1;\\r\\nuniform\\tvec4 textureRectangle2;\\r\\nuniform\\tvec4 textureRectangle3;\\r\\nuniform\\tvec4 textureRectangle4;\\r\\nuniform\\tvec4 textureRectangle5;\\r\\nuniform\\tvec4 textureRectangle6;\\r\\nuniform\\tvec4 textureRectangle7;\\r\\n\\r\\nuniform\\tvec4 textureTransAndScale0;\\r\\nuniform\\tvec4 textureTransAndScale1;\\r\\nuniform\\tvec4 textureTransAndScale2;\\r\\nuniform\\tvec4 textureTransAndScale3;\\r\\nuniform\\tvec4 textureTransAndScale4;\\r\\nuniform\\tvec4 textureTransAndScale5;\\r\\nuniform\\tvec4 textureTransAndScale6;\\r\\nuniform\\tvec4 textureTransAndScale7;\\r\\n\\r\\nuniform float brightness0;\\r\\nuniform float brightness1;\\r\\nuniform float brightness2;\\r\\nuniform float brightness3;\\r\\nuniform float brightness4;\\r\\nuniform float brightness5;\\r\\nuniform float brightness6;\\r\\nuniform float brightness7;\\r\\n\\r\\nuniform float alphaIndex0;\\r\\nuniform float alphaIndex1;\\r\\nuniform float alphaIndex2;\\r\\nuniform float alphaIndex3;\\r\\nuniform float alphaIndex4;\\r\\nuniform float alphaIndex5;\\r\\nuniform float alphaIndex6;\\r\\nuniform float alphaIndex7;\\r\\n\\r\\nuniform float isAddEffect0;\\r\\nuniform float isAddEffect1;\\r\\nuniform float isAddEffect2;\\r\\nuniform float isAddEffect3;\\r\\nuniform float isAddEffect4;\\r\\nuniform float isAddEffect5;\\r\\nuniform float isAddEffect6;\\r\\nuniform float isAddEffect7;\\r\\n\\r\\nuniform vec4 earthColor0;\\r\\nuniform vec4 earthColor1;\\r\\nuniform vec4 earthColor2;\\r\\nuniform vec4 earthColor3;\\r\\nuniform vec4 earthColor4;\\r\\nuniform vec4 earthColor5;\\r\\nuniform vec4 earthColor6;\\r\\nuniform vec4 earthColor7;\\r\\n\\r\\nuniform vec4 earthAddColor0;\\r\\nuniform vec4 earthAddColor1;\\r\\nuniform vec4 earthAddColor2;\\r\\nuniform vec4 earthAddColor3;\\r\\nuniform vec4 earthAddColor4;\\r\\nuniform vec4 earthAddColor5;\\r\\nuniform vec4 earthAddColor6;\\r\\nuniform vec4 earthAddColor7;\\r\\n\\r\\nuniform float south1;\\r\\nuniform float north1;\\r\\nuniform float southMercatorY1;\\r\\nuniform float oneOverMercatorHeight1;\\r\\nuniform float isReProjection;\\r\\n\\r\\nuniform float south2;\\r\\nuniform float north2;\\r\\nuniform float southMercatorY2;\\r\\nuniform float oneOverMercatorHeight2;\\r\\n\\r\\nuniform float south3;\\r\\nuniform float north3;\\r\\nuniform float southMercatorY3;\\r\\nuniform float oneOverMercatorHeight3;\\r\\n\\r\\nuniform float south4;\\r\\nuniform float north4;\\r\\nuniform float southMercatorY4;\\r\\nuniform float oneOverMercatorHeight4;\\r\\n\\r\\nuniform float south5;\\r\\nuniform float north5;\\r\\nuniform float southMercatorY5;\\r\\nuniform float oneOverMercatorHeight5;\\r\\n\\r\\nuniform float south6;\\r\\nuniform float north6;\\r\\nuniform float southMercatorY6;\\r\\nuniform float oneOverMercatorHeight6;\\r\\n\\r\\n\\r\\nuniform float south7;\\r\\nuniform float north7;\\r\\nuniform float southMercatorY7;\\r\\nuniform float oneOverMercatorHeight7;\\r\\n\\r\\n\\r\\nuniform float south8;\\r\\nuniform float north8;\\r\\nuniform float southMercatorY8;\\r\\nuniform float oneOverMercatorHeight8;\\r\\n\\r\\nuniform\\tfloat Km;\\r\\nuniform\\tfloat Kr;\\r\\nuniform\\tfloat ESun;\\r\\n\\r\\nuniform int nSamples;\\r\\nuniform float fSamples;\\r\\n\\r\\n//uniform float g,\\r\\n\\r\\n//uniform\\tvec3 v3CameraPosInput;\\r\\nuniform\\tvec3 v3LightPosInput;\\r\\n\\r\\nuniform\\tfloat fInnerRadius;\\r\\nuniform\\tfloat fOuterRadius;\\r\\n\\r\\nuniform float fScaleDepth;\\r\\nuniform\\tvec4 inputColor;\\r\\nuniform vec4 alphaValue;\\r\\nuniform float night;\\r\\n\\r\\nuniform float contrast;\\r\\nuniform float hue;\\r\\nuniform float saturation;\\r\\nuniform float textureGamma;\\r\\n\\r\\n//uniform vec4 earthColor;\\r\\n//uniform vec4 earthAddColor;\\r\\n//uniform float isAddEffect;\\r\\n\\r\\nuniform vec4 u_initialColor;\\r\\nuniform float nightfadeIn;\\r\\nuniform float nightfadeOut;\\r\\nuniform float fadeInDist;\\r\\nuniform float fadeOutDist;\\r\\n\\r\\nuniform float czm_fogDensity;\\r\\nuniform sampler2D colorMapping;\\r\\n\\r\\n// 是否开启颜色叠加 0 关闭 1 开启\\r\\nuniform float gradientColorOverlayEnable;\\r\\n// 颜色叠加方向\\r\\nuniform vec3 mapDirection;\\r\\n// 叠加使用的渐变纹理\\r\\nuniform sampler2D gradientColorMap;\\r\\n// 叠加使用的透明度\\r\\nuniform float gradientOpacity;\\r\\n\\r\\n//#define saturate(a) clamp( a, 0.0, 1.0 )\\r\\n//#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\r\\n//#define LOG2 1.442695\\r\\nstruct czm_ellipsoid\\r\\n{\\r\\n    vec3 center;\\r\\n    vec3 radii;\\r\\n    vec3 inverseRadii;\\r\\n    vec3 inverseRadiiSquared;\\r\\n};\\r\\nstruct AtmosphereColor\\r\\n{\\r\\n    vec3 mie;\\r\\n    vec3 rayleigh;\\r\\n};\\r\\n\\r\\n//搞定\\r\\nfloat scale(float fCos, float fScaleDepth)\\r\\n{\\r\\n\\tfloat x = 1.0 - fCos;\\r\\n\\treturn fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\\r\\n}\\r\\nvec4 depthColor(vec4 color)\\r\\n{\\r\\n     color.r = color.r * color.r * color.r;\\r\\n     color.g = color.g * color.g * color.g;\\r\\n     color.b = color.b * color.b;\\r\\n     return color;\\r\\n}\\r\\n//搞定\\r\\n// Returns the near intersection point of a line and a sphere\\r\\nfloat getNearIntersection(vec3 v3Pos, vec3 v3Ray, float fDistance2, float fRadius2)\\r\\n{\\r\\n\\tfloat B = 2.0 * dot(v3Pos, v3Ray);\\r\\n\\tfloat C = fDistance2 - fRadius2;\\r\\n\\tfloat fDet = max(0.0, B*B - 4.0 * C);\\r\\n\\treturn 0.5 * (-B - sqrt(fDet));\\r\\n}\\r\\n\\r\\n//contrast added by zhgu\\r\\nvec3 czm_contrast(vec3 rgb, float contrast){\\r\\n   vec3 color = mix(vec3(0.5), rgb, contrast);\\r\\n    color = clamp(color , 0.0, 1.0);\\r\\n    return color;\\r\\n}\\r\\n\\r\\n//hue added by zhgu\\r\\nvec3 czm_hue(vec3 rgb, float adjustment)\\r\\n{\\r\\n    const mat3 toYIQ = mat3(0.299,     0.587,     0.114,\\r\\n                            0.595716, -0.274453, -0.321263,\\r\\n                            0.211456, -0.522591,  0.311135);\\r\\n    const mat3 toRGB = mat3(1.0,  0.9563,  0.6210,\\r\\n                            1.0, -0.2721, -0.6474,\\r\\n                            1.0, -1.107,   1.7046);\\r\\n    vec3 yiq = toYIQ * rgb;\\r\\n    float hue = atan(yiq.z, yiq.y) + adjustment;\\r\\n    float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\\r\\n    vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\\r\\n    vec3 final = toRGB * color;\\r\\n    final = clamp(final , 0.0, 1.0);\\r\\n    return final;\\r\\n}\\r\\n//saturation added by zhgu\\r\\nvec3 czm_saturation(vec3 rgb, float adjustment)\\r\\n{\\r\\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\\r\\n    vec3 intensity = vec3(dot(rgb, W));\\r\\n    vec3 color = mix(intensity, rgb, adjustment);\\r\\n    color = clamp(color , 0.0, 1.0);\\r\\n    return color;\\r\\n\\r\\n}\\r\\n\\r\\nvec4 czm_FilterColor (vec4 finalColor){\\r\\n    vec4 finalColor1 = vec4(0);\\r\\n    if(grayFilterEnable){\\r\\n         float gray = clamp( dot( finalColor.rgb, vec3(0.333, 0.333, 0.333) ), 0.0, 1.0 );\\r\\n         finalColor1.rgb = texture2D( colorMapping, vec2( gray, 0.5 ) ).rgb;\\r\\n         finalColor1.a = finalColor.a;\\r\\n    }else{\\r\\n        finalColor1 = finalColor;\\r\\n    }\\r\\n    return finalColor1;\\r\\n}\\r\\nvec4 sampleAndBlend(\\r\\n    float addEffect,\\r\\n    vec4 eColor,\\r\\n    vec4 addColor,\\r\\n    vec4 previousColor,\\r\\n\\tsampler2D sampler_texture,\\r\\n\\tvec2 tileTextureCoordinates,\\r\\n\\tvec4 textureCoordinateRectangle,\\r\\n\\tvec4 textureCoordinateTranslationAndScale,\\r\\n\\tfloat textureAlphaIndex,\\r\\n\\tfloat brightness,\\r\\n\\tfloat south,\\r\\n\\tfloat north,\\r\\n\\tfloat southMercatorY,\\r\\n\\tfloat oneOverMercatorHeight,\\r\\n\\tfloat isReProjection,\\r\\n\\tvec4 alphaValue,\\r\\n\\t float contrast,\\r\\n     float hue,\\r\\n     float saturation,\\r\\n     float gamma)\\r\\n{\\r\\n\\r\\n\\tfloat textureAlpha = 1.0;\\r\\n\\r\\n\\tvec2 alphaMultiplier = step(textureCoordinateRectangle.xy, tileTextureCoordinates);\\r\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n    alphaMultiplier = step(vec2(0.0,0.0), textureCoordinateRectangle.zw - tileTextureCoordinates);\\r\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n\\tvec2 translation = textureCoordinateTranslationAndScale.xy;\\r\\n    vec2 scale = textureCoordinateTranslationAndScale.zw;\\r\\n    vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\\r\\n\\r\\n\\t//再投影\\r\\n    \\r\\n    if(oneOverMercatorHeight!=0.0){\\r\\n        float latitude = mix(south, north , textureCoordinates.y);\\r\\n        float sinLatitude = sin(latitude);\\r\\n        float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\\r\\n        float mercatorFraction = (mercatorY - southMercatorY) * oneOverMercatorHeight;\\r\\n        textureCoordinates.y =  mercatorFraction;\\r\\n\\r\\n        if(isReProjection == 0.0){\\r\\n            textureCoordinates.y =   (tileTextureCoordinates * scale + translation).y;\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\t//textureCoordinates.y = 1.0f - textureCoordinates.y;\\r\\n\\t//textureCoordinates.y = textureCoordinates.y;\\r\\n    vec4 value = texture2D(sampler_texture, textureCoordinates);\\r\\n      if(addEffect == 1.0){\\r\\n            value = depthColor(value);\\r\\n        }\\r\\n         value.rgb *=eColor.rgb;\\r\\n//         if(eColor.a==1.0){\\r\\n//               value *=eColor;\\r\\n//             }\\r\\n//             else{\\r\\n//               //value.rgb = (value.rgb + eColor.rgb * eColor.a)/(1.0 + eColor.a);\\r\\n//                value.rgb = value.rgb * (1.0-eColor.a) + eColor.rgb * eColor.a;\\r\\n//             }\\r\\n         value.rgb = (value.rgb + addColor.rgb * addColor.a)/(1.0 + addColor.a);\\r\\n    vec3 color = value.rgb;\\r\\n    float alpha = value.a;\\r\\n\\r\\n\\tcolor = mix(vec3(0.0,0.0,0.0), color, brightness);\\r\\n\\t\\t    //contrast\\r\\n    \\t    color = czm_contrast(color, contrast);\\r\\n            //hue\\r\\n            color = czm_hue(color, hue);\\r\\n            // saturation\\r\\n            color = czm_saturation(color, saturation);\\r\\n            // gamma\\r\\n            color = pow(color, vec3(gamma));\\r\\n            //filter\\r\\n            if(grayFilterIndex == textureAlphaIndex){\\r\\n                color = czm_FilterColor(vec4(color,alpha)).rgb;\\r\\n            }\\r\\n\\tfloat sourceAlpha = alpha * textureAlpha;\\r\\n    float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\\r\\n    vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\\r\\n    return vec4(outColor, outAlpha);\\r\\n}\\r\\n//czm_ellipsoid czm_getWgs84EllipsoidEC()\\r\\n//{\\r\\n//    vec3 radii = vec3(6378137.0, 6378137.0, 6356752.314245);\\r\\n//    vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\\r\\n//    vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\\r\\n//    czm_ellipsoid temp = czm_ellipsoid(viewMatrix[3].xyz, radii, inverseRadii, inverseRadiiSquared);\\r\\n//    return temp;\\r\\n//}\\r\\nfloat czm_fade(float cameraDist, float fadeInDist,float fadeOutDist){\\r\\n    float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\\r\\n    return fade;\\r\\n}\\r\\nAtmosphereColor computeGroundAtmosphereFromSpace(vec3 v3Pos, bool useSunLighting){\\r\\n        //float PI = 3.14159265;\\r\\n    \\t//float g2 =  g * g;\\r\\n\\r\\n    \\tvec3 v3InvWavelength = vec3(1.0 / pow(0.650, 4.0), 1.0 / pow(0.570, 4.0), 1.0 / pow(0.475, 4.0));\\r\\n\\r\\n    \\tvec3 v3CameraPos =  vec3(0.0, 0.0, 0.0);\\r\\n    \\tv3CameraPos = cameraPosition;\\r\\n\\r\\n    \\t// vec3 v3LightPos = v3LightPosInput / length(v3LightPosInput);\\r\\n        vec3 v3LightPos = v3LightPosInput;\\r\\n\\r\\n    \\tfloat fCameraHeight = length(v3CameraPos);\\r\\n\\r\\n    \\tfloat fCameraHeight2 = fCameraHeight * fCameraHeight;\\r\\n\\r\\n            \\tfloat inOutFactor = 1.05;\\r\\n            \\tfloat fInnerRadius2 = fInnerRadius * fInnerRadius;\\r\\n            \\tfloat fOuterRadius2 = fOuterRadius * fOuterRadius;\\r\\n\\r\\n            \\tfloat fKrESun = Kr * ESun;\\r\\n            \\tfloat fKmESun = Km * ESun;\\r\\n            \\tfloat fKr4PI = Kr * 4.0 * PI;\\r\\n            \\tfloat fKm4PI = Km * 4.0 * PI;\\r\\n\\r\\n            \\tfloat fInvScaleDepth = 1.0 / fScaleDepth;\\r\\n            \\tfloat fScale = 1.0 / (fOuterRadius - fInnerRadius);\\r\\n            \\tfloat fScaleOverScaleDepth = fScale / fScaleDepth;\\r\\n\\r\\n            \\t////////////////////////////////////////////////\\r\\n            \\t// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\\r\\n//            \\tvec3 v3Pos = PositionWS;\\r\\n            \\tvec3 v3Ray = v3Pos - v3CameraPos;\\r\\n            \\tv3Pos = normalize(v3Pos);\\r\\n            \\tfloat fFar = length(v3Ray);\\r\\n            \\tv3Ray /= fFar;\\r\\n            \\t// Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\\r\\n            \\tfloat fNear = getNearIntersection(v3CameraPos, v3Ray, fCameraHeight2, fOuterRadius2);\\r\\n            \\t// Calculate the ray\'s starting position, then calculate its scattering offset\\r\\n            \\tvec3 v3Start = v3CameraPos + v3Ray * fNear;\\r\\n            \\tfFar -= fNear;\\r\\n            \\tfloat fDepth = exp((fInnerRadius - fOuterRadius) * fInvScaleDepth);\\r\\n\\r\\n\\r\\n            \\t//changed by zhgu if you donnot want night make it 1.0\\r\\n            \\tfloat fLightAngle = useSunLighting ? dot(v3LightPos, v3Pos)/length(v3Pos) : 1.0;\\r\\n            \\tfloat fCameraAngle = dot(-v3Ray, v3Pos)/length(v3Pos);\\r\\n            \\t//float fLightAngle = dot(v3LightPos, v3Pos);\\r\\n            \\tfloat fCameraScale = scale(fCameraAngle, fScaleDepth);\\r\\n            \\tfloat fLightScale = scale(fLightAngle, fScaleDepth);\\r\\n            \\tfloat fCameraOffset = fDepth*fCameraScale;\\r\\n            \\tfloat fTemp = (fLightScale + fCameraScale);\\r\\n            \\t// Initialize the scattering loop variables\\r\\n            \\t//gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);\\r\\n            \\tfloat fSampleLength = fFar / fSamples;\\r\\n            \\tfloat fScaledLength = fSampleLength * fScale;\\r\\n            \\tvec3 v3SampleRay = v3Ray * fSampleLength;\\r\\n            \\tvec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\\r\\n            \\t// Now loop through the sample rays\\r\\n            \\tvec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\\r\\n            \\tvec3 v3Attenuate = vec3(0.0,0.0,0.0);\\r\\n            \\tfor(int i=0; i<2; i++)\\r\\n            \\t{\\r\\n            \\t  float fHeight = length(v3SamplePoint);\\r\\n            \\t  float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\\r\\n            \\t  float fScatter = fDepth*fTemp - fCameraOffset;\\r\\n            \\t  v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\\r\\n            \\t  v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\\r\\n            \\t  v3SamplePoint += v3SampleRay;\\r\\n            \\t}\\r\\n            \\tAtmosphereColor color;\\r\\n            \\tcolor.mie = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\\r\\n            \\tcolor.rayleigh = v3Attenuate;\\r\\n            \\treturn color;\\r\\n\\r\\n}\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor) {\\r\\n    float scalar = distanceToCamera * czm_fogDensity;\\r\\n    float fog = 1.0 - exp(-(scalar * scalar));\\r\\n    return mix(color, fogColor, fog);\\r\\n}\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant) {\\r\\n    float scalar = distanceToCamera * czm_fogDensity;\\r\\n    float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));\\r\\n    return mix(color, fogColor, fog);\\r\\n}\\r\\n\\r\\nfloat czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC)\\r\\n{\\r\\n    return max(dot(lightDirectionEC, normalEC), 0.0);\\r\\n}\\r\\nvarying float dotValue;\\r\\nvarying vec3 sunDirectionEC;\\r\\nvarying vec3 normalEC;\\r\\nvoid main(\\t)\\r\\n{\\r\\n    #include <logdepthbuf_fragment>\\r\\n\\t//vec2 texCoords =  vec2( gl_TexCoord[0] );\\r\\n\\tvec2 webglUv = texCoords;\\r\\n//    webglUv.y =1.0 - webglUv.y;\\r\\n    webglUv = clamp(webglUv , 0.0, 1.0);\\r\\n\\tvec4 lastColor = sampleAndBlend(isAddEffect0,earthColor0,earthAddColor0,u_initialColor,TexSampler0,webglUv,textureRectangle0,textureTransAndScale0,alphaIndex0,brightness0,south1,north1,southMercatorY1,oneOverMercatorHeight1,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect1,earthColor1,earthAddColor1,lastColor,TexSampler1,webglUv,textureRectangle1,textureTransAndScale1,alphaIndex1,brightness1,south2,north2,southMercatorY2,oneOverMercatorHeight2,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect2,earthColor2,earthAddColor2,lastColor,TexSampler2,webglUv,textureRectangle2,textureTransAndScale2,alphaIndex2,brightness2,south3,north3,southMercatorY3,oneOverMercatorHeight3,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect3,earthColor3,earthAddColor3,lastColor,TexSampler3,webglUv,textureRectangle3,textureTransAndScale3,alphaIndex3,brightness3,south4,north4,southMercatorY4,oneOverMercatorHeight4,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect4,earthColor4,earthAddColor4,lastColor,TexSampler4,webglUv,textureRectangle4,textureTransAndScale4,alphaIndex4,brightness4,south5,north5,southMercatorY5,oneOverMercatorHeight5,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n    lastColor = sampleAndBlend(isAddEffect4,earthColor4,earthAddColor4,lastColor,TexSampler4,webglUv,textureRectangle4,textureTransAndScale4,alphaIndex4,brightness4,south5,north5,southMercatorY5,oneOverMercatorHeight5,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect5,earthColor5,earthAddColor5,lastColor,TexSampler5,webglUv,textureRectangle5,textureTransAndScale5,alphaIndex5,brightness5,south6,north6,southMercatorY6,oneOverMercatorHeight6,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n   \\tlastColor = sampleAndBlend(isAddEffect6,earthColor6,earthAddColor6,lastColor,TexSampler6,webglUv,textureRectangle6,textureTransAndScale6,alphaIndex6,brightness6,south7,north7,southMercatorY7,oneOverMercatorHeight7,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect7,earthColor7,earthAddColor7,lastColor,TexSampler7,webglUv,textureRectangle7,textureTransAndScale7,alphaIndex7,brightness7,south8,north8,southMercatorY8,oneOverMercatorHeight8,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\t //added fade by zhgu to caculate fog\\r\\n             //float cameraDist = length(viewMatrix[3]);\\r\\n             float cameraDist = length(cameraPosition);\\r\\n         \\tfloat fade = czm_fade(cameraDist, fadeInDist, fadeOutDist);\\r\\n\\r\\n             //added lambertDiffuse TODO is it effective? 这个很一般，先忽略吧，毕竟咱们性能不太好啊\\r\\n             //float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_sunDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);\\r\\n             //diffuseIntensity = mix(1.0, diffuseIntensity, fade);\\r\\n             //vec4 finalColor = vec4(color.rgb * diffuseIntensity, color.a);\\r\\n             vec4 finalColor = lastColor;\\r\\n             //added fogColor and hdr\\r\\n             //added fogColor and hdr\\r\\n                      AtmosphereColor atmosFogColor = computeGroundAtmosphereFromSpace(PositionWS, false);\\r\\n                      vec3 c0 = atmosFogColor.mie;\\r\\n                      vec3 c1 = atmosFogColor.rayleigh;\\r\\n                     vec3 fogColor1 = c0 + finalColor.rgb * c1;\\r\\n                     //we should use hdr\\r\\n                     const float fExposure = 2.0;\\r\\n                     fogColor1 = vec3(1.0) - exp(-fExposure * fogColor1);\\r\\n\\r\\n                     //fog added\\r\\n                     //const float modifier = 0.15;\\r\\n                    finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor1), finalColor.a);\\r\\n\\r\\n                // ---------------------------------------------------------------------------\\r\\n                //ground\\r\\n                //SUN 这个sun的计算处理了下，我们不能和cesium用一样的参数，这样可能无法模拟真实太阳的位置\\r\\n                // changed by ztf 此处太阳光照计算废弃\\r\\n                // vec3 groundAtmosphereColor = vec3(0.0);\\r\\n                // if(night == 1.0){\\r\\n                //         AtmosphereColor atmosColor = computeGroundAtmosphereFromSpace(PositionWS, true);\\r\\n                //         groundAtmosphereColor = atmosColor.mie + finalColor.rgb * atmosColor.rayleigh;\\r\\n                //         groundAtmosphereColor = vec3(1.0) - exp(-fExposure * groundAtmosphereColor);\\r\\n                //         //TODO 这个可能要弱一点才行\\r\\n                //         float sunlitAtmosphereIntensity = clamp((cameraDist - nightfadeOut) / (nightfadeIn - nightfadeOut), 0.0, 1.0);//caculate sun\\r\\n                //         // used hdr to make HDR look better\\r\\n                //         sunlitAtmosphereIntensity = max(sunlitAtmosphereIntensity * sunlitAtmosphereIntensity, 0.03);\\r\\n                //         //mix sun\\r\\n                //         groundAtmosphereColor = mix(groundAtmosphereColor, fogColor1, sunlitAtmosphereIntensity);\\r\\n                // }\\r\\n                // else{\\r\\n                //         groundAtmosphereColor = fogColor1;\\r\\n                // }\\r\\n                vec3 groundAtmosphereColor = fogColor1;\\r\\n                // ---------------------------------------------------------------------------\\r\\n             //use saturation to look better\\r\\n             groundAtmosphereColor = czm_saturation(groundAtmosphereColor, 1.6);\\r\\n             //mix\\r\\n             finalColor = vec4(mix(finalColor.rgb, groundAtmosphereColor, fade), finalColor.a);\\r\\n              finalColor.rgb *= vec3(earthColor0.a);\\r\\n             //finally you get the color\\r\\n             if(grayFilterIndex==-1.0)\\r\\n             finalColor = czm_FilterColor(finalColor);\\r\\n\\r\\n             gl_FragColor = finalColor;\\r\\n             //now we get the shadow\\r\\n//              gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), (1.0-getShadowMask()));\\r\\n        vec4 shadow = vec4(vec3(0.0), shadowOpacity * ( 1.0 - getShadowMask() ) );\\r\\n         gl_FragColor.rgb = mix(gl_FragColor.rgb, shadow.rgb, shadow.a);\\r\\n\\r\\n    // 昼夜和线性颜色叠加 互斥 开启\\r\\n    if(night == 1.0){\\r\\n\\r\\n        float diffuseIntensity = czm_getLambertDiffuse(sunDirectionEC, normalize(normalEC)) * 0.9 + 0.2;\\r\\n        gl_FragColor = vec4(gl_FragColor.rgb * diffuseIntensity, gl_FragColor.a);\\r\\n\\r\\n    }else {\\r\\n\\r\\n        // // 是否开启颜色叠加 0 关闭 1 开启\\r\\n        // uniform float gradientColorOverlayEnable;\\r\\n        // // 颜色叠加方向\\r\\n        // uniform vec3 mapDirection;\\r\\n        // // 叠加使用的渐变纹理\\r\\n        // uniform sampler2D gradientColorMap;\\r\\n        \\r\\n        if(gradientColorOverlayEnable == 1.0){\\r\\n\\r\\n            float diffuseIntensity = dot(mapDirection, normalize(normalEC));\\r\\n            float uv_U = (diffuseIntensity + 1.0) / 2.0;// -1 ——> 1 映射到 0 —— 1\\r\\n            float uv_V = 0.1;\\r\\n\\r\\n            vec4 gradientColor = texture2D(gradientColorMap, vec2(uv_U, uv_V));\\r\\n\\r\\n            float tempR = gradientColor.r + (1.0 - gradientColor.r) * (1.0 - gradientOpacity);\\r\\n            float tempG = gradientColor.g + (1.0 - gradientColor.g) * (1.0 - gradientOpacity);\\r\\n            float tempB = gradientColor.b + (1.0 - gradientColor.b) * (1.0 - gradientOpacity);\\r\\n\\r\\n            gl_FragColor = vec4(gl_FragColor.rgb * vec3(tempR,tempG,tempB), gl_FragColor.a);\\r\\n\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n             #include <fog_fragment>\\r\\n}\\r\\n\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/mult_texture8.glsl?')
        },
        "./src/material/shaders/mult_texture9.glsl": /*!*************************************************!*\
  !*** ./src/material/shaders/mult_texture9.glsl ***!
  \*************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "//varying vec4 Position;\\r\\n#include <common>\\r\\n#include <packing>\\r\\n#include <fog_pars_fragment>\\r\\n#include <bsdfs>\\r\\n#include <lights_pars_begin>\\r\\n#include <shadowmap_pars_fragment>\\r\\n#include <shadowmask_pars_fragment>\\r\\n#include <logdepthbuf_pars_fragment>\\r\\nvarying vec3 PositionWS;\\r\\nvarying vec2 texCoords;\\r\\n//varying vec3 ModelPostion;\\r\\nvarying float v_distance;\\r\\n\\r\\nuniform bool grayFilterEnable;\\r\\nuniform float grayFilterIndex;\\r\\nuniform float shadowOpacity;\\r\\n//uniform float grayMinMax[2];\\r\\n//uniform float grayFilterPerBar[10];\\r\\n//uniform vec3 grayFilterColorBar[10];\\r\\n\\r\\nuniform sampler2D TexSampler0;\\r\\nuniform sampler2D TexSampler1;\\r\\nuniform sampler2D TexSampler2;\\r\\nuniform sampler2D TexSampler3;\\r\\nuniform sampler2D TexSampler4;\\r\\nuniform sampler2D TexSampler5;\\r\\nuniform sampler2D TexSampler6;\\r\\nuniform sampler2D TexSampler7;\\r\\nuniform sampler2D TexSampler8;\\r\\n\\r\\nuniform\\tvec4 textureRectangle0;\\r\\nuniform\\tvec4 textureRectangle1;\\r\\nuniform\\tvec4 textureRectangle2;\\r\\nuniform\\tvec4 textureRectangle3;\\r\\nuniform\\tvec4 textureRectangle4;\\r\\nuniform\\tvec4 textureRectangle5;\\r\\nuniform\\tvec4 textureRectangle6;\\r\\nuniform\\tvec4 textureRectangle7;\\r\\nuniform\\tvec4 textureRectangle8;\\r\\n\\r\\nuniform\\tvec4 textureTransAndScale0;\\r\\nuniform\\tvec4 textureTransAndScale1;\\r\\nuniform\\tvec4 textureTransAndScale2;\\r\\nuniform\\tvec4 textureTransAndScale3;\\r\\nuniform\\tvec4 textureTransAndScale4;\\r\\nuniform\\tvec4 textureTransAndScale5;\\r\\nuniform\\tvec4 textureTransAndScale6;\\r\\nuniform\\tvec4 textureTransAndScale7;\\r\\nuniform\\tvec4 textureTransAndScale8;\\r\\n\\r\\nuniform float brightness0;\\r\\nuniform float brightness1;\\r\\nuniform float brightness2;\\r\\nuniform float brightness3;\\r\\nuniform float brightness4;\\r\\nuniform float brightness5;\\r\\nuniform float brightness6;\\r\\nuniform float brightness7;\\r\\nuniform float brightness8;\\r\\n\\r\\nuniform float alphaIndex0;\\r\\nuniform float alphaIndex1;\\r\\nuniform float alphaIndex2;\\r\\nuniform float alphaIndex3;\\r\\nuniform float alphaIndex4;\\r\\nuniform float alphaIndex5;\\r\\nuniform float alphaIndex6;\\r\\nuniform float alphaIndex7;\\r\\nuniform float alphaIndex8;\\r\\n\\r\\nuniform float isAddEffect0;\\r\\nuniform float isAddEffect1;\\r\\nuniform float isAddEffect2;\\r\\nuniform float isAddEffect3;\\r\\nuniform float isAddEffect4;\\r\\nuniform float isAddEffect5;\\r\\nuniform float isAddEffect6;\\r\\nuniform float isAddEffect7;\\r\\nuniform float isAddEffect8;\\r\\n\\r\\nuniform vec4 earthColor0;\\r\\nuniform vec4 earthColor1;\\r\\nuniform vec4 earthColor2;\\r\\nuniform vec4 earthColor3;\\r\\nuniform vec4 earthColor4;\\r\\nuniform vec4 earthColor5;\\r\\nuniform vec4 earthColor6;\\r\\nuniform vec4 earthColor7;\\r\\nuniform vec4 earthColor8;\\r\\n\\r\\nuniform vec4 earthAddColor0;\\r\\nuniform vec4 earthAddColor1;\\r\\nuniform vec4 earthAddColor2;\\r\\nuniform vec4 earthAddColor3;\\r\\nuniform vec4 earthAddColor4;\\r\\nuniform vec4 earthAddColor5;\\r\\nuniform vec4 earthAddColor6;\\r\\nuniform vec4 earthAddColor7;\\r\\nuniform vec4 earthAddColor8;\\r\\n\\r\\nuniform float south1;\\r\\nuniform float north1;\\r\\nuniform float southMercatorY1;\\r\\nuniform float oneOverMercatorHeight1;\\r\\nuniform float isReProjection;\\r\\n\\r\\nuniform float south2;\\r\\nuniform float north2;\\r\\nuniform float southMercatorY2;\\r\\nuniform float oneOverMercatorHeight2;\\r\\n\\r\\nuniform float south3;\\r\\nuniform float north3;\\r\\nuniform float southMercatorY3;\\r\\nuniform float oneOverMercatorHeight3;\\r\\n\\r\\nuniform float south4;\\r\\nuniform float north4;\\r\\nuniform float southMercatorY4;\\r\\nuniform float oneOverMercatorHeight4;\\r\\n\\r\\nuniform float south5;\\r\\nuniform float north5;\\r\\nuniform float southMercatorY5;\\r\\nuniform float oneOverMercatorHeight5;\\r\\n\\r\\nuniform float south6;\\r\\nuniform float north6;\\r\\nuniform float southMercatorY6;\\r\\nuniform float oneOverMercatorHeight6;\\r\\n\\r\\n\\r\\nuniform float south7;\\r\\nuniform float north7;\\r\\nuniform float southMercatorY7;\\r\\nuniform float oneOverMercatorHeight7;\\r\\n\\r\\n\\r\\nuniform float south8;\\r\\nuniform float north8;\\r\\nuniform float southMercatorY8;\\r\\nuniform float oneOverMercatorHeight8;\\r\\n\\r\\n\\r\\nuniform float south9;\\r\\nuniform float north9;\\r\\nuniform float southMercatorY9;\\r\\nuniform float oneOverMercatorHeight9;\\r\\n\\r\\nuniform\\tfloat Km;\\r\\nuniform\\tfloat Kr;\\r\\nuniform\\tfloat ESun;\\r\\n\\r\\nuniform int nSamples;\\r\\nuniform float fSamples;\\r\\n\\r\\n//uniform float g,\\r\\n\\r\\n//uniform\\tvec3 v3CameraPosInput;\\r\\nuniform\\tvec3 v3LightPosInput;\\r\\n\\r\\nuniform\\tfloat fInnerRadius;\\r\\nuniform\\tfloat fOuterRadius;\\r\\n\\r\\nuniform float fScaleDepth;\\r\\nuniform\\tvec4 inputColor;\\r\\nuniform vec4 alphaValue;\\r\\nuniform float night;\\r\\n\\r\\nuniform float contrast;\\r\\nuniform float hue;\\r\\nuniform float saturation;\\r\\nuniform float textureGamma;\\r\\n//uniform vec4 earthColor;\\r\\n//uniform vec4 earthAddColor;\\r\\n//uniform float isAddEffect;\\r\\n\\r\\nuniform vec4 u_initialColor;\\r\\nuniform float nightfadeIn;\\r\\nuniform float nightfadeOut;\\r\\nuniform float fadeInDist;\\r\\nuniform float fadeOutDist;\\r\\n\\r\\nuniform float czm_fogDensity;\\r\\nuniform sampler2D colorMapping;\\r\\n\\r\\n// 是否开启颜色叠加 0 关闭 1 开启\\r\\nuniform float gradientColorOverlayEnable;\\r\\n// 颜色叠加方向\\r\\nuniform vec3 mapDirection;\\r\\n// 叠加使用的渐变纹理\\r\\nuniform sampler2D gradientColorMap;\\r\\n// 叠加使用的透明度\\r\\nuniform float gradientOpacity;\\r\\n\\r\\n//#define saturate(a) clamp( a, 0.0, 1.0 )\\r\\n//#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\r\\n//#define LOG2 1.442695\\r\\nstruct czm_ellipsoid\\r\\n{\\r\\n    vec3 center;\\r\\n    vec3 radii;\\r\\n    vec3 inverseRadii;\\r\\n    vec3 inverseRadiiSquared;\\r\\n};\\r\\nstruct AtmosphereColor\\r\\n{\\r\\n    vec3 mie;\\r\\n    vec3 rayleigh;\\r\\n};\\r\\n//搞定\\r\\nfloat scale(float fCos, float fScaleDepth)\\r\\n{\\r\\n\\tfloat x = 1.0 - fCos;\\r\\n\\treturn fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\\r\\n}\\r\\nvec4 depthColor(vec4 color)\\r\\n{\\r\\n     color.r = color.r * color.r * color.r;\\r\\n     color.g = color.g * color.g * color.g;\\r\\n     color.b = color.b * color.b;\\r\\n     return color;\\r\\n}\\r\\n\\r\\n//搞定\\r\\n// Returns the near intersection point of a line and a sphere\\r\\nfloat getNearIntersection(vec3 v3Pos, vec3 v3Ray, float fDistance2, float fRadius2)\\r\\n{\\r\\n\\tfloat B = 2.0 * dot(v3Pos, v3Ray);\\r\\n\\tfloat C = fDistance2 - fRadius2;\\r\\n\\tfloat fDet = max(0.0, B*B - 4.0 * C);\\r\\n\\treturn 0.5 * (-B - sqrt(fDet));\\r\\n}\\r\\n\\r\\n//contrast added by zhgu\\r\\nvec3 czm_contrast(vec3 rgb, float contrast){\\r\\n   vec3 color = mix(vec3(0.5), rgb, contrast);\\r\\n    color = clamp(color , 0.0, 1.0);\\r\\n    return color;\\r\\n}\\r\\n\\r\\n//hue added by zhgu\\r\\nvec3 czm_hue(vec3 rgb, float adjustment)\\r\\n{\\r\\n    const mat3 toYIQ = mat3(0.299,     0.587,     0.114,\\r\\n                            0.595716, -0.274453, -0.321263,\\r\\n                            0.211456, -0.522591,  0.311135);\\r\\n    const mat3 toRGB = mat3(1.0,  0.9563,  0.6210,\\r\\n                            1.0, -0.2721, -0.6474,\\r\\n                            1.0, -1.107,   1.7046);\\r\\n    vec3 yiq = toYIQ * rgb;\\r\\n    float hue = atan(yiq.z, yiq.y) + adjustment;\\r\\n    float chroma = sqrt(yiq.z * yiq.z + yiq.y * yiq.y);\\r\\n    vec3 color = vec3(yiq.x, chroma * cos(hue), chroma * sin(hue));\\r\\n    vec3 final = toRGB * color;\\r\\n    final = clamp(final , 0.0, 1.0);\\r\\n    return final;\\r\\n}\\r\\n//saturation added by zhgu\\r\\nvec3 czm_saturation(vec3 rgb, float adjustment)\\r\\n{\\r\\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\\r\\n    vec3 intensity = vec3(dot(rgb, W));\\r\\n    vec3 color = mix(intensity, rgb, adjustment);\\r\\n    color = clamp(color , 0.0, 1.0);\\r\\n    return color;\\r\\n\\r\\n}\\r\\nvec4 czm_FilterColor (vec4 finalColor){\\r\\n    vec4 finalColor1 = vec4(0);\\r\\n    if(grayFilterEnable){\\r\\n         float gray = clamp( dot( finalColor.rgb, vec3(0.333, 0.333, 0.333) ), 0.0, 1.0 );\\r\\n         finalColor1.rgb = texture2D( colorMapping, vec2( gray, 0.5 ) ).rgb;\\r\\n         finalColor1.a = finalColor.a;\\r\\n    }else{\\r\\n        finalColor1 = finalColor;\\r\\n    }\\r\\n    return finalColor1;\\r\\n}\\r\\nvec4 sampleAndBlend(\\r\\n    float addEffect,\\r\\n    vec4 eColor,\\r\\n    vec4 addColor,\\r\\n    vec4 previousColor,\\r\\n\\tsampler2D sampler_texture,\\r\\n\\tvec2 tileTextureCoordinates,\\r\\n\\tvec4 textureCoordinateRectangle,\\r\\n\\tvec4 textureCoordinateTranslationAndScale,\\r\\n\\tfloat textureAlphaIndex,\\r\\n\\tfloat brightness,\\r\\n\\tfloat south,\\r\\n\\tfloat north,\\r\\n\\tfloat southMercatorY,\\r\\n\\tfloat oneOverMercatorHeight,\\r\\n\\tfloat isReProjection,\\r\\n\\tvec4 alphaValue,\\r\\n\\t float contrast,\\r\\n     float hue,\\r\\n     float saturation,\\r\\n     float gamma)\\r\\n{\\r\\n\\r\\n\\tfloat textureAlpha = 1.0;\\r\\n\\r\\n\\tvec2 alphaMultiplier = step(textureCoordinateRectangle.xy, tileTextureCoordinates);\\r\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n    alphaMultiplier = step(vec2(0.0,0.0), textureCoordinateRectangle.zw - tileTextureCoordinates);\\r\\n    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;\\r\\n\\r\\n\\tvec2 translation = textureCoordinateTranslationAndScale.xy;\\r\\n    vec2 scale = textureCoordinateTranslationAndScale.zw;\\r\\n    vec2 textureCoordinates = tileTextureCoordinates * scale + translation;\\r\\n\\r\\n\\t//再投影\\r\\n    \\r\\n    if(oneOverMercatorHeight!=0.0){\\r\\n        float latitude = mix(south, north , textureCoordinates.y);\\r\\n        float sinLatitude = sin(latitude);\\r\\n        float mercatorY = 0.5 * log((1.0 + sinLatitude) / (1.0 - sinLatitude));\\r\\n        float mercatorFraction = (mercatorY - southMercatorY) * oneOverMercatorHeight;\\r\\n        textureCoordinates.y =  mercatorFraction;\\r\\n        if(isReProjection == 0.0){\\r\\n            textureCoordinates.y = (tileTextureCoordinates * scale + translation).y;\\r\\n        }\\r\\n    }\\r\\n    vec4 value = texture2D(sampler_texture, textureCoordinates);\\r\\n     if(addEffect == 1.0){\\r\\n            value = depthColor(value);\\r\\n        }\\r\\n        value.rgb *=eColor.rgb;\\r\\n//         if(eColor.a==1.0){\\r\\n//               value *=eColor;\\r\\n//             }\\r\\n//             else{\\r\\n//               //value.rgb = (value.rgb + eColor.rgb * eColor.a)/(1.0 + eColor.a);\\r\\n//                value.rgb = value.rgb * (1.0-eColor.a) + eColor.rgb * eColor.a;\\r\\n//             }\\r\\n          value.rgb = (value.rgb + addColor.rgb * addColor.a)/(1.0 + addColor.a);\\r\\n    vec3 color = value.rgb;\\r\\n    float alpha = value.a;\\r\\n\\r\\n\\tcolor = mix(vec3(0.0,0.0,0.0), color, brightness);\\r\\n    //contrast\\r\\n    color = czm_contrast(color, contrast);\\r\\n    //hue\\r\\n    color = czm_hue(color, hue);\\r\\n    // saturation\\r\\n    color = czm_saturation(color, saturation);\\r\\n    // gamma\\r\\n    color = pow(color, vec3(gamma));\\r\\n    //filter\\r\\n    if(grayFilterIndex == textureAlphaIndex){\\r\\n        color = czm_FilterColor(vec4(color,alpha)).rgb;\\r\\n    }\\r\\n\\tfloat sourceAlpha = alpha * textureAlpha;\\r\\n    float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);\\r\\n    vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;\\r\\n    return vec4(outColor, outAlpha);\\r\\n}\\r\\n//czm_ellipsoid czm_getWgs84EllipsoidEC()\\r\\n//{\\r\\n//    vec3 radii = vec3(6378137.0, 6378137.0, 6356752.314245);\\r\\n//    vec3 inverseRadii = vec3(1.0 / radii.x, 1.0 / radii.y, 1.0 / radii.z);\\r\\n//    vec3 inverseRadiiSquared = inverseRadii * inverseRadii;\\r\\n//    czm_ellipsoid temp = czm_ellipsoid(viewMatrix[3].xyz, radii, inverseRadii, inverseRadiiSquared);\\r\\n//    return temp;\\r\\n//}\\r\\nfloat czm_fade(float cameraDist, float fadeInDist,float fadeOutDist){\\r\\n    float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);\\r\\n    return fade;\\r\\n}\\r\\nAtmosphereColor computeGroundAtmosphereFromSpace(vec3 v3Pos, bool useSunLighting){\\r\\n        //float PI = 3.14159265;\\r\\n    \\t//float g2 =  g * g;\\r\\n\\r\\n    \\tvec3 v3InvWavelength = vec3(1.0 / pow(0.650, 4.0), 1.0 / pow(0.570, 4.0), 1.0 / pow(0.475, 4.0));\\r\\n\\r\\n    \\tvec3 v3CameraPos =  vec3(0.0, 0.0, 0.0);\\r\\n    \\tv3CameraPos = cameraPosition;\\r\\n\\r\\n    \\t// vec3 v3LightPos = v3LightPosInput / length(v3LightPosInput);\\r\\n        vec3 v3LightPos = v3LightPosInput;\\r\\n\\r\\n    \\tfloat fCameraHeight = length(v3CameraPos);\\r\\n\\r\\n    \\tfloat fCameraHeight2 = fCameraHeight * fCameraHeight;\\r\\n\\r\\n            \\tfloat inOutFactor = 1.05;\\r\\n            \\tfloat fInnerRadius2 = fInnerRadius * fInnerRadius;\\r\\n            \\tfloat fOuterRadius2 = fOuterRadius * fOuterRadius;\\r\\n\\r\\n            \\tfloat fKrESun = Kr * ESun;\\r\\n            \\tfloat fKmESun = Km * ESun;\\r\\n            \\tfloat fKr4PI = Kr * 4.0 * PI;\\r\\n            \\tfloat fKm4PI = Km * 4.0 * PI;\\r\\n\\r\\n            \\tfloat fInvScaleDepth = 1.0 / fScaleDepth;\\r\\n            \\tfloat fScale = 1.0 / (fOuterRadius - fInnerRadius);\\r\\n            \\tfloat fScaleOverScaleDepth = fScale / fScaleDepth;\\r\\n\\r\\n            \\t////////////////////////////////////////////////\\r\\n            \\t// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\\r\\n//            \\tvec3 v3Pos = PositionWS;\\r\\n            \\tvec3 v3Ray = v3Pos - v3CameraPos;\\r\\n            \\tv3Pos = normalize(v3Pos);\\r\\n            \\tfloat fFar = length(v3Ray);\\r\\n            \\tv3Ray /= fFar;\\r\\n            \\t// Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\\r\\n            \\tfloat fNear = getNearIntersection(v3CameraPos, v3Ray, fCameraHeight2, fOuterRadius2);\\r\\n            \\t// Calculate the ray\'s starting position, then calculate its scattering offset\\r\\n            \\tvec3 v3Start = v3CameraPos + v3Ray * fNear;\\r\\n            \\tfFar -= fNear;\\r\\n            \\tfloat fDepth = exp((fInnerRadius - fOuterRadius) * fInvScaleDepth);\\r\\n\\r\\n\\r\\n            \\t//changed by zhgu if you donnot want night make it 1.0\\r\\n            \\tfloat fLightAngle = useSunLighting ? dot(v3LightPos, v3Pos)/length(v3Pos) : 1.0;\\r\\n            \\tfloat fCameraAngle = dot(-v3Ray, v3Pos)/length(v3Pos);\\r\\n            \\t//float fLightAngle = dot(v3LightPos, v3Pos);\\r\\n            \\tfloat fCameraScale = scale(fCameraAngle, fScaleDepth);\\r\\n            \\tfloat fLightScale = scale(fLightAngle, fScaleDepth);\\r\\n            \\tfloat fCameraOffset = fDepth*fCameraScale;\\r\\n            \\tfloat fTemp = (fLightScale + fCameraScale);\\r\\n            \\t// Initialize the scattering loop variables\\r\\n            \\t//gl_FrontColor = vec4(0.0, 0.0, 0.0, 0.0);\\r\\n            \\tfloat fSampleLength = fFar / fSamples;\\r\\n            \\tfloat fScaledLength = fSampleLength * fScale;\\r\\n            \\tvec3 v3SampleRay = v3Ray * fSampleLength;\\r\\n            \\tvec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\\r\\n            \\t// Now loop through the sample rays\\r\\n            \\tvec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\\r\\n            \\tvec3 v3Attenuate = vec3(0.0,0.0,0.0);\\r\\n            \\tfor(int i=0; i<2; i++)\\r\\n            \\t{\\r\\n            \\t  float fHeight = length(v3SamplePoint);\\r\\n            \\t  float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\\r\\n            \\t  float fScatter = fDepth*fTemp - fCameraOffset;\\r\\n            \\t  v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\\r\\n            \\t  v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\\r\\n            \\t  v3SamplePoint += v3SampleRay;\\r\\n            \\t}\\r\\n            \\tAtmosphereColor color;\\r\\n            \\tcolor.mie = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\\r\\n            \\tcolor.rayleigh = v3Attenuate;\\r\\n            \\treturn color;\\r\\n\\r\\n}\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor) {\\r\\n    float scalar = distanceToCamera * czm_fogDensity;\\r\\n    float fog = 1.0 - exp(-(scalar * scalar));\\r\\n    return mix(color, fogColor, fog);\\r\\n}\\r\\nvec3 czm_fog(float distanceToCamera, vec3 color, vec3 fogColor, float fogModifierConstant) {\\r\\n    float scalar = distanceToCamera * czm_fogDensity;\\r\\n    float fog = 1.0 - exp(-((fogModifierConstant * scalar + fogModifierConstant) * (scalar * (1.0 + fogModifierConstant))));\\r\\n    return mix(color, fogColor, fog);\\r\\n}\\r\\n\\r\\n\\r\\nfloat czm_getLambertDiffuse(vec3 lightDirectionEC, vec3 normalEC)\\r\\n{\\r\\n    return max(dot(lightDirectionEC, normalEC), 0.0);\\r\\n}\\r\\nvarying float dotValue;\\r\\nvarying vec3 sunDirectionEC;\\r\\nvarying vec3 normalEC;\\r\\nvoid main(\\t)\\r\\n{\\r\\n    #include <logdepthbuf_fragment>\\r\\n\\t//vec2 texCoords =  vec2( gl_TexCoord[0] );\\r\\n\\tvec2 webglUv = texCoords;\\r\\n//    webglUv.y =1.0 - webglUv.y;\\r\\n    webglUv = clamp(webglUv , 0.0, 1.0);\\r\\n\\tvec4 lastColor = sampleAndBlend(isAddEffect0,earthColor0,earthAddColor0,u_initialColor,TexSampler0,webglUv,textureRectangle0,textureTransAndScale0,alphaIndex0,brightness0,south1,north1,southMercatorY1,oneOverMercatorHeight1,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect1,earthColor1,earthAddColor1,lastColor,TexSampler1,webglUv,textureRectangle1,textureTransAndScale1,alphaIndex1,brightness1,south2,north2,southMercatorY2,oneOverMercatorHeight2,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect2,earthColor2,earthAddColor2,lastColor,TexSampler2,webglUv,textureRectangle2,textureTransAndScale2,alphaIndex2,brightness2,south3,north3,southMercatorY3,oneOverMercatorHeight3,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect3,earthColor3,earthAddColor3,lastColor,TexSampler3,webglUv,textureRectangle3,textureTransAndScale3,alphaIndex3,brightness3,south4,north4,southMercatorY4,oneOverMercatorHeight4,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect4,earthColor4,earthAddColor4,lastColor,TexSampler4,webglUv,textureRectangle4,textureTransAndScale4,alphaIndex4,brightness4,south5,north5,southMercatorY5,oneOverMercatorHeight5,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect5,earthColor5,earthAddColor5,lastColor,TexSampler5,webglUv,textureRectangle5,textureTransAndScale5,alphaIndex5,brightness5,south6,north6,southMercatorY6,oneOverMercatorHeight6,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n   \\tlastColor = sampleAndBlend(isAddEffect6,earthColor6,earthAddColor6,lastColor,TexSampler6,webglUv,textureRectangle6,textureTransAndScale6,alphaIndex6,brightness6,south7,north7,southMercatorY7,oneOverMercatorHeight7,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect7,earthColor7,earthAddColor7,lastColor,TexSampler7,webglUv,textureRectangle7,textureTransAndScale7,alphaIndex7,brightness7,south8,north8,southMercatorY8,oneOverMercatorHeight8,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\tlastColor = sampleAndBlend(isAddEffect8,earthColor8,earthAddColor8,lastColor,TexSampler8,webglUv,textureRectangle8,textureTransAndScale8,alphaIndex8,brightness8,south9,north9,southMercatorY9,oneOverMercatorHeight9,isReProjection,alphaValue,contrast,hue,saturation,textureGamma);\\r\\n\\r\\n    //added fade by zhgu to caculate fog\\r\\n            //float cameraDist = length(viewMatrix[3]);\\r\\n            float cameraDist = length(cameraPosition);\\r\\n        \\tfloat fade = czm_fade(cameraDist, fadeInDist, fadeOutDist);\\r\\n\\r\\n            //added lambertDiffuse TODO is it effective? 这个很一般，先忽略吧，毕竟咱们性能不太好啊\\r\\n            //float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_sunDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);\\r\\n            //diffuseIntensity = mix(1.0, diffuseIntensity, fade);\\r\\n            //vec4 finalColor = vec4(color.rgb * diffuseIntensity, color.a);\\r\\n            vec4 finalColor = lastColor;\\r\\n            //added fogColor and hdr\\r\\n            //added fogColor and hdr\\r\\n                     AtmosphereColor atmosFogColor = computeGroundAtmosphereFromSpace(PositionWS, false);\\r\\n                     vec3 c0 = atmosFogColor.mie;\\r\\n                     vec3 c1 = atmosFogColor.rayleigh;\\r\\n                    vec3 fogColor1 = c0 + finalColor.rgb * c1;\\r\\n                    //we should use hdr\\r\\n                    const float fExposure = 2.0;\\r\\n                    fogColor1 = vec3(1.0) - exp(-fExposure * fogColor1);\\r\\n\\r\\n                    //fog added\\r\\n                    //const float modifier = 0.15;\\r\\n                     finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor1), finalColor.a);\\r\\n\\r\\n            // ---------------------------------------------------------------------------\\r\\n            //ground\\r\\n            //SUN 这个sun的计算处理了下，我们不能和cesium用一样的参数，这样可能无法模拟真实太阳的位置\\r\\n            // changed by ztf 此处太阳光照计算废弃\\r\\n            // vec3 groundAtmosphereColor = vec3(0.0);\\r\\n            // if(night == 1.0){\\r\\n            //         AtmosphereColor atmosColor = computeGroundAtmosphereFromSpace(PositionWS, true);\\r\\n            //         groundAtmosphereColor = atmosColor.mie + finalColor.rgb * atmosColor.rayleigh;\\r\\n            //         groundAtmosphereColor = vec3(1.0) - exp(-fExposure * groundAtmosphereColor);\\r\\n            //         //TODO 这个可能要弱一点才行\\r\\n            //         float sunlitAtmosphereIntensity = clamp((cameraDist - nightfadeOut) / (nightfadeIn - nightfadeOut), 0.0, 1.0);//caculate sun\\r\\n            //         // used hdr to make HDR look better\\r\\n            //         sunlitAtmosphereIntensity = max(sunlitAtmosphereIntensity * sunlitAtmosphereIntensity, 0.03);\\r\\n            //         //mix sun\\r\\n            //         groundAtmosphereColor = mix(groundAtmosphereColor, fogColor1, sunlitAtmosphereIntensity);\\r\\n            // }\\r\\n            // else{\\r\\n            //         groundAtmosphereColor = fogColor1;\\r\\n            // }\\r\\n            vec3 groundAtmosphereColor = fogColor1;\\r\\n            // ---------------------------------------------------------------------------\\r\\n            //use saturation to look better\\r\\n            groundAtmosphereColor = czm_saturation(groundAtmosphereColor, 1.6);\\r\\n            //mix\\r\\n            finalColor = vec4(mix(finalColor.rgb, groundAtmosphereColor, fade), finalColor.a);\\r\\n            finalColor.rgb *= vec3(earthColor0.a);\\r\\n            //finally you get the color\\r\\n             if(grayFilterIndex==-1.0){\\r\\n                finalColor = czm_FilterColor(finalColor);\\r\\n             }\\r\\n             gl_FragColor = finalColor;\\r\\n            //now we get the shadow\\r\\n//             gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), (1.0-getShadowMask()));\\r\\n        vec4 shadow = vec4(vec3(0.0), shadowOpacity * ( 1.0 - getShadowMask() ) );\\r\\n         gl_FragColor.rgb = mix(gl_FragColor.rgb, shadow.rgb, shadow.a);\\r\\n         \\r\\n    // 昼夜和线性颜色叠加 互斥 开启\\r\\n    if(night == 1.0){\\r\\n\\r\\n        float diffuseIntensity = czm_getLambertDiffuse(sunDirectionEC, normalize(normalEC)) * 0.9 + 0.2;\\r\\n        gl_FragColor = vec4(gl_FragColor.rgb * diffuseIntensity, gl_FragColor.a);\\r\\n\\r\\n    }else {\\r\\n\\r\\n        // // 是否开启颜色叠加 0 关闭 1 开启\\r\\n        // uniform float gradientColorOverlayEnable;\\r\\n        // // 颜色叠加方向\\r\\n        // uniform vec3 mapDirection;\\r\\n        // // 叠加使用的渐变纹理\\r\\n        // uniform sampler2D gradientColorMap;\\r\\n\\r\\n        if(gradientColorOverlayEnable == 1.0){\\r\\n\\r\\n            float diffuseIntensity = dot(mapDirection, normalize(normalEC));\\r\\n            float uv_U = (diffuseIntensity + 1.0) / 2.0;// -1 ——> 1 映射到 0 —— 1\\r\\n            float uv_V = 0.1;\\r\\n\\r\\n            vec4 gradientColor = texture2D(gradientColorMap, vec2(uv_U, uv_V));\\r\\n\\r\\n            float tempR = gradientColor.r + (1.0 - gradientColor.r) * (1.0 - gradientOpacity);\\r\\n            float tempG = gradientColor.g + (1.0 - gradientColor.g) * (1.0 - gradientOpacity);\\r\\n            float tempB = gradientColor.b + (1.0 - gradientColor.b) * (1.0 - gradientOpacity);\\r\\n\\r\\n            gl_FragColor = vec4(gl_FragColor.rgb * vec3(tempR,tempG,tempB), gl_FragColor.a);\\r\\n\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n        #include <fog_fragment>\\r\\n}\\r\\n\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/mult_texture9.glsl?')
        },
        "./src/material/shaders/projector_fragment.glsl": /*!******************************************************!*\
  !*** ./src/material/shaders/projector_fragment.glsl ***!
  \******************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "//uniform vec3 baseColor;\\r\\nuniform vec3 frustum[5];//the projector source device\\r\\nuniform sampler2D videoTexture;\\r\\nvarying vec4 vWorldPos;\\r\\nvarying vec3 vWorldnormal;\\r\\n//uniform vec3 axis;\\r\\nuniform float frustPlane;\\r\\n\\r\\n// get the idea from vector3\\r\\n// port from https://github.com/mrdoob/three.js/blob/35ae830a7c4544582ed2759e5b18c5d6ef37c6d9/src/math/Vector3.js#L559\\r\\n vec3 projectOnVector(vec3 a, vec3 b){\\r\\n    float dist = length(b);\\r\\n    return b * ( dot(a, b) / (dist * dist) );\\r\\n  }\\r\\n\\r\\n\\r\\n    void main() {\\r\\n    \\tvec3 dir = vWorldPos.xyz - frustum[0];\\r\\n    \\t//if(dir.z > 0.0) discard;\\r\\n      \\t//use normal to discard\\r\\n      \\tfloat f = dot(-dir, vWorldnormal);\\r\\n      \\t//float f1 = dot(-axis, vWorldnormal);\\r\\n      \\tfloat disToPlane = frustPlane - length(dir);\\r\\n      \\t//default set 0.001\\r\\n      \\tfloat precisionDis = 0.001;\\r\\n      \\tif(f<=precisionDis  || disToPlane < -precisionDis) discard;\\r\\n        vec3 center = (frustum[1] + frustum[2] + frustum[3] + frustum[4]) * 0.25;\\r\\n        vec3 frustumAxis = center - frustum[0];\\r\\n        float f1 = dot(-frustumAxis, vWorldnormal);\\r\\n        if(f1<=precisionDis) discard;\\r\\n        vec3 projected = projectOnVector(dir, frustumAxis);\\r\\n        float scalar = length(frustumAxis) / length(projected);\\r\\n        vec3 planeProj = ( dir * scalar ) + frustum[0];\\r\\n\\r\\n        // get the UVs\\r\\n        vec3 uvBase = planeProj - frustum[1]; // from top-left corner\\r\\n\\r\\n        vec3 sub12 = frustum[2] - frustum[1];\\r\\n        vec3 sub12uv = projectOnVector(uvBase, sub12);\\r\\n        float u = length(sub12uv) * sign(dot(sub12, sub12uv)) / length(sub12);\\r\\n        vec3 sub13 = frustum[3] - frustum[1];\\r\\n        vec3 sub13uv = projectOnVector(uvBase, sub13);\\r\\n        float v = length(sub13uv) * sign(dot(sub13, sub13uv)) / length(sub13);\\r\\n        v = 1. - v;\\r\\n\\r\\n        // antilias\\r\\n        if (max( u,v ) <= 1. && min( u, v ) >= 0.){\\r\\n        // default edge\\r\\n        float r = 0.005;\\r\\n        float a = abs(u - 0.5) - (0.5 - r);\\r\\n        float b = abs(v - 0.5) - (0.5 - r);\\r\\n        // it must be small if you donnot want to see the hackly texture\\r\\n        float sum = 0.0000000000001;\\r\\n        float count = 0.0;\\r\\n        sum += a * a * a * (sign(a) + 1.0);\\r\\n        count += 1.0 * a * a* (sign(a) + 1.0) ;\\r\\n        sum += b * b * b * (sign(b) + 1.0);\\r\\n        count += 1.0 * b * b * (sign(b) + 1.0);\\r\\n        gl_FragColor = texture2D(videoTexture, vec2(u, v));\\r\\n        gl_FragColor.a = sum / count <= 1.0 ? (r - sum / count)/r :1.0;\\r\\n            }\\r\\n        else{\\r\\n             discard;\\r\\n        }\\r\\n    }\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/projector_fragment.glsl?')
        },
        "./src/material/shaders/projector_vertex.glsl": /*!****************************************************!*\
  !*** ./src/material/shaders/projector_vertex.glsl ***!
  \****************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = " //caculate worldPos and worldnormal to discard and get the projector uvs\\r\\n varying vec4 vWorldPos;\\r\\n varying vec3 vWorldnormal;\\r\\n\\r\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\r\\n return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\r\\n}\\r\\nvoid main() {\\r\\n  vWorldPos = modelMatrix * vec4(position, 1.0);\\r\\n  vec3 transformedNormal = normalMatrix * normal;\\r\\n  vWorldnormal = inverseTransformDirection( transformedNormal, viewMatrix );\\r\\n  //gl_Position = projectionMatrix * viewMatrix * vWorldPos;\\r\\n   vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\r\\n       gl_Position = projectionMatrix * mvPosition;\\r\\n}\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/projector_vertex.glsl?')
        },
        "./src/material/shaders/scanning1_fragment.glsl": /*!******************************************************!*\
  !*** ./src/material/shaders/scanning1_fragment.glsl ***!
  \******************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "      uniform vec3 color;\\r\\n\\r\\n      uniform vec3 maxPos;\\r\\n      uniform vec3 minPos;\\r\\n\\r\\n      varying vec4 v_position;\\r\\n\\r\\n      #ifdef USE_UVMAP\\r\\n        uniform sampler2D uvMap;\\r\\n      #endif\\r\\n\\r\\n      uniform vec3 direction;\\r\\n\\r\\n    #include <logdepthbuf_pars_fragment>\\r\\n\\r\\n\\r\\n      bool isMax(vec3 a, vec3 b){\\r\\n        \\r\\n         float ax = a.x;\\r\\n         float ay = a.y;\\r\\n         float az = a.z;\\r\\n\\r\\n         float bx = b.x;\\r\\n         float by = b.y;\\r\\n         float bz = b.z;\\r\\n\\r\\n         return ax > bx && ay > by && az > bz;\\r\\n     }\\r\\n\\r\\n\\r\\n      bool isMin(vec3 a, vec3 b){\\r\\n        \\r\\n         float ax = a.x;\\r\\n         float ay = a.y;\\r\\n         float az = a.z;\\r\\n\\r\\n         float bx = b.x;\\r\\n         float by = b.y;\\r\\n         float bz = b.z;\\r\\n\\r\\n         return ax < bx && ay < by && az < bz;\\r\\n     }\\r\\n\\r\\n\\r\\n      void main() {\\r\\n      #include <logdepthbuf_fragment>\\r\\n//        vec3 dir = normalize(direction);\\r\\n//\\r\\n//        float subb = length((maxPos - minPos)*dir);\\r\\n//        float gap = length((v_position.xyz - minPos)*dir);\\r\\n        float subb = length(maxPos.z - minPos.z);\\r\\n        float gap = length(v_position.z - minPos.z);\\r\\n\\r\\n        vec2 texCoord = vec2((gap / subb), 0.5);\\r\\n        gl_FragColor = mix(vec4(0,0,0,0),vec4(color, 1.0),float(isMin(v_position.xyz,maxPos) && isMax(v_position.xyz,minPos)));\\r\\n\\r\\n        #ifdef USE_UVMAP\\r\\n           gl_FragColor.a *= texture2D( uvMap, texCoord ).r;\\r\\n        #endif\\r\\n        \\r\\n\\r\\n      }"\n\n//# sourceURL=webpack:///./src/material/shaders/scanning1_fragment.glsl?')
        },
        "./src/material/shaders/scanning1_vertex.glsl": /*!****************************************************!*\
  !*** ./src/material/shaders/scanning1_vertex.glsl ***!
  \****************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "varying vec4 v_position;\\r\\nuniform vec3 center;\\r\\n#include <common>\\r\\n#include <logdepthbuf_pars_vertex>\\r\\n#ifdef USE_RELATIVE\\r\\nuniform mat4 relativeModelMatrix;\\r\\n#endif\\r\\n\\r\\n        void main() {\\r\\n\\r\\n        vec4 pos = vec4(position, 1.0);\\r\\n\\r\\n        gl_Position = projectionMatrix * modelViewMatrix * pos;\\r\\n        #include <logdepthbuf_vertex>\\r\\n\\r\\n       #ifdef USE_RELATIVE\\r\\n        v_position = relativeModelMatrix * pos;\\r\\n        #else\\r\\n         v_position = pos;\\r\\n        #endif\\r\\n\\r\\n      }"\n\n//# sourceURL=webpack:///./src/material/shaders/scanning1_vertex.glsl?')
        },
        "./src/material/shaders/scanningCity_vertex.glsl": /*!*******************************************************!*\
  !*** ./src/material/shaders/scanningCity_vertex.glsl ***!
  \*******************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "#include <common>\\r\\n#include <logdepthbuf_pars_vertex>\\r\\nvarying vec2 vp;\\r\\n#ifdef USE_MAP\\r\\nuniform mat3 uvTransform;\\r\\n#endif\\r\\nattribute vec2 coordinates;\\r\\n\\r\\nvoid main() {\\r\\n        vec4 pos = vec4(position, 1.0);\\r\\n         #ifdef USE_MAP\\r\\n          vec2 vUv = ( uvTransform * vec3( coordinates, 1 ) ).xy;\\r\\n          vp = vUv;\\r\\n         #else\\r\\n          vp = coordinates;\\r\\n         #endif\\r\\n        gl_Position = projectionMatrix * modelViewMatrix * pos;\\r\\n         #include <logdepthbuf_vertex>\\r\\n\\r\\n}\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/scanningCity_vertex.glsl?')
        },
        "./src/material/shaders/scanning_fragment.glsl": /*!*****************************************************!*\
  !*** ./src/material/shaders/scanning_fragment.glsl ***!
  \*****************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "      uniform vec3 color;\\r\\n\\r\\n      uniform vec3 maxPos;\\r\\n      uniform vec3 minPos;\\r\\n\\r\\n      varying vec4 v_position;\\r\\n\\r\\n      #ifdef USE_UVMAP\\r\\n        uniform sampler2D uvMap;\\r\\n      #endif\\r\\n\\r\\n      float gap;\\r\\n\\r\\n      bool isMax(vec3 a, vec3 b){\\r\\n        \\r\\n         float ax = a.x;\\r\\n         float ay = a.y;\\r\\n         float az = a.y;\\r\\n\\r\\n         float bx = b.x;\\r\\n         float by = b.y;\\r\\n         float bz = b.z;\\r\\n\\r\\n         return ax > bx && ay > by && az > bz;\\r\\n     }\\r\\n\\r\\n\\r\\n      bool isMin(vec3 a, vec3 b){\\r\\n        \\r\\n         float ax = a.x;\\r\\n         float ay = a.y;\\r\\n         float az = a.y;\\r\\n\\r\\n         float bx = b.x;\\r\\n         float by = b.y;\\r\\n         float bz = b.z;\\r\\n\\r\\n         return ax < bx && ay < by && az < bz;\\r\\n     }\\r\\n\\r\\n\\r\\n      void main() {\\r\\n\\r\\n        float subb = maxPos.x - v_position.x;\\r\\n        gap = abs(maxPos.x - minPos.x);\\r\\n        vec2 texCoord = vec2((1.0 - (subb / gap)), 0.5);\\r\\n        gl_FragColor = mix(vec4(0,0,0,0),vec4(color, (1.0 - (subb / gap))),float(isMin(v_position.xyz,maxPos) && isMax(v_position.xyz,minPos)));\\r\\n\\r\\n        #ifdef USE_UVMAP\\r\\n           gl_FragColor.a = texture2D( uvMap, texCoord ).r;\\r\\n        #endif\\r\\n        \\r\\n\\r\\n      }"\n\n//# sourceURL=webpack:///./src/material/shaders/scanning_fragment.glsl?')
        },
        "./src/material/shaders/scanning_vertex.glsl": /*!***************************************************!*\
  !*** ./src/material/shaders/scanning_vertex.glsl ***!
  \***************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "varying vec4 v_position;\\r\\nuniform vec3 center;\\r\\n#ifdef USE_RELATIVE\\r\\nuniform mat4 relativeModelMatrix;\\r\\n#endif\\r\\n\\r\\n        void main() {\\r\\n\\r\\n        vec4 pos = vec4(position, 1.0);\\r\\n\\r\\n        gl_Position = projectionMatrix * modelViewMatrix * pos;\\r\\n\\r\\n       #ifdef USE_RELATIVE\\r\\n        v_position = relativeModelMatrix * pos;\\r\\n        #else\\r\\n         v_position = pos;\\r\\n        #endif\\r\\n\\r\\n      }"\n\n//# sourceURL=webpack:///./src/material/shaders/scanning_vertex.glsl?')
        },
        "./src/material/shaders/scannningCity_fragment.glsl": /*!**********************************************************!*\
  !*** ./src/material/shaders/scannningCity_fragment.glsl ***!
  \**********************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "\\r\\n                varying vec2 vp;\\r\\n                uniform vec3 scanningColor;\\r\\n                #ifdef USE_MAP\\r\\n                     uniform sampler2D map;\\r\\n                #endif\\r\\n                    uniform vec2 center;\\r\\n                    uniform float u_r;\\r\\n                    uniform float u_length;\\r\\n                #include <logdepthbuf_pars_fragment>\\r\\n                float getLeng(float x, float y, vec2 center){\\r\\n                    return  sqrt((x-center.x)*(x-center.x)+(y-center.y)*(y-center.y));\\r\\n                }\\r\\n                void main(){\\r\\n                #include <logdepthbuf_fragment>\\r\\n                #ifdef USE_MAP\\r\\n                        float r = texture2D(map, vp).r;\\r\\n                         gl_FragColor = r * vec4(scanningColor, 1.0);\\r\\n                 #else\\r\\n                        float uOpacity = 0.3;\\r\\n                        vec3 vColor = vec3(0.0) ;\\r\\n                        float uLength = getLeng(vp.x,vp.y, center);\\r\\n                        if ( uLength <= u_r && uLength > u_r - u_length) {\\r\\n                            float op = sin( (u_r - uLength) / u_length ) * 0.6 + 0.3 ;\\r\\n                             uOpacity = op;\\r\\n                             gl_FragColor = vec4(scanningColor,uOpacity);\\r\\n                        }\\r\\n                        else{\\r\\n                            discard;\\r\\n                        }\\r\\n                 #endif\\r\\n                }\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/scannningCity_fragment.glsl?')
        },
        "./src/material/shaders/shadow_pcss.glsl": /*!***********************************************!*\
  !*** ./src/material/shaders/shadow_pcss.glsl ***!
  \***********************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "\\r\\n\\r\\n                #define LIGHT_WORLD_SIZE 0.005\\r\\n\\t\\t\\t\\t#define LIGHT_FRUSTUM_WIDTH 3.75\\r\\n\\t\\t\\t\\t#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\\r\\n\\t\\t\\t\\t#define NEAR_PLANE 9.5\\r\\n\\r\\n\\t\\t\\t\\t#define NUM_SAMPLES 17\\r\\n\\t\\t\\t\\t#define NUM_RINGS 11\\r\\n\\t\\t\\t\\t#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\\r\\n\\t\\t\\t\\t#define PCF_NUM_SAMPLES NUM_SAMPLES\\r\\n\\r\\n\\t\\t\\t\\tvec2 poissonDisk[NUM_SAMPLES];\\r\\n\\r\\n\\t\\t\\t\\tvoid initPoissonSamples( const in vec2 randomSeed ) {\\r\\n\\t\\t\\t\\t\\tfloat ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\\r\\n\\t\\t\\t\\t\\tfloat INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\\r\\n\\r\\n\\t\\t\\t\\t\\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\\r\\n\\t\\t\\t\\t\\tfloat angle = rand( randomSeed ) * PI2;\\r\\n\\t\\t\\t\\t\\tfloat radius = INV_NUM_SAMPLES;\\r\\n\\t\\t\\t\\t\\tfloat radiusStep = radius;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\\r\\n\\t\\t\\t\\t\\t\\tpoissonDisk[i] = vec2( cos( angle ), sin( angle ) ) * pow( radius, 0.75 );\\r\\n\\t\\t\\t\\t\\t\\tradius += radiusStep;\\r\\n\\t\\t\\t\\t\\t\\tangle += ANGLE_STEP;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tfloat penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\\r\\n\\t\\t\\t\\t\\treturn (zReceiver - zBlocker) / zBlocker;\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tfloat findBlocker( sampler2D shadowMap, const in vec2 uv, const in float zReceiver ) {\\r\\n\\t\\t\\t\\t\\t// This uses similar triangles to compute what\\r\\n\\t\\t\\t\\t\\t// area of the shadow map we should search\\r\\n\\t\\t\\t\\t\\tfloat searchRadius = LIGHT_SIZE_UV * ( zReceiver - NEAR_PLANE ) / zReceiver;\\r\\n\\t\\t\\t\\t\\tfloat blockerDepthSum = 0.0;\\r\\n\\t\\t\\t\\t\\tint numBlockers = 0;\\r\\n\\r\\n\\t\\t\\t\\t\\tfor( int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++ ) {\\r\\n\\t\\t\\t\\t\\t\\tfloat shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\\r\\n\\t\\t\\t\\t\\t\\tif ( shadowMapDepth < zReceiver ) {\\r\\n\\t\\t\\t\\t\\t\\t\\tblockerDepthSum += shadowMapDepth;\\r\\n\\t\\t\\t\\t\\t\\t\\tnumBlockers ++;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\t\\tif( numBlockers == 0 ) return -1.0;\\r\\n\\r\\n\\t\\t\\t\\t\\treturn blockerDepthSum / float( numBlockers );\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius ) {\\r\\n\\t\\t\\t\\t\\tfloat sum = 0.0;\\r\\n\\t\\t\\t\\t\\tfor( int i = 0; i < PCF_NUM_SAMPLES; i ++ ) {\\r\\n\\t\\t\\t\\t\\t\\tfloat depth = unpackRGBAToDepth( texture2D( shadowMap, uv + poissonDisk[ i ] * filterRadius ) );\\r\\n\\t\\t\\t\\t\\t\\tif( zReceiver <= depth ) sum += 1.0;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\tfor( int i = 0; i < PCF_NUM_SAMPLES; i ++ ) {\\r\\n\\t\\t\\t\\t\\t\\tfloat depth = unpackRGBAToDepth( texture2D( shadowMap, uv + -poissonDisk[ i ].yx * filterRadius ) );\\r\\n\\t\\t\\t\\t\\t\\tif( zReceiver <= depth ) sum += 1.0;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\treturn sum / ( 2.0 * float( PCF_NUM_SAMPLES ) );\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tfloat PCSS ( sampler2D shadowMap, vec4 coords ) {\\r\\n\\t\\t\\t\\t\\tvec2 uv = coords.xy;\\r\\n\\t\\t\\t\\t\\tfloat zReceiver = coords.z; // Assumed to be eye-space z in this code\\r\\n\\r\\n\\t\\t\\t\\t\\tinitPoissonSamples( uv );\\r\\n\\t\\t\\t\\t\\t// STEP 1: blocker search\\r\\n\\t\\t\\t\\t\\tfloat avgBlockerDepth = findBlocker( shadowMap, uv, zReceiver );\\r\\n\\r\\n\\t\\t\\t\\t\\t//There are no occluders so early out (this saves filtering)\\r\\n\\t\\t\\t\\t\\tif( avgBlockerDepth == -1.0 ) return 1.0;\\r\\n\\r\\n\\t\\t\\t\\t\\t// STEP 2: penumbra size\\r\\n\\t\\t\\t\\t\\tfloat penumbraRatio = penumbraSize( zReceiver, avgBlockerDepth );\\r\\n\\t\\t\\t\\t\\tfloat filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\\r\\n\\r\\n\\t\\t\\t\\t\\t// STEP 3: filtering\\r\\n\\t\\t\\t\\t\\t//return avgBlockerDepth;\\r\\n\\t\\t\\t\\t\\treturn PCF_Filter( shadowMap, uv, zReceiver, filterRadius );\\r\\n\\t\\t\\t\\t}"\n\n//# sourceURL=webpack:///./src/material/shaders/shadow_pcss.glsl?')
        },
        "./src/material/shaders/shadow_pcss_getShadow.glsl": /*!*********************************************************!*\
  !*** ./src/material/shaders/shadow_pcss_getShadow.glsl ***!
  \*********************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "\\r\\n\\r\\nreturn PCSS( shadowMap, shadowCoord );\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/shadow_pcss_getShadow.glsl?')
        },
        "./src/material/shaders/skinning_pars_vertex.glsl": /*!********************************************************!*\
  !*** ./src/material/shaders/skinning_pars_vertex.glsl ***!
  \********************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "#ifdef USE_SKINNING\\r\\n\\r\\n\\tuniform mat4 bindMatrix;\\r\\n\\tuniform mat4 bindMatrixInverse;\\r\\n\\tuniform mat4 localBindMatrixInverse;\\r\\n//\\tuniform vec3 _worldPosition;\\r\\n\\r\\n\\t#ifdef BONE_TEXTURE\\r\\n\\r\\n\\t\\tuniform sampler2D boneTexture;\\r\\n\\t\\tuniform int boneTextureSize;\\r\\n\\r\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\r\\n\\r\\n\\t\\t\\tfloat j = i * 4.0;\\r\\n\\t\\t\\tfloat x = mod( j, float( boneTextureSize ) );\\r\\n\\t\\t\\tfloat y = floor( j / float( boneTextureSize ) );\\r\\n\\r\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureSize );\\r\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureSize );\\r\\n\\r\\n\\t\\t\\ty = dy * ( y + 0.5 );\\r\\n\\r\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\r\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\r\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\r\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\r\\n\\r\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\r\\n\\r\\n\\t\\t\\treturn bone;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t#else\\r\\n\\r\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\r\\n\\r\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\r\\n\\r\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\r\\n\\t\\t\\treturn bone;\\r\\n\\r\\n\\t\\t}\\r\\n\\r\\n\\t#endif\\r\\n\\r\\n#endif"\n\n//# sourceURL=webpack:///./src/material/shaders/skinning_pars_vertex.glsl?')
        },
        "./src/material/shaders/skinning_vertex.glsl": /*!***************************************************!*\
  !*** ./src/material/shaders/skinning_vertex.glsl ***!
  \***************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "#ifdef USE_SKINNING\\r\\n\\r\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\r\\n\\r\\n\\tvec4 skinned = vec4( 0.0 );\\r\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\r\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\r\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\r\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\r\\n\\r\\n\\ttransformed = ( localBindMatrixInverse * skinned ).xyz;\\r\\n\\r\\n#endif"\n\n//# sourceURL=webpack:///./src/material/shaders/skinning_vertex.glsl?')
        },
        "./src/material/shaders/standardScanning_fragment.glsl": /*!*************************************************************!*\
  !*** ./src/material/shaders/standardScanning_fragment.glsl ***!
  \*************************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "#define STANDARD\\r\\n\\r\\n#ifdef PHYSICAL\\r\\n\\t#define REFLECTIVITY\\r\\n\\t#define CLEARCOAT\\r\\n\\t#define TRANSPARENCY\\r\\n#endif\\r\\n\\r\\nuniform vec3 diffuse;\\r\\nuniform vec3 emissive;\\r\\nuniform float roughness;\\r\\nuniform float metalness;\\r\\nuniform float opacity;\\r\\n\\r\\n#ifdef TRANSPARENCY\\r\\n\\tuniform float transparency;\\r\\n#endif\\r\\n\\r\\n#ifdef REFLECTIVITY\\r\\n\\tuniform float reflectivity;\\r\\n#endif\\r\\n\\r\\n#ifdef CLEARCOAT\\r\\n\\tuniform float clearcoat;\\r\\n\\tuniform float clearcoatRoughness;\\r\\n#endif\\r\\n\\r\\n#ifdef USE_SHEEN\\r\\n\\tuniform vec3 sheen;\\r\\n#endif\\r\\n\\r\\nvarying vec3 vViewPosition;\\r\\n\\r\\n#ifndef FLAT_SHADED\\r\\n\\r\\n\\tvarying vec3 vNormal;\\r\\n\\r\\n\\t#ifdef USE_TANGENT\\r\\n\\r\\n\\t\\tvarying vec3 vTangent;\\r\\n\\t\\tvarying vec3 vBitangent;\\r\\n\\r\\n\\t#endif\\r\\n\\r\\n#endif\\r\\n\\r\\n#include <common>\\r\\n#include <packing>\\r\\n#include <dithering_pars_fragment>\\r\\n#include <color_pars_fragment>\\r\\n#include <uv_pars_fragment>\\r\\n#include <uv2_pars_fragment>\\r\\n#include <map_pars_fragment>\\r\\n#include <alphamap_pars_fragment>\\r\\n#include <aomap_pars_fragment>\\r\\n#include <lightmap_pars_fragment>\\r\\n#include <emissivemap_pars_fragment>\\r\\n#include <bsdfs>\\r\\n#include <cube_uv_reflection_fragment>\\r\\n#include <envmap_common_pars_fragment>\\r\\n#include <envmap_physical_pars_fragment>\\r\\n#include <fog_pars_fragment>\\r\\n#include <lights_pars_begin>\\r\\n#include <lights_physical_pars_fragment>\\r\\n#include <shadowmap_pars_fragment>\\r\\n#include <bumpmap_pars_fragment>\\r\\n#include <normalmap_pars_fragment>\\r\\n#include <clearcoat_normalmap_pars_fragment>\\r\\n#include <roughnessmap_pars_fragment>\\r\\n#include <metalnessmap_pars_fragment>\\r\\n#include <logdepthbuf_pars_fragment>\\r\\n#include <clipping_planes_pars_fragment>\\r\\n//scanning相关\\r\\n\\r\\n      uniform vec3 maxPos;\\r\\n      uniform vec3 minPos;\\r\\n\\r\\n      varying vec4 v_position;\\r\\n\\r\\n      uniform float use_uvMap;\\r\\n      uniform sampler2D uvMap;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n      bool isMax(vec3 a, vec3 b){\\r\\n\\r\\n         float ax = a.x;\\r\\n         float ay = a.y;\\r\\n         float az = a.z;\\r\\n\\r\\n         float bx = b.x;\\r\\n         float by = b.y;\\r\\n         float bz = b.z;\\r\\n\\r\\n         return ax > bx && ay > by && az > bz;\\r\\n     }\\r\\n\\r\\n\\r\\n      bool isMin(vec3 a, vec3 b){\\r\\n\\r\\n         float ax = a.x;\\r\\n         float ay = a.y;\\r\\n         float az = a.z;\\r\\n\\r\\n         float bx = b.x;\\r\\n         float by = b.y;\\r\\n         float bz = b.z;\\r\\n\\r\\n         return ax < bx && ay < by && az < bz;\\r\\n     }\\r\\n\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\\t#include <clipping_planes_fragment>\\r\\n\\r\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\r\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\r\\n\\tvec3 totalEmissiveRadiance = emissive;\\r\\n\\r\\n\\t#include <logdepthbuf_fragment>\\r\\n\\t#include <map_fragment>\\r\\n\\t#include <color_fragment>\\r\\n\\t#include <alphamap_fragment>\\r\\n\\t#include <alphatest_fragment>\\r\\n\\t#include <roughnessmap_fragment>\\r\\n\\t#include <metalnessmap_fragment>\\r\\n\\t#include <normal_fragment_begin>\\r\\n\\t#include <normal_fragment_maps>\\r\\n\\t#include <clearcoat_normal_fragment_begin>\\r\\n\\t#include <clearcoat_normal_fragment_maps>\\r\\n\\t#include <emissivemap_fragment>\\r\\n\\r\\n\\t// accumulation\\r\\n\\t#include <lights_physical_fragment>\\r\\n\\t#include <lights_fragment_begin>\\r\\n\\t#include <lights_fragment_maps>\\r\\n\\t#include <lights_fragment_end>\\r\\n\\r\\n\\t// modulation\\r\\n\\t#include <aomap_fragment>\\r\\n\\r\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\r\\n\\r\\n\\t// this is a stub for the transparency model\\r\\n\\t#ifdef TRANSPARENCY\\r\\n\\t\\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\\r\\n\\t#endif\\r\\n\\r\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\r\\n\\r\\n\\t float subb = length(maxPos.z - minPos.z);\\r\\n     float gap = length(v_position.z - minPos.z);\\r\\n\\r\\n     vec2 texCoord = vec2((gap / subb), 0.5);\\r\\n      gl_FragColor = mix(vec4(0,0,0,0),gl_FragColor,float(isMin(v_position.xyz,maxPos) && isMax(v_position.xyz,minPos)));\\r\\n\\r\\n     if(use_uvMap == 1.0){\\r\\n      gl_FragColor.a *= texture2D( uvMap, texCoord ).r;\\r\\n     }\\r\\n\\r\\n\\r\\n\\r\\n\\t#include <tonemapping_fragment>\\r\\n\\t#include <encodings_fragment>\\r\\n\\t#include <fog_fragment>\\r\\n\\t#include <premultiplied_alpha_fragment>\\r\\n\\t#include <dithering_fragment>\\r\\n\\r\\n\\r\\n}"\n\n//# sourceURL=webpack:///./src/material/shaders/standardScanning_fragment.glsl?')
        },
        "./src/material/shaders/standardScanning_vertex.glsl": /*!***********************************************************!*\
  !*** ./src/material/shaders/standardScanning_vertex.glsl ***!
  \***********************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "#define STANDARD\\r\\n\\r\\nvarying vec3 vViewPosition;\\r\\n\\r\\n#ifndef FLAT_SHADED\\r\\n\\r\\n\\tvarying vec3 vNormal;\\r\\n\\r\\n\\t#ifdef USE_TANGENT\\r\\n\\r\\n\\t\\tvarying vec3 vTangent;\\r\\n\\t\\tvarying vec3 vBitangent;\\r\\n\\r\\n\\t#endif\\r\\n\\r\\n#endif\\r\\n\\r\\n#include <common>\\r\\n#include <uv_pars_vertex>\\r\\n#include <uv2_pars_vertex>\\r\\n#include <displacementmap_pars_vertex>\\r\\n#include <color_pars_vertex>\\r\\n#include <fog_pars_vertex>\\r\\n#include <morphtarget_pars_vertex>\\r\\n#include <skinning_pars_vertex>\\r\\n#include <shadowmap_pars_vertex>\\r\\n#include <logdepthbuf_pars_vertex>\\r\\n#include <clipping_planes_pars_vertex>\\r\\n\\r\\n//scanning相关，应该专门做成一个宏，目前由于时间原因先这样吧\\r\\nvarying vec4 v_position;\\r\\nuniform mat4 relativeModelMatrix;\\r\\n\\r\\nvoid main() {\\r\\n\\r\\n\\t#include <uv_vertex>\\r\\n\\t#include <uv2_vertex>\\r\\n\\t#include <color_vertex>\\r\\n\\r\\n\\t#include <beginnormal_vertex>\\r\\n\\t#include <morphnormal_vertex>\\r\\n\\t#include <skinbase_vertex>\\r\\n\\t#include <skinnormal_vertex>\\r\\n\\t#include <defaultnormal_vertex>\\r\\n\\r\\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\\r\\n\\r\\n\\tvNormal = normalize( transformedNormal );\\r\\n\\r\\n\\t#ifdef USE_TANGENT\\r\\n\\r\\n\\t\\tvTangent = normalize( transformedTangent );\\r\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\r\\n\\r\\n\\t#endif\\r\\n\\r\\n#endif\\r\\n\\r\\n\\t#include <begin_vertex>\\r\\n\\t#include <morphtarget_vertex>\\r\\n\\t#include <skinning_vertex>\\r\\n\\t#include <displacementmap_vertex>\\r\\n\\t#include <project_vertex>\\r\\n\\t#include <logdepthbuf_vertex>\\r\\n\\t#include <clipping_planes_vertex>\\r\\n\\r\\n\\tvViewPosition = - mvPosition.xyz;\\r\\n\\r\\n\\t#include <worldpos_vertex>\\r\\n\\t#include <shadowmap_vertex>\\r\\n\\t#include <fog_vertex>\\r\\n\\r\\n\\t//scanning\\r\\n    v_position = relativeModelMatrix * vec4(position, 1.0);\\r\\n\\r\\n\\r\\n}\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/standardScanning_vertex.glsl?')
        },
        "./src/material/shaders/test.glsl": /*!****************************************!*\
  !*** ./src/material/shaders/test.glsl ***!
  \****************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "varying vec2 vUv;\\r\\nuniform float alpha;\\r\\nuniform vec3 color;\\r\\nvoid main() \\r\\n{ \\r\\n    // color format: RGBA\\r\\n\\t// this example: (r,g,b,a) = (u,v,0,1)\\r\\n\\tgl_FragColor = vec4(color, alpha);\\r\\n    //gl_FragColor = vec4( vec3( vUv, 0.0 ), 1.0 )* vec4(color,1.0);\\r\\n}"\n\n//# sourceURL=webpack:///./src/material/shaders/test.glsl?')
        },
        "./src/material/shaders/test1.glsl": /*!*****************************************!*\
  !*** ./src/material/shaders/test1.glsl ***!
  \*****************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "varying vec2 vUv;\\r\\nuniform sampler2D texture1;\\r\\nuniform sampler2D texture2;\\r\\nuniform vec3 color;\\r\\nvoid main()\\r\\n{\\r\\n    // color format: RGBA\\r\\n\\t// this example: (r,g,b,a) = (u,v,0,1)\\r\\n\\r\\n    vec4 color1 = texture2D( texture1, vUv )*0.5;\\r\\n    vec4 color2 = texture2D( texture2, vUv )*0.5;\\r\\n    gl_FragColor = vec4( color1.rgb + color2.rgb, 1.0 ) * vec4(color,1.0);\\r\\n}"\n\n//# sourceURL=webpack:///./src/material/shaders/test1.glsl?')
        },
        "./src/material/shaders/testFog.glsl": /*!*******************************************!*\
  !*** ./src/material/shaders/testFog.glsl ***!
  \*******************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "varying vec2 vUv;\\r\\nuniform float cameraHeight;\\r\\nuniform float tilt;\\r\\nvoid main()\\r\\n{\\r\\n   float alpha;\\r\\n   float fogHeight = 1500000.0;\\r\\n   float fogEarthHeight = 2000000.0;\\r\\n   if(cameraHeight < fogHeight){\\r\\n    alpha = 1.0;\\r\\n   }else{\\r\\n    alpha = 1.0 - (cameraHeight - fogHeight) * (cameraHeight - fogHeight) / (fogEarthHeight * fogEarthHeight);\\r\\n   }\\r\\n\\r\\n   if(alpha < 0.0){\\r\\n    alpha == 0.0;\\r\\n   }\\r\\n   float tiltAlpha = 1.0 - tilt / 70.0;\\r\\n   if(tiltAlpha < 0.0){\\r\\n    tiltAlpha = 0.0;\\r\\n   }\\r\\n   gl_FragColor = vec4(1.0, 1.0, 1.0, vUv.y * alpha * tiltAlpha * 1.5);\\r\\n}"\n\n//# sourceURL=webpack:///./src/material/shaders/testFog.glsl?')
        },
        "./src/material/shaders/testFog_vs.glsl": /*!**********************************************!*\
  !*** ./src/material/shaders/testFog_vs.glsl ***!
  \**********************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "varying vec2 vUv;\\r\\nuniform vec3 center;\\r\\nuniform vec3 yDir;\\r\\nuniform vec3 xDir;\\r\\nuniform float distance;\\r\\nvoid main()\\r\\n{\\r\\n    vUv = uv;\\r\\n //   gl_Position = vec4( position, 1.0 );\\r\\n\\r\\n    vec3 finalPos  = vec3(position);\\r\\n\\r\\n    if(uv.x<0.5){\\r\\n        finalPos = center - distance / 1.0 * xDir;\\r\\n    }else if(uv.x>0.5){\\r\\n        finalPos = center + distance / 1.0 * xDir;\\r\\n    }\\r\\n\\r\\n    if(uv.y>0.5){\\r\\n        finalPos = finalPos + distance / 1.5 * yDir;\\r\\n    }else if(uv.y<0.5){\\r\\n        finalPos = finalPos - 0.0;\\r\\n    }\\r\\n    vec4 newPos = projectionMatrix * (modelViewMatrix  * vec4( finalPos, 1.0 ));\\r\\n\\r\\n    gl_Position = newPos;\\r\\n\\r\\n  // gl_Position = projectionMatrix * modelViewMatrix  * vec4( position, 1.0 );\\r\\n\\r\\n}"\n\n//# sourceURL=webpack:///./src/material/shaders/testFog_vs.glsl?')
        },
        "./src/material/shaders/test_vs.glsl": /*!*******************************************!*\
  !*** ./src/material/shaders/test_vs.glsl ***!
  \*******************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "varying vec2 vUv;\\r\\nvoid main() \\r\\n{ \\r\\n    vUv = uv;\\r\\n    gl_Position = projectionMatrix * (modelViewMatrix * vec4( position, 1.0 ));\\r\\n}"\n\n//# sourceURL=webpack:///./src/material/shaders/test_vs.glsl?')
        },
        "./src/material/shaders/tonemapping_fragment.glsl": /*!********************************************************!*\
  !*** ./src/material/shaders/tonemapping_fragment.glsl ***!
  \********************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "#if defined( TONE_MAPPING ) && defined(STANDARD)\\r\\n\\r\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\r\\n\\r\\n#endif"\n\n//# sourceURL=webpack:///./src/material/shaders/tonemapping_fragment.glsl?')
        },
        "./src/material/shaders/uv2_pars_fragment.glsl": /*!*****************************************************!*\
  !*** ./src/material/shaders/uv2_pars_fragment.glsl ***!
  \*****************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\r\\n\\r\\n\\tvarying vec2 vUv2;\\r\\n\\r\\n#endif\\r\\n\\r\\n#if defined( USE_DIFFUSE_UV )\\r\\n\\r\\n\\tvarying vec2 vDiffuseUv;\\r\\n\\r\\n#endif\\r\\n\\r\\n#if defined( USE_UV3 )\\r\\n\\r\\n\\tvarying vec2 vUv3;\\r\\n\\r\\n#endif"\n\n//# sourceURL=webpack:///./src/material/shaders/uv2_pars_fragment.glsl?')
        },
        "./src/material/shaders/uv2_pars_vertex.glsl": /*!***************************************************!*\
  !*** ./src/material/shaders/uv2_pars_vertex.glsl ***!
  \***************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\r\\n\\r\\n\\tattribute vec2 uv2;\\r\\n\\tvarying vec2 vUv2;\\r\\n\\r\\n#endif\\r\\n\\r\\n#if defined( USE_DIFFUSE_UV )\\r\\n\\r\\n\\tattribute vec2 diffuseUv;\\r\\n\\tvarying vec2 vDiffuseUv;\\r\\n\\r\\n#endif\\r\\n\\r\\n#if defined( USE_UV3 )\\r\\n\\r\\n\\tattribute vec2 uv3;\\r\\n\\tvarying vec2 vUv3;\\r\\n\\r\\n#endif"\n\n//# sourceURL=webpack:///./src/material/shaders/uv2_pars_vertex.glsl?')
        },
        "./src/material/shaders/uv2_vertex.glsl": /*!**********************************************!*\
  !*** ./src/material/shaders/uv2_vertex.glsl ***!
  \**********************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP ) || defined (USE_DIFFUSE_UV2)\\r\\n    #ifdef USE_DIFFUSE_UV2\\r\\n        vUv2 = (uvTransform * vec3(uv2, 1.0)).xy;\\r\\n    #else\\r\\n\\t    vUv2 = uv2;\\r\\n\\t#endif\\r\\n\\r\\n#endif\\r\\n\\r\\n#if defined( USE_DIFFUSE_UV )\\r\\n    vDiffuseUv = ( uvTransform * vec3( diffuseUv, 1 ) ).xy;\\r\\n\\r\\n#endif\\r\\n#if defined( USE_UV3 )\\r\\n    vUv3 = ( uvTransform1 * vec3( uv3, 1 ) ).xy;\\r\\n\\r\\n#endif\\r\\n\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/uv2_vertex.glsl?')
        },
        "./src/material/shaders/uv_pars_vertex.glsl": /*!**************************************************!*\
  !*** ./src/material/shaders/uv_pars_vertex.glsl ***!
  \**************************************************/
        /*! no static exports found */
        function(module, exports) {
            eval('module.exports = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\r\\n\\r\\n\\tvarying vec2 vUv;\\r\\n\\tuniform mat3 uvTransform;\\r\\n\\r\\n#endif\\r\\n\\r\\n#if defined( USE_UV3 )\\r\\n    uniform mat3 uvTransform1;\\r\\n\\r\\n#endif\\r\\n"\n\n//# sourceURL=webpack:///./src/material/shaders/uv_pars_vertex.glsl?')
        },
        "./src/material/sideOptions.js": /*!*************************************!*\
  !*** ./src/material/sideOptions.js ***!
  \*************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n/**\r\n * 每个伟大的工程背后都有一堆乱七八糟的变量，或者常量\r\n */\nexports.default = {\n    FrontSide: 0,\n    BackSide: 1,\n    DoubleSide: 2\n};\n\n//# sourceURL=webpack:///./src/material/sideOptions.js?')
        },
        "./src/material/sourceThreeFunction.js": /*!*********************************************!*\
  !*** ./src/material/sourceThreeFunction.js ***!
  \*********************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\n//some function changed from Threejs source\nexports.default = {\n    copyParams: function copyParams(source) {\n        var params = {};\n        if (source.color) params.color = new THREE.Color(source.color.r, source.color.g, source.color.b);\n        if (source.side) params.side = source.side;\n        if (source.map) params.map = source.map;\n        if (source.lightMap) params.lightMap = source.lightMap;\n        if (source.lightMapIntensity) params.lightMapIntensity = source.lightMapIntensity;\n        if (source.aoMap) params.aoMap = source.aoMap;\n        if (source.aoMapIntensity) params.aoMapIntensity = source.aoMapIntensity;\n        if (source.specularMap) params.specularMap = source.specularMap;\n        if (source.alphaMap) params.alphaMap = source.alphaMap;\n        if (source.envMap) params.envMap = source.envMap;\n        if (source.combine) params.combine = source.combine;\n        if (source.reflectivity) params.reflectivity = source.reflectivity;\n        if (source.refractionRatio) params.refractionRatio = source.refractionRatio;\n        if (source.wireframe) params.wireframe = source.wireframe;\n        if (source.wireframeLinewidth) params.wireframeLinewidth = source.wireframeLinewidth;\n        if (source.wireframeLinecap) params.wireframeLinecap = source.wireframeLinecap;\n        if (source.wireframeLinejoin) params.wireframeLinejoin = source.wireframeLinejoin;\n        if (source.skinning) params.skinning = source.skinning;\n        if (source.morphTargets) params.morphTargets = source.morphTargets;\n        if (source.opacity) params.opacity = source.opacity;\n        if (source.transparent) params.transparent = source.transparent;\n        if (source.vertexColors) params.vertexColors = source.vertexColors;\n        if (source.blending) params.blending = source.blending;\n        if (source.polygonOffset) params.polygonOffset = source.polygonOffset;\n        if (source.polygonOffsetFactor) params.polygonOffsetFactor = source.polygonOffsetFactor;\n        if (source.polygonOffsetUnits) params.polygonOffsetUnits = source.polygonOffsetUnits;\n        return params;\n    }\n};\n\n//# sourceURL=webpack:///./src/material/sourceThreeFunction.js?')
        },
        "./src/material/specialMaterial/multMaterial.js": /*!******************************************************!*\
  !*** ./src/material/specialMaterial/multMaterial.js ***!
  \******************************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nvar mult1_fs = __webpack_require__(/*! ../shaders/mult_texture1.glsl */ "./src/material/shaders/mult_texture1.glsl");\nvar mult2_vs = __webpack_require__(/*! ../shaders/mult_texture2_vs.glsl */ "./src/material/shaders/mult_texture2_vs.glsl");\nvar mult2_fs = __webpack_require__(/*! ../shaders/mult_texture2.glsl */ "./src/material/shaders/mult_texture2.glsl");\nvar mult3_fs = __webpack_require__(/*! ../shaders/mult_texture3.glsl */ "./src/material/shaders/mult_texture3.glsl");\nvar mult4_fs = __webpack_require__(/*! ../shaders/mult_texture4.glsl */ "./src/material/shaders/mult_texture4.glsl");\nvar mult5_fs = __webpack_require__(/*! ../shaders/mult_texture5.glsl */ "./src/material/shaders/mult_texture5.glsl");\nvar mult6_fs = __webpack_require__(/*! ../shaders/mult_texture6.glsl */ "./src/material/shaders/mult_texture6.glsl");\nvar mult7_fs = __webpack_require__(/*! ../shaders/mult_texture7.glsl */ "./src/material/shaders/mult_texture7.glsl");\nvar mult8_fs = __webpack_require__(/*! ../shaders/mult_texture8.glsl */ "./src/material/shaders/mult_texture8.glsl");\nvar mult9_fs = __webpack_require__(/*! ../shaders/mult_texture9.glsl */ "./src/material/shaders/mult_texture9.glsl");\nvar mult10_fs = __webpack_require__(/*! ../shaders/mult_texture10.glsl */ "./src/material/shaders/mult_texture10.glsl");\nvar mult11_fs = __webpack_require__(/*! ../shaders/mult_texture11.glsl */ "./src/material/shaders/mult_texture11.glsl");\nvar mult12_fs = __webpack_require__(/*! ../shaders/mult_texture12.glsl */ "./src/material/shaders/mult_texture12.glsl");\nvar AtmosphereFromSpace = __webpack_require__(/*! ../shaders/AtmosphereFromSpace.glsl */ "./src/material/shaders/AtmosphereFromSpace.glsl");\nvar Atmosphere_vs = __webpack_require__(/*! ../shaders/atmosphere_vs.glsl */ "./src/material/shaders/atmosphere_vs.glsl");\n\nvar fsArray = [mult1_fs, mult2_fs, mult3_fs, mult4_fs, mult5_fs, mult6_fs, mult7_fs, mult8_fs, mult9_fs, mult10_fs, mult11_fs, mult12_fs];\nexports.default = {\n    createUniform: function createUniform() {\n        var uniforms = {\n            fogDensity: { value: 0.00025 },\n            fogNear: { value: 1 },\n            fogFar: { value: 2000 },\n            fogColor: { value: new THREE.Color(0xffffff) },\n            fogAlpha: { value: 1.0 },\n            grayFilterEnable: { value: false },\n            grayFilterIndex: { value: -1.0 },\n            colorMapping: { value: null },\n            TexSampler0: { value: {} },\n            textureRectangle0: { value: new THREE.Vector4(0.0, 0.0, 0.0, 0.0) },\n            textureTransAndScale0: { value: new THREE.Vector4(0.0, 0.0, 0.0, 0.0) },\n            alphaIndex0: { value: 1.0 },\n            brightness0: { value: 1.0 },\n            Km: { value: 0.0025 },\n            Kr: { value: 0.0015 },\n            ESun: { value: 10.0 },\n            nSamples: { value: 2 },\n            fSamples: { value: 2.0 },\n            v3LightPosInput: { value: new THREE.Vector3(20, 20, 20) },\n            fInnerRadius: { value: 1.0 },\n            fOuterRadius: { value: 1.05 },\n            fScaleDepth: { value: 0.25 },\n            v3CameraPosInput: { value: new THREE.Vector3(0.0, 0.0, 0.0) },\n\n            south1: { value: 0.0 },\n            north1: { value: 0.0 },\n            southMercatorY1: { value: 0.0 },\n            oneOverMercatorHeight1: { value: 0.0 },\n            isReProjection: { value: 0.0 },\n            objectPos: { value: new THREE.Vector4(0, 0, 0, 0) },\n            inputColor: { value: new THREE.Vector4(1.0, 0.0, 0.0, 0.0) },\n            alphaValue: { value: new THREE.Vector4(1.0, 0.0, 0.0, 0.0) },\n            isAddEffect0: { value: 0.0 },\n            earthColor0: { value: new THREE.Vector4(1.0, 1.0, 1.0, 1.0) },\n            earthAddColor0: { value: new THREE.Vector4(0.0, 0.0, 0.0, 0.0) },\n            night: { value: 1.0 },\n            contrast: { value: 1.0 },\n            hue: { value: 0.0 },\n            saturation: { value: 1.0 },\n            textureGamma: { value: 1.0 },\n            nightfadeIn: { value: 25000000.0 },\n            nightfadeOut: { value: 10000000.0 },\n            fadeInDist: { value: 15000000.0 },\n            fadeOutDist: { value: 10000000.0 },\n            u_initialColor: { value: new THREE.Vector4(0, 0, 0, 1) },\n            czm_fogDensity: { value: 0.0001 },\n            shadowOpacity: { value: 0.5 },\n            sunDirection: { value: new THREE.Vector3(0, 0, 0) },\n            // 颜色叠加\n            gradientColorOverlayEnable: { value: 0.0 },\n            mapDirection: { value: new THREE.Vector3(0, 0, 0) },\n            gradientColorMap: { value: null },\n            gradientOpacity: { value: 1.0 }\n        };\n\n        uniforms = THREE.UniformsUtils.clone(THREE.UniformsUtils.merge([THREE.UniformsLib[\'lights\'], uniforms]));\n        return uniforms;\n    },\n    createMultMaterial: function createMultMaterial(count) {\n        var uniforms = this.createUniform();\n        for (var i = 0; i < count - 1; i++) {\n            uniforms[\'TexSampler\' + (i + 1)] = { value: {} };\n            uniforms[\'alphaIndex\' + (i + 1)] = { value: 1.0 };\n            uniforms[\'textureRectangle\' + (i + 1)] = { value: new THREE.Vector4(0.0, 0.0, 0.0, 0.0) };\n            uniforms[\'textureTransAndScale\' + (i + 1)] = { value: new THREE.Vector4(0.0, 0.0, 0.0, 0.0) };\n            uniforms[\'brightness\' + (i + 1)] = { value: 1.0 };\n            uniforms[\'isAddEffect\' + (i + 1)] = { value: 0.0 };\n            uniforms[\'earthColor\' + (i + 1)] = { value: new THREE.Vector4(1.0, 1.0, 1.0, 1.0) };\n            uniforms[\'earthAddColor\' + (i + 1)] = { value: new THREE.Vector4(0.0, 0.0, 0.0, 0.0) };\n\n            uniforms[\'south\' + (i + 2)] = { value: 0.0 };\n            uniforms[\'north\' + (i + 2)] = { value: 0.0 };\n            uniforms[\'southMercatorY\' + (i + 2)] = { value: 0.0 };\n            uniforms[\'oneOverMercatorHeight\' + (i + 2)] = { value: 0.0 };\n        }\n\n        var material = new THREE.ShaderMaterial({\n            uniforms: uniforms,\n            vertexShader: mult2_vs,\n            fragmentShader: fsArray[count - 1]\n        });\n\n        return material;\n    },\n    createAtmosphereMaterial: function createAtmosphereMaterial() {\n        var uniforms = {\n            //two mult texture from bundle\n            fogDensity: { value: 0.00025 },\n            fogNear: { value: 1 },\n            fogFar: { value: 2000 },\n            fogColor: { value: new THREE.Color(0xffffff) },\n            fogAlpha: { value: 1.0 },\n            objectPos: { value: new THREE.Vector4(0, 0, 0, 0) },\n            Km: { value: 0.0025 },\n            Kr: { value: 0.0015 },\n            ESun: { value: 10.0 },\n            fSamples: { value: 2.0 },\n            g: { value: -0.98 },\n            v3LightPosInput: { value: new THREE.Vector3(1, 1, 1) },\n            fInnerRadius: { value: 6537590.425 },\n            fOuterRadius: { value: 6378137 },\n            night: { value: 1.0 },\n            czm_fogDensity: { value: 0.0001 }\n        };\n        var material = new THREE.ShaderMaterial({\n            uniforms: uniforms,\n            vertexShader: Atmosphere_vs,\n            fragmentShader: AtmosphereFromSpace\n        });\n        material.side = THREE.BackSide;\n        return material;\n    }\n};\n\n//# sourceURL=webpack:///./src/material/specialMaterial/multMaterial.js?')
        },
        "./src/material/specialMaterial/scanningMaterial.js": /*!**********************************************************!*\
  !*** ./src/material/specialMaterial/scanningMaterial.js ***!
  \**********************************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n *\r\n * References:\r\n *\thttp://www.valvesoftware.com/publications/2010/siggraph2010_vlachos_waterflow.pdf\r\n * \thttp://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html\r\n *\r\n */\n\nvar vertexshader = __webpack_require__(/*! ../shaders/scanning_vertex.glsl */ \"./src/material/shaders/scanning_vertex.glsl\");\nvar fragmentshader = __webpack_require__(/*! ../shaders/scanning_fragment.glsl */ \"./src/material/shaders/scanning_fragment.glsl\");\nvar v1shader = __webpack_require__(/*! ../shaders/scanning1_vertex.glsl */ \"./src/material/shaders/scanning1_vertex.glsl\");\nvar f1shader = __webpack_require__(/*! ../shaders/scanning1_fragment.glsl */ \"./src/material/shaders/scanning1_fragment.glsl\");\n\nTHREE.ScanningMaterial = function (options, materialName) {\n\n    options.maxPos = options.maxPos || new THREE.Vector3();\n    options.minPos = options.minPos || new THREE.Vector3();\n    options.color = options.color || new THREE.Vector3(1, 1, 1);\n    options.isUseUvMap = options.isUseUvMap == true ? true : false;\n\n    var uniforms = {\n        maxPos: { type: 'v3', value: options.maxPos },\n        minPos: { type: 'v3', value: options.minPos },\n        color: { type: 'v3', value: options.color },\n        uvMap: { value: {} },\n        direction: { value: new THREE.Vector3() },\n        uvRatio: { value: 1.0 },\n        relativeModelMatrix: { value: options.relativeModelMatrix }\n    };\n\n    var ScanningMaterial = new THREE.ShaderMaterial({\n        wireframe: true,\n        uniforms: uniforms,\n        vertexShader: vertexshader,\n        fragmentShader: fragmentshader,\n        depthTest: true,\n        transparent: true\n\n    });\n\n    ScanningMaterial.defines.USE_UVMAP = options.isUseUvMap;\n    ScanningMaterial.type = 'scanning';\n\n    return ScanningMaterial;\n};\n\nTHREE.ScanningMaterial1 = function (options, materialName) {\n\n    options.maxPos = options.maxPos || new THREE.Vector3();\n    options.minPos = options.minPos || new THREE.Vector3();\n    options.color = options.color || new THREE.Vector3(1, 1, 1);\n    options.isUseUvMap = options.isUseUvMap == true ? true : false;\n\n    var uniforms = {\n        maxPos: { type: 'v3', value: options.maxPos },\n        minPos: { type: 'v3', value: options.minPos },\n        color: { type: 'v3', value: options.color },\n        uvMap: { value: {} },\n        direction: { value: new THREE.Vector3() },\n        // uvRatio:{value:1.0},\n        relativeModelMatrix: { value: options.relativeModelMatrix }\n    };\n\n    var ScanningMaterial = new THREE.ShaderMaterial({\n        wireframe: true,\n        uniforms: uniforms,\n        vertexShader: v1shader,\n        fragmentShader: f1shader,\n        depthTest: true,\n        transparent: true\n\n    });\n\n    ScanningMaterial.defines.USE_UVMAP = options.isUseUvMap;\n    ScanningMaterial.type = 'scanning';\n\n    return ScanningMaterial;\n};\n\n//# sourceURL=webpack:///./src/material/specialMaterial/scanningMaterial.js?")
        },
        "./src/material/specialMaterial/specialMaterialManager.js": /*!****************************************************************!*\
  !*** ./src/material/specialMaterial/specialMaterialManager.js ***!
  \****************************************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _specialTextures = __webpack_require__(/*! ./specialTextures.json */ \"./src/material/specialMaterial/specialTextures.json\");\n\nvar _specialTextures2 = _interopRequireDefault(_specialTextures);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar maxImageCountPerTile = 12;\nfor (var i = 0; i < maxImageCountPerTile; i++) {\n    _specialTextures2.default.materials['Material' + (i + 1)] = [];\n    for (var j = 0; j <= i; j++) {\n        _specialTextures2.default.materials['Material' + (i + 1)].push('TexSampler' + j);\n    }\n}\nexports.default = {\n    getTextureName: function getTextureName(name, index) {\n        var mats = _specialTextures2.default.materials;\n        return mats[name][index];\n    },\n    isSpecialMaterial: function isSpecialMaterial(name) {\n        var mats = _specialTextures2.default.materials;\n        if (mats[name] === undefined) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n};\n\n//# sourceURL=webpack:///./src/material/specialMaterial/specialMaterialManager.js?")
        },
        "./src/material/specialMaterial/specialTextures.json": /*!***********************************************************!*\
  !*** ./src/material/specialMaterial/specialTextures.json ***!
  \***********************************************************/
        /*! exports provided: materials, default */
        function(module) {
            eval('module.exports = JSON.parse("{\\"materials\\":{\\"AtmosphereFromSpace\\":[],\\"test\\":[],\\"test1\\":[\\"texture1\\",\\"texture2\\"],\\"fog\\":[]}}");\n\n//# sourceURL=webpack:///./src/material/specialMaterial/specialTextures.json?')
        },
        "./src/material/specialMaterial/t3dMaterial.js": /*!*****************************************************!*\
  !*** ./src/material/specialMaterial/t3dMaterial.js ***!
  \*****************************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n            value: true\n});\nvar map_fragment = __webpack_require__(/*! ../shaders/map_fragment.glsl */ \"./src/material/shaders/map_fragment.glsl\");\nvar map_pars_fragment = __webpack_require__(/*! ../shaders/map_pars_fragment.glsl */ \"./src/material/shaders/map_pars_fragment.glsl\");\n\nvar aomap_fragment = __webpack_require__(/*! ../shaders/aomap_fragment.glsl */ \"./src/material/shaders/aomap_fragment.glsl\");\nvar uv_pars_vertex = __webpack_require__(/*! ../shaders/uv_pars_vertex.glsl */ \"./src/material/shaders/uv_pars_vertex.glsl\");\nvar uv2_pars_fragment = __webpack_require__(/*! ../shaders/uv2_pars_fragment.glsl */ \"./src/material/shaders/uv2_pars_fragment.glsl\");\nvar uv2_pars_vertex = __webpack_require__(/*! ../shaders/uv2_pars_vertex.glsl */ \"./src/material/shaders/uv2_pars_vertex.glsl\");\nvar uv2_vertex = __webpack_require__(/*! ../shaders/uv2_vertex.glsl */ \"./src/material/shaders/uv2_vertex.glsl\");\nvar alphamap_fragment = __webpack_require__(/*! ../shaders/alphamap_fragment.glsl */ \"./src/material/shaders/alphamap_fragment.glsl\");\nvar alphamap_pars_fragment = __webpack_require__(/*! ../shaders/alphamap_pars_fragment.glsl */ \"./src/material/shaders/alphamap_pars_fragment.glsl\");\n\nvar color_vertex = __webpack_require__(/*! ../shaders/color_vertex.glsl */ \"./src/material/shaders/color_vertex.glsl\");\nvar color_pars_vertex = __webpack_require__(/*! ../shaders/color_pars_vertex.glsl */ \"./src/material/shaders/color_pars_vertex.glsl\");\n\nvar color_fragment = __webpack_require__(/*! ../shaders/color_fragment.glsl */ \"./src/material/shaders/color_fragment.glsl\");\nvar color_pars_fragment = __webpack_require__(/*! ../shaders/color_pars_fragment.glsl */ \"./src/material/shaders/color_pars_fragment.glsl\");\n\nvar encodings_fragment = __webpack_require__(/*! ../shaders/encodings_fragment.glsl */ \"./src/material/shaders/encodings_fragment.glsl\");\n\nvar emissivemap_fragment = __webpack_require__(/*! ../shaders/emissivemap_fragment.glsl */ \"./src/material/shaders/emissivemap_fragment.glsl\");\nvar tonemapping_fragment = __webpack_require__(/*! ../shaders/tonemapping_fragment.glsl */ \"./src/material/shaders/tonemapping_fragment.glsl\");\n\n//为了解决gpupicker的问题，特地改写剪裁面shader\n// var clipping_planes_vertex = require('../shaders/clipping_planes_vertex.glsl');\n// var clipping_planes_pars_vertex = require('../shaders/clipping_planes_pars_vertex.glsl');\n// var clipping_planes_fragment = require('../shaders/clipping_planes_fragment.glsl');\n// var clipping_planes_pars_fragment = require('../shaders/clipping_planes_pars_fragment.glsl');\n\n//skining 骨骼动画精度问题\nvar skinning_pars_vertex = __webpack_require__(/*! ../shaders/skinning_pars_vertex.glsl */ \"./src/material/shaders/skinning_pars_vertex.glsl\");\nvar skinning_vertex = __webpack_require__(/*! ../shaders/skinning_vertex.glsl */ \"./src/material/shaders/skinning_vertex.glsl\");\n\nexports.default = {\n            initT3dMaterial: function initT3dMaterial(config) {\n                        //var  material =  new THREE.MeshStandardMaterial(params);\n                        THREE.Material.prototype.alphaMap1 = '';\n                        THREE.Material.prototype.alphaColor = new THREE.Vector4(1, 1, 1, 0);\n                        THREE.Material.prototype.aoMapFactor = config.aoMapFactor || 2.0;\n                        THREE.Material.prototype.aoFactor = config.aoFactor || 1.0;\n\n                        // THREE.Material.prototype.darkFactor = config.darkFactor || 1.0;\n                        //为解决gpupicker\n                        THREE.Material.prototype.setBaseID = function (value) {\n                                    if (!this.shader.uniforms.baseId) {\n                                                this.shader.uniforms.baseId = { value: value };\n                                    } else {\n                                                this.shader.uniforms.baseId.value = value;\n                                    }\n                        };\n                        //THREE.Material.prototype.gamma =  config.gamma || 1.5;\n                        //设置提前编译shader,本来想在render中进行改造，three提供的这个方法很完美\n                        THREE.Material.prototype.onBeforeCompile = function (shader) {\n\n                                    //diffuseColor.rgb = diffuseColor.rgb*(1.0-alphaColor.a)+alphaColor.rgb*alphaColor.a;\n\n                                    shader.vertexShader = shader.vertexShader.replace('#include <uv_pars_vertex>', uv_pars_vertex);\n                                    shader.vertexShader = shader.vertexShader.replace('#include <uv2_vertex>', uv2_vertex);\n                                    shader.vertexShader = shader.vertexShader.replace('#include <uv2_pars_vertex>', uv2_pars_vertex);\n\n                                    shader.vertexShader = shader.vertexShader.replace('#include <color_vertex>', color_vertex);\n                                    shader.vertexShader = shader.vertexShader.replace('#include <color_pars_vertex>', color_pars_vertex);\n\n                                    shader.vertexShader = shader.vertexShader.replace('#include <uv2_pars_vertex>', uv2_pars_vertex);\n\n                                    //解决骨骼动画精度问题\n                                    shader.vertexShader = shader.vertexShader.replace('#include <skinning_pars_vertex>', skinning_pars_vertex);\n                                    shader.vertexShader = shader.vertexShader.replace('#include <skinning_vertex>', skinning_vertex);\n\n                                    //为解决gpupicker,目前gpupicker在thingjs中解决，t3dMaterial只需解决shaderMaterial的问题\n                                    // shader.vertexShader = shader.vertexShader.replace('#include <clipping_planes_pars_vertex>', clipping_planes_pars_vertex);\n                                    // shader.vertexShader = shader.vertexShader.replace('#include <clipping_planes_vertex>', clipping_planes_vertex);\n                                    // shader.fragmentShader = shader.fragmentShader.replace('#include <clipping_planes_pars_fragment>', clipping_planes_pars_fragment);\n                                    // shader.fragmentShader = shader.fragmentShader.replace('#include <clipping_planes_fragment>', clipping_planes_fragment);\n\n                                    shader.fragmentShader = shader.fragmentShader.replace('#include <uv2_pars_fragment>', uv2_pars_fragment);\n\n                                    shader.fragmentShader = shader.fragmentShader.replace('#include <map_fragment>', map_fragment);\n                                    shader.fragmentShader = shader.fragmentShader.replace('#include <map_pars_fragment>', map_pars_fragment);\n\n                                    shader.fragmentShader = shader.fragmentShader.replace('#include <aomap_fragment>', aomap_fragment);\n                                    shader.fragmentShader = shader.fragmentShader.replace('#include <alphamap_pars_fragment>', alphamap_pars_fragment);\n                                    shader.fragmentShader = shader.fragmentShader.replace('#include <alphamap_fragment>', alphamap_fragment);\n\n                                    shader.fragmentShader = shader.fragmentShader.replace('#include <color_fragment>', color_fragment);\n                                    shader.fragmentShader = shader.fragmentShader.replace('#include <color_pars_fragment>', color_pars_fragment);\n                                    shader.fragmentShader = shader.fragmentShader.replace('#include <encodings_fragment>', encodings_fragment);\n\n                                    //tonemapping_pars_fragment\n                                    shader.fragmentShader = shader.fragmentShader.replace('#include <emissivemap_fragment>', emissivemap_fragment);\n                                    shader.fragmentShader = shader.fragmentShader.replace('#include <tonemapping_fragment>', tonemapping_fragment);\n                                    shader.uniforms.alphaMap1 = { value: this.alphaMap1 };\n                                    shader.uniforms.alphaColor = { value: this.alphaColor };\n                                    shader.uniforms.aoMapFactor = { value: this.aoMapFactor };\n                                    shader.uniforms.aoFactor = { value: this.aoFactor };\n\n                                    // shader.uniforms.darkFactor = {value :this.darkFactor};\n                                    shader.uniforms.baseId = { value: 0 };\n                                    //shader.uniforms.gamma = {value :this.gamma};\n                                    this.shader = shader;\n                        };\n            }\n\n};\n\n//# sourceURL=webpack:///./src/material/specialMaterial/t3dMaterial.js?")
        },
        "./src/material/specialMaterial/testMaterial.js": /*!******************************************************!*\
  !*** ./src/material/specialMaterial/testMaterial.js ***!
  \******************************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nvar test_vs = __webpack_require__(/*! ../shaders/test_vs.glsl */ "./src/material/shaders/test_vs.glsl");\nvar test_fs = __webpack_require__(/*! ../shaders/test.glsl */ "./src/material/shaders/test.glsl");\nvar test1_fs = __webpack_require__(/*! ../shaders/test1.glsl */ "./src/material/shaders/test1.glsl");\n\nvar testFog_vs = __webpack_require__(/*! ../shaders/testFog_vs.glsl */ "./src/material/shaders/testFog_vs.glsl");\nvar testFog_fs = __webpack_require__(/*! ../shaders/testFog.glsl */ "./src/material/shaders/testFog.glsl");\n\nvar projector_vs = __webpack_require__(/*! ../shaders/projector_vertex.glsl */ "./src/material/shaders/projector_vertex.glsl");\nvar projector_fs = __webpack_require__(/*! ../shaders/projector_fragment.glsl */ "./src/material/shaders/projector_fragment.glsl");\n\nvar gpu_vs = __webpack_require__(/*! ../shaders/gpu_vertex.glsl */ "./src/material/shaders/gpu_vertex.glsl");\nvar gpu_fs = __webpack_require__(/*! ../shaders/gpu_fragment.glsl */ "./src/material/shaders/gpu_fragment.glsl");\n\nvar bigpoint_vs = __webpack_require__(/*! ../shaders/bigpoint_vertex.glsl */ "./src/material/shaders/bigpoint_vertex.glsl");\nvar bigpoint_fs = __webpack_require__(/*! ../shaders/bigpoint_fragment.glsl */ "./src/material/shaders/bigpoint_fragment.glsl");\n\nvar frustum_vs = __webpack_require__(/*! ../shaders/frustum_vertex.glsl */ "./src/material/shaders/frustum_vertex.glsl");\nvar frustum_fs = __webpack_require__(/*! ../shaders/frustum_fragment.glsl */ "./src/material/shaders/frustum_fragment.glsl");\n\nvar scanningCity_vs = __webpack_require__(/*! ../shaders/scanningCity_vertex.glsl */ "./src/material/shaders/scanningCity_vertex.glsl");\nvar scanningCity_fs = __webpack_require__(/*! ../shaders/scannningCity_fragment.glsl */ "./src/material/shaders/scannningCity_fragment.glsl");\n\nvar standardScanning_vs = __webpack_require__(/*! ../shaders/standardScanning_vertex.glsl */ "./src/material/shaders/standardScanning_vertex.glsl");\nvar standardScanning_fs = __webpack_require__(/*! ../shaders/standardScanning_fragment.glsl */ "./src/material/shaders/standardScanning_fragment.glsl");\n\nvar interpolate_vs = __webpack_require__(/*! ../shaders/interpolate_vs.glsl */ "./src/material/shaders/interpolate_vs.glsl");\nvar interpolate_fs = __webpack_require__(/*! ../shaders/interpolate_fs.glsl */ "./src/material/shaders/interpolate_fs.glsl");\n\nexports.default = {\n    createTestMaterial: function createTestMaterial() {\n        var uniforms = {\n            color: { type: \'c\', value: new THREE.Color(0.0, 0.0, 0.0) },\n            alpha: { value: 1.0 }\n        };\n        var material = new THREE.ShaderMaterial({\n            uniforms: uniforms,\n            vertexShader: test_vs,\n            fragmentShader: test_fs\n        });\n        return material;\n    },\n    createFogMaterial: function createFogMaterial() {\n        var uniforms = {\n            color: { type: \'c\', value: new THREE.Color(0.0, 0.0, 0.0) },\n            alpha: { value: 1.0 },\n            center: { value: new THREE.Vector3(0, 0, 6378000) },\n            yDir: { value: new THREE.Vector3(0, 1, 0) },\n            xDir: { value: new THREE.Vector3(1, 0, 0) },\n            distance: { value: 0.0 },\n            cameraHeight: { value: 0.0 },\n            tilt: { value: 0.0 }\n        };\n        var material = new THREE.ShaderMaterial({\n            uniforms: uniforms,\n            vertexShader: testFog_vs,\n            fragmentShader: testFog_fs\n        });\n\n        return material;\n    },\n    createTest1Material: function createTest1Material() {\n        var uniforms = {\n            color: { type: \'c\', value: new THREE.Color(1.0, 1.0, 1.0) },\n            texture1: { value: {} },\n            texture2: { value: {} }\n        };\n        var material = new THREE.ShaderMaterial({\n            uniforms: uniforms,\n            vertexShader: test_vs,\n            fragmentShader: test1_fs\n        });\n        return material;\n    },\n    createProjectorMaterial: function createProjectorMaterial() {\n        var uniforms = {\n            frustum: {\n                value: [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()]\n            },\n            // axis:{value:new THREE.Vector3(0,0,1)},\n            frustPlane: { value: 10 },\n            videoTexture: { value: null }\n        };\n        var material = new THREE.ShaderMaterial({\n            uniforms: uniforms,\n            vertexShader: projector_vs,\n            fragmentShader: projector_fs\n        });\n        material.transparent = true;\n        material.side = THREE.FrontSide;\n        //material.depthTest = false;\n        return material;\n    },\n\n    createGpuMaterial: function createGpuMaterial() {\n        var uniforms = {\n            baseId: {\n                type: "f",\n                value: 10\n            },\n            rotation: { value: 0 },\n            center: { value: new THREE.Vector2(0.5, 0.5) }\n        };\n        var material = new THREE.ShaderMaterial({\n            uniforms: uniforms,\n            vertexShader: gpu_vs,\n            fragmentShader: gpu_fs\n        });\n        return material;\n    },\n\n    createBigPointMaterial: function createBigPointMaterial() {\n        var material = new THREE.ShaderMaterial({\n            uniforms: {\n                tex: {\n                    value: null\n                },\n                size: { value: 1 },\n                offset: { value: new THREE.Vector2(0.0) },\n                uvMap: {\n                    value: null\n                },\n                strength: { value: 1.0 },\n                imageSize: { value: new THREE.Vector2(64, 64) },\n                ptColor: { value: new THREE.Color(1, 1, 1) },\n                opacity: { value: 1.0 }\n            },\n            vertexShader: bigpoint_vs,\n            fragmentShader: bigpoint_fs,\n            blending: THREE.AdditiveBlending,\n            depthTest: false,\n            transparent: true\n            //vertexColors: true\n        });\n        material.defines.USE_MAP = true;\n        material.defines.USE_UVMAP = false;\n        return material;\n    },\n\n    createInterpolantMaterial: function createInterpolantMaterial() {\n        var uniforms = {\n            colorMapping: { value: null },\n            tDiffuse: { value: null },\n            color: { value: new THREE.Color(1, 1, 1) },\n            colorRange: { value: new THREE.Vector2(0, 0) },\n            texSize: { value: new THREE.Vector2(640, 640) },\n            mosaicSize: { value: new THREE.Vector2(16, 16) },\n            metalness: { value: 0.0 },\n            roughness: { value: 0.78 },\n            opacity: { value: 1.0 }\n        };\n\n        var material = new THREE.ShaderMaterial({\n            uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib[\'fog\'], THREE.UniformsLib[\'lights\'], uniforms]),\n            vertexShader: interpolate_vs,\n            fragmentShader: interpolate_fs,\n            transparent: true\n            //vertexColors: true\n        });\n        return material;\n    },\n\n    createFrustumMaterial: function createFrustumMaterial() {\n        var boundingBox = [];\n        for (var i = 0; i < 6; i++) {\n            boundingBox.push(new THREE.Vector4(0.0, 0.0, 0.0, 0.0));\n        }\n        var material = new THREE.ShaderMaterial({\n            uniforms: {\n                boundingBox: {\n                    value: boundingBox\n                },\n                color: { value: new THREE.Vector4(1.0, 0.0, 0.0, 0.5) }\n            },\n            vertexShader: frustum_vs,\n            fragmentShader: frustum_fs,\n            transparent: true\n            //blending: THREE.AdditiveBlending\n        });\n        material.side = THREE.FrontSide;\n        return material;\n    },\n    createScanningCityMaterial: function createScanningCityMaterial() {\n        var material = new THREE.ShaderMaterial({\n            uniforms: {\n                scanningColor: { value: new THREE.Color("#5588aa") },\n                u_r: { value: 0.2 },\n                u_length: { value: 0.1 }, //扫过区域\n                center: { value: new THREE.Vector2(0.0, 0.0) },\n                uvTransform: { value: new THREE.Matrix3() },\n                map: { value: null }\n            },\n            vertexShader: scanningCity_vs,\n            fragmentShader: scanningCity_fs,\n            transparent: true\n        });\n        material.type = \'initialScanning\';\n        return material;\n    },\n\n    createStandardScanningMaterial: function createStandardScanningMaterial() {\n        var material = new THREE.MeshStandardMaterial();\n        // Object.defineProperty(material, "maxPos", {\n        //     set: function (v) {\n        //         if(material._shader){\n        //             material._shader.uniforms[\'maxPos\'].value = v;\n        //         }\n        //         this._maxPos = v;\n        //     },\n        //     get: function () {\n        //         return this._maxPos;\n        //     }\n        // });\n        // Object.defineProperty(material, "minPos", {\n        //     set: function (v) {\n        //         if(material._shader){\n        //             material._shader.uniforms[\'minPos\'].value = v;\n        //         }\n        //         this._minPos = v;\n        //     },\n        //     get: function () {\n        //         return this._minPos;\n        //     }\n        // });\n        // Object.defineProperty(material, "uvMap", {\n        //     set: function (v) {\n        //         if(material._shader){\n        //             material._shader.uniforms[\'uvMap\'].value = v;\n        //         }\n        //         this._uvMap = v;\n        //     },\n        //     get: function () {\n        //         return this._uvMap;\n        //     }\n        // });\n        // Object.defineProperty(material, "use_uvMap", {\n        //     set: function (v) {\n        //         if(material._shader){\n        //             material._shader.uniforms[\'use_uvMap\'].value = v;\n        //         }\n        //         this[\'_use_uvMap\'] = v;\n        //     },\n        //     get: function () {\n        //         return this[\'_use_uvMap\'];\n        //     }\n        // });\n        // Object.defineProperty(material, "relativeModelMatrix", {\n        //     set: function (v) {\n        //         if(material._shader){\n        //             material._shader.uniforms[\'relativeModelMatrix\'].value = v;\n        //         }\n        //         this._relativeModelMatrix = v;\n        //     },\n        //     get: function () {\n        //         return this._relativeModelMatrix;\n        //     }\n        // });\n        //TODO 这里还是要存储一下一些属性\n        material.onBeforeCompile = function (shader, renderer) {\n            shader.vertexShader = standardScanning_vs;\n            shader.fragmentShader = standardScanning_fs;\n            if (!shader.uniforms[\'maxPos\']) {\n                shader.uniforms[\'maxPos\'] = {\n                    value: this.maxPos || new THREE.Vector3()\n                };\n            }\n            if (!shader.uniforms[\'minPos\']) {\n                shader.uniforms[\'minPos\'] = {\n                    value: this.minPos || new THREE.Vector3()\n                };\n            }\n            if (!shader.uniforms[\'uvMap\']) {\n                shader.uniforms[\'uvMap\'] = {\n                    value: this.uvMap || null\n                };\n            }\n            if (!shader.uniforms[\'use_uvMap\']) {\n                shader.uniforms[\'use_uvMap\'] = {\n                    value: this[\'use_uvMap\'] === undefined ? 0.0 : this.uvMap\n                };\n            }\n            if (!shader.uniforms[\'relativeModelMatrix\']) {\n                shader.uniforms[\'relativeModelMatrix\'] = {\n                    value: this.relativeModelMatrix || new THREE.Matrix4()\n                };\n            }\n            this._shader = shader;\n        };\n        return material;\n    }\n};\n\n//# sourceURL=webpack:///./src/material/specialMaterial/testMaterial.js?')
        },
        "./src/material/specialMaterial/water.js": /*!***********************************************!*\
  !*** ./src/material/specialMaterial/water.js ***!
  \***********************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n__webpack_require__(/*! ./water/Reflector.js */ \"./src/material/specialMaterial/water/Reflector.js\");\n\n__webpack_require__(/*! ./water/Refractor.js */ \"./src/material/specialMaterial/water/Refractor.js\");\n\n__webpack_require__(/*! ./water/Water3.js */ \"./src/material/specialMaterial/water/Water3.js\");\n\n__webpack_require__(/*! ./water/WaterMaterial3.js */ \"./src/material/specialMaterial/water/WaterMaterial3.js\");\n\nvar _buffer = __webpack_require__(/*! ../../util/buffer.js */ \"./src/util/buffer.js\");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _Material = __webpack_require__(/*! ../Material.js */ \"./src/material/Material.js\");\n\nvar _Material2 = _interopRequireDefault(_Material);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n  createWater3: function createWater3(geometry, materialName, param) {\n    var waterMat = this.createWater3Material(materialName, param);\n    var threeMat = waterMat.getTechnique(0).getPass(0).material;\n    var water = new THREE.Water3(geometry, threeMat);\n    water.t3dMaterial = material;\n    //water.position.y = 1;\n    //water.rotation.x = Math.PI * - 0.5;\n    return water;\n  },\n  /**\r\n   * 返回water的t3d材质\r\n   * @param geometry\r\n   * @param materialName\r\n   * @param param\r\n   */\n  createWater3Material: function createWater3Material(materialName, param) {\n    var material = _buffer2.default.materialBuffer.get(materialName);\n    if (!material) {\n      var textureLoader = new THREE.TextureLoader();\n      var param0 = {\n        color: new THREE.Color(1, 1, 1),\n        scale: 4,\n        flowDirection: new THREE.Vector2(1, 1),\n        normalMap0: '',\n        normalMap1: '',\n        tReflectionMap: '',\n        tRefractionMap: '',\n        textureWidth: 1024,\n        textureHeight: 1024,\n        intensity: 1.0,\n        flowSpeed: 1.0,\n        opacity: 1.0\n      };\n      if (param.color) {\n        if (param.color instanceof Array) {\n          param0.color = new THREE.Color(param.color[0], param.color[1], param.color[2]);\n        } else {\n          param0.color = new THREE.Color(param.color);\n        }\n      } else {\n        param0.color = new THREE.Color(1, 1, 1);\n      }\n      if (!THING.Utils.isNull(param.opacity)) {\n        param0.opacity = param.opacity;\n      }\n\n      param0.normalMap0 = param.normalMap0 ? textureLoader.load(param.normalMap0) : '';\n      param0.normalMap1 = param.normalMap1 ? textureLoader.load(param.normalMap1) : '';\n      param0.tReflectionMap = param.tReflectionMap ? textureLoader.load(param.tReflectionMap) : '';\n      param0.tRefractionMap = param.tRefractionMap ? textureLoader.load(param.tRefractionMap) : '';\n      //这里不能使用平铺模式，存在bug\n      // param0.tRefractionMap.wrapS = param0.tRefractionMap.wrapT = THREE.RepeatWrapping;\n      // param0.tReflectionMap.wrapS =  param0.tReflectionMap.wrapT = THREE.RepeatWrapping;\n\n\n      param0.flowDirection.x = param.flowX === undefined ? 1.0 : param.flowX;\n      param0.flowDirection.y = param.flowY === undefined ? 1.0 : param.flowY;\n      param0.flowSpeed = param.flowSpeed === undefined ? 1.0 : param.flowSpeed;\n      param0.intensity = param.intensity || 1.0;\n      param0.scale = param.scale || 4;\n\n      var waterMat = new THREE.WaterMaterial3(param0, materialName);\n      waterMat.updateFlow(param0.flowSpeed, materialName);\n      material = new _Material2.default();\n      material.getTechnique(0).getPass(0).material = waterMat;\n      _buffer2.default.materialBuffer.add(materialName, material);\n    }\n    return material;\n  }\n};\n\n//# sourceURL=webpack:///./src/material/specialMaterial/water.js?")
        },
        "./src/material/specialMaterial/water/Reflector.js": /*!*********************************************************!*\
  !*** ./src/material/specialMaterial/water/Reflector.js ***!
  \*********************************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\n/**\r\n * @author Slayvin / http://slayvin.net\r\n */\n\nTHREE.Reflector = function (geometry, options) {\n\n\t\tTHREE.Mesh.call(this, geometry);\n\n\t\tthis.type = 'Reflector';\n\n\t\tvar scope = this;\n\n\t\toptions = options || {};\n\n\t\tvar color = options.color !== undefined ? new THREE.Color(options.color) : new THREE.Color(0x7F7F7F);\n\t\tvar textureWidth = options.textureWidth || 512;\n\t\tvar textureHeight = options.textureHeight || 512;\n\t\tvar clipBias = options.clipBias || 0;\n\t\tvar shader = options.shader || THREE.Reflector.ReflectorShader;\n\t\tvar recursion = options.recursion !== undefined ? options.recursion : 0;\n\n\t\t//\n\n\t\tvar reflectorPlane = new THREE.Plane();\n\t\tvar normal = new THREE.Vector3();\n\t\tvar reflectorWorldPosition = new THREE.Vector3();\n\t\tvar cameraWorldPosition = new THREE.Vector3();\n\t\tvar rotationMatrix = new THREE.Matrix4();\n\t\tvar lookAtPosition = new THREE.Vector3(0, 0, -1);\n\t\tvar clipPlane = new THREE.Vector4();\n\t\tvar viewport = new THREE.Vector4();\n\n\t\tvar view = new THREE.Vector3();\n\t\tvar target = new THREE.Vector3();\n\t\tvar q = new THREE.Vector4();\n\n\t\tvar textureMatrix = new THREE.Matrix4();\n\t\tvar virtualCamera = new THREE.PerspectiveCamera();\n\n\t\tvar parameters = {\n\t\t\t\tminFilter: THREE.LinearFilter,\n\t\t\t\tmagFilter: THREE.LinearFilter,\n\t\t\t\tformat: THREE.RGBFormat,\n\t\t\t\tstencilBuffer: false\n\t\t};\n\n\t\tvar renderTarget = new THREE.WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n\t\tif (!THREE.MathUtils.isPowerOfTwo(textureWidth) || !THREE.MathUtils.isPowerOfTwo(textureHeight)) {\n\n\t\t\t\trenderTarget.texture.generateMipmaps = false;\n\t\t}\n\n\t\tvar material = new THREE.ShaderMaterial({\n\t\t\t\tuniforms: THREE.UniformsUtils.clone(shader.uniforms),\n\t\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\t\tvertexShader: shader.vertexShader\n\t\t});\n\n\t\tmaterial.uniforms.tDiffuse.value = renderTarget.texture;\n\t\tmaterial.uniforms.color.value = color;\n\t\tmaterial.uniforms.textureMatrix.value = textureMatrix;\n\n\t\tthis.material = material;\n\t\tthis.renderOrder = -Infinity; // render first\n\n\t\tthis.onBeforeRender = function (renderer, scene, camera) {\n\n\t\t\t\tif ('recursion' in camera.userData) {\n\n\t\t\t\t\t\tif (camera.userData.recursion === recursion) return;\n\n\t\t\t\t\t\tcamera.userData.recursion++;\n\t\t\t\t}\n\n\t\t\t\treflectorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n\t\t\t\tcameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n\n\t\t\t\trotationMatrix.extractRotation(scope.matrixWorld);\n\n\t\t\t\tnormal.set(0, 0, 1);\n\t\t\t\tnormal.applyMatrix4(rotationMatrix);\n\n\t\t\t\tview.subVectors(reflectorWorldPosition, cameraWorldPosition);\n\n\t\t\t\t// Avoid rendering when reflector is facing away\n\n\t\t\t\tif (view.dot(normal) > 0) return;\n\n\t\t\t\tview.reflect(normal).negate();\n\t\t\t\tview.add(reflectorWorldPosition);\n\n\t\t\t\trotationMatrix.extractRotation(camera.matrixWorld);\n\n\t\t\t\tlookAtPosition.set(0, 0, -1);\n\t\t\t\tlookAtPosition.applyMatrix4(rotationMatrix);\n\t\t\t\tlookAtPosition.add(cameraWorldPosition);\n\n\t\t\t\ttarget.subVectors(reflectorWorldPosition, lookAtPosition);\n\t\t\t\ttarget.reflect(normal).negate();\n\t\t\t\ttarget.add(reflectorWorldPosition);\n\n\t\t\t\tvirtualCamera.position.copy(view);\n\t\t\t\tvirtualCamera.up.set(0, 1, 0);\n\t\t\t\tvirtualCamera.up.applyMatrix4(rotationMatrix);\n\t\t\t\tvirtualCamera.up.reflect(normal);\n\t\t\t\tvirtualCamera.lookAt(target);\n\n\t\t\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\n\n\t\t\t\tvirtualCamera.updateMatrixWorld();\n\t\t\t\tvirtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n\n\t\t\t\tvirtualCamera.userData.recursion = 0;\n\n\t\t\t\t// Update the texture matrix\n\t\t\t\ttextureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n\t\t\t\ttextureMatrix.multiply(virtualCamera.projectionMatrix);\n\t\t\t\ttextureMatrix.multiply(virtualCamera.matrixWorldInverse);\n\t\t\t\ttextureMatrix.multiply(scope.matrixWorld);\n\n\t\t\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t\t\treflectorPlane.setFromNormalAndCoplanarPoint(normal, reflectorWorldPosition);\n\t\t\t\treflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n\n\t\t\t\tclipPlane.set(reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant);\n\n\t\t\t\tvar projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t\t\tq.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n\t\t\t\tq.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n\t\t\t\tq.z = -1.0;\n\t\t\t\tq.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n\n\t\t\t\t// Calculate the scaled plane vector\n\t\t\t\tclipPlane.multiplyScalar(2.0 / clipPlane.dot(q));\n\n\t\t\t\t// Replacing the third row of the projection matrix\n\t\t\t\tprojectionMatrix.elements[2] = clipPlane.x;\n\t\t\t\tprojectionMatrix.elements[6] = clipPlane.y;\n\t\t\t\tprojectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n\t\t\t\tprojectionMatrix.elements[14] = clipPlane.w;\n\n\t\t\t\t// Render\n\n\t\t\t\tscope.visible = false;\n\n\t\t\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\t\tvar currentXrEnabled = renderer.xr.enabled;\n\t\t\t\tvar currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\t\trenderer.xr.enabled = false; // Avoid camera modification\n\t\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n\t\t\t\trenderer.setRenderTarget(renderTarget);\n\n\t\t\t\trenderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n\t\t\t\tif (renderer.autoClear === false) renderer.clear();\n\t\t\t\trenderer.render(scene, virtualCamera);\n\n\t\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\t\t\trenderer.setRenderTarget(currentRenderTarget);\n\n\t\t\t\t// Restore viewport\n\n\t\t\t\tvar viewport = camera.viewport;\n\n\t\t\t\tif (viewport !== undefined) {\n\n\t\t\t\t\t\trenderer.state.viewport(viewport);\n\t\t\t\t}\n\n\t\t\t\tscope.visible = true;\n\t\t};\n\n\t\tthis.getRenderTarget = function () {\n\n\t\t\t\treturn renderTarget;\n\t\t};\n};\n\nTHREE.Reflector.prototype = Object.create(THREE.Mesh.prototype);\nTHREE.Reflector.prototype.constructor = THREE.Reflector;\n\nTHREE.Reflector.ReflectorShader = {\n\n\t\tuniforms: {\n\n\t\t\t\t'color': {\n\t\t\t\t\t\ttype: 'c',\n\t\t\t\t\t\tvalue: null\n\t\t\t\t},\n\n\t\t\t\t'tDiffuse': {\n\t\t\t\t\t\ttype: 't',\n\t\t\t\t\t\tvalue: null\n\t\t\t\t},\n\n\t\t\t\t'textureMatrix': {\n\t\t\t\t\t\ttype: 'm4',\n\t\t\t\t\t\tvalue: null\n\t\t\t\t}\n\n\t\t},\n\n\t\tvertexShader: ['uniform mat4 textureMatrix;', 'varying vec4 vUv;', 'void main() {', '\tvUv = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n\n\t\tfragmentShader: ['uniform vec3 color;', 'uniform sampler2D tDiffuse;', 'varying vec4 vUv;', 'float blendOverlay( float base, float blend ) {', '\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );', '}', 'vec3 blendOverlay( vec3 base, vec3 blend ) {', '\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );', '}', 'void main() {', '\tvec4 base = texture2DProj( tDiffuse, vUv );', '\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );', '}'].join('\\n')\n};\n\n//# sourceURL=webpack:///./src/material/specialMaterial/water/Reflector.js?")
        },
        "./src/material/specialMaterial/water/Refractor.js": /*!*********************************************************!*\
  !*** ./src/material/specialMaterial/water/Refractor.js ***!
  \*********************************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n *\r\n */\n\nTHREE.Refractor = function (geometry, options) {\n\n\t\tTHREE.Mesh.call(this, geometry);\n\n\t\tthis.type = 'Refractor';\n\n\t\tvar scope = this;\n\n\t\toptions = options || {};\n\n\t\tvar color = options.color !== undefined ? new THREE.Color(options.color) : new THREE.Color(0x7F7F7F);\n\t\tvar textureWidth = options.textureWidth || 512;\n\t\tvar textureHeight = options.textureHeight || 512;\n\t\tvar clipBias = options.clipBias || 0;\n\t\tvar shader = options.shader || THREE.Refractor.RefractorShader;\n\n\t\t//\n\n\t\tvar virtualCamera = new THREE.PerspectiveCamera();\n\t\tvirtualCamera.matrixAutoUpdate = false;\n\t\tvirtualCamera.userData.refractor = true;\n\n\t\t//\n\n\t\tvar refractorPlane = new THREE.Plane();\n\t\tvar textureMatrix = new THREE.Matrix4();\n\n\t\t// render target\n\n\t\tvar parameters = {\n\t\t\t\tminFilter: THREE.LinearFilter,\n\t\t\t\tmagFilter: THREE.LinearFilter,\n\t\t\t\tformat: THREE.RGBFormat,\n\t\t\t\tstencilBuffer: false\n\t\t};\n\n\t\tvar renderTarget = new THREE.WebGLRenderTarget(textureWidth, textureHeight, parameters);\n\n\t\tif (!THREE.MathUtils.isPowerOfTwo(textureWidth) || !THREE.MathUtils.isPowerOfTwo(textureHeight)) {\n\n\t\t\t\trenderTarget.texture.generateMipmaps = false;\n\t\t}\n\n\t\t// material\n\n\t\tthis.material = new THREE.ShaderMaterial({\n\t\t\t\tuniforms: THREE.UniformsUtils.clone(shader.uniforms),\n\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\t\ttransparent: true // ensures, refractors are drawn from farthest to closest\n\t\t});\n\n\t\tthis.material.uniforms.color.value = color;\n\t\tthis.material.uniforms.tDiffuse.value = renderTarget.texture;\n\t\tthis.material.uniforms.textureMatrix.value = textureMatrix;\n\n\t\t// functions\n\n\t\tvar visible = function () {\n\n\t\t\t\tvar refractorWorldPosition = new THREE.Vector3();\n\t\t\t\tvar cameraWorldPosition = new THREE.Vector3();\n\t\t\t\tvar rotationMatrix = new THREE.Matrix4();\n\n\t\t\t\tvar view = new THREE.Vector3();\n\t\t\t\tvar normal = new THREE.Vector3();\n\n\t\t\t\treturn function visible(camera) {\n\n\t\t\t\t\t\trefractorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n\t\t\t\t\t\tcameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n\n\t\t\t\t\t\tview.subVectors(refractorWorldPosition, cameraWorldPosition);\n\n\t\t\t\t\t\trotationMatrix.extractRotation(scope.matrixWorld);\n\n\t\t\t\t\t\tnormal.set(0, 0, 1);\n\t\t\t\t\t\tnormal.applyMatrix4(rotationMatrix);\n\n\t\t\t\t\t\treturn view.dot(normal) < 0;\n\t\t\t\t};\n\t\t}();\n\n\t\tvar updateRefractorPlane = function () {\n\n\t\t\t\tvar normal = new THREE.Vector3();\n\t\t\t\tvar position = new THREE.Vector3();\n\t\t\t\tvar quaternion = new THREE.Quaternion();\n\t\t\t\tvar scale = new THREE.Vector3();\n\n\t\t\t\treturn function updateRefractorPlane() {\n\n\t\t\t\t\t\tscope.matrixWorld.decompose(position, quaternion, scale);\n\t\t\t\t\t\tnormal.set(0, 0, 1).applyQuaternion(quaternion).normalize();\n\n\t\t\t\t\t\t// flip the normal because we want to cull everything above the plane\n\n\t\t\t\t\t\tnormal.negate();\n\n\t\t\t\t\t\trefractorPlane.setFromNormalAndCoplanarPoint(normal, position);\n\t\t\t\t};\n\t\t}();\n\n\t\tvar updateVirtualCamera = function () {\n\n\t\t\t\tvar clipPlane = new THREE.Plane();\n\t\t\t\tvar clipVector = new THREE.Vector4();\n\t\t\t\tvar q = new THREE.Vector4();\n\n\t\t\t\treturn function updateVirtualCamera(camera) {\n\n\t\t\t\t\t\tvirtualCamera.matrixWorld.copy(camera.matrixWorld);\n\t\t\t\t\t\tvirtualCamera.matrixWorldInverse.getInverse(virtualCamera.matrixWorld);\n\t\t\t\t\t\tvirtualCamera.projectionMatrix.copy(camera.projectionMatrix);\n\t\t\t\t\t\tvirtualCamera.far = camera.far; // used in WebGLBackground\n\n\t\t\t\t\t\t// The following code creates an oblique view frustum for clipping.\n\t\t\t\t\t\t// see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\n\t\t\t\t\t\t// Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\n\n\t\t\t\t\t\tclipPlane.copy(refractorPlane);\n\t\t\t\t\t\tclipPlane.applyMatrix4(virtualCamera.matrixWorldInverse);\n\n\t\t\t\t\t\tclipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant);\n\n\t\t\t\t\t\t// calculate the clip-space corner point opposite the clipping plane and\n\t\t\t\t\t\t// transform it into camera space by multiplying it by the inverse of the projection matrix\n\n\t\t\t\t\t\tvar projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t\t\t\t\tq.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n\t\t\t\t\t\tq.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n\t\t\t\t\t\tq.z = -1.0;\n\t\t\t\t\t\tq.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];\n\n\t\t\t\t\t\t// calculate the scaled plane vector\n\n\t\t\t\t\t\tclipVector.multiplyScalar(2.0 / clipVector.dot(q));\n\n\t\t\t\t\t\t// replacing the third row of the projection matrix\n\n\t\t\t\t\t\tprojectionMatrix.elements[2] = clipVector.x;\n\t\t\t\t\t\tprojectionMatrix.elements[6] = clipVector.y;\n\t\t\t\t\t\tprojectionMatrix.elements[10] = clipVector.z + 1.0 - clipBias;\n\t\t\t\t\t\tprojectionMatrix.elements[14] = clipVector.w;\n\t\t\t\t};\n\t\t}();\n\n\t\t// This will update the texture matrix that is used for projective texture mapping in the shader.\n\t\t// see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\n\n\t\tfunction updateTextureMatrix(camera) {\n\n\t\t\t\t// this matrix does range mapping to [ 0, 1 ]\n\n\t\t\t\ttextureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n\n\t\t\t\t// we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\n\t\t\t\t// (matrix above) with the projection and view matrix of the virtual camera\n\t\t\t\t// and the model matrix of the refractor\n\n\t\t\t\ttextureMatrix.multiply(camera.projectionMatrix);\n\t\t\t\ttextureMatrix.multiply(camera.matrixWorldInverse);\n\t\t\t\ttextureMatrix.multiply(scope.matrixWorld);\n\t\t}\n\n\t\t//\n\n\t\tfunction render(renderer, scene, camera) {\n\n\t\t\t\tscope.visible = false;\n\n\t\t\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\t\t\t\tvar currentXrEnabled = renderer.xr.enabled;\n\t\t\t\tvar currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\t\trenderer.xr.enabled = false; // avoid camera modification\n\t\t\t\trenderer.shadowMap.autoUpdate = false; // avoid re-computing shadows\n\n\t\t\t\trenderer.setRenderTarget(renderTarget);\n\t\t\t\tif (renderer.autoClear === false) renderer.clear();\n\t\t\t\trenderer.render(scene, virtualCamera);\n\n\t\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\t\t\t\trenderer.setRenderTarget(currentRenderTarget);\n\n\t\t\t\t// restore viewport\n\n\t\t\t\tvar viewport = camera.viewport;\n\n\t\t\t\tif (viewport !== undefined) {\n\n\t\t\t\t\t\trenderer.state.viewport(viewport);\n\t\t\t\t}\n\n\t\t\t\tscope.visible = true;\n\t\t}\n\n\t\t//\n\n\t\tthis.onBeforeRender = function (renderer, scene, camera) {\n\n\t\t\t\t// ensure refractors are rendered only once per frame\n\n\t\t\t\tif (camera.userData.refractor === true) return;\n\n\t\t\t\t// avoid rendering when the refractor is viewed from behind\n\n\t\t\t\tif (!visible(camera) === true) return;\n\n\t\t\t\t// update\n\n\t\t\t\tupdateRefractorPlane();\n\n\t\t\t\tupdateTextureMatrix(camera);\n\n\t\t\t\tupdateVirtualCamera(camera);\n\n\t\t\t\trender(renderer, scene, camera);\n\t\t};\n\n\t\tthis.getRenderTarget = function () {\n\n\t\t\t\treturn renderTarget;\n\t\t};\n};\n\nTHREE.Refractor.prototype = Object.create(THREE.Mesh.prototype);\nTHREE.Refractor.prototype.constructor = THREE.Refractor;\n\nTHREE.Refractor.RefractorShader = {\n\n\t\tuniforms: {\n\n\t\t\t\t'color': {\n\t\t\t\t\t\ttype: 'c',\n\t\t\t\t\t\tvalue: null\n\t\t\t\t},\n\n\t\t\t\t'tDiffuse': {\n\t\t\t\t\t\ttype: 't',\n\t\t\t\t\t\tvalue: null\n\t\t\t\t},\n\n\t\t\t\t'textureMatrix': {\n\t\t\t\t\t\ttype: 'm4',\n\t\t\t\t\t\tvalue: null\n\t\t\t\t}\n\n\t\t},\n\n\t\tvertexShader: ['uniform mat4 textureMatrix;', 'varying vec4 vUv;', 'void main() {', '\tvUv = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n\n\t\tfragmentShader: ['uniform vec3 color;', 'uniform sampler2D tDiffuse;', 'varying vec4 vUv;', 'float blendOverlay( float base, float blend ) {', '\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );', '}', 'vec3 blendOverlay( vec3 base, vec3 blend ) {', '\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );', '}', 'void main() {', '\tvec4 base = texture2DProj( tDiffuse, vUv );', '\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );', '}'].join('\\n')\n};\n\n//# sourceURL=webpack:///./src/material/specialMaterial/water/Refractor.js?")
        },
        "./src/material/specialMaterial/water/Water3.js": /*!******************************************************!*\
  !*** ./src/material/specialMaterial/water/Water3.js ***!
  \******************************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n *\r\n * References:\r\n *\thttp://www.valvesoftware.com/publications/2010/siggraph2010_vlachos_waterflow.pdf\r\n * \thttp://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html\r\n *\r\n */\n\nTHREE.Water3 = function (geometry, material) {\n\n        THREE.Mesh.call(this, geometry);\n\n        this.type = 'Water3';\n\n        if (!material) {\n                console.warn('there is not a water material');\n                return;\n        }\n        this.material = material;\n};\n\nTHREE.Water3.prototype = Object.create(THREE.Mesh.prototype);\nTHREE.Water3.prototype.constructor = THREE.Water3;\n\nTHREE.Water3.WaterShader = {\n\n        uniforms: {\n\n                'color': {\n                        type: 'c',\n                        value: null\n                },\n                'opacity': {\n                        type: 'f',\n                        value: 1.0\n                },\n                'reflectivity': {\n                        type: 'f',\n                        value: 0\n                },\n\n                'tReflectionMap': {\n                        type: 't',\n                        value: null\n                },\n\n                'tRefractionMap': {\n                        type: 't',\n                        value: null\n                },\n\n                'tNormalMap0': {\n                        type: 't',\n                        value: null\n                },\n\n                'tNormalMap1': {\n                        type: 't',\n                        value: null\n                },\n\n                'textureMatrix': {\n                        type: 'm4',\n                        value: null\n                },\n\n                'config': {\n                        type: 'v4',\n                        value: new THREE.Vector4()\n                },\n\n                'intensity': {\n                        type: 'f',\n                        value: 1.0\n                },\n\n                'metalness': {\n                        value: 0.0\n                },\n                'roughness': {\n                        value: 0.78\n                },\n                'specularFactor': {\n                        value: 1\n                }\n        },\n\n        defines: {\n                tReflectionMap: null,\n                tRefractionMap: null\n\n        },\n\n        vertexShader: ['#include <common>', '#include <shadowmap_pars_vertex>', '#include <fog_pars_vertex>', '#include <logdepthbuf_pars_vertex>', 'uniform mat4 textureMatrix;', '#ifdef USE_LIGHT', 'varying vec3 vViewPosition;', '#endif',\n\n        // 'varying vec4 vCoord;',\n        'varying vec2 vUv;', 'varying vec3 vToEye;', 'void main() {', '\tvUv = uv;',\n        // '\tvCoord = textureMatrix * vec4( position, 1.0 );',\n\n        '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tvToEye = cameraPosition - worldPosition.xyz;', '\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );', // used in fog_vertex\n        '#ifdef USE_LIGHT', 'vViewPosition = - mvPosition.xyz;', '#endif', '\tgl_Position = projectionMatrix * mvPosition;', 'vec3 transformedNormal = normalMatrix * vec3(normal);', '#include <shadowmap_vertex>', '\t#include <fog_vertex>', '#include <logdepthbuf_vertex>', '}'].join('\\n'),\n\n        fragmentShader: ['#include <common>', '#include <packing>', '#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', '#include <lightmap_pars_fragment>', '#include <bsdfs>', '#include <lights_pars_begin>', '#include <lights_physical_pars_fragment>', '#include <shadowmap_pars_fragment>', '#include <shadowmask_pars_fragment>', '#ifdef USE_LIGHT', 'varying vec3 vViewPosition;', '#endif', 'uniform vec3 diffuse;', 'uniform sampler2D tReflectionMap;', 'uniform sampler2D tRefractionMap;', 'uniform sampler2D tNormalMap0;', 'uniform sampler2D tNormalMap1;', '#ifdef USE_FLOWMAP', '\tuniform sampler2D tFlowMap;', '#else', '\tuniform vec2 flowDirection;', '#endif', 'uniform vec3 color;', 'uniform float opacity;', 'uniform float reflectivity;', 'uniform vec4 config;', 'uniform float metalness;', 'uniform float roughness;', 'uniform float specularFactor;',\n\n        // 'varying vec4 vCoord;',\n        'varying vec2 vUv;', 'varying vec3 vToEye;', 'void main() {', '#include <logdepthbuf_fragment>', '\tfloat flowMapOffset0 = config.x;', '\tfloat flowMapOffset1 = config.y;', '\tfloat halfCycle = config.z;', '\tfloat scale = config.w;', '\tvec3 toEye = normalize( vToEye );',\n\n        // determine flow direction\n        '\tvec2 flow;', '\t#ifdef USE_FLOWMAP', '\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;', '\t#else', '\t\tflow = flowDirection;', '\t#endif', '\tflow.x *= - 1.0;',\n\n        // sample normal maps (distort uvs with flowdata)\n        '\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * scale * flowMapOffset0 );', '\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * scale * flowMapOffset1 );',\n\n        // linear interpolate to get the final normal color\n        '\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;', '\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );',\n\n        // calculate normal vector\n        '\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );',\n\n        // calculate the fresnel term to blend reflection and refraction maps\n        '\tfloat theta = max( dot( toEye, normal ), 0.0 );', '\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );', 'vec2 uv = vec2(gl_FragCoord.x /1920.0, gl_FragCoord.y /978.0) + normal.xz * 0.05;', '\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );', '\tvec4 refractColor = texture2D( tRefractionMap, uv );', 'vec4 diffuseColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );', '#ifdef USE_LIGHT', 'ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );', 'float metalnessFactor = metalness;', 'float roughnessFactor = roughness;', 'vec3 geometryNormal = normal;', '#include <lights_physical_fragment>', '#include <lights_fragment_begin>', '#include <lights_fragment_maps>', '#include <lights_fragment_end>', 'vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;', 'outgoingLight = mix( outgoingLight, diffuseColor.rgb, 0.5 );', '#else', 'vec3 outgoingLight = diffuseColor.rgb;', '#endif', '\t#include <tonemapping_fragment>', '\t#include <encodings_fragment>', '\t#include <fog_fragment>',\n\n        // multiply water color with the mix of both textures\n        '\tgl_FragColor = vec4(outgoingLight, opacity);', '}'].join('\\n')\n};\n\n//# sourceURL=webpack:///./src/material/specialMaterial/water/Water3.js?")
        },
        "./src/material/specialMaterial/water/WaterMaterial3.js": /*!**************************************************************!*\
  !*** ./src/material/specialMaterial/water/WaterMaterial3.js ***!
  \**************************************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nvar _buffer = __webpack_require__(/*! ../../../util/buffer.js */ \"./src/util/buffer.js\");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nTHREE.WaterMaterial3 = function (options, materialName) {\n    var shader = THREE.Water3.WaterShader;\n    var material = new THREE.ShaderMaterial({\n        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib['fog'], THREE.UniformsLib['lights'], shader.uniforms]),\n        vertexShader: shader.vertexShader,\n        fragmentShader: shader.fragmentShader,\n        transparent: true,\n        fog: true,\n        lights: true,\n        defines: {\n            'USE_LIGHT': true\n        }\n    });\n    material.type = 'water3';\n\n    options = options || {};\n\n    var color = options.color !== undefined ? new THREE.Color(options.color) : new THREE.Color(0xFFFFFF);\n    var opacity = THING.Utils.parseValue(options.opacity, 1.0);\n    var flowDirection = THING.Utils.parseValue(options.flowDirection, new THREE.Vector2(1, 0));\n    var flowSpeed = THING.Utils.parseValue(options.flowSpeed, 1.0);\n    var reflectivity = THING.Utils.parseValue(options.reflectivity, 0.3);\n    var scale = THING.Utils.parseValue(options.scale, 1);\n    var intensity = THING.Utils.parseValue(options.intensity, 1.0);\n\n    var textureMatrix = new THREE.Matrix4();\n\n    var flowMap = options.flowMap || undefined;\n    var normalMap0 = options.normalMap0;\n    var normalMap1 = options.normalMap1;\n\n    var cycle = 0.15; // a cycle of a flow map phase\n    var halfCycle = cycle * 0.5;\n\n    // internal components\n\n    // material\n    if (!material) {\n        console.error('There is not a waterMaterial');\n        return;\n    }\n\n    if (flowMap !== undefined) {\n\n        material.defines.USE_FLOWMAP = '';\n        material.uniforms.tFlowMap = {\n            type: 't',\n            value: flowMap\n        };\n    } else {\n\n        material.uniforms.flowDirection = {\n            type: 'v2',\n            value: flowDirection\n        };\n    }\n\n    // maps\n\n    normalMap0.wrapS = normalMap0.wrapT = THREE.RepeatWrapping;\n    normalMap1.wrapS = normalMap1.wrapT = THREE.RepeatWrapping;\n\n    material.uniforms.tReflectionMap.value = options.tReflectionMap;\n    material.uniforms.tRefractionMap.value = options.tRefractionMap;\n    material.uniforms.tNormalMap0.value = normalMap0;\n    material.uniforms.tNormalMap1.value = normalMap1;\n\n    // water\n\n    material.uniforms.color.value = color;\n    material.uniforms.opacity.value = opacity;\n    material.uniforms.reflectivity.value = reflectivity;\n\n    material.uniforms.textureMatrix.value = textureMatrix;\n    material.uniforms.intensity.value = intensity;\n\n    // inital values\n\n    material.uniforms.config.value.x = 0; // flowMapOffset0\n    material.uniforms.config.value.y = halfCycle; // flowMapOffset1\n    material.uniforms.config.value.z = halfCycle; // halfCycle\n    material.uniforms.config.value.w = scale; // scale\n\n    this.material = material;\n    this.cycle = cycle;\n    this.halfCycle = halfCycle;\n\n    // var task = {\n    //     update: function () {\n    //         updateFlow(material, flowSpeed, cycle, halfCycle);\n    //         buffer.bigDirty = true;\n    //     }\n    // };\n    // buffer._renderList.add(materialName, task);\n\n    return this.material;\n};\n//water材质拥有updateFlow接口\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n *\r\n * References:\r\n *\thttp://www.valvesoftware.com/publications/2010/siggraph2010_vlachos_waterflow.pdf\r\n * \thttp://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html\r\n *\r\n */\nTHREE.Material.prototype.updateFlow = function (speed, materialName) {\n    if (this.type !== 'water3') return;\n    var task = _buffer2.default._renderList.get(materialName);\n    var material = this;\n    var cycle = material.uniforms.config.value.z * 2.0;\n    var halfCycle = material.uniforms.config.value.z;\n    if (!task) {\n        task = {\n            update: function update() {\n                updateFlow(material, speed, cycle, halfCycle);\n                _buffer2.default.bigDirty = true;\n            }\n        };\n    } else {\n        task.update = null;\n        task = {\n            update: function update() {\n                updateFlow(material, speed, cycle, halfCycle);\n                _buffer2.default.bigDirty = true;\n            }\n        };\n    }\n    _buffer2.default._renderList.add(materialName, task);\n};\nfunction updateFlow(material, flowSpeed, cycle, halfCycle) {\n    var config = material.uniforms.config;\n    config.value.x += 0.001 * flowSpeed; // flowMapOffset0\n    config.value.y = config.value.x + halfCycle; // flowMapOffset1\n    // Important: The distance between offsets should be always the value of \"halfCycle\".\n    // Moreover, both offsets should be in the range of [ 0, cycle ].\n    // This approach ensures a smooth water flow and avoids \"reset\" effects.\n\n    if (config.value.x >= cycle) {\n\n        config.value.x = 0;\n        config.value.y = halfCycle;\n    } else if (config.value.y >= cycle) {\n\n        config.value.y = config.value.y - cycle;\n    }\n    // material.uniforms.time.value += 1/100000;\n}\n\n//# sourceURL=webpack:///./src/material/specialMaterial/water/WaterMaterial3.js?")
        },
        "./src/material/textureFilterOptions.js": /*!**********************************************!*\
  !*** ./src/material/textureFilterOptions.js ***!
  \**********************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n\tvalue: true\n});\n/**\r\n * 每个伟大的工程背后都有一堆乱七八糟的变量，或者常量\r\n * sample_hello_texture.html有使用，好像是控制材质什么东西的，还不清楚是什么意思呢\r\n */\nexports.default = {\n\t/** Equal to: min=FO_POINT, mag=FO_POINT, mip=FO_NONE */\n\tNONE: 0,\n\t/** Equal to: min=FO_LINEAR, mag=FO_LINEAR, mip=FO_POINT */\n\tBILINEAR: 1,\n\t/** Equal to: min=FO_LINEAR, mag=FO_LINEAR, mip=FO_LINEAR */\n\tTRILINEAR: 2,\n\t/** Equal to: min=FO_ANISOTROPIC, max=FO_ANISOTROPIC, mip=FO_LINEAR */\n\tANISOTROPIC: 3\n};\n\n//# sourceURL=webpack:///./src/material/textureFilterOptions.js?')
        },
        "./src/material/textureManager.js": /*!****************************************!*\
  !*** ./src/material/textureManager.js ***!
  \****************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _buffer = __webpack_require__(/*! ../util/buffer.js */ "./src/util/buffer.js");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _storage = __webpack_require__(/*! ../loader/storage.js */ "./src/loader/storage.js");\n\nvar _storage2 = _interopRequireDefault(_storage);\n\nvar _ScrollAnimation = __webpack_require__(/*! ../animation/ScrollAnimation.js */ "./src/animation/ScrollAnimation.js");\n\nvar _ScrollAnimation2 = _interopRequireDefault(_ScrollAnimation);\n\nvar _RotationAnimation = __webpack_require__(/*! ../animation/RotationAnimation.js */ "./src/animation/RotationAnimation.js");\n\nvar _RotationAnimation2 = _interopRequireDefault(_RotationAnimation);\n\nvar _ScaleAnimation = __webpack_require__(/*! ../animation/ScaleAnimation.js */ "./src/animation/ScaleAnimation.js");\n\nvar _ScaleAnimation2 = _interopRequireDefault(_ScaleAnimation);\n\nvar _MultiTexutureAnimation = __webpack_require__(/*! ../animation/MultiTexutureAnimation.js */ "./src/animation/MultiTexutureAnimation.js");\n\nvar _MultiTexutureAnimation2 = _interopRequireDefault(_MultiTexutureAnimation);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n    getTexture: function getTexture(name) {\n        return _buffer2.default.textureBuffer.get(name);\n    },\n    destroyTexture: function destroyTexture(name) {\n        // 这个不能打开，里面有恶魔\n    },\n    loadBlob: function loadBlob(blobUrl, texName, callback) {\n        var textureLoader = new THREE.TextureLoader();\n        textureLoader.load(blobUrl, function (texture) {\n            _buffer2.default.textureBuffer.add(texName, texture);\n            callback(texture);\n        });\n    },\n    loadFile: function loadFile(texName, filename, groupName, numMips) {\n        var img = _storage2.default.getFile(filename);\n        var texture = new THREE.Texture(img);\n        texture.anisotropy = 16;\n        texture.needsUpdate = true;\n        // texture.image = img;\n        _buffer2.default.textureBuffer.add(texName, texture);\n    },\n    hasTexture: function hasTexture(name) {\n        var flag = false;\n        if (_buffer2.default.textureBuffer.get(name)) {\n            flag = true;\n        }\n        return flag;\n    },\n    setScrollAnimation: function setScrollAnimation(material, tex) {\n        var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        var y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n        if (!tex) return;\n        x = -x / 50;\n        y = -y / 50;\n        var task = new _ScrollAnimation2.default(material, tex, [x, y]);\n        return task;\n    },\n    setRotateAnimation: function setRotateAnimation(material, tex, angle) {\n        if (!tex) return;\n        angle = angle / 50;\n        tex.center = new THREE.Vector2(0.5, 0.5);\n        var task = new _RotationAnimation2.default(material, tex, angle);\n        return task;\n    },\n    setScaleAnimation: function setScaleAnimation(material, tex, scale) {\n        if (!tex) return;\n        scale = scale / 50;\n        tex.center = new THREE.Vector2(0.5, 0.5);\n        var task = new _ScaleAnimation2.default(material, tex, scale);\n        return task;\n    },\n\n    //TODO 材质动画\n    setTextureAnimation: function setTextureAnimation(material, texture, tilesHoriz, tilesVert, numTiles, tileDispDuration) {\n        if (!texture) return;\n        tileDispDuration = tileDispDuration / 50 || 0.02;\n        var task = new _MultiTexutureAnimation2.default(material, texture, tilesHoriz, tilesVert, numTiles, tileDispDuration);\n        // var tilesHorizontal = tilesHoriz;\n        // var tilesVertical = tilesVert;\n        // var numberOfTiles = numTiles;\n        // texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n        // texture.repeat.set( 1 / tilesHorizontal, 1 / tilesVertical );\n        // var currentTile = 0;\n        // var task = {\n        //     update: function () {\n        //         currentTile += tileDispDuration;\n        //         if (currentTile >= numberOfTiles){\n        //             currentTile = 0;\n        //         }\n        //         var currentColumn = currentTile % 1;\n        //         currentColumn = Math.floor(currentColumn*tilesHorizontal);\n        //         texture.offset.x = currentColumn/tilesHorizontal;\n        //\n        //         var currentRow = Math.floor( currentTile );\n        //         texture.offset.y = currentRow / tilesVertical;\n        //     }\n        // };\n        // var name = texture.name;\n        // buffer._renderList.add(name, task);\n        return task;\n    },\n    getTextureAnimation: function getTextureAnimation(name) {\n        return _buffer2.default._textureAnimation.get(name);\n    },\n    setAnimation: function setAnimation(texName, material, animName, data, texture) {\n        var tex;\n        var task;\n        var curName;\n        switch (texName) {\n            case "baseColorTexture":\n                tex = material.map;\n                curName = \'map\';\n                break;\n            case "emissiveTexture":\n                tex = material.emissiveMap;\n                curName = \'emissiveMap\';\n                break;\n            case "normalTexture":\n                tex = material.normalMap;\n                curName = \'normalMap\';\n                break;\n            case "maskTexture":\n                tex = material.alphaMap1;\n                curName = \'alphaMap1\';\n                break;\n            default:\n                tex = null;\n                curName = \'\';\n        }\n        if (!tex) return null;\n        switch (animName) {\n            case "scrollAnim":\n                if (!data.speed) {\n                    task = this.setScrollAnimation(material, tex, data[0], data[1]);\n                    task.setCirculation(0);\n                } else {\n                    task = this.setScrollAnimation(material, tex, data.speed[0], data.speed[1]);\n                    task.setCirculation(data.loop);\n                    task.setAnimationOption(data.A, data.T);\n                }\n\n                break;\n            case "rotateAnim":\n                if (!data.speed) {\n                    task = this.setRotateAnimation(material, tex, data);\n                    task.setCirculation(0);\n                } else {\n                    task = this.setRotateAnimation(material, tex, data.speed);\n                    task.setCirculation(data.loop);\n                    task.setAnimationOption(data.A, data.T);\n                }\n                break;\n            case "scaleAnim":\n                if (!data.speed) {\n                    task = this.setScaleAnimation(material, tex, data);\n                    task.setCirculation(0);\n                } else {\n                    task = this.setScaleAnimation(material, tex, data.speed);\n                    task.setCirculation(data.loop);\n                    task.setAnimationOption(data.A, data.T);\n                }\n                break;\n            case "multiFramesAnim":\n                var nums = data.tilesX * data.tilesY;\n                task = this.setTextureAnimation(material, tex, data.tilesX, data.tilesY, nums, data.animSpeed);\n                task.setCirculation(data.loop);\n                task.setRandom(data.random);\n                break;\n            default:\n                task = null;\n        }\n        if (curName && task && texture) {\n            task.changeTexture(curName, texture);\n        }\n        if (task) {\n            task.setInterval(data.interval * 50 || 0);\n        }\n        return task;\n    }\n};\n\n//# sourceURL=webpack:///./src/material/textureManager.js?')
        },
        "./src/node/CombineBasicProvider.js": /*!******************************************!*\
  !*** ./src/node/CombineBasicProvider.js ***!
  \******************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _CombineMeshProvider = __webpack_require__(/*! ./CombineMeshProvider.js */ \"./src/node/CombineMeshProvider.js\");\n\nvar _CombineMeshProvider2 = _interopRequireDefault(_CombineMeshProvider);\n\nvar _helper = __webpack_require__(/*! ../util/helper.js */ \"./src/util/helper.js\");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//basicProvider: merge object by the same material\nvar CombineBasicProvider = function () {\n    function CombineBasicProvider(name, attach, removeLast) {\n        _classCallCheck(this, CombineBasicProvider);\n\n        this.name = name || 'combine' + _helper2.default.getUUID();\n        this.meshCache = {};\n        this.matCache = {};\n        this.type = 'basic';\n        this.objects = [];\n        this.CombineMeshProviderFactory = [];\n        this.combineObject = null;\n        this.attach = attach || false;\n        this.removeLast = removeLast || false;\n        this.count = 0;\n        this.root = null;\n    }\n\n    _createClass(CombineBasicProvider, [{\n        key: '_getObject',\n        value: function _getObject(matName) {\n            return this.meshCache[matName];\n        }\n    }, {\n        key: '_addObject',\n        value: function _addObject(mesh, matName) {\n            if (this._getObject(matName)) {\n                this.meshCache[matName].push(mesh);\n            } else {\n                this.meshCache[matName] = [];\n                this.meshCache[matName].push(mesh);\n            }\n        }\n    }, {\n        key: '_getMaterial',\n        value: function _getMaterial(matName) {\n            return this.matCache[matName];\n        }\n    }, {\n        key: '_addMaterial',\n        value: function _addMaterial(material, matName) {\n            if (!this._getMaterial(matName)) {\n                this.matCache[matName] = material;\n            }\n        }\n    }, {\n        key: '_load',\n        value: function _load() {\n            var that = this;\n            var array = this.objects;\n            if (array.length < 1) {\n                console.log('请加入需要合并的物体');\n                return;\n            }\n            array.map(function (v) {\n\n                // v.updateMatrixWorld();\n                // var matrixWorld = v.matrixWorld;\n                v.traverse(function (object) {\n                    if (object instanceof THREE.Mesh) {\n                        //更新最新的基于世界的object用于合并\n                        that._updateWorldMesh(object);\n                        var mat = object.material;\n                        var matName = mat.uuid;\n                        that._addMaterial(mat, matName);\n                        that._addObject(object, matName);\n                    }\n                });\n            });\n        }\n    }, {\n        key: '_updateWorldMesh',\n        value: function _updateWorldMesh(object, matrixWorld) {\n            // var newObj = object.clone();\n            object.updateMatrixWorld();\n            object._geometry = object.geometry.clone();\n            // if(object.parent){\n            //     object._geometry.applyMatrix(object.parent.matrixWorld);\n            // }\n            object._geometry.applyMatrix(object.matrixWorld);\n            // object._geometry.applyMatrix(matrixWorld);\n            return object;\n        }\n        //构建合并材质工厂\n\n    }, {\n        key: '_createCombineMeshProviderFactory',\n        value: function _createCombineMeshProviderFactory() {\n            var matCache = this.matCache;\n            for (var k in matCache) {\n                this.CombineMeshProviderFactory.push(new _CombineMeshProvider2.default(matCache[k]));\n            }\n        }\n    }, {\n        key: 'addObjects',\n        value: function addObjects(array) {\n            for (var i = 0; i < array.length; i++) {\n                this.objects.push(array[i]);\n            }\n        }\n    }, {\n        key: '_getRoot',\n        value: function _getRoot() {\n            if (this.objects.length > 0) {\n                this.root = this.objects[0].parent;\n            }\n        }\n    }, {\n        key: '_attachNode',\n        value: function _attachNode(parentNode, childNode) {\n            parentNode.updateMatrixWorld();\n            var mm = new THREE.Matrix4();\n            var reverseMatrix = mm.getInverse(parentNode.matrixWorld);\n            childNode.applyMatrix(reverseMatrix);\n            parentNode.add(childNode);\n        }\n    }, {\n        key: '_removeLast',\n        value: function _removeLast() {\n            var objects = this.objects;\n            objects.map(function (v) {\n                var p = v.parent;\n                if (p) {\n                    p.remove(v);\n                } else {\n                    console.error('cannot remove' + p.name);\n                }\n            });\n        }\n    }, {\n        key: 'getTriangleCount',\n        value: function getTriangleCount() {\n            return this.count;\n        }\n    }, {\n        key: 'merge',\n        value: function merge() {\n            this._load();\n            this._createCombineMeshProviderFactory();\n            var that = this;\n            var newNode = new THREE.Object3D();\n            newNode.name = this.name;\n            this.combineObject = newNode;\n            if (this.attach) {\n                this._getRoot();\n                if (this.root) {\n                    this._attachNode(this.root, newNode);\n                }\n            }\n            //只输出第一个\n            // for(var k in this.meshCache){\n            //     var obj = this.meshCache[k][0];\n            //     obj.geometry = obj._geometry;\n            //     newNode.add(obj);\n            // }\n            this.CombineMeshProviderFactory.map(function (v) {\n                var name = v.getName();\n                var meshes = that.meshCache[name];\n                v.addObjects(meshes);\n                newNode.add(v.build());\n                that.count += v.getTriangleCount();\n            });\n\n            if (this.removeLast) {\n                this._removeLast();\n            }\n            console.log('triangle count:' + that.count);\n            return newNode;\n        }\n    }]);\n\n    return CombineBasicProvider;\n}();\n\nexports.default = CombineBasicProvider;\n\n//# sourceURL=webpack:///./src/node/CombineBasicProvider.js?")
        },
        "./src/node/CombineMeshProvider.js": /*!*****************************************!*\
  !*** ./src/node/CombineMeshProvider.js ***!
  \*****************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _helper = __webpack_require__(/*! ../util/helper.js */ \"./src/util/helper.js\");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nvar _Material = __webpack_require__(/*! ../material/Material.js */ \"./src/material/Material.js\");\n\nvar _Material2 = _interopRequireDefault(_Material);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//合并mesh类\n//你需要传入相同材质的基于世界坐标的geometry\nvar CombineMeshProvider = function () {\n    function CombineMeshProvider(material) {\n        _classCallCheck(this, CombineMeshProvider);\n\n        this.vertexCount = 0;\n        this.indexCount = 0;\n        this.material = material;\n        this.name = material.uuid;\n        this.bundeMeshs = [];\n        //对应的mesh的相对仿射信息\n        //this.transformations = [];\n        this.maxCount = 60000; //三角面数\n        this.count = 0;\n        this.combineMesh = null;\n    }\n\n    _createClass(CombineMeshProvider, [{\n        key: 'getName',\n        value: function getName() {\n            return this.name;\n        }\n    }, {\n        key: 'isExceed',\n        value: function isExceed(num) {\n            var count = this.vertexCount + num;\n            if (count > this.maxCount) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }, {\n        key: 'add',\n        value: function add(bundleMesh) {\n            var allCount = 0;\n            bundleMesh.vertexCount = bundleMesh._geometry.getAttribute('position').array.length / 3;\n            bundleMesh.indexCount = bundleMesh._geometry.index.array.length;\n\n            //加入一些属性\n\n            // for(var i = 0;i<bundleMeshs.length;i++){\n            //     allCount+=bundleMeshs[i].vertexCount;\n            // }\n            if (this.isExceed(bundleMesh.vertexCount)) {\n                console.error('combine exceed vertex count ' + this.maxCount);\n                return false;\n            }\n            // for(var i = 0;i<bundleMeshs.length;i++){\n            //     var bundleMesh=bundleMeshs[i];\n            this.vertexCount += bundleMesh.vertexCount;\n            this.indexCount += bundleMesh.indexCount;\n            this.bundeMeshs.push(bundleMesh);\n            //this.transformations.push(transformation);\n            // }\n        }\n    }, {\n        key: 'addObjects',\n        value: function addObjects(array) {\n            for (var i = 0; i < array.length; i++) {\n                this.add(array[i]);\n            }\n        }\n    }, {\n        key: 'getTriangleCount',\n        value: function getTriangleCount() {\n            return this.count;\n        }\n    }, {\n        key: 'build',\n        value: function build() {\n            var oneMaxArray = this.bundeMeshs;\n            var idxCount = this.indexCount; // oneMaxArray.pop();\n            var count = this.vertexCount; //oneMaxArray.pop();\n            this.count = count;\n            //console.log(count);\n            var sumPosArr = new Float32Array(count * 3);\n            var sumNormArr = new Float32Array(count * 3);\n            var sumUvArr = new Float32Array(count * 2);\n            var sumColorArr = new Float32Array(count * 4);\n            var sumAlphaArr = new Float32Array(count);\n            var sumUv2Arr = new Float32Array(count * 2);\n            var sumIdxArr = new Uint16Array(idxCount);\n            var sumPosCursor = 0;\n            var sumNormCursor = 0;\n            var sumUvCursor = 0;\n            var sumIdxCursor = 0;\n            var sumColorCursor = 0;\n            var sumAlphaCursor = 0;\n            var combineGeometry = new THREE.BufferGeometry();\n\n            for (var j = 0; j < oneMaxArray.length; j++) {\n                var obj = oneMaxArray[j];\n                //var transformation = this.transformations[j];\n                // var localPositions = transformation.positions;\n                // var localScales = transformation.scales;\n                // var localRots = transformation.quaternions;\n                var idxAttArr = obj._geometry.index.array; // obj.geometry.index.array;\n                for (var b = 0; b < idxAttArr.length; b++) {\n                    sumIdxArr[b + sumIdxCursor] = sumPosCursor / 3 + idxAttArr[b];\n                }\n                sumIdxCursor += idxAttArr.length;\n                if (obj._geometry.getAttribute('position')) {\n                    var posAttArr = obj._geometry.getAttribute('position').array; // obj.geometry.getAttribute('position').array;\n                    for (var b1 = 0; b1 < posAttArr.length;) {\n                        var vec = new THREE.Vector3(posAttArr[b1], posAttArr[b1 + 1], posAttArr[b1 + 2]);\n                        // for(var i = localPositions.length-1;i>-1;i--){\n                        //     var pos = localPositions[i];\n                        //     var scale = localScales[i];\n                        //     var rot = localRots[i];\n                        //     vec.x*=scale.x;\n                        //     vec.y*=scale.y;\n                        //     vec.z*=scale.z;\n                        //     vec = vec.applyQuaternion(rot);\n                        //     vec.x+=pos.x;\n                        //     vec.y+=pos.y;\n                        //     vec.z+=pos.z;\n                        // }\n                        sumPosArr[b1 + sumPosCursor] = vec.x;\n                        sumPosArr[b1 + sumPosCursor + 1] = vec.y;\n                        sumPosArr[b1 + sumPosCursor + 2] = vec.z;\n                        b1 += 3;\n                    }\n                    sumPosCursor += posAttArr.length;\n                }\n                if (obj._geometry.getAttribute('normal')) {\n                    var numAttArr = obj._geometry.getAttribute('normal').array; // obj.geometry.getAttribute('normal').array;\n                    for (var b2 = 0; b2 < numAttArr.length; b2++) {\n                        sumNormArr[b2 + sumNormCursor] = numAttArr[b2];\n                    }\n                    sumNormCursor += numAttArr.length;\n                }\n                var uvAttArr = obj._geometry.getAttribute('uv') ? obj._geometry.getAttribute('uv').array : []; // obj.geometry.getAttribute('uv').array;\n                if (uvAttArr) {\n                    for (var b3 = 0; b3 < uvAttArr.length; b3++) {\n                        sumUvArr[b3 + sumUvCursor] = uvAttArr[b3];\n                    }\n\n                    var uv2AttrArr = obj._geometry.getAttribute('uv2') ? obj._geometry.getAttribute('uv2').array : [];\n                    if (uv2AttrArr) {\n                        for (var b4 = 0; b4 < uv2AttrArr.length; b4++) {\n                            sumUv2Arr[b4 + sumUvCursor] = uv2AttrArr[b4];\n                        }\n                    }\n                    if (uvAttArr) {\n                        sumUvCursor += uvAttArr.length;\n                    }\n\n                    var colorAttrArr = obj._geometry.getAttribute('color') ? obj._geometry.getAttribute('color').array : [];\n                    if (colorAttrArr) {\n                        for (var b5 = 0; b5 < colorAttrArr.length; b5++) {\n                            sumColorArr[b5 + sumColorCursor] = colorAttrArr[b5];\n                        }\n                        sumColorCursor += colorAttrArr.length;\n                    }\n\n                    //added alphaIndex\n                    var alphaIndex = obj._geometry.getAttribute('alphaIndex') ? obj._geometry.getAttribute('alphaIndex').array : [];\n                    if (alphaIndex) {\n                        for (var b6 = 0; b6 < alphaIndex.length; b6++) {\n                            sumAlphaArr[b6 + sumAlphaCursor] = alphaIndex[b6];\n                        }\n                        sumAlphaCursor += alphaIndex.length;\n                    }\n                }\n            }\n            combineGeometry.addAttribute('position', new THREE.BufferAttribute(sumPosArr, 3));\n            combineGeometry.addAttribute('normal', new THREE.BufferAttribute(sumNormArr, 3));\n            combineGeometry.addAttribute('uv', new THREE.BufferAttribute(sumUvArr, 2));\n            if (sumUv2Arr.length !== 0) {\n                combineGeometry.addAttribute('uv2', new THREE.BufferAttribute(sumUv2Arr, 2));\n            }\n            if (sumColorArr.length !== 0) {\n                combineGeometry.addAttribute('color', new THREE.BufferAttribute(sumColorArr, 4));\n            }\n            if (sumAlphaArr.length !== 0) {\n                combineGeometry.addAttribute('alphaIndex', new THREE.BufferAttribute(sumAlphaArr, 1));\n            }\n            combineGeometry.setIndex(new THREE.BufferAttribute(sumIdxArr, 1));\n\n            var combineMesh = new THREE.Mesh(combineGeometry, this.material);\n            //added by zhgu 增加t3d材质\n            var t3dMat = new _Material2.default();\n            t3dMat.getTechnique(0).getPass(0).material = this.material;\n            combineMesh.t3dMaterial = t3dMat;\n\n            combineMesh.name = 'combineChild' + _helper2.default.getUUID();\n            this.combineMesh = combineMesh;\n            return this.combineMesh;\n            // combineNodes.push(combineMesh);\n        }\n    }]);\n\n    return CombineMeshProvider;\n}();\n\nexports.default = CombineMeshProvider;\n\n//# sourceURL=webpack:///./src/node/CombineMeshProvider.js?")
        },
        "./src/node/Object3D.Extend.js": /*!*************************************!*\
  !*** ./src/node/Object3D.Extend.js ***!
  \*************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nvar _materialFactory = __webpack_require__(/*! ../material/materialFactory.js */ \"./src/material/materialFactory.js\");\n\nvar _materialFactory2 = _interopRequireDefault(_materialFactory);\n\nvar _materialManager = __webpack_require__(/*! ../material/materialManager.js */ \"./src/material/materialManager.js\");\n\nvar _materialManager2 = _interopRequireDefault(_materialManager);\n\nvar _buffer = __webpack_require__(/*! ../util/buffer.js */ \"./src/util/buffer.js\");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _sourceThreeFunction = __webpack_require__(/*! ../material/sourceThreeFunction.js */ \"./src/material/sourceThreeFunction.js\");\n\nvar _sourceThreeFunction2 = _interopRequireDefault(_sourceThreeFunction);\n\nvar _helper = __webpack_require__(/*! ../util/helper.js */ \"./src/util/helper.js\");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nvar _camera = __webpack_require__(/*! ../camera/camera */ \"./src/camera/camera.js\");\n\nvar _camera2 = _interopRequireDefault(_camera);\n\n__webpack_require__(/*! ../extra/GPUParticleSystem.js */ \"./src/extra/GPUParticleSystem.js\");\n\nvar _modifierManager = __webpack_require__(/*! ../selection/modifierManager.js */ \"./src/selection/modifierManager.js\");\n\nvar _modifierManager2 = _interopRequireDefault(_modifierManager);\n\nvar _SceneNodeSelection = __webpack_require__(/*! ../selection/SceneNodeSelection.js */ \"./src/selection/SceneNodeSelection.js\");\n\nvar _SceneNodeSelection2 = _interopRequireDefault(_SceneNodeSelection);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nTHREE.Object3D.prototype.pickEnabled = true;\n// import compositorBuffer from '../compositor/compositorBuffer.js';\n// import compositorStrategy from '../compositor/compositorStrategy.js';\n\nTHREE.Object3D.prototype.queryFlag = 1;\nTHREE.Object3D.prototype.getParent = function () {\n    return this.parent;\n};\n\n//为了简单起见，先构建一个简单的事件管理机制，后续需要整理,目前我们需要区分出三种更新状态，立即执行机制immediate，add机制，还有changed机制\nvar MsgCenter = new THREE.EventDispatcher();\nMsgCenter.addEventListener('staticAdded', function (event) {\n    if (_buffer2.default.static && event.obj) {\n        event.obj.traverse(function (v) {\n            if (v.type !== 'PerspectiveCamera' && v.name !== '_cameraNodeTmp_') {\n                v._staticDirty = true;\n                v._changeAABB = true;\n            }\n        });\n    }\n});\nMsgCenter.addEventListener('staticChanged', function (event) {\n    if (_buffer2.default.static && event.obj) {\n        //buffer.frameManager.add(event.obj, 'staticChanged');\n        event.obj.traverse(function (v) {\n            if (v.type !== 'PerspectiveCamera' && v.name !== '_cameraNodeTmp_') {\n                v._staticDirty = true;\n                v._changeAABB = true;\n            }\n        });\n    }\n});\n//立即执行机制直接进行更新，普通机制我们可以在这一帧集体更新\nMsgCenter.addEventListener('immediateChanged', function (event) {\n    if (event.obj instanceof Array) {\n        event.obj.map(function (v) {\n            v.updateMatrixWorld();\n        });\n    } else {\n        event.obj.updateMatrixWorld();\n    }\n});\nTHREE.EventCenter = MsgCenter;\n\nTHREE.Object3D.prototype.yaw = function (degree, isWorld) {\n    isWorld = isWorld === undefined ? false : isWorld;\n    var radians = degree / 180;\n    radians = radians * Math.PI;\n    if (isWorld) {\n        this.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), radians);\n    } else {\n        this.rotateY(radians);\n    }\n    if (this.material) {\n        _buffer2.default.bigDirty = true;\n    }\n\n    if (THREE.EventCenter !== undefined) {\n        THREE.EventCenter.dispatchEvent({ type: 'staticChanged', obj: this });\n    }\n};\n\nTHREE.Object3D.prototype.roll = function (degree, isWorld) {\n    isWorld = isWorld === undefined ? false : isWorld;\n\n    var radians = degree / 180;\n    radians = radians * Math.PI;\n    if (isWorld) {\n        this.rotateOnWorldAxis(new THREE.Vector3(0, 0, 1), radians);\n    } else {\n        this.rotateZ(radians);\n    }\n\n    if (this.material) {\n        _buffer2.default.bigDirty = true;\n    }\n\n    if (THREE.EventCenter !== undefined) {\n        THREE.EventCenter.dispatchEvent({ type: 'staticChanged', obj: this });\n    }\n};\n\nTHREE.Object3D.prototype.pitch = function (degree, isWorld) {\n    isWorld = isWorld === undefined ? false : isWorld;\n    var radians = degree / 180;\n    radians = radians * Math.PI;\n    if (isWorld) {\n        this.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), radians);\n    } else {\n        this.rotateX(radians);\n    }\n    if (this.material) {\n        _buffer2.default.bigDirty = true;\n    }\n\n    if (THREE.EventCenter !== undefined) {\n        THREE.EventCenter.dispatchEvent({ type: 'staticChanged', obj: this });\n    }\n};\n\nTHREE.Object3D.prototype.getWorldAABB = function () {\n    var box3 = this._recursionAABB(this);\n    var center = new THREE.Vector3();\n    box3.getCenter(center);\n    if (!center.x && !center.y && !center.z) {\n        center.x = 0;\n        center.y = 0;\n        center.z = 0;\n    }\n    var size = new THREE.Vector3();\n    box3.getSize(size);\n    return {\n        center: [center.x, center.y, center.z],\n        radius: Math.sqrt(Math.pow(size.x, 2) + Math.pow(size.y, 2) + Math.pow(size.z, 2)) / 2,\n        width: size.x,\n        height: size.y,\n        depth: size.z\n\n    };\n};\n\nTHREE.Object3D.prototype._recursionAABB = function (node) {\n    var box3 = new THREE.Box3();\n    box3.setFromObject(node);\n    return box3;\n};\n\nTHREE.Object3D.prototype.setPickEnabled = function (bool) {\n    if (bool) {\n        this.pickEnabled = true;\n    } else {\n        this.pickEnabled = false;\n    }\n};\n\nTHREE.Object3D.prototype.getSelfWorldAABB = function () {\n    if (this.geometry) {\n        this.geometry.computeBoundingBox();\n\n        var box3 = this.geometry.boundingBox;\n        var center = new THREE.Vector3();\n        box3.getCenter(center);\n        if (!center.x && !center.y && !center.z) {\n            center.x = 0;\n            center.y = 0;\n            center.z = 0;\n        }\n        var size = new THREE.Vector3();\n        box3.getSize(size);\n        return {\n            center: [center.x, center.y, center.z],\n            radius: Math.sqrt(Math.pow(size.x, 2) + Math.pow(size.y, 2) + Math.pow(size.z, 2)) / 2,\n            width: size.x,\n            height: size.y,\n            depth: size.z\n        };\n    } else {\n        return {\n            center: [0, 0, 0],\n            radius: 0,\n            width: 0,\n            height: 0,\n            depth: 0\n        };\n    }\n};\n\n//TODO 这个接口有问题\nTHREE.Object3D.prototype.setPosition = function () {\n    var x, y, z;\n    var vector = new THREE.Vector3(0, 0, 0);\n    if (Array.isArray(arguments[0])) {\n        x = arguments[0][0];\n        y = arguments[0][1];\n        z = arguments[0][2];\n        vector.set(x, y, z);\n    } else if (arguments.length === 3) {\n        x = arguments[0];\n        y = arguments[1];\n        z = arguments[2];\n        vector.set(x, y, z);\n    } else if (!arguments[0]) {\n        console.log('setPosition坐标undefined');\n        vector.set(0, 0, 0);\n    } else if (arguments[0].isVector3) {\n        vector = arguments[0].clone();\n    }\n    this.position.copy(vector);\n    // if (this.parent) {\n    //   this.parent.updateMatrixWorld();\n    // }\n\n    if (THREE.EventCenter !== undefined) {\n        THREE.EventCenter.dispatchEvent({ type: 'immediateChanged', obj: this.parent || this });\n    }\n\n    if (this.material) {\n        _buffer2.default.bigDirty = true;\n    }\n};\n\nTHREE.Object3D.prototype.setWorldPosition = function () {\n    var x, y, z;\n    var vector = new THREE.Vector3(0, 0, 0);\n    if (Array.isArray(arguments[0])) {\n        x = arguments[0][0];\n        y = arguments[0][1];\n        z = arguments[0][2];\n        vector.set(x, y, z);\n    } else if (arguments.length === 3) {\n        x = arguments[0];\n        y = arguments[1];\n        z = arguments[2];\n        vector.set(x, y, z);\n    } else if (arguments[0].isVector3) {\n        vector = arguments[0].clone();\n    }\n\n    var localPos = this.parent.worldToLocal(vector.clone());\n    this.position.copy(localPos);\n    if (this.material) {\n        _buffer2.default.bigDirty = true;\n    }\n\n    if (THREE.EventCenter !== undefined) {\n        THREE.EventCenter.dispatchEvent({ type: 'staticChanged', obj: this });\n    }\n};\n\nTHREE.Object3D.prototype.setDerivedPosition = function () {\n    var x, y, z;\n    if (Array.isArray(arguments[0])) {\n        x = arguments[0][0];\n        y = arguments[0][1];\n        z = arguments[0][2];\n    } else if (arguments.length === 3) {\n        x = arguments[0];\n        y = arguments[1];\n        z = arguments[2];\n    } else if (arguments[0].isVector3) {\n        console.log('setDerivedPosition需要修改');\n    }\n    var vector = new THREE.Vector3(x, y, z);\n    var localPos = this.parent.worldToLocal(vector.clone());\n    this.position.copy(localPos);\n    if (this.material) {\n        _buffer2.default.bigDirty = true;\n    }\n\n    if (THREE.EventCenter !== undefined) {\n        THREE.EventCenter.dispatchEvent({ type: 'staticChanged', obj: this });\n    }\n};\n\nTHREE.Object3D.prototype.setScale = function () {\n    var x, y, z;\n    if (Array.isArray(arguments[0])) {\n        x = arguments[0][0];\n        y = arguments[0][1];\n        z = arguments[0][2];\n    } else if (arguments.length === 3) {\n        x = arguments[0];\n        y = arguments[1];\n        z = arguments[2];\n    }\n    this.scale.set(x, y, z);\n    if (this.material) {\n        _buffer2.default.bigDirty = true;\n    }\n\n    if (THREE.EventCenter !== undefined) {\n        THREE.EventCenter.dispatchEvent({ type: 'staticChanged', obj: this });\n    }\n};\n\n//TODO 这个和static相结合还需要设计一下，目前还是有些问题的\nTHREE.Object3D.prototype.setScaleInside = function () {\n    var x, y, z;\n    if (Array.isArray(arguments[0])) {\n        x = arguments[0][0];\n        y = arguments[0][1];\n        z = arguments[0][2];\n    } else if (arguments.length === 3) {\n        x = arguments[0];\n        y = arguments[1];\n        z = arguments[2];\n    }\n    if (this.material) {\n        _buffer2.default.bigDirty = true;\n    }\n\n    if (THREE.EventCenter !== undefined) {\n        THREE.EventCenter.dispatchEvent({ type: 'staticChanged', obj: this });\n    }\n    //标记渲染更新\n    this._scaleInside = new THREE.Vector3(x, y, z);\n};\n\nTHREE.Object3D.prototype.setScaleAnimation = function (ratio, min, max, flag) {\n    flag = flag || true;\n    min = min || 0.8;\n    max = max || 1.5;\n    ratio = ratio || 0.001;\n    var obj = this;\n    var origin = 1;\n    var scale = obj.getScale();\n    // var scaleX = obj.getScale()[0];\n    // var scaleY = obj.getScale()[1];\n    // var scaleZ = obj.getScale()[2];\n    var task = {\n        update: function update() {\n            if (flag) {\n                origin += ratio;\n                if (origin > max || origin === max) {\n                    flag = false;\n                }\n            } else {\n                origin -= ratio;\n                if (origin < min || origin === min) {\n                    flag = true;\n                }\n            }\n            obj.setScale(scale[0] * origin, scale[1] * origin, scale[2] * origin);\n            if (obj.material) {\n                _buffer2.default.bigDirty = true;\n            }\n\n            if (THREE.EventCenter !== undefined) {\n                THREE.EventCenter.dispatchEvent({ type: 'staticChanged', obj: obj });\n            }\n        }\n    };\n    var name = _helper2.default.getUUID();\n    _buffer2.default._renderList.add(name, task);\n};\n\nTHREE.Object3D.prototype.fadeIn = function (speed, beginFrame) {\n    speed = speed || 1 / 100;\n    beginFrame = beginFrame || 0;\n    var mat = [];\n    this.traverse(function (v) {\n        if (v.material) {\n            v.material.transparent = true;\n            v.material.opacity = 0;\n            mat.push(v.material);\n        }\n    });\n    if (!mat.length) return;\n    var task = {\n        speed: speed,\n        finish: false,\n        update: function update() {\n            var that = this;\n            if (_buffer2.default.frameTime > beginFrame) {\n                mat.map(function (v1) {\n                    if (!that.finish) {\n                        if (v1.opacity < 1) {\n                            v1.opacity += speed;\n                        } else {\n                            v1.opacity = 1;\n                            that.finish = true;\n                        }\n                    }\n                });\n            }\n        }\n    };\n    var name = _helper2.default.getUUID();\n    _buffer2.default._renderList.add(name, task);\n};\nTHREE.Object3D.prototype.fadeOut = function (speed, beginFrame) {\n    speed = speed || 1 / 100;\n    beginFrame = beginFrame || 0;\n    var mat = [];\n    this.traverse(function (v) {\n        if (v.material) {\n            v.material.transparent = true;\n            //v.material.opacity = 1;\n            mat.push(v.material);\n        }\n    });\n    if (!mat.length) return;\n    var task = {\n        speed: speed,\n        finish: false,\n        update: function update() {\n            var that = this;\n            if (_buffer2.default.frameTime > beginFrame) {\n                mat.map(function (v1) {\n                    if (!that.finish) {\n                        if (v1.opacity > 0) {\n                            v1.opacity -= speed;\n                        } else {\n                            v1.opacity = 0;\n                            that.finish = true;\n                        }\n                    }\n                });\n            }\n        }\n    };\n    var name = _helper2.default.getUUID();\n    _buffer2.default._renderList.add(name, task);\n};\n\nTHREE.Object3D.prototype.update = function () {};\nTHREE.Object3D.prototype.attachCamera = function () {\n    //TODO: 这块没有实现\n};\n\n//TODO add的时候可能有问题，注意有可能需要使用immediate策略\nTHREE.Object3D.prototype.attachObject = function (obj) {\n    if (!obj) {\n        console.log('无法识别' + obj);\n        return;\n    }\n    // this.isInit = true;\n    if (obj.type == 'light') {\n        var light = _buffer2.default.lightBuffer.get(obj.name);\n        this.add(light);\n\n        if (THREE.EventCenter !== undefined) {\n            THREE.EventCenter.dispatchEvent({ type: 'staticAdded', obj: light });\n        }\n    } else if (obj.type == 'Sprite') {\n        var mesh = _buffer2.default.entityBuffer.get(obj.name);\n        this.add(mesh);\n        mesh.queryFlag = mesh.queryFlag === 0 ? 0 : 1;\n\n        if (THREE.EventCenter !== undefined) {\n            THREE.EventCenter.dispatchEvent({ type: 'immediateChanged', obj: mesh });\n        }\n\n        //this.updateMatrixWorld();\n    } else if (obj.type == 'Sprite2D') {\n        var _mesh = _buffer2.default.entityBuffer.get(obj.name);\n        var parentNode = this;\n        this.updateMatrixWorld();\n        var position = this.getWorldPosition();\n        var screenPos = _camera2.default.getSpriteScreenCoords([position.x, position.y, position.z]);\n        var scene = _buffer2.default.sceneBuffer.get('_2DScene');\n        var newNode = new THREE.Object3D();\n        newNode.name = obj.name;\n        newNode.add(_mesh);\n        scene.add(newNode);\n        newNode.setPosition(screenPos[0], screenPos[1], 1);\n        _mesh.queryFlag = _mesh.queryFlag === 0 ? 0 : 1;\n        //实现update方法\n        var task = {\n            update: function update() {\n                var pos = parentNode.getWorldPosition();\n                var screenPos = _camera2.default.getSpriteScreenCoords([pos.x, pos.y, pos.z]);\n                newNode.setPosition(screenPos[0], screenPos[1], 1);\n            }\n        };\n        var name = _helper2.default.getUUID();\n        _buffer2.default._renderList.add(name, task);\n\n        // this.updateMatrixWorld();\n    } else if (obj.type == 'web') {\n        var target = new THREE.Vector3();\n        var pos = this.getWorldPosition(target);\n        obj.mat.position.copy(pos);\n\n        var width = Number(obj.mat.element.style.width.substr(0, obj.mat.element.style.width.length - 2));\n        obj.geometry.computeBoundingBox();\n        var width3d = obj.geometry.boundingBox.getSize(new THREE.Vector3()).x;\n        var height3d = obj.geometry.boundingBox.getSize(new THREE.Vector3()).y;\n        obj.mat.scale.set(0.01 * width3d, 0.01 * height3d, 1);\n        _buffer2.default.scene2.add(obj.mat);\n        if (THREE.EventCenter !== undefined) {\n            THREE.EventCenter.dispatchEvent({ type: 'staticAdded', obj: obj });\n        }\n    } else if (window.THING && obj instanceof THING.BaseObject) {\n        var objNode = obj._layer === undefined ? obj.node : obj._layer;\n        _buffer2.default.entityBuffer.add(obj.name, objNode);\n        objNode.queryFlag === 0 ? 0 : 1;\n        this.add(objNode);\n        this.updateMatrixWorld();\n    } else {\n        var meshName = obj.name;\n        //TODO: 存疑\n        var _mesh2 = _buffer2.default.entityBuffer.get(meshName);\n        //虽然感觉一个机柜的东西单独放在这里不是特别的合理，但是没有办法\n        _mesh2.isCabinetRoot = this.isCabinetRoot;\n        _mesh2.queryFlag = _mesh2.queryFlag === 0 ? 0 : 1;\n\n        this.add(_mesh2);\n\n        if (THREE.EventCenter !== undefined) {\n            THREE.EventCenter.dispatchEvent({ type: 'immediateChanged', obj: _mesh2 });\n        }\n\n        // this.updateMatrixWorld();\n    }\n    if (this.material) {\n        _buffer2.default.bigDirty = true;\n    }\n\n    // this.matrixWorldNeedsUpdate = true;\n    // mesh.matrixWorldNeedsUpdate = true;\n    //这里如果不设置，AABB将获取的不正确\n    // var rootNode = buffer.nodeBuffer.get(\"rootNode\");\n    // rootNode.matrixWorldNeedsUpdate = true;\n\n    // this.node = mesh;\n};\n\nTHREE.Object3D.prototype.detachObject = function (obj) {\n    var meshName = obj.name;\n    var mesh = _buffer2.default.entityBuffer.get(meshName);\n    this.remove(mesh);\n    if (this.material) {\n        _buffer2.default.bigDirty = true;\n    }\n};\n\n/**\r\n * 创建孩子\r\n * @param  {String} name   [description]\r\n * @param  {Array}  pos    [位置]\r\n * @param  {Number} rotate [旋转]\r\n * @return {[type]}        [MyGroup]\r\n */\nTHREE.Object3D.prototype.createChild = function () {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'obj';\n    var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n    var rotate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    //如果没有attachObject，则他的父亲节点一直都会是ROOT，这里没有空节点\n    //TODO: rotate 没有搞明白\n    var newNode = new THREE.Object3D();\n    var pv = new THREE.Vector3(pos[0], pos[1], pos[2]);\n    newNode.position.copy(pv);\n    newNode.name = name;\n    this.add(newNode);\n\n    _buffer2.default.nodeBuffer.add(name, newNode);\n\n    if (THREE.EventCenter !== undefined) {\n        THREE.EventCenter.dispatchEvent({ type: 'staticChanged', obj: newNode });\n    }\n\n    return newNode;\n};\n\nTHREE.Object3D.prototype.createTreeChild = function () {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'obj';\n    var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n    var rotate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    var newNode = new THREE.Object3D();\n    var pv = new THREE.Vector3(pos[0], pos[1], pos[2]);\n    newNode.position.copy(pv);\n    newNode.name = name;\n    this.add(newNode);\n    _buffer2.default.nodeBuffer.add(name, newNode);\n    newNode.followCameraFixY();\n    _buffer2.default.bigDirty = true;\n\n    if (THREE.EventCenter !== undefined) {\n        THREE.EventCenter.dispatchEvent({ type: 'staticAdded', obj: newNode });\n    }\n\n    return newNode;\n};\n\nTHREE.Object3D.prototype.addChild = function (node) {\n\n    THREE.SceneUtils.attach(node, _buffer2.default.nodeTrash, this);\n    if (this.material) {\n        _buffer2.default.bigDirty = true;\n    }\n\n    if (THREE.EventCenter !== undefined) {\n        THREE.EventCenter.dispatchEvent({ type: 'staticAdded', obj: node });\n    }\n};\n\nTHREE.Object3D.prototype.removeChild = function (node) {\n\n    //Three bug, 父亲需要先要更新矩阵\n    // this._recursionUpdate(node);\n    // var pos = node.getWorldPosition();\n    // node._worldPos = pos.clone();\n    // node._matrixWorld = node.matrixWorld.clone();\n    // node._matrix = node.matrix.clone();\n    // node._position = node.position.clone();\n    // this.remove(node);\n    // var rootNode = buffer.nodeBuffer.get(\"rootNode\");\n    THREE.SceneUtils.detach(node, node.parent, _buffer2.default.nodeTrash);\n    if (this.material) {\n        _buffer2.default.bigDirty = true;\n    }\n    if (THREE.CompositorCenter) {\n        if (isEffectObject(node)) {\n            var tech = node.technique;\n            for (var name in tech) {\n                node.removeEffectName(name);\n            }\n        }\n    }\n    return node;\n};\nTHREE.Object3D.prototype.destroy = function () {\n\n    this.parent.removeChild(this);\n    _buffer2.default.nodeBuffer.delete(this.name);\n    if (this.material) {\n        _buffer2.default.bigDirty = true;\n    }\n    if (THREE.CompositorCenter) {\n        if (isEffectObject(this)) {\n            var tech = this.technique;\n            for (var name in tech) {\n                this.removeEffectName(name);\n            }\n        }\n    }\n};\nTHREE.Object3D.prototype.removeChildMaterial = function (node) {\n    node.traverse(function (object) {\n        if (object.t3dMaterial) {\n            var t3dMat = object.t3dMaterial;\n            t3dMat.destroy();\n            _buffer2.default.bigDirty = true;\n        }\n    });\n};\n\nTHREE.Object3D.prototype.removeChildMaterialBuffer = function (node) {\n    node.traverse(function (object) {\n        if (object.t3dMaterial) {\n            var t3dMatName = object.t3dMaterial.name;\n            if (t3dMatName) {\n                if (_buffer2.default.materialBuffer.get(t3dMatName)) {\n                    _buffer2.default.materialBuffer.delete(t3dMatName);\n                }\n            }\n        }\n        if (object._t3dMaterial) {\n            var _t3dMatName = object._t3dMaterial.name;\n            if (_t3dMatName) {\n                if (_buffer2.default.materialBuffer.get(_t3dMatName)) {\n                    _buffer2.default.materialBuffer.delete(_t3dMatName);\n                }\n            }\n        }\n    });\n};\n\nTHREE.Object3D.prototype.upFollowCamera = function (t3dCamera) {\n    var that = this;\n    var v1 = new THREE.Vector3(0, 1, 0);\n    var v2 = t3dCamera.getUp();\n    v2 = new THREE.Vector3(v2[0], v2[1], v2[2]);\n\n    var quat = new THREE.Quaternion();\n    quat = quat.setFromUnitVectors(v1, v2);\n    that.setRotationFromQuaternion(quat);\n    _buffer2.default.bigDirty = true;\n    return that.rotation;\n};\n\nTHREE.Object3D.prototype.followCameraFixY = function (axis) {\n    var that = this;\n    that.rotation.set(0, 0, 0);\n    var task = null;\n\n    if (axis == 'x') {\n        task = {\n            update: function update() {\n                var cameraPos = _camera2.default.getPosition();\n                var lineCameraToObj = new THREE.Vector3(0, cameraPos[1] - that.position.y, cameraPos[2] - that.position.z);\n                var lineX = new THREE.Vector3(1, 0, 0);\n\n                var plane1 = new THREE.Vector3(0, 0, 0).copy(lineCameraToObj);\n                plane1 = plane1.cross(lineX);\n\n                var planeObj = new THREE.Vector3(0, -1, 0).applyQuaternion(that.quaternion);\n                var angleX = plane1.angleTo(planeObj);\n\n                var planeY = new THREE.Vector3(0, 0, 0).copy(planeObj);\n                planeY = planeY.cross(lineX);\n                var angleY = plane1.angleTo(planeY);\n\n                if (angleY < Math.PI / 2) {\n                    angleX = -angleX;\n                }\n\n                that.rotateX(angleX);\n                _buffer2.default.bigDirty = true;\n\n                if (THREE.EventCenter !== undefined) {\n                    THREE.EventCenter.dispatchEvent({ type: 'staticChanged', obj: that });\n                }\n            }\n        };\n    } else if (axis == 'z') {\n        //无意义\n        return;\n    } else {\n        task = {\n            update: function update() {\n                var cameraPos = _camera2.default.getPosition();\n                var lineCameraToObj = new THREE.Vector3(cameraPos[0] - that.position.x, 0, cameraPos[2] - that.position.z);\n                var lineY = new THREE.Vector3(0, 1, 0);\n\n                var plane1 = new THREE.Vector3(0, 0, 0).copy(lineCameraToObj);\n                plane1 = plane1.cross(lineY);\n\n                var planeObj = new THREE.Vector3(-1, 0, 0).applyQuaternion(that.quaternion);\n\n                var planeX = new THREE.Vector3(0, 0, 0).copy(planeObj);\n                planeX = planeX.cross(lineY);\n                var angleX = plane1.angleTo(planeX);\n\n                var angleY = plane1.angleTo(planeObj);\n\n                if (angleX < Math.PI / 2) {\n                    angleY = -angleY;\n                }\n\n                that.rotateY(angleY);\n                _buffer2.default.bigDirty = true;\n\n                if (THREE.EventCenter !== undefined) {\n                    THREE.EventCenter.dispatchEvent({ type: 'staticChanged', obj: that });\n                }\n            }\n        };\n    }\n\n    var name = _helper2.default.getUUID();\n    _buffer2.default._renderList.add(name, task);\n    // return that.rotation;\n};\n\nTHREE.Object3D.prototype.lookAtCamera = function (axis) {\n    var that = this;\n    var task = {\n        update: function update() {\n            var cameraPos = _camera2.default.getPosition();\n\n            that.lookAt(cameraPos[0], cameraPos[1], cameraPos[2]);\n\n            if (axis == 'x') {\n                that.rotateY(-Math.PI / 2);\n            } else if (axis == 'z') {\n                that.rotateX(-Math.PI / 2);\n            }\n            _buffer2.default.bigDirty = true;\n\n            if (THREE.EventCenter !== undefined) {\n                THREE.EventCenter.dispatchEvent({ type: 'immediateChanged', obj: that });\n            }\n        }\n    };\n    var name = _helper2.default.getUUID();\n    _buffer2.default._renderList.add(name, task);\n};\n\nTHREE.Object3D.prototype.setQueryFlags = function (flag, bool) {\n    this.queryFlag = flag;\n};\n\nTHREE.Object3D.prototype.convertWorldToLocalPosition = function (pos) {\n    var vec;\n    if (pos.isVector3) {\n        vec = pos.clone();\n    } else {\n        vec = new THREE.Vector3(pos[0], pos[1], pos[2]);\n    }\n\n    var resultPos = this.worldToLocal(vec);\n    return [resultPos.x, resultPos.y, resultPos.z];\n};\n\nTHREE.Object3D.prototype.convertLocalToWorldPosition = function (pos) {\n    // this._recursionUpdate(this);\n    var vec;\n    if (pos.isVector3) {\n        vec = pos.clone();\n    } else {\n        vec = new THREE.Vector3(pos[0], pos[1], pos[2]);\n    }\n    vec = new THREE.Vector3(pos[0], pos[1], pos[2]);\n\n    var resultPos = this.localToWorld(vec);\n    return [resultPos.x, resultPos.y, resultPos.z];\n};\n\nTHREE.Object3D.prototype.getPickEnabledCache = function () {\n    //console.log(\"测试getPickEnabledCache\");\n    if (this.pickEnabled === false || this.pickEnabled === undefined) {\n        return false;\n    } else {\n        return true;\n    }\n};\n\nTHREE.Object3D.prototype.getAllChildren = function (isRecursive) {\n    isRecursive = isRecursive || false;\n    if (!isRecursive) {\n        return this.children;\n    }\n    if (!this.children) return [];\n    var res = [];\n    this.traverse(function (object) {\n        if (object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Sprite || object instanceof THREE.Group) {\n            res.push(object);\n        }\n    });\n    return res;\n};\n\nTHREE.Object3D.prototype.getProperty = function (a, b, c) {\n    if (this.name.indexOf('Fl') > -1) {\n        return '地板';\n    } else if (this.name.indexOf('Cl') > -1) {\n        return '天花板';\n    }\n    return null;\n};\n\nTHREE.Object3D.prototype.removeQueryFlags = function (queryFlags) {\n    this.queryFlag = this.queryFlag == undefined ? 1 : this.queryFlag;\n    this.queryFlag = this.queryFlag | queryFlags;\n};\n\nTHREE.Object3D.prototype.addQueryFlags = function (queryFlags) {\n    this.queryFlag = this.queryFlag == undefined ? 1 : this.queryFlag;\n    this.queryFlag = this.queryFlag | queryFlags;\n};\n\n//这里需要改造一下,在渲染级别处理\nTHREE.Object3D.prototype.setVisibilityFlags = function (visibilityFlags, isRecursive) {\n    this.visibilityFlags = visibilityFlags;\n    if (isRecursive) {\n        this.traverse(function (obj) {\n            if (obj instanceof THREE.Mesh || obj instanceof THREE.Line || obj instanceof THREE.Sprite) {\n                obj.visibilityFlags = visibilityFlags;\n            }\n        });\n    }\n};\n\nTHREE.Object3D.prototype.addVisibilityFlags = function (visibilityFlags) {};\n\nTHREE.Object3D.prototype.removeVisibilityFlags = function (visibilityFlags) {};\n\nTHREE.Object3D.prototype.setCustomParameter = function (index, value) {\n    var custom = ['inputColor', 'alphaValue'];\n    var Mat = this.t3dMaterial;\n    if (!Mat) return;\n    var pass = Mat.getTechnique(0).getPass(0);\n    if (typeof index === 'number' && index < custom.length + 1) {\n        pass.setGpuProgramParameter('', custom[index - 1], value, 4, 'float');\n    } else if (typeof index === 'string') {\n        if (value.length) {\n            pass.setGpuProgramParameter('', index, value, value.length, 'float');\n        } else {\n            pass.setGpuProgramParameter('', index, value, 1, 'float');\n        }\n    }\n    if (this.material) {\n        _buffer2.default.bigDirty = true;\n    }\n};\n\nTHREE.Object3D.prototype.getAllAttachedObjects = function () {\n    /*if (this.material) {\r\n        return [this];\r\n    } else if (this.children.length > 0) {\r\n        let mesh = [];\r\n        this.children.map(a => { if (a.material) { mesh.push(a); } });\r\n        return mesh;\r\n    }*/\n    var mesh = [];\n    if (this.material) {\n        mesh.push(this);\n    } else if (this.children.length > 0) {\n        this.children.forEach(function (item) {\n            var arr = item.getAllAttachedObjects();\n            mesh.push.apply(mesh, arr);\n        });\n    }\n    return mesh;\n};\n\nTHREE.Object3D.prototype.getChild = function (name) {\n    for (var i in this.children) {\n        if (this.children[i].name == name) {\n            return this.children[i];\n        }\n    }\n    return null;\n};\n\nTHREE.Object3D.prototype.getPosition = function () {\n    return [this.position.x, this.position.y, this.position.z];\n};\n\nTHREE.Object3D.prototype.getOrientation = function () {\n    return [this.quaternion.x, this.quaternion.y, this.quaternion.z, this.quaternion.w];\n};\n\nTHREE.Object3D.prototype.getDerivedScale = function () {\n    var target = new THREE.Vector3();\n    var tem = this.getWorldScale(target);\n    return [tem.x, tem.y, tem.z];\n};\n\nTHREE.Object3D.prototype.getDerivedPosition = function () {\n    var target = new THREE.Vector3();\n    var tem = this.getWorldPosition(target);\n    return [tem.x, tem.y, tem.z];\n};\n\nTHREE.Object3D.prototype.getScale = function () {\n    // var tem = this.getWorldScale();\n    return [this.scale.x, this.scale.y, this.scale.z];\n};\n\nTHREE.Object3D.prototype.setDerivedOrientation = function (quaternion, quat1) {\n    // TODO: 这快可能有问题\n    var myQuaternion = new THREE.Quaternion();\n    myQuaternion.set(quaternion[0], quaternion[1], quaternion[2], quaternion[3]);\n    if (quat1) {\n        var myQuaternion1 = new THREE.Quaternion();\n        myQuaternion1.set(quat1[0], quat1[1], quat1[2], quat1[3]);\n        this.quaternion.multiplyQuaternions(myQuaternion, myQuaternion1);\n    } else {\n        this.applyQuaternion(myQuaternion);\n    }\n    if (this.material) {\n        _buffer2.default.bigDirty = true;\n    }\n\n    if (THREE.EventCenter !== undefined) {\n        THREE.EventCenter.dispatchEvent({ type: 'staticChanged', obj: this });\n    }\n};\n\nTHREE.Object3D.prototype.setOrientation = function (quaternion) {\n    var myQuaternion = new THREE.Quaternion();\n    myQuaternion.set(quaternion[0], quaternion[1], quaternion[2], quaternion[3]);\n    this.setRotationFromQuaternion(myQuaternion);\n    if (this.material) {\n        _buffer2.default.bigDirty = true;\n    }\n\n    if (THREE.EventCenter !== undefined) {\n        THREE.EventCenter.dispatchEvent({ type: 'staticChanged', obj: this });\n    }\n};\n\nTHREE.Object3D.prototype.translate = function (pos) {\n    this.translateX(pos[0]);\n    this.translateY(pos[1]);\n    this.translateZ(pos[2]);\n    if (this.material) {\n        _buffer2.default.bigDirty = true;\n    }\n    if (THREE.EventCenter !== undefined) {\n        THREE.EventCenter.dispatchEvent({ type: 'staticChanged', obj: this });\n    }\n};\n\nTHREE.Object3D.prototype.setTransparency = function (value) {\n    if (this.material) {\n        this.material.opacity = Math.abs(1 - value);\n        this.material.transparent = true;\n        this.material.needsUpdate = true;\n    }\n    if (this.children) {\n        for (var i = 0; i < this.children.length; i++) {\n            this.children[i].setTransparency(value);\n        }\n    }\n    if (this.material) {\n        _buffer2.default.bigDirty = true;\n    }\n};\n\nTHREE.Object3D.prototype.clear = function () {\n    // if(this.parent){\n    //     this.parent.remove(this);\n    // }\n};\n\n//极度优化的接口，后续如果有每帧调用的接口都需要极度优化\nTHREE.Object3D.prototype.getLocalAABB = function () {\n    if (_buffer2.default.static && !this.isNeedUpdateAABB() && this._localAABB && !this._changeAABB) {\n        // this.cancelAABB();\n        return _helper2.default.clone(this._localAABB, true);\n    }\n    var box3 = this._recursionAABB(this);\n    var myBox3 = new THREE.Box3();\n    var tmpSize = new THREE.Vector3();\n    box3.getSize(tmpSize);\n    var center = new THREE.Vector3();\n    box3.getCenter(center);\n    if (center.x === 0 && center.y === 0 && center.z === 0) {\n        var target = new THREE.Vector3();\n        center = this.getWorldPosition(target).clone(target);\n    }\n    center = this.worldToLocal(center);\n    myBox3.setFromCenterAndSize(center, tmpSize);\n\n    var size = myBox3.getSize(new THREE.Vector3());\n    var res = {\n        center: [center.x, center.y, center.z],\n        radius: Math.sqrt(Math.pow(size.x, 2) + Math.pow(size.y, 2) + Math.pow(size.z, 2)) / 2,\n        width: size.x,\n        height: size.y,\n        depth: size.z\n\n    };\n    this._localAABB = _helper2.default.clone(res, true);\n    this._changeAABB = false;\n    return res;\n};\n\nTHREE.Object3D.prototype.setProperty = function (type, name) {\n    if (!this._userProperty) {\n        this._userProperty = {};\n        this._userProperty[type] = name;\n    } else {\n        this._userProperty[type] = name;\n    }\n};\n\nTHREE.Object3D.prototype.setRenderQueueGroup = function (val) {\n    // console.log(\"setRenderQueueGroup没有实现\");\n    this.renderOrder = val;\n    if (this.material) {\n        _buffer2.default.bigDirty = true;\n    }\n};\n\nTHREE.Object3D.prototype.convertWorldToLocalOrientation = function (rot) {\n    // console.log('convertWorldToLocalOrientation没有实现');\n    // var qua = new THREE.Vector4( rot[0],rot[1],rot[2],rot[3] );\n    // qua.applyMatrix4(this.matrix);\n\n    // return [qua.x,qua.xy,qua.z,qua.w];\n    return rot;\n};\nTHREE.Object3D.prototype.convertLocalToWorldOrientation = function (rot) {\n    // var qua = new THREE.Vector4( rot[0],rot[1],rot[2],rot[3] );\n    // qua.applyMatrix4(this.matrixWorld);\n\n    // return [qua.x,qua.xy,qua.z,qua.w];\n    return rot;\n};\n\nTHREE.Object3D.prototype.getAllEntityNames = function () {\n    return [];\n};\n\n//\nTHREE.Object3D.prototype.setMaterialName = function (matName) {\n    var mat = _buffer2.default.materialBuffer.get(matName);\n    var passes = mat.getTechnique(0).getPass();\n    if (this.type === 'Sprite') {\n        passes.map(function (v) {\n            if (v.material.type != 'SpriteMaterial') {\n                var param = _sourceThreeFunction2.default.copyParams(v.material);\n                v.setMaterial(new THREE.SpriteMaterial(param));\n            }\n        });\n    } else if (this.type === 'Sprite2D') {\n        passes.map(function (v) {\n            if (v.material.type != 'SpriteMaterial') {\n                var param = _sourceThreeFunction2.default.copyParams(v.material);\n                v.setMaterial(new THREE.SpriteMaterial(param));\n                v.setDepthCheck(false);\n            }\n        });\n    } else if (this.type === 'LINE_PLANE_SPRITE') {\n        passes.map(function (v) {\n            if (v.material.type != 'MeshLineMaterial') {\n                var lineMat = _materialFactory2.default.createMaterial('MeshLineMaterial', { map: v.material.map });\n                v.setMaterial(lineMat);\n            }\n        });\n    }\n    this.t3dMaterial = mat;\n    if (this.material) {\n        _buffer2.default.bigDirty = true;\n    }\n};\n\nTHREE.Object3D.prototype.setFixedYawAxis = function (useFixed, fixedAxis) {};\n\nTHREE.Object3D.prototype.setDimensions = function (width, height) {\n    width = parseFloat(width) * 10000;\n    height = parseFloat(height) * 10000;\n    if (this.type === 'Sprite' || this.type === 'Sprite2D') {\n        this.scale.set(width, height, 1);\n    }\n    if (this.material) {\n        _buffer2.default.bigDirty = true;\n    }\n\n    if (THREE.EventCenter !== undefined) {\n        THREE.EventCenter.dispatchEvent({ type: 'staticChanged', obj: this });\n    }\n};\n\nTHREE.Object3D.prototype.setDirection = function (v, type) {\n    var zDir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0, 1];\n\n    var up = new THREE.Vector3(v[0], v[1], v[2]);\n    var orgin = new THREE.Vector3();\n    //type == 2 是 world\n    if (type == 2) {\n        //转换成世界的direction\n\n        this.getWorldDirection(orgin);\n\n        orgin.set(zDir[0], zDir[1], zDir[2]);\n\n        var dir = this.worldToLocal(up);\n        var o = this.worldToLocal(new THREE.Vector3(0, 0, 0));\n        var r = dir.sub(o);\n        r.normalize();\n        var quaternion = new THREE.Quaternion();\n\n        quaternion.setFromUnitVectors(orgin, r);\n        quaternion.normalize();\n\n        this.setRotationFromQuaternion(quaternion);\n        //\n        //type == 1 是 parent\n    } else if (type == 1) {\n\n        this.getWorldDirection(orgin);\n\n        orgin.set(zDir[0], zDir[1], zDir[2]);\n\n        var _dir = this.parent.worldToLocal(up);\n        var _o = this.parent.worldToLocal(new THREE.Vector3(0, 0, 0));\n        var _r = _dir.sub(_o);\n        _r.normalize();\n        var _quaternion = new THREE.Quaternion();\n\n        _quaternion.setFromUnitVectors(orgin, _r);\n        _quaternion.normalize();\n\n        this.setRotationFromQuaternion(_quaternion);\n    }\n\n    // this.updateMatrixWorld();\n    if (this.material) {\n        _buffer2.default.bigDirty = true;\n    }\n\n    if (THREE.EventCenter !== undefined) {\n        THREE.EventCenter.dispatchEvent({ type: 'immediateChanged', obj: this });\n    }\n};\n\nTHREE.Object3D.prototype._insideSizeControlNodes = function () {};\n\n//只处理单个pass的情况，多个pass对其进行标记\n//是否还需要考虑一下overrideMaterial的问题那？\n//考虑注册一个事件作为策略\nTHREE.Object3D.prototype.onBeforeRender = function (renderer, scene, camera, geometry, material, group) {\n    _useIndependentTransform(this);\n    //排除掉所有的空node,camera,light\n    if (!this.material && !this.t3dMaterial) return;\n    var that = this;\n    if (this._t3dRenderFlag && this.t3dMaterial) {\n        var t3dMaterial = this.t3dMaterial;\n        //正常处理流程\n        projectT3dMaterial(that, t3dMaterial);\n        var finalMaterial = scene.overrideMaterial || that.material;\n        return finalMaterial;\n    } else {\n        //如果没有挂接t3dMaterial\n        return material;\n        //console.warn(that.type+\":请挂接t3d材质\");\n    }\n};\n\n//使用gpupicker时需要重置渲染renderFlag\nTHREE.Object3D.prototype.beginGPUPickerRendering = function () {\n    this._t3dRenderFlag = false;\n};\nTHREE.Object3D.prototype.finishGPUPickerRendering = function () {\n    this._t3dRenderFlag = true;\n};\n\nfunction projectT3dMaterial(object, t3dMaterial) {\n    var tech = t3dMaterial.getTechnique(0);\n    var nums = tech.getNumPasses();\n    var pass = tech.getPass(0);\n    object.material = pass.getMaterial ? pass.getMaterial() : pass.material;\n    //TODO 这里可能会有问题\n    if (_buffer2.default.transparentOption === 1 && object.material.transparent) {\n        object.material.depthWrite = false;\n    }\n    object._numPasses = nums;\n}\n\nfunction isTransparent(obj) {\n    var flag = false;\n    if (obj.t3dMaterial) {\n        var passes = obj.t3dMaterial.getTechnique(0).getPass();\n        passes.map(function (v) {\n            if (v.getMaterial().transparent) {\n                flag = true;\n            }\n        });\n    } else if (obj.material) {\n        if (obj.material.transparent) {\n            flag = true;\n        }\n    }\n\n    return flag;\n}\n\n//TODO 直接渲染物体还不知道如何处理，目前暂不考虑，建议不要使用直接渲染物体\n//TODO 精灵问题先跳过\nTHREE.Object3D.prototype.onAfterRender = function (renderer, scene, camera, geometry, material, group) {\n    if (!this.material) return;\n    //如果开启了材质替换策略\n    if (renderer.materialManager.$mode !== 0) {\n        var mode = renderer.materialManager.$mode;\n        //如果未标记继续渲染策略\n        if (!this.technique1 || !this.technique1[mode]) {\n            return;\n        }\n    }\n    var that = this;\n    //if(that.isSprite) return;\n    if (that._numPasses && that._numPasses > 1) {\n        var passes = that.t3dMaterial.getTechnique(0).getPass();\n        passes.sort(function painterSortStable(a, b) {\n            return a.renderOrder - b.renderOrder;\n        });\n        passes.map(function (v, k, arr) {\n            if (k > 0) {\n                var mat = arr[k].material;\n                //不支持无图的pass多次渲染\n                //TODO可能需要修改THREE，专用uv3通道\n                if (that.geometry.attributes) {\n                    if (v.texCoord3) {\n                        //that.geometry.addAttribute( 'uv3', v.texCoord3 );\n                        that.geometry.addAttribute('uv3', v.texCoord3);\n                    } else {\n                        that.geometry.addAttribute('uv3', that.geometry.attributes.uv);\n                    }\n                }\n                renderer.renderBufferDirect(camera, scene.fog, geometry, mat, that, group);\n            }\n            // }\n        });\n    }\n    //新增，为uearth中多pass使用\n    else if (that._afterRendererMaterial && that._afterRendererMaterial.length) {\n            that._afterRendererMaterial.map(function (v1) {\n                renderer.renderBufferDirect(camera, scene.fog, geometry, v1, that, group);\n            });\n        }\n};\n\nTHREE.Object3D.prototype._t3dRenderFlag = true;\nTHREE.Object3D.prototype.setT3dRenderFlag = function (flag) {\n    this._t3dRenderFlag = flag;\n};\n\nTHREE.Object3D.prototype.getT3dRenderFlag = function () {\n    return this._t3dRenderFlag;\n};\n\nTHREE.Object3D.prototype.setMaterial = function (mat) {\n    this.t3dMaterial = mat;\n    if (this.material) {\n        _buffer2.default.bigDirty = true;\n    }\n};\n\nTHREE.Object3D.prototype.setAutoTracking = function () {};\nTHREE.Object3D.prototype.getAllEntities = function (isRecursive) {\n    if (this.material) {\n        return [this];\n    } else {\n        if (isRecursive && this.children) {\n            var res = [];\n            this.traverse(function (v) {\n                if (v.material) {\n                    res.push(v);\n                }\n            });\n            return res;\n        } else {\n            return [];\n        }\n    }\n};\nTHREE.Object3D.prototype.getAllSubEntities = function () {\n    if (this.material) {\n        return [this];\n    } else {\n        return [];\n    }\n};\nTHREE.Object3D.prototype.getMaterial = function () {\n    return this.t3dMaterial;\n};\nTHREE.Object3D.prototype.getDerivedOrientation = function () {\n    return [this.quaternion.x, this.quaternion.y, this.quaternion.z, this.quaternion.w];\n};\n\nTHREE.Object3D.prototype.showBoundingBox = function () {\n    console.log('没有实现');\n};\n\n//added by zhgu if we use static strategy\nTHREE.Object3D.prototype.add = function (object) {\n\n    if (arguments.length > 1) {\n\n        for (var i = 0; i < arguments.length; i++) {\n\n            this.add(arguments[i]);\n        }\n\n        return this;\n    }\n\n    if (object === this) {\n\n        console.error('THREE.Object3D.add: object can\\'t be added as a child of itself.', object);\n        return this;\n    }\n\n    if (object && object.isObject3D) {\n\n        if (object.parent !== null) {\n\n            object.parent.remove(object);\n        }\n\n        object.parent = this;\n        object.dispatchEvent({ type: 'added' });\n        //added by zhgu\n        if (THREE.EventCenter !== undefined) {\n            THREE.EventCenter.dispatchEvent({ type: 'staticAdded', obj: object });\n        }\n        this.children.push(object);\n    } else {\n\n        console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);\n    }\n\n    return this;\n};\n\nTHREE.Object3D.prototype.isNeedUpdateAABB = function () {\n    var flag = false;\n    this.traverse(function (v) {\n        if (v._staticDirty) {\n            return true;\n        }\n    });\n    return flag;\n};\nTHREE.Object3D.prototype.cancelAABB = function () {\n    this._changeAABB = false;\n    this.traverse(function (v) {\n        if (v._staticDirty) {\n            v._staticDirty = false;\n        }\n    });\n};\n//added by zhgu 新增lod的更新方法\nTHREE.LOD.prototype.update = function () {\n    var v1 = new THREE.Vector3();\n    var v2 = new THREE.Vector3();\n    var frameTrans = 0.0; //当前透明度\n    var curShowObj = null; //当前需要渐现的物体\n    var curHideObj = null; //当前需要渐隐的物体\n    var isShowAnimate = false; //是否是返回的渐现动画\n    var lastDistance = 0; //上一帧lod模型与摄影机的距离\n    return function update(camera) {\n        if (!_buffer2.default.LODAnimation) {\n            normalLOD(camera, v1, v2, this);\n            return;\n        }\n        //这几帧用于播放动画\n        if (curShowObj && curHideObj) {\n            //需要告诉我们执行dirty机制，当然后续我们还是用事件通知比较好\n            _buffer2.default.bigDirty = true;\n            frameTrans += _buffer2.default.LODAnimationDuring;\n            curHideObj.object.show(true);\n            setTransparent(curHideObj.object, 1.0 - frameTrans);\n            setTransparent(curShowObj.object, frameTrans);\n            curShowObj.object.show(true);\n            if (frameTrans >= 1.0) {\n                //还原物体\n                getOriginalObject(curHideObj.object);\n                getOriginalObject(curShowObj.object);\n                curHideObj.object.show(false);\n                curShowObj = null;\n                curHideObj = null;\n                frameTrans = 1.0;\n            }\n            return;\n        }\n        var levels = this.levels;\n        if (levels.length > 1) {\n            v1.setFromMatrixPosition(camera.matrixWorld);\n            v2.setFromMatrixPosition(this.matrixWorld);\n            var distance = v1.distanceTo(v2);\n            isShowAnimate = false;\n            levels[0].object.visible = true;\n            for (var i = 1, l = levels.length; i < l; i++) {\n                if (distance >= levels[i].distance) {\n                    //开始渐隐渐现\n                    if (lastDistance < levels[i].distance) {\n                        curHideObj = levels[i - 1];\n                        curShowObj = levels[i];\n                        frameTrans = 0.0;\n                    } else {\n                        levels[i - 1].object.visible = false;\n                        levels[i].object.visible = true;\n                    }\n                } else {\n                    //开始渐隐渐现\n                    if (lastDistance >= levels[i].distance) {\n                        curShowObj = levels[i - 1];\n                        curHideObj = levels[i];\n                        curShowObj.object.visible = false;\n                        frameTrans = 0.0;\n                        isShowAnimate = true;\n                    }\n                    break;\n                }\n            }\n            //这里为了不改变之前的逻辑，目前先暂时如此处理\n            for (; i < l; i++) {\n                if (isShowAnimate) {\n                    if (levels[i + 1]) {\n                        levels[i + 1].object.visible = false;\n                    }\n                } else {\n                    levels[i].object.visible = false;\n                }\n            }\n            lastDistance = distance;\n        }\n    };\n}();\n\n//threejs正常的lod切换方法\nfunction normalLOD(camera, v1, v2, lod) {\n    var levels = lod.levels;\n\n    if (levels.length > 1) {\n\n        v1.setFromMatrixPosition(camera.matrixWorld);\n        v2.setFromMatrixPosition(lod.matrixWorld);\n\n        var distance = v1.distanceTo(v2);\n\n        levels[0].object.visible = true;\n\n        for (var i = 1, l = levels.length; i < l; i++) {\n\n            if (distance >= levels[i].distance) {\n\n                levels[i - 1].object.visible = false;\n                levels[i].object.visible = true;\n            } else {\n\n                break;\n            }\n        }\n\n        for (; i < l; i++) {\n\n            levels[i].object.visible = false;\n        }\n    }\n}\n\n//设置物体透明接口\nfunction setTransparent(node, opacity) {\n    var result;\n    if (!node._selection) {\n        node._selection = new _SceneNodeSelection2.default();\n        node._selection.select(node, true);\n        result = node._selection._nodesResult;\n        //第一次备份下opacity与transparent\n        for (var k in result) {\n            result[k].t3dMaterial.getTechnique(0).getPass().map(function (v) {\n                v.material._LODopacity = v.material.opacity;\n                v.material._LODtransparent = v.material.transparent;\n                v.material._LODdepthWrite = v.material.depthWrite;\n            });\n        }\n    } else {\n        result = node._selection._nodesResult;\n    }\n    //更新opacity\n    for (var k1 in result) {\n        result[k1].t3dMaterial.getTechnique(0).getPass().map(function (v1) {\n            v1.material.opacity = opacity;\n            v1.material.transparent = true;\n            v1.material.depthWrite = false;\n        });\n    }\n    //}\n}\n//还原物体\nfunction getOriginalObject(node) {\n    if (node._selection) {\n        var result = node._selection._nodesResult;\n        //还原node\n        for (var k in result) {\n            result[k].t3dMaterial.getTechnique(0).getPass().map(function (v) {\n                v.material.opacity = v.material._LODopacity;\n                v.material.transparent = v.material._LODtransparent;\n                v.material.depthWrite = v.material._LODdepthWrite;\n            });\n        }\n    }\n}\n\nfunction _useIndependentTransform(node) {\n    if (node._scaleInside) {\n        var matrixWorld = node.matrixWorld;\n        var position = new THREE.Vector3();\n        var scale = new THREE.Vector3();\n        var quaternion = new THREE.Quaternion();\n        matrixWorld.decompose(position, quaternion, scale);\n        var scaleInside = node._scaleInside.clone();\n        scale = scale.multiply(scaleInside);\n        matrixWorld.compose(position, quaternion, scale);\n        delete node._scaleInside;\n    }\n}\n\nfunction isEffectObject(obj) {\n    if (obj.technique) {\n        for (var k in obj) {\n            if (obj[k]) {\n                return true;\n            }\n        }\n        return false;\n    } else {\n        return false;\n    }\n}\n\n//# sourceURL=webpack:///./src/node/Object3D.Extend.js?")
        },
        "./src/node/rootNode.js": /*!******************************!*\
  !*** ./src/node/rootNode.js ***!
  \******************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n// import nodeInstance from './nodeInstance.js';\n\n\nexports.default = {\n    init: function init(scene) {\n        this.scene = scene;\n        var rootNode = scene;\n        // buffer.nodeBuffer.add(name, rootNode);\n        return rootNode;\n    }\n};\n\n//# sourceURL=webpack:///./src/node/rootNode.js?")
        },
        "./src/overlay/GuiConstant.js": /*!************************************!*\
  !*** ./src/overlay/GuiConstant.js ***!
  \************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar VerticalAlignment = {\n    /** top */\n    TOP: 0,\n    /** center */\n    CENTER: 1,\n    /** bottom */\n    BOTTOM: 2\n};\n\nvar HorizontalAlignment = {\n    /** left */\n    LEFT: 0,\n    /** center */\n    CENTER: 1,\n    /** right */\n    RIGHT: 2\n};\n\nvar MetricsMode = {\n    /** 'left', 'top', 'height' and 'width' are parametrics from 0.0 to 1.0 */\n    RELATIVE: 0,\n    /** Positions & sizes are in absolute pixels */\n    PIXELS: 1,\n    /** Positions & sizes are in virtual pixels */\n    RELATIVE_ASPECT_ADJUSTED: 2\n};\n\nvar GuiConstant = {\n    HorizontalAlignment: HorizontalAlignment,\n    VerticalAlignment: VerticalAlignment,\n    MetricsMode: MetricsMode\n    //QueryFlags: QueryFlags\n};\n\nexports.default = GuiConstant;\n\n//# sourceURL=webpack:///./src/overlay/GuiConstant.js?")
        },
        "./src/overlay/Overlay.js": /*!********************************!*\
  !*** ./src/overlay/Overlay.js ***!
  \********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar Overlay = function () {\n    function Overlay(node) {\n        _classCallCheck(this, Overlay);\n\n        this.node = node;\n    }\n\n    _createClass(Overlay, [{\n        key: "setZOrder",\n        value: function setZOrder() {}\n    }, {\n        key: "add2D",\n        value: function add2D(element) {\n            this.node.add(element.sprite);\n        }\n    }, {\n        key: "show",\n        value: function show() {\n            this.node.visible = true;\n        }\n    }]);\n\n    return Overlay;\n}();\n\nexports.default = Overlay;\n\n//# sourceURL=webpack:///./src/overlay/Overlay.js?')
        },
        "./src/overlay/OverlayElementType.js": /*!*******************************************!*\
  !*** ./src/overlay/OverlayElementType.js ***!
  \*******************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar _constant = __webpack_require__(/*! ../util/constant.js */ "./src/util/constant.js");\n\nvar _constant2 = _interopRequireDefault(_constant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar OverlayElementType = _constant2.default.OverlayElementType;\n\nexports.default = OverlayElementType;\n//TODO 应该把所有t3d枚举类型都放在 util/constant.js 里\n\n//# sourceURL=webpack:///./src/overlay/OverlayElementType.js?')
        },
        "./src/overlay/PanelOverlayElement.js": /*!********************************************!*\
  !*** ./src/overlay/PanelOverlayElement.js ***!
  \********************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _buffer = __webpack_require__(/*! ../util/buffer.js */ \"./src/util/buffer.js\");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _helper = __webpack_require__(/*! ../util/helper.js */ \"./src/util/helper.js\");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PanelOverlayElement = function () {\n    function PanelOverlayElement(width, height, name) {\n        _classCallCheck(this, PanelOverlayElement);\n\n        var spriteMaterial = new THREE.SpriteMaterial({ color: 0x000000, opacity: 0 });\n        var sprite = new THREE.Sprite(spriteMaterial);\n        this.name = sprite.name = name || _helper2.default.getUUID();\n        this.sprite = sprite;\n\n        this._x = 0;\n        this._y = 0;\n\n        this.width = 0;\n        this.height = 0;\n\n        this.pWidth = width;\n        this.pHeight = height;\n\n        _buffer2.default.overlayBuffer.add(sprite.name, sprite);\n        this.children = new THREE.Group();\n        sprite.add(this.children);\n\n        this._materialName = '';\n\n        this._horizontalAlignment = '';\n        this._verticalAlignment = '';\n\n        this._elechildren = [];\n    }\n\n    _createClass(PanelOverlayElement, [{\n        key: 'addChild',\n        value: function addChild(obj) {\n            //console.log(\"%s add\", obj.name);\n            obj.pWidth = this.width;\n            obj.pHeight = this.height;\n            obj.sprite.position.z = this.sprite.position.z + 0.0001;\n            this.children.add(obj.sprite);\n            this._elechildren.push(obj);\n        }\n    }, {\n        key: 'setMaterialName',\n        value: function setMaterialName(name) {\n            this._materialName = name;\n            var _t3dmaterial = _buffer2.default.materialBuffer.get(name);\n            if (_t3dmaterial && _t3dmaterial.setOption) _t3dmaterial.setOption('SpriteMaterial');\n            this.sprite.t3dMaterial = _t3dmaterial;\n\n            var passes = _t3dmaterial.getTechnique(0).getPass();\n            if (passes.type && passes.type === 'web') {\n                passes = [{ material: passes }];\n            }\n            passes.map(function (v, k) {\n                var material = v.material;\n                if (!material) {\n                    //throw \"No material here.\";\n                    return;\n                }\n                if (material.type !== 'SpriteMaterial') {\n                    var old_material = material;\n                    material = new THREE.SpriteMaterial(); //this.sprite.material;\n                    material.name = old_material.name;\n                    if (old_material.map) {\n                        material.map = old_material.map;\n                    }\n                    if (old_material.color) {\n                        material.color.copy(old_material.color);\n                    }\n                    material.transparent = old_material.transparent;\n                    material.opacity = old_material.opacity;\n                    material.depthTest = false;\n                }\n                if (typeof _t3dmaterial.getTechnique(0).getPass(k).setMaterial === 'function') _t3dmaterial.getTechnique(0).getPass(k).setMaterial(material);else _t3dmaterial.getTechnique(0).getPass(k).material = material;\n                material.needsUpdate = true;\n            });\n        }\n    }, {\n        key: 'setPosition',\n        value: function setPosition(x, y) {\n            this._x = x;\n            this._y = y;\n\n            if (_buffer2.default.dom.offsetHeight == this.height && _buffer2.default.dom.offsetWidth == this.width) {\n                this.sprite.position.set(x, y, 1); // top left\n            } else {\n                x = -this.pWidth / 2 + this.width / 2 + x;\n                y = this.pHeight / 2 - this.height / 2 - y;\n                this.sprite.position.set(x, y, 1); // top left\n            }\n\n            //console.log(\"%s setPosition\", this.name, x, y);\n\n        }\n    }, {\n        key: 'setDimensions',\n        value: function setDimensions(width, height) {\n            this.width = width;\n            this.height = height;\n            this.sprite.scale.set(this.width, this.height, 1);\n            this.children.scale.set(1 / this.width, 1 / this.height, 1);\n            //this.children.position.set(-5, 32, 1);\n            //console.log(\"%s setDimensions\", this.name, width, height);\n            this.setPosition(this._x, this._y);\n            for (var i = 0; i < this._elechildren.length; i++) {\n                var ele = this._elechildren[i];\n                ele.pWidth = width;\n                ele.pHeight = height;\n                ele.setPosition(ele._x, ele._y);\n            }\n        }\n    }, {\n        key: 'setMetricsMode',\n        value: function setMetricsMode() {}\n    }, {\n        key: 'removeChild',\n        value: function removeChild(name) {\n            var obj = _buffer2.default.overlayBuffer.get(name);\n            this.sprite.remove(obj);\n        }\n    }, {\n        key: 'setZOrder',\n        value: function setZOrder() {}\n    }, {\n        key: 'show',\n        value: function show() {\n            this.sprite.visible = true;\n        }\n    }, {\n        key: 'hide',\n        value: function hide() {\n            this.sprite.visible = false;\n        }\n    }, {\n        key: 'setUV',\n        value: function setUV(a, b, c, d) {\n            console.log('PanelOverlayElement->setUV');\n        }\n    }, {\n        key: 'setHorizontalAlignment',\n        value: function setHorizontalAlignment(gha) {\n            console.log('PanelOverlayElement->setHorizontalAlignment');\n        }\n    }, {\n        key: 'setVerticalAlignment',\n        value: function setVerticalAlignment(gva) {\n            console.log('PanelOverlayElement->setVerticalAlignment');\n        }\n    }]);\n\n    return PanelOverlayElement;\n}();\n\nexports.default = PanelOverlayElement;\n\n//# sourceURL=webpack:///./src/overlay/PanelOverlayElement.js?")
        },
        "./src/overlay/overlayManager.js": /*!***************************************!*\
  !*** ./src/overlay/overlayManager.js ***!
  \***************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _Overlay = __webpack_require__(/*! ./Overlay.js */ "./src/overlay/Overlay.js");\n\nvar _Overlay2 = _interopRequireDefault(_Overlay);\n\nvar _PanelOverlayElement = __webpack_require__(/*! ./PanelOverlayElement.js */ "./src/overlay/PanelOverlayElement.js");\n\nvar _PanelOverlayElement2 = _interopRequireDefault(_PanelOverlayElement);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n    init: function init(scene, width, height) {\n        this.scene = scene;\n        this.width = width;\n        this.height = height;\n        this.overlayStore = {};\n    },\n    create: function create() {\n        var newNode = new THREE.Mesh();\n        this.scene.add(newNode);\n        return new _Overlay2.default(newNode);\n    },\n    createOverlay: function createOverlay() {\n        var newNode = new THREE.Mesh();\n        this.scene.add(newNode);\n        return new _Overlay2.default(newNode);\n    },\n    createOverlayElement: function createOverlayElement(elemName) {\n        this.overlayStore[elemName] = new _PanelOverlayElement2.default(this.width, this.height, elemName);\n        return this.overlayStore[elemName];\n    },\n    destroyOverlayElement: function destroyOverlayElement(name) {},\n    getOverlayElement: function getOverlayElement(elemName) {\n        return this.overlayStore[elemName];\n    }\n};\n\n//# sourceURL=webpack:///./src/overlay/overlayManager.js?')
        },
        "./src/renderer/FrameManager.js": /*!**************************************!*\
  !*** ./src/renderer/FrameManager.js ***!
  \**************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/**\r\n * @private 构造事件触发器,目前该触发器主要是为了static策略服务的\r\n */\nvar FrameManager = function () {\n    function FrameManager(scene, strategy) {\n        _classCallCheck(this, FrameManager);\n\n        this.strategy = strategy;\n        this.frameTime = 50;\n        this.changedObj = [];\n        this.addedObj = [];\n        this.scene = scene;\n    }\n\n    // add (obj, type){\n    //      if(type === \'staticAdded\'){\n    //          this.addedObj.push(obj);\n    //      } else{\n    //          this.changedObj.push(obj);\n    //      }\n    // }\n\n    _createClass(FrameManager, [{\n        key: "update",\n        value: function update(frameTime) {\n            this.frameTime = frameTime;\n            this.trigger();\n            this.clear();\n        }\n\n        //每帧触发执行,目前没有想好更好的机制来处理,理论上这个遍历还是可以省掉的\n\n    }, {\n        key: "trigger",\n        value: function trigger() {\n            //在整个场景去更新需要更新的矩阵\n            this.scene.traverse(function (v0) {\n                if (v0._staticDirty) {\n                    if (v0.matrixAutoUpdate) v0.updateMatrix();\n                    if (v0.parent) {\n                        v0.matrixWorld.multiplyMatrices(v0.parent.matrixWorld, v0.matrix);\n                    } else {\n                        v0.matrixWorld.copy(v0.matrix);\n                    }\n                    v0._staticDirty = false;\n                }\n            });\n        }\n        //TODO 这块需要思考一下如何能最快速度的找到父亲\n\n    }, {\n        key: "_getParent",\n        value: function _getParent(a, b) {}\n        // a.traverseAncestors()\n\n\n        // _setDirty (obj, dirty){\n        //      obj.traverse(function (v) {\n        //          v._staticDirty = dirty;\n        //          //应该更新包围盒\n        //          v._changeAABB = true;\n        //      })\n        // }\n\n        // _clearDirty (){\n        //     this.changedObj.map(obj=>{\n        //         obj.traverse(function (v) {\n        //             v._staticDirty = null;\n        //         });\n        //     });\n        //     this.addedObj.map(obj1=>{\n        //         obj1.traverse(function (v1) {\n        //             v1._dirty = null;\n        //         });\n        //     });\n        //\n        //\n        // }\n\n        //执行筛选排序逻辑\n\n    }, {\n        key: "process",\n        value: function process() {}\n        //清空\n\n    }, {\n        key: "clear",\n        value: function clear() {\n            // this._clearDirty();\n            this.changedObj = [];\n            this.addedObj = [];\n        }\n\n        // getChangedObj (){\n        //      return this.addedObj;\n        // }\n        //\n        // getAddedObj (){\n        //      return this.changedObj;\n        // }\n\n    }]);\n\n    return FrameManager;\n}();\n\nexports.FrameManager = FrameManager;\n\n//# sourceURL=webpack:///./src/renderer/FrameManager.js?')
        },
        "./src/renderer/RenderConfig.json": /*!****************************************!*\
  !*** ./src/renderer/RenderConfig.json ***!
  \****************************************/
        /*! exports provided: gammaFactor, gammaOutput, gammaInput, envMapIntensity, aoMapIntensity, aoMapFactor, aoFactor, toneMapping, static, transparentOption, logDepth, shadow, isWebGL2, darkFactor, default */
        function(module) {
            eval('module.exports = JSON.parse("{\\"gammaFactor\\":1.5,\\"gammaOutput\\":true,\\"gammaInput\\":true,\\"envMapIntensity\\":1.3,\\"aoMapIntensity\\":1.6,\\"aoMapFactor\\":2.4,\\"aoFactor\\":2.4,\\"toneMapping\\":1,\\"static\\":true,\\"transparentOption\\":0,\\"logDepth\\":false,\\"shadow\\":true,\\"isWebGL2\\":true,\\"darkFactor\\":0.75}");\n\n//# sourceURL=webpack:///./src/renderer/RenderConfig.json?')
        },
        "./src/renderer/RenderManager.js": /*!***************************************!*\
  !*** ./src/renderer/RenderManager.js ***!
  \***************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n//构建一个用于渲染的List,放入renderList中的对象必须实现render方法\nexports.default = {\n    init: function init(renderer, config) {\n        this._renderer = renderer;\n        this.config = config;\n        this.stack = [];\n    },\n    /**\r\n     * {\r\n     * 'renderer': renderer,\r\n     * 'scene': 'scene',\r\n     * 'camera': 'camera'\r\n     * }\r\n     */\n    add: function add(renderer, scene, camera) {\n        this.stack.push({\n            'renderer': renderer,\n            'scene': scene,\n            'camera': camera\n        });\n    },\n    // remove: function (index) {\n    //     var renderObj = this.stack.splice(index, 1);\n    //     return renderObj;\n    // },\n    replace: function replace(index, renderObj) {\n        if (renderObj && renderObj.renderer && renderObj.scene && renderObj.camera) {\n            this.stack.splice(index, 1, renderObj);\n        }\n    },\n    render: function render() {\n        if (this.stack.length === 0) return;\n        this._renderer.clear();\n        for (var i = 0, len = this.stack.length; i < len; i++) {\n            this.stack[i].renderer.render(this.stack[i].scene, this.stack[i].camera);\n        }\n    },\n    dirty: function dirty() {\n        if (this.stack.length === 0) return;\n        for (var i = 0, len = this.stack.length; i < len; i++) {\n            var renderer = this.stack[i].renderer;\n            if (renderer.dirty) {\n                renderer.dirty();\n            }\n        }\n    },\n    dirtyBig: function dirtyBig() {\n        if (this.stack.length === 0) return;\n        for (var i = 0, len = this.stack.length; i < len; i++) {\n            var renderer = this.stack[i].renderer;\n            if (renderer.dirtyBig) {\n                renderer.dirtyBig();\n            }\n        }\n    },\n    getRenderer: function getRenderer() {\n        return this._renderer;\n    },\n    getRenderSize: function getRenderSize() {\n        var size = this._renderer.getDrawingBufferSize(new THREE.Vector2());\n        return [size.width, size.height];\n    }\n};\n\n//# sourceURL=webpack:///./src/renderer/RenderManager.js?")
        },
        "./src/scene/QueryFlags.js": /*!*********************************!*\
  !*** ./src/scene/QueryFlags.js ***!
  \*********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.default = {\n    NONE_MASK: 0, // 不被查询\n    PICKABLE_MASK: 1 << 0,\n    CAMERACOLLISION_MASK: 1 << 1,\n    UNKOWN_MASK: 1 << 2\n};\n\n//# sourceURL=webpack:///./src/scene/QueryFlags.js?')
        },
        "./src/scene/RenderOperationType.js": /*!******************************************!*\
  !*** ./src/scene/RenderOperationType.js ***!
  \******************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = {\n\t/** A list of points, 1 vertex per point */\n\tPOINT_LIST: 'POINT_LIST',\n\t/** A list of lines, 2 vertices per line */\n\tLINE_LIST: 'LINE_LIST',\n\t/** A strip of connected lines, 1 vertex per line plus 1 start vertex */\n\tLINE_STRIP: 'LINE_STRIP',\n\t/** A list of triangles, 3 vertices per triangle */\n\tTRIANGLE_LIST: 'TRIANGLE_LIST',\n\t/** A strip of triangles, 3 vertices for the first triangle, and 1 per triangle after that */\n\tTRIANGLE_STRIP: 'TRIANGLE_STRIP',\n\t/** A fan of triangles, 3 vertices for the first triangle, and 1 per triangle after that */\n\tTRIANGLE_FAN: 'TRIANGLE_FAN'\n};\n\n//# sourceURL=webpack:///./src/scene/RenderOperationType.js?")
        },
        "./src/scene/RenderQueueGroupID.js": /*!*****************************************!*\
  !*** ./src/scene/RenderQueueGroupID.js ***!
  \*****************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.default = {\n    RENDER_QUEUE_BACKGROUND: 0,\n    RENDER_QUEUE_SKIES_EARLY: 5,\n    RENDER_QUEUE_1: 10,\n    RENDER_QUEUE_2: 20,\n    RENDER_QUEUE_WORLD_GEOMETRY_1: 25,\n    RENDER_QUEUE_3: 30,\n    RENDER_QUEUE_4: 40,\n    RENDER_QUEUE_MAIN: 50,\n    RENDER_QUEUE_6: 60,\n    RENDER_QUEUE_7: 70,\n    RENDER_QUEUE_WORLD_GEOMETRY_2: 75,\n    RENDER_QUEUE_8: 80,\n    RENDER_QUEUE_9: 90,\n    RENDER_QUEUE_SKIES_LATE: 95,\n    RENDER_QUEUE_OVERLAY: 100,\n    RENDER_QUEUE_MAX: 105\n};\n\n//# sourceURL=webpack:///./src/scene/RenderQueueGroupID.js?')
        },
        "./src/scene/SceneBlendFactor.js": /*!***************************************!*\
  !*** ./src/scene/SceneBlendFactor.js ***!
  \***************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n/** Blending factors for manually blending objects with the scene. If there isn\'t a predefined\r\n SceneBlendType that you like, then you can specify the blending factors directly to affect the\r\n combination of object and the existing scene. See Material::setSceneBlending for more details.\r\n Default: scene_blend one zero (opaque)\r\n @namespace t3djs.LayerBlendSource\r\n */\n//TODO t3d用法问题\nexports.default = {\n    /** Constant value of 1.0  */\n    ONE: THREE.NormalBlending,\n    /** Constant value of 0.0   */\n    ZERO: THREE.NormalBlending,\n    /** The existing pixel colour  */\n    DEST_COLOUR: THREE.NormalBlending,\n    /** The texture pixel (texel) colour   */\n    SOURCE_COLOUR: THREE.NormalBlending,\n    /** 1 - (dest_colour)    */\n    ONE_MINUS_DEST_COLOUR: THREE.NormalBlending,\n    /** 1 - (src_colour)  */\n    ONE_MINUS_SOURCE_COLOUR: THREE.NormalBlending,\n    /** The existing pixel alpha value  */\n    DEST_ALPHA: THREE.NormalBlending,\n    /** The texel alpha value  */\n    SOURCE_ALPHA: THREE.NormalBlending,\n    /** 1 - (dest_alpha)   */\n    ONE_MINUS_DEST_ALPHA: THREE.NormalBlending,\n    /** 1 - (src_alpha)  */\n    ONE_MINUS_SOURCE_ALPHA: THREE.NormalBlending\n};\n\n//# sourceURL=webpack:///./src/scene/SceneBlendFactor.js?')
        },
        "./src/scene/SceneBlendType.js": /*!*************************************!*\
  !*** ./src/scene/SceneBlendType.js ***!
  \*************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.default = {\n    /** Make the object transparent based on the final alpha values in the texture */\n    TRANSPARENT_ALPHA: THREE.NormalBlending,\n    /** Make the object transparent based on the colour values in the texture (brighter = more opaque) */\n    TRANSPARENT_COLOUR: THREE.CustomBlending,\n    /** Add the texture values to the existing scene content */\n    ADD: THREE.AdditiveBlending,\n    /** Multiply the 2 colours together */\n    MODULATE: THREE.MultiplyBlending,\n    /** The default blend mode where source replaces destination */\n    REPLACE: THREE.NoBlending\n};\n\n//# sourceURL=webpack:///./src/scene/SceneBlendType.js?')
        },
        "./src/scene/SceneLoadOptions.js": /*!***************************************!*\
  !*** ./src/scene/SceneLoadOptions.js ***!
  \***************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = {\n\t/** NO_OPTIONS */\n\tNO_OPTIONS: 0,\n\n\t/** Skips the environment settings in the file. Skipping the environment also skips shadows */\n\tSKIP_ENVIRONMENT: 0x1,\n\n\t/** Skips the shadow settings in the file */\n\tSKIP_SHADOWS: 0x2,\n\n\t/** Skips the sky settings in the file */\n\tSKIP_SKY: 0x4,\n\n\t/** Skips the nodes in the file */\n\tSKIP_NODES: 0x8,\n\n\t/** Skips the externals in the file */\n\tSKIP_EXTERNALS: 0x10,\n\n\t/** Skips the terrain in the file */\n\tSKIP_TERRAIN: 0x20,\n\n\t/** Skips scene level query flags in the file */\n\tSKIP_QUERY_FLAG_ALIASES: 0x200,\n\n\t/** Skips scene level visibility flags in the file */\n\tSKIP_VISIBILITY_FLAG_ALIASES: 0x400,\n\n\t/** Skips scene level resource locations in the file */\n\tSKIP_RESOURCE_LOCATIONS: 0x800,\n\n\t/** Indicates animation states should not be created for node animation tracks */\n\tNO_ANIMATION_STATES: 0x1000,\n\n\t/**\r\n  * Indicates scene 'externals' should not be stored. They will, however, still\r\n  * be loaded and the CreatedExternal() scene callback will be called\r\n  */\n\tNO_EXTERNALS: 0x2000,\n\n\t/**\r\n  * By default, the checks to see if the file that was passed\r\n  * in exists in the file system (outside of the configured resource locations).\r\n  * This flag disables that logic\r\n  */\n\tNO_FILE_SYSTEM_CHECK: 0x4000,\n\n\t/**\r\n  * Indicates that a light should be created if the loaded scene doesn't contain a light\r\n  * Any lights created as a result of setting the default lighting are not passed to\r\n  * the scene callback\r\n  */\n\tSET_DEFAULT_LIGHTING: 0x8000,\n\n\t/**\r\n  * Indicates that the 'fileNameOrContent' parameter in Load() should be treated as the\r\n  * scene XML. In other words, no file is loaded.\r\n  */\n\tFILE_NAME_CONTAINS_CONTENT: 0x10000,\n\n\t/** Skips mesh, texture, material, only for bin file     */\n\tSKIP_RESOURCE_BIN: 0x20000\n};\n\n//# sourceURL=webpack:///./src/scene/SceneLoadOptions.js?")
        },
        "./src/scene/SceneQueryTypeMask.js": /*!*****************************************!*\
  !*** ./src/scene/SceneQueryTypeMask.js ***!
  \*****************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.default = {\n    /** Query type mask which will be used for all */\n    ALL_TYPE_MASK: 0xFFFFFFFF,\n    /** Query type mask which will be used for world geometry @see SceneQuery */\n    WORLD_GEOMETRY_TYPE_MASK: 0x80000000,\n    /** Query type mask which will be used for entities @see SceneQuery */\n    ENTITY_TYPE_MASK: 0x40000000,\n    /** Query type mask which will be used for effects like billboardsets / particle systems @see SceneQuery */\n    FX_TYPE_MASK: 0x20000000,\n    /** Query type mask which will be used for StaticGeometry  @see SceneQuery */\n    STATICGEOMETRY_TYPE_MASK: 0x10000000,\n    /** Query type mask which will be used for lights  @see SceneQuery */\n    LIGHT_TYPE_MASK: 0x08000000,\n    /** Query type mask which will be used for frusta and cameras @see SceneQuery */\n    FRUSTUM_TYPE_MASK: 0x04000000\n};\n\n//# sourceURL=webpack:///./src/scene/SceneQueryTypeMask.js?')
        },
        "./src/scene/meshManager.js": /*!**********************************!*\
  !*** ./src/scene/meshManager.js ***!
  \**********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _buffer = __webpack_require__(/*! ../util/buffer.js */ "./src/util/buffer.js");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _cache = __webpack_require__(/*! ../loader/cache.js */ "./src/loader/cache.js");\n\nvar _cache2 = _interopRequireDefault(_cache);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n    createPlane: function createPlane(options) {\n        var name = \'FloorMesh\',\n            plane = options.plane,\n            width = options.width * (options.uTile || 1),\n            height = options.height * (options.vTile || 1),\n            xsegments = options.xsegments,\n            ysegments = options.ysegments,\n\n\n        // upVector = options.upVector || [0, 1, 0];\n        //在调整ITV的时候发现穿过来的options.plane[0]，这个才是他朝上的方向\n        upVector = options.plane[0] || [0, 1, 0];\n\n        if (upVector) {\n            this.up = new THREE.Vector3(upVector[0], upVector[1], upVector[2]);\n        }\n\n        // var floorGeometry = new THREE.PlaneBufferGeometry(20, 20);\n        var geometry = new THREE.PlaneBufferGeometry(width, height, xsegments, ysegments);\n        geometry.up = this.up;\n        geometry.uTile = options.uTile;\n        geometry.vTile = options.vTile;\n        geometry.type = \'Floor\';\n        // var  material = new THREE.MeshBasicMaterial({\n        //  color: 0xffff00,\n        //  side: THREE.DoubleSide\n        // });\n\n        // var plane = new THREE.Mesh(geometry, material);\n\n        // plane.receiveShadow = true;\n        // plane.rotation.x = -Math.PI / 2.0;\n        // plane.position.set(0, 0, 0);\n\n        _cache2.default.add(name, geometry);\n        return geometry;\n    },\n\n    getMesh: function getMesh(name) {\n        return _buffer2.default.entityBuffer.get(name);\n    }\n\n};\n\n//# sourceURL=webpack:///./src/scene/meshManager.js?')
        },
        "./src/scene/renderWindow.js": /*!***********************************!*\
  !*** ./src/scene/renderWindow.js ***!
  \***********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _storage = __webpack_require__(/*! ../loader/storage.js */ \"./src/loader/storage.js\");\n\nvar _storage2 = _interopRequireDefault(_storage);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n  width: 0,\n  height: 0,\n  init: function init(renderer) {\n    this.renderer = renderer;\n  },\n  getHeight: function getHeight() {\n    return this.renderer.domElement.clientHeight;\n  },\n  getWidth: function getWidth() {\n    return this.renderer.domElement.clientWidth;\n  },\n  writeContentsToFile: function writeContentsToFile(localfile, imgWidth, imgHeight) {\n    var canvas = document.getElementById('t3d') || window;\n    canvas.children[1].setAttribute('crossOrigin', 'anonymous');\n    var d = canvas.children[0].toDataURL('image/png');\n    return d;\n  }\n};\n\n//# sourceURL=webpack:///./src/scene/renderWindow.js?")
        },
        "./src/scene/sceneManager.js": /*!***********************************!*\
  !*** ./src/scene/sceneManager.js ***!
  \***********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _camera2 = __webpack_require__(/*! ../camera/camera.js */ \"./src/camera/camera.js\");\n\nvar _camera3 = _interopRequireDefault(_camera2);\n\nvar _buffer = __webpack_require__(/*! ../util/buffer.js */ \"./src/util/buffer.js\");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _cache = __webpack_require__(/*! ../loader/cache.js */ \"./src/loader/cache.js\");\n\nvar _cache2 = _interopRequireDefault(_cache);\n\nvar _helper = __webpack_require__(/*! ../util/helper.js */ \"./src/util/helper.js\");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nvar _ManualObject = __webpack_require__(/*! ../geometry/ManualObject.js */ \"./src/geometry/ManualObject.js\");\n\nvar _ManualObject2 = _interopRequireDefault(_ManualObject);\n\nvar _SceneNodeSelection = __webpack_require__(/*! ../selection/SceneNodeSelection.js */ \"./src/selection/SceneNodeSelection.js\");\n\nvar _SceneNodeSelection2 = _interopRequireDefault(_SceneNodeSelection);\n\nvar _billboard = __webpack_require__(/*! ../billboard/billboard.js */ \"./src/billboard/billboard.js\");\n\nvar _billboard2 = _interopRequireDefault(_billboard);\n\nvar _TextureAddressingMode = __webpack_require__(/*! ../material/TextureAddressingMode.js */ \"./src/material/TextureAddressingMode.js\");\n\nvar _TextureAddressingMode2 = _interopRequireDefault(_TextureAddressingMode);\n\nvar _animation = __webpack_require__(/*! ../animation/animation.js */ \"./src/animation/animation.js\");\n\nvar _animation2 = _interopRequireDefault(_animation);\n\nvar _animationState = __webpack_require__(/*! ../animation/animationState.js */ \"./src/animation/animationState.js\");\n\nvar _animationState2 = _interopRequireDefault(_animationState);\n\nvar _animationLodState = __webpack_require__(/*! ../animation/animationLodState.js */ \"./src/animation/animationLodState.js\");\n\nvar _animationLodState2 = _interopRequireDefault(_animationLodState);\n\nvar _math = __webpack_require__(/*! ../util/math.js */ \"./src/util/math.js\");\n\nvar _math2 = _interopRequireDefault(_math);\n\nvar _lightManager = __webpack_require__(/*! ../light/lightManager.js */ \"./src/light/lightManager.js\");\n\nvar _lightManager2 = _interopRequireDefault(_lightManager);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n  init: function init(scene, camera, closeFlag) {\n    closeFlag = closeFlag || false;\n    this.selections = {};\n    this.camera = camera;\n    this.scene = scene;\n\n    //TODO: debugger 使用\n    this.buffer = _buffer2.default;\n    if (!closeFlag) {\n      // scene.add(this.ambient);\n      _lightManager2.default.init(scene);\n      this.ambient = _lightManager2.default.getAmbientLight();\n    }\n  },\n  //agr2 这个玩意儿暂时也存成String吧这样方便一点\n  //TODO:entity需要构造成一个function\n  createEntity: function createEntity(agr1, agr2) {\n    var that = this;\n    var mesh, entityName, entity;\n    if (typeof agr1 == 'string' && typeof agr2 == 'string') {\n      if (agr2.indexOf('.mesh') > 0) {\n        agr2 = agr2.substr(0, agr2.indexOf('.mesh'));\n        agr2 += '.gltf';\n      }\n      mesh = _cache2.default.get(agr2);\n      // mesh = buffer.meshBuffer.get(agr2);\n      if (!mesh) {\n        console.log('没有找到' + agr2);\n        return;\n      }\n      entityName = agr1;\n    } else if (typeof agr1 == 'string' && typeof agr2 != 'string') {\n      mesh = agr2;\n      entityName = agr1;\n    } else if (typeof agr1 != 'string' && typeof agr2 == 'undefined') {\n      mesh = agr1;\n      entityName = agr1.name;\n    }\n    //如果是进来的有可能是Scene\n    // debugger;\n    if (mesh.type == 'Scene' || mesh.type == 'Line' || mesh.type == 'LineSegments' || mesh.type == 'Mesh' || mesh.type == 'Object3D') {\n      //TODO: 对就是这里，同样的代码写了两遍，下面还有一遍\n      mesh.yaw = function (degree) {\n\n        var radians = degree / 180;\n        this.rotateY(radians);\n      };\n\n      //粒子系统不克隆\n      if (mesh.PARTICLES_PER_CONTAINER !== undefined) {\n        entity = mesh;\n      } else {\n        entity = mesh.clone();\n      }\n\n      entity.name = entityName;\n      _buffer2.default.entityBuffer.add(entityName, entity);\n    } else {\n      var material = new THREE.MeshStandardMaterial({});\n      var obj = new THREE.Mesh(mesh, material);\n      //TODO: 对就是这里，同样的代码写了两遍，上面还有一遍\n      obj.yaw = function (degree) {\n        var radians = degree / 180;\n        this.rotateY(radians);\n      };\n      entity = obj;\n      entity.name = entityName;\n\n      if (mesh.up) {\n        entity.lookAt(mesh.up);\n      }\n      // if (mesh.type == \"Floor\") {\n      //  entity.receiveShadow = true;\n      //  entity.rotation.x = -Math.PI / 2.0;\n      // }\n      _buffer2.default.entityBuffer.add(entityName, entity);\n    }\n    //TODO: 丑陋至极\n    entity.setMaterialName = function (name) {\n      //t3dMaterial\n      var t3dMaterial = _buffer2.default.materialBuffer.get(name);\n      var temMat = _buffer2.default.materialBuffer.get(name).getTechnique(0).getPass(0).material;\n      if (t3dMaterial.type == 'web') {\n        // debugger\n        // var webMaterial = new THREE.MeshBasicMaterial({\n        //   color: new THREE.Color('black'),\n        //   opacity: 0,\n        //   blending: THREE.NoBlending,\n        //   side: THREE.DoubleSide\n        // });\n\n        var css3Obj = new THREE.CSS3DObject(t3dMaterial.iframe);\n        this.type = 'web';\n        this.visable = false;\n        this.mat = css3Obj;\n        // this.material = webMaterial;\n        // var elementW = this.geometry.parameters.width;\n        // var elementH = this.geometry.parameters.height;\n        // var planeW = this.geometry.parameters.width;\n        // var planeH = this.geometry.parameters.height;\n        // var mixerPlane = new THREEx.HtmlMixer.Plane(t3dMaterial.mixerContext, t3dMaterial.iframe, {\n        //   object3d: this,\n        //   elementW: elementW,\n        //   elementH: elementH,\n        //   planeW: planeW,\n        //   planeH: planeH,\n        // });\n        // mixerPlane.object3d.scale.multiplyScalar(2);\n        return;\n        //buffer.entityBuffer.add(this.name, mixerPlane.object3d);\n      }\n      //这块处理的不好，下面这块\n      if (mesh.uTile && mesh.vTile && temMat.map) {\n        temMat.map.repeat.set(mesh.uTile, mesh.vTile);\n        this.material = temMat;\n        this.t3dMaterial = t3dMaterial;\n        var texUnit = this.t3dMaterial.getTechnique(0).getPass(0).getTextureUnitState();\n        texUnit.map(function (arr) {\n          return arr.setTextureAddressingMode(_TextureAddressingMode2.default.WRAP);\n        });\n        // texUnit.params.TextureAddressingMode = 3;\n        // this.t3dMaterial  TextureAddressingMode\n      } else {\n        this.setMaterial(t3dMaterial);\n      }\n    };\n    //support many passes\n    entity.setMaterial = function (mat) {\n      mat.parent = this;\n      this._recursionSetMat(mat, this);\n      // //this.t3dMaterial = mat;\n      // //this.material = mat.getTechnique(0).getPass(0).material;\n      // var tech = mat.getTechnique();\n      // if (tech.length <= 1) {\n      //   var pass = tech[0].getPass();\n      //   if (pass.length <= 1) {\n      //     // this.material = pass[0].material;\n      //     //彩色盒子，颜色不对，避免给没有geometry的节点设置材质\n      //     this._recursionSetMat(pass[0].material, mat, this);\n      //   }\n      //   //process many passes\n      //   else {\n      //     var materialArray = [];\n      //     for (var i = 0; i < pass.length; i++) {\n      //       materialArray.push(pass[i].material);\n      //     }\n      //     var entity = new THREE.SceneUtils.createMultiMaterialObject(this.geometry, materialArray);\n      //     var entityName = this.name;\n      //     //update new Entity in buffer\n      //     this.visible = false;\n      //     buffer.entityBuffer.delete(entityName);\n      //     buffer.entityBuffer.add(entityName, entity);\n      //     this.parent.add(entity);\n      //     //entity.parent = this.parent;\n      //     //todo is not updating?? why?\n      //   }\n      // } //todo many techniques\n      // else {}\n    };\n    entity.setQueryFlags = function (flag, bool) {\n      this.quertFlag = flag;\n    };\n    entity.toString = function () {\n      return this.name;\n    };\n    entity.setRenderQueueGroup = function (val) {\n      this.renderOrder = val;\n    };\n    entity._recursionSetMat = function (t3dMat, node) {\n      if (node.geometry) {\n        node.t3dMaterial = t3dMat;\n      } else {\n        this._recursionSetMat(t3dMat, node.children[0]);\n      }\n    };\n    //这里需要改造一下，在渲染级别处理\n    entity.setVisibilityFlags = function (visibilityFlags, isRecursive) {\n      isRecursive = isRecursive || false;\n      if (!visibilityFlags) return;\n      var visibilityBuffer = _buffer2.default.visibilityBuffer.get(visibilityFlags) || [];\n      if (!visibilityBuffer.length) {\n        _buffer2.default.visibilityBuffer.add(visibilityFlags, visibilityBuffer);\n      }\n      visibilityBuffer.push(this);\n      this.visibilityFlags = visibilityFlags;\n      if (isRecursive) {\n        this.traverse(function (obj) {\n          if (obj instanceof THREE.Mesh || obj instanceof THREE.Line || obj instanceof THREE.Sprite) {\n            obj.visibilityFlags = visibilityFlags;\n            visibilityBuffer.push(obj);\n          }\n        });\n      }\n    };\n    return entity;\n  },\n  getSceneNode: function getSceneNode(name) {\n    return _buffer2.default.nodeBuffer.get(name);\n  },\n  getRootSceneNode: function getRootSceneNode() {\n    return _buffer2.default.nodeBuffer.get('rootNode');\n  },\n  getEntity: function getEntity(name) {\n    return _buffer2.default.entityBuffer.get(name);\n  },\n  getAllEntities: function getAllEntities() {\n    var res = _buffer2.default.entityBuffer.getAll();\n    if (!res) return [];\n    var entities = [];\n    for (var k in res) {\n      entities.push(res[k]);\n    }\n    return entities;\n  },\n  createLight: function createLight(name) {\n    var light = new THREE.PointLight(0xffffff, 1, 100);\n    // this.scene.add(light);\n    _buffer2.default.lightBuffer.add(name, light);\n    light.castShadow = true;\n    var lightManager = {\n      name: name,\n      type: 'light',\n      setPosition: function setPosition(x, y, z) {\n        light.position.set(x, y, z);\n      },\n      setDiffuseColour: function setDiffuseColour(color) {\n        var myColor = new THREE.Color(color[0], color[1], color[2]);\n        light.color.copy(myColor);\n      }\n    };\n    return lightManager;\n  },\n  setAmbientLight: function setAmbientLight(color) {\n    var lightColor = new THREE.Color(color[0], color[1], color[2]);\n    this.ambient.color = lightColor;\n  },\n  createDirectionLight: function createDirectionLight(name) {\n    var light = new THREE.DirectionalLight(new THREE.Color(1, 0.93333333, 0.866666666), 0.5);\n\n    // this.scene.add(light);\n    _buffer2.default.lightBuffer.add(name, light);\n    light.castShadow = true;\n    var lightManager = {\n      name: name,\n      type: 'light',\n      setPosition: function setPosition(x, y, z) {\n        light.position.set(x, y, z);\n      },\n      setDiffuseColour: function setDiffuseColour(color) {\n        var myColor = new THREE.Color(color[0], color[1], color[2]);\n        light.color.copy(myColor);\n      }\n    };\n    return lightManager;\n  },\n  createManualObject: function createManualObject(name) {\n    return new _ManualObject2.default(name);\n  },\n  createBillboardSet: function createBillboardSet() {\n    return new _billboard2.default(this.camera);\n  },\n\n  createSceneNodeSelection: function createSceneNodeSelection(name) {\n    if (name === undefined) name = _helper2.default.getUUID();\n    var slection = new _SceneNodeSelection2.default(name, this.scene);\n    if (this.selections[name]) {\n      this.destroySceneNodeSelection(name);\n      delete this.selections[name];\n    }\n    this.selections[name] = slection;\n    return slection;\n  },\n  setDefaultQueryFlags: function setDefaultQueryFlags() {\n    //TODO:哇\n  },\n  setDefaultVisibilityFlags: function setDefaultVisibilityFlags() {},\n  createAnimationState: function createAnimationState(name) {\n    return new _animationState2.default(name);\n  },\n  getAnimationState: function getAnimationState(name) {\n    if (_buffer2.default.animationStateBuffer.get(name)) {\n      return _buffer2.default.animationStateBuffer.get(name);\n    }\n    //否则即为lod，因为lod模型的动画名字都会有lod标识\n    var allState = _buffer2.default.animationStateBuffer.getAll();\n    var stateArr = [];\n    var reg = new RegExp('lod\\\\d{1,}@-', 'g');\n    for (var k in allState) {\n      if (k.replace(reg, '') == name) {\n        stateArr.push(allState[k]);\n      }\n    }\n    // console.log(stateArr);\n    var animations;\n    if (stateArr.length > 0) {\n      animations = new _animationLodState2.default(stateArr);\n    }\n    return animations;\n    //return buffer.animationStateBuffer.get(name);\n  },\n\n  //if boolean is true,animationAction will be reset,default is false\n  destroyAnimationState: function destroyAnimationState(name, boolean) {\n    boolean = boolean || false;\n    var animationState = _buffer2.default.animationStateBuffer.get(name);\n    animationState.setEnabled(false, boolean);\n    _buffer2.default.animationStateBuffer.delete(name);\n    // animationState.releaseMemory();\n  },\n  createAnimation: function createAnimation(name, time) {\n    return new _animation2.default(name, time);\n  },\n  getAnimation: function getAnimation(name) {\n    return _buffer2.default.animationBuffer.get(name);\n  },\n  destroyAnimation: function destroyAnimation(name) {\n    _buffer2.default.animationBuffer.delete(name);\n  },\n\n  getCurrentCamera: function getCurrentCamera() {\n    return _camera3.default;\n  },\n  pickSprite2D: function pickSprite2D() {\n    return null;\n  },\n  createSprite2D: function createSprite2D(name, width, height, shpereCull, shpereCenter) {\n    width = parseFloat(width);\n    height = parseFloat(height);\n    var billboard = new THREE.Sprite();\n    billboard.scale.set(width, height, 1);\n    billboard.name = name;\n    billboard.type = 'Sprite2D';\n    _buffer2.default.entityBuffer.add(billboard.name, billboard);\n    _buffer2.default.nodeBuffer.add(billboard.name, billboard);\n    return billboard;\n    //console.warn(\"createSprite2D没实现\");\n  },\n  //defaultSceneLight\n  createDefaultSceneLight: function createDefaultSceneLight(pos, option) {},\n  setIntensity: function setIntensity(val) {\n    this.ambient.intensity = val;\n  },\n  destroySceneNodeSelection: function destroySceneNodeSelection(name) {\n    var selection = this.selections[name];\n    if (selection) {\n      selection.isDestroy = true;\n      selection.destroy();\n      delete this.selections[name];\n    }\n  },\n  //TODO 这个接口会导致内存泄漏问题，但是uinv一直再调用，如果不和老t3d一致就会出错\n  destroySceneNode: function destroySceneNode(name) {\n    var temNode = name;\n    if (typeof name === 'string') {\n      temNode = _buffer2.default.nodeBuffer.get(name);\n      _buffer2.default.nodeBuffer.delete(name);\n      _buffer2.default.entityBuffer.delete(name);\n    } else {\n      _buffer2.default.nodeBuffer.delete(name.name);\n      _buffer2.default.entityBuffer.delete(name.name);\n    }\n    if (temNode) {\n      if (temNode.selections) {\n        for (var pro in temNode.selections) {\n          var select = temNode.selections[pro];\n          select.unselect(temNode, false);\n        }\n        temNode.selections = null;\n      }\n      if (temNode.modifiers) {\n        for (var _i = 0; _i < temNode.modifiers.length; _i++) {\n          var modif = temNode.modifiers[_i];\n          modif.removeSceneNode(temNode);\n        }\n        temNode.modifiers = null;\n      }\n      if (temNode.geometry) {\n        var geometry = temNode.geometry;\n        if (geometry.colors) geometry.colors.length = 0;\n        if (geometry.faces) geometry.faces.length = 0;\n        if (geometry.faceVertexUvs) geometry.faceVertexUvs.length = 0;\n        geometry.dispose();\n      }\n      if (temNode.material) {\n        //temNode.material.uniforms = null;\n        //temNode.material.map = null;\n      }\n      if (temNode.t3dMaterial) {\n        //temNode.t3dMaterial.destroy();\n        //temNode.material.dispose();\n      }\n      for (var i = 0; i < temNode.children.length; i++) {\n        this.destroySceneNode(temNode.children[i]);\n      }\n      temNode.destroy();\n      temNode.parent.remove(temNode);\n      temNode = null;\n    }\n  },\n  getAllLights: function getAllLights() {\n    //TODO: 没有实现\n    return [];\n  },\n  //TODO: 没有实现\n  setSkyBox: function setSkyBox() {},\n  setFog: function setFog(color, near, far) {\n    // this.scene.fog = new THREE.FogExp2( 0xFFFFFF, 0.0005 );\n    this.scene.fog = new THREE.Fog(new THREE.Color(color[0], color[1], color[2]), near, far);\n  },\n  getManualObject: function getManualObject(name) {\n    return _buffer2.default.entityBuffer.get(name);\n  },\n  createRectangle2D: function createRectangle2D() {\n    function Rectangle2D() {\n      var spriteMaterial = new THREE.SpriteMaterial({ color: 0xff0000, opacity: 0 });\n      var sprite = new THREE.Sprite(spriteMaterial);\n      this.name = sprite.name = _helper2.default.getUUID();\n\n      _buffer2.default.nodeBuffer.add(this.name, sprite);\n      this.sprite = sprite;\n      _buffer2.default.entityBuffer.add(this.name, this.sprite);\n    }\n    Rectangle2D.prototype = {\n      setCorners: function setCorners(left, top, right, bottom) {\n        this.sprite.scale.set(window.innerWidth, window.innerHeight, 1);\n      },\n      setRenderQueueGroup: function setRenderQueueGroup() {},\n      setInfiniteBoundingBox: function setInfiniteBoundingBox() {}\n    };\n    return new Rectangle2D();\n  },\n  destroyManualObject: function destroyManualObject(name) {\n    var temEntity = _buffer2.default.entityBuffer.get(name);\n    _buffer2.default.entityBuffer.delete(name);\n    if (temEntity && temEntity.geometry) {\n      var geometry = temEntity.geometry;\n      if (geometry.colors) {\n        geometry.colors.length = 0;\n      }\n      if (geometry.faces) {\n        geometry.faces.length = 0;\n      }\n      if (geometry.faceVertexUvs) {\n        geometry.faceVertexUvs.length = 0;\n      }\n      if (geometry.vertices) {\n        geometry.vertices.length = 0;\n      }\n      geometry.dispose();\n      temEntity.geometry = null;\n    }\n    temEntity = null;\n    //console.log(\"destroyManualObject\");\n  },\n\n  changeDirectLight: function changeDirectLight(light, option, boundingSphere, showHelper) {\n    var defaultoption = {\n      intensity: light.intensity || 0.5,\n      alpha: light.alpha || 120,\n      beta: light.beta || 0,\n      shadow: true,\n      shadowQuality: 1024\n    };\n\n    option = Object.assign({}, defaultoption, option);\n    light.intensity = option.intensity;\n    light.visible = option.intensity > 0;\n\n    light.alpha = option.alpha;\n    light.beta = option.beta;\n    light.position.copy(_math2.default.directionFromAlphaBeta(option.alpha, option.beta));\n    light.position.normalize().multiplyScalar(boundingSphere.radius || 1).add(new THREE.Vector3(boundingSphere.center[0], boundingSphere.center[1], boundingSphere.center[2]));\n    light.target.position.copy(new THREE.Vector3(boundingSphere.center[0], boundingSphere.center[1], boundingSphere.center[2]));\n    light.target.updateMatrixWorld(true);\n    if (light.helper) {\n      this.scene.remove(light.helper);\n    }\n    light.castShadow = option.shadow;\n    if (light.castShadow) {\n      var shadowCamera = light.shadow.camera;\n      shadowCamera.top = shadowCamera.right = boundingSphere.radius;\n      shadowCamera.bottom = shadowCamera.left = -boundingSphere.radius;\n      shadowCamera.near = 0.1;\n      shadowCamera.far = boundingSphere.radius * 2;\n      shadowCamera.updateProjectionMatrix();\n      var shadowResolution = {\n        'low': 512,\n        'medium': 1024,\n        'high': 2048,\n        'ultra': 4096\n      }[option.shadowQuality] || 1024;\n      light.shadow.bias = -0.003;\n      light.shadow.radius = 0.1;\n      light.shadow.mapSize.set(shadowResolution, shadowResolution);\n    }\n    if (showHelper && light.intensity > 0) {\n      var lightHelper = new THREE.DirectionalLightHelper(light);\n      light.helper = lightHelper;\n      this.scene.add(lightHelper);\n      lightHelper.update();\n    }\n  },\n\n  getDirectionalLight: function getDirectionalLight() {\n    return _lightManager2.default.getDirectionalLight();\n  },\n\n  //聚光灯\n  createSpotLight: function createSpotLight(position, helper) {\n    position = position || [10, 10, 10];\n    var spotLight = new THREE.SpotLight(0xffffff, 0.5);\n    spotLight.position.set(position[0], position[1], position[2]);\n    spotLight.angle = Math.PI / 4;\n    this.scene.add(spotLight);\n    if (helper) {\n      var lightHelper = new THREE.SpotLightHelper(spotLight);\n      spotLight.helper = lightHelper;\n      this.scene.add(lightHelper);\n    }\n    return spotLight;\n  },\n\n  changeSpotLight: function changeSpotLight(light, option, boundingSphere, showHelper) {\n    var defaultoption = {\n      intensity: light.intensity || 0.5,\n      alpha: light.alpha || 120,\n      beta: light.beta || 0,\n      angle: light.angle,\n      distance: light.distance,\n      shadow: true,\n      shadowQuality: 1024,\n      penumbra: light.penumbra,\n      decay: light.decay\n    };\n\n    option = Object.assign({}, defaultoption, option);\n    light.intensity = option.intensity;\n    light.penumbra = option.penumbra;\n    light.decay = option.decay;\n    light.visible = option.intensity > 0;\n\n    light.alpha = option.alpha;\n    light.beta = option.beta;\n    light.position.copy(_math2.default.directionFromAlphaBeta(option.alpha, option.beta));\n    light.position.normalize().multiplyScalar(boundingSphere.radius || 1).add(new THREE.Vector3(boundingSphere.center[0], boundingSphere.center[1], boundingSphere.center[2]));\n    light.distance = option.distance;\n    light.angle = option.angle;\n    if (light.helper) {\n      this.scene.remove(light.helper);\n    }\n    if (showHelper && light.intensity > 0) {\n      var lightHelper = new THREE.SpotLightHelper(light);\n      light.helper = lightHelper;\n      this.scene.add(lightHelper);\n      lightHelper.update();\n    }\n  }\n}; /**\r\n    * [THREE description]\r\n    *  yaw,row,pitch 有必要优化一下啊S h i t\r\n    * @type {[type]}\r\n    */\n\n//# sourceURL=webpack:///./src/scene/sceneManager.js?")
        },
        "./src/scene/viewport.js": /*!*******************************!*\
  !*** ./src/scene/viewport.js ***!
  \*******************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.default = {\n    init: function init(scene, renderer) {\n        this.scene = scene;\n        this.renderer = renderer;\n    },\n    color: [0, 0, 0],\n    get backgroundColour() {\n        return this.color;\n    },\n    set backgroundColour(value) {\n        this.color = value;\n        var color = new THREE.Color(value[0], value[1], value[2]);\n        this.scene.background = color;\n    },\n    setBackgroundColour: function setBackgroundColour(color) {\n        this.backgroundColour = color;\n    },\n    getActualWidth: function getActualWidth() {\n        return this.renderer.domElement.clientWidth;\n    },\n    getActualHeight: function getActualHeight() {\n        return this.renderer.domElement.clientHeight;\n    }\n};\n\n//# sourceURL=webpack:///./src/scene/viewport.js?')
        },
        "./src/selection/MaterialModifier.js": /*!*******************************************!*\
  !*** ./src/selection/MaterialModifier.js ***!
  \*******************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _helper = __webpack_require__(/*! ../util/helper.js */ \"./src/util/helper.js\");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nvar _tween = __webpack_require__(/*! ../extra/tween.js */ \"./src/extra/tween.js\");\n\nvar _tween2 = _interopRequireDefault(_tween);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar calculate = function calculate(f, t, d, func) {\n  if (typeof func !== 'function') {\n    func = _tween2.default.Cubic.Quart.easeInOut;\n  }\n  var result = [];\n  //var frames = Math.ceil(d / 16);\n  var frames = d | 0;\n  f *= 1.0;\n  t *= 1.0;\n  for (var i = 0; i <= frames; i++) {\n    var n = func(i, 0, 1, frames);\n    n = f + (t - f) * n;\n    result.push(n);\n  }\n  return result;\n};\n\nfunction selectMaterial(nodes) {\n  for (var pro in nodes) {\n    var t3d_mat_origin = nodes[pro].t3dMaterial;\n    if (!t3d_mat_origin) {\n      continue;\n    }\n    if (this._nodesMap[pro]) {\n      continue;\n    }\n\n    if (!nodes[pro].modifiers) {\n      nodes[pro].modifiers = [];\n    }\n    nodes[pro].modifiers.push(this);\n\n    this._nodesMap[pro] = nodes[pro];\n    var mat_origin = t3d_mat_origin.getTechnique(0).getPass(0);\n    var t3d_mat_key = mat_origin.material.name;\n    var t3d_mat_bak = this._materialCopy[t3d_mat_key];\n    var mat_bak = t3d_mat_bak && t3d_mat_bak.material.getTechnique(0).getPass(0);\n    if (!t3d_mat_bak) {\n      t3d_mat_bak = this._materialCopy[t3d_mat_key] = { refrence: 0, material: t3d_mat_origin.clone() };\n      mat_bak = t3d_mat_bak.material.getTechnique(0).getPass(0);\n\n      if (mat_origin.material.alphaColor) {\n        mat_bak.material.backup_color = mat_origin.material.alphaColor.clone();\n      }\n\n      var opacity = this._trans === -1 ? mat_origin.material.opacity : 1 - this._trans;\n\n      if (this.override) {\n        //本次是override,并且覆盖之前的override\n        mat_bak.material.opacity = opacity;\n        if (this._colour.x + this._colour.y + this._colour.z > -1) {\n          mat_bak.material.alphaColor = this._colour.clone();\n          mat_bak.material.override_color = this._colour.clone();\n        }\n      } else if (mat_origin.material.override_color) {\n        //之前是override，本次不是\n        mat_bak.material.opacity = mat_origin.material.opacity;\n        mat_bak.material.alphaColor = mat_origin.material.override_color.clone();\n        mat_bak.material.override_color = mat_origin.material.override_color.clone();\n      } else {\n        //都不是override\n        mat_bak.material.opacity = opacity;\n        if (this._colour.x + this._colour.y + this._colour.z > -1) {\n          mat_bak.material.alphaColor = this._colour.clone();\n        }\n      }\n\n      if (mat_bak.material.opacity < 1) {\n        mat_bak.material.transparent = true;\n        mat_bak.material.depthWrite = false;\n      } else {\n        // mat_bak.material.transparent = false;\n      }\n\n      if (this._isFlashing) {\n        mat_bak.material.alphaColor.w = 0;\n      }\n\n      mat_bak.material.needsUpdate = true;\n    }\n    t3d_mat_bak.refrence++;\n\n    nodes[pro][this.bak_name] = nodes[pro]['t3dMaterial'];\n    //nodes[pro][\"material_bak_\" + this.name] = nodes[pro][\"material\"];\n    nodes[pro].t3dMaterial = t3d_mat_bak.material;\n    nodes[pro].material = mat_bak.material;\n  }\n}\n\nfunction before(node, result) {\n  if (!Array.isArray(result)) {\n    result = [];\n  }\n  var index = node.modifiers.indexOf(this);\n  if (index < 0 || index == node.modifiers.length - 1) {\n    return result;\n  }\n  result = node.modifiers.splice(index + 1);\n  result.reverse();\n  for (var i = 0; i < result.length; i++) {\n    var mo = result[i];\n    var nodes = {};\n    nodes[node.name] = node;\n    unselectMaterial.call(mo, nodes);\n  }\n  //console.info('修改器协助排序，退出:%s个',result.length);\n  return result;\n}\n\nfunction after(node, result) {\n  if (!Array.isArray(result) || result.length < 1) {\n    return;\n  }\n  for (var i = 0; i < result.length; i++) {\n    var mo = result[i];\n    var nodes = {};\n    nodes[node.name] = node;\n    selectMaterial.call(mo, nodes);\n  }\n  //console.info('修改器协助排序，进入:%s个',result.length);\n}\n\nfunction unselectMaterial(nodes) {\n  var t3d_mat_bak_pro = this.bak_name;\n  //var mat_bak_pro = \"material_bak_\" + this.name;\n  for (var pro in nodes) {\n    if (!this._nodesMap[pro]) {\n      continue;\n    }\n    delete this._nodesMap[pro];\n\n    if (!nodes[pro].modifiers) {\n      continue;\n    }\n\n    var bak_removed_modifier = before.call(this, nodes[pro]);\n\n    var last = nodes[pro].modifiers.pop();\n    if (last != this) {\n      //console.error('修改器退出顺序错误，期望:%s，实际:%s',last.name,this.name);\n      nodes[pro].modifiers.push(last);\n      continue;\n    }\n    if (nodes[pro].t3dMaterial && nodes[pro][t3d_mat_bak_pro]) {\n      var t3d_mat_bak = nodes[pro].t3dMaterial = nodes[pro][t3d_mat_bak_pro];\n      var mat_bak = nodes[pro].material = t3d_mat_bak.getTechnique(0).getPass(0).material;\n      var t3d_mat_key = mat_bak.name;\n      delete nodes[pro][t3d_mat_bak_pro];\n      //delete nodes[pro][mat_bak_pro];\n      if (this._materialCopy[t3d_mat_key]) {\n        if (typeof this._materialCopy[t3d_mat_key].refrence === 'number') {\n          this._materialCopy[t3d_mat_key].refrence--;\n        } else {\n          console.log('[%s] didn\\'t found', t3d_mat_key);\n        }\n        if (this._materialCopy[t3d_mat_key].refrence < 1) {\n          delete this._materialCopy[t3d_mat_key];\n        }\n      } else {\n        console.log('[%s] didn\\'t found', t3d_mat_key);\n      }\n    }\n    after.call(this, nodes[pro], bak_removed_modifier);\n  }\n}\n\nfunction MaterialModifier(name) {\n  if (name === undefined) name = _helper2.default.getUUID();\n  this.name = name;\n  this.bak_name = 't3d_material_bak_' + this.name;\n  this._trans = -1;\n  // this._nodes = [];\n  this._seletions = [];\n  this._nodesMap = {};\n  this.autoUpdate = false;\n  this._autoUpdateID = null;\n  this.fadeSpeed = 1;\n  this.flashSpeed = 1;\n  this._isFading = false;\n  this._isFlashing = false;\n  this.flashLoop = false;\n  this._updateQueen = [];\n  this._removeQueen = [];\n  this.override = false;\n  this._materialCopy = {};\n  this._colour = new THREE.Vector4(-1, -1, -1, 0);\n}\n\nfunction createUpdateFunc(data, update, complete) {\n  var begin = data.begin || new Date().getTime();\n  var from = isNaN(data.from) ? 0 : data.from;\n  var to = isNaN(data.to) ? 1 : data.to;\n  var during = data.during;\n  var func = data.func;\n\n  function _loop(reset) {\n    if (reset === 'reset') begin = new Date().getTime();\n    var timespan = new Date().getTime() - begin;\n\n    if (timespan <= during) {\n      var percent = func(timespan, 0, 1, during);\n      var n = from + (to - from) * percent;\n      update(n);\n      //requestAnimationFrame(_loop);\n      return true;\n    } else if (timespan > during) {\n      update(to);\n      var flag = complete();\n      begin = new Date().getTime();\n      return flag;\n    }\n  }\n\n  return _loop;\n}\n\nMaterialModifier.prototype.toString = function () {\n  return this.name;\n};\n\nMaterialModifier.prototype.getId = function () {\n  console.log('[%s] didn\\'t ready', 'MaterialModifier.getId');\n};\n\nMaterialModifier.prototype.setAutoUpdate = function (b) {\n  this.autoUpdate = b;\n  this.autoUpdateRunner();\n};\n\nMaterialModifier.prototype.getAutoUpdate = function () {\n  return this.autoUpdate;\n};\n\nMaterialModifier.prototype.autoUpdateRunner = function () {\n  if (this._autoUpdateID) {\n    cancelAnimationFrame(this._autoUpdateID);\n    this._autoUpdateID = false;\n  }\n\n  var that = this;\n\n  if (that.autoUpdate) {\n    _autoUpdateHandler();\n  }\n\n  function _autoUpdateHandler() {\n    if (that._autoUpdateID) {\n      cancelAnimationFrame(that._autoUpdateID);\n      that._autoUpdateID = 0;\n    }\n    that.update();\n    if (that.autoUpdate) {\n      that._autoUpdateID = requestAnimationFrame(_autoUpdateHandler);\n    }\n  }\n};\n\nMaterialModifier.prototype.setTransparency = function (trans) {\n  this._trans = trans;\n};\n\nMaterialModifier.prototype.getTransparency = function () {\n  return this._trans;\n};\n\nMaterialModifier.prototype.fade = function (from, to) {\n  if (this._seletions.length < 1) {\n    //return;\n  }\n  var d = 1000 * 1 / this.fadeSpeed;\n  // var data = calculate(from, to, d, tween.Cubic.easeOut);\n  var that = this;\n  this._isFading = true;\n  var uFunc = createUpdateFunc({\n    from: from,\n    to: to,\n    during: d,\n    func: _tween2.default.Cubic.easeOut,\n    begin: new Date().getTime()\n  }, function (o) {\n    for (var pro in that._materialCopy) {\n      var material = that._materialCopy[pro].material;\n      if (material) {\n        material = material.getTechnique(0).getPass(0).material;\n        material.transparent = true;\n        material.opacity = o;\n      }\n    }\n  }, function () {\n    that._isFading = false;\n    return false;\n  });\n  that._updateQueen.push(uFunc);\n  /*if(this.autoUpdate){\r\n      this.setAutoUpdate(this.autoUpdate);\r\n  }*/\n};\n\nMaterialModifier.prototype.fadeIn = function () {\n  if (this._seletions.length < 1) {\n    //return;\n  }\n  var from = this._trans;\n  this.fade(from, 1);\n};\n\nMaterialModifier.prototype.fadeOut = function () {\n  if (this._seletions.length < 1) {\n    //return;\n  }\n  var from = this._trans;\n  this.fade(from, 0);\n};\n\nMaterialModifier.prototype.setFadeSpeed = function (speed) {\n  if (speed === 0) return;\n  this.fadeSpeed = speed;\n};\n\nMaterialModifier.prototype.isFading = function () {\n  return this._isFading;\n};\n\nMaterialModifier.prototype.setColour = function (r, g, b, a) {\n  this._colour.x = r;\n  this._colour.y = g;\n  this._colour.z = b;\n  this._colour.w = a;\n};\n\nMaterialModifier.prototype.flash = function (from, to) {\n  var d = 1000; // this.flashSpeed;\n  if (from < to) {\n    to = Math.min(1 - this._trans, to);\n    from = Math.max(from, 0.01);\n  }\n  var that = this;\n  this._isFlashing = true;\n  var uFunc = createUpdateFunc({\n    from: 0,\n    to: 1,\n    during: d,\n    func: _tween2.default.Linear,\n    begin: new Date().getTime()\n  }, function (percent) {\n    var o = from + (to - from) * percent;\n    for (var pro in that._materialCopy) {\n      var material = that._materialCopy[pro].material;\n      if (!material) continue;\n      material = material.getTechnique(0).getPass(0).material;\n      if (!material.override_color) {\n        material.alphaColor.w = o;\n      } else if (material.override_color && that.override) {\n        material.alphaColor.w = o;\n      } else {\n        material.alphaColor = material.backup_color;\n      }\n    }\n  }, function () {\n    //if(that.flashLoop){\n    var t = from;\n    from = to;\n    to = t;\n    //}\n    return true;\n  });\n  that._updateQueen.push(uFunc);\n  this.autoUpdateRunner();\n};\n\nMaterialModifier.prototype.setFlashSpeed = function (speed) {\n  this.flashSpeed = speed;\n};\n\nMaterialModifier.prototype.setFlashLoop = function (b) {\n  this.flashLoop = b;\n};\n\nMaterialModifier.prototype.isFlashing = function () {\n  return this._isFlashing;\n};\n\nMaterialModifier.prototype.getFlashValue = function () {\n  console.log('[%s] didn\\'t ready', 'MaterialModifier.getFlashValue');\n};\n\nMaterialModifier.prototype.setOverride = function (b) {\n  this.override = b;\n};\n\nMaterialModifier.prototype.getAllSceneNodeNames = function () {\n  console.log('[%s] didn\\'t ready', 'MaterialModifier.getAllSceneNodeNames');\n};\n\nMaterialModifier.prototype.getModifiedMaterialNameString = function () {\n  console.log('[%s] didn\\'t ready', 'MaterialModifier.getModifiedMaterialNameString');\n};\n\nMaterialModifier.prototype.addSceneNode = function (node) {\n  // this._nodes.push(node);\n  var _nodes = {};\n  _nodes[node.uuid] = node;\n  selectMaterial.call(this, _nodes);\n};\n\nMaterialModifier.prototype.removeSceneNode = function (node) {\n  var _nodes = {};\n  _nodes[node.uuid] = node;\n  unselectMaterial.call(this, _nodes);\n  // var index = this._nodes.indexOf(node);\n  // if (index > -1) {\n  //   this._nodes.splice(index, 1);\n  // }\n};\n\nMaterialModifier.prototype.addSceneNodeSelection = function (t3dCollector) {\n  this._seletions.push(t3dCollector);\n  var _nodes = t3dCollector._nodesResult;\n  selectMaterial.call(this, _nodes);\n};\n\nMaterialModifier.prototype.removeSceneNodeSelection = function (t3dCollector) {\n  var _nodes = t3dCollector._nodesResult;\n  unselectMaterial.call(this, _nodes);\n  var index = this._seletions.indexOf(t3dCollector);\n  if (index > -1) {\n    this._seletions.splice(index, 1);\n  }\n};\n\nMaterialModifier.prototype.enable = function () {\n  console.log('[%s] didn\\'t ready', 'MaterialModifier.enable');\n};\n\nMaterialModifier.prototype.disable = function () {\n  console.log('[%s] didn\\'t ready', 'MaterialModifier.disable');\n};\n\nMaterialModifier.prototype.update = function (frameTime) {\n  for (var i = 0; i < this._removeQueen.length; i++) {\n    var func = this._removeQueen[i];\n    var index = this._updateQueen.indexOf(func);\n    if (index > -1) this._updateQueen.splice(index, 1);\n  }\n  this._removeQueen.length = 0;\n  for (var _i = 0; _i < this._updateQueen.length; _i++) {\n    var _func = this._updateQueen[_i];\n    if (typeof _func === 'function') {\n      var flag = _func();\n      if (!flag) this._removeQueen.push(_func);\n    } else {\n      this._removeQueen.push(_func);\n    }\n  }\n};\n\nMaterialModifier.prototype.setOverrideDepthCheckEnabled = function (bOverride, bEnabled) {\n  console.log('[%s] didn\\'t ready', 'MaterialModifier.setOverrideDepthCheckEnabled');\n};\n\nMaterialModifier.prototype.setOverrideDepthBias = function (bool, p1, p2) {\n  console.log('[%s] didn\\'t ready', 'MaterialModifier.setOverrideDepthBias');\n};\n\nMaterialModifier.prototype.setColourPassDepthWriteEnabled = function (b) {\n  console.warn('MaterialModifier.prototype.setColourPassDepthWriteEnabled');\n};\n\nexports.default = MaterialModifier;\n\n//# sourceURL=webpack:///./src/selection/MaterialModifier.js?")
        },
        "./src/selection/SceneNodeSelection.js": /*!*********************************************!*\
  !*** ./src/selection/SceneNodeSelection.js ***!
  \*********************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _SelectConstant = __webpack_require__(/*! ./SelectConstant.js */ \"./src/selection/SelectConstant.js\");\n\nvar _SelectConstant2 = _interopRequireDefault(_SelectConstant);\n\nvar _helper = __webpack_require__(/*! ../util/helper.js */ \"./src/util/helper.js\");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction selectNodes(node, recusive, marks, result) {\n  var level = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n  if (!node) {\n    return;\n  }\n  var uuid = node.uuid;\n  var mark = marks[uuid];\n  if (mark === _SelectConstant2.default.SelectionMark.Stop && level > 0) {\n    //停止\n    //result[node.uuid] = node;\n    return;\n  } else if (mark === _SelectConstant2.default.SelectionMark.Jump) {//跳过\n\n  } else {\n    if (result[node.uuid]) {\n      console.log('% :已经存在');\n    }\n    if (node.uuid && node.material) {\n      if (!node.selections) {\n        node.selections = {};\n      }\n      node.selections[this.name] = this;\n      result[node.uuid] = node;\n    }\n  }\n  if (recusive && node.children.length > 0) {\n    for (var i = 0; i < node.children.length; i++) {\n      selectNodes.call(this, node.children[i], recusive, marks, result, level + 1);\n    }\n  }\n}\n\nfunction unselectNodes(nodes) {\n  for (var pro in nodes) {\n    var node = nodes[pro];\n    if (node.selections) {\n      var select = node.selections[this.name];\n      delete node.selections[this.name];\n    }\n    delete this._nodesResult[pro];\n  }\n}\n\nfunction SceneNodeSelection(name) {\n  if (name === undefined) name = _helper2.default.getUUID();\n  this.name = name;\n\n  this._nodesMark = {};\n  this._nodesResult = {};\n}\n\nSceneNodeSelection.prototype.toString = function () {\n  return this.name;\n};\n\n//没用过\nSceneNodeSelection.prototype.setAutoResetMark = function (b) {};\n\n//没用过\nSceneNodeSelection.prototype.getAutoResetMark = function () {};\n\nSceneNodeSelection.prototype.mark = function (node, mark) {\n  if (node === undefined || node === null) {\n    return;\n  }\n  this._nodesMark[node.uuid] = mark;\n};\n\nSceneNodeSelection.prototype.markSelection = function (selection, mark) {\n  for (var pro in selection._nodesResult) {\n    this._nodesMark[selection._nodesResult[pro].uuid] = mark;\n  }\n};\n\nSceneNodeSelection.prototype.getMark = function (node) {\n  var mark = _SelectConstant2.default.SelectionMark.None;\n  if (node) {\n    mark = this._nodesMark[node.uuid];\n    mark = mark ? mark : _SelectConstant2.default.SelectionMark.None;\n  }\n  return mark;\n};\n\nSceneNodeSelection.prototype.getAllNameString = function () {\n  var nodes = this._nodesResult;\n  var names = [];\n  for (var pro in nodes) {\n    names.push(nodes[pro].name);\n  }\n  return names.join(';');\n};\n\nSceneNodeSelection.prototype.select = function (node, recusive) {\n  //this._nodesSelect[node.uuid] = {node: node, recusive: recusive};\n  var temp_result = {};\n  selectNodes.call(this, node, recusive, this._nodesMark, temp_result);\n  for (var pro in temp_result) {\n    this._nodesResult[pro] = temp_result[pro];\n  }\n  // this._nodesMark = {};\n};\n\nSceneNodeSelection.prototype.reselect = function (node, recusive) {\n  unselectNodes.call(this, this._nodesResult);\n  selectNodes.call(this, node, recusive, this._nodesMark, this._nodesResult);\n};\n\nSceneNodeSelection.prototype.unselect = function (node, recusive) {\n  var temp_result = {};\n  if (recusive) {\n    selectNodes.call(this, node, recusive, this._nodesMark, temp_result);\n  } else {\n    temp_result[node.uuid] = node;\n  }\n  unselectNodes.call(this, temp_result);\n};\n\nSceneNodeSelection.prototype.deselect = function (node, recusive) {\n  var temp_result = {};\n  selectNodes.call(this, node, recusive, this._nodesMark, temp_result);\n  unselectNodes.call(this, temp_result);\n  this._nodesResult = temp_result;\n};\n\nSceneNodeSelection.prototype.selectList = function (nodeList, recusive) {\n  if (!nodeList || !Array.isArray(nodeList)) {\n    return;\n  }\n  for (var i = 0; i < nodeList.length; i++) {\n    this.select(nodeList[i], recusive);\n  }\n};\n\nSceneNodeSelection.prototype.unselectList = function (nodeList, recusive) {\n  if (!nodeList || !Array.isArray(nodeList)) {\n    return;\n  }\n  for (var i = 0; i < nodeList.length; i++) {\n    this.unselect(nodeList[i], recusive);\n  }\n};\n\nSceneNodeSelection.prototype.isEmpty = function () {\n  for (var key in this._nodesResult) {\n    return false;\n  }\n  return true;\n};\n\nSceneNodeSelection.prototype.merge = function (selection, recusive) {\n  var source_nodes = selection._nodesResult;\n  var dest_nodes = this._nodesResult;\n  for (var pro in source_nodes) {\n    dest_nodes[pro] = source_nodes[pro];\n  }\n};\n\nSceneNodeSelection.prototype.unmerge = function (selection, recusive) {\n  var source_nodes = selection._nodesResult;\n  var dest_nodes = this._nodesResult;\n  for (var pro in source_nodes) {\n    delete dest_nodes[pro];\n  }\n};\n//TODO 标记一下，这里还是有些问题需要想好\nSceneNodeSelection.prototype.getWorldAABB = function (isLocal) {\n  var nodes = this._nodesResult;\n  var allBox = new THREE.Box3();\n  for (var pro in nodes) {\n    var myBox3 = new THREE.Box3();\n    if (!nodes[pro]) {\n      continue;\n    }\n    if (nodes[pro].typeName == 'Billboard') {\n      myBox3.setFromObject(nodes[pro]);\n    } else if (nodes[pro].geometry) {\n\n      //非常坑,nodes[pro].geometry.computeBoundingBox()这个方法计算出来的boundingBox数值不对\n      // myBox3.setFromObject(node);这个方法又迭代了children，我已经是心力交瘁了\n      nodes[pro].geometry.computeBoundingBox();\n      var mySelfBox3 = nodes[pro].geometry.boundingBox;\n      // var testSize = mySelfBox3.getSize();\n      // var testCenter = mySelfBox3.getCenter();\n      // var localPos = nodes[pro].position.clone();\n      // if (nodes[pro]._position) {\n      //     localPos = nodes[pro]._position.clone();\n      // }\n      myBox3 = mySelfBox3.clone();\n      //这里怎么能保证matrixWorld已经被更新过了那？看来我们的frameManager需要对其进行标记了\n      myBox3.applyMatrix4(nodes[pro].matrixWorld);\n      // if (matrixWorld) {\n      //     myBox3.applyMatrix4(matrixWorld);\n      // } else {\n      //     myBox3.applyMatrix4(nodes[pro].matrixWorld);\n      // }\n    }\n\n    var localPos = nodes[pro].getPosition();\n    if (isLocal) {\n\n      // if (localPos[0] === 0 && localPos[1] === 0 && localPos[2] === 0) {\n      //   var tmpSize = myBox3.getSize();\n      //   var tmpCenter = new THREE.Vector3(0, 0, 0);\n      //   myBox3.setFromCenterAndSize(tmpCenter, tmpSize);\n      // }\n      // else {\n      //     var myPos = new THREE.Vector3(localPos[0], localPos[1], localPos[2]);\n      //     myBox3.setFromCenterAndSize(myPos, tmpSize);\n      // }\n    }\n    var bbSize = new THREE.Vector3();\n    myBox3.getSize(bbSize);\n    if (bbSize.x === 0 && bbSize.y === 0 && bbSize.z === 0) {\n      continue;\n    }\n    allBox.union(myBox3);\n  }\n  var center = new THREE.Vector3();\n  allBox.getCenter(center);\n  if (!center.x && !center.y && !center.z) {\n    center.x = 0;\n    center.y = 0;\n    center.z = 0;\n  }\n\n  var size = new THREE.Vector3();\n  allBox.getSize(size);\n  return {\n    center: [center.x, center.y, center.z],\n    radius: Math.sqrt(Math.pow(size.x, 2) + Math.pow(size.y, 2) + Math.pow(size.z, 2)) / 2,\n    width: size.x,\n    height: size.y,\n    depth: size.z\n  };\n};\n\nSceneNodeSelection.prototype.setQueryFlags = function (QueryFlags) {\n  for (var pro in this._nodesResult) {\n    this._nodesResult[pro].setQueryFlags(QueryFlags);\n  }\n};\n\nSceneNodeSelection.prototype.addQueryFlags = function (QueryFlags) {\n  //TODO:\n  for (var pro in this._nodesResult) {\n    this._nodesResult[pro].addQueryFlags(QueryFlags);\n  }\n};\n\nSceneNodeSelection.prototype.removeQueryFlags = function (QueryFlags) {\n  for (var pro in this._nodesResult) {\n    this._nodesResult[pro].removeQueryFlags(QueryFlags);\n  }\n};\n\nSceneNodeSelection.prototype.setPickEnabled = function (b) {\n  for (var pro in this._nodesResult) {\n    this._nodesResult[pro].setPickEnabled(b);\n  }\n};\n\nSceneNodeSelection.prototype.showBoundingBox = function (b) {};\n\nSceneNodeSelection.prototype.show = function () {\n  var b = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n  for (var pro in this._nodesResult) {\n    // if (this._nodesResult[pro].material)\n    // this._nodesResult[pro].material.opacity = 1;\n    this._nodesResult[pro].show(b);\n  }\n};\n\nSceneNodeSelection.prototype.setDepthCheckEnabled = function (flag) {\n  for (var pro in this._nodesResult) {\n    var obj3d = this._nodesResult[pro];\n    if (obj3d && obj3d.material) {\n      obj3d.material.depthTest = flag;\n    }\n  }\n};\n\nSceneNodeSelection.prototype.clone = function (name) {\n  var selection = new SceneNodeSelection(name);\n  for (var pro in this._nodesMark) {\n    selection._nodesMark[pro] = this._nodesMark[pro];\n  }\n  for (var _pro in this._nodesResult) {\n    selection._nodesResult[_pro] = this._nodesResult[_pro];\n  }\n  return selection;\n};\n\nSceneNodeSelection.prototype.clear = function () {\n  for (var pro in this['_nodesResult']) {\n    delete this['_nodesResult'][pro];\n  }\n};\n\nSceneNodeSelection.prototype.destroy = function () {\n  for (var pro in this['_nodesMark']) {\n    delete this['_nodesMark'][pro];\n  }for (var _pro2 in this['_nodesResult']) {\n    delete this['_nodesResult'][_pro2];\n  }\n};\n\n//没用过\nSceneNodeSelection.prototype.updateBounds = function () {};\n\nSceneNodeSelection.prototype.setRenderQueueGroup = function (renderQueueGroup) {\n  for (var pro in this._nodesResult) {\n    this._nodesResult[pro].setRenderQueueGroup(renderQueueGroup);\n  }\n};\n\nSceneNodeSelection.prototype.removeAllModifiers = function () {\n  for (var pro in this._nodesResult) {\n    var obj3d = this._nodesResult[pro];\n    if (obj3d && obj3d.node && obj3d.node.modifiers) {\n      obj3d.node.modifiers.length = 0;\n    }\n  }\n};\n\nSceneNodeSelection.prototype.setVisibilityFlags = function (visibilityFlags) {\n  for (var pro in this._nodesResult) {\n    this._nodesResult[pro].setVisibilityFlags(visibilityFlags);\n  }\n};\n\nSceneNodeSelection.prototype.addVisibilityFlags = function (visibilityFlags) {\n  for (var pro in this._nodesResult) {\n    this._nodesResult[pro].addVisibilityFlags(visibilityFlags);\n  }\n};\n\nSceneNodeSelection.prototype.removeVisibilityFlags = function (visibilityFlags) {\n  for (var pro in this._nodesResult) {\n    this._nodesResult[pro].removeVisibilityFlags(visibilityFlags);\n  }\n};\n\nSceneNodeSelection.prototype.setCustomParameter = function (index, value) {\n  for (var pro in this._nodesResult) {\n    this._nodesResult[pro].setCustomParameter(index, value);\n  }\n};\n\nexports.default = SceneNodeSelection;\n\n//# sourceURL=webpack:///./src/selection/SceneNodeSelection.js?")
        },
        "./src/selection/SelectConstant.js": /*!*****************************************!*\
  !*** ./src/selection/SelectConstant.js ***!
  \*****************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nvar ModifierType = {\n    Material: 0x0201,\n    TransparencyColour: 0x0201,\n    AutoRotation: 0x0101,\n    AutoScale: 0x0102\n};\n\nvar SelectionMark = {\n    None: 0,\n    Stop: 1,\n    Jump: 2\n};\n\nvar SelectConstant = {\n    ModifierType: ModifierType,\n    SelectionMark: SelectionMark\n    //QueryFlags: QueryFlags\n};\n\nexports.default = SelectConstant;\n\n//# sourceURL=webpack:///./src/selection/SelectConstant.js?')
        },
        "./src/selection/modifierManager.js": /*!******************************************!*\
  !*** ./src/selection/modifierManager.js ***!
  \******************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _SceneNodeSelection = __webpack_require__(/*! ./SceneNodeSelection.js */ "./src/selection/SceneNodeSelection.js");\n\nvar _SceneNodeSelection2 = _interopRequireDefault(_SceneNodeSelection);\n\nvar _MaterialModifier = __webpack_require__(/*! ./MaterialModifier.js */ "./src/selection/MaterialModifier.js");\n\nvar _MaterialModifier2 = _interopRequireDefault(_MaterialModifier);\n\nvar _helper = __webpack_require__(/*! ../util/helper.js */ "./src/util/helper.js");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _modifiers = {};\n\nvar modifierManager = {};\n\nmodifierManager.createModifier = function (name, type) {\n    var m = new _MaterialModifier2.default(name);\n    _modifiers[name] = m;\n    return m;\n};\n\nmodifierManager.destroyModifier = function (name) {\n    console.log(\'destroyModifier\');\n};\n\nfunction returnNull() {\n    return null;\n}\n\nexports.default = modifierManager;\n\n//# sourceURL=webpack:///./src/selection/modifierManager.js?')
        },
        "./src/util/GeoBuild.js": /*!******************************!*\
  !*** ./src/util/GeoBuild.js ***!
  \******************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _materialManager = __webpack_require__(/*! ../material/materialManager.js */ \"./src/material/materialManager.js\");\n\nvar _materialManager2 = _interopRequireDefault(_materialManager);\n\nvar _buffer = __webpack_require__(/*! ../util/buffer.js */ \"./src/util/buffer.js\");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction GeoBuild() {\n  var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\n  var defaultOpt = {\n    rootNode: undefined,\n    url: undefined,\n    texturePath: undefined,\n    name: 'geoBuildRoot',\n    sphere: true,\n    earthRadius: 6378000,\n    materialName: 'geobuild_mat',\n    multiplier: 3,\n    transparent: true,\n    isAnimation: undefined\n  };\n  this.node = new THREE.Object3D();\n\n  var name = opt.name || defaultOpt.name;\n  this.name = name;\n\n  var rootNode = opt.rootNode;\n  this.root = rootNode.createChild(this.name);\n\n  this.sphere = opt.sphere !== undefined ? opt.sphere : defaultOpt.sphere;\n  this.earthRadius = opt.earthRadius || defaultOpt.earthRadius;\n\n  var materialName = opt.materialName || defaultOpt.materialName;\n  this.t3dMaterial = _materialManager2.default.getMaterial(materialName);\n  if (!this.t3dMaterial) {\n    this.t3dMaterial = _materialManager2.default.createMaterial(materialName, 'MeshBasicMaterial');\n  }\n  var mat = this.material = this.t3dMaterial.getMaterial()[0];\n  mat.color.set(0xffffff);\n  mat.side = THREE.BackSide;\n\n  this.multiplier = opt.multiplier || defaultOpt.multiplier;\n\n  this.transparent = opt.transparent !== undefined ? opt.transparent : defaultOpt.transparent;\n  var transparent = this.transparent;\n\n  this.isAnimation = opt.isAnimation;\n\n  var texturePath = opt.texturePath || defaultOpt.texturePath;\n  this.texturePath = texturePath;\n\n  var url = opt.url || defaultOpt.url;\n  this.url = url;\n\n  if (texturePath != undefined) {\n    var textureLoader = new THREE.TextureLoader();\n    textureLoader.load(texturePath, function (texture) {\n      mat.map = texture;\n      mat.transparent = transparent;\n    });\n  }\n  /*this.material = new THREE.MeshFaceMaterial([\r\n      new THREE.MeshBasicMaterial({color: 0x00ffff, side: THREE.BackSide}),\r\n      new THREE.MeshBasicMaterial({color: 0xffff00, side: THREE.BackSide}),\r\n  ]);*/\n}\n\nGeoBuild.id = 0;\n\nGeoBuild.prototype.load = function (src, success, fail) {\n  var that = this;\n  var loader = new THREE.FileLoader();\n  loader.load(src, function (response) {\n    if (!response || response.length < 1) return false;\n    if (typeof response === 'string') response = JSON.parse(response);\n    try {\n      var result = that.create(response);\n      if (typeof success === 'function') success(result, that);\n    } catch (error) {\n      console.log(error);\n      if (typeof fail === 'function') fail(error, that);\n    }\n  }, undefined, function (error) {\n    console.log(error);\n    if (typeof fail === 'function') fail(error, that);\n  });\n};\n\nGeoBuild.prototype.create = function (result) {\n  var that = this;\n  var meshes = [];\n\n  var centerX = [];\n  var centerY = [];\n\n  result.features.map(function (feature) {\n    var height = feature.properties.floor - 0;\n    height = isNaN(height) ? 200 : height;\n    height *= that.multiplier;\n\n    var group = new THREE.Group();\n    group.name = 'geo_build_' + GeoBuild.id++;\n    group.properties = feature.properties;\n    var s = that.shapes(feature);\n    s.shapes.map(function (v, i) {\n      var mesh = that.extrude(v, height, s.positions[i]);\n      group.add(mesh);\n    });\n    _buffer2.default.nodeBuffer.add(group.name, group);\n\n    that.root.add(group);\n    if (that.isAnimation == true) {\n      group.setScale([0, 0, 0]);\n    }\n    centerX.push(group.properties.centerx);\n    centerY.push(group.properties.centery);\n    // meshes.push(group);\n  });\n  var minCenterX = Math.min.apply(Math, centerX);\n  var minCenterY = Math.min.apply(Math, centerY);\n  var maxCenterX = Math.max.apply(Math, centerX);\n  var maxCenterY = Math.max.apply(Math, centerY);\n  that.regionCenter = [(minCenterX + maxCenterX) / 2, (minCenterY + maxCenterY) / 2];\n  // return meshes;\n};\n\nGeoBuild.prototype.shapes = function (feature) {\n  var that = this;\n  var shapes = [];\n  var positions = [];\n\n  var hs = that.earthRadius + 1;\n\n  var node = new THREE.Object3D();\n  this.node.add(node);\n\n  var coordinates = feature.geometry.coordinates;\n  if (feature.geometry.type === 'Polygon') {\n    coordinates = [coordinates];\n  }\n  coordinates.map(function (value1) {\n    value1.map(function (value2) {\n      var vertices = [];\n\n      var coord = that.convert(value2[0], hs);\n      positions.push(coord);\n      node.setDerivedPosition(coord);\n      node.setDirection(coord, 2, [0, 1, 0]);\n      node.updateMatrixWorld();\n\n      value2.map(function (value3) {\n        coord = that.convert(value3, hs);\n        var res = node.convertWorldToLocalPosition(coord);\n        var v3 = new THREE.Vector3(res[0], res[2], 0);\n        vertices.push(v3);\n      });\n\n      var shape = new THREE.Shape(vertices);\n      shapes.push(shape);\n    });\n  });\n\n  this.node.remove(node);\n  return { positions: positions, shapes: shapes };\n};\n\nGeoBuild.prototype.extrude = function (shape, height, position) {\n  var that = this;\n  var geometry = shape.makeGeometry();\n\n  geometry = new THREE.ExtrudeGeometry(shape, {\n    // extrudePath: path,\n    step: 1,\n    amount: height,\n    material: 0,\n    extrudeMaterial: 1,\n    bevelEnabled: false,\n    UVGenerator: that.uvgenerator(geometry, height)\n  });\n\n  geometry.vertices.map(function (v) {\n    var y = v.y;\n    v.y = v.z;\n    v.z = y;\n  });\n\n  var mesh = new THREE.Mesh(geometry, this.material);\n  mesh.position.set(position[0], position[1], position[2]);\n  mesh.setDirection(position, 2, [0, 1, 0]);\n  mesh.updateMatrixWorld();\n  mesh.t3dMaterial = this.t3dMaterial;\n  return mesh;\n};\n\nGeoBuild.prototype.uvgenerator = function (geo, height) {\n  geo.computeBoundingBox();\n  var minX = geo.boundingBox.min.x,\n      maxX = geo.boundingBox.max.x,\n      minY = geo.boundingBox.min.y,\n      maxY = geo.boundingBox.max.y,\n      minZ = 0,\n      maxZ = height;\n\n  var UVGenerator = {\n\n    generateTopUV: function generateTopUV(geometry, vertices, indexA, indexB, indexC) {\n\n      var a_x = (vertices[indexA * 3] - minX) / (maxX - minX);\n      var a_y = 1 - (vertices[indexA * 3 + 1] - minY) / (maxY - minY);\n      var b_x = (vertices[indexB * 3] - minX) / (maxX - minX);\n      var b_y = 1 - (vertices[indexB * 3 + 1] - minY) / (maxY - minY);\n      var c_x = (vertices[indexC * 3] - minX) / (maxX - minX);\n      var c_y = 1 - (vertices[indexC * 3 + 1] - minY) / (maxY - minY);\n\n      return [new THREE.Vector2(a_x, a_y), new THREE.Vector2(b_x, b_y), new THREE.Vector2(c_x, c_y)];\n    },\n\n    generateSideWallUV: function generateSideWallUV(geometry, vertices, indexA, indexB, indexC, indexD) {\n\n      var a_x = (vertices[indexA * 3] - minX) / (maxX - minX);\n      var a_y = (vertices[indexA * 3 + 1] - minY) / (maxY - minY);\n      var a_z = 1 - (vertices[indexA * 3 + 2] - minZ) / (maxZ - minZ);\n      var b_x = (vertices[indexB * 3] - minX) / (maxX - minX);\n      var b_y = (vertices[indexB * 3 + 1] - minY) / (maxY - minY);\n      var b_z = 1 - (vertices[indexB * 3 + 2] - minZ) / (maxZ - minZ);\n      var c_x = (vertices[indexC * 3] - minX) / (maxX - minX);\n      var c_y = (vertices[indexC * 3 + 1] - minY) / (maxY - minY);\n      var c_z = 1 - (vertices[indexC * 3 + 2] - minZ) / (maxZ - minZ);\n      var d_x = (vertices[indexD * 3] - minX) / (maxX - minX);\n      var d_y = (vertices[indexD * 3 + 1] - minY) / (maxY - minY);\n      var d_z = 1 - (vertices[indexD * 3 + 2] - minZ) / (maxZ - minZ);\n\n      if (Math.abs(a_y - b_y) < 0.01) {\n\n        return [new THREE.Vector2(a_x, 1 - a_z), new THREE.Vector2(b_x, 1 - b_z), new THREE.Vector2(c_x, 1 - c_z), new THREE.Vector2(d_x, 1 - d_z)];\n      } else {\n\n        return [new THREE.Vector2(a_y, 1 - a_z), new THREE.Vector2(b_y, 1 - b_z), new THREE.Vector2(c_y, 1 - c_z), new THREE.Vector2(d_y, 1 - d_z)];\n      }\n    }\n  };\n\n  return UVGenerator;\n};\n\nGeoBuild.prototype.release = function () {};\n\nGeoBuild.prototype.convert = function (latLng, r) {\n  var lat = latLng[0];\n  var lng = latLng[1];\n\n  var latArc = lat / 180 * Math.PI;\n  var lngArc = lng / 180 * Math.PI;\n  var y = r * Math.sin(lngArc);\n  var curR = r * Math.cos(lngArc);\n\n  var x = -curR * Math.cos(latArc);\n  var z = curR * Math.sin(latArc);\n\n  return [x, y, z];\n};\n\nexports.default = GeoBuild;\n\n//# sourceURL=webpack:///./src/util/GeoBuild.js?")
        },
        "./src/util/InterpolationMode.js": /*!***************************************!*\
  !*** ./src/util/InterpolationMode.js ***!
  \***************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.default = {\n    /** Values are interpolated along straight lines. */\n    LINEAR: 0,\n    /** Values are interpolated along a spline, resulting in smoother changes in direction. */\n    SPLINE: 1\n};\n\n//# sourceURL=webpack:///./src/util/InterpolationMode.js?')
        },
        "./src/util/LayerOptions.js": /*!**********************************!*\
  !*** ./src/util/LayerOptions.js ***!
  \**********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.default = {\n    LayerBlendOperationEx: {\n        /** use source1 without modification */\n        SOURCE1: 0,\n        /** use source2 without modification */\n        SOURCE2: 1,\n        /** multiply source1 and source2 together */\n        MODULATE: 2,\n        /** as MODULATE but brighten afterwards (x2) */\n        MODULATE_X2: 3,\n        /** as MODULATE but brighten more afterwards (x4) */\n        MODULATE_X4: 4,\n        /** add source1 and source2 together */\n        ADD: 5,\n        /** as ADD, but subtract 0.5 from the result */\n        ADD_SIGNED: 6,\n        /** as ADD, but subtract product from the sum */\n        ADD_SMOOTH: 7,\n        /** subtract source2 from source1 */\n        SUBTRACT: 8,\n        /** use interpolated alpha value from vertices to scale source1, then add source2 scaled by (1-alpha) */\n        BLEND_DIFFUSE_ALPHA: 9,\n        /** as BLEND_DIFFUSE_ALPHA, but use alpha from texture */\n        BLEND_TEXTURE_ALPHA: 10,\n        /** as BLEND_DIFFUSE_ALPHA, but use current alpha from previous stages */\n        BLEND_CURRENT_ALPHA: 11,\n        /** as BLEND_DIFFUSE_ALPHA but use a constant manual blend value (0.0-1.0) */\n        BLEND_MANUAL: 12,\n        /** dot product of color1 and color2 */\n        DOTPRODUCT: 13,\n        /** use interpolated color values from vertices to scale source1, then add source2 scaled by (1-color) */\n        BLEND_DIFFUSE_COLOUR: 14\n    },\n    LayerBlendSource: {\n        /** the colour as built up from previous stages */\n        CURRENT: 0,\n        /** the colour derived from the texture assigned to this layer */\n        TEXTURE: 1,\n        /** the interpolated diffuse colour from the vertices */\n        DIFFUSE: 2,\n        /** the interpolated specular colour from the vertices */\n        SPECULAR: 3,\n        /** a colour supplied manually as a separate argument */\n        MANUAL: 4\n    }\n};\n\n//# sourceURL=webpack:///./src/util/LayerOptions.js?')
        },
        "./src/util/TextOptions.js": /*!*********************************!*\
  !*** ./src/util/TextOptions.js ***!
  \*********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar TextOptions = {\n    TextAlignment: {\n        /** Left */\n        Left: 0,\n        LEFT: 0,\n        /** Center */\n        Center: 1,\n        CENTER: 1,\n        /** Right */\n        Right: 2,\n        RIGHT: 2,\n        /** Top */\n        Top: 0,\n        TOP: 0,\n        /** Bottom */\n        Bottom: 2,\n        BOTTOM: 2\n    },\n    FontStyle: {\n        /** Regular */\n        Regular: 0,\n        /** Bold */\n        Bold: 1,\n        /** Italic */\n        Italic: 2,\n        /** BoldItalic */\n        BoldItalic: 3,\n        /** Underline */\n        Underline: 4,\n        /** Strikeout */\n        Strikeout: 8\n    }\n};\nexports.default = TextOptions;\n\n//# sourceURL=webpack:///./src/util/TextOptions.js?')
        },
        "./src/util/TransformSpace.js": /*!************************************!*\
  !*** ./src/util/TransformSpace.js ***!
  \************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.default = {\n    /** Transform is relative to the local space */\n    LOCAL: 0,\n    /** Transform is relative to the space of the parent node */\n    PARENT: 1,\n    /** Transform is relative to world space */\n    WORLD: 2\n};\n\n//# sourceURL=webpack:///./src/util/TransformSpace.js?')
        },
        "./src/util/arrayUtil.js": /*!*******************************!*\
  !*** ./src/util/arrayUtil.js ***!
  \*******************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.default = {\n    ///集合取交集\n    intersect: function intersect() {\n        var result = new Array();\n        var obj = {};\n        for (var i = 0; i < arguments.length; i++) {\n            for (var j = 0; j < arguments[i].length; j++) {\n                var str = arguments[i][j];\n                if (!obj[str]) {\n                    obj[str] = 1;\n                } else {\n                    obj[str]++;\n                    if (obj[str] == arguments.length) {\n                        result.push(str);\n                    }\n                } //end else\n            } //end for j\n        } //end for i\n        return result;\n    },\n\n    //集合去掉重复\n    uniquelize: function uniquelize(arr) {\n        //debugger\n        var tmp = {};\n        var ret = [];\n        for (var i = 0; i < arr.length; i++) {\n            if (!tmp[arr[i]]) {\n                tmp[arr[i]] = 1;\n                ret.push(arr[i]);\n            }\n        }\n        return ret;\n    },\n    //并集\n    union: function union() {\n        var arr = new Array();\n        var obj = {};\n        for (var i = 0; i < arguments.length; i++) {\n            for (var j = 0; j < arguments[i].length; j++) {\n                var str = arguments[i][j];\n                if (!obj[str]) {\n                    obj[str] = 1;\n                    arr.push(str);\n                }\n            } //end for j\n        } //end for i\n        return arr;\n    },\n\n    //2个集合的差集 在arr不存在\n    minus: function minus(arr1, arr) {\n        var result = new Array();\n        var obj = {};\n        for (var i = 0; i < arr.length; i++) {\n            obj[arr[i]] = 1;\n        }\n        for (var j = 0; j < arr1.length; j++) {\n            if (!obj[arr1[j]]) {\n                obj[arr1[j]] = 1;\n                result.push(arr1[j]);\n            }\n        }\n        return result;\n    }\n};\n\n//# sourceURL=webpack:///./src/util/arrayUtil.js?')
        },
        "./src/util/base.js": /*!**************************!*\
  !*** ./src/util/base.js ***!
  \**************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.default = {\n  isArray: function isArray(obj) {\n    return Array.isArray(obj);\n  },\n  extend: function extend(subClass, superClass) {\n    var F = function F() {};\n    F.prototype = superClass.prototype;\n    subClass.prototype = new F();\n    subClass.prototype.constructor = subClass;\n    subClass.superclass = superClass.prototype;\n    if (superClass.prototype.constructor == Object.prototype.constructor) {\n      superClass.prototype.constructor = superClass;\n    }\n  }\n};\n\n//# sourceURL=webpack:///./src/util/base.js?')
        },
        "./src/util/buffer.js": /*!****************************!*\
  !*** ./src/util/buffer.js ***!
  \****************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = {\n    dom: {},\n    resourcePath: '',\n    isWebGL2: true, //默认使用webgl2\n    //是否开启static策略\n    static: false,\n    frameManager: null,\n    //透明的渲染处理策略\n    transparentOption: 0,\n    //摄影机变化\n    cameraState: false,\n    LODAnimation: false,\n    LODAnimationDuring: 0.02,\n    //是否开启了logDepth策略\n    logDepth: false,\n    //渲染窗口大小\n    renderSize: [],\n    compositorSign: false,\n    envMapIntensity: 1.3,\n    aoMapIntensity: 1.5,\n    workers: 0,\n    //标脏\n    dirty: false,\n    bigDirty: false,\n    //当前scheme标记\n    scheme: '',\n    //当前visibilityFlags标记\n    visibilityFlags: 0,\n    scene2: {},\n    //是否监听帧率\n    isListenFPS: false,\n    fpsRecorder: [],\n    //load标示\n    requestSign: 0,\n    responseSign: 0,\n    maxAnisotropy: 0,\n    nodeTrash: new THREE.Group(),\n    debuggerList: [],\n    frameTime: 0,\n    overlayBuffer: function () {\n        var buffer = {};\n        return {\n            get: function get(name) {\n                return buffer[name];\n            },\n            delete: function _delete(name) {\n                return delete buffer[name];\n            },\n            add: function add(name, obj) {\n                buffer[name] = obj;\n            },\n            getAll: function getAll() {\n                return buffer;\n            },\n            deleteAll: function deleteAll() {\n                buffer = {};\n            }\n        };\n    }(),\n    nodeBuffer: function () {\n        var buffer = {};\n        return {\n            get: function get(name) {\n                return buffer[name];\n            },\n            delete: function _delete(name) {\n                return delete buffer[name];\n            },\n            add: function add(name, obj) {\n                buffer[name] = obj;\n            },\n            getAll: function getAll() {\n                return buffer;\n            },\n            deleteAll: function deleteAll() {\n                buffer = {};\n            }\n        };\n    }(),\n    animationStateBuffer: function () {\n        var buffer = {};\n        return {\n            get: function get(name) {\n                return buffer[name];\n            },\n            delete: function _delete(name) {\n                return delete buffer[name];\n            },\n            add: function add(name, obj) {\n                buffer[name] = obj;\n            },\n            getAll: function getAll() {\n                return buffer;\n            },\n            deleteAll: function deleteAll() {\n                buffer = {};\n            }\n        };\n    }(),\n    animationBuffer: function () {\n        var buffer = {};\n        return {\n            get: function get(name) {\n                return buffer[name];\n            },\n            delete: function _delete(name) {\n                return delete buffer[name];\n            },\n            add: function add(name, obj) {\n                buffer[name] = obj;\n            },\n            getAll: function getAll() {\n                return buffer;\n            },\n            deleteAll: function deleteAll() {\n                buffer = {};\n            }\n        };\n    }(),\n    sceneBuffer: function () {\n        var buffer = {};\n        return {\n            get: function get(name) {\n                return buffer[name];\n            },\n            delete: function _delete(name) {\n                return delete buffer[name];\n            },\n            add: function add(name, obj) {\n                buffer[name] = obj;\n            },\n            getAll: function getAll() {\n                return buffer;\n            },\n            deleteAll: function deleteAll() {\n                buffer = {};\n            }\n        };\n    }(),\n    entityBuffer: function () {\n        var buffer = {};\n        return {\n            get: function get(name) {\n                return buffer[name];\n            },\n            delete: function _delete(name) {\n                return delete buffer[name];\n            },\n            add: function add(name, obj) {\n                buffer[name] = obj;\n            },\n            getAll: function getAll() {\n                return buffer;\n            },\n            deleteAll: function deleteAll() {\n                buffer = {};\n            }\n        };\n    }(),\n    textureBuffer: function () {\n        var buffer = {};\n        return {\n            get: function get(name) {\n                return buffer[name];\n            },\n            delete: function _delete(name) {\n                return delete buffer[name];\n            },\n            add: function add(name, obj) {\n                buffer[name] = obj;\n            },\n            getAll: function getAll() {\n                return buffer;\n            },\n            deleteAll: function deleteAll() {\n                buffer = {};\n            }\n        };\n    }(),\n    tileTextureBuffer: function () {\n        var buffer = {};\n        return {\n            get: function get(name) {\n                return buffer[name];\n            },\n            delete: function _delete(name) {\n                return delete buffer[name];\n            },\n            add: function add(name, obj) {\n                buffer[name] = obj;\n            },\n            getAll: function getAll() {\n                return buffer;\n            },\n            deleteAll: function deleteAll() {\n                buffer = {};\n            }\n        };\n    }(),\n    materialBuffer: function () {\n        var buffer = {};\n        return {\n            get: function get(name) {\n                return buffer[name];\n            },\n            delete: function _delete(name) {\n                return delete buffer[name];\n            },\n            add: function add(name, obj) {\n                buffer[name] = obj;\n            },\n            getAll: function getAll() {\n                return buffer;\n            },\n            deleteAll: function deleteAll() {\n                buffer = {};\n            }\n        };\n    }(),\n    tileMaterialBuffer: function () {\n        var buffer = {};\n        return {\n            get: function get(name) {\n                return buffer[name];\n            },\n            delete: function _delete(name) {\n                return delete buffer[name];\n            },\n            add: function add(name, obj) {\n                buffer[name] = obj;\n            },\n            getAll: function getAll() {\n                return buffer;\n            },\n            deleteAll: function deleteAll() {\n                buffer = {};\n            }\n        };\n    }(),\n    eventBuffer: function () {\n        var buffer = {};\n        return {\n            get: function get(name) {\n                return buffer[name];\n            },\n            delete: function _delete(name) {\n                return delete buffer[name];\n            },\n            add: function add(name, obj) {\n                buffer[name] = obj;\n            },\n            getAll: function getAll() {\n                return buffer;\n            },\n            deleteAll: function deleteAll() {\n                buffer = {};\n            }\n        };\n    }(),\n    lightBuffer: function () {\n        var buffer = {};\n        return {\n            get: function get(name) {\n                return buffer[name];\n            },\n            delete: function _delete(name) {\n                return delete buffer[name];\n            },\n            add: function add(name, obj) {\n                buffer[name] = obj;\n            },\n            getAll: function getAll() {\n                return buffer;\n            },\n            deleteAll: function deleteAll() {\n                buffer = {};\n            }\n        };\n    }(),\n    webBuffer: function () {\n        var buffer = {};\n        return {\n            get: function get(name) {\n                return buffer[name];\n            },\n            delete: function _delete(name) {\n                return delete buffer[name];\n            },\n            add: function add(name, obj) {\n                buffer[name] = obj;\n            },\n            getAll: function getAll() {\n                return buffer;\n            },\n            deleteAll: function deleteAll() {\n                buffer = {};\n            }\n        };\n    }(),\n    //这里存设置visibility的物体\n    visibilityBuffer: function () {\n        var buffer = {};\n        return {\n            get: function get(name) {\n                return buffer[name];\n            },\n            delete: function _delete(name) {\n                return delete buffer[name];\n            },\n            add: function add(name, obj) {\n                buffer[name] = obj;\n            },\n            getAll: function getAll() {\n                return buffer;\n            },\n            update: function update(name, obj) {\n                buffer[name] = obj;\n            },\n            deleteAll: function deleteAll() {\n                buffer = {};\n            }\n        };\n    }(),\n    //设置投影仪使用\n    projector: function () {\n        var buffer = {};\n        return {\n            get: function get(name) {\n                return buffer[name];\n            },\n            delete: function _delete(name) {\n                return delete buffer[name];\n            },\n            add: function add(name, obj) {\n                buffer[name] = obj;\n            },\n            getAll: function getAll() {\n                return buffer;\n            },\n            update: function update(name, obj) {\n                buffer[name] = obj;\n            },\n            deleteAll: function deleteAll() {\n                buffer = {};\n            }\n        };\n    }(),\n    //需要在每帧里面update的东西请放到这里面吧,但是呢，一定要实现一个update的方法啊！\n    _renderList: function () {\n        var buffer = {};\n        return {\n            get: function get(name) {\n                return buffer[name];\n            },\n            delete: function _delete(name) {\n                return delete buffer[name];\n            },\n            add: function add(name, obj) {\n                buffer[name] = obj;\n            },\n            updateAll: function updateAll(interval) {\n                for (var i in buffer) {\n                    buffer[i].update(interval);\n                }\n            },\n            getAll: function getAll() {\n                return buffer;\n            },\n            deleteAll: function deleteAll() {\n                buffer = {};\n            }\n        };\n    }(),\n    _textureAnimation: function () {\n        var buffer = {};\n        return {\n            get: function get(name) {\n                return buffer[name];\n            },\n            delete: function _delete(name) {\n                return delete buffer[name];\n            },\n            add: function add(name, obj) {\n                buffer[name] = obj;\n            },\n            updateAll: function updateAll(interval) {\n                for (var i in buffer) {\n                    buffer[i].update(interval);\n                }\n            },\n            getAll: function getAll() {\n                return buffer;\n            },\n            deleteAll: function deleteAll() {\n                buffer = {};\n            }\n        };\n    }(),\n    _animationManager: function () {\n        var buffer = {};\n        return {\n            get: function get(name) {\n                return buffer[name];\n            },\n            delete: function _delete(name) {\n                return delete buffer[name];\n            },\n            add: function add(name, obj) {\n                buffer[name] = obj;\n            },\n            updateAll: function updateAll(interval) {\n                for (var i in buffer) {\n                    buffer[i].update(interval);\n                }\n            },\n            getAll: function getAll() {\n                return buffer;\n            },\n            deleteAll: function deleteAll() {\n                buffer = {};\n            }\n        };\n    }(),\n    _materialAnimationManager: function () {\n        var buffer = {};\n        return {\n            get: function get(name) {\n                return buffer[name];\n            },\n            delete: function _delete(name) {\n                return delete buffer[name];\n            },\n            add: function add(name, obj) {\n                buffer[name] = obj;\n            },\n            updateAll: function updateAll(interval) {\n                for (var i in buffer) {\n                    buffer[i].update(interval);\n                }\n            },\n            getAll: function getAll() {\n                return buffer;\n            },\n            deleteAll: function deleteAll() {\n                buffer = {};\n            }\n        };\n    }(),\n    managerBuffer: function () {\n        var buffer = {};\n        return {\n            get: function get(name) {\n                return buffer[name];\n            },\n            delete: function _delete(name) {\n                return delete buffer[name];\n            },\n            add: function add(name, obj) {\n                buffer[name] = obj;\n            },\n            updateAll: function updateAll(interval) {\n                for (var i in buffer) {\n                    buffer[i].update(interval);\n                }\n            },\n            getAll: function getAll() {\n                return buffer;\n            },\n            deleteAll: function deleteAll() {\n                buffer = {};\n            }\n        };\n    }()\n};\n\n//# sourceURL=webpack:///./src/util/buffer.js?")
        },
        "./src/util/constant.js": /*!******************************!*\
  !*** ./src/util/constant.js ***!
  \******************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar constant = {};\n\n/**\r\n * Enumeration denoting the spaces which a transform can be relative to.\r\n * @namespace constant.TransformSpace\r\n */\nconstant.TransformSpace = {\n    /** Transform is relative to the local space */\n    LOCAL: 0,\n    /** Transform is relative to the space of the parent node */\n    PARENT: 1,\n    /** Transform is relative to world space */\n    WORLD: 2\n};\n\n/**\r\n * Enumeration Query type mask\r\n * @namespace constant.SceneQueryTypeMask\r\n */\nconstant.SceneQueryTypeMask = {\n    /** Query type mask which will be used for all */\n    ALL_TYPE_MASK: 0xFFFFFFFF,\n    /** Query type mask which will be used for world geometry @see SceneQuery */\n    WORLD_GEOMETRY_TYPE_MASK: 0x80000000,\n    /** Query type mask which will be used for entities @see SceneQuery */\n    ENTITY_TYPE_MASK: 0x40000000,\n    /** Query type mask which will be used for effects like billboardsets / particle systems @see SceneQuery */\n    FX_TYPE_MASK: 0x20000000,\n    /** Query type mask which will be used for StaticGeometry  @see SceneQuery */\n    STATICGEOMETRY_TYPE_MASK: 0x10000000,\n    /** Query type mask which will be used for lights  @see SceneQuery */\n    LIGHT_TYPE_MASK: 0x08000000,\n    /** Query type mask which will be used for frusta and cameras @see SceneQuery */\n    FRUSTUM_TYPE_MASK: 0x04000000\n};\n\n/**\r\n * Scene Load Options\r\n * @namespace constant.SceneLoadOptions\r\n */\nconstant.SceneLoadOptions = {\n    /** NO_OPTIONS */\n    NO_OPTIONS: 0,\n\n    /** Skips the environment settings in the file. Skipping the environment also skips shadows */\n    SKIP_ENVIRONMENT: 0x1,\n\n    /** Skips the shadow settings in the file */\n    SKIP_SHADOWS: 0x2,\n\n    /** Skips the sky settings in the file */\n    SKIP_SKY: 0x4,\n\n    /** Skips the nodes in the file */\n    SKIP_NODES: 0x8,\n\n    /** Skips the externals in the file */\n    SKIP_EXTERNALS: 0x10,\n\n    /** Skips the terrain in the file */\n    SKIP_TERRAIN: 0x20,\n\n    /** Skips scene level query flags in the file */\n    SKIP_QUERY_FLAG_ALIASES: 0x200,\n\n    /** Skips scene level visibility flags in the file */\n    SKIP_VISIBILITY_FLAG_ALIASES: 0x400,\n\n    /** Skips scene level resource locations in the file */\n    SKIP_RESOURCE_LOCATIONS: 0x800,\n\n    /** Indicates animation states should not be created for node animation tracks */\n    NO_ANIMATION_STATES: 0x1000,\n\n    /**\r\n     * Indicates scene 'externals' should not be stored. They will, however, still\r\n     * be loaded and the CreatedExternal() scene callback will be called\r\n     */\n    NO_EXTERNALS: 0x2000,\n\n    /**\r\n     * By default, the checks to see if the file that was passed\r\n     * in exists in the file system (outside of the configured resource locations).\r\n     * This flag disables that logic\r\n     */\n    NO_FILE_SYSTEM_CHECK: 0x4000,\n\n    /**\r\n     * Indicates that a light should be created if the loaded scene doesn't contain a light\r\n     * Any lights created as a result of setting the default lighting are not passed to\r\n     * the scene callback\r\n     */\n    SET_DEFAULT_LIGHTING: 0x8000,\n\n    /**\r\n     * Indicates that the 'fileNameOrContent' parameter in Load() should be treated as the\r\n     * scene XML. In other words, no file is loaded.\r\n     */\n    FILE_NAME_CONTAINS_CONTENT: 0x10000,\n\n    /** Skips mesh, texture, material, only for bin file     */\n    SKIP_RESOURCE_BIN: 0x20000\n};\n\n/**\r\n * Flags that define which name prefixes to se.\r\n * @namespace constant.SceneLoadNamePrefix\r\n */\nconstant.SceneLoadNamePrefix = {\n    /** use prefix on object */\n    OBJECT_NAME_PREFIX: 0x1,\n    /** use prefix on node */\n    NODE_NAME_PREFIX: 0x2,\n    /** use prefix on animation */\n    NODE_ANIMATION_NAME_PREFIX: 0x4,\n    /** use prefix on OBJECT_NAME_PREFIX | NODE_NAME_PREFIX | NODE_ANIMATION_NAME_PREFIX (default) */\n    ALL_NAME_PREFIXES: 0x1 | 0x2 | 0x4\n};\n\nconstant.TrackVertexColourType = {\n    TVC_NONE: 0x0,\n    TVC_AMBIENT: 0x1,\n    TVC_DIFFUSE: 0x2,\n    TVC_SPECULAR: 0x4,\n    TVC_EMISSIVE: 0x8\n};\n\n/**\r\n * Defines the type of light\r\n * @namespace constant.LightTypes\r\n */\nconstant.LightTypes = {\n    /** Point light sources give off light equally in all directions, so require only position not direction */\n    POINT: 0,\n    /** Directional lights simulate parallel light beams from a distant source, hence have direction but no position */\n    DIRECTIONAL: 1,\n    /** Spotlights simulate a cone of light from a source so require position and direction, plus extra values for falloff */\n    SPOTLIGHT: 2\n};\n\n/**\r\n * Enumeration Resource Group Manager Name\r\n * @namespace constant.ResourceGroupName\r\n */\nconstant.ResourceGroupName = {\n    /** the 'General' group */\n    DEFAULT: 'General',\n    /** the 'Internal' group */\n    INTERNAL: 'Internal',\n    /** the 'Autodetect' group */\n    AUTODETECT: 'Autodetect'\n};\n\n/**\r\n * The type of billboard to use.\r\n * @namespace constant.BillboardType\r\n */\nconstant.BillboardType = {\n    /** Standard point billboard (default), always faces the camera completely and is always upright */\n    POINT: 0,\n    /** Billboards are oriented around a shared direction vector (used as Y axis) and only rotate around this to face the camera */\n    ORIENTED_COMMON: 1,\n    /** Billboards are oriented around their own direction vector (their own Y axis) and only rotate around this to face the camera */\n    ORIENTED_SELF: 2,\n    /** Billboards are perpendicular to a shared direction vector (used as Z axis, the facing direction) and X, Y axis are determined by a shared up-vertor */\n    PERPENDICULAR_COMMON: 3,\n    /** Billboards are perpendicular to their own direction vector (their own Z axis, the facing direction) and X, Y axis are determined by a shared up-vertor */\n    PERPENDICULAR_SELF: 4\n};\n\n/**\r\n * The type of Effect to use.\r\n * @namespace constant.EffectType\r\n */\nconstant.EffectType = {\n    Transparency: 0x1,\n    Colour: 0x2,\n\n    Grown: 0x4,\n    Slide: 0x8,\n    Bloom: 0x10\n};\n\n/**\r\n * The type of Modifier to use.\r\n * @namespace constant.ModifierType\r\n */\nconstant.ModifierType = {\n    Material: 0x0201,\n    TransparencyColour: 0x0201,\n    AutoRotation: 0x0101,\n    AutoScale: 0x0102\n};\n\n/**\r\n * The type of Modifier to use.\r\n * @namespace constant.ModifierType\r\n */\nconstant.SelectionMark = {\n    None: 0,\n    Stop: 1,\n    Jump: 2\n};\n\n/**\r\n * The type of Plane to use.\r\n * @namespace constant.Plane\r\n */\nconstant.Plane = {};\n\n/** Types of blending that you can specify between an object and the existing contents of the scene.\r\n @remarks\r\n As opposed to the LayerBlendType, which classifies blends between texture layers, these blending\r\n types blend between the output of the texture units and the pixels already in the viewport,\r\n allowing for object transparency, glows, etc.\r\n @par\r\n These types are provided to give quick and easy access to common effects. You can also use\r\n the more manual method of supplying source and destination blending factors.\r\n See Material::setSceneBlending for more details.\r\n @see\r\n     Material::setSceneBlending\r\n @namespace constant.SceneBlendType\r\n */\nconstant.SceneBlendType = {\n    /** Make the object transparent based on the final alpha values in the texture */\n    TRANSPARENT_ALPHA: 0,\n    /** Make the object transparent based on the colour values in the texture (brighter = more opaque) */\n    TRANSPARENT_COLOUR: 1,\n    /** Add the texture values to the existing scene content */\n    ADD: 2,\n    /** Multiply the 2 colours together */\n    MODULATE: 3,\n    /** The default blend mode where source replaces destination */\n    REPLACE: 4\n};\n\n/**\r\n * Type of texture blend mode.\r\n * @namespace constant.LayerBlendType\r\n */\nconstant.LayerBlendType = {\n    /** blend by colour */\n    COLOUR: 0,\n    /** blend by aplha */\n    ALPHA: 1\n};\n\n/** List of valid texture blending operations, for use with TextureUnitState::setColourOperation.\r\n @remarks\r\n This list is a more limited list than LayerBlendOperationEx because it only\r\n includes operations that are supportable in both multipass and multitexture\r\n rendering and thus provides automatic fallback if multitexture hardware\r\n is lacking or insufficient.\r\n @namespace constant.LayerBlendOperation\r\n */\nconstant.LayerBlendOperation = {\n    /** Replace all colour with texture with no adjustment */\n    REPLACE: 0,\n    /** Add colour components together. */\n    ADD: 1,\n    /** Multiply colour components together. */\n    MODULATE: 2,\n    /** Blend based on texture alpha */\n    ALPHA_BLEND: 3\n\n};\n\n/** Expert list of valid texture blending operations, for use with TextureUnitState::setColourOperationEx\r\n and TextureUnitState::setAlphaOperation, and internally in the LayerBlendModeEx class. It's worth\r\n noting that these operations are for blending <i>between texture layers</i> and not between rendered objects\r\n and the existing scene. Because all of these modes are only supported in multitexture hardware it may be\r\n required to set up a fallback operation where this hardware is not available.\r\n @namespace constant.LayerBlendOperationEx\r\n */\nconstant.LayerBlendOperationEx = {\n    /** use source1 without modification */\n    SOURCE1: 0,\n    /** use source2 without modification */\n    SOURCE2: 1,\n    /** multiply source1 and source2 together */\n    MODULATE: 2,\n    /** as MODULATE but brighten afterwards (x2) */\n    MODULATE_X2: 3,\n    /** as MODULATE but brighten more afterwards (x4) */\n    MODULATE_X4: 4,\n    /** add source1 and source2 together */\n    ADD: 5,\n    /** as ADD, but subtract 0.5 from the result */\n    ADD_SIGNED: 6,\n    /** as ADD, but subtract product from the sum */\n    ADD_SMOOTH: 7,\n    /** subtract source2 from source1 */\n    SUBTRACT: 8,\n    /** use interpolated alpha value from vertices to scale source1, then add source2 scaled by (1-alpha) */\n    BLEND_DIFFUSE_ALPHA: 9,\n    /** as BLEND_DIFFUSE_ALPHA, but use alpha from texture */\n    BLEND_TEXTURE_ALPHA: 10,\n    /** as BLEND_DIFFUSE_ALPHA, but use current alpha from previous stages */\n    BLEND_CURRENT_ALPHA: 11,\n    /** as BLEND_DIFFUSE_ALPHA but use a constant manual blend value (0.0-1.0) */\n    BLEND_MANUAL: 12,\n    /** dot product of color1 and color2 */\n    DOTPRODUCT: 13,\n    /** use interpolated color values from vertices to scale source1, then add source2 scaled by (1-color) */\n    BLEND_DIFFUSE_COLOUR: 14\n};\n\n/** List of valid sources of values for blending operations used\r\n in TextureUnitState::setColourOperation and TextureUnitState::setAlphaOperation,\r\n and internally in the LayerBlendModeEx class.\r\n @namespace constant.LayerBlendSource\r\n */\nconstant.LayerBlendSource = {\n    /** the colour as built up from previous stages */\n    CURRENT: 0,\n    /** the colour derived from the texture assigned to this layer */\n    TEXTURE: 1,\n    /** the interpolated diffuse colour from the vertices */\n    DIFFUSE: 2,\n    /** the interpolated specular colour from the vertices */\n    SPECULAR: 3,\n    /** a colour supplied manually as a separate argument */\n    MANUAL: 4\n};\n\n/** Blending factors for manually blending objects with the scene. If there isn't a predefined\r\n SceneBlendType that you like, then you can specify the blending factors directly to affect the\r\n combination of object and the existing scene. See Material::setSceneBlending for more details.\r\n Default: scene_blend one zero (opaque)\r\n @namespace constant.LayerBlendSource\r\n */\nconstant.SceneBlendFactor = {\n    /** Constant value of 1.0  */\n    ONE: 0,\n    /** Constant value of 0.0   */\n    ZERO: 1,\n    /** The existing pixel colour  */\n    DEST_COLOUR: 2,\n    /** The texture pixel (texel) colour   */\n    SOURCE_COLOUR: 3,\n    /** 1 - (dest_colour)    */\n    ONE_MINUS_DEST_COLOUR: 4,\n    /** 1 - (src_colour)  */\n    ONE_MINUS_SOURCE_COLOUR: 5,\n    /** The existing pixel alpha value  */\n    DEST_ALPHA: 6,\n    /** The texel alpha value  */\n    SOURCE_ALPHA: 7,\n    /** 1 - (dest_alpha)   */\n    ONE_MINUS_DEST_ALPHA: 8,\n    /** 1 - (src_alpha)  */\n    ONE_MINUS_SOURCE_ALPHA: 9\n};\n\n/** Comparison functions used for the depth/stencil buffer operations and\r\n others.\r\n @namespace constant.CompareFunction\r\n */\nconstant.CompareFunction = {\n    ALWAYS_FAIL: 0,\n    ALWAYS_PASS: 1,\n    LESS: 2,\n    LESS_EQUAL: 3,\n    EQUAL: 4,\n    NOT_EQUAL: 5,\n    GREATER_EQUAL: 6,\n    GREATER: 7\n};\n\n/** High-level filtering options providing shortcuts to settings the\r\n minification, magnification and mip filters.\r\n\r\n @namespace constant.TextureFilterOptions\r\n */\nconstant.TextureFilterOptions = {\n    /** Equal to: min=FO_POINT, mag=FO_POINT, mip=FO_NONE */\n    NONE: 0,\n    /** Equal to: min=FO_LINEAR, mag=FO_LINEAR, mip=FO_POINT */\n    BILINEAR: 1,\n    /** Equal to: min=FO_LINEAR, mag=FO_LINEAR, mip=FO_LINEAR */\n    TRILINEAR: 2,\n    /** Equal to: min=FO_ANISOTROPIC, max=FO_ANISOTROPIC, mip=FO_LINEAR */\n    ANISOTROPIC: 3\n};\n\n/** FilterType.\r\n @namespace constant.FilterType\r\n */\nconstant.FilterType = {\n    /** The filter used when shrinking a texture */\n    MIN: 0,\n    /** The filter used when magnifying a texture */\n    MAG: 1,\n    /** The filter used when determining the mipmap */\n    MIP: 2\n};\n\n/** Filtering options for textures / mipmaps.\r\n @namespace constant.FilterOptions\r\n */\nconstant.FilterOptions = {\n    /** No filtering, used for FILT_MIP to turn off mipmapping */\n    NONE: 0,\n    /** Use the closest pixel */\n    POINT: 1,\n    /** Average of a 2x2 pixel area, denotes bilinear for MIN and MAG, trilinear for MIP */\n    LINEAR: 2,\n    /** Similar to FO_LINEAR, but compensates for the angle of the texture plane */\n    ANISOTROPIC: 3\n};\n\n/** Fog modes.\r\n * @namespace constant.FogMode\r\n */\nconstant.FogMode = {\n    /** No fog. Duh. */\n    NONE: 0,\n    /** Fog density increases  exponentially from the camera (fog = 1/e^(distance * density)) */\n    EXP: 1,\n    /** Fog density increases at the square of FOG_EXP, i.e. even quicker (fog = 1/e^(distance * density)^2) */\n    EXP2: 2,\n    /** Fog density increases linearly between the start and end distances */\n    LINEAR: 3\n};\n\n/** Hardware culling modes based on vertex winding.\r\n This setting applies to how the hardware API culls triangles it is sent.\r\n @namespace constant.CullingMode\r\n */\nconstant.CullingMode = {\n    /** Hardware never culls triangles and renders everything it receives. */\n    NONE: 1,\n    /** Hardware culls triangles whose vertices are listed clockwise in the view (default). */\n    CLOCKWISE: 2,\n    /** Hardware culls triangles whose vertices are listed anticlockwise in the view. */\n    ANTICLOCKWISE: 3\n};\n\n/** The polygon mode to use when rasterising.\r\n @namespace constant.PolygonMode\r\n */\nconstant.PolygonMode = {\n    /** Only points are rendered. */\n    POINTS: 1,\n    /** Wireframe models are rendered. */\n    WIREFRAME: 2,\n    /** Solid polygons are rendered. */\n    SOLID: 3\n};\n\nconstant.GeometryShapeType = {\n    Shape: 0,\n    Circle: 1,\n    Rectangle: 2\n};\n\nconstant.GeometryPathType = {\n    RoundedCornerSpline3: 0,\n    CatmullRomSpline3: 1,\n    Line: 2\n};\n\nconstant.GeometryTrackAddressingMode = {\n    ABSOLUTE_LINEIC: 0,\n    RELATIVE_LINEIC: 1,\n    POINT: 2\n};\n\n/** Texture addressing modes - default is TAM_WRAP.\r\n @note\r\n These settings are relevant in both the fixed-function and the\r\n programmable pipeline.\r\n @namespace constant.TextureAddressingMode\r\n */\nconstant.TextureAddressingMode = {\n    /** Texture wraps at values over 1.0 */\n    WRAP: 0,\n    /** Texture mirrors (flips) at joins over 1.0 */\n    MIRROR: 1,\n    /** Texture clamps at 1.0 */\n    CLAMP: 2,\n    /** Texture coordinates outside the range [0.0, 1.0] are set to the border colour */\n    BORDER: 3\n};\n\n/** Enum identifying the texture type\r\n @namespace constant.TextureType\r\n */\nconstant.TextureType = {\n    /** 1D texture, used in combination with 1D texture coordinates */\n    TEX_TYPE_1D: 1,\n    /** 2D texture, used in combination with 2D texture coordinates (default) */\n    TEX_TYPE_2D: 2,\n    /** 3D volume texture, used in combination with 3D texture coordinates */\n    TEX_TYPE_3D: 3,\n    /** 3D cube map, used in combination with 3D texture coordinates */\n    TEX_TYPE_CUBE_MAP: 4\n};\n\n/** Enum identifying special mipmap numbers\r\n @namespace constant.TextureMipmap\r\n */\nconstant.TextureMipmap = {\n    /** Generate mipmaps up to 1x1 */\n    UNLIMITED: 0x7FFFFFFF,\n    /** Use TextureManager default */\n    DEFAULT: -1\n};\n\n/**\r\n * The rendering operation type to perform\r\n * larrow rename from OperationType\r\n * @namespace constant.RenderOperationType\r\n */\nconstant.RenderOperationType = {\n    /** A list of points, 1 vertex per point */\n    POINT_LIST: 1,\n    /** A list of lines, 2 vertices per line */\n    LINE_LIST: 2,\n    /** A strip of connected lines, 1 vertex per line plus 1 start vertex */\n    LINE_STRIP: 3,\n    /** A list of triangles, 3 vertices per triangle */\n    TRIANGLE_LIST: 4,\n    /** A strip of triangles, 3 vertices for the first triangle, and 1 per triangle after that */\n    TRIANGLE_STRIP: 5,\n    /** A fan of triangles, 3 vertices for the first triangle, and 1 per triangle after that */\n    TRIANGLE_FAN: 6\n};\n\n/** Enumeration of queue groups, by which the application may group queued renderables\r\n so that they are rendered together with events in between\r\n @remarks\r\n When passed into methods these are actually passed as a uint8 to allow you\r\n to use values in between if you want to.\r\n * @namespace constant.RenderQueueGroupID\r\n */\nconstant.RenderQueueGroupID = {\n    /** Use this queue for objects which must be rendered first e.g. backgrounds */\n    RENDER_QUEUE_BACKGROUND: 0,\n    /** First queue (after backgrounds), used for skyboxes if rendered first */\n    RENDER_QUEUE_SKIES_EARLY: 5,\n    /** RENDER_QUEUE_1 */\n    RENDER_QUEUE_1: 10,\n    /** RENDER_QUEUE_2 */\n    RENDER_QUEUE_2: 20,\n    /** RENDER_QUEUE_WORLD_GEOMETRY_1 */\n    RENDER_QUEUE_WORLD_GEOMETRY_1: 25,\n    /** RENDER_QUEUE_3 */\n    RENDER_QUEUE_3: 30,\n    /** RENDER_QUEUE_4 */\n    RENDER_QUEUE_4: 40,\n    /** The default render queue */\n    RENDER_QUEUE_MAIN: 50,\n    /** RENDER_QUEUE_6 */\n    RENDER_QUEUE_6: 60,\n    /** RENDER_QUEUE_7 */\n    RENDER_QUEUE_7: 70,\n    /** RENDER_QUEUE_WORLD_GEOMETRY_2 */\n    RENDER_QUEUE_WORLD_GEOMETRY_2: 75,\n    /** RENDER_QUEUE_8 */\n    RENDER_QUEUE_8: 80,\n    /** RENDER_QUEUE_9 */\n    RENDER_QUEUE_9: 90,\n    /** Penultimate queue(before overlays), used for skyboxes if rendered last */\n    RENDER_QUEUE_SKIES_LATE: 95,\n    /** Use this queue for objects which must be rendered last e.g. overlays */\n    RENDER_QUEUE_OVERLAY: 100,\n    /** Final possible render queue, don't exceed this */\n    RENDER_QUEUE_MAX: 105\n};\n\n/**\r\n * Defines the relative positions for the Position object.\r\n * @namespace constant.FlashRelativePosition\r\n */\nconstant.RelativePosition = {\n    /** Left. */\n    Left: 0,\n    /** TopLeft. */\n    TopLeft: 1,\n    /** TopCenter. */\n    TopCenter: 2,\n    /** TopRight. */\n    TopRight: 3,\n    /** Right. */\n    Right: 4,\n    /** BottomRight. */\n    BottomRight: 5,\n    /** BottomCenter. */\n    BottomCenter: 6,\n    /** BottomLeft. */\n    BottomLeft: 7,\n    /** Center. */\n    Center: 8\n};\n//constant.OverlayRelativePosition = constant.FlashRelativePosition;\n\n/**\r\n * Used by FlashControl::setScaleMode, defines the scaling mode to use when the aspect ratio of the control does not match that of the movie.\r\n *\r\n * <ul>\r\n * <li>SM_SHOWALL - Preserves the movie's aspect ratio by adding borders. (Default)\r\n * <li>SM_NOBORDER - Preserves the movie's aspect ratio by cropping the sides.\r\n * <li>SM_EXACTFIT - Does not preserve the movie's aspect ratio, scales the movie to the dimensions of the control.\r\n * @namespace constant.FlashScaleMode\r\n */\nconstant.FlashScaleMode = {\n    SHOWALL: 0,\n    NOBORDER: 1,\n    EXACTFIT: 2\n};\n\n/** The types of animation interpolation available.\r\n * @namespace constant.InterpolationMode\r\n */\nconstant.InterpolationMode = {\n    /** Values are interpolated along straight lines. */\n    LINEAR: 0,\n    /** Values are interpolated along a spline, resulting in smoother changes in direction. */\n    SPLINE: 1\n};\n\n/** The types of rotational interpolation available.\r\n * @namespace constant.RotationInterpolationMode\r\n */\nconstant.RotationInterpolationMode = {\n    /** Values are interpolated linearly. This is faster but does not\r\n     necessarily give a completely accurate result.\r\n     */\n    LINEAR: 0,\n    /** Values are interpolated spherically. This is more accurate but\r\n     has a higher cost.\r\n     */\n    SPHERICAL: 0\n};\n\n/** The types of Overlay Element.\r\n * @namespace constant.OverlayElementType\r\n */\nconstant.OverlayElementType = {\n    /** Panel */\n    Panel: 'Panel',\n    /** BorderPanel */\n    BorderPanel: 'BorderPanel'\n};\n\n/** Enum describing how the position / size of an element is to be recorded.\r\n * @namespace constant.GuiMetricsMode\r\n */\nconstant.GuiMetricsMode = {\n    /** 'left', 'top', 'height' and 'width' are parametrics from 0.0 to 1.0 */\n    RELATIVE: 0,\n    /** Positions & sizes are in absolute pixels */\n    PIXELS: 1,\n    /** Positions & sizes are in virtual pixels */\n    RELATIVE_ASPECT_ADJUSTED: 2\n};\n\n/** Enum describing where '0' is in relation to the parent in the horizontal dimension.\r\n @remarks Affects how 'left' is interpreted.\r\n * @namespace constant.GuiHorizontalAlignment\r\n */\nconstant.GuiHorizontalAlignment = {\n    /** left */\n    LEFT: 0,\n    /** center */\n    CENTER: 1,\n    /** right */\n    RIGHT: 2\n};\n\n/** Enum describing where '0' is in relation to the parent in the vertical dimension.\r\n @remarks Affects how 'top' is interpreted.\r\n * @namespace constant.GuiVerticalAlignment\r\n */\nconstant.GuiVerticalAlignment = {\n    /** top */\n    TOP: 0,\n    /** center */\n    CENTER: 1,\n    /** bottom */\n    BOTTOM: 2\n};\n\n/**\r\n * Enumeration\r\n * @namespace constant.FontStyle\r\n */\nconstant.FontStyle = {\n    /** Regular */\n    Regular: 0,\n    /** Bold */\n    Bold: 1,\n    /** Italic */\n    Italic: 2,\n    /** BoldItalic */\n    BoldItalic: 3,\n    /** Underline */\n    Underline: 4,\n    /** Strikeout */\n    Strikeout: 8\n};\n\n/**\r\n * Enumeration\r\n * @namespace constant.BrushType\r\n */\nconstant.BrushType = {\n    /** SolidColor */\n    SolidColor: 0,\n    /** HatchFill */\n    HatchFill: 1,\n    /** TextureFill */\n    TextureFill: 2,\n    /** PathGradient */\n    PathGradient: 3,\n    /** LinearGradient */\n    LinearGradient: 4\n};\n\n/**\r\n * Enumeration\r\n * @namespace constant.BrushType\r\n */\nconstant.PenAlignment = {\n    /** Alignment Center */\n    Center: 0,\n    /** Alignment Inset */\n    Inset: 1\n};\n\n/**\r\n * Line cap constants (only the lowest 8 bits are used).\r\n * @namespace constant.LineCap\r\n */\nconstant.LineCap = {\n    /** Flat */\n    Flat: 0,\n    /** Square */\n    Square: 1,\n    /** Round */\n    Round: 2,\n    /** Triangle */\n    Triangle: 3,\n\n    /** NoAnchor */\n    NoAnchor: 0x10, // corresponds to flat cap\n    /** SquareAnchor */\n    SquareAnchor: 0x11, // corresponds to square cap\n    /** RoundAnchor */\n    RoundAnchor: 0x12, // corresponds to round cap\n    /** DiamondAnchor */\n    DiamondAnchor: 0x13, // corresponds to triangle cap\n    /** ArrowAnchor */\n    ArrowAnchor: 0x14, // no correspondence\n    /** Custom */\n    Custom: 0xff, // custom cap\n    /** AnchorMask */\n    AnchorMask: 0xf0 // mask to check for anchor or not.\n};\n\n/**\r\n * Line join constants\r\n * @namespace constant.LineJoin\r\n */\nconstant.LineJoin = {\n    /** Miter */\n    Miter: 0,\n    /** Bevel */\n    Bevel: 1,\n    /** Round */\n    Round: 2,\n    /** MiterClipped */\n    MiterClipped: 3\n};\n\n/**\r\n * Dash style constants\r\n * @namespace constant.DashStyle\r\n */\nconstant.DashStyle = {\n    /** Solid */\n    Solid: 0, // 0\n    /** Dash */\n    Dash: 1, // 1\n    /** Dot */\n    Dot: 2, // 2\n    /** DashDot */\n    DashDot: 3, // 3\n    /** DashDotDot */\n    DashDotDot: 4, // 4\n    /** Custom */\n    Custom: 5 // 5\n};\n\n/**\r\n * Dash cap constants\r\n * @namespace constant.DashStyle\r\n */\nconstant.DashCap = {\n    /** Flat */\n    Flat: 0,\n    /** Round */\n    Round: 2,\n    /** Triangle */\n    Triangle: 3\n};\n/**\r\n * Enumeration\r\n * @namespace constant.TextAlignment\r\n */\nconstant.TextAlignment = {\n    /** Left */\n    Left: 0,\n    LEFT: 0,\n    /** Center */\n    Center: 1,\n    CENTER: 1,\n    /** Right */\n    Right: 2,\n    RIGHT: 2,\n    /** Top */\n    Top: 0,\n    TOP: 0,\n    /** Bottom */\n    Bottom: 2,\n    BOTTOM: 2\n};\n\n/**\r\n * Enumeration\r\n * @namespace constant.HtmlViewRenderMode\r\n */\nconstant.HtmlViewRenderMode = {\n    /** CONTINUOUS */\n    CONTINUOUS: 0,\n    /** ON_DEMAND */\n    ON_DEMAND: 1\n};\n\n// constant.EventType = {  // When you add to this, don't forget to add to StringFromType!\n// INVALID : 0,\n// CLICK : 1,\n// DBLCLICK : 2,\n// MOUSEDOWN : 3,\n// MOUSEMOVE : 4,\n// MOUSEUP : 5,\n// WHEEL : 6,\n// KEYDOWN : 7,\n// KEYPRESS : 8,\n// KEYUP : 9,\n// RESIZE : 10,  // This we also trigger on the fullscreen transition.\n// CONTEXTMENU : 11\n// };\n\nconstant.EventButton = {\n    LEFT: 0,\n    MIDDLE: 1,\n    RIGHT: 2\n};\n\nconstant.CursorType = {\n    POINTER: 0,\n    CROSS: 1,\n    HAND: 2,\n    IBEAM: 3,\n    WAIT: 4,\n    HELP: 5\n};\n\n/** Specifies perspective (realistic) or orthographic (architectural) projection.\r\n */\nconstant.ProjectionType = {\n    ORTHOGRAPHIC: 0,\n    PERSPECTIVE: 1\n};\n\n/** Gesture ID\r\n */\nconstant.GestureID = {\n    BEGIN: 1,\n    END: 2,\n    ZOOM: 3,\n    PAN: 4,\n    ROTATE: 5,\n    TWOFINGERTAP: 6,\n    PRESSANDTAP: 7,\n    ROLLOVER: 7\n};\n/** packr */\n\nexports.default = constant;\n\n//# sourceURL=webpack:///./src/util/constant.js?")
        },
        "./src/util/game.js": /*!**************************!*\
  !*** ./src/util/game.js ***!
  \**************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.default = {\n  isSupportNonPowerOf2Textures: function isSupportNonPowerOf2Textures() {\n    return false;\n  },\n  render: function render() {}\n};\n\n//# sourceURL=webpack:///./src/util/game.js?')
        },
        "./src/util/grid.js": /*!**************************!*\
  !*** ./src/util/grid.js ***!
  \**************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n\tvalue: true\n});\nexports.default = {\n\tinit: function init(scene) {\n\t\tthis.scene = scene;\n\t},\n\tsetEnabled: function setEnabled(visible) {\n\t\tvar gridHelper;\n\t\tif (visible) {\n\t\t\tvar size = 30;\n\t\t\tvar divisions = 10;\n\t\t\tgridHelper = new THREE.GridHelper(size, divisions);\n\t\t\tthis.scene.add(gridHelper);\n\t\t}\n\t\tthis.gridHelper = gridHelper;\n\t},\n\tsetPerspectiveSize: function setPerspectiveSize(size) {\n\t\tthis.gridHelper.size = size;\n\t},\n\tsetDivision: function setDivision(division) {\n\t\tthis.gridHelper.division = division;\n\t},\n\tenable: function enable() {}\n};\n\n//# sourceURL=webpack:///./src/util/grid.js?')
        },
        "./src/util/helper.js": /*!****************************!*\
  !*** ./src/util/helper.js ***!
  \****************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = {\n    toHexString: function toHexString(r, g, b) {\n        return ('00000' + (r << 16 | g << 8 | b).toString(16)).slice(-6);\n    },\n    getUUID: function getUUID() {\n        var d = new Date().getTime();\n        var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n            var r = (d + Math.random() * 16) % 16 | 0;\n            d = Math.floor(d / 16);\n            return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n        });\n        return uuid;\n    },\n\n    /**\r\n     * 克隆对象\r\n     * @memberof THING.Utils\r\n     * @param {Object} obj js对象\r\n     * @param {Boolean} isDeep 是否深拷贝\r\n     * @return {Object}\r\n     */\n    clone: function clone(obj, isDeep) {\n        if (!obj || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {\n            return obj;\n        }\n        var c = obj instanceof Array ? [] : {};\n        for (var i in obj) {\n            var prop = obj[i];\n            if (isDeep && (typeof prop === 'undefined' ? 'undefined' : _typeof(prop)) == 'object') {\n                if (prop instanceof Array) {\n                    c[i] = [];\n\n                    for (var j = 0; j < prop.length; j++) {\n                        if (_typeof(prop[j]) != 'object') {\n                            c[i].push(prop[j]);\n                        } else {\n                            c[i].push(this.clone(prop[j], isDeep));\n                        }\n                    }\n                } else {\n                    c[i] = this.clone(prop, isDeep);\n                }\n            } else {\n                c[i] = prop;\n            }\n        }\n        return c;\n    },\n\n    /**\r\n     * 成员键值全部转换成小写\r\n     * @memberof THING.Utils\r\n     * @param {Object} input 要处理的 js 对象\r\n     * @param {Boolean} deep 是否需要转换所有的键值\r\n     * @param {Function} filter 键值过滤函数\r\n     * @return {Object}\r\n     */\n    objectKeysToLowerCase: function objectKeysToLowerCase(input, deep, filter) {\n        var idx, key, keys, last, output, self, type, value;\n        self = this.objectKeysToLowerCase;\n        type = typeof deep === 'undefined' ? 'undefined' : _typeof(deep);\n\n        // Convert \"deep\" to a number between 0 to Infinity or keep special object.\n        if (type === 'undefined' || deep === null || deep === 0 || deep === false) {\n            deep = 0; // Shallow copy\n        } else if (type === 'object') {\n            if (!(deep instanceof self)) {\n                throw new TypeError('Expected \"deep\" to be a special object');\n            }\n        } else if (deep === true) {\n            deep = Infinity; // Deep copy\n        } else if (type === 'number') {\n            if (isNaN(deep) || deep < 0) {\n                throw new RangeError('Expected \"deep\" to be a positive number, got ' + deep);\n            }\n        } else throw new TypeError('Expected \"deep\" to be a boolean, number or object, got \"' + type + '\"');\n\n        // Check type of input, and throw if null or not an object.\n        if (input === null || (typeof input === 'undefined' ? 'undefined' : _typeof(input)) !== 'object') {\n            throw new TypeError('Expected \"input\" to be an object');\n        }\n\n        // Check type of filter\n        type = typeof filter === 'undefined' ? 'undefined' : _typeof(filter);\n        if (filter === null || type === 'undefined' || type === 'function') {\n            filter = filter || null;\n        } else {\n            throw new TypeError('Expected \"filter\" to be a function');\n        }\n\n        keys = Object.keys(input); // Get own keys from object\n        last = keys.length - 1;\n        output = {}; // new object\n\n        if (deep) {\n            // only run the deep copy if needed.\n            if (typeof deep === 'number') {\n                // Create special object to be used during deep copy\n                deep = Object.seal(Object.create(self.prototype, {\n                    input: { value: [] },\n                    output: { value: [] },\n                    level: { value: -1, writable: true },\n                    max: { value: deep, writable: false }\n                }));\n            } else {\n                // Circle detection\n                idx = deep.input.indexOf(input);\n                if (~idx) {\n                    return deep.output[idx];\n                }\n            }\n\n            deep.level += 1;\n            deep.input.push(input);\n            deep.output.push(output);\n\n            idx = last + 1;\n            while (idx--) {\n                key = keys[last - idx]; // Using [last - idx] to preserve order.\n                value = input[key];\n                if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value && deep.level < deep.max) {\n                    if (filter ? filter(value) : value.constructor === Object) {\n                        value = self(value, deep, filter);\n                    }\n                }\n                output[key.toLowerCase()] = value;\n            }\n            deep.level -= 1;\n        } else {\n            // Simple shallow copy\n            idx = last + 1;\n            while (idx--) {\n                key = keys[last - idx]; // Using [last - idx] to preserve order.\n                output[key.toLowerCase()] = input[key];\n            }\n        }\n        return output;\n    }\n};\n\n//# sourceURL=webpack:///./src/util/helper.js?")
        },
        "./src/util/math.js": /*!**************************!*\
  !*** ./src/util/math.js ***!
  \**************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\n\n/**\r\n * A module for math for math.\r\n * @namespace math\r\n */\nvar math = {};\n\nmath.debug = {\n    logWarning: function logWarning(msg) {\n        console.warn(msg);\n    }\n};\n\n/**\r\n * Creates a quaternion which rotates around the given axis by the given\r\n * angle.\r\n * @param {!math.Vector3} axis The axis about which to rotate.\r\n * @param {number} angle The angle by which to rotate (in degree!).\r\n * @return {!quaternions.Quaternion} A quaternion which rotates angle\r\n *     degree around the axis.\r\n */\nmath.makeQuatAxisAngle = function (axis, degree) {\n    var radians = math.degreesToRadians(degree);\n    var d = 1 / Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);\n    var sin = Math.sin(radians / 2);\n    var cos = Math.cos(radians / 2);\n    return [sin * axis[0] * d, sin * axis[1] * d, sin * axis[2] * d, cos];\n};\n\n/**\r\n * Multiplies two quaternions.\r\n * @param {!quaternions.Quaternion} a Operand quaternion.\r\n * @param {!quaternions.Quaternion} b Operand quaternion.\r\n * @return {!quaternions.Quaternion} The quaternion product a * b.\r\n */\nmath.mulQuatQuat = function (a, b) {\n    var aX = a[0];\n    var aY = a[1];\n    var aZ = a[2];\n    var aW = a[3];\n    var bX = b[0];\n    var bY = b[1];\n    var bZ = b[2];\n    var bW = b[3];\n\n    return [aW * bX + aX * bW + aY * bZ - aZ * bY, aW * bY + aY * bW + aZ * bX - aX * bZ, aW * bZ + aZ * bW + aX * bY - aY * bX, aW * bW - aX * bX - aY * bY - aZ * bZ];\n};\n\n/**\r\n * Divides a Quaternion by its length and returns the quotient.\r\n * @param {!quaternions.Quaternion} a The Quaternion.\r\n * @return {!quaternions.Quaternion} A unit length quaternion pointing in\r\n *     the same direction as a.\r\n */\nmath.normalizeQuat = function (a) {\n    var d = 1 / Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3]);\n    return [a[0] * d, a[1] * d, a[2] * d, a[3] * d];\n};\n\nmath.numberSign = function (n) {\n    if (n < 0) {\n        return -1;\n    }\n    return 1;\n};\n\n/**\r\n * Converts degrees to radians.\r\n * @param {number} degrees A value in degrees.\r\n * @return {number} the value in radians.\r\n */\nmath.degToRad = function (degrees) {\n    return degrees * Math.PI / 180;\n};\n\n/**\r\n * Converts radians to degrees.\r\n * @param {number} radians A value in radians.\r\n * @return {number} the value in degrees.\r\n */\nmath.radToDeg = function (radians) {\n    return radians * 180 / Math.PI;\n};\n\n/**\r\n * Negates a vector.\r\n * @param {!math.Vector} v The vector.\r\n * @return {!math.Vector} -v.\r\n */\nmath.negativeVector = function (v) {\n    var r = [];\n    var vLength = v.length;\n    for (var i = 0; i < vLength; ++i) {\n        r[i] = -v[i];\n    }\n    return r;\n};\n\n/**\r\n * .toFixed(x) a vector.\r\n * @param {!math.Vector} v The vector.\r\n * @return {!math.Vector} v.\r\n */\nmath.fixedVector = function (v, x) {\n    var r = [];\n    var vLength = v.length;\n    for (var i = 0; i < vLength; ++i) {\n        r[i] = v[i].toFixed(x);\n    }\n    return r;\n};\n\n/**\r\n vectorDistance\r\n */\nmath.vectorDistance = function (v1, v2) {\n    var v = math.subtractVectors(v1, v2);\n    return math.vectorLength(v);\n};\n\n/*\r\n copy cpp code from ogre:\r\n 目前只是抄写, 没测试\r\n Vector3 Quaternion::operator* (const Vector3& v) const\r\n {\r\n // nVidia SDK implementation\r\n Vector3 uv, uuv;\r\n Vector3 qvec(x, y, z);\r\n uv = qvec.crossProduct(v);\r\n uuv = qvec.crossProduct(uv);\r\n uv *= (2.0f * w);\r\n uuv *= 2.0f;\r\n\r\n return v + uv + uuv;\r\n\r\n }\r\n */\nmath.multiplyQuatByVector = function (quatOne, vecOne) {\n    var qvec = [quatOne[0], quatOne[1], quatOne[2]];\n\n    var uv = math.vectorCrossProduct(qvec, vecOne);\n    var uuv = math.vectorCrossProduct(qvec, uv);\n\n    uv = math.multiplyVector(uv, 2.0 * quatOne[3]);\n    uuv = math.multiplyVector(uuv, 2.0);\n\n    var tmp = math.addVectors(vecOne, uv);\n    return math.addVectors(tmp, uuv);\n};\n\n/**\r\n random range\r\n */\n// math.random = function (minValue, maxValue) {\n//     return uinv.random() * maxValue + minValue;\n// };\n\n/**\r\n random Vector\r\n math.randomVector2 = function (minValue, maxValue) {\r\n    return [math.random(minValue, maxValue), math.random(minValue, maxValue)];\r\n}\r\n */\n\n/**\r\n * @author mr.doob / http://mrdoob.com/\r\n */\nmath.Color = function (hex) {\n    this.setHex(hex);\n};\nmath.Color.prototype = {\n    // larrow add\n    toArray: function toArray() {\n        return [this.r, this.g, this.b];\n    },\n\n    copy: function copy(color) {\n        this.r = color.r;\n        this.g = color.g;\n        this.b = color.b;\n        this.hex = color.hex;\n    },\n\n    setHex: function setHex(hex) {\n        this.hex = ~~hex & 0xffffff;\n        this.updateRGB();\n    },\n\n    setRGB: function setRGB(r, g, b) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.updateHex();\n    },\n\n    setHSV: function setHSV(h, s, v) {\n        // based on MochiKit implementation by Bob Ippolito\n        // h,s,v ranges are < 0.0 - 1.0 >\n        var r, g, b, i, f, p, q, t;\n        if (v == 0.0) {\n            r = g = b = 0;\n        } else {\n            i = Math.floor(h * 6);\n            f = h * 6 - i;\n            p = v * (1 - s);\n            q = v * (1 - s * f);\n            t = v * (1 - s * (1 - f));\n            switch (i) {\n                case 1:\n                    r = q;\n                    g = v;\n                    b = p;\n                    break;\n                case 2:\n                    r = p;\n                    g = v;\n                    b = t;\n                    break;\n                case 3:\n                    r = p;\n                    g = q;\n                    b = v;\n                    break;\n                case 4:\n                    r = t;\n                    g = p;\n                    b = v;\n                    break;\n                case 5:\n                    r = v;\n                    g = p;\n                    b = q;\n                    break;\n                case 6: // fall through\n                case 0:\n                    r = v;\n                    g = t;\n                    b = p;\n                    break;\n            }\n        }\n        this.setRGB(r, g, b);\n    },\n\n    updateHex: function updateHex() {\n        this.hex = ~~(this.r * 255) << 16 ^ ~~(this.g * 255) << 8 ^ ~~(this.b * 255);\n    },\n\n    updateRGB: function updateRGB() {\n        this.r = (this.hex >> 16 & 255) / 255;\n        this.g = (this.hex >> 8 & 255) / 255;\n        this.b = (this.hex & 255) / 255;\n    },\n\n    clone: function clone() {\n        return new math.Color(this.hex);\n    }\n\n};\n\nmath.hexColorToArray = function (hex) {\n    var clr = new math.Color(hex);\n    return clr.toArray();\n};\n\n//wxz\nmath.parseVector3 = function (str) {\n    var strList = str.split(' ');\n    var x = Number(strList[0]);\n    var y = Number(strList[1]);\n    var z = Number(strList[2]);\n    var v = [x, y, z];\n    return v;\n};\n\nmath.parseQuaternion = function (str) {\n    var strList = str.split(' ');\n    var w = Number(strList[0]);\n    var x = Number(strList[1]);\n    var y = Number(strList[2]);\n    var z = Number(strList[3]);\n    return [x, y, z, w];\n};\n\n// larrow 2016.09.19\nmath.parseVector2 = function (str) {\n    var strList = str.split(' ');\n    var x = Number(strList[0]);\n    var y = Number(strList[1]);\n    var v = [x, y];\n    return v;\n};\n/*\r\n Copyright (c) 2008 Seneca College\r\n Licenced under the MIT License (http://www.math.org/index.php/mit-license/)\r\n */\n\n/**\r\n math.TOLERANCE = 0.00001<br />\r\n This is used as a buffer when doing some calculations with\r\n floating point numbers.  Due to floating point innacuracy, we cannot\r\n use == on floating point numbers for comparison.  Two floats which\r\n we believe to be equal may in fact not be equal, they may vary a\r\n small amount. Therefore a constant is defined here which will later\r\n be used to compare against the difference on vector component\r\n allowing some tolerance.\r\n @constant\r\n */\nmath.TOLERANCE = 0.00001;\n\nvar T3D_FLOAT_ARRAY = Array;\nvar dest;\n\n/**\r\n @private\r\n Find the smallest number that's a power of 2 that's bigger\r\n than the given number.\r\n\r\n @param {int} number The base number which the next power of two\r\n number must be found.  For example:\r\n <pre>\r\n var i = roundUpToNextPowerOfTwo(3);\r\n // i is now 4\r\n\r\n i = roundUpToNextPowerOfTwo(4);\r\n // i is now 4\r\n\r\n i = roundUpToNextPowerOfTwo(9);\r\n // i is now 16\r\n </pre>\r\n\r\n @returns {int} A number which is greater or equal to 'number'\r\n which is the closest power of two which exists.\r\n */\nmath.roundUpToNextPowerOfTwo = function (number) {\n    var i = 1;\n\n    while (i < number) {\n        i *= 2;\n    }\n\n    return i;\n};\n\n/**\r\n Inverse of a square root.\r\n\r\n @param {float} num\r\n\r\n @return {float} the inverse square root of num or 0 ir num was not a\r\n number.\r\n */\nmath.invSqrt = function (num) {\n    if (!isNaN(num)) {\n        // We have to do this ourselves since javascript does not have it.\n        return 1 / Math.sqrt(num);\n    }\n\n    math.debug.logWarning('invSqrt() caled with a parameter that\\'s not a number');\n\n    return 0;\n};\n\n/**\r\n gluLookAt Implementation\r\n\r\n @param {Array} eye The location of the camera.\r\n @param {Array} center Where the camera is looking at.\r\n @param {Array} up A Vector which represents the camera's up\r\n vector.\r\n\r\n @returns {Array} the lookat matrix or null if one of the arguments were\r\n not valid Vectors.\r\n */\nmath.lookAt = function (eye, center, up) {\n    // Figure out the Orientation\n    var z = math.subtractVectors(eye, center, null);\n    var x = math.vectorCrossProduct(up, z, null);\n    var y = math.vectorCrossProduct(z, x, null);\n    math.normalizeVector(z);\n    math.normalizeVector(y);\n    math.normalizeVector(x);\n\n    // makeMatrix expects values to be in column-major\n    return math.makeMatrix(x[0], y[0], z[0], 0, x[1], y[1], z[1], 0, x[2], y[2], z[2], 0, 0, 0, 0, 1);\n};\n\n/**\r\n @private\r\n this function needs testing\r\n\r\n Create an orthographic matrix from the specified arguments.\r\n\r\n @param {float} left The coordinate of the left vertical clipping plane.\r\n @param {float} right The coordinate of the right vertical clipping plane.\r\n @param {float} bottom The coordinate of the bottom horizontal clipping\r\n plane.\r\n @param {float} top The coordinate of the top horizontal clipping plane.\r\n @param {float} znear The distance to the near clipping plane.\r\n @param {float} zfar The distance to the far clipping plane.\r\n\r\n @returns {Array} an orthographic matrix defined by the arguments.\r\n */\nmath.makeOrtho = function (left, right, bottom, top, znear, zfar) {\n    return M4x4.makeOrtho(left, right, bottom, top, znear, zfar);\n};\n\n/**\r\n Create a perspective projection matrix.\r\n\r\n @param {float} fovy The field of view angle in degrees in the Y\r\n direction.\r\n @param {float} aspect The aspect ratio\r\n @param {float} znear The distance from the viewer to the near clipping\r\n plane.\r\n @param {float} zfar The distance from the viewer to the far clipping\r\n plane.\r\n\r\n @returns {Array} A perspective projection matrix.\r\n */\nmath.makePerspective = function (fovy, aspect, znear, zfar) {\n    return M4x4.makePerspective(fovy, aspect, znear, zfar);\n};\n\n/**\r\n glFrustum Implementation\r\n\r\n @param {float} left The coordinate of the left vertical clipping plane.\r\n @param {float} right The coordinate of the right vertical clipping plane.\r\n @param {float} bottom The coordinate of the bottom horizontal clipping\r\n plane.\r\n @param {float} top The coordinate of the top horizontal clipping plane.\r\n @param {float} znear The distance to the near clipping plane.\r\n @param {float} zfar The distance to the far clipping plane.\r\n\r\n @returns {Array} A perspective projection matrix.\r\n */\nmath.makeFrustum = function (left, right, bottom, top, znear, zfar) {\n    return M4x4.makeFrustum(left, right, bottom, top, znear, zfar);\n};\n\n/**\r\n Convert 'rad' radians into degrees.\r\n\r\n @param {float} rad The value in radians to convert into degrees.\r\n\r\n @returns {float} The value of 'rad' radians converted to degrees.\r\n */\nmath.radiansToDegrees = function (rad) {\n    return rad / (Math.PI * 2) * 360.0;\n};\n\n/**\r\n Convert 'deg' degrees into radians.\r\n\r\n @param {float} degrees The value in degrees to convert into radians.\r\n\r\n @returns {float} The value of 'deg' degrees converted to radians.\r\n */\nmath.degreesToRadians = function (deg) {\n    return deg / 360.0 * (Math.PI * 2);\n};\n\n/**\r\n Get a random value from min to max inclusive\r\n\r\n @param {num} min\r\n @param {num} max\r\n\r\n @returns {num} a random number from min to max.\r\n */\n// math.getRandom = function (min, max) {\n//     var norm = uinv.random();\n//     return ((max - min) * norm) + min;\n// };\n\n// math.getRandomInt = function (min, max) {\n//     var norm = uinv.random();\n//     var result = ((max - min) * norm) + min;\n//     return Math.floor(result);\n// };\n\nmath.findMax = function (arrayIn) {\n    var max = arrayIn[0];\n    for (var i = 0; i < arrayIn.length; i++) {\n        if (arrayIn[i] > max) {\n            max = arrayIn[i];\n        }\n    }\n    return max;\n};\n\nmath.findMin = function (arrayIn) {\n    var min = arrayIn[0];\n    for (var i = 0; i < arrayIn.length; i++) {\n        if (arrayIn[i] < min) {\n            min = arrayIn[i];\n        }\n    }\n    return min;\n};\n/* -*- Mode: js2; js2-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40; -*- */\n/*\r\n * Copyright (c) 2010 Mozilla Corporation\r\n * Copyright (c) 2010 Vladimir Vukicevic\r\n *\r\n * Permission is hereby granted, free of charge, to any person\r\n * obtaining a copy of this software and associated documentation\r\n * files (the \"Software\"), to deal in the Software without\r\n * restriction, including without limitation the rights to use,\r\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\n * OTHER DEALINGS IN THE SOFTWARE.\r\n */\n// larrow skip const MJS_VERSION = 0x000000;\n// larrow skip const MJS_DO_ASSERT = true;\n/* larrow skip\r\n try {\r\n WebGLFloatArray;\r\n } catch (x) {\r\n WebGLFloatArray = Float32Array;\r\n }\r\n */\n// larrow skip const MJS_FLOAT_ARRAY_TYPE =  WebGLFloatArray;\n\n// larrow add:\nvar MJS_VERSION = 0x000000;\nvar MJS_DO_ASSERT = true;\nvar MJS_FLOAT_ARRAY_TYPE = Array;\n\nfunction MathUtils_assert(cond, msg) {\n    if (MJS_DO_ASSERT) {\n        if (!cond) throw new Error('Assertion failed: ' + msg);\n    }\n}\n\nvar V3 = {};\nV3._temp1 = new MJS_FLOAT_ARRAY_TYPE(3);\nV3._temp2 = new MJS_FLOAT_ARRAY_TYPE(3);\nV3._temp3 = new MJS_FLOAT_ARRAY_TYPE(3);\nif (MJS_FLOAT_ARRAY_TYPE == Array) {\n    V3.x = [1.0, 0.0, 0.0];\n    V3.y = [0.0, 1.0, 0.0];\n    V3.z = [0.0, 0.0, 1.0];\n    V3.$ = function V3_$(x, y, z) {\n        return [x, y, z];\n    };\n    V3.clone = function V3_clone(a) {\n        return [a[0], a[1], a[2]];\n    };\n} else {\n    V3.x = new MJS_FLOAT_ARRAY_TYPE([1.0, 0.0, 0.0]);\n    V3.y = new MJS_FLOAT_ARRAY_TYPE([0.0, 1.0, 0.0]);\n    V3.z = new MJS_FLOAT_ARRAY_TYPE([0.0, 0.0, 1.0]);\n    V3.$ = function V3_$(x, y, z) {\n        return new MJS_FLOAT_ARRAY_TYPE([x, y, z]);\n    };\n    V3.clone = function V3_clone(a) {\n        return new MJS_FLOAT_ARRAY_TYPE(a);\n    };\n}\nV3.u = V3.x;\nV3.v = V3.y;\nV3.add = function (a, b, r) {\n    if (r == undefined) r = new MJS_FLOAT_ARRAY_TYPE(3);\n    r[0] = a[0] + b[0];\n    r[1] = a[1] + b[1];\n    r[2] = a[2] + b[2];\n    return r;\n};\nV3.sub = function (a, b, r) {\n    if (r == undefined) r = new MJS_FLOAT_ARRAY_TYPE(3);\n    r[0] = a[0] - b[0];\n    r[1] = a[1] - b[1];\n    r[2] = a[2] - b[2];\n    return r;\n};\nV3.neg = function (a, r) {\n    if (r == undefined) r = new MJS_FLOAT_ARRAY_TYPE(3);\n    r[0] = -a[0];\n    r[1] = -a[1];\n    r[2] = -a[2];\n    return r;\n};\nV3.direction = function (a, b, r) {\n    if (r == undefined) r = new MJS_FLOAT_ARRAY_TYPE(3);\n    return V3.normalize(V3.sub(a, b, r), r);\n};\nV3.length = function (a) {\n    var temp = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);\n    return temp;\n};\nV3.lengthSquared = function (a) {\n    return a[0] * a[0] + a[1] * a[1] + a[2] * a[2];\n};\nV3.normalize = function (a, r) {\n    if (r == undefined) r = new MJS_FLOAT_ARRAY_TYPE(3);\n    var im = 1.0 / V3.length(a);\n    r[0] = a[0] * im;\n    r[1] = a[1] * im;\n    r[2] = a[2] * im;\n    return r;\n};\nV3.scale = function (a, k, r) {\n    if (r == undefined) r = new MJS_FLOAT_ARRAY_TYPE(3);\n    r[0] = a[0] * k;\n    r[1] = a[1] * k;\n    r[2] = a[2] * k;\n    return r;\n};\nV3.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n};\nV3.cross = function (a, b, r) {\n    if (r == undefined) r = new MJS_FLOAT_ARRAY_TYPE(3);\n    r[0] = a[1] * b[2] - a[2] * b[1];\n    r[1] = a[2] * b[0] - a[0] * b[2];\n    r[2] = a[0] * b[1] - a[1] * b[0];\n    return r;\n};\nvar M4x4 = {};\nM4x4._temp1 = new MJS_FLOAT_ARRAY_TYPE(16);\nM4x4._temp2 = new MJS_FLOAT_ARRAY_TYPE(16);\nif (MJS_FLOAT_ARRAY_TYPE == Array) {\n    M4x4.I = [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0];\n    M4x4.$ = function M4x4_$(m00, m01, m02, m03, m04, m05, m06, m07, m08, m09, m10, m11, m12, m13, m14, m15) {\n        return [m00, m01, m02, m03, m04, m05, m06, m07, m08, m09, m10, m11, m12, m13, m14, m15];\n    };\n    M4x4.clone = function M4x4_clone(m) {\n        return new [m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11]]();\n    };\n} else {\n    M4x4.I = new MJS_FLOAT_ARRAY_TYPE([1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]);\n    M4x4.$ = function M4x4_$(m00, m01, m02, m03, m04, m05, m06, m07, m08, m09, m10, m11, m12, m13, m14, m15) {\n        return new MJS_FLOAT_ARRAY_TYPE([m00, m01, m02, m03, m04, m05, m06, m07, m08, m09, m10, m11, m12, m13, m14, m15]);\n    };\n    M4x4.clone = function M4x4_clone(m) {\n        return new MJS_FLOAT_ARRAY_TYPE(m);\n    };\n}\nM4x4.identity = M4x4.I;\nM4x4.topLeft3x3 = function M4x4_topLeft3x3(m, r) {\n    if (r == undefined) r = new MJS_FLOAT_ARRAY_TYPE(9);\n    r[0] = m[0];\n    r[1] = m[1];\n    r[2] = m[2];\n    r[3] = m[4];\n    r[4] = m[5];\n    r[5] = m[6];\n    r[6] = m[8];\n    r[7] = m[9];\n    r[8] = m[10];\n    return r;\n};\nM4x4.inverseOrthonormal = function M4x4_inverseOrthonormal(m, r) {\n    if (r == undefined) r = new MJS_FLOAT_ARRAY_TYPE(16);\n    M4x4.transpose(m, r);\n    var t = [m[12], m[13], m[14]];\n    r[3] = r[7] = r[11] = 0;\n    r[12] = -V3.dot([r[0], r[4], r[8]], t);\n    r[13] = -V3.dot([r[1], r[5], r[9]], t);\n    r[14] = -V3.dot([r[2], r[6], r[10]], t);\n    return r;\n};\nM4x4.inverseTo3x3 = function (m, r) {\n    if (r == undefined) r = new MJS_FLOAT_ARRAY_TYPE(9);\n    var a11 = m[10] * m[5] - m[6] * m[9],\n        a21 = -m[10] * m[1] + m[2] * m[9],\n        a31 = m[6] * m[1] - m[2] * m[5],\n        a12 = -m[10] * m[4] + m[6] * m[8],\n        a22 = m[10] * m[0] - m[2] * m[8],\n        a32 = -m[6] * m[0] + m[2] * m[4],\n        a13 = m[9] * m[4] - m[5] * m[8],\n        a23 = -m[9] * m[0] + m[1] * m[8],\n        a33 = m[5] * m[0] - m[1] * m[4];\n    var det = m[0] * a11 + m[1] * a12 + m[2] * a13;\n    if (det == 0) throw new Error('matrix not invertible');\n    var idet = 1.0 / det;\n    r[0] = idet * a11;\n    r[1] = idet * a21;\n    r[2] = idet * a31;\n    r[3] = idet * a12;\n    r[4] = idet * a22;\n    r[5] = idet * a32;\n    r[6] = idet * a13;\n    r[7] = idet * a23;\n    r[8] = idet * a33;\n    return r;\n};\nM4x4.makeFrustum = function (left, right, bottom, top, znear, zfar, r) {\n    if (r == undefined) r = new MJS_FLOAT_ARRAY_TYPE(16);\n    // var X = 2 * znear / (right - left);\n    // var Y = 2 * znear / (top - bottom);\n    // var A = (right + left) / (right - left);\n    // var B = (top + bottom) / (top - bottom);\n    // var C = -(zfar + znear) / (zfar - znear);\n    // var D = -2 * zfar * znear / (zfar - znear);\n    r[0] = 2 * znear / (right - left);\n    r[1] = 0;\n    r[2] = 0;\n    r[3] = 0;\n    r[4] = 0;\n    r[5] = 2 * znear / (top - bottom);\n    r[6] = 0;\n    r[7] = 0;\n    r[8] = (right + left) / (right - left);\n    r[9] = (top + bottom) / (top - bottom);\n    r[10] = -(zfar + znear) / (zfar - znear);\n    r[11] = -1;\n    r[12] = 0;\n    r[13] = 0;\n    r[14] = -2 * zfar * znear / (zfar - znear);\n    r[15] = 0;\n    return r;\n};\nM4x4.makePerspective = function (fovy, aspect, znear, zfar, r) {\n    var ymax = znear * Math.tan(fovy * Math.PI / 360.0);\n    var ymin = -ymax;\n    var xmin = ymin * aspect;\n    var xmax = ymax * aspect;\n    return M4x4.makeFrustum(xmin, xmax, ymin, ymax, znear, zfar, r);\n};\nM4x4.makeOrtho = function (left, right, bottom, top, znear, zfar, r) {\n    if (r == undefined) r = new MJS_FLOAT_ARRAY_TYPE(16);\n    var tX = -(right + left) / (right - left);\n    var tY = -(top + bottom) / (top - bottom);\n    var tZ = -(zfar + znear) / (zfar - znear);\n    // var X = 2 / (right - left);\n    // var Y = 2 / (top - bottom);\n    // var Z = -2 / (zfar - znear);\n    r[0] = 2 / (right - left);\n    r[1] = 0;\n    r[2] = 0;\n    r[3] = 0;\n    r[4] = 0;\n    r[5] = 2 / (top - bottom);\n    r[6] = 0;\n    r[7] = 0;\n    r[8] = 0;\n    r[9] = 0;\n    r[10] = -2 / (zfar - znear);\n    r[11] = 0;\n    r[12] = -(right + left) / (right - left);\n    r[13] = -(top + bottom) / (top - bottom);\n    r[14] = -(zfar + znear) / (zfar - znear);\n    r[15] = 0;\n    return r;\n};\nM4x4.makeOrtho2D = function (left, right, bottom, top, r) {\n    return M4x4.makeOrtho(left, right, bottom, top, -1, 1, r);\n};\nM4x4.mul = function (a, b, r) {\n    if (r == undefined) r = new MJS_FLOAT_ARRAY_TYPE(16);\n    r[0] = b[0] * a[0] + b[0 + 1] * a[4] + b[0 + 2] * a[8] + b[0 + 3] * a[12];\n    r[0 + 1] = b[0] * a[1] + b[0 + 1] * a[5] + b[0 + 2] * a[9] + b[0 + 3] * a[13];\n    r[0 + 2] = b[0] * a[2] + b[0 + 1] * a[6] + b[0 + 2] * a[10] + b[0 + 3] * a[14];\n    r[0 + 3] = b[0] * a[3] + b[0 + 1] * a[7] + b[0 + 2] * a[11] + b[0 + 3] * a[15];\n    r[4] = b[4] * a[0] + b[4 + 1] * a[4] + b[4 + 2] * a[8] + b[4 + 3] * a[12];\n    r[4 + 1] = b[4] * a[1] + b[4 + 1] * a[5] + b[4 + 2] * a[9] + b[4 + 3] * a[13];\n    r[4 + 2] = b[4] * a[2] + b[4 + 1] * a[6] + b[4 + 2] * a[10] + b[4 + 3] * a[14];\n    r[4 + 3] = b[4] * a[3] + b[4 + 1] * a[7] + b[4 + 2] * a[11] + b[4 + 3] * a[15];\n    r[8] = b[8] * a[0] + b[8 + 1] * a[4] + b[8 + 2] * a[8] + b[8 + 3] * a[12];\n    r[8 + 1] = b[8] * a[1] + b[8 + 1] * a[5] + b[8 + 2] * a[9] + b[8 + 3] * a[13];\n    r[8 + 2] = b[8] * a[2] + b[8 + 1] * a[6] + b[8 + 2] * a[10] + b[8 + 3] * a[14];\n    r[8 + 3] = b[8] * a[3] + b[8 + 1] * a[7] + b[8 + 2] * a[11] + b[8 + 3] * a[15];\n    r[12] = b[12] * a[0] + b[12 + 1] * a[4] + b[12 + 2] * a[8] + b[12 + 3] * a[12];\n    r[12 + 1] = b[12] * a[1] + b[12 + 1] * a[5] + b[12 + 2] * a[9] + b[12 + 3] * a[13];\n    r[12 + 2] = b[12] * a[2] + b[12 + 1] * a[6] + b[12 + 2] * a[10] + b[12 + 3] * a[14];\n    r[12 + 3] = b[12] * a[3] + b[12 + 1] * a[7] + b[12 + 2] * a[11] + b[12 + 3] * a[15];\n    return r;\n};\nM4x4.makeRotate = function (angle, axis, r) {\n    if (r == undefined) r = new MJS_FLOAT_ARRAY_TYPE(16);\n    axis = V3.normalize(axis, V3._temp1);\n    var x = axis[0],\n        y = axis[1],\n        z = axis[2];\n    var c = Math.cos(angle);\n    var c1 = 1 - c;\n    var s = Math.sin(angle);\n    r[0] = x * x * c1 + c;\n    r[1] = y * x * c1 + z * s;\n    r[2] = z * x * c1 - y * s;\n    r[3] = 0;\n    r[4] = x * y * c1 - z * s;\n    r[5] = y * y * c1 + c;\n    r[6] = y * z * c1 + x * s;\n    r[7] = 0;\n    r[8] = x * z * c1 + y * s;\n    r[9] = y * z * c1 - x * s;\n    r[10] = z * z * c1 + c;\n    r[11] = 0;\n    r[12] = 0;\n    r[13] = 0;\n    r[14] = 0;\n    r[15] = 1;\n    return r;\n};\nM4x4.rotate = function (angle, axis, m, r) {\n    M4x4.makeRotate(angle, axis, M4x4._temp1);\n    return M4x4.mul(m, M4x4._temp1, r);\n};\nM4x4.makeScale3 = function (x, y, z, r) {\n    if (r == undefined) r = new MJS_FLOAT_ARRAY_TYPE(16);\n    r[0] = x;\n    r[1] = 0;\n    r[2] = 0;\n    r[3] = 0;\n    r[4] = 0;\n    r[5] = y;\n    r[6] = 0;\n    r[7] = 0;\n    r[8] = 0;\n    r[9] = 0;\n    r[10] = z;\n    r[11] = 0;\n    r[12] = 0;\n    r[13] = 0;\n    r[14] = 0;\n    r[15] = 1;\n    return r;\n};\nM4x4.makeScale1 = function (k, r) {\n    return M4x4.makeScale3(k, k, k, r);\n};\nM4x4.makeScale = function (v, r) {\n    return M4x4.makeScale3(v[0], v[1], v[2], r);\n};\nM4x4.scale3 = function (x, y, z, m, r) {\n    M4x4.makeScale3(x, y, z, M4x4._temp1);\n    return M4x4.mul(m, M4x4._temp1, r);\n};\nM4x4.scale1 = function (k, m, r) {\n    M4x4.makeScale3(k, k, k, M4x4._temp1);\n    return M4x4.mul(m, M4x4._temp1, r);\n};\nM4x4.scale = function (v, m, r) {\n    M4x4.makeScale3(v[0], v[1], v[2], M4x4._temp1);\n    return M4x4.mul(m, M4x4._temp1, r);\n};\nM4x4.makeTranslate3 = function (x, y, z, r) {\n    if (r == undefined) r = new MJS_FLOAT_ARRAY_TYPE(16);\n    r[0] = 1;\n    r[1] = 0;\n    r[2] = 0;\n    r[3] = 0;\n    r[4] = 0;\n    r[5] = 1;\n    r[6] = 0;\n    r[7] = 0;\n    r[8] = 0;\n    r[9] = 0;\n    r[10] = 1;\n    r[11] = 0;\n    r[12] = x;\n    r[13] = y;\n    r[14] = z;\n    r[15] = 1;\n    return r;\n};\nM4x4.makeTranslate1 = function (k, r) {\n    return M4x4.makeTranslate3(k, k, k, r);\n};\nM4x4.makeTranslate = function (v, r) {\n    return M4x4.makeTranslate3(v[0], v[1], v[2], r);\n};\nM4x4.translate3 = function (x, y, z, m, r) {\n    M4x4.makeTranslate3(x, y, z, M4x4._temp1);\n    return M4x4.mul(m, M4x4._temp1, r);\n};\nM4x4.translate1 = function (k, m, r) {\n    M4x4.makeTranslate3(k, k, k, M4x4._temp1);\n    return M4x4.mul(m, M4x4._temp1, r);\n};\nM4x4.translate = function (v, m, r) {\n    M4x4.makeTranslate3(v[0], v[1], v[2], M4x4._temp1);\n    return M4x4.mul(m, M4x4._temp1, r);\n};\nM4x4.makeLookAt = function (eye, center, up, r) {\n    var z = V3.direction(eye, center, V3._temp1);\n    var x = V3.normalize(V3.cross(up, z, V3._temp2), V3._temp2);\n    var y = V3.normalize(V3.cross(z, x, V3._temp3), V3._temp3);\n    var tm1 = M4x4._temp1;\n    var tm2 = M4x4._temp2;\n    tm1[0] = x[0];\n    tm1[1] = y[0];\n    tm1[2] = z[0];\n    tm1[3] = 0;\n    tm1[4] = x[1];\n    tm1[5] = y[1];\n    tm1[6] = z[1];\n    tm1[7] = 0;\n    tm1[8] = x[2];\n    tm1[9] = y[2];\n    tm1[10] = z[2];\n    tm1[11] = 0;\n    tm1[12] = 0;\n    tm1[13] = 0;\n    tm1[14] = 0;\n    tm1[15] = 1;\n    tm2[0] = 1;\n    tm2[1] = 0;\n    tm2[2] = 0;\n    tm2[3] = 0;\n    tm2[4] = 0;\n    tm2[5] = 1;\n    tm2[6] = 0;\n    tm2[7] = 0;\n    tm2[8] = 0;\n    tm2[9] = 0;\n    tm2[10] = 1;\n    tm2[3] = 0;\n    tm2[0] = -eye[0];\n    tm2[1] = -eye[1];\n    tm2[2] = -eye[2];\n    tm2[3] = 0;\n    if (r == undefined) r = new MJS_FLOAT_ARRAY_TYPE(16);\n    return M4x4.mul(tm1, tm2, r);\n};\nM4x4.transpose = function (m, r) {\n    if (m == r) {\n        var tmp = 0.0;\n        tmp = m[1];\n        m[1] = m[4];\n        m[4] = tmp;\n        tmp = m[2];\n        m[2] = m[8];\n        m[8] = tmp;\n        tmp = m[3];\n        m[3] = m[12];\n        m[12] = tmp;\n        tmp = m[6];\n        m[6] = m[9];\n        m[9] = tmp;\n        tmp = m[7];\n        m[7] = m[13];\n        m[13] = tmp;\n        tmp = m[11];\n        m[11] = m[14];\n        m[14] = tmp;\n        return m;\n    }\n    if (r == undefined) r = new MJS_FLOAT_ARRAY_TYPE(16);\n    r[0] = m[0];\n    r[1] = m[4];\n    r[2] = m[8];\n    r[3] = m[12];\n    r[4] = m[1];\n    r[5] = m[5];\n    r[6] = m[9];\n    r[7] = m[13];\n    r[8] = m[2];\n    r[9] = m[6];\n    r[10] = m[10];\n    r[11] = m[14];\n    r[12] = m[3];\n    r[13] = m[7];\n    r[14] = m[11];\n    r[15] = m[15];\n    return r;\n};\n/*\r\n Copyright (c) 2008 Seneca College\r\n Licenced under the MIT License (http://www.math.org/index.php/mit-license/)\r\n */\n\n// Written By:      Mark Paruzel\n// Date:            March 23, 2008\n// Project:         Canvas 3D Library\n// -----------------------------------------------------------------------------\n// NOTE: This group of functions act upon an array of three values which\n//       represent a vector in 3D space. The values of the array each hold the\n//       values of the X, Y, and Z coordinates on each axis.\n// -----------------------------------------------------------------------------\n/**\r\n Check to see if vector 'vecArr' is valid.  That is, if it\r\n has the correct amount of components, is the right type and has\r\n the correct types.\r\n\r\n @param {Array} vecArr The vector to check.\r\n\r\n @return {boolean} True if the 'vecArr' is valid, false otherwise.\r\n */\nmath.isValidVector = function (vecArr) {\n    // Check if the value being passed is an array\n    if (vecArr instanceof Array || vecArr instanceof T3D_FLOAT_ARRAY) {\n        // Need to allow 4D vectors since last element of\n        // vector may not always be 1, and we can't assume\n        // user wants w = 1.\n        if (vecArr.length == 3 || vecArr.length == 4) {\n            for (var i = 0, len = vecArr.length; i < len; i++) {\n                // Check for bad values\n                if (isNaN(vecArr[i])) return false;\n            }\n\n            return true;\n        }\n    }\n\n    return false;\n};\n\n/**\r\n Copy the Vector 'srcVec' and return it.\r\n\r\n @param {Array} srcVec The vector to copy.\r\n\r\n @returns {Array} A copy of the 'srcVec' vector.\r\n */\nmath.copyVector = function (srcVec, dest) {\n    if (dest == undefined) {\n        return V3.clone(srcVec);\n    }\n    dest[0] = srcVec[0];\n    dest[1] = srcVec[1];\n    dest[2] = srcVec[2];\n};\n\n/**\r\n Copy the components of srcVec Vector to destVec Vector.\r\n\r\n @param {Array} srcVec The source Vector to copy from.\r\n @param {Array} destVec The destination Vector to copy to.\r\n */\nmath.copyVectorContents = function (srcVec, destVec) {\n    destVec = V3.clone(srcVec);\n};\n\nmath.addVectorComponent = function (srcVec, newComponent) {\n    var newVec = new T3D_FLOAT_ARRAY(4);\n    newVec[0] = srcVec[0];\n    newVec[1] = srcVec[1];\n    newVec[2] = srcVec[2];\n    newVec[3] = newComponent;\n    return newVec;\n};\n/**\r\n Create a 3D Vector from the given 'newX', 'newY'\r\n and 'newZ' arguments.\r\n\r\n @param {float} newX The x value.\r\n @param {float} newY The y value.\r\n @param {float} newZ The z value.\r\n\r\n @returns {Array} A 3D Vector with the components specified by the\r\n three arguments.\r\n */\nmath.makeVector = function (newX, newY, newZ) {\n    return new T3D_FLOAT_ARRAY([!isNaN(newX) ? parseFloat(newX) : 0.0, !isNaN(newY) ? parseFloat(newY) : 0.0, !isNaN(newZ) ? parseFloat(newZ) : 0.0]);\n};\n\n/**\r\n Normalize the given Vector. A normalized Vector points in the same direction\r\n as the original, yet has a length of 1.\r\n\r\n @param {Array} vec The Vector to normalize.\r\n\r\n @returns {Array} The normalized Vector if the argument is a Vector\r\n object, otherwise returns nulls.\r\n */\nmath.normalizeVector = function (vec) {\n    var compr, ln;\n    if (vec.length === 4) {\n        compr = vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2];\n        // Sometimes this can become invalid\n        ln = Math.sqrt(compr);\n        // If the length is greater then zero, return the normalized Vector\n        // Normalization\n        vec[0] = vec[0] != 0.0 ? vec[0] / ln : 0.0;\n        vec[1] = vec[1] != 0.0 ? vec[1] / ln : 0.0;\n        vec[2] = vec[2] != 0.0 ? vec[2] / ln : 0.0;\n        vec[3] = vec[3] != 0.0 ? vec[2] / ln : 0.0;\n        return vec;\n    }\n    compr = vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2];\n    // Sometimes this can become invalid\n    ln = Math.sqrt(compr);\n    // If the length is greater then zero, return the normalized Vector\n    // Normalization\n    vec[0] = vec[0] != 0.0 ? vec[0] / ln : 0.0;\n    vec[1] = vec[1] != 0.0 ? vec[1] / ln : 0.0;\n    vec[2] = vec[2] != 0.0 ? vec[2] / ln : 0.0;\n    return vec;\n};\n\n/**\r\n Get the dot product of two vectors.\r\n\r\n @param {Array} vecOne The first vector.\r\n @param {Array} vecTwo The second vector.\r\n\r\n @returns {float} The dot product of the two specified Vectors. If\r\n one of the Vectors was invalid, returns null.\r\n */\nmath.vectorDotProduct = function (vecOne, vecTwo, dest) {\n    return V3.dot(vecOne, vecTwo, dest);\n};\n\n/**\r\n Get the result of projecting vector 'vecOne' onto 'vecTwo'.\r\n\r\n @param {Array} vecOne\r\n @param {Array} vecTwo\r\n\r\n @returns {Array} result of projecting vector 'vecOne' onto 'vecTwo'.\r\n */\nmath.vectorProject = function (vecOne, vecTwo) {\n    //           vecOne . vecTwo\n    // result =  ---------------- x vecTwo\n    //           vecTwo . vecTwo\n    // get the top and bottom dot product\n    var topDot = V3.dot(vecOne, vecTwo);\n    var bottomDot = V3.dot(vecTwo, vecTwo);\n\n    return math.multiplyVector(vecTwo, topDot / bottomDot);\n};\n\n/**\r\n Get the cross product of two Vectors.  The cross product is a Vector which\r\n is perpendicular to both the first and second vector.\r\n\r\n @param {Array} vecOne The first vector.\r\n @param {Array} vecTwo The second vector.\r\n\r\n @returns {Array} The cross product of 'vecOne' and 'vecTwo'.\r\n */\nmath.vectorCrossProduct = function (vecOne, vecTwo, dest) {\n    return V3.cross(vecOne, vecTwo, dest);\n};\n\n/**\r\n Get the length of the vector 'vec'.\r\n\r\n @param {Array} vec The vector for which the length is needed.\r\n\r\n @return {float} The length of the vector 'vec'.\r\n */\nmath.vectorLength = function (vec) {\n    return V3.length(vec);\n};\n\n/**\r\n Get the squared length of the vector 'vec'.\r\n\r\n @param {Array} vec The vector for which the squared length is required.\r\n\r\n @returns {float} The 'length' of each component of 'vec' added together.\r\n */\nmath.vectorLengthSq = function (vec) {\n    return V3.lengthSquared(vec);\n};\n\n/**\r\n Add two Vectors together and place the result in dest and\r\n return it.\r\n\r\n @param {Array} vecOne The first Vector.\r\n @param {Array} vecTwo The second Vector.\r\n @param {Array} [dest] A vector which will hold the result.\r\n\r\n @returns {Array} The resultant Vector if both were valid\r\n Vectors, otherwise returns null.\r\n */\nmath.addVectors = function (vecOne, vecTwo, dest) {\n    return V3.add(vecOne, vecTwo, dest);\n};\n\n/**\r\n Subtract vector 'vecTwo' from vector 'vecOne'.\r\n\r\n @param {Array} vecOne The Vector to subtract from.\r\n @param {Array} vecTwo The Vector which is used to subtract.\r\n @param {Array} [dest] The Vector which will contains the resultant.\r\n\r\n @returns {Array} The resultant Vector, which is the first vector\r\n minus the second. If one of the vector were not valid, returns null.\r\n */\nmath.subtractVectors = function (vecOne, vecTwo, dest) {\n    if (vecOne.isVector3) {\n        vecOne = [vecOne.x, vecOne.y, vecOne.z];\n    }\n    if (vecTwo.isVector3) {\n        vecTwo = [vecTwo.x, vecTwo.y, vecTwo.z];\n    }\n    return V3.sub(vecOne, vecTwo, dest);\n};\n\n/**\r\n Multiply the specified vector by the scalar.  Place the result\r\n in 'dest' and return it.  This operation will multiply the scalar\r\n by each component of the vector, effectively scaling it, making it\r\n geometrically longer or shorter.  If the scalar value is negative,\r\n the result will point in the opposite direction of 'vec'.\r\n\r\n @param {Array} vec The vector to scale.\r\n @param {float} scalar The amount to scale the vector.\r\n @param {Array} [dest] A vector which will hold\r\n the result if provided.\r\n\r\n @returns {Array} A vector 'vec' which has been scaled by 'scalar' or\r\n returns null if 'vec' was invalid or 'scalar' was not a number.\r\n */\nmath.multiplyVector = function (vec, scalar, dest) {\n    return V3.scale(vec, scalar, dest);\n};\n\n/**\r\n Divide each component of 'vec' and store into dest and return it.\r\n\r\n @param {Array} vec The vector to divide.\r\n @param {float} scalar The amount to scale 'vec'.\r\n @param {Array} [dest] A vector which will hold\r\n the result if provided.\r\n\r\n @returns {Array} A vector 'vec' which has been divided by 'scalar' or\r\n returns null if 'vec' was invalid or 'scalar' was NaN.\r\n */\nmath.divideVector = function (vec, scalar, dest) {\n    if (dest == undefined) {\n        dest = new T3D_FLOAT_ARRAY(3);\n    }\n    dest[0] = vec[0] / scalar;\n    dest[1] = vec[1] / scalar;\n    dest[2] = vec[2] / scalar;\n\n    return dest;\n};\n\n/**\r\n Multiply two Vectors together, this is not a dot product or a cross\r\n product operation.  Instead, each corresponding component of each of\r\n the vectors are multiplied together\r\n\r\n @param {Array} vecOne Vector one.\r\n @param {Array} vecTwo Vector two.\r\n @param {Array} [dest] The destination will contain the result of\r\n the operation.\r\n\r\n @returns {Array} A Vector which is the result of multiplying each\r\n component together or null if one of the vectors where not valid\r\n Vectors.\r\n */\nmath.multiplyVectorByVector = function (vecOne, vecTwo, dest) {\n    if (dest == undefined) {\n        dest = new T3D_FLOAT_ARRAY(3);\n    }\n    dest[0] = vecOne[0] * vecTwo[0];\n    dest[1] = vecOne[1] * vecTwo[1];\n    dest[2] = vecOne[2] * vecTwo[2];\n    return dest;\n};\nmath.divideVectorByVector = function (vecOne, vecTwo, dest) {\n    if (dest == undefined) {\n        dest = new T3D_FLOAT_ARRAY(3);\n    }\n    dest[0] = vecOne[0] / vecTwo[0];\n    dest[1] = vecOne[1] / vecTwo[1];\n    dest[2] = vecOne[2] / vecTwo[2];\n    return dest;\n};\n\n/**\r\n Compare two vectors for equality. Two Vectors are said to be equal\r\n if all their components are equal.\r\n\r\n @param {Array} vecOne Vector one.\r\n @param {Array} vectwo Vector two.\r\n\r\n @return {boolean} True if both vectors are equal, null otherwise.\r\n */\nmath.isVectorEqual = function (vecOne, vecTwo) {\n    // add tolerance to calculations\n    return vecOne[0] === vecTwo[0] && vecOne[1] === vecTwo[1] && vecOne[2] === vecTwo[2];\n};\n\n/**\r\n Check to see if a Vector is a zero vector, that is a vector with a\r\n length of zero, or it has components close enough to zero to be\r\n considered zero.  'Close enough' is considered true if the components\r\n lie between the -TOLERANCE and +TOLERANCE constant.\r\n\r\n @param {Array} vec The Vector to check.\r\n\r\n @return {boolean} True if the vector is considered a zero vector, false otherwise.\r\n */\nmath.isVectorZero = function (vec) {\n    // Check for a tolerance\n    return -math.TOLERANCE < vec[0] && vec[0] < math.TOLERANCE && -math.TOLERANCE < vec[1] && vec[1] < math.TOLERANCE && -math.TOLERANCE < vec[2] && vec[2] < math.TOLERANCE;\n};\n\n/**\r\n Get the angle (in degrees) between two vectors.\r\n\r\n @param {Array} vecOne The first vector.\r\n @param {Array} vecTwo The second vector.\r\n\r\n @return {float} The angle in degrees between the two vectors.\r\n */\nmath.getAngleBetweenVectors = function (vecOne, vecTwo) {\n    var dot = math.vectorDotProduct(vecOne, vecTwo);\n    //force dot into acceptable range.\n    if (dot > 1 && dot < 1 + math.TOLERANCE) {\n        dot = 1;\n    } else if (dot < -1 && dot > -1 - math.TOLERANCE) {\n        dot = -1;\n    }\n    return math.radiansToDegrees(Math.acos(dot));\n};\n/*\r\n Copyright (c) 2008 Seneca College\r\n Licenced under the MIT License (http://www.math.org/index.php/mit-license/)\r\n */\n// Written By:  Mark Paruzel\n// Date:        April 20, 2008\n// Project:     Canvas 3D Library\n// -----------------------------------------------------------------------------\n// NOTE: This group of functions act uppon an array of four values which\n//       represent a Quaternion in 3D space. The values of the array each hold\n//       the values of the W, X, Y, and Z values of a quaternion.\n// -----------------------------------------------------------------------------\n/**\r\n Is the object 'quat' a valid Quaternion?\r\n\r\n @param {Array} quat\r\n\r\n @returns {boolean} True if 'quat' is a valid Quaternion, false\r\n otherwise.\r\n */\nmath.isValidQuat = function (quat) {\n    // All math types are arrays instead of objects for performance reasons.\n    if (quat instanceof Array || quat instanceof T3D_FLOAT_ARRAY) {\n        // Must be 4 values long\n        if (quat.length == 4) {\n            for (var i = 0; i < 4; i++) {\n                // Check for bad values\n                if (isNaN(quat[i])) return false;\n            }\n\n            return true;\n        }\n    }\n\n    // if not instance of an Array\n    return false;\n};\n\n/**\r\n Make a Quaternion from the arguments.\r\n\r\n @param {float} newX\r\n @param {float} newY\r\n @param {float} newZ\r\n @param {float} newW\r\n\r\n @returns {Array} A Quaternion defined by the passed\r\n in arguments.\r\n */\nmath.makeQuat = function (newX, newY, newZ, newW) {\n    // Quat = W + X * i + Y * j + Z * k\n    var quat = new T3D_FLOAT_ARRAY(4);\n\n    quat[3] = !isNaN(newW) ? parseFloat(newW) : 0.0; // W\n    quat[0] = !isNaN(newX) ? parseFloat(newX) : 0.0; // X\n    quat[1] = !isNaN(newY) ? parseFloat(newY) : 0.0; // Y\n    quat[2] = !isNaN(newZ) ? parseFloat(newZ) : 0.0; // Z\n    return quat;\n};\n\n/**\r\n Convert a Quaternion to a Matrix.\r\n\r\n @param {Array} quat\r\n @param {Array} dest\r\n\r\n @returns {Array} A matrix\r\n */\nmath.quatToMatrix = function (quat, dest) {\n    var quatToMatrixTx = 2.0 * quat[0];\n    var quatToMatrixTy = 2.0 * quat[1];\n    var quatToMatrixTz = 2.0 * quat[2];\n    var quatToMatrixTwx = quatToMatrixTx * quat[3];\n    var quatToMatrixTwy = quatToMatrixTy * quat[3];\n    var quatToMatrixTwz = quatToMatrixTz * quat[3];\n    var quatToMatrixTxx = quatToMatrixTx * quat[0];\n    var quatToMatrixTxy = quatToMatrixTy * quat[0];\n    var quatToMatrixTxz = quatToMatrixTz * quat[0];\n    var quatToMatrixTyy = quatToMatrixTy * quat[1];\n    var quatToMatrixTyz = quatToMatrixTz * quat[1];\n    var quatToMatrixTzz = quatToMatrixTz * quat[2];\n\n    if (dest) {\n        dest[0] = 1.0 - (quatToMatrixTyy + quatToMatrixTzz);\n        dest[1] = quatToMatrixTxy - quatToMatrixTwz;\n        dest[2] = quatToMatrixTxz + quatToMatrixTwy;\n        dest[3] = 0.0;\n        dest[4] = quatToMatrixTxy + quatToMatrixTwz;\n        dest[5] = 1.0 - (quatToMatrixTxx + quatToMatrixTzz);\n        dest[6] = quatToMatrixTyz - quatToMatrixTwx;\n        dest[7] = 0.0;\n        dest[8] = quatToMatrixTxz - quatToMatrixTwy;\n        dest[9] = quatToMatrixTyz + quatToMatrixTwx;\n        dest[10] = 1.0 - (quatToMatrixTxx + quatToMatrixTyy);\n        dest[11] = 0.0;\n        dest[12] = 0.0;\n        dest[13] = 0.0;\n        dest[14] = 0.0;\n        dest[15] = 1.0;\n\n        return dest;\n    }\n    // Setup a new Matrix out of this quaternion\n    var newMat = new T3D_FLOAT_ARRAY(16);\n\n    newMat[0] = 1.0 - (quatToMatrixTyy + quatToMatrixTzz);\n    newMat[1] = quatToMatrixTxy + quatToMatrixTwz;\n    newMat[2] = quatToMatrixTxz - quatToMatrixTwy;\n    newMat[3] = 0.0;\n\n    newMat[4] = quatToMatrixTxy - quatToMatrixTwz;\n    newMat[5] = 1.0 - (quatToMatrixTxx + quatToMatrixTzz);\n    newMat[6] = quatToMatrixTyz + quatToMatrixTwx;\n    newMat[7] = 0.0;\n\n    newMat[8] = quatToMatrixTxz + quatToMatrixTwy;\n    newMat[9] = quatToMatrixTyz - quatToMatrixTwx;\n    newMat[10] = 1.0 - (quatToMatrixTxx + quatToMatrixTyy);\n    newMat[11] = 0.0;\n\n    newMat[12] = 0.0;\n    newMat[13] = 0.0;\n    newMat[14] = 0.0;\n    newMat[15] = 1.0;\n    return newMat;\n};\n\n/**\r\n * TODO 被base_ex中覆盖了\r\n * @param {Array} axisVec\r\n * @param {float} angleScalar\r\n */\n// math.quatToAxisAngle = function (axisVec, angleScalar) {\n//   axisVec = makeVector();\n//\n//   // Get the Length squared\n//   var sqLength = math.quatLengthSq();\n//\n//   // If length is very small, its basically touching a world Axis\n//   if (sqLength > math.TOLERANCE) {\n//     var invLength = math.invSqrt(sqLength);\n//\n//     // Set the Angle\n//     angleScalar = 2.0 * Math.acos(quat[3]);\n//\n//     // Set the Vector\n//     axisVec[0] = quat[0] * invLength;\n//     axisVec[1] = quat[1] * invLength;\n//     axisVec[2] = quat[2] * invLength;\n//   } else {\n//     // Set world Axis\n//     angleScalar = 0.0;\n//     axisVec = math.makeVector(1.0, 0.0, 0.0);\n//   }\n// };\n\n/**\r\n Convert an axis-angle vector to a Quaternion.\r\n\r\n @param {Array} axisVec\r\n @param {float} angleScalar\r\n @param {Array} dest\r\n\r\n @returns {Array}\r\n\r\n */\nmath.axisAngleToQuathalfAngle = null;\nmath.axisAngleToQuats = null;\nmath.axisAngleToQuat = function (axisVec, angleScalar, dest) {\n    // q = cos(A/2) + sin(A/2) * (x*i + y*j + z*k)\n    math.axisAngleToQuathalfAngle = 0.5 * angleScalar;\n    math.axisAngleToQuats = Math.sin(math.axisAngleToQuathalfAngle);\n\n    if (dest) {\n        dest[3] = Math.cos(math.axisAngleToQuathalfAngle);\n        dest[0] = math.axisAngleToQuats * axisVec[0];\n        dest[1] = math.axisAngleToQuats * axisVec[1];\n        dest[2] = math.axisAngleToQuats * axisVec[2];\n        return dest;\n    }\n    var quat = math.makeQuat(math.axisAngleToQuats * axisVec[0], math.axisAngleToQuats * axisVec[1], math.axisAngleToQuats * axisVec[2], Math.cos(math.axisAngleToQuathalfAngle));\n    return quat;\n};\n\n/**\r\n Convert a Matrix to a Quaternion.\r\n\r\n @param {Array} newMat\r\n\r\n @returns {Array}\r\n */\nmath.matrixToQuat = function (newMat) {\n    var quat = math.makeQuat();\n    var trace = newMat[0] + newMat[5] + newMat[10] + 1;\n    var sqTrace;\n    var s;\n    if (trace > 0.0) {\n        sqTrace = Math.sqrt(trace);\n        s = 0.5 / sqTrace;\n        quat[3] = 0.25 / s;\n        quat[0] = (newMat[6] - newMat[9]) * s;\n        quat[1] = (newMat[8] - newMat[2]) * s;\n        quat[2] = (newMat[1] - newMat[4]) * s;\n    } else {\n        if (newMat[0] > newMat[5] && newMat[0] > newMat[10]) {\n            s = 2.0 * Math.sqrt(1.0 + newMat[0] - newMat[5] - newMat[10]);\n            quat[0] = 0.25 * s;\n            quat[1] = (newMat[1] - newMat[4]) / s;\n            quat[2] = (newMat[2] - newMat[8]) / s;\n            quat[3] = (newMat[9] - newMat[6]) / s;\n        } else if (newMat[5] > newMat[10]) {\n            s = 2.0 * Math.sqrt(1.0 + newMat[5] - newMat[0] - newMat[10]);\n            quat[0] = (newMat[1] - newMat[4]) / s;\n            quat[1] = 0.25 * s;\n            quat[2] = (newMat[9] - newMat[6]) / s;\n            quat[3] = (newMat[2] - newMat[8]) / s;\n        } else {\n            s = 2.0 * Math.sqrt(1.0 + newMat[10] - newMat[0] - newMat[5]);\n            quat[0] = (newMat[2] - newMat[8]) / s;\n            quat[1] = (newMat[9] - newMat[6]) / s;\n            quat[2] = 0.25 * s;\n            quat[3] = (newMat[1] - newMat[4]) / s;\n        }\n    }\n\n    return quat;\n};\n\n/**\r\n @param {Array} quat\r\n\r\n @returns {float}\r\n */\nmath.quatLengthSq = function (quat) {\n    return quat[0] * quat[0] + quat[1] * quat[1] + quat[2] * quat[2];\n};\n\n/**\r\n Get the length of Quaternion 'quat'.\r\n\r\n @param {Array} quat\r\n\r\n @returns {float} The length 'quat' or null if 'quat' was not a\r\n valid Quaternion.\r\n */\nmath.quatLength = function (quat) {\n    return Math.sqrt(math.quatLengthSq(quat));\n};\n\n/**\r\n Add two quaternions.\r\n\r\n @param {Array} quatOne\r\n @param {Array} quatTwo\r\n\r\n @returns {Array} The result of adding quatOne and quatTwo.\r\n */\nmath.addQuats = function (quatOne, quatTwo) {\n    var quat = math.makeQuat();\n    for (var i = 0; i < 4; i++) {\n        quat[i] = quatOne[i] + quatTwo[i];\n    }\n    return quat;\n};\n\n/**\r\n Subtract Quaternion 'quatTwo' from 'quatOne'.\r\n\r\n @param {Array} quatOne\r\n @param {Array} quatTwo\r\n\r\n @returns {Array}\r\n */\nmath.subtractQuats = function (quatOne, quatTwo) {\n    var quat = math.makeQuat();\n    for (var i = 0; i < 4; i++) {\n        quat[i] = quatOne[i] - quatTwo[i];\n    }\n    return quat;\n};\n\n/**\r\n Multiply the Quaternion 'quatOne' with a scalar.\r\n\r\n @param {Array} quatOne\r\n @param {float} scalar\r\n\r\n @return {Array}\r\n */\nmath.multiplyQuatByScalar = function (quatOne, scalar) {\n    var quat = math.makeQuat();\n    for (var i = 0; i < 4; i++) {\n        quat[i] = quatOne[i] * scalar; //!! Mark: is this supposed to be a multiply?\n    }\n    return quat;\n};\n\n/**\r\n Get the conjugate of Quaternion 'quat'.\r\n\r\n @param {Array} quat\r\n\r\n return {Array}\r\n */\nmath.getQuatConjugate = function (quat) {\n    var nQt = math.makeQuat();\n    nQt[3] = quat[3];\n    nQt[0] = -quat[0];\n    nQt[1] = -quat[1];\n    nQt[2] = -quat[2];\n    return nQt;\n};\n\n/**\r\n Dot Product\r\n\r\n @param {Array} quatOne\r\n @param {Array} quatTwo\r\n\r\n @returns {float}\r\n */\nmath.quatDotProduct = function (quatOne, quatTwo) {\n    return quatOne[0] * quatTwo[0] + quatOne[1] * quatTwo[1] + quatOne[2] * quatTwo[2] + quatOne[3] * quatTwo[3];\n};\n\n/**\r\n Get the normalized Quaternion of quat.\r\n\r\n @param {Array} quat\r\n\r\n @return {Array}\r\n larrow use o3d's normalizeQuat\r\n math.normalizeQuat = function (quat)\r\n {\r\n  var newQuat = math.makeQuat();\r\n  var len = math.quatLength(quat);\r\n  var invLen = 1.0 / len;\r\n  if (len > 0.001)\r\n  {\r\n    newQuat[0] = quat[0] * invLen;\r\n    newQuat[1] = quat[1] * invLen;\r\n    newQuat[2] = quat[2] * invLen;\r\n    newQuat[3] = quat[3] * invLen;\r\n  }\r\n  else\r\n  {\r\n    // If Normalization Cannot be done\r\n    newQuat[0] = 0.0;\r\n    newQuat[1] = 0.0;\r\n    newQuat[2] = 0.0;\r\n    newQuat[3] = 0.0;\r\n  }\r\n  return newQuat;\r\n}\r\n */\n\n/**\r\n Get the inverse of the Quaternion quat.\r\n\r\n @param {Array} quat\r\n\r\n @return {Array}\r\n */\nmath.inverseQuat = function (quat) {\n    var invQuat = math.makeQuat();\n    var norm = 0.0;\n    for (var i = 0; i < 4; i++) {\n        norm += quat[i] * quat[i];\n    }\n    if (norm > 0.0) {\n        var invNorm = 1.0 / norm;\n        invQuat[3] = quat[3] * invNorm;\n        invQuat[0] = -quat[0] * invNorm;\n        invQuat[1] = -quat[1] * invNorm;\n        invQuat[2] = -quat[2] * invNorm;\n    }\n    return invQuat;\n};\n/*\r\n Copyright (c) 2008 Seneca College\r\n Licenced under the MIT License (http://www.math.org/index.php/mit-license/)\r\n */\n// Written By:  Mark Paruzel\n// Date:        April 11, 2008\n// Project:     Canvas 3D Library\n// -----------------------------------------------------------------------------\n// NOTE: This group of functions act upon an array of sixteen values which\n//       represent a matrix orientation. How a Matrix Works:\n//\n//       - An Orientation uses the 3 Axis in a 3D world: Up, Forward and Left\n//         (Right handed system).\n//       - A 4x4 Matrix adds in a Translation into the matrix along with an\n//         Orientation.\n//\n//          Matrix uses column-major order which means elements are listed column\n//          first\n//\n//       +-                             -+\n//       |  Right.x, Up.x, Fwd.x, Pos.x  |\n//       |  Right.y, Up.y, Fwd.y, Pos.y  |\n//       |  Right.z, Up.z, Fwd.z, Pos.z  |\n//       |  0.0,     0.0,  0.0,   1.0    |\n//       +-                             -+\n//\n//       Array Indices:\n//       +-               -+\n//       |  0,  4,  8, 11  |\n//       |  1,  5,  6, 12  |\n//       |  2,  6,  9, 13  |\n//       |  3,  7, 10, 15  |\n//       +-               -+\n// -----------------------------------------------------------------------------\n/**\r\n Is the Matrix 'mat' is valid?  That is, does it contain 16\r\n values and are all the values numbers?\r\n\r\n @param {Array} mat The matrix to check.\r\n\r\n @returns {boolean} True if the object 'mat' is a matrix,\r\n false otherwise.\r\n */\nmath.isValidMatrix = function (mat) {\n    // Check if the value being passed is an array\n    if (mat instanceof Array || mat instanceof MJS_FLOAT_ARRAY_TYPE) {\n        // Must be array of 16 Values\n        if (mat.length == 16) {\n            for (var i = 0; i < 16; i++) {\n                // Check for bad values\n                if (isNaN(mat[i])) return false;\n            }\n\n            return true;\n        }\n    }\n\n    return false;\n};\n\n/**\r\n Create an identity matrix. An identity matrix is a matrix in\r\n which all the elements are zero, save on the main diagonal\r\n where all elements are ones.<br />\r\n <br />\r\n Example:\r\n <pre>\r\n +-            -+\r\n |  1, 0, 0, 0  |\r\n |  0, 1, 0, 0  |\r\n |  0, 0, 1, 0  |\r\n |  0, 0, 0, 1  |\r\n +-            -+\r\n </pre>\r\n\r\n An identity matrix is equivalent to the number one in some respects,\r\n that is multiplying matrix M by an identity matrix will yield M.\r\n Matrix multiplication with an identity matrix is one case in which\r\n matrix multiplication is commutative.\r\n M * I = M\r\n I * M = M\r\n <br />\r\n\r\n @returns {Array} An identity matrix.\r\n */\nmath.makeIdentityMatrix = function () {\n    return new T3D_FLOAT_ARRAY([1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]);\n};\n\n/**\r\n Create a Zero matrix, that is a matrix in which each component\r\n of the matrix is zero.\r\n\r\n @returns {Array} A zero matrix.\r\n */\nmath.makeZeroMatrix = function () {\n    return new T3D_FLOAT_ARRAY([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]);\n};\n\n/**\r\n Set the elements of a matrix.  Supply the values in column-major\r\n ordering.\r\n\r\n e[r][c], e01 = row 0, column 1\r\n\r\n @param {Array} mat The matrix to set\r\n @param {float} e00 Column 0, Row 0\r\n @param {float} e01\r\n @param {float} e02\r\n @param {float} e03\r\n @param {float} e10 Column 1, Row 0\r\n @param {float} e11\r\n @param {float} e12\r\n @param {float} e13\r\n @param {float} e20 Column 2, Row 0\r\n @param {float} e21\r\n @param {float} e22\r\n @param {float} e23\r\n @param {float} e30 Column 3, Row 0\r\n @param {float} e31\r\n @param {float} e32\r\n @param {float} e33\r\n */\nmath.setMatrix = function (mat, e00, e01, e02, e03, e10, e11, e12, e13, e20, e21, e22, e23, e30, e31, e32, e33) {\n    mat[0] = e00;\n    mat[1] = e01;\n    mat[2] = e02;\n    mat[3] = e03;\n\n    mat[4] = e10;\n    mat[5] = e11;\n    mat[6] = e12;\n    mat[7] = e13;\n\n    mat[8] = e20;\n    mat[9] = e21;\n    mat[10] = e22;\n    mat[11] = e23;\n\n    mat[12] = e30;\n    mat[13] = e31;\n    mat[14] = e32;\n    mat[15] = e33;\n};\n\n/**\r\n Make a matrix by providing each component. Supply the values in colum-major order.<br />\r\n Indices:\r\n <pre>\r\n +-               -+\r\n |  0,  4,  8, 12  |\r\n |  1,  5,  9, 13  |\r\n |  2,  6, 10, 14  |\r\n |  3,  7, 11, 15  |\r\n +-               -+\r\n </pre>\r\n\r\n @param {float} e00 Element at row 0 column 0.\r\n @param {float} e01 Element at row 1 column 0.\r\n @param {float} e02 Element at row 2 column 0.\r\n @param {float} e03 Element at row 3 column 0.\r\n @param {float} e10 Element at row 0 column 1.\r\n @param {float} e11 Element at row 1 column 1.\r\n @param {float} e12 Element at row 2 column 1.\r\n @param {float} e13 Element at row 3 column 1.\r\n @param {float} e20 Element at row 0 column 2.\r\n @param {float} e21 Element at row 1 column 2.\r\n @param {float} e22 Element at row 2 column 2.\r\n @param {float} e23 Element at row 3 column 2.\r\n @param {float} e30 Element at row 0 column 3.\r\n @param {float} e31 Element at row 1 column 3.\r\n @param {float} e32 Element at row 2 column 3.\r\n @param {float} e33 Element at row 3 column 3.\r\n\r\n @return {Array} A matrix defined by the provided arguments.\r\n */\nmath.makeMatrix = function (e00, e01, e02, e03, e10, e11, e12, e13, e20, e21, e22, e23, e30, e31, e32, e33) {\n    return [!isNaN(e00) ? parseFloat(e00) : 0.0, !isNaN(e01) ? parseFloat(e01) : 0.0, !isNaN(e02) ? parseFloat(e02) : 0.0, !isNaN(e03) ? parseFloat(e03) : 0.0, !isNaN(e10) ? parseFloat(e10) : 0.0, !isNaN(e11) ? parseFloat(e11) : 0.0, !isNaN(e12) ? parseFloat(e12) : 0.0, !isNaN(e13) ? parseFloat(e13) : 0.0, !isNaN(e20) ? parseFloat(e20) : 0.0, !isNaN(e21) ? parseFloat(e21) : 0.0, !isNaN(e22) ? parseFloat(e22) : 0.0, !isNaN(e23) ? parseFloat(e23) : 0.0, !isNaN(e30) ? parseFloat(e30) : 0.0, !isNaN(e31) ? parseFloat(e31) : 0.0, !isNaN(e32) ? parseFloat(e32) : 0.0, !isNaN(e33) ? parseFloat(e33) : 0.0];\n};\n\n/**\r\n Check if two matrices are equal. Assumes for performance reasons\r\n that the matrices passed in are valid. Two matrices are equal if\r\n they're corresponding components are equal or their difference is\r\n less than TOLERANCE. This tolerance is simply a small number used\r\n as a buffer due to floating point inaccuracies.\r\n\r\n @param {Array} matrix1 The first matrix.\r\n @param {Array} matrix2 The second matrix.\r\n\r\n @return {boolean} True if matrices are equal, false otherwise.\r\n */\nmath.matricesEqual = function (matrix1, matrix2) {\n    var areEqual = true;\n\n    // stop as soon as we find an element that is not equal\n    for (var i = 0; areEqual && i < 16; i++) {\n        // if it goes beyond the threshold or tolerance, we can stop\n        if (Math.abs(matrix1[i] - matrix2[i]) > math.TOLERANCE) {\n            areEqual = false;\n        }\n    }\n\n    return areEqual;\n};\n\n/**\r\n */\nmath.makePoseMatrix = function (vecLeft, vecUp, vecFrwd, vecPos) {\n    // +-                            -+\n    // |  Left.x, Up.y, Dir.x, Pos.x  |\n    // |  Left.y, Up.x, Dir.y, Pos.y  |\n    // |  Left.z, Up.z, Dir.z, Pos.z  |\n    // |  0.0,    0.0,    0.0,  1.0   |\n    // +-                            -+\n    var mat = new T3D_FLOAT_ARRAY(16);\n    // Left\n    mat[0] = vecLeft[0];\n    mat[1] = vecLeft[1];\n    mat[2] = vecLeft[2];\n    mat[3] = 0.0;\n\n    // Up\n    mat[4] = vecUp[0];\n    mat[5] = vecUp[1];\n    mat[6] = vecUp[2];\n    mat[7] = 0.0;\n\n    // Forward\n    mat[8] = vecFrwd[0];\n    mat[9] = vecFrwd[1];\n    mat[10] = vecFrwd[2];\n    mat[11] = 0.0;\n\n    // Position\n    mat[12] = vecPos[0];\n    mat[13] = vecPos[1];\n    mat[14] = vecPos[2];\n    mat[15] = 1.0;\n\n    return mat;\n};\n\n/**\r\n Get the transpose of matrix 'mat'.  A transposed matrix is created\r\n by interchanging the rows and columns of a matrix.\r\n\r\n Transposing the following matrix,\r\n <pre>\r\n +-            -+\r\n |  A, B, C, D  |\r\n |  E, F, G, H  |\r\n |  I, J, K, L  |\r\n |  M, N, O, P  |\r\n +-            -+\r\n </pre>\r\n\r\n would yield:\r\n <pre>\r\n +-            -+\r\n |  A, E, I, M  |\r\n |  B, F, J, N  |\r\n |  C, G, K, O  |\r\n |  D, H, L, P  |\r\n +-            -+\r\n </pre>\r\n\r\n @param {Array} mat Matrix to transpose.\r\n\r\n @returns {Array} The transposed matrix if the passed in matrix\r\n was valid, otherwise returns null.\r\n */\nmath.transposeMatrix = function (mat, dest) {\n    return M4x4.transpose(mat, dest);\n};\n\n/**\r\n Get the inverse of matrix 'mat'.  Matrix-matrix division is not\r\n defined mathematically, but there is a multiplicative inverse\r\n operation which is useful in solving some matrix equations.\r\n Note that only matrices with a determinant not equal to zero\r\n will have an inverse.  There is no need to check if first if\r\n the matrix has a determinant not equal to zero as this function\r\n does that anyway.\r\n\r\n @param {Array} mat The Matrix for which the inverse is\r\n required.\r\n\r\n @returns {Array} The inverse of matrix 'mat' if it has one\r\n */\nmath.inverseMatrix = function (mat) {\n    if (!mat) {\n        return;\n    }\n    var kInv = new T3D_FLOAT_ARRAY(16); // larrowmath.mat1;\n    var fA0 = mat[0] * mat[5] - mat[1] * mat[4];\n    var fA1 = mat[0] * mat[6] - mat[2] * mat[4];\n    var fA2 = mat[0] * mat[7] - mat[3] * mat[4];\n    var fA3 = mat[1] * mat[6] - mat[2] * mat[5];\n    var fA4 = mat[1] * mat[7] - mat[3] * mat[5];\n    var fA5 = mat[2] * mat[7] - mat[3] * mat[6];\n    var fB0 = mat[8] * mat[13] - mat[9] * mat[12];\n    var fB1 = mat[8] * mat[14] - mat[10] * mat[12];\n    var fB2 = mat[8] * mat[15] - mat[11] * mat[12];\n    var fB3 = mat[9] * mat[14] - mat[10] * mat[13];\n    var fB4 = mat[9] * mat[15] - mat[11] * mat[13];\n    var fB5 = mat[10] * mat[15] - mat[11] * mat[14];\n    // Determinant\n    var fDet = fA0 * fB5 - fA1 * fB4 + fA2 * fB3 + fA3 * fB2 - fA4 * fB1 + fA5 * fB0;\n    // Account for a very small value\n    if (Math.abs(fDet) <= 1e-9) {\n        math.debug.logWarning('inverseMatrix() failed due to bad values');\n        return null;\n    }\n    kInv[0] = +mat[5] * fB5 - mat[6] * fB4 + mat[7] * fB3;\n    kInv[4] = -mat[4] * fB5 + mat[6] * fB2 - mat[7] * fB1;\n    kInv[8] = +mat[4] * fB4 - mat[5] * fB2 + mat[7] * fB0;\n    kInv[12] = -mat[4] * fB3 + mat[5] * fB1 - mat[6] * fB0;\n    kInv[1] = -mat[1] * fB5 + mat[2] * fB4 - mat[3] * fB3;\n    kInv[5] = +mat[0] * fB5 - mat[2] * fB2 + mat[3] * fB1;\n    kInv[9] = -mat[0] * fB4 + mat[1] * fB2 - mat[3] * fB0;\n    kInv[13] = +mat[0] * fB3 - mat[1] * fB1 + mat[2] * fB0;\n    kInv[2] = +mat[13] * fA5 - mat[14] * fA4 + mat[15] * fA3;\n    kInv[6] = -mat[12] * fA5 + mat[14] * fA2 - mat[15] * fA1;\n    kInv[10] = +mat[12] * fA4 - mat[13] * fA2 + mat[15] * fA0;\n    kInv[14] = -mat[12] * fA3 + mat[13] * fA1 - mat[14] * fA0;\n    kInv[3] = -mat[9] * fA5 + mat[10] * fA4 - mat[11] * fA3;\n    kInv[7] = +mat[8] * fA5 - mat[10] * fA2 + mat[11] * fA1;\n    kInv[11] = -mat[8] * fA4 + mat[9] * fA2 - mat[11] * fA0;\n    kInv[15] = +mat[8] * fA3 - mat[9] * fA1 + mat[10] * fA0;\n    // Inverse using Determinant\n    var fInvDet = 1.0 / fDet;\n    kInv[0] *= fInvDet;\n    kInv[1] *= fInvDet;\n    kInv[2] *= fInvDet;\n    kInv[3] *= fInvDet;\n    kInv[4] *= fInvDet;\n    kInv[5] *= fInvDet;\n    kInv[6] *= fInvDet;\n    kInv[7] *= fInvDet;\n    kInv[8] *= fInvDet;\n    kInv[9] *= fInvDet;\n    kInv[10] *= fInvDet;\n    kInv[11] *= fInvDet;\n    kInv[12] *= fInvDet;\n    kInv[13] *= fInvDet;\n    kInv[14] *= fInvDet;\n    kInv[15] *= fInvDet;\n    return kInv;\n};\n\n/**\r\n Get the matrix determinant of 'mat'.\r\n\r\n @param {Array} mat The matrix for which the determinant\r\n is required.\r\n\r\n @returns {float} The matrix determinant of 'mat' or null if\r\n 'mat' is invalid.\r\n */\nmath.matrixDeterminant = function (mat) {\n    var fA0 = mat[0] * mat[5] - mat[1] * mat[4];\n    var fA1 = mat[0] * mat[6] - mat[2] * mat[4];\n    var fA2 = mat[0] * mat[7] - mat[3] * mat[4];\n    var fA3 = mat[1] * mat[6] - mat[2] * mat[5];\n    var fA4 = mat[1] * mat[7] - mat[3] * mat[5];\n    var fA5 = mat[2] * mat[7] - mat[3] * mat[6];\n    var fB0 = mat[8] * mat[13] - mat[9] * mat[12];\n    var fB1 = mat[8] * mat[14] - mat[10] * mat[12];\n    var fB2 = mat[8] * mat[15] - mat[11] * mat[12];\n    var fB3 = mat[9] * mat[14] - mat[10] * mat[13];\n    var fB4 = mat[9] * mat[15] - mat[11] * mat[13];\n    var fB5 = mat[10] * mat[15] - mat[11] * mat[14];\n    // Construct the Determinant\n    var fDet = fA0 * fB5 - fA1 * fB4 + fA2 * fB3 + fA3 * fB2 - fA4 * fB1 + fA5 * fB0;\n    return fDet;\n};\n\n/**\r\n Get the adjoint matrix of matrix 'mat'.\r\n\r\n @param {Array} mat The matrix which the adjoint is required.\r\n\r\n @returns {Array} the adjoint matrix of 'mat' if it was valid, otherwise\r\n returns null.\r\n */\nmath.matrixAdjoint = function (mat) {\n    var fA0 = mat[0] * mat[5] - mat[1] * mat[4];\n    var fA1 = mat[0] * mat[6] - mat[2] * mat[4];\n    var fA2 = mat[0] * mat[7] - mat[3] * mat[4];\n    var fA3 = mat[1] * mat[6] - mat[2] * mat[5];\n    var fA4 = mat[1] * mat[7] - mat[3] * mat[5];\n    var fA5 = mat[2] * mat[7] - mat[3] * mat[6];\n    var fB0 = mat[8] * mat[13] - mat[9] * mat[12];\n    var fB1 = mat[8] * mat[14] - mat[10] * mat[12];\n    var fB2 = mat[8] * mat[15] - mat[11] * mat[12];\n    var fB3 = mat[9] * mat[14] - mat[10] * mat[13];\n    var fB4 = mat[9] * mat[15] - mat[11] * mat[13];\n    var fB5 = mat[10] * mat[15] - mat[11] * mat[14];\n    // Adjoint\n    var k = new T3D_FLOAT_ARRAY([mat[5] * fB5 - mat[6] * fB4 + mat[7] * fB3, -mat[1] * fB5 + mat[2] * fB4 - mat[3] * fB3, mat[13] * fA5 - mat[14] * fA4 + mat[15] * fA3, -mat[9] * fA5 + mat[10] * fA4 - mat[11] * fA3, -mat[4] * fB5 + mat[6] * fB2 - mat[7] * fB1, mat[0] * fB5 - mat[2] * fB2 + mat[3] * fB1, -mat[12] * fA5 + mat[14] * fA2 - mat[15] * fA1, mat[8] * fA5 - mat[10] * fA2 + mat[11] * fA1, mat[4] * fB4 - mat[5] * fB2 + mat[7] * fB0, -mat[0] * fB4 + mat[1] * fB2 - mat[3] * fB0, mat[12] * fA4 - mat[13] * fA2 + mat[15] * fA0, -mat[8] * fA4 + mat[9] * fA2 - mat[11] * fA0, -mat[4] * fB3 + mat[5] * fB1 - mat[6] * fB0, mat[0] * fB3 - mat[1] * fB1 + mat[2] * fB0, -mat[12] * fA3 + mat[13] * fA1 - mat[14] * fA0, mat[8] * fA3 - mat[9] * fA1 + mat[10] * fA0]);\n    return k;\n};\n\n/**\r\n Multiply a given Matrix 'mat' with a scalar value.  This will result\r\n in a matrix which has each component in 'mat' multiplied with 'scalar'.\r\n\r\n @param {Array} mat The matrix to \"scale\".\r\n @param {float} scalar The value which will be multiplied by each\r\n component of 'mat'.\r\n\r\n @returns {Array} The Matrix 'mat', with each component\r\n multiplied by 'scalar'.\r\n */\nmath.multiplyMatrixByScalar = function (mat, scalar, dest) {\n    if (dest == undefined) {\n        dest = new T3D_FLOAT_ARRAY(16);\n    }\n    for (var i = 0; i < 16; i++) {\n        dest[i] = mat[i] * scalar;\n    }\n    return dest;\n};\n\n// -----------------------------------------------------------------------------\n\n/**\r\n Divide a Matrix 'mat' by a scalar value. This will divide each\r\n component of the matrix 'mat' by 'scalar' and reutrn the value.\r\n\r\n @param {Array} mat The matrix which will be divided.\r\n @param {float} scalar The value which the matrix components\r\n will be divided by.\r\n\r\n @returns {Array} The Matrix 'mat' divided by 'scalar'.\r\n */\nmath.divideMatrixByScalar = function (mat, scalar, dest) {\n    if (dest == undefined) {\n        dest = new T3D_FLOAT_ARRAY(16);\n    }\n    // Multiply each variable\n    for (var i = 0; i < 16; i++) {\n        dest[i] = mat[i] / scalar;\n    }\n    return dest;\n};\n\n/**\r\n Multiply matrix 'matOne' by 'matTwo'.\r\n\r\n @param {Array} matOne\r\n @param {Array} matTwo\r\n\r\n @returns {Array} The result of multiplying 'matOne' by 'matTwo'.\r\n */\nmath.multiplyMatrixByMatrix = function (matOne, matTwo, dest) {\n    return M4x4.mul(matOne, matTwo, dest);\n};\n\n/**\r\n Multiply a matrix by a direction vector\r\n\r\n @param {Array} mat\r\n @param {Array} vec\r\n @param {Array} dest\r\n\r\n @returns {Array} vector\r\n */\nmath.multiplyMatrixByDirection = function (mat, vec, dest) {\n    if (dest == undefined) {\n        dest = new T3D_FLOAT_ARRAY(3);\n    }\n    // since we don't need to multiply the translation part, we leave it out.\n    var a = mat[0] * vec[0] + mat[4] * vec[1] + mat[8] * vec[2];\n    var b = mat[1] * vec[0] + mat[5] * vec[1] + mat[9] * vec[2];\n    var c = mat[2] * vec[0] + mat[6] * vec[1] + mat[10] * vec[2];\n    dest[0] = a;\n    dest[1] = b;\n    dest[2] = c;\n    return dest;\n};\n\n/**\r\n Multiply a vector 'vec' by Matrix 'mat'. This results in a vector\r\n which the elements are found by calculatig the dot product of the\r\n column vectors of 'mat' by 'vec'.\r\n\r\n If 'vec' is an array of 3 values, the last component, w will be assumed to be 1. If 'vec'\r\n is an array of 4 values, dest must also be an array of 4 values.\r\n\r\n @param {Array} mat The matrix, an array of 16 values.\r\n\r\n @param {Array} vec Array of 3 or 4 values. If last component, W is not present, W=1 will\r\n be assumed. Also, if the Array has 3 elements, the return value will be 3 elements. If the\r\n array has 4 elements, the return value will have 4 elements.\r\n\r\n @param {Array} dest Optional return by reference.\r\n\r\n @returns {Array} The vector 'vec' multiplied by matrix 'mat' if both\r\n arguments were valid, otherwise returns null.\r\n */\nmath.multiplyMatrixByVector = function (mat, vec, dest) {\n    var len = vec.length;\n    var w = len == 3 ? 1 : vec[3];\n    if (dest == undefined) {\n        dest = new T3D_FLOAT_ARRAY(len);\n    }\n    var a = mat[0] * vec[0] + mat[4] * vec[1] + mat[8] * vec[2] + mat[12] * w;\n    var b = mat[1] * vec[0] + mat[5] * vec[1] + mat[9] * vec[2] + mat[13] * w;\n    var c = mat[2] * vec[0] + mat[6] * vec[1] + mat[10] * vec[2] + mat[14] * w;\n    var d = mat[3] * vec[0] + mat[7] * vec[1] + mat[11] * vec[2] + mat[15] * w;\n    dest[0] = a;\n    dest[1] = b;\n    dest[2] = c;\n    // make sure they passed us a 4 component vector before trying to write to that\n    // element.\n    if (len === 4) {\n        dest[3] = d;\n    }\n    return dest;\n};\n\n/**\r\n Add two matrices.  This will result in a matrix in which each\r\n corresponding component  of each matrix are added together.\r\n\r\n @param {Array} matOne The first matrix.\r\n @param {Array} matTwo The second matrix.\r\n\r\n @returns {Array} A Matrix which is the addition of 'matOne' and\r\n 'matTwo'.\r\n */\nmath.addMatrices = function (matOne, matTwo) {\n    if (dest == undefined) {\n        dest = new T3D_FLOAT_ARRAY(16);\n    }\n    for (var i = 0; i < 16; i++) {\n        // Add each value of the matrix to its counterpart\n        dest[i] = matOne[i] + matTwo[i];\n    }\n    return dest;\n};\n\n/**\r\n Subtract Matrix 'matTwo' from 'matOne'.  This will result in a\r\n matrix in which each component of 'matTwo' is subtracted from\r\n Matrix 'matOne.\r\n\r\n @param {Array} matOne The matrix which is being\r\n subtracted from.\r\n @param {Array} matTwo The matrix which is matOne is being\r\n subtracted from.\r\n\r\n @returns {Array} A matrix which is 'matTwo' subtracted from 'matOne'.\r\n */\nmath.subtractMatrices = function (matOne, matTwo) {\n    if (dest == undefined) {\n        dest = new T3D_FLOAT_ARRAY(16);\n    }\n    for (var i = 0; i < 16; i++) {\n        // Add each value of the matrix to its counterpart\n        dest[i] = matOne[i] - matTwo[i];\n    }\n    return dest;\n};\n\nmath.copyMatrix = function (srcMat, dest) {\n    if (dest == undefined) {\n        return M4x4.clone(srcMat);\n    }\n    dest[0] = srcMat[0];\n    dest[1] = srcMat[1];\n    dest[2] = srcMat[2];\n    dest[3] = srcMat[3];\n    dest[4] = srcMat[4];\n    dest[5] = srcMat[5];\n    dest[6] = srcMat[6];\n    dest[7] = srcMat[7];\n    dest[8] = srcMat[8];\n    dest[9] = srcMat[9];\n    dest[10] = srcMat[10];\n    dest[11] = srcMat[11];\n    dest[12] = srcMat[12];\n    dest[13] = srcMat[13];\n    dest[14] = srcMat[14];\n    dest[15] = srcMat[15];\n};\nmath.emptyMatrix = function (srcMat) {\n    srcMat[0] = 0;\n    srcMat[1] = 0;\n    srcMat[2] = 0;\n    srcMat[3] = 0;\n    srcMat[4] = 0;\n    srcMat[5] = 0;\n    srcMat[6] = 0;\n    srcMat[7] = 0;\n    srcMat[8] = 0;\n    srcMat[9] = 0;\n    srcMat[10] = 0;\n    srcMat[11] = 0;\n    srcMat[12] = 0;\n    srcMat[13] = 0;\n    srcMat[14] = 0;\n    srcMat[15] = 0;\n};\n\nmath.caculateBezier = function (a, b, c, nums) {\n    nums = nums || 50;\n    var p1 = new THREE.Vector3(a[0], a[1], a[2]);\n    var p2 = new THREE.Vector3(b[0], b[1], b[2]);\n    var p3 = new THREE.Vector3(c[0], c[1], c[2]);\n    var curve = new THREE.QuadraticBezierCurve3(p1, p2, p3);\n    var points = curve.getPoints(nums);\n    var res = [];\n    points.map(function (v) {\n        res.push([v.x, v.y, v.z]);\n    });\n    return res;\n};\n\nmath.getInverseMat4x4 = function (mat) {\n    var mm = new THREE.Matrix4();\n    return mm.getInverse(mat);\n};\n\n//new added\n// Convert alpha beta rotation to direction.\n// @param {number} alpha 垂直方向上与z轴的夹角\n// @param {number} beta x-y平面上的夹角\n// @param {THREE.Vector3} out?\n// @return {THREE.Vector3}\nmath.directionFromAlphaBeta = function (alpha, beta) {\n    var theta = alpha / 180 * Math.PI + Math.PI / 2;\n    var phi = -beta / 180 * Math.PI + Math.PI / 2;\n\n    var dir = new THREE.Vector3();\n    var r = Math.sin(theta);\n    dir.x = r * Math.cos(phi);\n    dir.y = -Math.cos(theta);\n    dir.z = r * Math.sin(phi);\n\n    return dir;\n};\n\nmath.getDistanceFromArray = function (a, b) {\n    return Math.sqrt((a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]));\n};\n\nmath.getDirectionByAxisAngle = function (curDirection, axis, angle) {\n    var alpha = angle / 180 * Math.PI;\n    var curDir = new THREE.Vector3(curDirection[0], curDirection[1], curDirection[2]);\n    //这里必须反向\n    var curAxis = new THREE.Vector3(-axis[0], -axis[1], -axis[2]);\n    return curDir.applyAxisAngle(curAxis, alpha);\n};\n\nmath.arrayToFloat32Array = function (arr) {\n    var len = arr.length;\n    var res = new Float32Array(len);\n    for (var i = 0; i < len; i++) {\n        res[i] = arr[i];\n    }\n    return res;\n};\n\nmath.precisionAdd = function (a1, a2) {\n    var r1, r2, m;\n    try {\n        r1 = a1.toString().split('.')[1].length;\n    } catch (e) {\n        r1 = 0;\n    }\n    try {\n        r2 = a2.toString().split('.')[1].length;\n    } catch (e) {\n        r2 = 0;\n    }\n    m = Math.pow(10, Math.max(r1, r2));\n    return (a1 * m + a2 * m) / m;\n};\n\nexports.default = math;\n\n//# sourceURL=webpack:///./src/util/math.js?")
        },
        "./src/util/util.js": /*!**************************!*\
  !*** ./src/util/util.js ***!
  \**************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n// import RenderConfig from '../renderer/RenderConfig';\n\n\nvar _buffer3 = __webpack_require__(/*! ./buffer.js */ \"./src/util/buffer.js\");\n\nvar _buffer4 = _interopRequireDefault(_buffer3);\n\nvar _helper = __webpack_require__(/*! ./helper.js */ \"./src/util/helper.js\");\n\nvar _helper2 = _interopRequireDefault(_helper);\n\nvar _storage = __webpack_require__(/*! ../loader/storage.js */ \"./src/loader/storage.js\");\n\nvar _storage2 = _interopRequireDefault(_storage);\n\nvar _cache = __webpack_require__(/*! ../loader/cache.js */ \"./src/loader/cache.js\");\n\nvar _cache2 = _interopRequireDefault(_cache);\n\nvar _eventManager = __webpack_require__(/*! ../event/eventManager.js */ \"./src/event/eventManager.js\");\n\nvar _eventManager2 = _interopRequireDefault(_eventManager);\n\nvar _Material = __webpack_require__(/*! ../material/Material.js */ \"./src/material/Material.js\");\n\nvar _Material2 = _interopRequireDefault(_Material);\n\nvar _water = __webpack_require__(/*! ../material/specialMaterial/water.js */ \"./src/material/specialMaterial/water.js\");\n\nvar _water2 = _interopRequireDefault(_water);\n\nvar _CombineBasicProvider = __webpack_require__(/*! ../node/CombineBasicProvider.js */ \"./src/node/CombineBasicProvider.js\");\n\nvar _CombineBasicProvider2 = _interopRequireDefault(_CombineBasicProvider);\n\n__webpack_require__(/*! ../extra/BufferGeometryUtils.js */ \"./src/extra/BufferGeometryUtils.js\");\n\nvar _MeshLine = __webpack_require__(/*! ../extra/MeshLine */ \"./src/extra/MeshLine.js\");\n\nvar _math = __webpack_require__(/*! ../util/math.js */ \"./src/util/math.js\");\n\nvar _math2 = _interopRequireDefault(_math);\n\nvar _ScrollAnimation = __webpack_require__(/*! ../animation/ScrollAnimation.js */ \"./src/animation/ScrollAnimation.js\");\n\nvar _ScrollAnimation2 = _interopRequireDefault(_ScrollAnimation);\n\nvar _RenderManager = __webpack_require__(/*! ../renderer/RenderManager.js */ \"./src/renderer/RenderManager.js\");\n\nvar _RenderManager2 = _interopRequireDefault(_RenderManager);\n\nvar _materialFactory = __webpack_require__(/*! ../material/materialFactory */ \"./src/material/materialFactory.js\");\n\nvar _materialFactory2 = _interopRequireDefault(_materialFactory);\n\nvar _canvasManager = __webpack_require__(/*! ../canvas/canvasManager.js */ \"./src/canvas/canvasManager.js\");\n\nvar _canvasManager2 = _interopRequireDefault(_canvasManager);\n\nvar _GeometryManager = __webpack_require__(/*! ../geometry/GeometryManager */ \"./src/geometry/GeometryManager.js\");\n\nvar _GeometryManager2 = _interopRequireDefault(_GeometryManager);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar loader = new THREE.GLTFLoader();\n\nfunction clone(obj, isDeep) {\n    if (!obj || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {\n        return obj;\n    }\n    var c = obj instanceof Array ? [] : {};\n    for (var i in obj) {\n        var prop = obj[i];\n        if (isDeep && (typeof prop === 'undefined' ? 'undefined' : _typeof(prop)) == 'object') {\n            if (prop instanceof Array) {\n                c[i] = [];\n\n                for (var j = 0; j < prop.length; j++) {\n                    if (_typeof(prop[j]) != 'object') {\n                        c[i].push(prop[j]);\n                    } else {\n                        c[i].push(clone(prop[j], isDeep));\n                    }\n                }\n            } else {\n                c[i] = clone(prop, isDeep);\n            }\n        } else {\n            c[i] = prop;\n        }\n    }\n    return c;\n}\n\n//我发现这个util能做一切事情，太牛逼了\n//如有发现不合理的地方请立即抽象，谢谢\n//\nexports.default = {\n    //添加这个属性是因为窗口变化的时候需要触发\n    resizeCallbacks: [],\n    init: function init(dom, scene) {\n        this.dom = dom;\n        this.scene = scene;\n    },\n    makeClient: function makeClient(method) {\n        method();\n    },\n    setRenderCallback: function setRenderCallback(func) {\n        this.callback = func;\n    },\n    //TODO: 应该调用loader的\n    loadMeshUrl: function loadMeshUrl(name, path, callback) {\n        loader.load(path, function (gltf) {\n            gltf.scene.position.copy(new THREE.Vector3(0, 0, 0));\n            gltf.scene.name = name;\n            //buffer.meshBuffer.add(name, gltf.scene);\n            callback(gltf.scene);\n        });\n    },\n    loadTextureUrl: function loadTextureUrl(name, url, callback) {\n        var loader = new THREE.TextureLoader();\n        loader.load(url, function (texture) {\n            texture.name = name;\n            _buffer4.default.textureBuffer.add(name, texture);\n            callback(texture, 'succeed');\n        }, function (xhr) {\n            console.log(xhr.loaded / xhr.total * 100 + '% loaded');\n        }, function (xhr) {\n            callback(false, 'failure');\n            //console.log('An error happened');\n        });\n    },\n    loadEnvMap: function loadEnvMap(path, format, storeInBuffer) {\n        format = format || '.jpg';\n        storeInBuffer = storeInBuffer === undefined ? true : false;\n        var envMap = new THREE.CubeTextureLoader().load([path + 'lf' + format, path + 'rt' + format, path + 'up' + format, path + 'dn' + format, path + 'bk' + format, path + 'fr' + format]);\n        // envMap.encoding = THREE.sRGBEncoding;\n        // envMap.needsUpdate = true;\n        if (storeInBuffer) {\n            _buffer4.default.textureBuffer.add('_defaultEnvMap', envMap);\n        }\n        return envMap;\n    },\n    loadFileUrl: function loadFileUrl(src, success, fail) {\n        var that = this;\n        var loader = new THREE.FileLoader();\n        loader.load(src, function (response) {\n            if (!response || response.length < 1) return false;\n            //if (typeof response === 'string') response = JSON.parse(response);\n            try {\n                success(response, that);\n            } catch (error) {\n                console.log(error);\n                if (typeof fail === 'function') fail(error, that);\n            }\n        }, undefined, function (error) {\n            console.log(error);\n            if (typeof fail === 'function') fail(error, that);\n        });\n    },\n    createColourMaterial: function createColourMaterial(color, name) {\n        var myColor = new THREE.Color(color[0], color[1], color[2]);\n        var material = new _Material2.default(name, 'MeshLambertMaterial');\n        material.getTechnique(0).getPass(0).material.emissive = myColor;\n        material.getTechnique(0).getPass(0).material.color = myColor;\n        _buffer4.default.materialBuffer.add(name, material);\n    },\n    setEventCallback: function setEventCallback(name, func) {\n        var event = new _eventManager2.default(this.dom);\n        var id = _helper2.default.getUUID();\n        _buffer4.default.eventBuffer.add(id, event);\n        event.addListener(name, func);\n    },\n    showConsole: function showConsole() {\n        //呵呵哒\n    },\n    fitCamera: function fitCamera(arr) {\n        return {\n            center: arr\n        };\n    },\n    //TODO: 以下方法不完美\n    getUrlFileName: function getUrlFileName(url) {\n        url = url.replace(/\\\\/g, '/');\n        return url.substr(url.lastIndexOf('/') + 1);\n    },\n    //TODO: 以下方法不完美\n    getUrlFileTitle: function getUrlFileTitle(url) {\n        var temName = this.getUrlFileName(url);\n        temName = temName.substr(0, temName.lastIndexOf('.'));\n        return temName;\n    },\n    setSkyBox: function setSkyBox(name) {\n        // var dd = cache;\n        if (name === '') {\n            this.scene.background = null;\n            return;\n        }\n\n        var index = {\n            'rt': 0,\n            'lf': 1,\n            'up': 2,\n            'dn': 3,\n            'fr': 4,\n            'bk': 5\n        };\n        var folder = _storage2.default.getFile(name);\n        var files = folder.children;\n        var texture = new THREE.CubeTexture();\n        for (var i in files) {\n            var sign = i.substring(i.indexOf('_') + 1, i.indexOf('.'));\n            texture.images[index[sign]] = files[i];\n        }\n\n        texture.needsUpdate = true;\n        this.scene.background = texture;\n    },\n    initEnvironment: function initEnvironment(name) {\n        if (name === '') {\n            return;\n        }\n\n        var index = {\n            'lf': 0,\n            'rt': 1,\n            'up': 2,\n            'dn': 3,\n            'bk': 4,\n            'fr': 5\n        };\n        var folder = _storage2.default.getFile(name);\n        if (!folder) return;\n        var files = folder.children;\n        var texture = new THREE.CubeTexture();\n        for (var i in files) {\n            var sign = i.substring(i.indexOf('_') + 1, i.indexOf('.'));\n            texture.images[index[sign]] = files[i];\n        }\n        var envMap = _buffer4.default.textureBuffer.get('_defaultEnvMap');\n        if (envMap) {\n            envMap = texture;\n        } else {\n            _buffer4.default.textureBuffer.add('_defaultEnvMap', texture);\n        }\n        texture.needsUpdate = true;\n        // this.scene.background = envMap;\n    },\n    setPluginPath: function setPluginPath() {\n        //直接穿过\n    },\n    isActiveWindow: function isActiveWindow() {\n        return true;\n    },\n    createClient: function createClient() {\n        var t3d = document.getElementById('t3d') || window;\n        return t3d;\n    },\n    setResizeCallback: function setResizeCallback(func) {\n        var that = this;\n        var t3d = document.getElementById('t3d') || window;\n        var callback = function callback() {\n            func(that.dom.offsetWidth, that.dom.offsetHeight);\n        };\n        this.resizeCallbacks.push(callback);\n        // var t3d = document.getElementById('t3d') || window;\n        // t3d.addEventListener('resize', function (){\n        //    func(that.dom.offsetWidth,that.dom.offsetHeight);\n        // }, false);\n        // this.dom.addEventListener('onresize', this.onWindowResize, false);\n    },\n    isPathExist: function isPathExist(path) {\n        return _storage2.default.isExist(path);\n    },\n\n    //TODO: 以下方法非常恶心\n    _getFiles: function _getFiles(path, match) {\n        var result = [];\n        var index = path.indexOf('\\\\');\n        var myPath = path.substr(0, index);\n        var files = _storage2.default.getFile(myPath);\n        if (files) {\n            files = files.children;\n        }\n        for (var i in files) {\n            if (i.indexOf(match) >= 0) {\n                result.push(files[i]);\n            }\n        }\n        return result;\n    },\n    getPathFiles: function getPathFiles(path) {\n        var result = [];\n        if (path.indexOf('.scene') >= 0) {\n            result = this._getFiles(path, '.gltf');\n            //如果没有gltf则去请求lod\n            if (result.length === 0) {\n                result = this._getFiles(path, '.lod');\n            }\n        }\n        if (path.indexOf('.animation') >= 0) {\n            result = this._getFiles(path, '.animation');\n            var temArr = [];\n            for (var i in result) {\n                temArr.push(result[i].name);\n            }\n            result = temArr;\n        }\n        return result;\n    },\n    isFileExist: function isFileExist(path) {\n        path = path.replace(/\\\\/g, '/');\n        if (_storage2.default.getFile(path)) {\n            return true;\n        } else {\n            return false;\n        }\n    },\n\n    //为lod新增的接口\n    isLodFileExist: function isLodFileExist(path) {\n        path = path.replace(/\\\\/g, '/');\n        var files = _storage2.default.getFile(this.getFilePath(path));\n        var name = this.getUrlFileName(path);\n        var flag = false;\n        var reg = new RegExp('lod\\\\d{1,}@-', 'g');\n        if (files) {\n            for (var k in files.children) {\n                if (k.replace(reg, '') == name) {\n                    return true;\n                }\n            }\n        }\n        return flag;\n    },\n    base64Encode: function base64Encode(cfilename) {\n        return encodeURI(cfilename);\n    },\n    getFilePath: function getFilePath(path) {\n        var result = '';\n        if (path.indexOf('/') > -1) {\n            var sp = path.lastIndexOf('/');\n            result = path.substr(0, sp);\n        }\n        return result;\n    },\n    printConsole: function printConsole(msg) {\n        console.warn(msg);\n    },\n    setInvokeNodeCallback: function setInvokeNodeCallback() {\n        console.log('setInvokeNodeCallback 没有实现');\n    },\n    setNodeExceptionCallback: function setNodeExceptionCallback() {\n        console.log('setNodeExceptionCallback 没有实现');\n    },\n    setInvokeBrowserCallback: function setInvokeBrowserCallback() {\n        console.log('setInvokeBrowserCallback 没有实现');\n    },\n    readFile: function readFile(path) {\n        var text = _storage2.default.getFile(path);\n        return text;\n    },\n    writeFile: function writeFile() {},\n    extends: function _extends() {\n        var args = arguments;\n        if (args.length < 1) return;\n        if (args.length === 1) return args[0];\n        var temp = args[0];\n        for (var n = 1; n < args.length; n++) {\n            for (var i in args[n]) {\n                temp[i] = args[n][i];\n            }\n        }\n        return temp;\n    },\n    extend: function extend(subClass, superClass) {\n        var F = function F() {},\n            cloneFun = clone;\n        F.prototype = superClass.prototype;\n        subClass.prototype = new F();\n        subClass.prototype.constructor = subClass;\n        subClass.superclass = superClass.prototype;\n        if (superClass.prototype.constructor === Object.prototype.constructor) {\n            superClass.prototype.constructor = superClass;\n        }\n        if (!subClass.prototype.__extendList) {\n            subClass.prototype.__extendList = [];\n        } else {\n            subClass.prototype.__extendList = cloneFun(subClass.prototype.__extendList);\n        }\n        subClass.prototype.__extendList.push(superClass);\n    },\n    createBoxHelper: function createBoxHelper(box) {\n        var helper = new THREE.Box3Helper(box, 0xffff00);\n        this.scene.add(helper);\n    },\n\n    //该接口只能传入floatArray数组，为了最大限度的提升性能\n    createBufferAttributeMesh: function createBufferAttributeMesh(nodeName, pos, index, texCoord, normal) {\n        var geometry = new THREE.BufferGeometry();\n        geometry.setIndex(new THREE.BufferAttribute(index, 1));\n        geometry.addAttribute('position', new THREE.BufferAttribute(pos, 3));\n        if (texCoord) {\n            geometry.addAttribute('uv', new THREE.BufferAttribute(texCoord, 2));\n        }\n        if (normal) {\n            geometry.addAttribute('normal', new THREE.BufferAttribute(normal, 3));\n        }\n        var myEntity = new THREE.Mesh(geometry);\n        myEntity.name = nodeName;\n        _buffer4.default.nodeBuffer.add(nodeName, myEntity);\n        return myEntity;\n    },\n    beginVertexesIndexsTexCoordEndArray: function beginVertexesIndexsTexCoordEndArray(nodeName, type, pos, index, texCoord, normal) {\n        if (type == 'LINE_STRIP') {\n            //console.log('LINE_STRIP稍后实现');\n        } else if (type == 'TRIANGLE_LIST') {\n            //console.log('TRIANGLE_LIST稍后实现');\n        }\n        var geometry = new THREE.BufferGeometry();\n        // geometry.setIndex(new THREE.Uint16BufferAttribute(index, 1));\n        geometry.setIndex(new THREE.BufferAttribute(index, 1));\n        geometry.addAttribute('position', new THREE.Float32BufferAttribute(pos, 3));\n        if (texCoord) {\n            geometry.addAttribute('uv', new THREE.Float32BufferAttribute(texCoord, 2));\n        }\n        if (normal) {\n            geometry.addAttribute('normal', new THREE.Float32BufferAttribute(normal, 3));\n        }\n        geometry.computeFaceNormals();\n        geometry.computeVertexNormals();\n        // var t3dMat = buffer.materialBuffer.get(matName);\n        //\n        // if (!t3dMat) {\n        //     console.log('没有找到材质');\n        //     return;\n        // }\n        // geometry.computeVertexNormals();\n\n        var myEntity = new THREE.Mesh(geometry);\n        // myEntity.setMaterial(t3dMat);\n\n        myEntity.name = nodeName;\n        _buffer4.default.nodeBuffer.add(nodeName, myEntity);\n        return myEntity;\n    },\n    beginVertexesIndexsTexCoordEndArrayGeometry: function beginVertexesIndexsTexCoordEndArrayGeometry(pos, index, texCoord, normal) {\n        var geometry = new THREE.BufferGeometry();\n        // geometry.setIndex(new THREE.Uint16BufferAttribute(index, 1));\n        geometry.setIndex(new THREE.BufferAttribute(index, 1));\n        geometry.addAttribute('position', new THREE.Float32BufferAttribute(pos, 3));\n        if (texCoord) {\n            geometry.addAttribute('uv', new THREE.Float32BufferAttribute(texCoord, 2));\n        }\n        if (normal) {\n            geometry.addAttribute('normal', new THREE.Float32BufferAttribute(normal, 3));\n        }\n        geometry.computeFaceNormals();\n        geometry.computeVertexNormals();\n        return geometry;\n    },\n\n    //合并同一节点下所有相同材质的物体，在地球上慎用，有可能会造成精度问题\n    mergeObject: function mergeObject(array, name, attach, removeLast) {\n        var combineProvider = new _CombineBasicProvider2.default(name, attach, removeLast);\n        combineProvider.addObjects(array);\n        return combineProvider.merge();\n    },\n    createWater3: function createWater3(pos, index, texCoord, normal, param, materialName) {\n        var geometry = this.beginVertexesIndexsTexCoordEndArrayGeometry(pos, index, texCoord, normal);\n        var water = _water2.default.createWater3(geometry, materialName, param);\n        return water;\n    },\n    createWater3Material: function createWater3Material(materialName, param) {\n        var waterMaterial = _water2.default.createWater3Material(materialName, param);\n        return waterMaterial;\n    },\n    setLODAnimation: function setLODAnimation(flag, during) {\n        flag = flag || false;\n        _buffer4.default.LODAnimation = flag;\n        //during > 0.1 ? 0.1 :during;\n        _buffer4.default.LODAnimationDuring = during || 0.02;\n    },\n    setStatic: function setStatic(flag) {\n        flag = flag || false;\n        var scene = _buffer4.default.sceneBuffer.get('_3DScene');\n        scene.autoUpdate = !flag;\n        _buffer4.default.static = flag;\n    },\n    startFPSListen: function startFPSListen() {\n        _buffer4.default.isListenFPS = true;\n    },\n    stopFPSListen: function stopFPSListen() {\n        var result = 0;\n        _buffer4.default.isListenFPS = false;\n        _buffer4.default.fpsRecorder.map(function (v) {\n            return result += v;\n        });\n        result = result / _buffer4.default.fpsRecorder.length;\n        _buffer4.default.fpsRecorder = [];\n        return result;\n    },\n\n\n    /**\r\n     *@author zhuguang <zhuguang@uinnova.com>\r\n     *@param {Array} geoArray 一维geometry数组\r\n     *@return {Array} 返回合并完的geometry数组\r\n     *@date 2019/03/01 10:59:58\r\n     */\n    mergeBufferGeometry: function mergeBufferGeometry(geoArray, maxCount, useGroups) {\n        maxCount = maxCount || 50000;\n        var res = THREE.BufferGeometryUtils1.mergeBufferGeometries1(geoArray, maxCount, useGroups);\n        return res;\n    },\n\n    /**\r\n     *@author zhuguang <zhuguang@uinnova.com>\r\n     *@param {Array} geoArray 一维geometry数组\r\n     *@param {Number} maxCount 最大合并顶点数，默认是50000\r\n     *@return {Array} 返回合并完的geometry数组\r\n     *@date 2019/03/01 10:59:58\r\n     */\n    mergeBufferGeometry1: function mergeBufferGeometry1(geoArray, maxCount, useGroups) {\n        maxCount = maxCount || 50000;\n        //console.time();\n        var res = THREE.BufferGeometryUtils1.mergeBufferGeometries1(geoArray, maxCount, useGroups);\n        //console.log('merge:'+geoArray.length + '耗时:');\n        //console.timeEnd();\n        return res;\n    },\n\n    //合并同一级别下相同t3dMaterial材质的mesh，如果mesh上有矩阵，需要将isUseMatrix设置为true,最终返回合并完的数组mesh\n    mergeMesh: function mergeMesh(meshArray, maxCount, isUseMatrix, useGroups) {\n        isUseMatrix = isUseMatrix || false;\n        maxCount = maxCount || 50000;\n        var meshFactory = {};\n        var mergedMeshArr = [];\n        for (var i = 0; i < meshArray.length; i++) {\n            var mesh = meshArray[i];\n            if (!meshFactory[mesh.t3dMaterial.name]) {\n                meshFactory[mesh.t3dMaterial.name] = [];\n            }\n            //需要处理顶点和法线\n            if (isUseMatrix) {\n                var position = mesh.geometry.attributes.position;\n                if (position !== undefined) {\n                    mesh.matrix.applyToBufferAttribute(position);\n                    position.needsUpdate = true;\n                }\n                var normal = mesh.geometry.attributes.normal;\n                if (normal !== undefined) {\n                    var normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrix);\n                    normalMatrix.applyToBufferAttribute(normal);\n                    normal.needsUpdate = true;\n                }\n            }\n            meshFactory[mesh.t3dMaterial.name].push(mesh.geometry);\n        }\n\n        for (var k in meshFactory) {\n            var mergeGeomtries = this.mergeBufferGeometry1(meshFactory[k], maxCount, useGroups);\n            for (var r = 0; r < mergeGeomtries.length; r++) {\n                var t3dMaterial = _buffer4.default.materialBuffer.getMaterial(k);\n                var material = t3dMaterial.getTechnique(0).getPass(0).material;\n                var mergedMesh = new THREE.Mesh(mergeGeomtries[r], material);\n                mergedMesh.t3dMaterial = t3dMaterial;\n                mergedMeshArr.push(mergedMesh);\n            }\n        }\n\n        return mergedMeshArr;\n    },\n\n    /** 注意：目前只有LINE_LOFT支持width属性，LINE_PLANE需要传入片的朝向，默认为[0,1,0],BUILDING,LINE_LOFT,LINE_PLANE不需要传入uv,其他geometry如果不传入uv默认均为0\r\n     *        normal:BUILDING,LINE_LOFT,LINE_PLANE_SPRITE不需要传入normal,其他geometry如果需要正确的光照必须传入normal,\r\n     *        building的数据比较特殊，默认只支持xz平面向y拔起\r\n     *  myData = {\r\n     *      position:[],\r\n     *      normal:[],\r\n     *      uv:[],\r\n     *      index:[],\r\n     *      color:[],\r\n     *      uv2:[],\r\n     *      uv3:[],\r\n     *      holes:[[]],//如果是building带洞需要,holes为二维数组\r\n     *  }\r\n     *  config = {\r\n     *      line:{\r\n     *          up:[0,1,0],//LINE_PLANE需要设置朝向\r\n     *          width:1,//线宽度\r\n     *          uvRatio:1//uv重复度，根据距离设置，默认为1\r\n     *      },\r\n     *      building:{\r\n     *          height:0//高度\r\n     *         buildingTextureSize:[3,3]默认是3，计算building侧面uv时需要传入正确的值\r\n     *         buildingMaskTextureSize:[3,3]默认是3*3，如果需要使用maskMap高级模式需要传入正确的值\r\n     *         buildingLevelHeight:0//建筑是否分层\r\n     *         needsUvs : true//默认是否挂载额外的uv\r\n     *         manager:如果是异步处理则需要传入一个manager\r\n     *      }\r\n     *  }\r\n       */\n    createGeometry: function createGeometry(type, myData, config) {\n        var defaultConfig = {\n            line: {\n                up: [0, 1, 0], //LINE_PLANE需要设置朝向\n                width: 20, //线宽度\n                uvRatio: 1\n            },\n            building: {\n                height: 0, //高度\n                buildingTextureSize: [3, 3],\n                buildingMaskTextureSize: [3, 3],\n                buildingLevelHeight: 0,\n                needsUvs: true,\n                asynchronous: false,\n                manager: null\n            }\n        };\n        if (config.building) {\n            config.building = Object.assign({}, defaultConfig.building, config.building);\n        }\n        if (config.line) {\n            config.line = Object.assign({}, defaultConfig.line, config.line);\n        }\n        config = Object.assign({}, defaultConfig, config);\n        var geometry;\n        // var that = this;\n        var width = config.line.width;\n        var height = config.building.height;\n        var id = config.building.id;\n        var vis = config.building.vis;\n        var up = config.line.up;\n        var uvRatio = config.line.uvRatio;\n        var uStep = config.line.uStep;\n        var buildingTextureSize = config.building.buildingTextureSize;\n        var buildingMaskTextureSize = config.building.buildingMaskTextureSize;\n        var buildingWindowTextureSize = config.building.buildingWindowTextureSize;\n        var buildingLevelHeight = config.building.buildingLevelHeight;\n        var needsUvs = config.building.needsUvs;\n        //如果走worker则要开启useWorker\n        var asynchronous = config.building.asynchronous;\n        var manager = config.building.manager;\n\n        var positions = myData.position;\n        var uvs = myData.uv;\n        var index = myData.index;\n        var normal = myData.normal;\n        var colors = myData.colors;\n        var uv2 = myData.uv2;\n        var uv3 = myData.uv3;\n        var holes = myData.holes;\n        //处理数据\n        var vPos = [];\n        var vUv = [];\n        if (positions) {\n            for (var i = 0; i < positions.length; i += 3) {\n                vPos.push(new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]));\n            }\n        }\n        if (uvs) {\n            for (var _i = 0; _i < uvs.length; _i += 2) {\n                vUv.push(new THREE.Vector2(uvs[_i], uvs[_i + 1]));\n            }\n        }\n        // let topUv = myData.topUv;\n        // let sideUv = myData.sideUv;\n        if (type == 'TRIANGLE_STRIP' || type == 'TRIANGLE_LIST' || type == 'LINE_LIST' || type == 'LINE_STRIP') {\n            geometry = new THREE.BufferGeometry();\n            geometry.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n            if (uvs) {\n                geometry.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));\n            }\n            if (normal) {\n                geometry.addAttribute('normal', new THREE.Float32BufferAttribute(normal, 3));\n            }\n            if (colors) {\n                geometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\n            }\n            if (index) {\n                geometry.setIndex(new THREE.Uint16BufferAttribute(index, 1));\n            }\n            if (uv2) {\n                geometry.addAttribute('uv2', new THREE.Float32BufferAttribute(uv2, 2));\n            }\n            if (uv3) {\n                geometry.addAttribute('uv3', new THREE.Float32BufferAttribute(uv3, 2));\n            }\n        }\n        //目前LINELOFT不支持index\n        else if (type == 'LINE_LOFT') {\n                // var path = new THREE.CatmullRomCurve3(vPos);\n                // geometry = new THREE.TubeBufferGeometry(path, 64, width, 8, false);\n                var pList = new THREE.PathPointList();\n                pList.set(vPos, 0.0, 0.0, new THREE.Vector3(up[0], up[1], up[2]));\n                geometry = new THREE.PathTubeGeometry({\n                    pathPointList: pList,\n                    options: {\n                        radius: width, // default is 0.1\n                        radialSegments: 8, // default is 8\n                        progress: 1, // default is 1\n                        startRad: 0 // default is 0\n                    },\n                    usage: THREE.DynamicDrawUsage\n                }, true);\n                //现在的uv是按照管线周长计算的，要转为根据传入的uStep计算\n                var uvArray = geometry.attributes.uv.array;\n                var rate = Math.PI * 2 * width / uStep;\n                for (var j = 0; j < geometry.attributes.uv.count; j += 1) {\n                    uvArray[j * 2] = uvArray[j * 2] * rate;\n                }\n                geometry.addAttribute('uv', new THREE.BufferAttribute(uvArray, 2));\n                var _buffer = geometry.index.array.buffer;\n                var indexArray = new Uint16Array(_buffer);\n                geometry.setIndex(new THREE.BufferAttribute(indexArray, 1));\n            } else if (type == 'LINE_PLANE_SPRITE') {\n                var _geometry = new THREE.Geometry();\n                _geometry.vertices = vPos;\n                _geometry.textureCoord = vUv;\n                var lineObj = new _MeshLine.MeshLine();\n                lineObj.setGeometry(_geometry, undefined, uStep);\n                geometry = lineObj.geometry;\n            } else if (type == 'LINE_PLANE') {\n                var _pList = new THREE.PathPointList();\n                geometry = new THREE.PathGeometry(undefined, true);\n                _pList.set(vPos, 0.0, 0.0, new THREE.Vector3(up[0], up[1], up[2]));\n                geometry.update(_pList, {\n                    width: width,\n                    arrow: false,\n                    uvRatio: uvRatio\n                    // uvOffset: params.scrollUV ? scrollingY : 0\n                });\n                //现在的uv是按照宽度计算的，要转为根据传入的uStep计算\n                var _uvArray = geometry.attributes.uv.array;\n                var _rate = width / uStep;\n                for (var _j = 0; _j < geometry.attributes.uv.count; _j += 1) {\n                    _uvArray[_j * 2] = _uvArray[_j * 2] * _rate;\n                }\n                geometry.addAttribute('uv', new THREE.BufferAttribute(_uvArray, 2));\n                var _buffer2 = geometry.index.array.buffer;\n                var _indexArray = new Uint16Array(_buffer2, geometry.drawRange.start, geometry.drawRange.count);\n                geometry.setIndex(new THREE.BufferAttribute(_indexArray, 1));\n            } else if (type === 'BUILDING') {\n                //这个有些特殊\n                if (manager) {\n                    this.createBuildingByManager(positions, holes, height, buildingTextureSize, buildingMaskTextureSize, manager, buildingWindowTextureSize, id, vis);\n                    //需要在onmessage中去创建geometry然后分发出去给外部使用\n                } else {\n                    geometry = this._createBuilding(positions, holes, height, buildingTextureSize, buildingMaskTextureSize, undefined, buildingWindowTextureSize);\n                }\n            }\n        return geometry;\n    },\n    _createBuilding: function _createBuilding(positions, holes, height, buildingTextureSize, buildingMaskTextureSize, id, buildingWindowTextureSize) {\n        var geometry = new THREE.BufferGeometry();\n        var that = this;\n        var vertices = [];\n        //存放y轴的值\n        var yValue = 0;\n        for (var i = 0; i < positions.length / 3; i++) {\n            if (yValue === 0) {\n                yValue = positions[3 * i + 1];\n            }\n            //设置y为0\n            var v = new THREE.Vector3(positions[3 * i], positions[3 * i + 2], 0);\n            vertices.push(v);\n        }\n        var shape = new THREE.Shape(vertices);\n        if (holes) {\n            for (var j = 0; j < holes.length; j++) {\n                var hv = [];\n                var hole = holes[j];\n                for (var k = 0; k < hole.length / 3; k++) {\n                    var _v = new THREE.Vector3(hole[3 * k], hole[3 * k + 2], 0);\n                    hv.push(_v);\n                }\n                var holePath = new THREE.Path(hv);\n                shape.holes.push(holePath);\n            }\n        }\n        //创建geometry\n        var geo = new THREE.BufferGeometry();\n        geo.topUV = []; //top始终是不变的,目前通过包围盒计算\n        geo.sideUV1 = []; //u:0-1,v:0-1;\n        geo.sideUV2 = []; //u:0-1,v:0-y;\n        geo.sideUV3 = []; //u:0-x,v:0-1;\n        geo.sideUV4 = []; //u:0-x,v:0-y;\n        //mask\n        geo.sideUV5 = []; //u:0-1,v:0-y;\n        geo.sideUV6 = []; //u:0-x,v:0-1;\n        geo.sideUV7 = []; //u:0-x,v:0-y;\n\n        // mask around\n        geo.sideUV8 = [];\n        // geo.sidePerimeter = shape.getLength();// 几何体侧边周长\n\n        geometry = new THREE.ExtrudeBufferGeometry(shape, {\n            // extrudePath: path,\n            steps: 1,\n            depth: height,\n            material: 0,\n            extrudeMaterial: 1,\n            bevelEnabled: false,\n            UVGenerator: that._uvgenerator(geo, height, vertices, buildingTextureSize, buildingMaskTextureSize, buildingWindowTextureSize)\n        });\n        // let worldPlaneGroup = geometry.groups[0];\n        // let WorldPlanePosition = [];\n        //继续转换顶点，这里确实有点绕, 获取真正的底面数组\n        var normalArray = geometry.attributes.normal.array;\n        for (var _i2 = 0, array = geometry.attributes.position.array, length = array.length; _i2 < length; _i2 += 3) {\n            // if (buildingLevelHeight) {\n            //     if (i >= worldPlaneGroup.start * 3 && i <= (worldPlaneGroup.start + Math.floor(worldPlaneGroup.count / 2)) * 3) {\n            //         WorldPlanePosition.push(array[i]);\n            //         WorldPlanePosition.push(array[i + 2]);\n            //         WorldPlanePosition.push(array[i + 1]);\n            //     }\n            // }\n            //从xy平面转换到xz平面\n            var y = array[_i2 + 1];\n            array[_i2 + 1] = array[_i2 + 2] + yValue; //垂直方向\n            array[_i2 + 2] = y;\n            //继续转换法线，这里threejs会进行内部转换,所以必须转回来\n            normalArray[_i2] = -normalArray[_i2];\n            normalArray[_i2 + 1] = -normalArray[_i2 + 1];\n            normalArray[_i2 + 2] = -normalArray[_i2 + 2];\n            var y1 = normalArray[_i2 + 1];\n            normalArray[_i2 + 1] = normalArray[_i2 + 2];\n            normalArray[_i2 + 2] = y1;\n        }\n        //继续计算侧面uv\n        if (height) {\n            //changed, 如果想自定义uv，可以使用属性里面的值自由配置\n            geometry.topUV = geo.topUV;\n            geometry.sideUV1 = geo.sideUV1;\n            geometry.sideUV2 = geo.sideUV2;\n            geometry.sideUV3 = geo.sideUV3;\n            geometry.sideUV4 = geo.sideUV4;\n            geometry.sideUV5 = geo.sideUV5;\n            geometry.sideUV6 = geo.sideUV6;\n            geometry.sideUV7 = geo.sideUV7;\n            geometry.sideUV8 = geo.sideUV8;\n            //TODO 创建几万级的数据还有很大的优化空间，应该还能提升将近一倍的效率\n            geometry.addAttribute('uv', new THREE.BufferAttribute(_math2.default.arrayToFloat32Array(geo.topUV.concat(geo.sideUV2)), 2));\n            geometry.addAttribute('uv2', new THREE.BufferAttribute(_math2.default.arrayToFloat32Array(geo.topUV.concat(geo.sideUV1)), 2));\n            geometry.addAttribute('uv3', new THREE.BufferAttribute(_math2.default.arrayToFloat32Array(geo.topUV.concat(geo.sideUV4)), 2));\n\n            // 环绕纹理使用的UV，暂时用法\n            geometry.addAttribute('uv8', new THREE.BufferAttribute(_math2.default.arrayToFloat32Array(geo.topUV.concat(geo.sideUV8)), 2));\n\n            if (id !== undefined) {\n                var idArray = new Float32Array(geometry.attributes.position.count);\n                idArray.fill(id);\n                geometry.addAttribute('id', new THREE.BufferAttribute(idArray, 1));\n            }\n            //geometry.addAttribute('uv3', new THREE.Float32BufferAttribute(geo.topUV.concat(geo.sideUV7), 2));\n        }\n        return geometry;\n        // if (buildingLevelHeight) {\n        //     let levelPosition = [];\n        //     //继续生成楼层平面\n        //     let levels = Math.floor(height / buildingLevelHeight) - 1;\n        //     for (let i = 0; i < levels; i++) {\n        //         let curLevelHeight = buildingLevelHeight * (i + 1);\n        //         let curLevelPositon = that._createBuildingLevelPlane(WorldPlanePosition, curLevelHeight);\n        //         levelPosition.concat(curLevelPositon);\n        //     }\n        //     //生成每一层的geometry\n        //     let levelGeometry = new THREE.BufferGeometry();\n        //     levelGeometry.addAttribute('position', new THREE.Float32BufferAttribute(levelPosition, 3));\n        //     //TODO 每一层的uv还未计算，而且还不清楚是否应该把层与最终的geometry进行合并，如果合并可能会为后续的使用带来很大的麻烦\n        // }\n    },\n    _createBuildingLevelPlane: function _createBuildingLevelPlane(WorldPlanePosition, height) {\n        var res = [];\n        for (var i = 0; i < WorldPlanePosition.length; i++) {\n            if ((i + 1) % 2 === 0) {\n                res.push(WorldPlanePosition[i] + height);\n            } else {\n                res.push(WorldPlanePosition[i]);\n            }\n        }\n        return res;\n    },\n\n    //为building计算uv\n    _uvgenerator: function _uvgenerator(geo, height, vertices, buildingTextureSize, buildingMaskTextureSize, buildingWindowTextureSize) {\n        //计算包围盒\n        if (geo.boundingBox === null) {\n            geo.boundingBox = new THREE.Box3();\n        }\n        geo.boundingBox.setFromPoints(vertices);\n        var minX = geo.boundingBox.min.x,\n            maxX = geo.boundingBox.max.x,\n            minY = geo.boundingBox.min.y,\n            maxY = geo.boundingBox.max.y,\n            minZ = 0,\n            maxZ = height;\n        var dx = buildingTextureSize[0];\n        var dy = buildingTextureSize[1];\n        var dx1 = buildingMaskTextureSize[0];\n        var dy1 = buildingMaskTextureSize[1];\n\n        var windowDx = buildingWindowTextureSize[0];\n        var windowDy = buildingWindowTextureSize[1];\n\n        var ratio = 0.0;\n\n        var UVGenerator = {\n\n            generateTopUV: function generateTopUV(geometry, vertices, indexA, indexB, indexC) {\n\n                var a_x = (vertices[indexA * 3] - minX) / (maxX - minX);\n                var a_y = 1 - (vertices[indexA * 3 + 1] - minY) / (maxY - minY);\n                var b_x = (vertices[indexB * 3] - minX) / (maxX - minX);\n                var b_y = 1 - (vertices[indexB * 3 + 1] - minY) / (maxY - minY);\n                var c_x = (vertices[indexC * 3] - minX) / (maxX - minX);\n                var c_y = 1 - (vertices[indexC * 3 + 1] - minY) / (maxY - minY);\n\n                var result = [new THREE.Vector2(a_x, a_y), new THREE.Vector2(b_x, b_y), new THREE.Vector2(c_x, c_y)];\n                geo.topUV.push.call(geo.topUV, result[0].x, result[0].y, result[1].x, result[1].y, result[2].x, result[2].y);\n                return result;\n            },\n\n            generateSideWallUV: function generateSideWallUV(geometry, vertices, indexA, indexB, indexC, indexD) {\n                var a = [vertices[indexA * 3], vertices[indexA * 3 + 1]];\n                var b = [vertices[indexB * 3], vertices[indexB * 3 + 1]];\n\n                var x = _math2.default.getDistanceFromArray(a, b) / dx;\n                var y = height / dy;\n\n                var x1 = _math2.default.getDistanceFromArray(a, b) / dx1;\n                var y1 = height / dy1;\n\n                function setSideUV(x, y, uv) {\n                    var res = [new THREE.Vector2(0, 0), new THREE.Vector2(x, 0), new THREE.Vector2(x, y), new THREE.Vector2(0, y)];\n                    uv.push.call(uv, res[0].x, res[0].y, res[1].x, res[1].y, res[3].x, res[3].y);\n                    uv.push.call(uv, res[1].x, res[1].y, res[2].x, res[2].y, res[3].x, res[3].y);\n                }\n\n                var sideUV1 = [new THREE.Vector2(0, 0), new THREE.Vector2(1, 0), new THREE.Vector2(1, 1), new THREE.Vector2(0, 1)];\n\n                setSideUV(-1, 1, geo.sideUV1);\n                setSideUV(-1, y, geo.sideUV2);\n                setSideUV(-x, 1, geo.sideUV3);\n                setSideUV(-x, y, geo.sideUV4);\n\n                setSideUV(-1, y1, geo.sideUV5);\n                setSideUV(-x1, 1, geo.sideUV6);\n                setSideUV(-x1, y1, geo.sideUV7);\n\n                // 计算窗户环绕UV\n                var a_x = vertices[indexA * 3];\n                var a_y = vertices[indexA * 3 + 1];\n                var a_z = vertices[indexA * 3 + 2];\n                var b_x = vertices[indexB * 3];\n                var b_y = vertices[indexB * 3 + 1];\n                var b_z = vertices[indexB * 3 + 2];\n\n                var a_p = new THREE.Vector3(a_x, a_y, a_z);\n                var b_p = new THREE.Vector3(b_x, b_y, b_z);\n\n                // 面宽度\n                var faceLength = a_p.distanceTo(b_p);\n\n                function setSideUV_Arround(x, y, uv) {\n                    var res = [new THREE.Vector2(ratio, 0), new THREE.Vector2(ratio + faceLength / windowDx, 0), new THREE.Vector2(ratio + faceLength / windowDx, height / windowDy), new THREE.Vector2(ratio, height / windowDy)];\n                    uv.push.call(uv, res[0].x, res[0].y, res[1].x, res[1].y, res[3].x, res[3].y);\n                    uv.push.call(uv, res[1].x, res[1].y, res[2].x, res[2].y, res[3].x, res[3].y);\n                }\n\n                setSideUV_Arround(-1, 1, geo.sideUV8);\n\n                ratio += faceLength / windowDx;\n                // ratio += faceLength / geo.sidePerimeter;\n\n                return sideUV1;\n            }\n        };\n        return UVGenerator;\n    },\n    createBuildingByManager: function createBuildingByManager(positions, holes, height, buildingTextureSize, buildingMaskTextureSize, manager, buildingWindowTextureSize, id, vis) {\n        manager = manager || new _GeometryManager2.default('_defaultGeometryManager');\n        manager.total++;\n        manager.addData({\n            positions: positions,\n            holes: holes,\n            height: height,\n            id: id,\n            vis: vis,\n            buildingTextureSize: buildingTextureSize,\n            buildingMaskTextureSize: buildingMaskTextureSize,\n            buildingWindowTextureSize: buildingWindowTextureSize\n        });\n        // var worker = manager.getWorker();\n        // worker.postMessage({ positions:positions, holes:holes, height:height, buildingTextureSize:buildingTextureSize, buildingMaskTextureSize:buildingMaskTextureSize});\n    },\n\n    //系统级设置aoIntensity\n    setAoIntensity: function setAoIntensity(aoIntensity) {\n        _RenderManager2.default.config.aoMapIntensity = aoIntensity;\n        this.scene.traverse(function (v) {\n            if (v.t3dMaterial) {\n                v.t3dMaterial.getMaterial()[0].aoMapIntensity = aoIntensity;\n            }\n        });\n    },\n\n    //系统设置aoMapFactor\n    setAoMapFactor: function setAoMapFactor(aoMapFactor) {\n        _RenderManager2.default.config.aoMapFactor = aoMapFactor;\n        _RenderManager2.default.config.aoFactor = aoMapFactor;\n        this.scene.traverse(function (v) {\n            if (v.t3dMaterial && v.t3dMaterial.getMaterial()[0].shader) {\n                v.t3dMaterial.getMaterial()[0].shader.uniforms.aoMapFactor.value = aoMapFactor;\n                v.t3dMaterial.getMaterial()[0].shader.uniforms.aoFactor.value = aoMapFactor;\n            }\n        });\n    },\n\n    //系统设置环境图强度\n    setEnvMapIntensity: function setEnvMapIntensity(envMapIntensity) {\n        _RenderManager2.default.config.envMapIntensity = envMapIntensity;\n        this.scene.traverse(function (v) {\n            if (v.t3dMaterial) {\n                v.t3dMaterial.getMaterial()[0].envMapIntensity = envMapIntensity;\n            }\n        });\n    },\n\n    //系统设置gamma值\n    setGamma: function setGamma(gamma) {\n        _RenderManager2.default.getRenderer().gammaFactor = gamma;\n        _RenderManager2.default.config.gammaFactor = gamma;\n        this.scene.traverse(function (v) {\n            if (v.t3dMaterial) {\n                v.t3dMaterial.getMaterial()[0].needsUpdate = true;\n            }\n        });\n    },\n    createBigPointMesh: function createBigPointMesh(geometry, material) {\n        var bigPoint = new THREE.Points(geometry, material);\n        return bigPoint;\n    },\n    createBigPointGeometry: function createBigPointGeometry(position, color, uv, vis) {\n        var geometry = new THREE.BufferGeometry();\n        geometry.addAttribute('position', new THREE.Float32BufferAttribute(position, 3));\n        geometry.addAttribute('color', new THREE.Float32BufferAttribute(color, 4));\n        var len = position.length;\n        if (!uv) {\n            uv = new Float32Array(len / 3 * 2);\n        }\n        geometry.addAttribute('uv', new THREE.Float32BufferAttribute(uv, 2));\n        if (!vis) {\n            vis = new Float32Array(len / 3);\n            vis.fill(1);\n        }\n        geometry.addAttribute('vis', new THREE.BufferAttribute(vis, 1));\n        return geometry;\n    },\n    createBigPoint: function createBigPoint(positions, colors, size, symbol, name) {\n        name = name || 'bigPointMat';\n        var geometry = this.createBigPointGeometry(positions, colors);\n        var material = this.createBigPointMaterial(name, size, symbol);\n        return this.createBigPointMesh(geometry, material);\n    },\n\n    /**\r\n       *  symbol = {\r\n       *          lineWidth :0,\r\n       *          color: 'rgba(255,0,0,1)',\r\n       *          lineColor: 'rgba(0,0,255,1)',\r\n       *          type:'circle',\r\n       *          blending: 2\r\n       * }\r\n      **/\n    createBigPointMaterial: function createBigPointMaterial(matName, size, symbol) {\n        size = size === undefined ? 1 : size;\n        var _defaultSymbol = {\n            lineWidth: 0,\n            color: [1, 1, 1],\n            lineColor: [1, 1, 1],\n            type: 'circle',\n            blending: 2\n        };\n        //十字型默认线宽为1\n        if (symbol && symbol.type === 'cross') {\n            _defaultSymbol.lineWidth = 1;\n        }\n        symbol = Object.assign({}, _defaultSymbol, symbol);\n        var material = _materialFactory2.default.createMaterial('bigPointMaterial');\n        var texture = void 0;\n        //贴图透明度 走opacity\n        if (symbol.type === 'image') {\n            texture = new THREE.TextureLoader().load(symbol.url, function (ev) {\n                material.uniforms.imageSize.value = new THREE.Vector2(ev.image.width, ev.image.height);\n                if (symbol.useColor === true) {\n                    material.uniforms.ptColor.value = new THREE.Color(symbol.color[0], symbol.color[1], symbol.color[2]);\n                }\n                if (symbol.opacity !== null && symbol.opacity !== undefined) {\n                    material.uniforms.opacity.value = symbol.opacity;\n                }\n            });\n            texture.anisotropy = 16;\n            texture.needsUpdate = true;\n            //   symbol.blending = THREE.NormalBlending;\n        } else {\n            //矢量透明度 在color中 rgba\n            var canvas = _canvasManager2.default.createSymbol(symbol, 'bigPoint');\n            texture = new THREE.Texture(canvas.getTexture(), matName + '_texture');\n            texture.needsUpdate = true;\n        }\n        material.name = matName;\n        material.blending = symbol.blending;\n        material.uniforms.tex.value = texture;\n        material.uniforms.size.value = size;\n        _buffer4.default.materialBuffer.add(matName, material);\n        return material;\n    },\n    beginFrame: function beginFrame(flag) {\n        _buffer4.default.frameTime = 0;\n    },\n\n    //TODO 默认计算写入到uv3通道\n    createScanningUV: function createScanningUV(node, min, max, planeU, planeV, isClone) {\n        if (node instanceof Array) {\n            for (var i = 0, len = node.length; i < len; i++) {\n                this._createScanningUV(node[i], min, max, planeU, planeV, isClone);\n            }\n        } else {\n            this._createScanningUV(node, min, max, planeU, planeV, isClone);\n        }\n    },\n    _createScanningUV: function _createScanningUV(node, min, max, planeU, planeV, isClone) {\n        isClone = isClone === undefined ? true : isClone;\n        planeU = planeU || [1, 0, 0.5]; //u投影计算\n        planeV = planeV || [0, 1, 0]; //v投影计算\n        node.updateWorldMatrix(true, true); //为了保险，更新整个场景树吧\n        var inverseMatrixWorld = new THREE.Matrix4();\n        inverseMatrixWorld.getInverse(node.matrixWorld);\n        var meshes = node.getMeshes();\n        var needToClone;\n        for (var i = 0, len = meshes.length; i < len; i++) {\n            needToClone = true;\n            var curGeometry = meshes[i].geometry;\n            if (curGeometry.isGeometry) {\n                var bufferGeometry = new THREE.BufferGeometry();\n                bufferGeometry.fromGeometry(curGeometry);\n                meshes[i].geometry = bufferGeometry;\n                curGeometry = bufferGeometry;\n                needToClone = false;\n            }\n            if (isClone) {\n                curGeometry = meshes[i].geometry.clone();\n                meshes[i].geometry = curGeometry;\n            } else {\n                curGeometry = meshes[i].geometry;\n            }\n            var matrix = meshes[i].matrixWorld;\n            var worldMatrix = matrix.multiplyMatrices(inverseMatrixWorld, matrix);\n            this._processScanningUV(curGeometry, worldMatrix, min, max, planeU, planeV);\n        }\n    },\n\n    //目前暂且使用uv3\n    _processScanningUV: function _processScanningUV(geometry, worldMatrix, min, max, planeU, planeV) {\n        //如果是xy平面,然后z往x上投影\n        var position = geometry.getAttribute('position').array;\n        var uv3 = new Float32Array(position.length * 2 / 3);\n        var maxX = max[0] - min[0];\n        var maxY = max[1] - min[1];\n        var maxZ = max[2] - min[2];\n        for (var i = 0, len = position.length; i < len / 3; i++) {\n            var posVector = new THREE.Vector4(position[3 * i], position[3 * i + 1], position[3 * i + 2], 1);\n            posVector.applyMatrix4(worldMatrix);\n            var posx = posVector.x;\n            var posy = posVector.y;\n            var posz = posVector.z;\n            var u = (posx - min[0]) * planeU[0] / maxX + (posy - min[1]) * planeU[1] / maxY + (posz - min[2]) * planeU[2] / maxZ;\n            var v = (posx - min[0]) * planeV[0] / maxX + (posy - min[1]) * planeV[1] / maxY + (posz - min[2]) * planeV[2] / maxZ;\n            uv3[2 * i] = u;\n            uv3[2 * i + 1] = v;\n        }\n        //console.log(uv3);\n        geometry.addAttribute('uv3', new THREE.BufferAttribute(uv3, 2));\n    }\n};\n\n//# sourceURL=webpack:///./src/util/util.js?")
        },
        "./src/version.json": /*!**************************!*\
  !*** ./src/version.json ***!
  \**************************/
        /*! exports provided: version, default */
        function(module) {
            eval('module.exports = JSON.parse("{\\"version\\":1.1}");\n\n//# sourceURL=webpack:///./src/version.json?')
        },
        "./src/volume/VolumeData.js": /*!**********************************!*\
  !*** ./src/volume/VolumeData.js ***!
  \**********************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _materialManager = __webpack_require__(/*! ../material/materialManager.js */ \"./src/material/materialManager.js\");\n\nvar _materialManager2 = _interopRequireDefault(_materialManager);\n\nvar _buffer = __webpack_require__(/*! ../util/buffer.js */ \"./src/util/buffer.js\");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _simpleheat = __webpack_require__(/*! ../extra/simpleheat.js */ \"./src/extra/simpleheat.js\");\n\nvar _simpleheat2 = _interopRequireDefault(_simpleheat);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Volume = function () {\n  function Volume(name, segX, segY, segZ, width, height, depth, minValue, maxValue) {\n    _classCallCheck(this, Volume);\n\n    // var geometry = new THREE.BoxGeometry(width, height, depth);\n    // // var mat = new Material(name);\n    // var material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\n    // // geometry.colors = [];\n    // \n    this.defaultValue = 0;\n    this.width = width;\n    this.depth = depth;\n\n    this.segX = segX;\n    this.segY = segY;\n\n    this.data = [];\n    var radius = 30; // 影响范围 3.5 米\n    var blur = 30;\n    var mapCanvas = document.createElement('canvas');\n    var image = document.createElement('img');\n\n    //扩大10倍，因为如果用米太小了\n    mapCanvas.width = width * 10;\n    mapCanvas.height = depth * 10;\n    mapCanvas.style.position = 'absolute';\n    mapCanvas.style.left = '0px';\n    mapCanvas.style.top = '0px';\n\n    this.canvas = mapCanvas;\n\n    this.max = maxValue;\n    this.min = minValue;\n    // this.distance = value[4] - value[0];\n    // var grid = this._colorDIY(value);\n    // this.max = (40);\n\n    this.name = name;\n    // this._generateData(segX, segY, width * 10, depth * 10);\n    this.heat = new _simpleheat2.default(mapCanvas);\n    this.heat.data(this.data);\n    this.heat.max(this.max);\n    // this.heat.min(this.min);\n    this.heat.radius(radius, blur);\n    // this.heat.gradient(grid);\n    // this.heat.draw(); //每次数值更新需要重新 draw 一下\n    // image.src = null;\n    image.width = mapCanvas.width;\n    image.height = mapCanvas.height;\n    // debugger;\n    // // mat = mat.getTechnique(0).getPass(0).material;\n    // var mesh = THREE.Mesh(geometry, material);\n    var mat = _materialManager2.default.createMaterial(name + '_material', 'MeshBasicMaterial');\n    this.material = mat;\n\n    var texture = new THREE.Texture(image); //document.querySelector('.heatmap-canvas')\n    texture.needsUpdate = true;\n    // texture.repeat.set(4, 4);\n    // mat.getTechnique(0).getPass(0).material = new THREE.MeshBasicMaterial();\n    mat.getTechnique(0).getPass(0).material.color = new THREE.Color('#0000ff');\n    // mat.getTechnique(0).getPass(0).material.map = texture;\n    mat.getTechnique(0).getPass(0).material.depthWrite = false;\n    mat.getTechnique(0).getPass(0).material.depthTest = false;\n\n    var backPass = mat.getTechnique(0).createPass();\n    backPass.material.map = texture;\n    backPass.material.depthWrite = false;\n    backPass.material.depthTest = false;\n    // var geometry = new THREE.BoxGeometry(depth, height, width, segX, segY, segZ);\n\n    var geometry = new THREE.PlaneGeometry(width, depth);\n    // var material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });\n\n    var cube = new THREE.Mesh(geometry, mat.getTechnique(0).getPass(0).material);\n    cube.setMaterial(mat);\n    // debugger;\n    cube.rotateX(-(0.5 * Math.PI));\n    cube.translateZ(height / 2);\n    cube.name = name;\n    cube.toString = function () {\n      return this.name;\n    };\n    this.plane = cube;\n    // this.plane.show(false);\n    _buffer2.default.entityBuffer.add(name, cube);\n\n    this.heat.data(this.data);\n    this.heat.draw(); //每次数值更新需要重新 draw 一下\n\n    backPass.material.map.image.src = this.canvas.toDataURL('image/png');\n    backPass.material.map.needsUpdate = true;\n  }\n\n  _createClass(Volume, [{\n    key: '_generateData',\n    value: function _generateData(segX, segY, width, height) {\n      this.data = [];\n      var detaX = height / (segX * 10);\n      var detaY = width / (segY * 10);\n      // debugger;\n      for (var i = 0; i < segX; i++) {\n        for (var j = 0; j < segY; j++) {\n          var x = detaX * i * 10;\n          var y = detaY * j * 10;\n          this._paintAtCoord(y, x);\n        }\n      }\n    }\n  }, {\n    key: '_paintAtCoord',\n    value: function _paintAtCoord(x, y) {\n      // var count = 0;\n      // var v = Math.random() * 1000;\n      this.data.push([x, y, this.defaultValue]);\n    }\n  }, {\n    key: '_valueToColor',\n    value: function _valueToColor(value) {\n      var colorCode = value / this.distance;\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.name;\n    }\n  }, {\n    key: 'setValueByIndex',\n    value: function setValueByIndex(idx, value) {\n\n      // geometry.colors[idx] = threeColor;\n    }\n  }, {\n    key: 'setValueByLocalPosition',\n    value: function setValueByLocalPosition(value, x, y, z) {}\n  }, {\n    key: 'setValueByLocalPositionList',\n    value: function setValueByLocalPositionList(valueList) {}\n  }, {\n    key: 'setValueByWorldPosition',\n    value: function setValueByWorldPosition(value, x, y, z) {}\n  }, {\n    key: 'changeValueRange',\n    value: function changeValueRange(value) {\n      var grid = this._colorDIY(value);\n      this.max = value[4] - value[0];\n      this.min = value[0];\n      // this.heat.max(this.max);\n      // this.heat.gradient(grid);\n      //  this.heat.draw(); //每次数值更新需要重新 draw 一下\n      var mat = this.plane.t3dMaterial.getTechnique(0).getPass(1).material;\n      mat.map.image.src = this.canvas.toDataURL('image/png');\n      mat.map.needsUpdate = true;\n    }\n  }, {\n    key: '_colorDIY',\n    value: function _colorDIY(value) {\n      if (value.length < 3) {\n        value = [5, 22, 26, 30, 35];\n      }\n      // value = [5, 22, 26, 30, 35];\n      var sum = value[4] - value[0];\n      var one = (value[0] - value[0]) / sum;\n      var two = (value[1] - value[0]) / sum;\n      var three = (value[2] - value[0]) / sum;\n      var four = (value[3] - value[0]) / sum;\n      var five = (value[4] - value[0]) / sum;\n\n      var grid = {};\n      grid[one] = 'blue';\n      grid[two] = 'cyan';\n      grid[three] = 'lime';\n      grid[four] = 'yellow';\n      grid[five] = 'red';\n      return grid;\n      // this.heat.gradient(grid);\n    }\n  }, {\n    key: 'setDefaultValue',\n    value: function setDefaultValue(value) {\n      this.defaultValue = 0;\n      // this._generateData()\n      // this.heat.draw();\n    }\n  }, {\n    key: 'setValueByWorldPositionList',\n    value: function setValueByWorldPositionList(valueList) {\n      // this._generateData(this.segX, this.segY, this.width * 10, this.depth * 10);\n      for (var i = 0; i < valueList.length; i += 4) {\n        var value = valueList[i];\n        var x = valueList[i + 1];\n        var y = valueList[i + 2];\n        var z = valueList[i + 3];\n        var worldPos = new THREE.Vector3(x, y, z);\n\n        this.plane.worldToLocal(worldPos);\n        var posX = this.width / 2;\n        var posY = this.depth / 2;\n        posX = worldPos.x + posX;\n        posY = posY - worldPos.y;\n        this.data.push([posX * 10, posY * 10, value - this.min]);\n      }\n\n      this.heat.data(this.data);\n      this.heat.draw(); //每次数值更新需要重新 draw 一下\n      var mat = this.plane.t3dMaterial.getTechnique(0).getPass(1).material;\n      mat.map.image.src = this.canvas.toDataURL('image/png');\n      mat.map.needsUpdate = true;\n      // this.material.map.image.src = this.canvas.toDataURL('image/png');\n      // this.material.map.needsUpdate = true;\n      // this.plane.material.map.image.src = this.canvas.toDataURL('image/png');\n      // this.plane.material.map.needsUpdate = true;\n      // \n\n      // this.plane.show(true);\n      // this.material.getTechnique(0).getPass(0).material.map.needsUpdate = true;\n      // debugger;\n    }\n  }, {\n    key: 'resetOptimizedData',\n    value: function resetOptimizedData() {\n      // debugger;\n      // this._generateData(this.segX, this.segY, this.width * 10, this.depth * 10);\n      // this.data.map(a => a[2] = 0);\n      // this.data = [];\n      //清空效果\n    }\n  }, {\n    key: 'resetDataZero',\n    value: function resetDataZero() {\n      this.data = [];\n      // debugger;\n      // this._generateData(this.segX, this.segY, this.width * 10, this.depth * 10);\n\n      // this.heat.data(this.data);\n      // this.data.map(a => a[2] = 0);\n      //清空数值\n    }\n  }, {\n    key: 'bold',\n    value: function bold(percent) {\n      //效果加粗\n    }\n  }, {\n    key: 'smooth',\n    value: function smooth(percent) {\n      //效果差值\n    }\n  }, {\n    key: 'setPercent',\n    value: function setPercent(percent) {\n      // debugger;\n      //设置截面位置\n    }\n  }, {\n    key: 'getPercent',\n    value: function getPercent() {\n      // debugger;\n      //获取当前截面位置\n    }\n  }, {\n    key: 'setDir',\n    value: function setDir(dir) {\n      //设置法相\n    }\n  }, {\n    key: 'getDir',\n    value: function getDir() {}\n  }, {\n    key: 'update',\n    value: function update() {}\n  }, {\n    key: 'getManualObject',\n    value: function getManualObject() {\n      return this.plane;\n    }\n  }, {\n    key: 'getMaterial',\n    value: function getMaterial() {\n      return this.material;\n    }\n  }, {\n    key: 'setSquareCornerFac',\n    value: function setSquareCornerFac(fac) {}\n  }]);\n\n  return Volume;\n}();\n\nexports.default = Volume;\n\n//# sourceURL=webpack:///./src/volume/VolumeData.js?")
        },
        "./src/volume/volumeDataManager.js": /*!*****************************************!*\
  !*** ./src/volume/volumeDataManager.js ***!
  \*****************************************/
        /*! no static exports found */
        function(module, exports, __webpack_require__) {
            "use strict";
            eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\nvar _VolumeData = __webpack_require__(/*! ./VolumeData.js */ "./src/volume/VolumeData.js");\n\nvar _VolumeData2 = _interopRequireDefault(_VolumeData);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n    init: function init(scene) {\n        this.scene = scene;\n    },\n    createVolumeData: function createVolumeData(name, segX, segY, segZ, width, height, depth, minv, maxv) {\n        var volumeInstance = new _VolumeData2.default(name, segX, segY, segZ, width, height, depth, minv, maxv);\n        // this.scene.add(volumeInstance);\n\n        return volumeInstance;\n        // width x, height y, depth z\n        // segX, segY 点阵密度\n        // minv, maxv 最大值，最小值\n    },\n    getByName: function getByName() {},\n    destroyVolumeData: function destroyVolumeData() {}\n};\n\n//# sourceURL=webpack:///./src/volume/volumeDataManager.js?')
        }
    })
}
, function(t, e) {
    var n, r, a = t.exports = {};
    function i() {
        throw new Error("setTimeout has not been defined")
    }
    function o() {
        throw new Error("clearTimeout has not been defined")
    }
    function s(t) {
        if (n === setTimeout)
            return setTimeout(t, 0);
        if ((n === i || !n) && setTimeout)
            return n = setTimeout,
            setTimeout(t, 0);
        try {
            return n(t, 0)
        } catch (e) {
            try {
                return n.call(null, t, 0)
            } catch (e) {
                return n.call(this, t, 0)
            }
        }
    }
    !function() {
        try {
            n = "function" == typeof setTimeout ? setTimeout : i
        } catch (t) {
            n = i
        }
        try {
            r = "function" == typeof clearTimeout ? clearTimeout : o
        } catch (t) {
            r = o
        }
    }();
    var l, u = [], c = !1, h = -1;
    function d() {
        c && l && (c = !1,
        l.length ? u = l.concat(u) : h = -1,
        u.length && f())
    }
    function f() {
        if (!c) {
            var t = s(d);
            c = !0;
            for (var e = u.length; e; ) {
                for (l = u,
                u = []; ++h < e; )
                    l && l[h].run();
                h = -1,
                e = u.length
            }
            l = null,
            c = !1,
            function(t) {
                if (r === clearTimeout)
                    return clearTimeout(t);
                if ((r === o || !r) && clearTimeout)
                    return r = clearTimeout,
                    clearTimeout(t);
                try {
                    r(t)
                } catch (e) {
                    try {
                        return r.call(null, t)
                    } catch (e) {
                        return r.call(this, t)
                    }
                }
            }(t)
        }
    }
    function p(t, e) {
        this.fun = t,
        this.array = e
    }
    function m() {}
    a.nextTick = function(t) {
        var e = new Array(arguments.length - 1);
        if (arguments.length > 1)
            for (var n = 1; n < arguments.length; n++)
                e[n - 1] = arguments[n];
        u.push(new p(t,e)),
        1 !== u.length || c || s(f)
    }
    ,
    p.prototype.run = function() {
        this.fun.apply(null, this.array)
    }
    ,
    a.title = "browser",
    a.browser = !0,
    a.env = {},
    a.argv = [],
    a.version = "",
    a.versions = {},
    a.on = m,
    a.addListener = m,
    a.once = m,
    a.off = m,
    a.removeListener = m,
    a.removeAllListeners = m,
    a.emit = m,
    a.prependListener = m,
    a.prependOnceListener = m,
    a.listeners = function(t) {
        return []
    }
    ,
    a.binding = function(t) {
        throw new Error("process.binding is not supported")
    }
    ,
    a.cwd = function() {
        return "/"
    }
    ,
    a.chdir = function(t) {
        throw new Error("process.chdir is not supported")
    }
    ,
    a.umask = function() {
        return 0
    }
}
, function(t, e, n) {
    "use strict";
    var r = this && this.__importDefault || function(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    ;
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var a = r(n(24))
      , i = r(n(33))
      , o = n(6);
    e.default = function(t, e, n) {
        void 0 === n && (n = {});
        for (var r = [], s = t[0], l = t[1], u = t[2], c = t[3], h = e / i.default([s, l], [u, l], n) * (u - s), d = e / i.default([s, l], [s, c], n) * (c - l), f = u - s, p = c - l, m = Math.floor(f / h), g = Math.floor(p / d), v = (p - g * d) / 2, y = s + (f - m * h) / 2, _ = 0; _ < m; _++) {
            for (var x = l + v, b = 0; b < g; b++) {
                var w = o.polygon([[[y, x], [y, x + d], [y + h, x + d], [y + h, x], [y, x]]], n.properties);
                n.mask ? a.default(n.mask, w) && r.push(w) : r.push(w),
                x += d
            }
            y += h
        }
        return o.featureCollection(r)
    }
}
, function(t, e, n) {
    "use strict";
    var r = this && this.__importDefault || function(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    ;
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var a = r(n(25))
      , i = n(9);
    e.default = function(t, e) {
        var n = !1;
        return i.flattenEach(t, function(t) {
            i.flattenEach(e, function(e) {
                if (!0 === n)
                    return !0;
                n = !a.default(t.geometry, e.geometry)
            })
        }),
        n
    }
}
, function(t, e, n) {
    "use strict";
    var r = this && this.__importDefault || function(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    ;
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var a = r(n(26))
      , i = r(n(27))
      , o = n(9)
      , s = r(n(32));
    function l(t, e) {
        for (var n = 0; n < t.coordinates.length - 1; n++)
            if (c(t.coordinates[n], t.coordinates[n + 1], e.coordinates))
                return !0;
        return !1
    }
    function u(t, e) {
        for (var n = 0, r = e.coordinates; n < r.length; n++) {
            var o = r[n];
            if (a.default(o, t))
                return !0
        }
        return i.default(e, s.default(t)).features.length > 0
    }
    function c(t, e, n) {
        var r = n[0] - t[0]
          , a = n[1] - t[1]
          , i = e[0] - t[0]
          , o = e[1] - t[1];
        return 0 == r * o - a * i && (Math.abs(i) >= Math.abs(o) ? i > 0 ? t[0] <= n[0] && n[0] <= e[0] : e[0] <= n[0] && n[0] <= t[0] : o > 0 ? t[1] <= n[1] && n[1] <= e[1] : e[1] <= n[1] && n[1] <= t[1])
    }
    e.default = function(t, e) {
        var n = !0;
        return o.flattenEach(t, function(t) {
            o.flattenEach(e, function(e) {
                if (!1 === n)
                    return !1;
                n = function(t, e) {
                    switch (t.type) {
                    case "Point":
                        switch (e.type) {
                        case "Point":
                            return o = t.coordinates,
                            c = e.coordinates,
                            !(o[0] === c[0] && o[1] === c[1]);
                        case "LineString":
                            return !l(e, t);
                        case "Polygon":
                            return !a.default(t, e)
                        }
                        break;
                    case "LineString":
                        switch (e.type) {
                        case "Point":
                            return !l(t, e);
                        case "LineString":
                            return n = t,
                            r = e,
                            !(i.default(n, r).features.length > 0);
                        case "Polygon":
                            return !u(e, t)
                        }
                        break;
                    case "Polygon":
                        switch (e.type) {
                        case "Point":
                            return !a.default(e, t);
                        case "LineString":
                            return !u(t, e);
                        case "Polygon":
                            return !function(t, e) {
                                for (var n = 0, r = t.coordinates[0]; n < r.length; n++) {
                                    var o = r[n];
                                    if (a.default(o, e))
                                        return !0
                                }
                                for (var l = 0, u = e.coordinates[0]; l < u.length; l++) {
                                    var c = u[l];
                                    if (a.default(c, t))
                                        return !0
                                }
                                return i.default(s.default(t), s.default(e)).features.length > 0
                            }(e, t)
                        }
                    }
                    var n, r, o, c;
                    return !1
                }(t.geometry, e.geometry)
            })
        }),
        n
    }
}
, function(t, e, n) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = n(12);
    function a(t, e, n) {
        var r = !1;
        e[0][0] === e[e.length - 1][0] && e[0][1] === e[e.length - 1][1] && (e = e.slice(0, e.length - 1));
        for (var a = 0, i = e.length - 1; a < e.length; i = a++) {
            var o = e[a][0]
              , s = e[a][1]
              , l = e[i][0]
              , u = e[i][1];
            if (t[1] * (o - l) + s * (l - t[0]) + u * (t[0] - o) == 0 && (o - t[0]) * (l - t[0]) <= 0 && (s - t[1]) * (u - t[1]) <= 0)
                return !n;
            s > t[1] != u > t[1] && t[0] < (l - o) * (t[1] - s) / (u - s) + o && (r = !r)
        }
        return r
    }
    e.default = function(t, e, n) {
        if (void 0 === n && (n = {}),
        !t)
            throw new Error("point is required");
        if (!e)
            throw new Error("polygon is required");
        var i = r.getCoord(t)
          , o = r.getGeom(e)
          , s = o.type
          , l = e.bbox
          , u = o.coordinates;
        if (l && !1 === function(t, e) {
            return e[0] <= t[0] && e[1] <= t[1] && e[2] >= t[0] && e[3] >= t[1]
        }(i, l))
            return !1;
        "Polygon" === s && (u = [u]);
        for (var c = !1, h = 0; h < u.length && !c; h++)
            if (a(i, u[h][0], n.ignoreBoundary)) {
                for (var d = !1, f = 1; f < u[h].length && !d; )
                    a(i, u[h][f], !n.ignoreBoundary) && (d = !0),
                    f++;
                d || (c = !0)
            }
        return c
    }
}
, function(t, e, n) {
    "use strict";
    var r = this && this.__importDefault || function(t) {
        return t && t.__esModule ? t : {
            default: t
        }
    }
    ;
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var a = n(6)
      , i = n(12)
      , o = r(n(28))
      , s = n(9)
      , l = r(n(29));
    function u(t, e) {
        var n = i.getCoords(t)
          , r = i.getCoords(e);
        if (2 !== n.length)
            throw new Error("<intersects> line1 must only contain 2 coordinates");
        if (2 !== r.length)
            throw new Error("<intersects> line2 must only contain 2 coordinates");
        var o = n[0][0]
          , s = n[0][1]
          , l = n[1][0]
          , u = n[1][1]
          , c = r[0][0]
          , h = r[0][1]
          , d = r[1][0]
          , f = r[1][1]
          , p = (f - h) * (l - o) - (d - c) * (u - s)
          , m = (d - c) * (s - h) - (f - h) * (o - c)
          , g = (l - o) * (s - h) - (u - s) * (o - c);
        if (0 === p)
            return null;
        var v = m / p
          , y = g / p;
        if (v >= 0 && v <= 1 && y >= 0 && y <= 1) {
            var _ = o + v * (l - o)
              , x = s + v * (u - s);
            return a.point([_, x])
        }
        return null
    }
    e.default = function(t, e) {
        var n = {}
          , r = [];
        if ("LineString" === t.type && (t = a.feature(t)),
        "LineString" === e.type && (e = a.feature(e)),
        "Feature" === t.type && "Feature" === e.type && null !== t.geometry && null !== e.geometry && "LineString" === t.geometry.type && "LineString" === e.geometry.type && 2 === t.geometry.coordinates.length && 2 === e.geometry.coordinates.length) {
            var c = u(t, e);
            return c && r.push(c),
            a.featureCollection(r)
        }
        var h = l.default();
        return h.load(o.default(e)),
        s.featureEach(o.default(t), function(t) {
            s.featureEach(h.search(t), function(e) {
                var a = u(t, e);
                if (a) {
                    var o = i.getCoords(a).join(",");
                    n[o] || (n[o] = !0,
                    r.push(a))
                }
            })
        }),
        a.featureCollection(r)
    }
}
, function(t, e, n) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = n(6)
      , a = n(12)
      , i = n(9);
    e.default = function(t) {
        if (!t)
            throw new Error("geojson is required");
        var e = [];
        return i.flattenEach(t, function(t) {
            !function(t, e) {
                var n = []
                  , i = t.geometry;
                if (null !== i) {
                    switch (i.type) {
                    case "Polygon":
                        n = a.getCoords(i);
                        break;
                    case "LineString":
                        n = [a.getCoords(i)]
                    }
                    n.forEach(function(n) {
                        var a = function(t, e) {
                            var n = [];
                            return t.reduce(function(t, a) {
                                var i, o, s, l, u, c, h = r.lineString([t, a], e);
                                return h.bbox = (o = a,
                                s = (i = t)[0],
                                l = i[1],
                                u = o[0],
                                c = o[1],
                                [s < u ? s : u, l < c ? l : c, s > u ? s : u, l > c ? l : c]),
                                n.push(h),
                                a
                            }),
                            n
                        }(n, t.properties);
                        a.forEach(function(t) {
                            t.id = e.length,
                            e.push(t)
                        })
                    })
                }
            }(t, e)
        }),
        r.featureCollection(e)
    }
}
, function(t, e, n) {
    var r = n(30)
      , a = n(6)
      , i = n(9)
      , o = n(16).default
      , s = i.featureEach
      , l = (i.coordEach,
    a.polygon,
    a.featureCollection);
    function u(t) {
        var e = r(t);
        return e.insert = function(t) {
            if ("Feature" !== t.type)
                throw new Error("invalid feature");
            return t.bbox = t.bbox ? t.bbox : o(t),
            r.prototype.insert.call(this, t)
        }
        ,
        e.load = function(t) {
            var e = [];
            return Array.isArray(t) ? t.forEach(function(t) {
                if ("Feature" !== t.type)
                    throw new Error("invalid features");
                t.bbox = t.bbox ? t.bbox : o(t),
                e.push(t)
            }) : s(t, function(t) {
                if ("Feature" !== t.type)
                    throw new Error("invalid features");
                t.bbox = t.bbox ? t.bbox : o(t),
                e.push(t)
            }),
            r.prototype.load.call(this, e)
        }
        ,
        e.remove = function(t, e) {
            if ("Feature" !== t.type)
                throw new Error("invalid feature");
            return t.bbox = t.bbox ? t.bbox : o(t),
            r.prototype.remove.call(this, t, e)
        }
        ,
        e.clear = function() {
            return r.prototype.clear.call(this)
        }
        ,
        e.search = function(t) {
            var e = r.prototype.search.call(this, this.toBBox(t));
            return l(e)
        }
        ,
        e.collides = function(t) {
            return r.prototype.collides.call(this, this.toBBox(t))
        }
        ,
        e.all = function() {
            var t = r.prototype.all.call(this);
            return l(t)
        }
        ,
        e.toJSON = function() {
            return r.prototype.toJSON.call(this)
        }
        ,
        e.fromJSON = function(t) {
            return r.prototype.fromJSON.call(this, t)
        }
        ,
        e.toBBox = function(t) {
            var e;
            if (t.bbox)
                e = t.bbox;
            else if (Array.isArray(t) && 4 === t.length)
                e = t;
            else if (Array.isArray(t) && 6 === t.length)
                e = [t[0], t[1], t[3], t[4]];
            else if ("Feature" === t.type)
                e = o(t);
            else {
                if ("FeatureCollection" !== t.type)
                    throw new Error("invalid geojson");
                e = o(t)
            }
            return {
                minX: e[0],
                minY: e[1],
                maxX: e[2],
                maxY: e[3]
            }
        }
        ,
        e
    }
    t.exports = u,
    t.exports.default = u
}
, function(t, e, n) {
    "use strict";
    t.exports = a,
    t.exports.default = a;
    var r = n(31);
    function a(t, e) {
        if (!(this instanceof a))
            return new a(t,e);
        this._maxEntries = Math.max(4, t || 9),
        this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)),
        e && this._initFormat(e),
        this.clear()
    }
    function i(t, e, n) {
        if (!n)
            return e.indexOf(t);
        for (var r = 0; r < e.length; r++)
            if (n(t, e[r]))
                return r;
        return -1
    }
    function o(t, e) {
        s(t, 0, t.children.length, e, t)
    }
    function s(t, e, n, r, a) {
        a || (a = m(null)),
        a.minX = 1 / 0,
        a.minY = 1 / 0,
        a.maxX = -1 / 0,
        a.maxY = -1 / 0;
        for (var i, o = e; o < n; o++)
            i = t.children[o],
            l(a, t.leaf ? r(i) : i);
        return a
    }
    function l(t, e) {
        return t.minX = Math.min(t.minX, e.minX),
        t.minY = Math.min(t.minY, e.minY),
        t.maxX = Math.max(t.maxX, e.maxX),
        t.maxY = Math.max(t.maxY, e.maxY),
        t
    }
    function u(t, e) {
        return t.minX - e.minX
    }
    function c(t, e) {
        return t.minY - e.minY
    }
    function h(t) {
        return (t.maxX - t.minX) * (t.maxY - t.minY)
    }
    function d(t) {
        return t.maxX - t.minX + (t.maxY - t.minY)
    }
    function f(t, e) {
        return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY
    }
    function p(t, e) {
        return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY
    }
    function m(t) {
        return {
            children: t,
            height: 1,
            leaf: !0,
            minX: 1 / 0,
            minY: 1 / 0,
            maxX: -1 / 0,
            maxY: -1 / 0
        }
    }
    function g(t, e, n, a, i) {
        for (var o, s = [e, n]; s.length; )
            (n = s.pop()) - (e = s.pop()) <= a || (o = e + Math.ceil((n - e) / a / 2) * a,
            r(t, o, e, n, i),
            s.push(e, o, o, n))
    }
    a.prototype = {
        all: function() {
            return this._all(this.data, [])
        },
        search: function(t) {
            var e = this.data
              , n = []
              , r = this.toBBox;
            if (!p(t, e))
                return n;
            for (var a, i, o, s, l = []; e; ) {
                for (a = 0,
                i = e.children.length; a < i; a++)
                    o = e.children[a],
                    p(t, s = e.leaf ? r(o) : o) && (e.leaf ? n.push(o) : f(t, s) ? this._all(o, n) : l.push(o));
                e = l.pop()
            }
            return n
        },
        collides: function(t) {
            var e = this.data
              , n = this.toBBox;
            if (!p(t, e))
                return !1;
            for (var r, a, i, o, s = []; e; ) {
                for (r = 0,
                a = e.children.length; r < a; r++)
                    if (i = e.children[r],
                    p(t, o = e.leaf ? n(i) : i)) {
                        if (e.leaf || f(t, o))
                            return !0;
                        s.push(i)
                    }
                e = s.pop()
            }
            return !1
        },
        load: function(t) {
            if (!t || !t.length)
                return this;
            if (t.length < this._minEntries) {
                for (var e = 0, n = t.length; e < n; e++)
                    this.insert(t[e]);
                return this
            }
            var r = this._build(t.slice(), 0, t.length - 1, 0);
            if (this.data.children.length)
                if (this.data.height === r.height)
                    this._splitRoot(this.data, r);
                else {
                    if (this.data.height < r.height) {
                        var a = this.data;
                        this.data = r,
                        r = a
                    }
                    this._insert(r, this.data.height - r.height - 1, !0)
                }
            else
                this.data = r;
            return this
        },
        insert: function(t) {
            return t && this._insert(t, this.data.height - 1),
            this
        },
        clear: function() {
            return this.data = m([]),
            this
        },
        remove: function(t, e) {
            if (!t)
                return this;
            for (var n, r, a, o, s = this.data, l = this.toBBox(t), u = [], c = []; s || u.length; ) {
                if (s || (s = u.pop(),
                r = u[u.length - 1],
                n = c.pop(),
                o = !0),
                s.leaf && -1 !== (a = i(t, s.children, e)))
                    return s.children.splice(a, 1),
                    u.push(s),
                    this._condense(u),
                    this;
                o || s.leaf || !f(s, l) ? r ? (n++,
                s = r.children[n],
                o = !1) : s = null : (u.push(s),
                c.push(n),
                n = 0,
                r = s,
                s = s.children[0])
            }
            return this
        },
        toBBox: function(t) {
            return t
        },
        compareMinX: u,
        compareMinY: c,
        toJSON: function() {
            return this.data
        },
        fromJSON: function(t) {
            return this.data = t,
            this
        },
        _all: function(t, e) {
            for (var n = []; t; )
                t.leaf ? e.push.apply(e, t.children) : n.push.apply(n, t.children),
                t = n.pop();
            return e
        },
        _build: function(t, e, n, r) {
            var a, i = n - e + 1, s = this._maxEntries;
            if (i <= s)
                return o(a = m(t.slice(e, n + 1)), this.toBBox),
                a;
            r || (r = Math.ceil(Math.log(i) / Math.log(s)),
            s = Math.ceil(i / Math.pow(s, r - 1))),
            (a = m([])).leaf = !1,
            a.height = r;
            var l, u, c, h, d = Math.ceil(i / s), f = d * Math.ceil(Math.sqrt(s));
            for (g(t, e, n, f, this.compareMinX),
            l = e; l <= n; l += f)
                for (g(t, l, c = Math.min(l + f - 1, n), d, this.compareMinY),
                u = l; u <= c; u += d)
                    h = Math.min(u + d - 1, c),
                    a.children.push(this._build(t, u, h, r - 1));
            return o(a, this.toBBox),
            a
        },
        _chooseSubtree: function(t, e, n, r) {
            for (var a, i, o, s, l, u, c, d, f, p; r.push(e),
            !e.leaf && r.length - 1 !== n; ) {
                for (c = d = 1 / 0,
                a = 0,
                i = e.children.length; a < i; a++)
                    l = h(o = e.children[a]),
                    f = t,
                    p = o,
                    (u = (Math.max(p.maxX, f.maxX) - Math.min(p.minX, f.minX)) * (Math.max(p.maxY, f.maxY) - Math.min(p.minY, f.minY)) - l) < d ? (d = u,
                    c = l < c ? l : c,
                    s = o) : u === d && l < c && (c = l,
                    s = o);
                e = s || e.children[0]
            }
            return e
        },
        _insert: function(t, e, n) {
            var r = this.toBBox
              , a = n ? t : r(t)
              , i = []
              , o = this._chooseSubtree(a, this.data, e, i);
            for (o.children.push(t),
            l(o, a); e >= 0 && i[e].children.length > this._maxEntries; )
                this._split(i, e),
                e--;
            this._adjustParentBBoxes(a, i, e)
        },
        _split: function(t, e) {
            var n = t[e]
              , r = n.children.length
              , a = this._minEntries;
            this._chooseSplitAxis(n, a, r);
            var i = this._chooseSplitIndex(n, a, r)
              , s = m(n.children.splice(i, n.children.length - i));
            s.height = n.height,
            s.leaf = n.leaf,
            o(n, this.toBBox),
            o(s, this.toBBox),
            e ? t[e - 1].children.push(s) : this._splitRoot(n, s)
        },
        _splitRoot: function(t, e) {
            this.data = m([t, e]),
            this.data.height = t.height + 1,
            this.data.leaf = !1,
            o(this.data, this.toBBox)
        },
        _chooseSplitIndex: function(t, e, n) {
            var r, a, i, o, l, u, c, d, f, p, m, g, v, y;
            for (u = c = 1 / 0,
            r = e; r <= n - e; r++)
                a = s(t, 0, r, this.toBBox),
                i = s(t, r, n, this.toBBox),
                f = a,
                p = i,
                m = void 0,
                g = void 0,
                v = void 0,
                y = void 0,
                m = Math.max(f.minX, p.minX),
                g = Math.max(f.minY, p.minY),
                v = Math.min(f.maxX, p.maxX),
                y = Math.min(f.maxY, p.maxY),
                o = Math.max(0, v - m) * Math.max(0, y - g),
                l = h(a) + h(i),
                o < u ? (u = o,
                d = r,
                c = l < c ? l : c) : o === u && l < c && (c = l,
                d = r);
            return d
        },
        _chooseSplitAxis: function(t, e, n) {
            var r = t.leaf ? this.compareMinX : u
              , a = t.leaf ? this.compareMinY : c;
            this._allDistMargin(t, e, n, r) < this._allDistMargin(t, e, n, a) && t.children.sort(r)
        },
        _allDistMargin: function(t, e, n, r) {
            t.children.sort(r);
            var a, i, o = this.toBBox, u = s(t, 0, e, o), c = s(t, n - e, n, o), h = d(u) + d(c);
            for (a = e; a < n - e; a++)
                i = t.children[a],
                l(u, t.leaf ? o(i) : i),
                h += d(u);
            for (a = n - e - 1; a >= e; a--)
                i = t.children[a],
                l(c, t.leaf ? o(i) : i),
                h += d(c);
            return h
        },
        _adjustParentBBoxes: function(t, e, n) {
            for (var r = n; r >= 0; r--)
                l(e[r], t)
        },
        _condense: function(t) {
            for (var e, n = t.length - 1; n >= 0; n--)
                0 === t[n].children.length ? n > 0 ? (e = t[n - 1].children).splice(e.indexOf(t[n]), 1) : this.clear() : o(t[n], this.toBBox)
        },
        _initFormat: function(t) {
            var e = ["return a", " - b", ";"];
            this.compareMinX = new Function("a","b",e.join(t[0])),
            this.compareMinY = new Function("a","b",e.join(t[1])),
            this.toBBox = new Function("a","return {minX: a" + t[0] + ", minY: a" + t[1] + ", maxX: a" + t[2] + ", maxY: a" + t[3] + "};")
        }
    }
}
, function(t, e, n) {
    t.exports = function() {
        "use strict";
        function t(t, e, n) {
            var r = t[e];
            t[e] = t[n],
            t[n] = r
        }
        function e(t, e) {
            return t < e ? -1 : t > e ? 1 : 0
        }
        return function(n, r, a, i, o) {
            !function e(n, r, a, i, o) {
                for (; i > a; ) {
                    if (i - a > 600) {
                        var s = i - a + 1
                          , l = r - a + 1
                          , u = Math.log(s)
                          , c = .5 * Math.exp(2 * u / 3)
                          , h = .5 * Math.sqrt(u * c * (s - c) / s) * (l - s / 2 < 0 ? -1 : 1)
                          , d = Math.max(a, Math.floor(r - l * c / s + h))
                          , f = Math.min(i, Math.floor(r + (s - l) * c / s + h));
                        e(n, r, d, f, o)
                    }
                    var p = n[r]
                      , m = a
                      , g = i;
                    for (t(n, a, r),
                    o(n[i], p) > 0 && t(n, a, i); m < g; ) {
                        for (t(n, m, g),
                        m++,
                        g--; o(n[m], p) < 0; )
                            m++;
                        for (; o(n[g], p) > 0; )
                            g--
                    }
                    0 === o(n[a], p) ? t(n, a, g) : t(n, ++g, i),
                    g <= r && (a = g + 1),
                    r <= g && (i = g - 1)
                }
            }(n, r, a || 0, i || n.length - 1, o || e)
        }
    }()
}
, function(t, e, n) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = n(6)
      , a = n(12);
    function i(t, e) {
        void 0 === e && (e = {});
        var n = a.getGeom(t);
        n.type;
        return s(n.coordinates, e.properties ? e.properties : "Feature" === t.type ? t.properties : {})
    }
    function o(t, e) {
        void 0 === e && (e = {});
        var n = a.getGeom(t)
          , i = (n.type,
        n.coordinates)
          , o = e.properties ? e.properties : "Feature" === t.type ? t.properties : {}
          , l = [];
        return i.forEach(function(t) {
            l.push(s(t, o))
        }),
        r.featureCollection(l)
    }
    function s(t, e) {
        return t.length > 1 ? r.multiLineString(t, e) : r.lineString(t[0], e)
    }
    e.default = function(t, e) {
        void 0 === e && (e = {});
        var n = a.getGeom(t);
        switch (e.properties || "Feature" !== t.type || (e.properties = t.properties),
        n.type) {
        case "Polygon":
            return i(n, e);
        case "MultiPolygon":
            return o(n, e);
        default:
            throw new Error("invalid poly")
        }
    }
    ,
    e.polygonToLine = i,
    e.multiPolygonToLine = o,
    e.coordsToLine = s
}
, function(t, e, n) {
    "use strict";
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    var r = n(12)
      , a = n(6);
    e.default = function(t, e, n) {
        void 0 === n && (n = {});
        var i = r.getCoord(t)
          , o = r.getCoord(e)
          , s = a.degreesToRadians(o[1] - i[1])
          , l = a.degreesToRadians(o[0] - i[0])
          , u = a.degreesToRadians(i[1])
          , c = a.degreesToRadians(o[1])
          , h = Math.pow(Math.sin(s / 2), 2) + Math.pow(Math.sin(l / 2), 2) * Math.cos(u) * Math.cos(c);
        return a.radiansToLength(2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h)), n.units)
    }
}
, function(t, e, n) {
    var r;
    t.exports = (r = n(3),
    n(13),
    n(35),
    n(36),
    n(10),
    n(11),
    n(14),
    n(18),
    n(37),
    n(19),
    n(38),
    n(39),
    n(40),
    n(15),
    n(41),
    n(8),
    n(5),
    n(42),
    n(43),
    n(44),
    n(45),
    n(46),
    n(47),
    n(48),
    n(49),
    n(50),
    n(51),
    n(52),
    n(53),
    n(54),
    n(55),
    n(56),
    n(57),
    r)
}
, function(t, e, n) {
    var r;
    t.exports = (r = n(3),
    function() {
        if ("function" == typeof ArrayBuffer) {
            var t = r.lib.WordArray
              , e = t.init;
            (t.init = function(t) {
                if (t instanceof ArrayBuffer && (t = new Uint8Array(t)),
                (t instanceof Int8Array || "undefined" != typeof Uint8ClampedArray && t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array || t instanceof Float64Array) && (t = new Uint8Array(t.buffer,t.byteOffset,t.byteLength)),
                t instanceof Uint8Array) {
                    for (var n = t.byteLength, r = [], a = 0; a < n; a++)
                        r[a >>> 2] |= t[a] << 24 - a % 4 * 8;
                    e.call(this, r, n)
                } else
                    e.apply(this, arguments)
            }
            ).prototype = t
        }
    }(),
    r.lib.WordArray)
}
, function(t, e, n) {
    var r;
    t.exports = (r = n(3),
    function() {
        var t = r
          , e = t.lib.WordArray
          , n = t.enc;
        function a(t) {
            return t << 8 & 4278255360 | t >>> 8 & 16711935
        }
        n.Utf16 = n.Utf16BE = {
            stringify: function(t) {
                for (var e = t.words, n = t.sigBytes, r = [], a = 0; a < n; a += 2) {
                    var i = e[a >>> 2] >>> 16 - a % 4 * 8 & 65535;
                    r.push(String.fromCharCode(i))
                }
                return r.join("")
            },
            parse: function(t) {
                for (var n = t.length, r = [], a = 0; a < n; a++)
                    r[a >>> 1] |= t.charCodeAt(a) << 16 - a % 2 * 16;
                return e.create(r, 2 * n)
            }
        },
        n.Utf16LE = {
            stringify: function(t) {
                for (var e = t.words, n = t.sigBytes, r = [], i = 0; i < n; i += 2) {
                    var o = a(e[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
                    r.push(String.fromCharCode(o))
                }
                return r.join("")
            },
            parse: function(t) {
                for (var n = t.length, r = [], i = 0; i < n; i++)
                    r[i >>> 1] |= a(t.charCodeAt(i) << 16 - i % 2 * 16);
                return e.create(r, 2 * n)
            }
        }
    }(),
    r.enc.Utf16)
}
, function(t, e, n) {
    var r, a, i, o, s, l;
    t.exports = (r = n(3),
    n(18),
    i = (a = r).lib.WordArray,
    o = a.algo,
    s = o.SHA256,
    l = o.SHA224 = s.extend({
        _doReset: function() {
            this._hash = new i.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428])
        },
        _doFinalize: function() {
            var t = s._doFinalize.call(this);
            return t.sigBytes -= 4,
            t
        }
    }),
    a.SHA224 = s._createHelper(l),
    a.HmacSHA224 = s._createHmacHelper(l),
    r.SHA224)
}
, function(t, e, n) {
    var r, a, i, o, s, l, u, c;
    t.exports = (r = n(3),
    n(13),
    n(19),
    i = (a = r).x64,
    o = i.Word,
    s = i.WordArray,
    l = a.algo,
    u = l.SHA512,
    c = l.SHA384 = u.extend({
        _doReset: function() {
            this._hash = new s.init([new o.init(3418070365,3238371032), new o.init(1654270250,914150663), new o.init(2438529370,812702999), new o.init(355462360,4144912697), new o.init(1731405415,4290775857), new o.init(2394180231,1750603025), new o.init(3675008525,1694076839), new o.init(1203062813,3204075428)])
        },
        _doFinalize: function() {
            var t = u._doFinalize.call(this);
            return t.sigBytes -= 16,
            t
        }
    }),
    a.SHA384 = u._createHelper(c),
    a.HmacSHA384 = u._createHmacHelper(c),
    r.SHA384)
}
, function(t, e, n) {
    var r;
    t.exports = (r = n(3),
    n(13),
    function(t) {
        var e = r
          , n = e.lib
          , a = n.WordArray
          , i = n.Hasher
          , o = e.x64.Word
          , s = e.algo
          , l = []
          , u = []
          , c = [];
        !function() {
            for (var t = 1, e = 0, n = 0; n < 24; n++) {
                l[t + 5 * e] = (n + 1) * (n + 2) / 2 % 64;
                var r = (2 * t + 3 * e) % 5;
                t = e % 5,
                e = r
            }
            for (t = 0; t < 5; t++)
                for (e = 0; e < 5; e++)
                    u[t + 5 * e] = e + (2 * t + 3 * e) % 5 * 5;
            for (var a = 1, i = 0; i < 24; i++) {
                for (var s = 0, h = 0, d = 0; d < 7; d++) {
                    if (1 & a) {
                        var f = (1 << d) - 1;
                        f < 32 ? h ^= 1 << f : s ^= 1 << f - 32
                    }
                    128 & a ? a = a << 1 ^ 113 : a <<= 1
                }
                c[i] = o.create(s, h)
            }
        }();
        var h = [];
        !function() {
            for (var t = 0; t < 25; t++)
                h[t] = o.create()
        }();
        var d = s.SHA3 = i.extend({
            cfg: i.cfg.extend({
                outputLength: 512
            }),
            _doReset: function() {
                for (var t = this._state = [], e = 0; e < 25; e++)
                    t[e] = new o.init;
                this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32
            },
            _doProcessBlock: function(t, e) {
                for (var n = this._state, r = this.blockSize / 2, a = 0; a < r; a++) {
                    var i = t[e + 2 * a]
                      , o = t[e + 2 * a + 1];
                    i = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8),
                    o = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8),
                    (P = n[a]).high ^= o,
                    P.low ^= i
                }
                for (var s = 0; s < 24; s++) {
                    for (var d = 0; d < 5; d++) {
                        for (var f = 0, p = 0, m = 0; m < 5; m++)
                            f ^= (P = n[d + 5 * m]).high,
                            p ^= P.low;
                        var g = h[d];
                        g.high = f,
                        g.low = p
                    }
                    for (d = 0; d < 5; d++) {
                        var v = h[(d + 4) % 5]
                          , y = h[(d + 1) % 5]
                          , _ = y.high
                          , x = y.low;
                        for (f = v.high ^ (_ << 1 | x >>> 31),
                        p = v.low ^ (x << 1 | _ >>> 31),
                        m = 0; m < 5; m++)
                            (P = n[d + 5 * m]).high ^= f,
                            P.low ^= p
                    }
                    for (var b = 1; b < 25; b++) {
                        var w = (P = n[b]).high
                          , C = P.low
                          , E = l[b];
                        E < 32 ? (f = w << E | C >>> 32 - E,
                        p = C << E | w >>> 32 - E) : (f = C << E - 32 | w >>> 64 - E,
                        p = w << E - 32 | C >>> 64 - E);
                        var T = h[u[b]];
                        T.high = f,
                        T.low = p
                    }
                    var M = h[0]
                      , A = n[0];
                    for (M.high = A.high,
                    M.low = A.low,
                    d = 0; d < 5; d++)
                        for (m = 0; m < 5; m++) {
                            var P = n[b = d + 5 * m]
                              , S = h[b]
                              , R = h[(d + 1) % 5 + 5 * m]
                              , D = h[(d + 2) % 5 + 5 * m];
                            P.high = S.high ^ ~R.high & D.high,
                            P.low = S.low ^ ~R.low & D.low
                        }
                    P = n[0];
                    var j = c[s];
                    P.high ^= j.high,
                    P.low ^= j.low
                }
            },
            _doFinalize: function() {
                var e = this._data
                  , n = e.words
                  , r = (this._nDataBytes,
                8 * e.sigBytes)
                  , i = 32 * this.blockSize;
                n[r >>> 5] |= 1 << 24 - r % 32,
                n[(t.ceil((r + 1) / i) * i >>> 5) - 1] |= 128,
                e.sigBytes = 4 * n.length,
                this._process();
                for (var o = this._state, s = this.cfg.outputLength / 8, l = s / 8, u = [], c = 0; c < l; c++) {
                    var h = o[c]
                      , d = h.high
                      , f = h.low;
                    d = 16711935 & (d << 8 | d >>> 24) | 4278255360 & (d << 24 | d >>> 8),
                    f = 16711935 & (f << 8 | f >>> 24) | 4278255360 & (f << 24 | f >>> 8),
                    u.push(f),
                    u.push(d)
                }
                return new a.init(u,s)
            },
            clone: function() {
                for (var t = i.clone.call(this), e = t._state = this._state.slice(0), n = 0; n < 25; n++)
                    e[n] = e[n].clone();
                return t
            }
        });
        e.SHA3 = i._createHelper(d),
        e.HmacSHA3 = i._createHmacHelper(d)
    }(Math),
    r.SHA3)
}
, function(t, e, n) {
    var r;
    t.exports = (r = n(3),
    /** @preserve
	(c) 2012 by Cédric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
    function(t) {
        var e = r
          , n = e.lib
          , a = n.WordArray
          , i = n.Hasher
          , o = e.algo
          , s = a.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13])
          , l = a.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11])
          , u = a.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6])
          , c = a.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11])
          , h = a.create([0, 1518500249, 1859775393, 2400959708, 2840853838])
          , d = a.create([1352829926, 1548603684, 1836072691, 2053994217, 0])
          , f = o.RIPEMD160 = i.extend({
            _doReset: function() {
                this._hash = a.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
            },
            _doProcessBlock: function(t, e) {
                for (var n = 0; n < 16; n++) {
                    var r = e + n
                      , a = t[r];
                    t[r] = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8)
                }
                var i, o, f, x, b, w, C, E, T, M, A, P = this._hash.words, S = h.words, R = d.words, D = s.words, j = l.words, L = u.words, I = c.words;
                for (w = i = P[0],
                C = o = P[1],
                E = f = P[2],
                T = x = P[3],
                M = b = P[4],
                n = 0; n < 80; n += 1)
                    A = i + t[e + D[n]] | 0,
                    A += n < 16 ? p(o, f, x) + S[0] : n < 32 ? m(o, f, x) + S[1] : n < 48 ? g(o, f, x) + S[2] : n < 64 ? v(o, f, x) + S[3] : y(o, f, x) + S[4],
                    A = (A = _(A |= 0, L[n])) + b | 0,
                    i = b,
                    b = x,
                    x = _(f, 10),
                    f = o,
                    o = A,
                    A = w + t[e + j[n]] | 0,
                    A += n < 16 ? y(C, E, T) + R[0] : n < 32 ? v(C, E, T) + R[1] : n < 48 ? g(C, E, T) + R[2] : n < 64 ? m(C, E, T) + R[3] : p(C, E, T) + R[4],
                    A = (A = _(A |= 0, I[n])) + M | 0,
                    w = M,
                    M = T,
                    T = _(E, 10),
                    E = C,
                    C = A;
                A = P[1] + f + T | 0,
                P[1] = P[2] + x + M | 0,
                P[2] = P[3] + b + w | 0,
                P[3] = P[4] + i + C | 0,
                P[4] = P[0] + o + E | 0,
                P[0] = A
            },
            _doFinalize: function() {
                var t = this._data
                  , e = t.words
                  , n = 8 * this._nDataBytes
                  , r = 8 * t.sigBytes;
                e[r >>> 5] |= 128 << 24 - r % 32,
                e[14 + (r + 64 >>> 9 << 4)] = 16711935 & (n << 8 | n >>> 24) | 4278255360 & (n << 24 | n >>> 8),
                t.sigBytes = 4 * (e.length + 1),
                this._process();
                for (var a = this._hash, i = a.words, o = 0; o < 5; o++) {
                    var s = i[o];
                    i[o] = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8)
                }
                return a
            },
            clone: function() {
                var t = i.clone.call(this);
                return t._hash = this._hash.clone(),
                t
            }
        });
        function p(t, e, n) {
            return t ^ e ^ n
        }
        function m(t, e, n) {
            return t & e | ~t & n
        }
        function g(t, e, n) {
            return (t | ~e) ^ n
        }
        function v(t, e, n) {
            return t & n | e & ~n
        }
        function y(t, e, n) {
            return t ^ (e | ~n)
        }
        function _(t, e) {
            return t << e | t >>> 32 - e
        }
        e.RIPEMD160 = i._createHelper(f),
        e.HmacRIPEMD160 = i._createHmacHelper(f)
    }(Math),
    r.RIPEMD160)
}
, function(t, e, n) {
    var r, a, i, o, s, l, u, c, h;
    t.exports = (r = n(3),
    n(14),
    n(15),
    i = (a = r).lib,
    o = i.Base,
    s = i.WordArray,
    l = a.algo,
    u = l.SHA1,
    c = l.HMAC,
    h = l.PBKDF2 = o.extend({
        cfg: o.extend({
            keySize: 4,
            hasher: u,
            iterations: 1
        }),
        init: function(t) {
            this.cfg = this.cfg.extend(t)
        },
        compute: function(t, e) {
            for (var n = this.cfg, r = c.create(n.hasher, t), a = s.create(), i = s.create([1]), o = a.words, l = i.words, u = n.keySize, h = n.iterations; o.length < u; ) {
                var d = r.update(e).finalize(i);
                r.reset();
                for (var f = d.words, p = f.length, m = d, g = 1; g < h; g++) {
                    m = r.finalize(m),
                    r.reset();
                    for (var v = m.words, y = 0; y < p; y++)
                        f[y] ^= v[y]
                }
                a.concat(d),
                l[0]++
            }
            return a.sigBytes = 4 * u,
            a
        }
    }),
    a.PBKDF2 = function(t, e, n) {
        return h.create(n).compute(t, e)
    }
    ,
    r.PBKDF2)
}
, function(t, e, n) {
    var r;
    t.exports = (r = n(3),
    n(5),
    r.mode.CFB = function() {
        var t = r.lib.BlockCipherMode.extend();
        function e(t, e, n, r) {
            var a = this._iv;
            if (a) {
                var i = a.slice(0);
                this._iv = void 0
            } else
                i = this._prevBlock;
            r.encryptBlock(i, 0);
            for (var o = 0; o < n; o++)
                t[e + o] ^= i[o]
        }
        return t.Encryptor = t.extend({
            processBlock: function(t, n) {
                var r = this._cipher
                  , a = r.blockSize;
                e.call(this, t, n, a, r),
                this._prevBlock = t.slice(n, n + a)
            }
        }),
        t.Decryptor = t.extend({
            processBlock: function(t, n) {
                var r = this._cipher
                  , a = r.blockSize
                  , i = t.slice(n, n + a);
                e.call(this, t, n, a, r),
                this._prevBlock = i
            }
        }),
        t
    }(),
    r.mode.CFB)
}
, function(t, e, n) {
    var r, a, i;
    t.exports = (r = n(3),
    n(5),
    r.mode.CTR = (a = r.lib.BlockCipherMode.extend(),
    i = a.Encryptor = a.extend({
        processBlock: function(t, e) {
            var n = this._cipher
              , r = n.blockSize
              , a = this._iv
              , i = this._counter;
            a && (i = this._counter = a.slice(0),
            this._iv = void 0);
            var o = i.slice(0);
            n.encryptBlock(o, 0),
            i[r - 1] = i[r - 1] + 1 | 0;
            for (var s = 0; s < r; s++)
                t[e + s] ^= o[s]
        }
    }),
    a.Decryptor = i,
    a),
    r.mode.CTR)
}
, function(t, e, n) {
    var r;
    t.exports = (r = n(3),
    n(5),
    /** @preserve
	 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
	 * derived from CryptoJS.mode.CTR
	 * Jan Hruby jhruby.web@gmail.com
	 */
    r.mode.CTRGladman = function() {
        var t = r.lib.BlockCipherMode.extend();
        function e(t) {
            if (255 == (t >> 24 & 255)) {
                var e = t >> 16 & 255
                  , n = t >> 8 & 255
                  , r = 255 & t;
                255 === e ? (e = 0,
                255 === n ? (n = 0,
                255 === r ? r = 0 : ++r) : ++n) : ++e,
                t = 0,
                t += e << 16,
                t += n << 8,
                t += r
            } else
                t += 1 << 24;
            return t
        }
        var n = t.Encryptor = t.extend({
            processBlock: function(t, n) {
                var r = this._cipher
                  , a = r.blockSize
                  , i = this._iv
                  , o = this._counter;
                i && (o = this._counter = i.slice(0),
                this._iv = void 0),
                function(t) {
                    0 === (t[0] = e(t[0])) && (t[1] = e(t[1]))
                }(o);
                var s = o.slice(0);
                r.encryptBlock(s, 0);
                for (var l = 0; l < a; l++)
                    t[n + l] ^= s[l]
            }
        });
        return t.Decryptor = n,
        t
    }(),
    r.mode.CTRGladman)
}
, function(t, e, n) {
    var r, a, i;
    t.exports = (r = n(3),
    n(5),
    r.mode.OFB = (a = r.lib.BlockCipherMode.extend(),
    i = a.Encryptor = a.extend({
        processBlock: function(t, e) {
            var n = this._cipher
              , r = n.blockSize
              , a = this._iv
              , i = this._keystream;
            a && (i = this._keystream = a.slice(0),
            this._iv = void 0),
            n.encryptBlock(i, 0);
            for (var o = 0; o < r; o++)
                t[e + o] ^= i[o]
        }
    }),
    a.Decryptor = i,
    a),
    r.mode.OFB)
}
, function(t, e, n) {
    var r, a;
    t.exports = (r = n(3),
    n(5),
    r.mode.ECB = ((a = r.lib.BlockCipherMode.extend()).Encryptor = a.extend({
        processBlock: function(t, e) {
            this._cipher.encryptBlock(t, e)
        }
    }),
    a.Decryptor = a.extend({
        processBlock: function(t, e) {
            this._cipher.decryptBlock(t, e)
        }
    }),
    a),
    r.mode.ECB)
}
, function(t, e, n) {
    var r;
    t.exports = (r = n(3),
    n(5),
    r.pad.AnsiX923 = {
        pad: function(t, e) {
            var n = t.sigBytes
              , r = 4 * e
              , a = r - n % r
              , i = n + a - 1;
            t.clamp(),
            t.words[i >>> 2] |= a << 24 - i % 4 * 8,
            t.sigBytes += a
        },
        unpad: function(t) {
            var e = 255 & t.words[t.sigBytes - 1 >>> 2];
            t.sigBytes -= e
        }
    },
    r.pad.Ansix923)
}
, function(t, e, n) {
    var r;
    t.exports = (r = n(3),
    n(5),
    r.pad.Iso10126 = {
        pad: function(t, e) {
            var n = 4 * e
              , a = n - t.sigBytes % n;
            t.concat(r.lib.WordArray.random(a - 1)).concat(r.lib.WordArray.create([a << 24], 1))
        },
        unpad: function(t) {
            var e = 255 & t.words[t.sigBytes - 1 >>> 2];
            t.sigBytes -= e
        }
    },
    r.pad.Iso10126)
}
, function(t, e, n) {
    var r;
    t.exports = (r = n(3),
    n(5),
    r.pad.Iso97971 = {
        pad: function(t, e) {
            t.concat(r.lib.WordArray.create([2147483648], 1)),
            r.pad.ZeroPadding.pad(t, e)
        },
        unpad: function(t) {
            r.pad.ZeroPadding.unpad(t),
            t.sigBytes--
        }
    },
    r.pad.Iso97971)
}
, function(t, e, n) {
    var r;
    t.exports = (r = n(3),
    n(5),
    r.pad.ZeroPadding = {
        pad: function(t, e) {
            var n = 4 * e;
            t.clamp(),
            t.sigBytes += n - (t.sigBytes % n || n)
        },
        unpad: function(t) {
            for (var e = t.words, n = t.sigBytes - 1; !(e[n >>> 2] >>> 24 - n % 4 * 8 & 255); )
                n--;
            t.sigBytes = n + 1
        }
    },
    r.pad.ZeroPadding)
}
, function(t, e, n) {
    var r;
    t.exports = (r = n(3),
    n(5),
    r.pad.NoPadding = {
        pad: function() {},
        unpad: function() {}
    },
    r.pad.NoPadding)
}
, function(t, e, n) {
    var r, a, i, o;
    t.exports = (r = n(3),
    n(5),
    i = (a = r).lib.CipherParams,
    o = a.enc.Hex,
    a.format.Hex = {
        stringify: function(t) {
            return t.ciphertext.toString(o)
        },
        parse: function(t) {
            var e = o.parse(t);
            return i.create({
                ciphertext: e
            })
        }
    },
    r.format.Hex)
}
, function(t, e, n) {
    var r;
    t.exports = (r = n(3),
    n(10),
    n(11),
    n(8),
    n(5),
    function() {
        var t = r
          , e = t.lib.BlockCipher
          , n = t.algo
          , a = []
          , i = []
          , o = []
          , s = []
          , l = []
          , u = []
          , c = []
          , h = []
          , d = []
          , f = [];
        !function() {
            for (var t = [], e = 0; e < 256; e++)
                t[e] = e < 128 ? e << 1 : e << 1 ^ 283;
            var n = 0
              , r = 0;
            for (e = 0; e < 256; e++) {
                var p = r ^ r << 1 ^ r << 2 ^ r << 3 ^ r << 4;
                p = p >>> 8 ^ 255 & p ^ 99,
                a[n] = p,
                i[p] = n;
                var m = t[n]
                  , g = t[m]
                  , v = t[g]
                  , y = 257 * t[p] ^ 16843008 * p;
                o[n] = y << 24 | y >>> 8,
                s[n] = y << 16 | y >>> 16,
                l[n] = y << 8 | y >>> 24,
                u[n] = y,
                y = 16843009 * v ^ 65537 * g ^ 257 * m ^ 16843008 * n,
                c[p] = y << 24 | y >>> 8,
                h[p] = y << 16 | y >>> 16,
                d[p] = y << 8 | y >>> 24,
                f[p] = y,
                n ? (n = m ^ t[t[t[v ^ m]]],
                r ^= t[t[r]]) : n = r = 1
            }
        }();
        var p = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54]
          , m = n.AES = e.extend({
            _doReset: function() {
                if (!this._nRounds || this._keyPriorReset !== this._key) {
                    for (var t = this._keyPriorReset = this._key, e = t.words, n = t.sigBytes / 4, r = 4 * ((this._nRounds = n + 6) + 1), i = this._keySchedule = [], o = 0; o < r; o++)
                        if (o < n)
                            i[o] = e[o];
                        else {
                            var s = i[o - 1];
                            o % n ? n > 6 && o % n == 4 && (s = a[s >>> 24] << 24 | a[s >>> 16 & 255] << 16 | a[s >>> 8 & 255] << 8 | a[255 & s]) : (s = a[(s = s << 8 | s >>> 24) >>> 24] << 24 | a[s >>> 16 & 255] << 16 | a[s >>> 8 & 255] << 8 | a[255 & s],
                            s ^= p[o / n | 0] << 24),
                            i[o] = i[o - n] ^ s
                        }
                    for (var l = this._invKeySchedule = [], u = 0; u < r; u++)
                        o = r - u,
                        s = u % 4 ? i[o] : i[o - 4],
                        l[u] = u < 4 || o <= 4 ? s : c[a[s >>> 24]] ^ h[a[s >>> 16 & 255]] ^ d[a[s >>> 8 & 255]] ^ f[a[255 & s]]
                }
            },
            encryptBlock: function(t, e) {
                this._doCryptBlock(t, e, this._keySchedule, o, s, l, u, a)
            },
            decryptBlock: function(t, e) {
                var n = t[e + 1];
                t[e + 1] = t[e + 3],
                t[e + 3] = n,
                this._doCryptBlock(t, e, this._invKeySchedule, c, h, d, f, i),
                n = t[e + 1],
                t[e + 1] = t[e + 3],
                t[e + 3] = n
            },
            _doCryptBlock: function(t, e, n, r, a, i, o, s) {
                for (var l = this._nRounds, u = t[e] ^ n[0], c = t[e + 1] ^ n[1], h = t[e + 2] ^ n[2], d = t[e + 3] ^ n[3], f = 4, p = 1; p < l; p++) {
                    var m = r[u >>> 24] ^ a[c >>> 16 & 255] ^ i[h >>> 8 & 255] ^ o[255 & d] ^ n[f++]
                      , g = r[c >>> 24] ^ a[h >>> 16 & 255] ^ i[d >>> 8 & 255] ^ o[255 & u] ^ n[f++]
                      , v = r[h >>> 24] ^ a[d >>> 16 & 255] ^ i[u >>> 8 & 255] ^ o[255 & c] ^ n[f++]
                      , y = r[d >>> 24] ^ a[u >>> 16 & 255] ^ i[c >>> 8 & 255] ^ o[255 & h] ^ n[f++];
                    u = m,
                    c = g,
                    h = v,
                    d = y
                }
                m = (s[u >>> 24] << 24 | s[c >>> 16 & 255] << 16 | s[h >>> 8 & 255] << 8 | s[255 & d]) ^ n[f++],
                g = (s[c >>> 24] << 24 | s[h >>> 16 & 255] << 16 | s[d >>> 8 & 255] << 8 | s[255 & u]) ^ n[f++],
                v = (s[h >>> 24] << 24 | s[d >>> 16 & 255] << 16 | s[u >>> 8 & 255] << 8 | s[255 & c]) ^ n[f++],
                y = (s[d >>> 24] << 24 | s[u >>> 16 & 255] << 16 | s[c >>> 8 & 255] << 8 | s[255 & h]) ^ n[f++],
                t[e] = m,
                t[e + 1] = g,
                t[e + 2] = v,
                t[e + 3] = y
            },
            keySize: 8
        });
        t.AES = e._createHelper(m)
    }(),
    r.AES)
}
, function(t, e, n) {
    var r;
    t.exports = (r = n(3),
    n(10),
    n(11),
    n(8),
    n(5),
    function() {
        var t = r
          , e = t.lib
          , n = e.WordArray
          , a = e.BlockCipher
          , i = t.algo
          , o = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4]
          , s = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]
          , l = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28]
          , u = [{
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
        }, {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
        }, {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
        }, {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
        }, {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
        }, {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
        }, {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
        }, {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
        }]
          , c = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679]
          , h = i.DES = a.extend({
            _doReset: function() {
                for (var t = this._key.words, e = [], n = 0; n < 56; n++) {
                    var r = o[n] - 1;
                    e[n] = t[r >>> 5] >>> 31 - r % 32 & 1
                }
                for (var a = this._subKeys = [], i = 0; i < 16; i++) {
                    var u = a[i] = []
                      , c = l[i];
                    for (n = 0; n < 24; n++)
                        u[n / 6 | 0] |= e[(s[n] - 1 + c) % 28] << 31 - n % 6,
                        u[4 + (n / 6 | 0)] |= e[28 + (s[n + 24] - 1 + c) % 28] << 31 - n % 6;
                    for (u[0] = u[0] << 1 | u[0] >>> 31,
                    n = 1; n < 7; n++)
                        u[n] = u[n] >>> 4 * (n - 1) + 3;
                    u[7] = u[7] << 5 | u[7] >>> 27
                }
                var h = this._invSubKeys = [];
                for (n = 0; n < 16; n++)
                    h[n] = a[15 - n]
            },
            encryptBlock: function(t, e) {
                this._doCryptBlock(t, e, this._subKeys)
            },
            decryptBlock: function(t, e) {
                this._doCryptBlock(t, e, this._invSubKeys)
            },
            _doCryptBlock: function(t, e, n) {
                this._lBlock = t[e],
                this._rBlock = t[e + 1],
                d.call(this, 4, 252645135),
                d.call(this, 16, 65535),
                f.call(this, 2, 858993459),
                f.call(this, 8, 16711935),
                d.call(this, 1, 1431655765);
                for (var r = 0; r < 16; r++) {
                    for (var a = n[r], i = this._lBlock, o = this._rBlock, s = 0, l = 0; l < 8; l++)
                        s |= u[l][((o ^ a[l]) & c[l]) >>> 0];
                    this._lBlock = o,
                    this._rBlock = i ^ s
                }
                var h = this._lBlock;
                this._lBlock = this._rBlock,
                this._rBlock = h,
                d.call(this, 1, 1431655765),
                f.call(this, 8, 16711935),
                f.call(this, 2, 858993459),
                d.call(this, 16, 65535),
                d.call(this, 4, 252645135),
                t[e] = this._lBlock,
                t[e + 1] = this._rBlock
            },
            keySize: 2,
            ivSize: 2,
            blockSize: 2
        });
        function d(t, e) {
            var n = (this._lBlock >>> t ^ this._rBlock) & e;
            this._rBlock ^= n,
            this._lBlock ^= n << t
        }
        function f(t, e) {
            var n = (this._rBlock >>> t ^ this._lBlock) & e;
            this._lBlock ^= n,
            this._rBlock ^= n << t
        }
        t.DES = a._createHelper(h);
        var p = i.TripleDES = a.extend({
            _doReset: function() {
                var t = this._key.words;
                this._des1 = h.createEncryptor(n.create(t.slice(0, 2))),
                this._des2 = h.createEncryptor(n.create(t.slice(2, 4))),
                this._des3 = h.createEncryptor(n.create(t.slice(4, 6)))
            },
            encryptBlock: function(t, e) {
                this._des1.encryptBlock(t, e),
                this._des2.decryptBlock(t, e),
                this._des3.encryptBlock(t, e)
            },
            decryptBlock: function(t, e) {
                this._des3.decryptBlock(t, e),
                this._des2.encryptBlock(t, e),
                this._des1.decryptBlock(t, e)
            },
            keySize: 6,
            ivSize: 2,
            blockSize: 2
        });
        t.TripleDES = a._createHelper(p)
    }(),
    r.TripleDES)
}
, function(t, e, n) {
    var r;
    t.exports = (r = n(3),
    n(10),
    n(11),
    n(8),
    n(5),
    function() {
        var t = r
          , e = t.lib.StreamCipher
          , n = t.algo
          , a = n.RC4 = e.extend({
            _doReset: function() {
                for (var t = this._key, e = t.words, n = t.sigBytes, r = this._S = [], a = 0; a < 256; a++)
                    r[a] = a;
                a = 0;
                for (var i = 0; a < 256; a++) {
                    var o = a % n
                      , s = e[o >>> 2] >>> 24 - o % 4 * 8 & 255;
                    i = (i + r[a] + s) % 256;
                    var l = r[a];
                    r[a] = r[i],
                    r[i] = l
                }
                this._i = this._j = 0
            },
            _doProcessBlock: function(t, e) {
                t[e] ^= i.call(this)
            },
            keySize: 8,
            ivSize: 0
        });
        function i() {
            for (var t = this._S, e = this._i, n = this._j, r = 0, a = 0; a < 4; a++) {
                n = (n + t[e = (e + 1) % 256]) % 256;
                var i = t[e];
                t[e] = t[n],
                t[n] = i,
                r |= t[(t[e] + t[n]) % 256] << 24 - 8 * a
            }
            return this._i = e,
            this._j = n,
            r
        }
        t.RC4 = e._createHelper(a);
        var o = n.RC4Drop = a.extend({
            cfg: a.cfg.extend({
                drop: 192
            }),
            _doReset: function() {
                a._doReset.call(this);
                for (var t = this.cfg.drop; t > 0; t--)
                    i.call(this)
            }
        });
        t.RC4Drop = e._createHelper(o)
    }(),
    r.RC4)
}
, function(t, e, n) {
    var r;
    t.exports = (r = n(3),
    n(10),
    n(11),
    n(8),
    n(5),
    function() {
        var t = r
          , e = t.lib.StreamCipher
          , n = t.algo
          , a = []
          , i = []
          , o = []
          , s = n.Rabbit = e.extend({
            _doReset: function() {
                for (var t = this._key.words, e = this.cfg.iv, n = 0; n < 4; n++)
                    t[n] = 16711935 & (t[n] << 8 | t[n] >>> 24) | 4278255360 & (t[n] << 24 | t[n] >>> 8);
                var r = this._X = [t[0], t[3] << 16 | t[2] >>> 16, t[1], t[0] << 16 | t[3] >>> 16, t[2], t[1] << 16 | t[0] >>> 16, t[3], t[2] << 16 | t[1] >>> 16]
                  , a = this._C = [t[2] << 16 | t[2] >>> 16, 4294901760 & t[0] | 65535 & t[1], t[3] << 16 | t[3] >>> 16, 4294901760 & t[1] | 65535 & t[2], t[0] << 16 | t[0] >>> 16, 4294901760 & t[2] | 65535 & t[3], t[1] << 16 | t[1] >>> 16, 4294901760 & t[3] | 65535 & t[0]];
                for (this._b = 0,
                n = 0; n < 4; n++)
                    l.call(this);
                for (n = 0; n < 8; n++)
                    a[n] ^= r[n + 4 & 7];
                if (e) {
                    var i = e.words
                      , o = i[0]
                      , s = i[1]
                      , u = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8)
                      , c = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8)
                      , h = u >>> 16 | 4294901760 & c
                      , d = c << 16 | 65535 & u;
                    for (a[0] ^= u,
                    a[1] ^= h,
                    a[2] ^= c,
                    a[3] ^= d,
                    a[4] ^= u,
                    a[5] ^= h,
                    a[6] ^= c,
                    a[7] ^= d,
                    n = 0; n < 4; n++)
                        l.call(this)
                }
            },
            _doProcessBlock: function(t, e) {
                var n = this._X;
                l.call(this),
                a[0] = n[0] ^ n[5] >>> 16 ^ n[3] << 16,
                a[1] = n[2] ^ n[7] >>> 16 ^ n[5] << 16,
                a[2] = n[4] ^ n[1] >>> 16 ^ n[7] << 16,
                a[3] = n[6] ^ n[3] >>> 16 ^ n[1] << 16;
                for (var r = 0; r < 4; r++)
                    a[r] = 16711935 & (a[r] << 8 | a[r] >>> 24) | 4278255360 & (a[r] << 24 | a[r] >>> 8),
                    t[e + r] ^= a[r]
            },
            blockSize: 4,
            ivSize: 2
        });
        function l() {
            for (var t = this._X, e = this._C, n = 0; n < 8; n++)
                i[n] = e[n];
            for (e[0] = e[0] + 1295307597 + this._b | 0,
            e[1] = e[1] + 3545052371 + (e[0] >>> 0 < i[0] >>> 0 ? 1 : 0) | 0,
            e[2] = e[2] + 886263092 + (e[1] >>> 0 < i[1] >>> 0 ? 1 : 0) | 0,
            e[3] = e[3] + 1295307597 + (e[2] >>> 0 < i[2] >>> 0 ? 1 : 0) | 0,
            e[4] = e[4] + 3545052371 + (e[3] >>> 0 < i[3] >>> 0 ? 1 : 0) | 0,
            e[5] = e[5] + 886263092 + (e[4] >>> 0 < i[4] >>> 0 ? 1 : 0) | 0,
            e[6] = e[6] + 1295307597 + (e[5] >>> 0 < i[5] >>> 0 ? 1 : 0) | 0,
            e[7] = e[7] + 3545052371 + (e[6] >>> 0 < i[6] >>> 0 ? 1 : 0) | 0,
            this._b = e[7] >>> 0 < i[7] >>> 0 ? 1 : 0,
            n = 0; n < 8; n++) {
                var r = t[n] + e[n]
                  , a = 65535 & r
                  , s = r >>> 16
                  , l = ((a * a >>> 17) + a * s >>> 15) + s * s
                  , u = ((4294901760 & r) * r | 0) + ((65535 & r) * r | 0);
                o[n] = l ^ u
            }
            t[0] = o[0] + (o[7] << 16 | o[7] >>> 16) + (o[6] << 16 | o[6] >>> 16) | 0,
            t[1] = o[1] + (o[0] << 8 | o[0] >>> 24) + o[7] | 0,
            t[2] = o[2] + (o[1] << 16 | o[1] >>> 16) + (o[0] << 16 | o[0] >>> 16) | 0,
            t[3] = o[3] + (o[2] << 8 | o[2] >>> 24) + o[1] | 0,
            t[4] = o[4] + (o[3] << 16 | o[3] >>> 16) + (o[2] << 16 | o[2] >>> 16) | 0,
            t[5] = o[5] + (o[4] << 8 | o[4] >>> 24) + o[3] | 0,
            t[6] = o[6] + (o[5] << 16 | o[5] >>> 16) + (o[4] << 16 | o[4] >>> 16) | 0,
            t[7] = o[7] + (o[6] << 8 | o[6] >>> 24) + o[5] | 0
        }
        t.Rabbit = e._createHelper(s)
    }(),
    r.Rabbit)
}
, function(t, e, n) {
    var r;
    t.exports = (r = n(3),
    n(10),
    n(11),
    n(8),
    n(5),
    function() {
        var t = r
          , e = t.lib.StreamCipher
          , n = t.algo
          , a = []
          , i = []
          , o = []
          , s = n.RabbitLegacy = e.extend({
            _doReset: function() {
                var t = this._key.words
                  , e = this.cfg.iv
                  , n = this._X = [t[0], t[3] << 16 | t[2] >>> 16, t[1], t[0] << 16 | t[3] >>> 16, t[2], t[1] << 16 | t[0] >>> 16, t[3], t[2] << 16 | t[1] >>> 16]
                  , r = this._C = [t[2] << 16 | t[2] >>> 16, 4294901760 & t[0] | 65535 & t[1], t[3] << 16 | t[3] >>> 16, 4294901760 & t[1] | 65535 & t[2], t[0] << 16 | t[0] >>> 16, 4294901760 & t[2] | 65535 & t[3], t[1] << 16 | t[1] >>> 16, 4294901760 & t[3] | 65535 & t[0]];
                this._b = 0;
                for (var a = 0; a < 4; a++)
                    l.call(this);
                for (a = 0; a < 8; a++)
                    r[a] ^= n[a + 4 & 7];
                if (e) {
                    var i = e.words
                      , o = i[0]
                      , s = i[1]
                      , u = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8)
                      , c = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8)
                      , h = u >>> 16 | 4294901760 & c
                      , d = c << 16 | 65535 & u;
                    for (r[0] ^= u,
                    r[1] ^= h,
                    r[2] ^= c,
                    r[3] ^= d,
                    r[4] ^= u,
                    r[5] ^= h,
                    r[6] ^= c,
                    r[7] ^= d,
                    a = 0; a < 4; a++)
                        l.call(this)
                }
            },
            _doProcessBlock: function(t, e) {
                var n = this._X;
                l.call(this),
                a[0] = n[0] ^ n[5] >>> 16 ^ n[3] << 16,
                a[1] = n[2] ^ n[7] >>> 16 ^ n[5] << 16,
                a[2] = n[4] ^ n[1] >>> 16 ^ n[7] << 16,
                a[3] = n[6] ^ n[3] >>> 16 ^ n[1] << 16;
                for (var r = 0; r < 4; r++)
                    a[r] = 16711935 & (a[r] << 8 | a[r] >>> 24) | 4278255360 & (a[r] << 24 | a[r] >>> 8),
                    t[e + r] ^= a[r]
            },
            blockSize: 4,
            ivSize: 2
        });
        function l() {
            for (var t = this._X, e = this._C, n = 0; n < 8; n++)
                i[n] = e[n];
            for (e[0] = e[0] + 1295307597 + this._b | 0,
            e[1] = e[1] + 3545052371 + (e[0] >>> 0 < i[0] >>> 0 ? 1 : 0) | 0,
            e[2] = e[2] + 886263092 + (e[1] >>> 0 < i[1] >>> 0 ? 1 : 0) | 0,
            e[3] = e[3] + 1295307597 + (e[2] >>> 0 < i[2] >>> 0 ? 1 : 0) | 0,
            e[4] = e[4] + 3545052371 + (e[3] >>> 0 < i[3] >>> 0 ? 1 : 0) | 0,
            e[5] = e[5] + 886263092 + (e[4] >>> 0 < i[4] >>> 0 ? 1 : 0) | 0,
            e[6] = e[6] + 1295307597 + (e[5] >>> 0 < i[5] >>> 0 ? 1 : 0) | 0,
            e[7] = e[7] + 3545052371 + (e[6] >>> 0 < i[6] >>> 0 ? 1 : 0) | 0,
            this._b = e[7] >>> 0 < i[7] >>> 0 ? 1 : 0,
            n = 0; n < 8; n++) {
                var r = t[n] + e[n]
                  , a = 65535 & r
                  , s = r >>> 16
                  , l = ((a * a >>> 17) + a * s >>> 15) + s * s
                  , u = ((4294901760 & r) * r | 0) + ((65535 & r) * r | 0);
                o[n] = l ^ u
            }
            t[0] = o[0] + (o[7] << 16 | o[7] >>> 16) + (o[6] << 16 | o[6] >>> 16) | 0,
            t[1] = o[1] + (o[0] << 8 | o[0] >>> 24) + o[7] | 0,
            t[2] = o[2] + (o[1] << 16 | o[1] >>> 16) + (o[0] << 16 | o[0] >>> 16) | 0,
            t[3] = o[3] + (o[2] << 8 | o[2] >>> 24) + o[1] | 0,
            t[4] = o[4] + (o[3] << 16 | o[3] >>> 16) + (o[2] << 16 | o[2] >>> 16) | 0,
            t[5] = o[5] + (o[4] << 8 | o[4] >>> 24) + o[3] | 0,
            t[6] = o[6] + (o[5] << 16 | o[5] >>> 16) + (o[4] << 16 | o[4] >>> 16) | 0,
            t[7] = o[7] + (o[6] << 8 | o[6] >>> 24) + o[5] | 0
        }
        t.RabbitLegacy = e._createHelper(s)
    }(),
    r.RabbitLegacy)
}
, function(t, e, n) {
    "use strict";
    n.r(e);
    n(21);
    var r = n(0)
      , a = THING.BaseObject.prototype.movePath
      , i = THING.BaseObject.prototype.lookAt;
    THING.BaseObject.prototype.movePath = function(t) {
        t.orientToPathDegree = THING.Utils.parseValue(t.orientToPathDegree, 0);
        let e, n, i = THING.Utils.parseValue(t.turnSpeed, 1);
        if (i >= 10 && (i = 10),
        t.turnAtFirstPoint) {
            var o = CMAP.Util.convertWorldToLonlat(this.position)
              , s = CMAP.Util.convertLonlatToWorld([o[0], o[1] + .1])
              , l = new THREE.Vector3(s[0] - this.position[0],s[1] - this.position[1],s[2] - this.position[2]);
            l.normalize();
            var u = new THREE.Vector3(this.node.matrixWorld.elements[8],this.node.matrixWorld.elements[9],this.node.matrixWorld.elements[10]);
            e = u.angleTo(l),
            u.cross(l).z < 0 && (e *= -1),
            e = Math.radToDeg(e)
        }
        let c, h = 0;
        function d(a) {
            var o = a.object
              , s = a.fromPosition;
            r.a.isArrayEqual(c, s) || (h = 0,
            c = s);
            var l = a.toPosition
              , u = o.position
              , d = r.a.convertWorldToLonlat(s)
              , f = r.a.convertWorldToLonlat(u)
              , p = r.a.convertWorldToLonlat(l)
              , m = r.a.getAzimuth(d, p)
              , g = function(e) {
                var a = f[0] + 90 - e;
                let i = r.a.convertLonlatToWorld([f[0], f[1]]);
                if (n = CMAP.Util.positionToQuaternion(i, a),
                0 !== THING.Math.getDistance(u, l) && Math.abs(f[2] - p[2]) > .001) {
                    var s = Math.atan((f[2] - p[2]) / THING.Math.getDistance(u, l));
                    let e = new THREE.Quaternion;
                    var c = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), THING.Math.degToRad(t.orientToPathDegree));
                    o instanceof CMAP.GeoPoint && "image" === o.renderer.type && !1 === o.renderer.useSpriteMaterial && (s += Math.PI / 2),
                    e = e.setFromAxisAngle(c, s),
                    n = n.multiply(e)
                }
                return n
            };
            if (1 === a.progress) {
                var v = r.a.convertWorldToLonlat(a.fromPosition);
                m = r.a.getAzimuth(v, f)
            }
            m += t.orientToPathDegree,
            THING.Utils.isNull(e) && (e = m,
            g(m)),
            e - m > 180 ? m += 360 : m - e > 180 && (m -= 360),
            Math.abs(e - m) > 1e-5 ? g(e += (m - e) * i * .1 * ++h) : h = 0,
            o instanceof CMAP.GeoPoint && (o._coordinates = f),
            o.node._setWorldQuaternion(n),
            o.node.updateMatrixWorld(!1, !1)
        }
        let f = t.update;
        CMAP.getCurrentMap() && t.orientToPath && (f && !t.correctObject ? t.update = function(t) {
            f.call(this, t),
            d(t)
        }
        : t.update = function(e) {
            d(e),
            t.correctObject = !0
        }
        ),
        a.call(this, t)
    }
    ,
    THING.BaseObject.prototype.lookAt = function(t, e) {
        i.call(this, t, e),
        e = e || {};
        var n = THING.Utils.parseValue(e.isEarth, !1);
        if (t && n) {
            this.angles = CMAP.Util.getAnglesFromPosition(this.position);
            var r = function(t, e, n, r={}) {
                if (!(t && t instanceof THING.BaseObject))
                    return console.error("[CameraPose.js] : [calcFlyToParams] : error target", t),
                    null;
                const a = function(e) {
                    let n = null;
                    if (!e)
                        return console.error("[CameraPose.js] : [calcFlyToParams] : error position", e),
                        null;
                    if (Array.isArray(e) && (n = THING.Utils.parseVector3(e)),
                    e instanceof THREE.Vector3 && (n = e),
                    !n)
                        return console.error("[CameraPose.js] : [calcFlyToParams] : error position", e),
                        null;
                    n = THING.Utils.parseVector3(t.worldToSelf(n.toArray()));
                    const a = {
                        radius: t._FlyPropForCam_ && t._FlyPropForCam_.radius ? t._FlyPropForCam_.radius : t.boundingBox.radius,
                        center: t._FlyPropForCam_ && t._FlyPropForCam_.center ? t._FlyPropForCam_.center : t.boundingBox.center,
                        fov: THING.App.current.camera.fov
                    };
                    Object.assign(a, r),
                    0 === a.radius && (a.radius = t.getRadius(!0));
                    const i = {
                        xAngle: 0,
                        yAngle: 0,
                        radius: 1
                    }
                      , o = THING.Utils.parseVector3(t.worldToSelf(a.center));
                    let s = new THREE.Vector3;
                    s.copy(n),
                    s = s.sub(o),
                    i.radius = s.length() * Math.sin(a.fov / 1 * 1 / 180 * Math.PI) / a.radius;
                    const l = new THREE.Vector3;
                    l.copy(s),
                    l.normalize();
                    const u = new THREE.Vector3(l.x,0,l.z);
                    u.normalize();
                    const c = new THREE.Vector3(0,0,1);
                    return i.xAngle = THING.Math.getAngleBetweenVectors(l.toArray(), u.toArray()) * THING.Math.sign(l.y),
                    i.yAngle = THING.Math.getAngleBetweenVectors(c.toArray(), u.toArray()) * THING.Math.sign(u.x),
                    i.xAngle = Number.isNaN(i.xAngle) ? 0 : i.xAngle,
                    i.yAngle = Number.isNaN(i.yAngle) ? 0 : i.yAngle,
                    i
                }
                  , i = a(e)
                  , o = a(n);
                return {
                    position: {
                        pitch: i.xAngle,
                        yaw: i.yAngle,
                        radiusFac: i.radius
                    },
                    target: {
                        pitch: o.xAngle,
                        yaw: o.yAngle,
                        radiusFac: o.radius
                    }
                }
            }(this, t.position, this.position);
            this.rotateY(r.position.yaw)
        }
    }
    ,
    THREE.EarthOrbitControls = function(t, e) {
        var n;
        this.object = t,
        this.domElement = void 0 !== e ? e : document,
        this.enabled = !0,
        this.isEarth = !0,
        this.target = new THREE.Vector3,
        this.target.set = function(t, e, n) {
            if (r.targetLimitData) {
                let a = THING.Math.world2Lonlat([t, e, n]);
                if (a && a.length > 1) {
                    const i = r.targetLimitData.min
                      , o = r.targetLimitData.max;
                    a[0] < i[0] ? a[0] = i[0] : a[0] > o[0] && (a[0] = o[0]),
                    a[1] < i[1] ? a[1] = i[1] : a[1] > o[1] && (a[1] = o[1]);
                    const s = THING.Math.lonlat2World(a);
                    t = s[0],
                    e = s[1],
                    n = s[2]
                }
            }
            return void 0 === n && (n = this.z),
            this.x = t,
            this.y = e,
            this.z = n,
            this
        }
        ,
        this._leftInteractive = !0,
        this._keepTarget = !1,
        this.minDistance = 500,
        this.maxDistance = 2e7,
        this._distanceFixFactor = 1e-4,
        this.minZoom = 0,
        this.maxZoom = 1 / 0,
        this.maxPitchAngle = 87,
        this._minPolarAngle = 0,
        this._maxPolarAngle = THING.Math.degToRad(this.maxPitchAngle),
        this.minAzimuthAngle = -1 / 0,
        this.maxAzimuthAngle = 1 / 0,
        this.enableDamping = !1,
        this.dampingFactor = .88,
        this.dampingZoomFactor = .5,
        this.enableZoom = !0,
        this.zoomSpeed = 1,
        this.zoomFactor = 1,
        this.zoomDelayFactor = .06,
        this.enableRotate = !0,
        this.rotateSpeed = .07,
        this.enablePan = !0,
        this.keyPanSpeed = 7,
        this.panSpeed = 1,
        this.autoRotate = !1,
        this.autoRotateSpeed = 2,
        this.enableKeys = !0,
        this.keys = {
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            BOTTOM: 40
        },
        this.mouseButtons = {
            ORBIT: THREE.MOUSE.LEFT,
            ZOOM: THREE.MOUSE.MIDDLE,
            PAN: THREE.MOUSE.RIGHT
        },
        this.target0 = this.target.clone(),
        this.position0 = this.object.position.clone(),
        this.zoom0 = this.object.zoom,
        this.standardRadius = 10216133.731679259,
        this.targetMaxOffset = 6e7,
        this.panStander = this.maxDistance - 6378e3,
        this.isDispatchEvent = !0,
        this.enableZoomOnTarget = !0,
        this.options = {},
        this._isCameraStatic = !0,
        this.setOptions = function(t) {
            this.options = t,
            this.mouseButtons = {
                ORBIT: this._parseToThreeMouseKey(t.moveKey),
                ZOOM: this._parseToThreeMouseKey(t.zoomKey),
                PAN: this._parseToThreeMouseKey(t.rotationKey)
            },
            this.enableZoomOnTarget = t.enableZoomOnTarget
        }
        ,
        this._parseToThreeMouseKey = function(t) {
            var e;
            switch (t) {
            case "left":
                e = THREE.MOUSE.LEFT;
                break;
            case "right":
                e = THREE.MOUSE.RIGHT;
                break;
            case "middle":
                e = THREE.MOUSE.MIDDLE
            }
            return e
        }
        ,
        this._parseToThingMouseKey = function(t) {
            var e;
            switch (t) {
            case THREE.MOUSE.LEFT:
                e = "left";
                break;
            case THREE.MOUSE.RIGHT:
                e = "right";
                break;
            case THREE.MOUSE.MIDDLE:
                e = "middle"
            }
            return e
        }
        ,
        this.getOptions = function(t) {
            return this.options.rotationKey = this._parseToThingMouseKey(this.mouseButtons.PAN),
            this.options.zoomKey = this._parseToThingMouseKey(this.mouseButtons.ZOOM),
            this.options.moveKey = this._parseToThingMouseKey(this.mouseButtons.ORBIT),
            this.options.enableZoomOnTarget = this.enableZoomOnTarget,
            this.options
        }
        ,
        this.getPolarAngle = function() {
            return c.phi
        }
        ,
        this.getAzimuthalAngle = function() {
            return c.theta
        }
        ,
        this.getRotationSpherePhi = function() {
            return h.phi
        }
        ,
        this.getSphericalRadius = function() {
            return c.radius
        }
        ,
        this.saveState = function() {
            r.target0.copy(r.target),
            r.position0.copy(r.object.position),
            r.zoom0 = r.object.zoom
        }
        ,
        this.reset = function() {
            r.target.copy(r.target0),
            r.object.position.copy(r.position0),
            r.object.zoom = r.zoom0,
            r.object.updateProjectionMatrix(),
            r.dispatchEvent(i),
            r.update(),
            u = l.NONE
        }
        ,
        this.goHome = function() {
            A = !0,
            r.object.up.set(0, 1, 0),
            r.object.position.set(4890109.86328125, 9295980.46875, 13943610.3515625),
            c.radius = 17457167.49609005,
            h.phi = -.01,
            h.theta = Math.PI / 2,
            h.radius = c.radius - 6378e3,
            r._isCameraStatic = !1,
            r.update(),
            r._isCameraStatic = !0
        }
        ,
        this.setState = function(t) {
            if (r.enabled) {
                var e = r._getIntersectPoint();
                r.target.copy(e);
                var n = r.target
                  , a = r.object.position
                  , i = (new THREE.Vector3).subVectors(n, a)
                  , o = (new THREE.Vector3).crossVectors(a, i)
                  , s = (new THREE.Vector3).crossVectors(i, o);
                s = s.normalize(),
                r.object.up.copy(s),
                r.object.lookAt(n.x, n.y, n.z)
            }
        }
        ,
        this.correctUp = function(t) {
            var e = THING.Utils.parseValue(t.time, 3e3)
              , n = t.callback
              , a = r.target
              , i = r.object.position
              , o = new THREE.Vector3;
            o.copy(r.object.up),
            o.normalize();
            var s = new THREE.Vector3;
            s.copy(i),
            s.normalize();
            var l = null;
            requestAnimationFrame(function t(i) {
                l || (l = i);
                var u = i - l
                  , c = o.lerp(s, u / e);
                r.object.up = c,
                r.object.lookAt(a),
                u / e < 1 ? requestAnimationFrame(t) : (n && n(),
                THING.Utils.log("end-correct"))
            })
        }
        ,
        this._getIntersectPoint = function(t=!0, e=!1) {
            if (!e && (this._isCameraStatic || 0 === this._getState() || 2 === this._getState() || this._keepTarget))
                return this.target;
            var n = new THREE.Vector3
              , r = [];
            if (this.object.getWorldDirection(n),
            n.normalize(),
            j._camera = this.object,
            j.set(this.object.position, n),
            D.set(this.object.position, n),
            t) {
                var a = t3djs.buffer.nodeBuffer.get("tiles-root");
                if (a && a.ensureVisible() && (r = j.intersectObjects(a.children, !0)),
                r.length > 0) {
                    let t = r[0].point;
                    if (CMAP.Util.convertWorldToLonlat(t.toArray())[2] >= 0)
                        return t
                }
            }
            var i = new THREE.Vector3;
            return D.intersectSphere(L, i),
            i.equals(new THREE.Vector3(0,0,0)) ? this.target : i
        }
        ,
        this._getIntersectPointByMouse = function(t, e) {
            var n = [];
            if (r.isEarth) {
                var a = new THREE.Vector3;
                this.object.getWorldDirection(a),
                a.normalize(),
                D.set(this.object.position, a),
                j.setFromCamera(new THREE.Vector2(t,e), this.object);
                var i = t3djs.buffer.nodeBuffer.get("tiles-root");
                i && i.ensureVisible() && (n = j.intersectObjects(i.children, !0));
                var o = new THREE.Vector3;
                return D.intersectSphere(L, o),
                n.length > 0 ? n[0].point : this._getIntersectPoint()
            }
            let s = r.domElement.clientWidth * (U.x + 1) / 2
              , l = (1 - U.y) * r.domElement.clientHeight / 2
              , u = this.app.camera.screenToWorld(s, l);
            return new THREE.Vector3(u[0],u[1],u[2])
        }
        ,
        this._getIntersectQuaternion = function(t, e) {
            (new THREE.Vector3).copy(t);
            var n = new THREE.Vector3;
            n.copy(t),
            n.normalize();
            var r = new THREE.Quaternion;
            r.setFromUnitVectors(new THREE.Vector3(0,1,0), n);
            var a = new THREE.Quaternion;
            return a.setFromAxisAngle(new THREE.Vector3(0,1,0), Math.PI / 2 + e),
            r.multiply(a),
            r.normalize(),
            r
        }
        ,
        this._correctCube = function() {
            var t = this._getIntersectPoint();
            k.position.copy(t);
            var e = CMAP.Util.getAnglesFromPosition(t.toArray());
            k.setAngles(e)
        }
        ,
        this._correctSphericalRotation = function(t) {
            var e = new THREE.Vector3;
            if (e.copy(t),
            k.worldToLocal(e),
            h.setFromVector3(e),
            0 !== r.target.length()) {
                var n = r.object.position.distanceTo(this._getIntersectPoint());
                h.radius = n
            }
            h.phi = -h.phi,
            h.theta = Math.PI + h.theta,
            !1
        }
        ,
        this._getAngle = function() {
            if (0 !== r.target.length()) {
                var t = new THREE.Vector3;
                t.copy(r.target),
                t.normalize();
                var e = new THREE.Vector3(0,6378e3,0);
                e.sub(this.object.position),
                e.normalize();
                var n = new THREE.Vector3;
                this.object.getWorldDirection(n),
                n.projectOnPlane(t),
                e.projectOnPlane(t);
                var a = e.angleTo(n);
                return n.cross(e),
                n.sub(t),
                n.length() <= 1 && (a *= -1),
                a
            }
        }
        ,
        this.setTargetLimit = function(t) {
            if (t) {
                const e = t.min
                  , n = t.max;
                e && n && e.length > 1 && n.length > 1 && (this.targetLimitData = {
                    min: [e[0], e[1]],
                    max: [n[0], n[1]]
                })
            } else
                this.targetLimitData = void 0
        }
        ,
        this.autoFixTarget = function(t) {
            if (!H && r.app && (r.app.scene.add(k),
            k.visible = !1,
            H = !0,
            !0),
            A) {
                if (r.dispatchEvent(i),
                r.enableDamping || (A = !1),
                B.multiply(F),
                r.targetLimitData) {
                    const t = r.target.clone().applyQuaternion(B)
                      , e = r.targetLimitData.min
                      , n = r.targetLimitData.max;
                    let a = THING.Math.world2Lonlat(t.toArray());
                    if (a[0] < e[0] || a[0] > n[0] || a[1] < e[1] || a[1] > n[1])
                        return
                }
                if (t.applyQuaternion(B),
                r.object.updateMatrixWorld(!0),
                0 !== r.target.length()) {
                    var e = new THREE.Vector3;
                    e.copy(t),
                    e.normalize(),
                    r.object.up.copy(e),
                    r.target.applyQuaternion(B)
                } else {
                    var n = this._getIntersectPoint();
                    n.y += 100,
                    r.target.copy(n)
                }
                r.object.lookAt(r.target)
            } else if (P) {
                r.dispatchEvent(i),
                P = !1;
                var a = this._getIntersectPoint();
                let t = new THREE.Vector3;
                t.copy(k.position),
                t.normalize();
                var o = new THREE.Vector3;
                o.setFromSpherical(h),
                o.applyMatrix4(k.matrixWorld),
                r.object.up.copy(t),
                r.object.position.copy(o),
                r.target.copy(a),
                r.object.lookAt(r.target)
            } else if (S || R) {
                r.dispatchEvent(i);
                var s = r.object.position.distanceTo(this._getIntersectPoint());
                if (s > r.maxDistance && R || s < r.minDistance + r._distanceFixFactor && S)
                    h.radius = s,
                    p = 1;
                else {
                    var l = this._getIntersectPointByMouse(U.x, U.y)
                      , u = new THREE.Vector3;
                    u.copy(r.object.position),
                    u.sub(l),
                    u.normalize();
                    var d = this._getIntersectPointByMouse(0, 0)
                      , f = new THREE.Vector3;
                    f.copy(r.object.position),
                    f.sub(d),
                    f.normalize();
                    var m = f.dot(u)
                      , g = c.radius * p - c.radius;
                    let t = THING.App.current._delay;
                    t > 100 && (t = 100),
                    t && r.zoomSpeed && (g = Math.abs(g) / g * r.zoomSpeed * t / 1e3 * 618e4),
                    h.radius = Math.max(this.minDistance, h.radius + g * m),
                    h.radius >= r.maxDistance && R && (h.radius = r.maxDistance),
                    h.radius <= r.minDistance && S && (h.radius = r.minDistance + r._distanceFixFactor);
                    var v = new THREE.Vector3;
                    if (v.setFromSpherical(h),
                    isNaN(v.x))
                        return;
                    u.multiplyScalar(g),
                    r.object.position.add(u);
                    var y = r._isCameraStatic;
                    r._isCameraStatic = !1,
                    this._correctCube(),
                    r._isCameraStatic = y,
                    v.applyMatrix4(k.matrixWorld),
                    r.object.position.copy(v),
                    r.object.up.copy(r.object.position),
                    r.target.copy(k.position),
                    r.enableDamping || (S = !1,
                    R = !1)
                }
            }
        }
        ,
        this.addEventListener("start", function() {
            r._isCameraStatic = !1
        }),
        this.addEventListener("end", function() {
            r._isCameraStatic = !0
        }),
        this.update = (n = new THREE.Vector3,
        function() {
            var t = r.object.position;
            n.copy(t),
            c.setFromVector3(n),
            f.setFromVector3(r.target),
            f.radius = 6378e3,
            r.enabled && this.autoFixTarget(t),
            r.object.lookAt(r.target),
            this._correctCube(),
            this._correctSphericalRotation(t);
            var e = r.object.position.distanceTo(this._getIntersectPoint());
            return r.earthPanSpeed = r.panSpeed / .1 * e / 3e7,
            r.zoomSpeed = h.radius / 4e6 * this.zoomFactor,
            !0 === r.enableDamping ? A ? (d.x *= 1 - r.dampingFactor,
            d.y *= 1 - r.dampingFactor,
            z(d.x),
            q(d.y),
            (P || S || R || d.x > -1e-10 && d.x < 1e-10 || d.y > -1e-10 && d.y < 1e-10) && (A = !1,
            d.set(0, 0))) : S ? (p += (1 - p) * r.dampingZoomFactor * THING.App.current._delay * r.zoomDelayFactor) > .99999999 && (p = 1,
            S = !1) : R && (p -= (p - 1) * r.dampingZoomFactor * THING.App.current._delay * r.zoomDelayFactor) < 1.0000001 && (p = 1,
            R = !1) : (d.set(0, 0),
            p = 1,
            A = !1,
            P = !1),
            m.set(0, 0, 0),
            !1
        }
        ),
        this.dispose = function() {
            r.domElement.removeEventListener("contextmenu", st, !1),
            r.domElement.removeEventListener("mousedown", Q, !1),
            r.domElement.removeEventListener("wheel", nt, !1),
            r.domElement.removeEventListener("touchstart", at, !1),
            r.domElement.removeEventListener("touchend", ot, !1),
            r.domElement.removeEventListener("touchmove", it, !1),
            r.domElement.ownerDocument.removeEventListener("mousemove", Z, !1),
            r.domElement.ownerDocument.removeEventListener("mouseup", tt, !1),
            window.removeEventListener("keydown", rt, !1)
        }
        ;
        var r = this
          , a = {
            type: "wheel"
        }
          , i = {
            type: "change"
        }
          , o = {
            type: "start"
        }
          , s = {
            type: "end"
        }
          , l = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_DOLLY: 4,
            TOUCH_PAN: 5
        }
          , u = l.NONE;
        r._getState = function() {
            return u
        }
        ,
        r._setState = function(t) {
            u = t
        }
        ;
        var c = new THREE.Spherical
          , h = new THREE.Spherical;
        h.theta = Math.PI / 2,
        h.phi = -.01,
        h.radius = this.panStander;
        var d = new THREE.Vector2
          , f = (new THREE.Spherical,
        new THREE.Spherical);
        f.radius = 6378e3;
        new THREE.Spherical,
        new THREE.Cylindrical,
        new THREE.Cylindrical;
        var p = 1
          , m = new THREE.Vector3
          , g = new THREE.Vector2
          , v = new THREE.Vector2
          , y = new THREE.Vector2
          , _ = new THREE.Vector2
          , x = new THREE.Vector2
          , b = new THREE.Vector2
          , w = new THREE.Vector2
          , C = new THREE.Vector2
          , E = new THREE.Vector2
          , T = new THREE.Vector2
          , M = new THREE.Vector2
          , A = (new THREE.Vector3,
        new THREE.Vector3,
        !1)
          , P = !1
          , S = !1
          , R = !1
          , D = new THREE.Ray
          , j = new THREE.Raycaster
          , L = new THREE.Sphere(new THREE.Vector3(0,0,0),6378e3)
          , I = new THREE.BoxGeometry(10,10,10)
          , O = new THREE.MeshStandardMaterial({
            color: 65280
        })
          , k = new THREE.Mesh(I,O)
          , H = !1
          , F = new THREE.Quaternion
          , B = new THREE.Quaternion
          , U = {};
        function N() {
            return Math.pow(.95, r.zoomSpeed)
        }
        function z(t) {
            var e = new THREE.Vector3(0,6378e4,0);
            e.unproject(r.object),
            e.normalize(),
            d.x = t,
            t *= 1 - Math.sin(h.phi),
            B.setFromAxisAngle(e, -t)
        }
        function q(t) {
            var e = new THREE.Vector3(6378e3,0,0);
            e.unproject(r.object),
            e.normalize(),
            d.y = t,
            F.setFromAxisAngle(e, -t)
        }
        var V = function(t) {
            h.phi > -.001 || (h.theta -= t,
            h.theta > 2 * Math.PI && (h.theta = h.theta - 2 * Math.PI),
            h.theta < 0 && (h.theta = 2 * Math.PI + h.theta))
        }
          , W = function(t) {
            P = !0,
            h.phi += t,
            h.phi >= -.01 && (h.phi = -.01),
            h.phi < -r.maxPolarAngle && (h.phi = -r.maxPolarAngle),
            h.phi > -r.minPolarAngle && (h.phi = -r.minPolarAngle)
        }
          , G = function(t, e) {
            var n = r.domElement === document ? r.domElement.body : r.domElement;
            let a = r.rotateSpeed / .07;
            r.object.isPerspectiveCamera ? (V(2 * Math.PI * t / n.clientWidth * a),
            W(2 * Math.PI * e / n.clientHeight * a)) : r.object.isOrthographicCamera ? (V(t * (r.object.right - r.object.left) / r.object.zoom / n.clientWidth, r.object.matrix),
            W(e * (r.object.top - r.object.bottom) / r.object.zoom / n.clientHeight, r.object.matrix)) : (THING.Utils.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
            r.enablePan = !1)
        };
        function Y(t, e) {
            let n = r.domElement;
            var a = n.currentStyle || window.getComputedStyle(n, null)
              , i = e ? e[0] : parseInt(a.borderLeftWidth, 10)
              , o = e ? e[1] : parseInt(a.borderTopWidth, 10)
              , s = n.getBoundingClientRect();
            return {
                x: t.clientX - i - s.left,
                y: t.clientY - o - s.top
            }
        }
        function K(t) {
            R = !0,
            r.object.isPerspectiveCamera ? p /= t : r.object.isOrthographicCamera ? (r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom * t)),
            r.object.updateProjectionMatrix(),
            !0) : (THING.Utils.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            r.enableZoom = !1)
        }
        function $(t) {
            S = !0,
            r.object.isPerspectiveCamera ? p *= t : r.object.isOrthographicCamera ? (r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom / t)),
            r.object.updateProjectionMatrix(),
            !0) : (THING.Utils.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            r.enableZoom = !1)
        }
        function X(t) {
            _.set(t.touches[0].pageX, t.touches[0].pageY)
        }
        function J(t) {
            x.set(t.touches[0].pageX, t.touches[0].pageY),
            b.subVectors(x, _),
            G(b.x, b.y),
            _.copy(x),
            r.update()
        }
        function Q(t) {
            if (!1 !== r.enabled) {
                switch (t.preventDefault(),
                t.button) {
                case r.mouseButtons.ORBIT:
                    if (!1 === r.enableRotate)
                        return;
                    !function(t) {
                        let e = Y(t);
                        g.set(e.x, e.y)
                    }(t),
                    u = l.ROTATE;
                    break;
                case r.mouseButtons.ZOOM:
                    if (!1 === r.enableZoom)
                        return;
                    !function(t) {
                        let e = Y(t);
                        w.set(e.x, e.y)
                    }(t),
                    u = l.DOLLY;
                    break;
                case r.mouseButtons.PAN:
                    if (!1 === r.enablePan)
                        return;
                    !function(t) {
                        let e = Y(t);
                        _.set(e.x, e.y)
                    }(t),
                    u = l.PAN
                }
                u !== l.NONE && (r.domElement.ownerDocument.addEventListener("mousemove", Z, !1),
                r.domElement.ownerDocument.addEventListener("mouseup", tt, !1),
                r.dispatchEvent(o))
            }
        }
        function Z(t) {
            if (!1 !== r.enabled)
                switch (t.preventDefault(),
                u) {
                case l.ROTATE:
                    if (!1 === r.enableRotate)
                        return;
                    !function(t) {
                        A = !0;
                        let e = Y(t);
                        v.set(e.x, e.y),
                        y.subVectors(v, g);
                        var n = r.domElement === document ? r.domElement.body : r.domElement;
                        z(2 * Math.PI * y.x / n.clientWidth * r.earthPanSpeed),
                        q(2 * Math.PI * y.y / n.clientHeight * r.earthPanSpeed),
                        g.copy(v),
                        r.update()
                    }(t);
                    break;
                case l.DOLLY:
                    if (!1 === r.enableZoom)
                        return;
                    !function(t) {
                        let e = Y(t);
                        C.set(e.x, e.y),
                        E.subVectors(C, w),
                        E.y > 0 ? K(N()) : E.y < 0 && $(N()),
                        w.copy(C),
                        r.update()
                    }(t);
                    break;
                case l.PAN:
                    if (!1 === r.enablePan)
                        return;
                    !function(t) {
                        let e = Y(t);
                        x.set(e.x, e.y),
                        b.subVectors(x, _),
                        G(b.x, b.y),
                        _.copy(x),
                        r.update()
                    }(t)
                }
        }
        function tt(t) {
            if (!1 === r.enabled)
                return r.domElement.ownerDocument.removeEventListener("mousemove", Z, !1),
                void r.domElement.ownerDocument.removeEventListener("mouseup", tt, !1);
            r.domElement.ownerDocument.removeEventListener("mousemove", Z, !1),
            r.domElement.ownerDocument.removeEventListener("mouseup", tt, !1),
            r.dispatchEvent(s),
            u = l.NONE
        }
        r.rotate = function(t, e) {
            switch (e = (e = THING.Utils.parseValue(e, 1e3)) / 180 * Math.PI,
            t) {
            case "up":
                this.pan(0, e);
                break;
            case "down":
                this.pan(0, -e);
                break;
            case "left":
                this.pan(e, 0);
                break;
            case "right":
                this.pan(-e, 0)
            }
        }
        ,
        r.move = function(t, e) {
            t = t / 180 * Math.PI,
            t *= this.earthPanSpeed,
            e = e / 180 * Math.PI,
            e *= this.earthPanSpeed,
            B.set(0, 0, 0, 1),
            F.set(0, 0, 0, 1),
            A = !0,
            z(t),
            q(e)
        }
        ,
        r.zoom = function(t, e) {
            switch (e = THING.Utils.parseValue(e, .95),
            e = Math.pow(e, r.zoomSpeed),
            t) {
            case "in":
                $(e);
                break;
            case "out":
                K(e)
            }
        }
        ,
        r.earthRotate = function(t, e) {
            switch (e = (e = THING.Utils.parseValue(e, 10)) / 180 * Math.PI,
            e *= this.earthPanSpeed,
            B.set(0, 0, 0, 1),
            F.set(0, 0, 0, 1),
            A = !0,
            t) {
            case "right":
                z(-e);
                break;
            case "left":
                z(e);
                break;
            case "up":
                q(e);
                break;
            case "down":
                q(-e)
            }
        }
        ;
        let et = function() {
            let t, e = !1;
            return function() {
                e = !0,
                t && e && clearTimeout(t),
                t = setTimeout(function() {
                    r.dispatchEvent(s),
                    e = !1
                }, 300)
            }
        }();
        function nt(t) {
            !1 === r.enabled || !1 === r.enableZoom || u !== l.NONE && u !== l.ROTATE || (t.preventDefault(),
            t.stopPropagation(),
            r.dispatchEvent(o),
            function(t) {
                let e = Y(t);
                U.x = e.x / r.domElement.clientWidth * 2 - 1,
                U.y = -e.y / r.domElement.clientHeight * 2 + 1,
                t.deltaY < 0 ? ($(N()),
                r.dispatchEvent(a)) : t.deltaY > 0 && (K(N()),
                r.dispatchEvent(a)),
                r.update()
            }(t),
            et())
        }
        function rt(t) {
            !1 !== r.enabled && !1 !== r.enableKeys && !1 !== r.enablePan && function(t) {
                switch (t.keyCode) {
                case r.keys.UP:
                    G(0, r.keyPanSpeed),
                    r.update();
                    break;
                case r.keys.BOTTOM:
                    G(0, -r.keyPanSpeed),
                    r.update();
                    break;
                case r.keys.LEFT:
                    G(r.keyPanSpeed, 0),
                    r.update();
                    break;
                case r.keys.RIGHT:
                    G(-r.keyPanSpeed, 0),
                    r.update()
                }
            }(t)
        }
        function at(t) {
            if (!1 !== r.enabled) {
                switch (t.touches.length) {
                case 1:
                    if (!1 === r.enableRotate)
                        return;
                    !function(t) {
                        g.set(t.touches[0].pageX, t.touches[0].pageY)
                    }(t),
                    u = l.TOUCH_ROTATE;
                    break;
                case 3:
                    if (!1 === r.enableZoom)
                        return;
                    X(t),
                    u = l.TOUCH_PAN;
                    break;
                case 2:
                    if (T.set(t.touches[0].pageX, t.touches[0].pageY),
                    M.set(t.touches[1].pageX, t.touches[1].pageY),
                    !1 === r.enablePan)
                        return;
                    X(t),
                    function(t) {
                        var e = t.touches[0].pageX - t.touches[1].pageX
                          , n = t.touches[0].pageY - t.touches[1].pageY
                          , r = Math.sqrt(e * e + n * n);
                        w.set(0, r)
                    }(t),
                    u = l.TOUCH_PAN;
                    break;
                default:
                    u = l.NONE
                }
                u !== l.NONE && r.dispatchEvent(o)
            }
        }
        function it(t) {
            if (!1 !== r.enabled)
                switch (t.preventDefault(),
                t.stopPropagation(),
                t.touches.length) {
                case 1:
                    if (!1 === r.enableRotate)
                        return;
                    if (u !== l.TOUCH_ROTATE)
                        return;
                    !function(t) {
                        A = !0,
                        v.set(t.touches[0].pageX, t.touches[0].pageY),
                        y.subVectors(v, g);
                        var e = r.domElement === document ? r.domElement.body : r.domElement;
                        z(2 * Math.PI * y.x / e.clientWidth * r.earthPanSpeed),
                        q(2 * Math.PI * y.y / e.clientHeight * r.earthPanSpeed),
                        g.copy(v),
                        r.update()
                    }(t);
                    break;
                case 3:
                    if (!1 === r.enableZoom)
                        return;
                    if (u !== l.TOUCH_PAN)
                        return;
                    J(t);
                    break;
                case 2:
                    var e = new THREE.Vector2(t.touches[0].pageX,t.touches[0].pageY)
                      , n = new THREE.Vector2(t.touches[1].pageX,t.touches[1].pageY)
                      , a = e.sub(T).normalize()
                      , i = n.sub(M).normalize();
                    if (a.dot(i) > 0) {
                        if (u = l.TOUCH_PAN,
                        !1 === r.enablePan)
                            return;
                        J(t)
                    } else {
                        if (u = l.TOUCH_DOLLY,
                        !1 === r.enableZoom)
                            return;
                        !function(t) {
                            var e = t.touches[0].pageX - t.touches[1].pageX
                              , n = t.touches[0].pageY - t.touches[1].pageY
                              , a = Math.sqrt(e * e + n * n);
                            C.set(0, a),
                            E.subVectors(C, w),
                            E.y > 0 ? $(N()) : E.y < 0 && K(N()),
                            w.copy(C),
                            r.update()
                        }(t)
                    }
                    break;
                default:
                    u = l.NONE
                }
        }
        function ot(t) {
            !1 !== r.enabled && (r.dispatchEvent(s),
            u = l.NONE)
        }
        function st(t) {
            !1 !== r.enabled && t.preventDefault()
        }
        r.domElement.addEventListener("contextmenu", st, !1),
        r.domElement.addEventListener("mousedown", Q, !1),
        r.domElement.addEventListener("wheel", nt, !1),
        r.domElement.addEventListener("touchstart", at, !1),
        r.domElement.addEventListener("touchend", ot, !1),
        r.domElement.addEventListener("touchmove", it, !1),
        window.addEventListener("keydown", rt, !1),
        r.setLeftInteractive = function(t) {
            r.mouseButtons = t ? {
                ORBIT: 0,
                ZOOM: 1,
                PAN: 2
            } : {
                ORBIT: 2,
                ZOOM: 1,
                PAN: 0
            },
            r._leftInteractive = t
        }
        ,
        this.update(),
        r.pan = G,
        r.panDelta = b
    }
    ,
    THREE.EarthOrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype),
    THREE.EarthOrbitControls.prototype.constructor = THREE.EarthOrbitControls,
    Object.defineProperties(THREE.EarthOrbitControls.prototype, {
        leftInteractive: {
            get: function() {
                return this._leftInteractive
            },
            set: function(t) {
                this.setLeftInteractive(t)
            }
        },
        center: {
            get: function() {
                return THING.Utils.warn("THREE.EarthOrbitControls: .center has been renamed to .target"),
                this.target
            }
        },
        noZoom: {
            get: function() {
                return THING.Utils.warn("THREE.EarthOrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),
                !this.enableZoom
            },
            set: function(t) {
                THING.Utils.warn("THREE.EarthOrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),
                this.enableZoom = !t
            }
        },
        noRotate: {
            get: function() {
                return THING.Utils.warn("THREE.EarthOrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),
                !this.enableRotate
            },
            set: function(t) {
                THING.Utils.warn("THREE.EarthOrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),
                this.enableRotate = !t
            }
        },
        noPan: {
            get: function() {
                return THING.Utils.warn("THREE.EarthOrbitControls: .noPan has been deprecated. Use .enablePan instead."),
                !this.enablePan
            },
            set: function(t) {
                THING.Utils.warn("THREE.EarthOrbitControls: .noPan has been deprecated. Use .enablePan instead."),
                this.enablePan = !t
            }
        },
        noKeys: {
            get: function() {
                return THING.Utils.warn("THREE.EarthOrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),
                !this.enableKeys
            },
            set: function(t) {
                THING.Utils.warn("THREE.EarthOrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),
                this.enableKeys = !t
            }
        },
        staticMoving: {
            get: function() {
                return THING.Utils.warn("THREE.EarthOrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),
                !this.enableDamping
            },
            set: function(t) {
                THING.Utils.warn("THREE.EarthOrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),
                this.enableDamping = !t
            }
        },
        dynamicDampingFactor: {
            get: function() {
                return THING.Utils.warn("THREE.EarthOrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),
                this.dampingFactor
            },
            set: function(t) {
                THING.Utils.warn("THREE.EarthOrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),
                this.dampingFactor = t
            }
        },
        minPolarAngle: {
            get: function() {
                return this._minPolarAngle
            },
            set: function(t) {
                this._minPolarAngle = t
            }
        },
        maxPolarAngle: {
            get: function() {
                return this._maxPolarAngle
            },
            set: function(t) {
                this._maxPolarAngle = t < this.maxPitchAngle * Math.PI / 180 ? t : this.maxPitchAngle * Math.PI / 180
            }
        }
    }),
    THREE.EarthOrbitControls.prototype.setLookAt = function(t) {
        this.object.lookAt(new THREE.Vector3(t[0],t[1],t[2]))
    }
    ;
    const o = 2e7
      , s = 10
      , l = Math.pow(500 / o, 1 / 18)
      , u = 20
      , c = o * Math.exp(u * Math.log(l))
      , h = 22;
    var d = class {
        static getLevelByDistance(t) {
            return t <= s ? h : t < c ? h - 1 - Math.floor((t - s) / ((c - s) / (h - u))) : Math.abs(Math.ceil(Math.log(t / o) / Math.log(l)))
        }
        static getCurentLevel(t) {
            let e = t.camera.curOrbit.object.position.distanceTo(t.camera.curOrbit._getIntersectPoint());
            return this.getLevelByDistance(e)
        }
        static getCurentVisible(t, e, n) {
            let a = !0;
            n = THING.Utils.parseValue(n, 3e3);
            let i = t.camera.curOrbit.object.position.distanceTo(t.camera.curOrbit._getIntersectPoint());
            if (e instanceof Array) {
                let n = t.camera.curOrbit.object.position;
                n = [n.x, n.y, n.z];
                let a = r.a.convertLonlat2World(e, 1);
                i = t3djs.math.vectorDistance(n, a)
            }
            return i < n && (a = !1),
            a
        }
        static getDistanceByLevel(t) {
            let e = 0;
            return e = (t = Math.floor(t)) <= 0 ? o : t >= h ? s : t > u ? ((e = o * Math.exp(u * Math.log(l))) - s) / (h - u) : o * Math.exp(t * Math.log(l))
        }
        static getCameraHeightByLevel(t) {
            var e = this.getDistanceByLevel(t)
              , n = THING.App.current.camera.getCameInfo().pitch;
            return e * Math.sin(Math.degToRad(n))
        }
    }
    ;
    var f = class extends THING.Selector {
        constructor(t) {
            super(t),
            this.app = t
        }
        removeAll(t) {
            for (let e = this.objects.length - 1; e >= 0; e--)
                this.remove(this.objects[e], t)
        }
        remove(t) {
            t.isBaseObject && t.destroy(),
            super.remove(t)
        }
    }
      , p = n(7);
    var m = class extends f {
        constructor(t) {
            super(t),
            this._uEarth = t.uEarth,
            this._visible = !0,
            this._depthMode = THING.App.current.uEarth.depthMode
        }
        add(t, e) {
            return super.add(t),
            "TileLayer" === t.layerType ? t.visible && (this._uEarth._earthInstance.addTileLayer(t, e),
            t.style.night = this._uEarth.style.night,
            this._uEarth._earthInstance.tileEarth.changeStyle()) : "Tile3dLayer" === t.layerType ? this._uEarth._earthInstance.addTile3dLayer(t) : "TerrainLayer" === t.layerType ? this._uEarth.terrainLayer.url = t.url : "VectorBaseLayer" === t.layerType && t3djs.rootNode.attachObject(t),
            this._uEarth.allLayers.add(t),
            this.buildReturnObject(this.objects)
        }
        remove(t) {
            if ("TileLayer" === t.layerType)
                this._uEarth._earthInstance.removeTileLayer(t),
                this._uEarth._earthInstance.tileEarth.changeStyle();
            else if ("Tile3dLayer" === t.layerType)
                this._uEarth._earthInstance.removeTile3dLayer(t);
            else if ("Terrain" === t.layerType)
                this._uEarth.terrainLayer.url = "";
            else if ("VectorBaseLayer" === t.layerType) {
                THING.App.current.uEarth.depthMode = this._depthMode;
                let e = t._layer || t.node;
                t3djs.rootNode.remove(e),
                t3djs.rootNode.removeChildMaterialBuffer(e)
            }
            return super.remove(t),
            this._uEarth.allLayers.remove(t),
            this.buildReturnObject(this.objects)
        }
        get visible() {
            return this._visible
        }
        set visible(t) {
            let e = t3djs.buffer.nodeBuffer.get("tiles-root");
            e && (e.visible = t);
            let n = t3djs.buffer.nodeBuffer.get("earthAtmosphereNode");
            n && (n.visible = t),
            this._visible = t
        }
    }
    ;
    var g = class extends f {
        constructor(t) {
            super(t),
            this.app = t,
            this._uEarth = t.uEarth
        }
        add(t) {
            return t.isLayer || THING.Utils.warn("only layer can be added"),
            "TileFeatureLayer" !== t.layerType && "TileBuildingLayer" !== t.layerType && "Tile3dLayer" !== t.layerType || this._uEarth._earthInstance.addTile3dLayer(t),
            t3djs.rootNode.attachObject(t),
            super.add(t),
            this._uEarth.allLayers.add(t),
            setTimeout(()=>{
                this.app.rendererManager._mainRenderer.dirty()
            }
            , 20),
            this.buildReturnObject(this.objects)
        }
        remove(t, e) {
            let n;
            "string" == typeof t ? n = (n = this._uEarth.allLayers.query("#" + t))[0] : "object" == typeof t ? n = t : "number" == typeof t && (n = this.objects[t]);
            let r = n._layer || n.node;
            n.is2D ? t3djs.earthRoot.remove(r) : t3djs.rootNode.remove(r),
            t3djs.rootNode.removeChildMaterialBuffer(r),
            n._layerScene && n._layerScene.map(t=>{
                t.destroy()
            }
            ),
            this._uEarth.allLayers.remove(n),
            this.app.rendererManager._mainRenderer.dirty(),
            super.remove(n);
            for (var a = n.children.length - 1; a >= 0; a--)
                n.children[a].destroy();
            n.destroy(e)
        }
    }
      , v = {
        Scene_2D: 0,
        Scene_3D: 1
    };
    class y extends THING.BaseObject {
        constructor(t) {
            super(t),
            this.app = t,
            this._visible = !0,
            this.scene = [],
            this._backups = {
                camera: {},
                lighting: {},
                postEffect: {}
            }
        }
        setup(t) {
            let e = this.app;
            var n = this
              , r = window.t3djs.buffer.nodeBuffer.get("earthRoot")
              , a = window.t3djs.rootNode
              , i = window.t3djs.earthRoot;
            e.on(THING.EventType.LevelChange, function(t) {
                setTimeout(()=>{
                    n.onCampusLevelFly(t),
                    e.picker.pickedResultFunc = function(t) {
                        return t
                    }
                }
                , 10)
            });
            e.on(THING.EventType.Pick, function(t) {
                var o = e.level;
                if (o.current) {
                    n._lastPickedObject && n._lastPickedObject.style && (n._lastPickedObject.style.outlineColor = null);
                    var s = t.object;
                    (function(t) {
                        var n = e.level.current;
                        return !(!n || !t || t === n || "Ground" === t.type || t.isMarker || "Map" === t.type || n.isCampus && t.isChildOf(n.ground) || t.node.isChildOf(r) || t.node.isChildOf(a) || t.node.isChildOf(i))
                    }
                    )(s) && (s.style.outlineColor = o.options.outlineColor),
                    n._lastPickedObject = s
                }
            }, THING.EventTag.LevelPickOperation)
        }
        clearBackupInfo(t, e) {
            delete this._backups[t][e]
        }
        onCampusLevelFly(t) {
            var e = t.object;
            let n = e.parents
              , r = !1;
            if ("Campus" === e.type)
                r = !0;
            else
                for (let t = 0; t < n.length; t++)
                    if (n[t].type && "Campus" === n[t].type) {
                        r = !0;
                        break
                    }
            if (r) {
                var a, i, o = e.sceneJSONData ? e.sceneJSONData.camInfo : null;
                o && (a = o.eye.concat(),
                i = o.target.concat(),
                a = e.selfToWorld(a),
                i = e.selfToWorld(i));
                var s = t.position || this.getBackupInfoValue("camera", "Campus", "position") || a
                  , l = t.target || this.getBackupInfoValue("camera", "Campus", "target") || i || e
                  , u = t.radius || Math.min(e.boundingBox.radius, 300);
                this.app.camera.flyTo(this.buildFlyParams({
                    position: s,
                    target: l,
                    radius: u
                }, t))
            }
        }
        getBackupInfoValue(t, e, n) {
            var r = this._backups[t][e];
            return r ? r[n] : null
        }
        buildFlyParams(t, e) {
            e = e || {};
            var n = this;
            let r = THING.Utils;
            t._flyStart = function() {
                n._levelChanging = !0
            }
            ,
            t._flying = function() {
                n._levelChanging = !0
            }
            ,
            t._flyStop = function() {
                n._levelChanging = !1
            }
            ,
            t._flyComplete = function() {
                n._levelChanging = !1
            }
            ,
            t.distance = t.distance || e.distance,
            t.time = r.parseValue(t.time || e.time, 1e3),
            t.keepDirection = r.parseValue(t.keepDirection || e.keepDirection, !1);
            var a = this.app.level.current;
            e.lastObject === a && (t.offset = t.offset || e.offset,
            t.worldOffset = t.worldOffset || e.worldOffset,
            t.radius = t.radius || e.radius || a.boundingBox.radius,
            t.xAngle = r.parseValue(t.xAngle || e.xAngle, null),
            t.yAngle = r.parseValue(t.yAngle || e.yAngle, null)),
            t.targetForFlyComplete = a;
            var i = a.userData.camInfo;
            if (i) {
                var o = a.parents.query(".Campus")[0];
                o && (t.target = o.selfToWorld(i.target),
                t.position = o.selfToWorld(i.eye))
            }
            return t
        }
        add(t) {
            this.scene.push(t)
        }
        customSetup(t) {}
        destroy() {
            this.scene.length > 0 && this.scene.map(t=>{
                t.destroy()
            }
            )
        }
        set visible(t) {
            this.scene.length > 0 && this.scene.map(e=>{
                e.visible = t
            }
            ),
            this._visible = t
        }
        get visible() {
            return this._visible
        }
    }
    THING.factory.registerClass("CampusManager", y);
    var _ = class {
        constructor(t, e) {
            t = t || {},
            this.id = t.id,
            this.name = t.name,
            this.radius = THING.Utils.parseValue(t.radius, 6378e3),
            this.position = THING.Utils.parseValue(t.position, [0, 0, 0]),
            this.scale = this.radius / 6378e3,
            this.mode = v.Scene_3D,
            this.state = "wait",
            this.ellipsoid = Cesium.Ellipsoid.WGS84,
            this.t3djs = e
        }
        setNearClipDistance(t) {
            this.app.camera.near = t
        }
        setFarClipDistance(t) {
            this.app.camera.far = t
        }
        update() {
            if (this.app.domElement.getClientRects()[0]) {
                const t = this.app.camera.position
                  , e = THING.Math.getVectorLength(t)
                  , n = e - this.radius
                  , r = 5e7
                  , a = this.app.camera.fov
                  , i = this.app.domElement.getClientRects()[0].width / this.app.domElement.getClientRects()[0].height
                  , o = e * Math.tan(THING.Math.degToRad(a))
                  , s = o * i
                  , l = Math.pow(o * o + s * s, .5)
                  , u = Math.pow(l * l + e * e, .5);
                u < r ? this.setFarClipDistance(r) : this.setFarClipDistance(u),
                n > 1e4 && n <= 1e5 && this.setNearClipDistance(100),
                n > 1e3 && n <= 1e4 ? this.setNearClipDistance(10) : n > 100 && n <= 1e3 ? this.setNearClipDistance(1) : n > 1 && n <= 100 ? this.setNearClipDistance(.1) : n <= 1 ? this.setNearClipDistance(.01) : n > 1e5 && n < 6e7 && this.setNearClipDistance(n / 20)
            }
        }
    }
      , x = {
        WireFrame: 0,
        Edge: 1
    };
    var b = class {
        constructor(t, e) {
            this.name = r.a.getUUID()
        }
        setEdges(t) {
            this.edges = t
        }
        setUp(t, e, n=function() {}
        ) {
            if (this.params = e,
            this.layer = t,
            this.extent = t.extent,
            this.effect = void 0 === e.effect ? x.WireFrame : e.effect,
            this.minCoordinates = [],
            this.maxCoordinates = [],
            this._angle = void 0 === e.angle ? 0 : e.angle,
            this.extent) {
                var r = this._angle % 360;
                r < 0 && (r += 360),
                r >= 0 && r < 90 ? (this.minCoordinates = [this.extent.minX, this.extent.minY],
                this.maxCoordinates = [this.extent.maxX, this.extent.maxY]) : r >= 90 && r < 180 ? (this.minCoordinates = [this.extent.minX, this.extent.maxY],
                this.maxCoordinates = [this.extent.maxX, this.extent.minY]) : r >= 180 && r < 270 ? (this.minCoordinates = [this.extent.maxX, this.extent.maxY],
                this.maxCoordinates = [this.extent.minX, this.extent.minY]) : r >= 270 & r < 360 && (this.minCoordinates = [this.extent.maxX, this.extent.minY],
                this.maxCoordinates = [this.extent.minX, this.extent.maxY])
            }
            if (e.startCoordinates && (this.minCoordinates = e.startCoordinates),
            e.endCoordinates && (this.maxCoordinates = e.endCoordinates),
            this.minCoordinates.length < 2 || this.maxCoordinates.length < 2)
                return console.error("该数据没有extent也没有传入起点和终点，无法进行扫光"),
                void (this._error = !0);
            this.rootNode = t.node,
            this.meshes = this.rootNode.getMeshes(),
            this.inverseMatrixWorld = new THREE.Matrix4,
            this.originalMin = new THREE.Vector3,
            this.originalMax = new THREE.Vector3,
            this.min = new THREE.Vector3,
            this.max = new THREE.Vector3,
            this._speed = THING.Utils.parseValue(e.speed, 1),
            this.record = 1e3 / this._speed,
            this.speed = [1, 1, 1],
            this.running = 0,
            this.startPosition = new THREE.Vector3,
            this.endPosition = new THREE.Vector3,
            this.uvRatio = 1,
            this._textureLoader = new THREE.TextureLoader,
            this.texture = null,
            e.uvMapUrl && (this.texture = this._textureLoader.load(e.uvMapUrl)),
            e.color = e.color || [255, 255, 255],
            this.color = CMAP.Util.colorFormatNewToOld(e.color),
            this.color = new THREE.Vector3(this.color[0],this.color[1],this.color[2]);
            let a = 1e4;
            t.extent && (a = CMAP.Util.getSphericalDistance([t.extent.maxX, t.extent.maxY], [t.extent.minX, t.extent.minY])),
            this.maxDistance = THING.Utils.parseValue(e.maxDistance, a),
            this.bandWidth = THING.Utils.parseValue(e.bandSize, this.maxDistance),
            this.bandWidth = 2 * this.bandWidth,
            this.bandSize = THING.Utils.parseValue(e.bandWidth, 5e3),
            this.bandSize = 2 * this.bandSize,
            this.bandHeight = THING.Utils.parseValue(e.bandWidth, 1e3),
            this._size = [this.bandWidth, this.bandSize, this.bandHeight],
            this.blending = e.blending ? THREE.AdditiveBlending : THREE.NormalBlending,
            this.effect === x.Edge ? this.edges ? (this.edges.map(t=>{
                let e = t.material;
                e.depthWrite = !1,
                e.uniforms.color.value = this.color,
                e.uniforms.relativeModelMatrix.value = new THREE.Matrix4,
                this.texture && (e.defines.USE_UVMAP = !0,
                e.uniforms.uvMap.value = this.texture),
                e.needsUpdate = !0
            }
            ),
            this.init(),
            n("finish")) : this.createEdge(()=>{
                this.init(),
                n("finish")
            }
            ) : (this.init(),
            n("finish"))
        }
        createEdge(t=function() {}
        ) {
            console.time(),
            this.edges = [];
            let e = []
              , n = THING.Utils.parseValue(this.layer.renderOrder, 0);
            n -= .1,
            this.layer.node.traverse(t=>{
                if (t.isMesh) {
                    let r = THREE.ScanningMaterial1({
                        color: this.color
                    });
                    r.depthWrite = !1,
                    r.defines.USE_RELATIVE = !0,
                    r.uniforms.relativeModelMatrix.value = new THREE.Matrix4,
                    this.texture && (r.defines.USE_UVMAP = !0,
                    r.uniforms.uvMap.value = this.texture),
                    r.wireframe = !1,
                    r.needsUpdate = !0;
                    let a = t.geometry;
                    window.EW && EW.setThreadsNumber(4);
                    let i = THING.App.current.edgesGeometriesManager.get(a);
                    if (i.isBufferGeometry) {
                        let e = new THREE.LineSegments(i,r);
                        e.renderOrder = n,
                        e.visible = !1,
                        t.parent.add(e),
                        t.__edgeLine = e,
                        t._scanningMat = r,
                        this.edges.push(t.__edgeLine)
                    } else {
                        let a = i.then(e=>{
                            if (!a._break) {
                                let a = new THREE.LineSegments(e,r);
                                return a.renderOrder = n,
                                a.visible = !1,
                                t.parent.add(a),
                                t.__edgeLine = a,
                                t._scanningMat = r,
                                this.edges.push(t.__edgeLine),
                                Promise.resolve(a)
                            }
                        }
                        );
                        e.push(i)
                    }
                }
            }
            ),
            0 === e.length ? (t("finish"),
            console.timeEnd()) : Promise.all(e).then(e=>{
                t("finish"),
                console.timeEnd()
            }
            )
        }
        showDebug(t) {
            (t = !1 !== t) ? (this.baseObject.node.visible = !0,
            this.debugBox.material.opacity = .3,
            this.debugObject.style.axisHelper = !0) : (this.baseObject.node.visible = !1,
            this.debugObject.style.axisHelper = !1,
            this.debugBox.material.opacity = 0)
        }
        init() {
            var t = this
              , e = CMAP.Util.convertLonlatToWorld(this.minCoordinates, this.layer.offsetHeight)
              , n = CMAP.Util.convertLonlatToWorld(this.maxCoordinates, this.layer.offsetHeight);
            this.startPosition = new THREE.Vector3(e[0],e[1],e[2]),
            this.endPosition = new THREE.Vector3(n[0],n[1],n[2]);
            var a = new THREE.Object3D;
            a.position.set(this.startPosition.x, this.startPosition.y, this.startPosition.z);
            var i = r.a.positionToQuaternion(e, this.minCoordinates[0] + 90 - this._angle);
            a.setRotationFromQuaternion(i),
            this.rootNode.add(a),
            this.debugBox = new THREE.Mesh(new THREE.BoxGeometry(this.bandWidth,this.bandSize,this.bandHeight),new THREE.MeshStandardMaterial({
                color: new THREE.Color(1,0,0),
                transparent: !0,
                opacity: 0,
                depthWrite: !1
            })),
            a.add(this.debugBox),
            this.baseObject = this.layer.app.create({
                type: "Thing",
                userData: {
                    SKIP_THEME: 1
                }
            }),
            this.baseObject.node = a,
            this.baseObject.node.visible = !1,
            this.baseObject.inheritVisible = !1,
            this.debugObject = this.layer.app.create({
                type: "Thing",
                userData: {
                    SKIP_THEME: 1
                }
            }),
            this.debugObject.node = this.debugBox,
            a.updateMatrixWorld(!0),
            this.inverseMatrixWorld.getInverse(a.matrixWorld),
            this.endPosition.applyMatrix4(this.inverseMatrixWorld),
            this.speed = this._getSpeed();
            for (var o = this.debugBox.geometry.vertices, s = new THREE.Box3, l = new THREE.Vector3, u = 0, c = o.length; u < c; u++)
                l.copy(o[u]),
                s.expandByPoint(l);
            this.min = s.min,
            this.max = s.max,
            this.originalMin.copy(s.min),
            this.originalMax.copy(s.max),
            this.meshes.map(e=>{
                var n;
                this.effect === x.WireFrame ? ((n = THREE.ScanningMaterial1({
                    color: t.color
                })).depthWrite = !1,
                n.defines.USE_RELATIVE = !0,
                t.texture && (n.defines.USE_UVMAP = !0,
                n.uniforms.uvMap.value = t.texture),
                n.needsUpdate = !0,
                e._afterRendererMaterial || (e._afterRendererMaterial = []),
                e._afterRendererMaterial.push(n),
                e._scanningMat = n) : this.effect === x.Edge && (n = e._scanningMat,
                e.__edgeLine.visible = !0);
                let r = new THREE.Matrix4;
                r.copy(e.matrixWorld),
                r = r.multiplyMatrices(t.inverseMatrixWorld, r),
                n.uniforms.relativeModelMatrix.value = r,
                n.uniforms.maxPos.value.copy(t.max),
                n.uniforms.minPos.value.copy(t.min),
                n.uniforms.direction.value = new THREE.Vector3(t.speed[0],t.speed[1],t.speed[2]),
                n.blending = t.blending
            }
            )
        }
        triggerUpdate(t) {
            if (this._error)
                return;
            let e = THING.Utils.parseValue(t.angle, 0)
              , n = !1
              , r = !1
              , a = CMAP.Util.colorFormatNewToOld(t.color);
            this.color = void 0 === t.color ? this.color : new THREE.Vector3(a[0],a[1],a[2]),
            this.texture = t.uvMapUrl ? this._textureLoader.load(t.uvMapUrl) : this.texture,
            this._speed = t.speed || this._speed,
            this.record = 1e3 / this._speed,
            (t.bandWidth || t.bandSize || t.bandHeight) && (n = !0,
            this._size = [t.bandWidth || this._size[0], t.bandSize || this._size[1], t.bandHeight || this._size[2]]),
            e && (r = !0,
            this.baseObject.node.rotateY(e * Math.PI / 180)),
            n ? this._updateDebugBox() : r && this._updateBaseNode(),
            this._updateMaterial()
        }
        _updateDebugBox() {
            this.debugObject.destroy(),
            this.debugBox = new THREE.Mesh(new THREE.BoxGeometry(this.bandWidth,this.bandSize,this.bandHeight),new THREE.MeshBasicMaterial({
                color: new THREE.Color(1,0,0),
                transparent: !0,
                opacity: .3,
                depthWrite: !1
            })),
            this.baseObject.node.add(this.debugBox),
            this.debugObject = this.layer.app.create({
                type: "Thing"
            }),
            this.debugObject.node = this.debugBox,
            this._updateBaseNode()
        }
        _updateMaterial() {
            var t = this;
            this.meshes.map(e=>{
                var n = e._scanningMat;
                n.uniforms.color.value = t.color,
                n.uniforms.uvMap.value = t.texture
            }
            )
        }
        _updateBaseNode() {
            let t = this.baseObject.node;
            t.updateMatrixWorld(!0),
            this.inverseMatrixWorld.getInverse(t.matrixWorld),
            this.endPosition.applyMatrix4(this.inverseMatrixWorld),
            this.debugBox.position.set(0, 0, 0);
            for (var e = this.debugBox.geometry.vertices, n = new THREE.Box3, r = new THREE.Vector3, a = 0, i = e.length; a < i; a++)
                r.copy(e[a]),
                n.expandByPoint(r);
            this.min = n.min,
            this.max = n.max,
            this.originalMin.copy(n.min),
            this.originalMax.copy(n.max);
            var o = this;
            this.meshes.map(t=>{
                var e = t._scanningMat
                  , n = new THREE.Matrix4;
                n.copy(t.matrixWorld),
                n = n.multiplyMatrices(o.inverseMatrixWorld, n),
                e.uniforms.relativeModelMatrix.value = n,
                e.uniforms.maxPos.value.copy(o.max),
                e.uniforms.minPos.value.copy(o.min)
            }
            )
        }
        _getSpeed() {
            return [0, 0, THING.App.current.deltaTime / 16.667 * this.maxDistance / this.record]
        }
        onUpdate() {
            if (this._error)
                return;
            this.running >= this.record && (this.min.copy(this.originalMin),
            this.max.copy(this.originalMax),
            this.debugBox.position.set(0, 0, 0),
            this.running = 0);
            let t = this.meshes;
            for (var e = 0; e < t.length; e++)
                this.effect === x.ChangeEffect ? t[e]._scanningMat._shader && (t[e]._scanningMat._shader.uniforms.maxPos.value.copy(this.max),
                t[e]._scanningMat._shader.uniforms.minPos.value.copy(this.min)) : (t[e]._scanningMat.uniforms.maxPos.value.copy(this.max),
                t[e]._scanningMat.uniforms.minPos.value.copy(this.min));
            this._updateData(this.debugBox.position, this.speed),
            this._updateData(this.min, this.speed),
            this._updateData(this.max, this.speed),
            this.running++
        }
        _updateData(t, e) {
            return t.z += THING.App.current.deltaTime / 16.66 * e[2],
            t
        }
        destroy(t=!0) {
            if (!this._error && (this.debugObject.destroy(),
            this.baseObject.destroy(),
            this.meshes.map(t=>{
                if (t._afterRendererMaterial)
                    for (let e = t._afterRendererMaterial.length - 1; e >= 0; e--)
                        "scanning" === t._afterRendererMaterial[e].type && t._afterRendererMaterial.splice(e, 1)
            }
            ),
            t)) {
                let t = this.edges;
                t && t.length && t.map(t=>{
                    t.destroy()
                }
                )
            }
        }
    }
    ;
    var w = class {
        constructor(t, e) {
            this.name = r.a.getUUID()
        }
        setUp(t, e, n=function() {}
        ) {
            this._layer = t,
            this._meshes = t.node.getMeshes(),
            this._setParams(e),
            this._getCenter(),
            this._createMaterial(),
            this.effect === x.Edge ? (this._scanningMat.wireframe = !1,
            this._scanningMat.visible = !1,
            this.createEdge(()=>{
                this._createCoordinate(this.edges),
                this._updateGlow(),
                this._scanningMat.visible = !0,
                n("finish")
            }
            )) : (this._createCoordinate(this._meshes),
            this._meshes.map(t=>{
                t._afterRendererMaterial || (t._afterRendererMaterial = []),
                t._afterRendererMaterial.push(this._scanningMat)
            }
            ),
            n("finish"))
        }
        _setParams(t={}) {
            let e = {
                color: "#5588aa",
                map: null,
                speed: 1,
                angle: 0,
                blending: !0,
                effect: x.Edge,
                scanningLength: .1,
                glow: !1,
                direction: [0, 1]
            };
            t = Object.assign({}, e, t),
            this.color = CMAP.Util.colorFormatNewToOld(t.color),
            this.color = new THREE.Color(this.color[0],this.color[1],this.color[2]),
            this.speed = t.speed,
            this.blending = t.blending ? 2 : 1,
            this._textureLoader = new THREE.TextureLoader,
            this.texture = null,
            this.direction = t.direction;
            let n = t.map ? t.map : t.uvMapUrl;
            n && (this.texture = this._textureLoader.load(n),
            this.texture.wrapS = this.texture.wrapT = THREE.RepeatWrapping,
            this.texture.rotation = t.angle * Math.PI / 180,
            this.angle = t.angle),
            this.effect = t.effect,
            this.scanningLength = t.scanningLength,
            this.glow = t.glow
        }
        _getCenter() {
            let t = this._layer.extent;
            this.center = [(t.minX + t.maxX) / 2, (t.minY + t.maxY) / 2],
            this.min = [t.minX, t.minY],
            this.extentLength = [t.maxX - t.minX, t.maxY - t.minY]
        }
        _createCoordinate(t) {
            this._layer.node.updateMatrixWorld(!0),
            t.map(t=>{
                let e = t.geometry.attributes.position
                  , n = e.count
                  , a = new Float32Array(2 * n);
                for (var i = t.matrixWorld, o = 0, s = n; o < s; o++) {
                    var l = new THREE.Vector3;
                    l.x = e.getX(o),
                    l.y = e.getY(o),
                    l.z = e.getZ(o),
                    l.applyMatrix4(i);
                    var u = r.a.world2Lonlat([l.x, l.y, l.z], [0, 0, 0]);
                    a[2 * o] = u[0],
                    a[2 * o] -= this.min[0],
                    a[2 * o] /= this.extentLength[0],
                    a[2 * o + 1] = u[1],
                    a[2 * o + 1] -= this.min[1],
                    a[2 * o + 1] /= this.extentLength[1]
                }
                t.geometry.addAttribute("coordinates", new THREE.BufferAttribute(a,2))
            }
            )
        }
        _createMaterial() {
            let t = t3djs.materialManager.createMaterial(null, "scanningCityMaterial").getMaterial()[0];
            t.depthWrite = !1,
            this._scanningMat = t,
            t.uniforms.u_r.value = .1,
            t.uniforms.u_length.value = this.scanningLength,
            t.uniforms.scanningColor.value = this.color,
            t.uniforms.center.value = new THREE.Vector2(.5,.5),
            this.texture && (t.defines.USE_MAP = !0,
            t.uniforms.map.value = this.texture,
            this.texture.matrix.setUvTransform(this.texture.offset.x, this.texture.offset.y, this.texture.repeat.x, this.texture.repeat.y, this.texture.rotation, this.texture.center.x, this.texture.center.y),
            t.uniforms.uvTransform.value.copy(this.texture.matrix)),
            t.wireframe = !0,
            t.blending = this.blending
        }
        createEdge(t=function() {}
        ) {
            console.time(),
            this.edges = [];
            let e = []
              , n = THING.Utils.parseValue(this._layer.renderOrder, 0);
            n -= .1,
            this._layer.node.traverse(t=>{
                if (t.isMesh) {
                    let r = t.geometry;
                    window.EW && EW.setThreadsNumber(4);
                    let a = THING.App.current.edgesGeometriesManager.get(r);
                    if (a.isBufferGeometry) {
                        let e = new THREE.LineSegments(a,this._scanningMat);
                        t.parent.add(e),
                        e.renderOrder = n,
                        this.edges.push(e)
                    } else {
                        let r = a.then(e=>{
                            if (!r._break) {
                                let r = new THREE.LineSegments(e,this._scanningMat);
                                return t.parent.add(r),
                                r.renderOrder = n,
                                this.edges.push(r),
                                Promise.resolve(r)
                            }
                        }
                        );
                        e.push(a)
                    }
                }
            }
            ),
            0 === e.length ? (t("finish"),
            console.timeEnd()) : Promise.all(e).then(e=>{
                t("finish"),
                console.timeEnd()
            }
            )
        }
        _updateGlow() {
            THING.Utils.isNull(this.edges) || this.edges.length <= 0 || (this.glow ? this.edges.map(t=>{
                THING.App.current.effectManager.setEffect(t, "glow")
            }
            ) : this.edges.map(t=>{
                THING.App.current.effectManager.removeEffect(t, "glow")
            }
            ))
        }
        onUpdate() {
            const t = this.speed * THING.App.current.deltaTime / 16.667;
            this.texture ? (this.texture.offset.x -= .003 * t * this.direction[0],
            this.texture.offset.y -= .003 * t * this.direction[1],
            this.texture.matrix.setUvTransform(this.texture.offset.x, this.texture.offset.y, this.texture.repeat.x, this.texture.repeat.y, this.texture.rotation, this.texture.center.x, this.texture.center.y),
            this._scanningMat.uniforms.uvTransform.value.copy(this.texture.matrix)) : (this._scanningMat.uniforms.u_r.value += .003 * t,
            this.step = this._scanningMat.uniforms.u_r.value,
            this.step > .7 && (this._scanningMat.uniforms.u_r.value = .2)),
            this.glow && this._layer.app.rendererManager._mainRenderer.dirty("Glow")
        }
        showDebug(t) {
            THING.Utils.log("自定义扫光暂无debug模式")
        }
        updateScanning(t) {
            THING.Utils.isNull(t.color) || (this.color = CMAP.Util.colorFormatNewToOld(t.color),
            this.color = new THREE.Color(this.color[0],this.color[1],this.color[2]),
            this._scanningMat.uniforms.scanningColor.value = this.color),
            THING.Utils.isNull(t.direction) || (this.direction = t.direction),
            THING.Utils.isNull(t.speed) || (this.speed = t.speed);
            let e = THING.Utils.parseValue(t.map, t.uvMapUrl);
            e && (this.texture = this._textureLoader.load(e),
            this.texture.wrapS = this.texture.wrapT = THREE.RepeatWrapping,
            this._scanningMat.uniforms.map.value = this.texture,
            this._scanningMat.needsUpdate = !0),
            THING.Utils.isNull(t.angle) || (this.texture && (this.texture.rotation = t.angle * Math.PI / 180,
            this.texture.matrix.setUvTransform(this.texture.offset.x, this.texture.offset.y, this.texture.repeat.x, this.texture.repeat.y, this.texture.rotation, this.texture.center.x, this.texture.center.y),
            this._scanningMat.uniforms.uvTransform.value.copy(this.texture.matrix)),
            this.angle = t.angle),
            THING.Utils.isNull(t.blending) || (this.blending = t.blending ? 2 : 1,
            this._scanningMat.blending = this.blending),
            THING.Utils.isNull(t.scanningLength) || (this._scanningMat.uniforms.u_length.value = t.scanningLength),
            THING.Utils.isNull(t.glow) || (this.glow = t.glow,
            this._updateGlow())
        }
        destroy() {
            this._meshes.map(t=>{
                if (t._afterRendererMaterial)
                    for (let e = t._afterRendererMaterial.length - 1; e >= 0; e--)
                        "initialScanning" === t._afterRendererMaterial[e].type && t._afterRendererMaterial.splice(e, 1);
                t.geometry.deleteAttribute("coordinates")
            }
            ),
            this.edges && this.edges.map(t=>{
                t.parent.remove(t),
                t.dispose()
            }
            ),
            this._scanningMat = null,
            THING.App.current.rendererManager._mainRenderer.dirty()
        }
    }
      , C = n(2);
    class E extends THING.BaseStyle {
        constructor(t) {
            super(t)
        }
        get opacity() {
            return this.obj.renderer ? this.obj.renderer.opacity : super.opacity
        }
        set opacity(t) {
            this.obj.renderer ? this.obj.renderer.opacity = t : super.opacity = t
        }
    }
    THING.factory.registerClass("GeoStyle", E);
    var T = E
      , M = n(1);
    class A extends THING.BaseObject {
        constructor(t) {
            super(t),
            this.app = t,
            this._layer = this.node,
            this._style = new T(this),
            this.isLayer = !0
        }
        setupParent(t) {
            t || (t = {}),
            void 0 !== t.parent ? super.setParent(t) : CMAP.getCurrentMap() && CMAP.getCurrentMap().add(this)
        }
        customSetup(t) {
            var e, n, r, a;
            this.name = void 0 === t.name ? THREE.Math.generateUUID() : this.name,
            this.id = void 0 === t.id ? this.name : t.id,
            this.renderOrder = void 0 === t.renderOrder ? 0 : t.renderOrder,
            this.inheritVisible = void 0 === t.inheritVisible || t.inheritVisible,
            this._fixedPoint = t.fixedPoint || null,
            this._fixedHeight = THING.Utils.parseValue(t.fixedHeight, 3e3),
            this._updaterName = "layerUpdater_" + this.queryID,
            t.visibleLevel && (this._visibleLevel = t.visibleLevel,
            this._updateFunc = (e = this,
            n = t.visibleLevel,
            r = this._fixedPoint,
            a = this._fixedHeight,
            function() {
                e._setLevel.call(e, n, r, a)
            }
            )),
            this.visible = void 0 === t.visible || t.visible,
            this.app.on(THING.EventType.EnterLevel, "." + this.type, ()=>{}
            , THING.EventTag.LevelCameraControl),
            this.app.on(THING.EventType.EnterLevel, "." + this.type, ()=>{}
            , THING.EventTag.LevelSetBackground),
            this.app.on(THING.EventType.EnterLevel, "." + this.type, ()=>{}
            , THING.EventTag.LevelSetEffect),
            this.app.on(THING.EventType.EnterLevel, "." + this.type, t=>{}
            , THING.EventTag.LevelSceneOperations),
            this.app.on(THING.EventType.EnterLevel, "." + this.type, t=>{
                this.app.uEarth.onCampusLevelPickedResultFunc(t)
            }
            , THING.EventTag.LevelPickedResultFunc),
            this.app.on(THING.EventType.EnterLevel, "." + this.type, t=>{
                this.app.uEarth.onCampusLevelFly(t)
            }
            , THING.EventTag.LevelFly),
            this.app.on(THING.EventType.LeaveLevel, "." + this.type, t=>{
                this.app.uEarth.onCampusLevelSceneOperations()
            }
            , THING.EventTag.LevelSceneOperations)
        }
        onCampusLevelFly(t) {
            t.previous ? t.previous.type !== this.type && "Map" !== t.previous.type && this.app.camera.earthFlyTo(this._lastCameraInfo) : this.app.trigger("cameraFlyComplete")
        }
        setupComplete(t) {
            super.setupComplete(t),
            this.trigger(THING.EventType.LayerComplete, {
                object: this
            }),
            THING.App.current.trigger(THING.EventType.LayerComplete, {
                object: this
            })
        }
        canAcceptEvent(t) {
            return "update" === t.type || !(!t.object || !t.object.isChildOf(this))
        }
        get visibleLevel() {
            return this._visibleLevel
        }
        set visibleLevel(t) {
            this._visibleLevel = t,
            C.a.delete(this._updaterName),
            this._updateFunc = function(t, e, n, r) {
                return function() {
                    t._setLevel.call(t, e, n, r)
                }
            }(this, this._visibleLevel, this._fixedPoint, this._fixedHeight),
            C.a.add(this._updaterName, this._updateFunc)
        }
        _setLevel(t, e, n) {
            if (this.node && this.node)
                if (e) {
                    let t = d.getCurentVisible(this.app, e, n);
                    this.node.visible = t
                } else {
                    let e = d.getCurentLevel(this.app)
                      , n = !0;
                    n = 2 === t.length ? !(e < t[0] || e > t[1]) : !(e < t[0]),
                    this.node.visble !== n && (this.node.visible = n)
                }
        }
        get fixedPoint() {
            return this._fixedPoint
        }
        set fixedPoint(t) {
            var e, n, r;
            t instanceof Array && this._updateFunc && (this._fixedPoint = t,
            C.a.delete(this._updaterName),
            this._updateFunc = (e = this,
            n = this._fixedPoint,
            r = this._fixedHeight,
            function() {
                e._setLevel.call(e, null, n, r)
            }
            ),
            C.a.add(this._updaterName, this._updateFunc))
        }
        get fixedHeight() {
            return this._fixedHeight
        }
        set fixedHeight(t) {
            var e, n, r;
            this._updateFunc && (this._fixedHeight = t,
            C.a.delete(this._updaterName),
            this._updateFunc = (e = this,
            n = this._fixedPoint,
            r = this._fixedHeight,
            function() {
                e._setLevel.call(e, null, n, r)
            }
            ),
            C.a.add(this._updaterName, this._updateFunc))
        }
        show(t) {
            void 0 === t && (t = !0),
            this.visible = t
        }
        hide() {
            this.visible = !1
        }
        setVisible(t, e) {
            if (e)
                for (let e = 0; e < this.children.length; e++)
                    this.children[e].visible = t;
            this.visible = t
        }
        get visible() {
            return this.node.visible
        }
        set visible(t) {
            if (!this.node)
                return null;
            this.node.visible = t,
            this._updateFunc && (t ? C.a.add(this._updaterName, this._updateFunc) : C.a.delete(this._updaterName)),
            this.renderer && "cool" === this.renderer._type && this.renderer._effect && this._updateEffect(t, this.renderer._glowStrength),
            THING.App.current.rendererManager._mainRenderer.dirty(),
            THING.App.current.picker.needUpdate = !0
        }
        _updatePostEffect(t) {
            THING.Utils.isNull(t.postRadialBlur) || this._setPostRadiusEffect(t.postRadialBlur),
            THING.Utils.isNull(t.postRadialBlur2) || this._setPostRadialBlur2(t.postRadialBlur2),
            THING.App.current.rendererManager._mainRenderer.dirty()
        }
        _updateEffect(t, e) {
            this.node.traverse(function(n) {
                n.material && M.a._updateEffect(n, "glow", t, e)
            })
        }
        get children() {
            return this._children
        }
        get renderer() {
            return this._renderer
        }
        get objects() {
            return this.children
        }
        set renderOrder(t) {
            this._renderOrder = t,
            super.style.renderOrder = t,
            this.children.map(function(e) {
                e.renderOrder = t
            })
        }
        get renderOrder() {
            return this._renderOrder
        }
        get offsetHeight() {
            return this._offsetHeight
        }
        set offsetHeight(t) {
            for (var e = 0; e < this.children.length; e++)
                this.children[e].offsetHeight = t;
            this._offsetHeight = t
        }
        get offsetHeightField() {
            return this._offsetHeightField
        }
        set offsetHeightField(t) {
            for (var e = 0; e < this.children.length; e++)
                this.children[e].offsetHeightField = t;
            this._offsetHeightField = t
        }
        get style() {
            return this._style
        }
        startScanning(t) {
            var e = new b(this,t = t || {});
            this.scanning = e,
            this.scanning.setUp(this, t, ()=>{
                this.app.addControl(e, e.name)
            }
            )
        }
        startInitialScanning(t) {
            var e = new w(this,t);
            this.scanning = e,
            this.scanning.setUp(this, t, ()=>{
                this.app.addControl(e, e.name)
            }
            )
        }
        _setPostRadiusEffect(t) {
            for (var e = 0; e < this.children.length; e++) {
                this.children[e]._setPostRadiusEffect(t)
            }
        }
        _setPostRadialBlur2(t) {
            for (var e = 0; e < this.children.length; e++) {
                this.children[e]._setPostRadialBlur2(t)
            }
        }
        destroyScanning(t=!0) {
            this.scanning && (this.scanning.destroy(t),
            this.app.removeControl(this.scanning.name))
        }
        destroyInitialScanning(t=!0) {
            this.scanning && (this.scanning.destroy(t),
            this.app.removeControl(this.scanning.name))
        }
        updateScanning(t) {
            if (this.scanning) {
                let n = this.scanning.params
                  , r = this.scanning.edges;
                if (n = Object.assign({}, n, t),
                r) {
                    this.destroyScanning(!1);
                    var e = new b(this,n);
                    this.scanning = e,
                    e.setEdges(r),
                    this.scanning.setUp(this, n, ()=>{
                        this.app.addControl(e, e.name)
                    }
                    )
                } else
                    this.destroyScanning(),
                    this.startScanning(n)
            }
        }
        updateInitialScanning(t) {
            this.scanning && this.scanning.updateScanning(t)
        }
        showScanningDebug(t) {
            this.scanning && this.scanning.showDebug(t)
        }
        destroy(t) {
            super.destroy(),
            this._updateFunc && this._updaterName && C.a.delete(this._updaterName),
            (t = THING.Utils.parseValue(t, !1)) && (this.dataSource && this.dataSource.features && (this.dataSource.features = []),
            this.data && this.data.features && (this.data.features = []))
        }
        _playAnimation(t) {
            let e;
            t || (t = {}),
            void 0 === t.grow && (t.grow = !0),
            void 0 === t.type && (t.type = "opacity"),
            void 0 === t.ease && (t.ease = TWEEN.Easing.Linear.None),
            void 0 === t.time && (t.time = 2e3);
            let n = this;
            if ((e = t.grow ? new TWEEN.Tween({
                num: 0
            }).to({
                num: 1
            }, t.time) : new TWEEN.Tween({
                num: 1
            }).to({
                num: 0
            }, t.time)).easing(t.ease || TWEEN.Easing.Linear.None),
            void 0 === t.type || "opacity" === t.type) {
                var r = this.node.getMaterials();
                e.onUpdate(function(a) {
                    (t.grow && a.num >= 1 || !t.grow && a.num <= 0) && (e.stop(),
                    n.app.trigger("PlayAnimationEnd", {
                        object: n
                    }),
                    THING.App.current.rendererManager._mainRenderer.dirty()),
                    r.map(function(t) {
                        t.opacity = a.num
                    })
                })
            } else if ("size" === t.type) {
                var a = this.node.getRenderableNodes()
                  , i = [];
                a.map(function(t) {
                    var e = t.scale.clone();
                    i.push(e)
                }),
                e.onUpdate(function(r) {
                    (t.grow && r.num >= 1 || !t.grow && r.num <= 0) && (e.stop(),
                    n.app.trigger("PlayAnimationEnd", {
                        object: n
                    }),
                    THING.App.current.rendererManager._mainRenderer.dirty()),
                    a.map(function(t, e) {
                        var n = i[e]
                          , a = [n.x * r.num, n.y * r.num, n.z * r.num];
                        t.setScale(a)
                    })
                })
            }
            e.start()
        }
    }
    THING.factory.registerClass("Layer", A);
    var P = A;
    class S extends P {
        constructor(t) {
            super(t),
            this.app = t,
            this._uEarth = t.uEarth,
            this.node = this._layer = new THREE.Group,
            this._layerScene = []
        }
        customSetup(t) {
            super.customSetup(t)
        }
        add(t) {
            "Campus" !== t.type && super.add({
                object: t,
                keepNode: !0,
                keepVisible: !1
            }),
            Array.isArray(t) ? t.map(t=>{
                this._layer.add(t._layer)
            }
            ) : "GeoScene" === t.type ? (this._layerScene.push(t),
            t._marker && (this._layer.add(t._marker._layer),
            this._uEarth.sceneManager.add(t))) : "GeoPoint" === t.type || "GeoLine" === t.type || "GeoPolygon" === t.type || "GeoWater" === t.type || "GeoBuilding" === t.type ? this._layer.add(t._layer) : this._layer.add(t.node),
            setTimeout(()=>{
                this.app.rendererManager._mainRenderer.dirty()
            }
            , 20)
        }
        remove(t) {
            var e = this.children.indexOf(t);
            e > -1 && this.children.splice(e, 1),
            t.infoWindow && t.infoWindow.destroy(),
            this.node.remove(t.node),
            "GeoScene" === t.type && t.destroy()
        }
        removeAll() {
            for (; this.children.length > 0; )
                this.remove(this.children[0]);
            this._layerScene.map(t=>{
                t.destroy()
            }
            )
        }
        show(t) {
            this._layer.visible = t
        }
        get visible() {
            return this._visible
        }
        set visible(t) {
            super.visible = t;
            for (let e = 0; e < this.children.length; e++)
                this.children[e].visible = t;
            for (let e = 0; e < this._layerScene.length; e++)
                this._layerScene[e].visible = t;
            this._visible = t
        }
        get scene() {
            return this._layerScene
        }
        get curInitScene() {
            return this._uEarth.sceneManager.getCurInitScene()
        }
    }
    THING.factory.registerClass("ThingLayer", S);
    var R = S;
    const D = ["addEffect", "brightness", "contrast", "gamma", "hue", "customColor", "saturation", "grayFilterEnable"]
      , j = ["TexSampler0", "TexSampler1", "TexSampler2", "TexSampler3", "TexSampler4", "TexSampler5", "TexSampler6"];
    var L = {
        recorder: function() {
            let t = [];
            return {
                push: function(e) {
                    return t.length >= 2 && t.shift(),
                    t.push(e),
                    t
                },
                get: function() {
                    return t
                },
                clear: function() {
                    t.splice(0, t.length)
                }
            }
        },
        getFrameState: function(t, e, n, r=1) {
            let a = t.cameraPos
              , i = t.viewPort
              , o = t.fov
              , s = t.cameraDirection
              , l = t.cameraUp
              , u = t.aspectRatio;
            n === v.Scene_2D ? e.mapProjection = new Cesium.WebMercatorProjection : n === v.Scene_3D && (e.mapProjection = new Cesium.GeographicProjection),
            e.cameraPos.x = a[0],
            e.cameraPos.y = -a[2],
            e.cameraPos.z = a[1];
            let c = new Cesium.Cartesian3;
            if (n === v.Scene_3D ? (c.x = -a[0],
            c.y = a[2],
            c.z = a[1]) : n === v.Scene_2D && (c.x = a[1],
            c.y = a[0],
            c.z = -a[2]),
            e.positionWC = c,
            n === v.Scene_3D)
                e.positionCartographic = e.mapProjection.ellipsoid.cartesianToCartographic(e.cameraPos);
            else if (n === v.Scene_2D) {
                let t = new Cesium.Cartesian3;
                t.x = a[0],
                t.y = -a[2],
                t.z = a[1],
                e.positionCartographic = e.mapProjection.unproject(t)
            }
            let h = i.actualWidth;
            i.actualHeight;
            e.drawWidth = h,
            e.drawHeight = h / u,
            o = this.getFov(o, t.fovScale),
            o = Math.PI * o / 180;
            let d = u <= 1 ? o : 2 * Math.atan(Math.tan(.5 * o) / u);
            e.fov = o,
            e.fovy = d,
            e.aspectRatio = u,
            e.sseDenominator = 2 * r * Math.tan(.5 * d);
            e.perspectiveOffCenterFrustum.near = 1,
            e.perspectiveOffCenterFrustum.far = 5e8,
            e.perspectiveOffCenterFrustum.top = 1 * Math.tan(.5 * d),
            e.perspectiveOffCenterFrustum.sseDenominator = e.sseDenominator,
            e.perspectiveOffCenterFrustum.bottom = -e.perspectiveOffCenterFrustum.top,
            e.perspectiveOffCenterFrustum.right = u * e.perspectiveOffCenterFrustum.top,
            e.perspectiveOffCenterFrustum.left = -e.perspectiveOffCenterFrustum.right;
            let f = new Cesium.Cartesian3;
            n === v.Scene_3D ? (f.x = -s[0],
            f.y = s[2],
            f.z = s[1]) : n === v.Scene_2D && (f.x = s[1],
            f.y = s[0],
            f.z = -s[2]),
            e.directionWC = f;
            let p = new Cesium.Cartesian3;
            return n === v.Scene_3D ? (p.x = -l[0],
            p.y = l[2],
            p.z = l[1]) : n === v.Scene_2D && (p.x = l[1],
            p.y = l[0],
            p.z = -l[2]),
            e.upWC = p,
            n === v.Scene_2D ? e.mode = Cesium.SceneMode.COLUMBUS_VIEW : n === v.Scene_3D && (e.mode = Cesium.SceneMode.SCENE3D),
            e.cullingVolume = e.perspectiveOffCenterFrustum.computeCullingVolume(e.positionWC, f, p),
            e.context = {},
            e.frameNumber = Cesium.Math.incrementWrap(e.frameNumber, 15e6, 1),
            e.afterRender = [],
            e.time || (e.time = Cesium.JulianDate.fromDate(new Date)),
            e.camera = {
                positionWC: e.positionWC,
                positionCartographic: e.positionCartographic,
                directionWC: e.directionWC,
                frustum: e.perspectiveOffCenterFrustum
            },
            e.context.drawingBufferWidth = e.drawWidth,
            e.context.drawingBufferHeight = e.drawHeight,
            e.shadowState.shadowsEnabled = !1,
            e
        },
        tileNameCreater: function(t) {
            return "EarthTile_" + t._level + "_" + t._x + "_" + t._y
        },
        getMeterialName: function(t, e, n, r) {
            let a = t + "--" + e.boundingSphere3D.radius;
            for (let t = 0; t < n.length; t++) {
                if (n[t].readyImagery)
                    a += "--" + this.createImageUrl(n[t].readyImagery) + "#" + n[t].readyImagery.imageryLayer.textureFlag
            }
            return a
        },
        isNeedUpdate: function(t, e, n, r) {
            if (t && t === e.boundingSphere3D.radius) {
                let t = window.t3djs.buffer.nodeBuffer.get(n);
                if (t)
                    return r && r.add(t),
                    !1
            }
            return !0
        },
        getReadyImageNums: function(t) {
            let e = 0;
            for (let n = 0; n < t.length; n++)
                t[n].readyImagery && e++;
            return e
        },
        isNeedUpdateTexture: function(t, e) {
            let n = e.data ? e.data.imagery : e;
            if (t) {
                let e = t.textureName;
                if (e.length !== n.length)
                    return !0;
                for (let t = 0; t < e.length; t++) {
                    let a = n[t].readyImagery;
                    var r = this.createImageUrl(a);
                    if (e[t] !== r)
                        return !0
                }
                return !1
            }
            return !0
        },
        cacheShow: function(t, e, n) {
            let r = window.t3djs.buffer.nodeBuffer.get(t);
            r.material = window.t3djs.buffer.tileMaterialBuffer.get(e),
            r && n.add(r)
        },
        cacheHide: function(t) {
            let e = window.t3djs.buffer.nodeBuffer.get(t);
            e && (e.show(!1),
            e.setPickEnabled(!0))
        },
        getFov: (t,e=2)=>t * e,
        createImageUrl(t) {
            if (t)
                return t.image ? t.image.currentSrc : ""
        },
        getFogExpDensity(t, e, n) {
            if (!e)
                return 0;
            let a = r.a.getDistance(t.camera.camera.position, t.camera.curOrbit._getIntersectPoint())
              , i = 0;
            if (i = a >= 701163.8668984541 ? 0 : .5 / a,
            t.camera.curOrbit.getRotationSpherePhi) {
                let e = t.camera.curOrbit.getRotationSpherePhi()
                  , n = 1;
                i *= n = e > -.26185763889539315 ? 0 : e > -.6462719298409876 && e <= -.26185763889539315 ? .4 : e > -.8053399123012166 && e <= -.6462719298409876 ? .6 : e > -.964407894761466 && e <= -.8053399123012166 ? .6 : .8
            } else
                THING.Utils.warn("该插件不支持phi角计算，请更新最新插件");
            return i * n
        },
        getFogDensity(t, e, n) {
            if (!e)
                return 0;
            let a = 0;
            if (a = .6 / r.a.getDistance(t.camera.camera.position, t.camera.curOrbit._getIntersectPoint()),
            t.camera.curOrbit.getRotationSpherePhi) {
                let e = t.camera.curOrbit.getRotationSpherePhi()
                  , n = 1;
                e > -.26185763889539315 ? n = .5 : e > -.6462719298409876 && e <= -.26185763889539315 ? n = .6 : e > -.8053399123012166 && e <= -.6462719298409876 ? n = .7 : e > -.964407894761466 && e <= -.8053399123012166 ? n = .85 : e > -1.1 && e <= -.964407894761466 && (n = .95),
                a *= n
            } else
                THING.Utils.warn("该插件不支持phi角计算，请更新最新插件");
            return a * n
        },
        setFogDensity(t, e) {
            for (var n = t.data.imagery, r = 0; r < n.length; r++)
                n[r].readyImagery.fogDensity = e
        },
        isNeedUpdateUniforms(t) {
            let e = !1;
            for (var n = 0, r = t.length; n < r; n++) {
                let r = t[n];
                r.updateFlag && r.updateFlag === this.getUpdateFlag(r) || (e = !0,
                r.updateFlag = this.getUpdateFlag(r))
            }
            return e
        },
        getUpdateFlag(t) {
            let e;
            return D.map(n=>{
                e = t.readyImagery && t.readyImagery.imageryLayer[n] ? n + ":" + t.readyImagery.imageryLayer[n] : n + ":0"
            }
            ),
            e
        },
        getTextureUniformNums(t) {
            let e = t.uniforms
              , n = 0;
            return j.map(t=>{
                e[t] && n++
            }
            ),
            n
        },
        cloneFloat32Array(t) {
            for (var e = t.length, n = new Float32Array(e), r = 0; r < e; r++)
                n[r] = t[r];
            return n
        }
    };
    const I = 12
      , O = ["Material1"]
      , k = ["textureRectangle0"]
      , H = ["textureTransAndScale0"]
      , F = ["brightness0"]
      , B = ["alphaIndex0"]
      , U = ["earthColor0"]
      , N = ["isAddEffect0"]
      , z = ["south1"]
      , q = ["north1"]
      , V = ["southMercatorY1"]
      , W = ["oneOverMercatorHeight1"];
    function G(t) {
        const e = t[0]
          , n = e.substring(0, e.length - 1)
          , r = parseInt(e.substring(e.length - 1));
        for (let e = 1; e < I; e++)
            t.push(n + (r + e))
    }
    G(O),
    G(k),
    G(H),
    G(F),
    G(B),
    G(U),
    G(N),
    G(z),
    G(q),
    G(V),
    G(W);
    var Y = new Map;
    THING.EventType.TileLoadedInCurrentView = "TileLoadedInCurrentView",
    THING.Utils.debounce = ((t,e)=>{
        let n;
        return function() {
            let r = this
              , a = arguments;
            clearTimeout(n),
            n = setTimeout(function() {
                t.apply(r, a)
            }, e)
        }
    }
    );
    let K = !1;
    var $ = THING.Utils.debounce(()=>{
        K = !0
    }
    , 500);
    function X() {
        K && (THING.App.current.trigger(THING.EventType.TileLoadedInCurrentView),
        K = !1)
    }
    function J(t, e, n, r, a) {
        let i = e.data.imagery;
        if (i.length > 0) {
            let r, s, l = L.cloneFloat32Array(t.vertices), u = t.indices, c = t.encoding, h = c.getStride(), d = l.length / h;
            r = [-t.center.x, t.center.z, t.center.y],
            this.quadTileRelativePos[n] = r;
            let f = new THREE.BufferGeometry;
            if (s = new THREE.InterleavedBuffer(l,h),
            f.setIndex(new THREE.BufferAttribute(u,1)),
            c.quantization === Cesium.TerrainQuantization.BITS12) {
                let e = new Float32Array(2 * d);
                for (let n = 0; n < l.length / h; n++) {
                    let r, a, i, o, u, d = l[h * n] / 4096, f = Math.floor(d) / 4096, p = d - Math.floor(d), m = l[h * n + 1] / 4096;
                    m = Math.floor(m) / 4096;
                    let g = new Cesium.Cartesian3(f,p,m)
                      , v = new Cesium.Cartesian3;
                    Cesium.Matrix4.multiplyByPoint(c.fromScaledENU, g, v),
                    r = v.x - t.center.x,
                    a = v.y - t.center.y,
                    i = v.z - t.center.z;
                    let y = l[h * n + 2] / 4096;
                    o = Math.floor(y) / 4096,
                    u = y - Math.floor(y),
                    l[n * h] = -r,
                    l[n * h + 1] = i,
                    l[n * h + 2] = a,
                    e[2 * n] = o,
                    e[2 * n + 1] = u,
                    s = new THREE.InterleavedBuffer(l,h)
                }
                f.addAttribute("position", new THREE.InterleavedBufferAttribute(s,3,0,!1)),
                f.addAttribute("uv", new THREE.BufferAttribute(e,2))
            } else
                f.addAttribute("position", new THREE.InterleavedBufferAttribute(s,3,0,!1)),
                f.addAttribute("uv", new THREE.InterleavedBufferAttribute(s,2,4,!1));
            Q.call(this, i, n, this.quadTileRelativePos[n], this.quadTileEncode[n], a),
            Z.call(this, i, n, this.quadTileRelativePos[n], a);
            let p = window.t3djs.buffer.nodeBuffer.get(n);
            p && (p.parent.removeChild(p),
            window.t3djs.buffer.nodeBuffer.delete(n));
            let m = t3djs.buffer.tileMaterialBuffer.get(a);
            var o = new THREE.Mesh(f,m);
            o.renderLayer = 1,
            o.receiveShadow = !0,
            o.visibilityFlags = 1024,
            o.name = n,
            o.materialName = a,
            t3djs.buffer.nodeBuffer.add(n, o),
            this.rootNode.add(o),
            o.setWorldPosition(r),
            o.tile = e,
            l = null,
            u = null,
            c = null
        }
    }
    function Q(t, e, n, r, a) {
        let i = t.length;
        i > I && (i = I);
        let o = t3djs.buffer.tileMaterialBuffer.get(a)
          , s = this.materialDirty;
        if (o) {
            o._textureCount !== t.length && (t3djs.buffer.tileMaterialBuffer.delete(a),
            (o = (o = window.t3djs.materialManager.getMaterial(O[i - 1])).getTechnique(0).getPass(0).material.clone())._textureCount = i,
            t3djs.buffer.tileMaterialBuffer.add(a, o),
            s = !0)
        } else
            (o = (o = window.t3djs.materialManager.getMaterial(O[i - 1])).getTechnique(0).getPass(0).material.clone()).name = "tile",
            o._textureCount = i,
            t3djs.buffer.tileMaterialBuffer.add(a, o),
            s = !0;
        let l = o;
        l.polygonOffset = !0,
        l.polygonOffsetFactor = 1,
        l.polygonOffsetUnits = 100;
        let u = e.split("_")[1];
        et(l, "czm_fogDensity", this._fogDensity),
        s && et(l, "isReProjection", u < 9 ? 1 : 0);
        for (let e = 0; e < i; e++) {
            const r = t[e].readyImagery;
            if (r) {
                let a = r.image.name;
                if (l.uniforms["TexSampler" + e].value = window.t3djs.textureManager.getTexture(a),
                s) {
                    let a = r.imageryLayer._layerIndex
                      , i = t[e].textureTranslationAndScale
                      , o = [i.x, i.y, i.z, i.w]
                      , s = t[e].textureCoordinateRectangle
                      , u = [s.x, s.y, s.z, s.w];
                    if (et(l, k[e], u),
                    et(l, H[e], o),
                    et(l, B[e], a),
                    r.imageryLayer.imageryProvider._tilingScheme.__proto__ === Cesium.WebMercatorTilingScheme.prototype) {
                        let n = t[e].readyImagery.rectangle.south
                          , r = t[e].readyImagery.rectangle.north
                          , a = Math.sin(n)
                          , i = .5 * Math.log((1 + a) / (1 - a));
                        a = Math.sin(r);
                        let o = 1 / (.5 * Math.log((1 + a) / (1 - a)) - i);
                        et(l, z[e], n),
                        et(l, q[e], r),
                        et(l, V[e], i),
                        et(l, W[e], o)
                    }
                    et(l, "objectPos", [n[0], n[1], n[2], 0]),
                    et(l, "v3LightPosInput", [this._sunLight.sunDirection.x, this._sunLight.sunDirection.y, this._sunLight.sunDirection.z]),
                    et(l, "fInnerRadius", 6378e3),
                    et(l, "fOuterRadius", 6378e3 * 1.025),
                    et(l, "ESun", 20)
                }
            } else
                t[e].loadingImagery && (l.uniforms["TexSampler" + e].value = null,
                this.updateESunWhenLoadingImage && et(l, "ESun", 0))
        }
    }
    function Z(t, e, n, a) {
        let i = !1
          , o = t.length;
        o > 6 && (o = 6);
        let s = t3djs.buffer.tileMaterialBuffer.get(a);
        if (!s)
            return void THING.Utils.log("没有找到该瓦片材质");
        if (t[0].readyImagery) {
            let e = t[0].readyImagery.imageryLayer.grayFilterPerBar
              , n = t[0].readyImagery.imageryLayer.grayFilterColorBar
              , a = t[0].readyImagery.imageryLayer.grayFilterEnable
              , i = void 0 === t[0].readyImagery.imageryLayer.grayFilterIndex ? -1 : t[0].readyImagery.imageryLayer.grayFilterIndex;
            et(s, "grayFilterEnable", a),
            et(s, "grayFilterIndex", i),
            tt(s, e, n);
            let o = t[0].readyImagery.imageryLayer.gradientColorOverlayEnable;
            if (et(s, "gradientColorOverlayEnable", o ? 1 : 0),
            o) {
                et(s, "mapDirection", t[0].readyImagery.imageryLayer.gradientMapDirection);
                let e = t[0].readyImagery.imageryLayer.gradientColorPerBar
                  , n = t[0].readyImagery.imageryLayer.gradientColorBar
                  , a = t[0].readyImagery.imageryLayer.gradientColorMapUrl
                  , i = t[0].readyImagery.imageryLayer.gradientAlongWithCameraEnable
                  , o = t[0].readyImagery.imageryLayer.gradientOpacity;
                if (i) {
                    let t = 3174285.284198257
                      , e = (r.a.getDistance(this.app.camera.camera.position, this.app.camera.curOrbit._getIntersectPoint()) - t) / (16747458.377761858 - t);
                    et(s, "gradientOpacity", e > 0 && e <= 1 ? o - o * (1 - e) : e <= 0 ? 0 : o)
                } else
                    et(s, "gradientOpacity", o);
                a ? function(t, e, n) {
                    if (!t)
                        return void THING.Utils.warn("please check your material");
                    var r = e
                      , a = Y.get(r);
                    a || (a = (new THREE.TextureLoader).load(e),
                    Y.set(r, a));
                    "gradientColorMap" === n && (t.uniforms.gradientColorMap.value = a)
                }(s, a, "gradientColorMap") : tt(s, e, n, "gradientColorMap")
            }
        } else
            et(s, "grayFilterEnable", !1);
        if (void 0 === s._tileNeedUpdate && (s._tileNeedUpdate = !0),
        !s._tileNeedUpdate)
            return;
        let l = s;
        for (let e = 0; e < o; e++) {
            if (!t[e].readyImagery) {
                i = !0;
                continue
            }
            let n = t[e].readyImagery.imageryLayer.brightness
              , r = t[e].readyImagery.imageryLayer.customColor
              , a = t[e].readyImagery.imageryLayer.addEffect
              , o = t[e].readyImagery.imageryLayer.hue
              , s = t[e].readyImagery.imageryLayer.contrast
              , u = t[e].readyImagery.imageryLayer.saturation
              , c = t[e].readyImagery.imageryLayer.gamma
              , h = 0 === c ? 1 : 1 / c
              , d = t[e].readyImagery.imageryLayer.night;
            et(l, F[e], n),
            et(l, N[e], a ? 1 : 0),
            et(l, U[e], r),
            et(l, "contrast", s),
            et(l, "hue", o),
            et(l, "saturation", u),
            et(l, "textureGamma", h),
            et(l, "night", d)
        }
        i || (s._tileNeedUpdate = !1)
    }
    function tt(t, e, n, a) {
        if (t) {
            var i = e.toString() + "_" + n.toString()
              , o = Y.get(i);
            o || (o = r.a._generateGradientTextureByGray(e, n),
            Y.set(i, o)),
            a ? "gradientColorMap" === a && (t.uniforms.gradientColorMap.value = o) : t.uniforms.colorMapping.value = o
        } else
            THING.Utils.warn("please check your material")
    }
    function et(t, e, n, r) {
        if (t)
            if ("grayFilterPerBar" !== r)
                if ("grayFilterColorBar" !== r)
                    n instanceof Array ? 1 === n.length ? t.uniforms[e].value = n : 2 === n.length ? (t.uniforms[e].value.x = n[0],
                    t.uniforms[e].value.y = n[1]) : 3 === n.length ? (t.uniforms[e].value.x = n[0],
                    t.uniforms[e].value.y = n[1],
                    t.uniforms[e].value.z = n[2]) : 4 === n.length && (t.uniforms[e].value.x = n[0],
                    t.uniforms[e].value.y = n[1],
                    t.uniforms[e].value.z = n[2],
                    t.uniforms[e].value.w = n[3]) : t.uniforms[e].value = n;
                else
                    for (let r = 0; r < n.length; r++)
                        t.uniforms[e].value[r].x = n[r][0],
                        t.uniforms[e].value[r].y = n[r][1],
                        t.uniforms[e].value[r].z = n[r][2];
            else
                n.map((n,r)=>{
                    t.uniforms[e].value[r] = n
                }
                );
        else
            THING.Utils.warn("please check your material")
    }
    var nt = class extends _ {
        constructor(t, e) {
            super(),
            this.autoAdjustClipping = !0,
            this.t3djs = t3djs,
            this.app = t,
            this._readyPromise = Cesium.when.defer(),
            this._ready = !1,
            this.tile3ds = [],
            this.isEarthShow = !1,
            this.fog = void 0 === e.fog || e.fog,
            this.updateESunWhenLoadingImage = THING.Utils.parseValue(e.updateESunWhenLoadingImage, !1),
            this.sseFactor = THING.Utils.parseValue(e.sseFactor, 1),
            this._sunLight = void 0 === e.sunLight ? void 0 : e.sunLight,
            this.fogDensity = 1,
            this._fogDensity = 0,
            this.fogExpDensity = 0,
            this.quadTileRadius = {},
            this.quadTileRelativePos = {},
            this.quadTileEncode = {},
            this.quadTileMatrial = {},
            this._util = L,
            this._recorder = L.recorder(),
            this.rootNode = new THREE.Group,
            this.rootNode.name = "tileEarth",
            window.t3djs.buffer.nodeBuffer.add("tiles-root", this.rootNode);
            var n = this.t3djs.earthAndAtmosphere = new THREE.Group;
            n._isSeneRoot_ = !0,
            window.t3djs.buffer.nodeBuffer.add("earthRoot", n),
            n.add(this.rootNode),
            CMAP.getCurrentMap().node.add(n),
            this.dirty = !1,
            this.materialDirty = !1,
            this.tileCacheSize = 500,
            this._imageryLayerCollection = new Cesium.ImageryLayerCollection,
            this._useTerrain = e.terrainLayer._useTerrain,
            this._terrainProvider = e.terrainLayer._terrainLayer,
            this._frameState = new Cesium.FrameState,
            this._frameState.passes.render = !0,
            this._frameState.frameNumber = 0,
            this._frameState.cameraPos = new Cesium.Cartesian3,
            this._frameState.positionCartographic = new Cesium.Cartographic,
            this._frameState.perspectiveOffCenterFrustum = new Cesium.PerspectiveOffCenterFrustum,
            this._surfaceShaderSet = new Cesium.GlobeSurfaceShaderSet,
            this._surfaceShaderSet.baseVertexShaderSource = new Cesium.ShaderSource({
                sources: [Cesium.GroundAtmosphere, Cesium.GlobeVS]
            }),
            this._surfaceShaderSet.baseFragmentShaderSource = new Cesium.ShaderSource({
                sources: [Cesium.GlobeFS]
            });
            let r = this;
            this._terrainProvider._readyPromise.then(function() {
                setTimeout(function() {
                    r._surface = new Cesium.QuadtreePrimitive({
                        tileProvider: new Cesium.GlobeSurfaceTileProvider({
                            terrainProvider: r._terrainProvider,
                            imageryLayers: r._imageryLayerCollection,
                            surfaceShaderSet: r._surfaceShaderSet
                        }),
                        tileCacheSize: r.tileCacheSize
                    }),
                    r.app.trigger("terrainReady")
                }, 1e3)
            })
        }
        _createDepthGlobe() {
            let t = new THREE.MeshBasicMaterial;
            t.colorWrite = !1;
            let e = new THREE.SphereGeometry(6377990,128,128)
              , n = new THREE.Mesh(e,t);
            window.t3djs.rootNode.createChild("tiles").add(n)
        }
        _updateCameraNearFar() {
            super.update(this)
        }
        update() {
            if (this.autoAdjustClipping && this._updateCameraNearFar(),
            !this.isEarthShow)
                return;
            if (!this._surface)
                return;
            if (0 === this._imageryLayerCollection.length && 0 === this.tile3ds.length)
                return;
            let t = {
                actualWidth: this.app.domElement.clientWidth,
                actualHeight: this.app.domElement.clientHeight
            };
            var e = this.app.camera.camera
              , n = e.convertLocalToWorldPosition([0, 1, 0])
              , r = e.convertLocalToWorldPosition([0, 0, 0]);
            let a = [n[0] - r[0], n[1] - r[1], n[2] - r[2]]
              , i = this.app.uEarth._cameraInfo || {
                cameraPos: this.app.camera.position,
                viewPort: t,
                fov: this.app.camera.camera.cameraP.fov,
                cameraDirection: this.app.camera.direction,
                cameraUp: a,
                aspectRatio: e.cameraP.aspect
            };
            if (this.app.domElement.clientHeight !== this.app.domElement.clientWidth || 0 !== this.app.domElement.clientWidth) {
                if (this._frameState = L.getFrameState(i, this._frameState, this.mode, this.sseFactor),
                this._frameState.terrainExaggeration = CMAP.getCurrentMap().terrainLayer.terrainExaggeration,
                this._imageryLayerCollection.length > 0) {
                    if (this._surface.beginFrame(this._frameState),
                    this._surface.render(this._frameState),
                    Cesium.RequestScheduler.update(),
                    this.fog ? (this._fogDensity = L.getFogDensity(this.app, this.fog, this.fogDensity),
                    this.app.scene.fog.density = this._fogDensity) : this._fogDensity = 0,
                    this.app.scene.fog && (this.app.scene.fog.density = L.getFogExpDensity(this.app, this.fog, this.fogExpDensity)),
                    this._sunLight) {
                        let t = this._sunLight;
                        this._scrubJulian = Cesium.JulianDate.addSeconds(t._startTime, t._timeLine.seconds, new Cesium.JulianDate),
                        t._currentTime = t._setAndUpdateClockTime(this._scrubJulian),
                        t.sunDirection = t._computeSunDirectionAndPosition(t._currentTime),
                        t._updateSunDirection()
                    }
                    this._surface.endFrame(this._frameState);
                    let t = this._surface.tileProvider._tilesToRenderByTextureCount;
                    this.draw(t)
                }
                for (let t = 0; t < this.rootNode.children.length; t++)
                    this.rootNode.children[t].material.uniforms.sunDirection.value = this._sunLight.sunDirection;
                for (let t = 0; t < this.tile3ds.length; t++) {
                    let e = this.tile3ds[t];
                    e._3dtileset.update(this._frameState);
                    let n = e._3dtileset._selectedTiles;
                    e.draw3dTiles(n),
                    e.callAfterRenderFunctions(this._frameState)
                }
            }
        }
        onUpdate() {
            this.update(),
            this.app.root.static && CMAP.getCurrentMap().node.updateMatrixWorld()
        }
        draw(t) {
            let e = t.length;
            if ("break" !== function(t) {
                let e = t.length;
                if (0 === e)
                    return X(),
                    "break";
                let n = []
                  , r = []
                  , a = "";
                for (let i = 0; i < e; i++) {
                    let e = t[i];
                    if (Cesium.defined(e))
                        for (let t = 0; t < e.length; t++) {
                            let i = e[t]
                              , o = L.tileNameCreater(i);
                            L.isNeedUpdateTexture(this.quadTileMatrial[o], i) && n.push(o),
                            this._useTerrain && i.data.terrainData && (this.mesh = i.data.terrainData._mesh,
                            Cesium.defined(this.mesh) && L.isNeedUpdate(this.quadTileRadius[o], this.mesh, o) && r.push(o)),
                            a += o + ","
                        }
                }
                let i = this._recorder.push(a);
                return 1 === i.length ? "break" : i[0] === i[1] && 0 === r.length && 0 === n.length ? (X(),
                "break") : ($(),
                "renderer")
            }
            .call(this, t) || this.dirty) {
                for (let n = 0; n < e; n++) {
                    let e = t[n];
                    if (Cesium.defined(e))
                        for (let t = 0; t < e.length; t++) {
                            let n = e[t]
                              , r = "";
                            if (!n.data.terrainData)
                                return;
                            if (r = n.data.terrainData._mesh,
                            !Cesium.defined(r))
                                return
                        }
                }
                this.rootNode.children.length = 0;
                for (let n = 0; n < e; n++) {
                    let e = t[n];
                    if (Cesium.defined(e))
                        for (let t = 0; t < e.length; t++) {
                            let n, r = e[t], a = "", i = "", o = "", s = "";
                            if (!r.data.terrainData)
                                continue;
                            if (a = r.data.terrainData._mesh,
                            !Cesium.defined(a))
                                continue;
                            n = r.data.imagery,
                            o = s = (i = L.tileNameCreater(r)) + "--" + a.boundingSphere3D.radius,
                            this.mode === v.Scene_2D && (s += "_p");
                            let l = L.isNeedUpdate(this.quadTileRadius[i], a, i)
                              , u = !0;
                            if (l || u) {
                                this.quadTileMatrial[i] || (this.quadTileMatrial[i] = {}),
                                this.quadTileMatrial[i].textureCount = n.length,
                                this.quadTileMatrial[i].textureName = [];
                                for (let t = 0; t < n.length; t++) {
                                    if (!n[t].readyImagery)
                                        continue;
                                    let e = n[t].readyImagery
                                      , r = L.createImageUrl(e);
                                    this.quadTileMatrial[i].textureName[t] = r
                                }
                                this.quadTileRadius[i] = a.boundingSphere3D.radius
                            }
                            l ? (J.call(this, a, r, i, s, o),
                            a = null,
                            this._ready || (this._ready = !0,
                            this._readyPromise.resolve(!0))) : (u && (Q.call(this, n, i, this.quadTileRelativePos[i], this.quadTileEncode[i], o),
                            L.cacheShow(i, o, this.rootNode)),
                            Z.call(this, n, i, this.quadTileRelativePos[i], o))
                        }
                }
                this.dirty = !1
            }
        }
        show(t) {
            this.isEarthShow = void 0 === t || t,
            this.rootNode.show(t)
        }
        addTile3dLayer(t) {
            t._ellipsoid = this.ellipsoid,
            this.tile3ds.push(t)
        }
        removeTile3dLayer(t) {
            for (let e in this.tile3ds)
                this.tile3ds[e].node.uuid === t.node.uuid && this.tile3ds.splice(e, 1)
        }
        removeAllLayers() {
            this.tile3ds = [],
            this._imageryLayerCollection.removeAll(!0)
        }
        setBaseMap(t, e) {
            let n = "";
            var r = e.indexOf("{")
              , a = e.indexOf("}")
              , i = {
                url: e,
                maximumLevel: t.maximumLevel,
                loadByBlob: t._loadByBlob,
                timeout: t._timeout,
                tilingScheme: t._tilingScheme,
                tileType: t._tilingSchemeType
            };
            if (r > 0 && a > r && r !== e.indexOf("{x}") && r && r !== e.indexOf("{z}")) {
                var o = e.substring(r + 1, a)
                  , s = o.split(",");
                e = e.replace(o, "s"),
                i.url = e,
                i.subDomains = s
            }
            for (let e = 0; e < this._imageryLayerCollection.length; e++) {
                let r = this._imageryLayerCollection.get(e);
                if (t.id === r.id) {
                    let a = r._imageryProvider.url.indexOf(i.url);
                    if (n = r._imageryProvider.url,
                    a >= 0)
                        return;
                    this._imageryLayerCollection.remove(r, !0);
                    let o = this._imageryLayerCollection.addImageryProvider(new Cesium.createOpenStreetMapImageryProvider(i), e);
                    return o.id = t.id,
                    o.brightness = t.style.brightness,
                    o.addEffect = t.style.addEffect,
                    o.customColor = t.style._customColor,
                    o.grayFilterEnable = t.style.grayFilterEnable,
                    o.grayFilterPerBar = t.style.grayFilterPerBar,
                    o.grayFilterColorBar = t.style._grayFilterColorBar,
                    o.hue = t.style.hue,
                    o.night = t.style.night,
                    o.saturation = t.style.saturation,
                    o.contrast = t.style.contrast,
                    o.textureGamma = t.style.gamma,
                    o.textureFlag = t.textureFlag,
                    o.gradientColorOverlayEnable = t.style.gradientColorOverlayEnable,
                    o.gradientMapDirection = t.style.gradientMapDirection,
                    o.gradientColorPerBar = t.style.gradientColorPerBar,
                    o.gradientColorBar = t.style._gradientColorBar,
                    o.gradientColorMapUrl = t.style.gradientColorMapUrl,
                    o.gradientOpacity = t.style._gradientOpacity,
                    o.gradientAlongWithCameraEnable = t.style._gradientAlongWithCameraEnable,
                    this.changeStyle(),
                    void (t._tileLayer = o.imageryProvider)
                }
            }
        }
        addImageryLayer(t, e) {
            let n = this._imageryLayerCollection.addImageryProvider(t._tileLayer, e);
            n.id = t.id,
            n.brightness = t.style.brightness,
            n.addEffect = t.style.addEffect,
            n.customColor = t.style._customColor,
            n.grayFilterEnable = t.style.grayFilterEnable,
            n.grayFilterPerBar = t.style.grayFilterPerBar,
            n.grayFilterColorBar = t.style._grayFilterColorBar,
            n.grayFilterIndex = t.style._grayFilterIndex,
            n.hue = t.style.hue,
            n.saturation = t.style.saturation,
            n.contrast = t.style.contrast,
            n.gamma = t.style.gamma,
            n.night = t.style.night,
            n.textureFlag = t.textureFlag,
            n.gradientColorOverlayEnable = t.style.gradientColorOverlayEnable,
            n.gradientMapDirection = t.style.gradientMapDirection,
            n.gradientColorPerBar = t.style.gradientColorPerBar,
            n.gradientColorBar = t.style._gradientColorBar,
            n.gradientColorMapUrl = t.style.gradientColorMapUrl,
            n.gradientOpacity = t.style._gradientOpacity,
            n.gradientAlongWithCameraEnable = t.style._gradientAlongWithCameraEnable
        }
        removeImageryLayer(t) {
            for (let e = 0; e < this._imageryLayerCollection.length; e++) {
                let n = this._imageryLayerCollection.get(e);
                n.id === t.id && (this._imageryLayerCollection.remove(n, !0),
                0 === this._imageryLayerCollection.length && (this.rootNode.children.length = 0))
            }
        }
        changeStyle() {
            this.dirty = !0,
            this.materialDirty = !0;
            let t = t3djs.buffer.tileMaterialBuffer.getAll();
            for (var e in t)
                t[e]._tileNeedUpdate = !0
        }
    }
    ;
    var rt = class {
        constructor(t, e, n) {
            this.app = t,
            this._night = e,
            this._cameraAndRadiiAndDynamicAtmosphereColor = new Cesium.Cartesian4;
            var r = this._createAtmosphereGeometry()
              , a = window.t3djs.materialManager.getMaterial("AtmosphereFromSpace")
              , i = this.node = new THREE.Group;
            i.name = "atmosphere",
            window.t3djs.buffer.nodeBuffer.get("earthRoot").add(i),
            this._uniforms = {
                czm_sunPositionWC: {
                    value: new THREE.Vector3
                },
                czm_sunDirectionWC: {
                    value: new THREE.Vector3
                },
                u_cameraAndRadiiAndDynamicAtmosphereColor: {
                    value: new THREE.Vector4
                },
                u_hsbShift: {
                    value: new THREE.Vector3
                },
                u_fogColor: {
                    value: new THREE.Vector4(1,1,1,1)
                },
                opacity: {
                    value: 1
                },
                Kr: {
                    value: .0012
                },
                Km: {
                    value: .0015
                },
                ESun: {
                    value: 27
                },
                exposure: {
                    value: .9
                },
                g: {
                    value: -.95
                }
            },
            this._spSkyFromSpace = new THREE.ShaderMaterial({
                wireframe: !1,
                side: THREE.DoubleSide,
                depthWrite: !1,
                transparent: !0,
                opacity: 1,
                vertexShader: "\n      // attribute vec4 position;\n\n      uniform vec4 u_cameraAndRadiiAndDynamicAtmosphereColor; // Camera height, outer radius, inner radius, dynamic atmosphere color flag\n      uniform vec3 czm_sunPositionWC;\n      uniform vec3 czm_sunDirectionWC;\n\n      uniform float Kr;\n      uniform float Km;\n      uniform float ESun;\n      \n      // const float czm_pi = 3.141592653589793;\n      // // const float Kr = 0.0025;\n      // uniform const float Kr;\n      // const float Kr4PI = Kr * 4.0 * czm_pi;\n      // // const float Km = 0.0015;\n      // uniform const float Km;\n      // const float Km4PI = Km * 4.0 * czm_pi;\n      // // const float ESun = 15.0;\n      // uniform const float ESun;\n      // const float KmESun = Km * ESun;\n      // const float KrESun = Kr * ESun;\n\n      const vec3 InvWavelength = vec3(\n          5.60204474633241,  // Red = 1.0 / Math.pow(0.650, 4.0)\n          9.473284437923038, // Green = 1.0 / Math.pow(0.570, 4.0)\n          19.643802610477206); // Blue = 1.0 / Math.pow(0.475, 4.0)\n      const float rayleighScaleDepth = 0.25;\n      \n      const int nSamples = 2;\n      const float fSamples = 2.0;\n      \n      varying vec3 v_rayleighColor;\n      varying vec3 v_mieColor;\n      varying vec3 v_toCamera;\n      varying float cameraLength;\n\n      #include <fog_pars_vertex>\n      #include <logdepthbuf_pars_vertex>\n      #include <common>\n      \n      float scale(float cosAngle)\n      {\n          float x = 1.0 - cosAngle;\n          return rayleighScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n      }\n      \n      void main(void)\n      {\n\n          float czm_pi = 3.141592653589793;\n          float Kr4PI = Kr * 4.0 * czm_pi;\n          float Km4PI = Km * 4.0 * czm_pi;\n          float KmESun = Km * ESun;\n          float KrESun = Kr * ESun;\n\n          // Unpack attributes\n          // float cameraHeight = u_cameraAndRadiiAndDynamicAtmosphereColor.x;// 相机高度\n          float cameraHeight = length(cameraPosition);// 相机高度\n          cameraLength = cameraHeight;\n          float outerRadius = u_cameraAndRadiiAndDynamicAtmosphereColor.y;// 外圈半径\n          float innerRadius = u_cameraAndRadiiAndDynamicAtmosphereColor.z;// 内圈半径\n      \n          // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n          vec3 positionV3 = position.xyz;\n          vec3 ray = positionV3 - cameraPosition;\n          float far = length(ray);\n          ray /= far;\n          float atmosphereScale = 1.0 / (outerRadius - innerRadius);\n      \n          // 判断在太空还是在大气层\n          vec3 start;\n          float startOffset;\n          if(cameraHeight > outerRadius) {\n            // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\n            float B = 2.0 * dot(cameraPosition, ray);\n            float C = cameraHeight * cameraHeight - outerRadius * outerRadius;\n            float det = max(0.0, B*B - 4.0 * C);\n            float near = 0.5 * (-B - sqrt(det));\n        \n            // Calculate the ray's starting position, then calculate its scattering offset\n            start = cameraPosition + ray * near;\n            far -= near;\n            float startAngle = dot(ray, start) / outerRadius;\n            float startDepth = exp(-1.0 / rayleighScaleDepth );\n            startOffset = startDepth*scale(startAngle);\n          }else{\n            // Calculate the ray's starting position, then calculate its scattering offset\n            start = cameraPosition;\n            float height = length(start);\n            float depth = exp((atmosphereScale / rayleighScaleDepth ) * (innerRadius - cameraHeight));\n            float startAngle = dot(ray, start) / height;\n            startOffset = depth*scale(startAngle);\n          }\n      \n          // Initialize the scattering loop variables\n          float sampleLength = far / fSamples;\n          float scaledLength = sampleLength * atmosphereScale;\n          vec3 sampleRay = ray * sampleLength;\n          vec3 samplePoint = start + sampleRay * 0.5;\n      \n          // Now loop through the sample rays\n          vec3 frontColor = vec3(0.0, 0.0, 0.0);\n          vec3 lightDir = (u_cameraAndRadiiAndDynamicAtmosphereColor.w > 0.0) ? czm_sunPositionWC - cameraPosition : cameraPosition;\n          lightDir = normalize(lightDir);\n      \n          for(int i=0; i<nSamples; i++)\n          {\n              float height = length(samplePoint);\n              float depth = exp((atmosphereScale / rayleighScaleDepth ) * (innerRadius - height));\n              float fLightAngle = dot(lightDir, samplePoint) / height;\n              float fCameraAngle = dot(ray, samplePoint) / height;\n              float fScatter = (startOffset + depth*(scale(fLightAngle) - scale(fCameraAngle)));\n              vec3 attenuate = exp(-fScatter * (InvWavelength * Kr4PI + Km4PI));\n              frontColor += attenuate * (depth * scaledLength);\n              samplePoint += sampleRay;\n          }\n      \n          // Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\n          v_mieColor = frontColor * KmESun;\n          v_rayleighColor = frontColor * (InvWavelength * KrESun);\n          v_toCamera = cameraPosition - positionV3;\n\n          #include <fog_vertex>\n\n          vec4 temp = modelViewMatrix * vec4(position, 1.0);\n          gl_Position = projectionMatrix * temp;\n\n          #include <logdepthbuf_vertex>\n      }\n    ",
                fragmentShader: "\n      #include <fog_pars_fragment>\n      #include <logdepthbuf_pars_fragment>\n\n      #ifdef COLOR_CORRECT\n      uniform vec3 u_hsbShift; // Hue, saturation, brightness\n      #endif\n      \n      uniform vec3 czm_sunDirectionWC;\n      uniform vec3 czm_sunPositionWC;\n      uniform vec4 u_cameraAndRadiiAndDynamicAtmosphereColor; // Camera height, outer radius, inner radius, dynamic atmosphere color flag\n      \n      uniform float exposure;\n      uniform float g;\n\n      uniform vec4 u_fogColor;\n      uniform float opacity;\n      \n      varying vec3 v_rayleighColor;\n      varying vec3 v_mieColor;\n      varying vec3 v_toCamera;\n      varying vec3 v_positionEC;\n\n      varying float cameraLength;\n      varying float flag;\n      \n      void main (void)\n      {\n          #include <logdepthbuf_fragment>\n\n          float g2 = g * g;\n\n          // Extra normalize added for Android\n          float cosAngle = dot(czm_sunDirectionWC, normalize(v_toCamera)) / length(v_toCamera);\n          float rayleighPhase = 0.75 * (1.0 + cosAngle * cosAngle);\n          float miePhase = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + cosAngle * cosAngle) / pow(1.0 + g2 - 2.0 * g * cosAngle, 1.5);\n      \n          vec3 rgb = rayleighPhase * v_rayleighColor + miePhase * v_mieColor;\n\n          // const float exposure = 1.5;\n          rgb = vec3(1.0) - exp(-exposure * rgb);\n\n          // Alter alpha based on how close the viewer is to the ground (1.0 = on ground, 0.0 = at edge of atmosphere)\n          float atmosphereAlpha = clamp((u_cameraAndRadiiAndDynamicAtmosphereColor.y - cameraLength) / (u_cameraAndRadiiAndDynamicAtmosphereColor.y - u_cameraAndRadiiAndDynamicAtmosphereColor.z), 0.0, 1.0);\n      \n          // Alter alpha based on time of day (0.0 = night , 1.0 = day)\n          float nightAlpha = (u_cameraAndRadiiAndDynamicAtmosphereColor.w > 0.0) ? clamp(dot(normalize(cameraPosition), czm_sunDirectionWC), 0.0, 1.0) : 1.0;\n          atmosphereAlpha *= pow(nightAlpha, 0.5);\n      \n          gl_FragColor = vec4(vec3(rgb.r,rgb.g,rgb.b * 1.05), mix(rgb.b, 1.0, atmosphereAlpha) * smoothstep(0.0, 1.0, 1.0) * opacity);\n          \n          gl_FragColor = gl_FragColor * u_fogColor;\n\n          #include <fog_fragment>\n      }\n    ",
                uniforms: this._uniforms
            });
            var o = new THREE.Mesh(r,this._spSkyFromSpace);
            o.renderLayer = 1;
            var s = new THREE.Group;
            s.renderOrder = -500,
            i.add(s),
            s.add(o),
            o.setPickEnabled(!1),
            o.visibilityFlags = 1024;
            let l = n.sunDirection;
            var u = a.getTechnique(0).getPass(0);
            u.setGpuProgramParameter(window.t3djs.GpuProgramType.FRAGMENT_PROGRAM, "v3LightPosInput", [l.x, l.y, l.z], 3),
            u.setGpuProgramParameter(window.t3djs.GpuProgramType.FRAGMENT_PROGRAM, "fInnerRadius", 6378e3),
            u.setGpuProgramParameter(window.t3djs.GpuProgramType.FRAGMENT_PROGRAM, "fOuterRadius", 6378e3 * 1.025),
            u.setGpuProgramParameter(window.t3djs.GpuProgramType.FRAGMENT_PROGRAM, "ESun", 15),
            u.setGpuProgramParameter(window.t3djs.GpuProgramType.FRAGMENT_PROGRAM, "g", 0),
            u.setGpuProgramParameter(window.t3djs.GpuProgramType.FRAGMENT_PROGRAM, "Km", .0015),
            u.setGpuProgramParameter(window.t3djs.GpuProgramType.FRAGMENT_PROGRAM, "Kr", .0025),
            u.setGpuProgramParameter(window.t3djs.GpuProgramType.FRAGMENT_PROGRAM, "night", e ? 1 : 0),
            u.setDepthWrite(!1)
        }
        _createAtmosphereGeometry() {
            var t = Cesium.EllipsoidGeometry.createGeometry(new Cesium.EllipsoidGeometry({
                radii: Cesium.Cartesian3.multiplyByScalar(Cesium.Ellipsoid.WGS84.radii, 1.025, new Cesium.Cartesian3),
                slicePartitions: 64,
                stackPartitions: 64,
                vertexFormat: Cesium.VertexFormat.POSITION_ONLY
            }));
            let e = new THREE.BufferGeometry
              , n = t.attributes.position
              , r = [];
            for (let t = 0; t < n.values.length; t++)
                r.push(-n.values[t]),
                r.push(n.values[t + 2]),
                r.push(n.values[t + 1]),
                t += 3;
            let a = t.indices
              , i = [];
            for (let t = 0; t < a.length; t++)
                i.push(a[t]);
            e.setAttribute("position", new THREE.Float32BufferAttribute(r,3)),
            e.setIndex(i);
            let o = new THREE.SphereBufferGeometry(6378e3 * 1.025,256,256)
              , s = new Cesium.Cartesian4;
            return this._night > 0 ? s.w = 1 : s.w = 0,
            s.y = 6378e3 * 1.025,
            s.z = 6378e3,
            this._cameraAndRadiiAndDynamicAtmosphereColor = s,
            o
        }
        show(t) {
            t = void 0 === t || t,
            this.node.show(t)
        }
        hide() {
            this.show(!1)
        }
        onUpdate() {
            var t = t3djs.materialManager.getMaterial("AtmosphereFromSpace").getMaterial()[0];
            let e = this.app;
            var n = L.getFogDensity(e, !0, 1);
            t.uniforms.czm_fogDensity.value = n;
            let a = r.a.getDistance(e.camera.camera.position, e.camera.curOrbit._getIntersectPoint());
            t.uniforms.ESun.value = a < 53e4 ? 35 : 12;
            let i = e.uEarth._earthInstance._sunLight
              , o = this._uniforms;
            o.czm_sunPositionWC.value = i.sunPosition,
            o.czm_sunDirectionWC.value = i.sunDirection;
            let s = a / 701163.8668984541;
            if (s > 1 ? (o.opacity.value = 1,
            s = 1) : o.opacity.value = Math.max(.88, s),
            e.uEarth._earthInstance.tileEarth.fog) {
                let t = e.scene.fog && e.scene.fog.density;
                o.u_fogColor.value = t > 0 && e.uEarth.style._fogExpColor || new THREE.Vector4(1,1,1,1),
                o.Kr.value = .002 + (.0012 - .002) * s,
                o.Km.value = .001,
                o.ESun.value = 150 + -120 * s,
                o.exposure.value = .3 + (.9 - .3) * s,
                o.g.value = -.98
            } else
                o.u_fogColor.value = new THREE.Vector4(1,1,1,1);
            let l = new THREE.Vector4(this._cameraAndRadiiAndDynamicAtmosphereColor.x,this._cameraAndRadiiAndDynamicAtmosphereColor.y,this._cameraAndRadiiAndDynamicAtmosphereColor.z,this._cameraAndRadiiAndDynamicAtmosphereColor.w);
            o.u_cameraAndRadiiAndDynamicAtmosphereColor.value = l
        }
        showNight(t) {
            var e = window.t3djs.materialManager.getMaterial("AtmosphereFromSpace").getTechnique(0).getPass(0);
            t ? (e.setGpuProgramParameter(window.t3djs.GpuProgramType.FRAGMENT_PROGRAM, "night", 1),
            this._cameraAndRadiiAndDynamicAtmosphereColor.w = 1) : (e.setGpuProgramParameter(window.t3djs.GpuProgramType.FRAGMENT_PROGRAM, "night", 0),
            this._cameraAndRadiiAndDynamicAtmosphereColor.w = 0),
            this._uniforms.u_cameraAndRadiiAndDynamicAtmosphereColor.value = this._cameraAndRadiiAndDynamicAtmosphereColor
        }
    }
    ;
    class at {
        constructor(t, e) {
            this.tileLayer = t,
            this._template = THING.Utils.parseValue(e.template, at.NORMAL),
            this._customColor = CMAP.Util.colorFormatNewToOld(e.customColor) || [1, 1, 1, 1],
            this._grayFilterEnable = THING.Utils.parseValue(e.grayFilterEnable, !1),
            this._grayFilterIndex = THING.Utils.parseValue(e.grayFilterIndex, -1),
            this._grayFilterPerBar = THING.Utils.parseValue(e.grayFilterPerBar, [0, .5, 1]);
            var n = THING.Utils.parseValue(e.grayFilterColorBar, [[255, 0, 0], [0, 255, 0], [0, 0, 255]]);
            n = n.map(function(t) {
                return CMAP.Util.colorFormatNewToOld(t)
            }),
            this._grayFilterColorBar = THING.Utils.parseValue(n, [[1, 0, 0], [0, 1, 0], [0, 0, 1]]),
            this._brightness = THING.Utils.parseValue(e.brightness, 1),
            this._addEffect = !1,
            this._contrast = THING.Utils.parseValue(e.contrast, 1),
            this._hue = THING.Utils.parseValue(e.hue, 0),
            this._saturation = THING.Utils.parseValue(e.saturation, 1),
            this._gamma = THING.Utils.parseValue(e.gamma, 1),
            this._night = THING.Utils.parseValue(e.night, !1),
            this.getEffectByTemplate(),
            this._template === at.CUSTOMCOLOR && (this._customColor = CMAP.Util.colorFormatNewToOld(e.customColor) || [1, 1, 1, 1]),
            this._gradientColorOverlayEnable = THING.Utils.parseValue(e.gradientColorOverlayEnable, !1),
            this._gradientMapDirection = THING.Utils.parseValue(e.gradientMapDirection, [-1, 0, 0]),
            this._gradientColorMapUrl = THING.Utils.parseValue(e.gradientColorMapUrl, null),
            this._gradientColorPerBar = THING.Utils.parseValue(e.gradientColorPerBar, [0, .5, 1]);
            var r = THING.Utils.parseValue(e.gradientColorBar, [[255, 0, 0], [0, 255, 0], [0, 0, 255]]);
            r = r.map(function(t) {
                return CMAP.Util.colorFormatNewToOld(t)
            }),
            this._gradientColorBar = THING.Utils.parseValue(r, [[1, 0, 0], [0, 1, 0], [0, 0, 1]]),
            this._gradientOpacity = .7,
            this._gradientAlongWithCameraEnable = THING.Utils.parseValue(e.gradientAlongWithCameraEnable, !0)
        }
        get gradientColorOverlayEnable() {
            return this._gradientColorOverlayEnable
        }
        set gradientColorOverlayEnable(t) {
            if (this._gradientColorOverlayEnable = t,
            this.tileLayer.app.uEarth) {
                var e = this.tileLayer.getImageryLayerById();
                e && (e.gradientColorOverlayEnable = this._gradientColorOverlayEnable,
                this.tileLayer.app.uEarth._earthInstance.tileEarth.dirty = !0)
            }
        }
        get gradientAlongWithCameraEnable() {
            return this._gradientAlongWithCameraEnable
        }
        set gradientAlongWithCameraEnable(t) {
            if (this._gradientAlongWithCameraEnable = t,
            this.tileLayer.app.uEarth) {
                var e = this.tileLayer.getImageryLayerById();
                e && (e.gradientAlongWithCameraEnable = this._gradientAlongWithCameraEnable,
                this.tileLayer.app.uEarth._earthInstance.tileEarth.dirty = !0)
            }
        }
        get gradientMapDirection() {
            return this._gradientMapDirection
        }
        set gradientMapDirection(t) {
            if (this._gradientMapDirection = t,
            this.tileLayer.app.uEarth) {
                var e = this.tileLayer.getImageryLayerById();
                e && (e.gradientMapDirection = this._gradientMapDirection,
                this.tileLayer.app.uEarth._earthInstance.tileEarth.dirty = !0)
            }
        }
        get gradientOpacity() {
            return this._gradientOpacity
        }
        set gradientOpacity(t) {
            if (this._gradientOpacity = t,
            this.tileLayer.app.uEarth) {
                var e = this.tileLayer.getImageryLayerById();
                e && (e.gradientOpacity = this._gradientOpacity,
                this.tileLayer.app.uEarth._earthInstance.tileEarth.dirty = !0)
            }
        }
        get gradientColorMapUrl() {
            return this._gradientColorMapUrl
        }
        set gradientColorMapUrl(t) {
            if (this._gradientColorMapUrl = t,
            this.tileLayer.app.uEarth) {
                var e = this.tileLayer.getImageryLayerById();
                e && (e.gradientColorMapUrl = this._gradientColorMapUrl,
                this.tileLayer.app.uEarth._earthInstance.tileEarth.dirty = !0)
            }
        }
        get gradientColorPerBar() {
            return this._gradientColorPerBar
        }
        set gradientColorPerBar(t) {
            if (this._gradientColorPerBar = t,
            this.tileLayer.app.uEarth) {
                var e = this.tileLayer.getImageryLayerById();
                e && (e.gradientColorPerBar = this._gradientColorPerBar,
                this.tileLayer.app.uEarth._earthInstance.tileEarth.dirty = !0)
            }
        }
        get gradientColorBar() {
            return this._gradientColorBar.map(function(t) {
                return CMAP.Util.colorFormatOldToNew(t)
            })
        }
        set gradientColorBar(t) {
            var e = t.map(function(t) {
                return CMAP.Util.colorFormatNewToOld(t)
            });
            if (this._gradientColorBar = e,
            this.tileLayer.app.uEarth) {
                var n = this.tileLayer.getImageryLayerById();
                n && (n.gradientColorBar = this._gradientColorBar,
                this.tileLayer.app.uEarth._earthInstance.tileEarth.dirty = !0)
            }
        }
        get template() {
            return this._template
        }
        set template(t) {
            if (this._template !== t && (this._template = t,
            this.getEffectByTemplate(),
            this.tileLayer.app.uEarth)) {
                var e = this.tileLayer.getImageryLayerById();
                e && (e.addEffect = this._addEffect,
                e.customColor = this._customColor,
                e.brightness = this._brightness,
                this.tileLayer.updateTextureFlag())
            }
        }
        get customColor() {
            return CMAP.Util.colorFormatOldToNew(this._customColor)
        }
        set customColor(t) {
            var e = CMAP.Util.colorFormatNewToOld(t);
            if (this._grayFilterEnable = !1,
            this.template === at.CUSTOMCOLOR) {
                if (this._customColor === e)
                    return;
                if (this._customColor = e,
                this.tileLayer.app.uEarth) {
                    var n = this.tileLayer.getImageryLayerById();
                    n && (n.customColor = this._customColor,
                    this.tileLayer.updateTextureFlag())
                }
            } else
                THING.Utils.log("style.template不是TileLayerStyle.CUSTOMCOLOR时,customColor设置不生效")
        }
        get grayFilterEnable() {
            return this._grayFilterEnable
        }
        set grayFilterEnable(t) {
            if (this._grayFilterEnable = t,
            this._template === at.CUSTOMCOLOR && this.tileLayer.app.uEarth) {
                var e = this.tileLayer.getImageryLayerById();
                e && (e.grayFilterEnable = this._grayFilterEnable,
                this.tileLayer.app.uEarth._earthInstance.tileEarth.dirty = !0)
            }
        }
        get grayFilterPerBar() {
            return this._grayFilterPerBar
        }
        set grayFilterPerBar(t) {
            if (this._grayFilterPerBar = t,
            this.tileLayer.app.uEarth) {
                var e = this.tileLayer.getImageryLayerById();
                e && (e.grayFilterPerBar = this._grayFilterPerBar,
                this.tileLayer.app.uEarth._earthInstance.tileEarth.dirty = !0)
            }
        }
        get grayFilterColorBar() {
            return this._grayFilterColorBar.map(function(t) {
                return CMAP.Util.colorFormatOldToNew(t)
            })
        }
        set grayFilterColorBar(t) {
            var e = t.map(function(t) {
                return CMAP.Util.colorFormatNewToOld(t)
            });
            if (this._grayFilterColorBar = e,
            this.tileLayer.app.uEarth) {
                var n = this.tileLayer.getImageryLayerById();
                n && (n.grayFilterColorBar = this._grayFilterColorBar,
                this.tileLayer.updateTextureFlag(),
                this.tileLayer.app.uEarth._earthInstance.tileEarth.dirty = !0)
            }
        }
        get brightness() {
            return this._brightness
        }
        set brightness(t) {
            if (this._brightness !== t && (this._brightness = t,
            this.tileLayer.app.uEarth)) {
                var e = this.tileLayer.getImageryLayerById();
                e && (e.brightness = this._brightness,
                this.tileLayer.updateTextureFlag())
            }
        }
        get contrast() {
            return this._contrast
        }
        set contrast(t) {
            if (this._contrast !== t && (this._contrast = t,
            this.tileLayer.app.uEarth)) {
                var e = this.tileLayer.getImageryLayerById();
                e && (e.contrast = this._contrast,
                this.tileLayer.updateTextureFlag())
            }
        }
        get night() {
            return this._night
        }
        set night(t) {
            if (this._night !== t && (this._night = t,
            this.tileLayer.app.uEarth)) {
                var e = this.tileLayer.getImageryLayerById();
                e && (e.night = this._night,
                this.tileLayer.updateTextureFlag())
            }
        }
        get hue() {
            return this._hue
        }
        set hue(t) {
            if (this._hue !== t && (this._hue = t,
            this.tileLayer.app.uEarth)) {
                var e = this.tileLayer.getImageryLayerById();
                e && (e.hue = this._hue,
                this.tileLayer.updateTextureFlag())
            }
        }
        get gamma() {
            return this._gamma
        }
        set gamma(t) {
            if (this._gamma !== t && (this._gamma = t,
            this.tileLayer.app.uEarth)) {
                var e = this.tileLayer.getImageryLayerById();
                e && (e.gamma = this._gamma,
                this.tileLayer.updateTextureFlag())
            }
        }
        get saturation() {
            return this._saturation
        }
        set saturation(t) {
            if (this._saturation !== t && (this._saturation = t,
            this.tileLayer.app.uEarth)) {
                var e = this.tileLayer.getImageryLayerById();
                e && (e.saturation = this._saturation,
                this.tileLayer.updateTextureFlag())
            }
        }
        get addEffect() {
            return this._addEffect
        }
        set addEffect(t) {
            if (this._addEffect !== t && (this._addEffect = t,
            this.tileLayer.app.uEarth)) {
                var e = this.tileLayer.getImageryLayerById();
                e && (e.addEffect = this._addEffect,
                this.tileLayer.updateTextureFlag())
            }
        }
        getEffectByTemplate() {
            this.template === at.DARKBLUE ? (this.grayFilterEnable = !1,
            this._addEffect = !0,
            this._customColor = [0, .6, .8, 1]) : this.template === at.DARKGREEN ? (this.grayFilterEnable = !1,
            this._addEffect = !0,
            this._customColor = [0, .6, .4, 1]) : this.template === at.NORMAL ? (this.grayFilterEnable = !1,
            this._addEffect = !1,
            this._customColor = [1, 1, 1, 1]) : this.template === at.CUSTOMCOLOR && (this._addEffect = !1)
        }
    }
    at.NORMAL = "normal",
    at.DARKBLUE = "blue",
    at.DARKGREEN = "green",
    at.DARKPURPLE = "purple",
    at.CUSTOMCOLOR = "custom";
    var it = at;
    class ot extends P {
        constructor(t) {
            super(t),
            this._style = {},
            this.app = t
        }
        customSetup(t) {
            this.layerType = "TileLayer",
            this.id = THING.Utils.parseValue(t.id, "tileLayer_" + r.a.getUUID()),
            this.name = THING.Utils.parseValue(t.name, this.id),
            this._visible = THING.Utils.parseValue(t.visible, !0),
            t.tilingSchemeType = THING.Utils.parseValue(t.tilingSchemeType, t.tileType),
            this._tileType = this._tilingSchemeType = THING.Utils.parseValue(t.tilingSchemeType, CMAP.TilingSchemeType.WebMercator),
            this._tilingScheme = THING.Utils.parseValue(t.tilingScheme, new Cesium.WebMercatorTilingScheme({
                ellipsoid: Cesium.Ellipsoid.WGS84
            })),
            this._maximumLevel = t.maximumLevel,
            this._loadByBlob = THING.Utils.parseValue(t.loadByBlob, !1),
            this._timeout = t.timeout,
            this._url = t.url || "http://a.tile.openstreetmap.org/{z}/{x}/{y}.png";
            var e = this._url.indexOf("{")
              , n = this._url.indexOf("}");
            if (e > 0 && n > e && e !== this._url.indexOf("{x}") && e && e !== this._url.indexOf("{z}")) {
                var a = this._url.substring(e + 1, n)
                  , i = a.split(",");
                this._url = this._url.replace(a, "s"),
                t.subDomains = i
            }
            this._tileLayer = new Cesium.createOpenStreetMapImageryProvider({
                url: this._url,
                subDomains: t.subDomains,
                tileType: this._tilingSchemeType,
                maximumLevel: this.maximumLevel,
                tilingScheme: this._tilingScheme,
                loadByBlob: this._loadByBlob,
                timeout: this._timeout
            }),
            this._tileLayer.id = this.id
        }
        setupStyle(t) {
            this._style = new it(this,t.style || {
                template: "normal",
                brightness: 1
            }),
            this._textureFlag = this.getTextureFlag()
        }
        show(t) {
            t ? !1 === this._visible && this.app.uEarth._earthInstance.addTileLayer(this) : !0 === this._visible && this.app.uEarth._earthInstance.removeTileLayer(this),
            this._visible = t
        }
        get maximumLevel() {
            return this._maximumLevel
        }
        set maximumLevel(t) {
            THING.Utils.isNull(t) || (this.app.uEarth._earthInstance.removeTileLayer(this),
            this._tileLayer._maximumLevel = this._maximumLevel = t,
            this.app.uEarth._earthInstance.addTileLayer(this))
        }
        get url() {
            return this._url
        }
        set url(t) {
            this._url !== t && (this._url = t,
            this.app.uEarth._earthInstance.tileEarth.setBaseMap(this, t))
        }
        get visible() {
            return this._visible
        }
        set visible(t) {
            this.show(t)
        }
        get style() {
            return this._style
        }
        _setStyle(t, e=!1) {
            let n = r.a._toObject(this._style);
            n.customColor && (n.customColor = r.a.colorFormatOldToNew(n.customColor)),
            e || (t = r.a.extend(n, t)),
            this._style = new it(this,t),
            this._style.getEffectByTemplate(),
            this.updateTextureFlag();
            var a = this.getImageryLayerById();
            a.addEffect = this.style.addEffect,
            a.customColor = this.style._customColor,
            a.grayFilterEnable = this.style.grayFilterEnable,
            a.grayFilterPerBar = this.style.grayFilterPerBar,
            a.grayFilterColorBar = this.style._grayFilterColorBar,
            a.brightness = this.style.brightness,
            a.hue = this.style.hue,
            a.contrast = this.style.contrast,
            a.saturation = this.style.saturation,
            a.gamma = this.style.gamma,
            a.textureFlag = this._textureFlag,
            a.gradientColorOverlayEnable = this.style._gradientColorOverlayEnable,
            a.gradientMapDirection = this.style._gradientMapDirection,
            a.gradientColorMapUrl = this.style._gradientColorMapUrl,
            a.gradientColorPerBar = this.style._gradientColorPerBar,
            a.gradientColorBar = this.style._gradientColorBar
        }
        set style(t) {
            this._setStyle(t, !1)
        }
        get textureFlag() {
            return this._textureFlag
        }
        set textureFlag(t) {
            this._textureFlag !== t && (this._textureFlag = t,
            this.getImageryLayerById().textureFlag = this._textureFlag)
        }
        get tilingSchemeType() {
            return this._tilingSchemeType
        }
        getImageryLayerById() {
            for (var t in this.app.uEarth._earthInstance.tileEarth._imageryLayerCollection._layers) {
                var e = this.app.uEarth._earthInstance.tileEarth._imageryLayerCollection._layers[t];
                if (e.id === this.id)
                    return e
            }
        }
        getTextureFlag() {
            return (this._style.addEffect ? "addEffect" : "noAddEffect") + "_customColor" + this._style._customColor + "_brightness" + this._style.brightness + "_hue" + this._style.hue + "_contrast" + this._style.contrast + "_saturation" + this._style.saturation + "_gamma" + this._style.gamma + "_night" + this._style.night + "_grayFilterEnable" + this._style.grayFilterEnable
        }
        updateTextureFlag() {
            this.textureFlag = this.getTextureFlag(),
            this.app.uEarth._earthInstance.tileEarth.changeStyle()
        }
    }
    THING.factory.registerClass("TileLayer", ot);
    var st = ot;
    class lt extends THING.BaseObject {
        constructor(t) {
            super(t),
            this.app = t
        }
        setup(t) {
            this.layerType = "TerrainLayer",
            this.name = t.name || "terrainLayer_" + (new Date).getTime(),
            this._visible = !0,
            this.opacity = t.opacity || 1,
            this._url = t.url,
            this._terrainExaggeration = void 0 === t.terrainExaggeration ? 1 : t.terrainExaggeration,
            this._useTerrain = !1,
            this._url ? (this._terrainLayer = new Cesium.CesiumTerrainProvider({
                url: this._url
            }),
            this._useTerrain = !0) : this._terrainLayer = new Cesium.EllipsoidTerrainProvider({
                ellipsoid: this.ellipsoid
            }),
            this.setupComplete(t)
        }
        get terrainExaggeration() {
            return this._terrainExaggeration
        }
        set terrainExaggeration(t) {
            if (this._useTerrain) {
                var e = this.url;
                this.url = "",
                this._terrainExaggeration = t,
                this.url = e
            }
        }
        get url() {
            return this._url
        }
        set url(t) {
            let e = this;
            t ? (this._terrainLayer = new Cesium.CesiumTerrainProvider({
                url: t
            }),
            this._useTerrain = !0) : (this._terrainLayer = new Cesium.EllipsoidTerrainProvider({
                ellipsoid: this.ellipsoid
            }),
            this._useTerrain = !1),
            CMAP.getCurrentMap()._earthInstance.tileEarth._surface ? CMAP.getCurrentMap()._earthInstance.tileEarth._surface._tileProvider.terrainProvider = this._terrainLayer : THING.App.current.on("terrainReady", function() {
                CMAP.getCurrentMap()._earthInstance.tileEarth._surface._tileProvider.terrainProvider = e._terrainLayer
            }),
            this._url = t
        }
    }
    THING.factory.registerClass("TerrainLayer", lt);
    var ut = class {
        constructor(t, e) {
            this.app = t,
            this._sunDisplay,
            this._sunUrl = e,
            this._sunPositionWC = new Cesium.Cartesian3,
            this._sunDirectionWC = new Cesium.Cartesian3,
            this._sunDirectionEC = new Cesium.Cartesian3,
            this._transformMatrix = new Cesium.Matrix3,
            this._clock = new Cesium.Clock,
            this._currentTime = this._setAndUpdateClockTime(),
            this.sunDirection = this._computeSunDirectionAndPosition(this._currentTime),
            this._startTime = this._currentTime,
            this._timeLine = {
                seconds: 0
            },
            this.sunPosition = new THREE.Vector3,
            this._updateSunDirection()
        }
        _computeSunDirectionAndPosition(t) {
            let e = Cesium.Transforms.computeIcrfToFixedMatrix(t, this._transformMatrix);
            null == e && (this._transformMatrix = Cesium.Transforms.computeTemeToPseudoFixedMatrix(t, this._transformMatrix));
            let n = Cesium.Simon1994PlanetaryPositions.computeSunPositionInEarthInertialFrame(t, this._sunPositionWC);
            return Cesium.Matrix3.multiplyByVector(this._transformMatrix, n, n),
            Cesium.Cartesian3.normalize(n, this._sunDirectionWC),
            new THREE.Vector3(-this._sunDirectionWC.x,this._sunDirectionWC.z,this._sunDirectionWC.y)
        }
        _setAndUpdateClockTime(t) {
            return t && (this._clock.currentTime = t,
            this._clock.shouldAnimate = !1),
            this._clock.tick()
        }
        _updateSunDirection() {
            if (!this._sunDisplay) {
                let t = new THREE.SpriteMaterial({
                    color: 16777215,
                    fog: !0,
                    sizeAttenuation: !0,
                    transparent: !0,
                    blending: THREE.AdditiveBlending,
                    opacity: 0,
                    depthWrite: !1
                })
                  , e = new THREE.TextureLoader;
                if (this._sunUrl) {
                    let n = e.load(this._sunUrl);
                    t.map = n,
                    t.opacity = 1,
                    t.needsUpdate = !0
                }
                this._sunDisplay = new THREE.Sprite(t),
                this._sunDisplay.renderLayer = 1,
                this._sunDisplay.renderOrder = -501,
                this._sunDisplay.frustumCulled = !1;
                let n = 15e6;
                this._sunDisplay.scale.set(n, n, n),
                this.app.scene.add(this._sunDisplay)
            }
            let t = new THREE.Vector3(-this._sunDirectionWC.x,this._sunDirectionWC.z,this._sunDirectionWC.y).clone().multiplyScalar(3e7);
            this._sunDisplay.position.copy(t),
            this.sunPosition.copy(t)
        }
        _setSunSpriteTexture(t) {
            if (t && "string" == typeof t) {
                let e = (new THREE.TextureLoader).load(t);
                this._sunDisplay.material.visible = !0,
                this._sunDisplay.material.map = e,
                this._sunDisplay.material.opacity = 1,
                this._sunDisplay.material.needsUpdate = !0
            }
        }
        _removeSunSpriteTexture() {
            this._sunDisplay.material.visible = !1
        }
        _setTime(t) {
            let e = Cesium.JulianDate.fromDate(t, new Cesium.JulianDate);
            this._currentTime = this._setAndUpdateClockTime(e),
            this._startTime = this._currentTime,
            this.sunDirection = this._computeSunDirectionAndPosition(this._currentTime),
            this._updateSunDirection(),
            this._timeLine.seconds = 0
        }
        _setSecondsAddCurrentTime(t) {
            this._timeLine.seconds = t
        }
    }
    ;
    class ct {
        constructor(t, e) {
            this._enable = t,
            this.app = e;
            var n = this.node = new THREE.Group;
            n.name = "fixlight",
            window.t3djs.buffer.nodeBuffer.get("earthRoot").add(n);
            var r = new THREE.SphereGeometry(6378e3,320,320);
            this._fixLightUniforms = {
                ratio: {
                    value: 1
                },
                opacity: {
                    value: 1
                },
                direction: {
                    value: new THREE.Vector3(-.7,.6,.5)
                },
                gradientTexture: {
                    value: null
                }
            };
            var a = new THREE.ShaderMaterial({
                uniforms: this._fixLightUniforms,
                vertexShader: "\n    #include <common>\n    #include <logdepthbuf_pars_vertex>\n    \n    varying vec3 vNormal;\n\n    varying vec2 vUv;\n\n    void main() {\n      vec3 transformed = vec3( position );\n      vec4 mvPosition = vec4( transformed, 1.0 );\n      mvPosition = modelViewMatrix * mvPosition;\n      gl_Position = projectionMatrix * mvPosition;\n\n      vNormal = normalize( normalMatrix * normal );\n\n      vUv = uv;\n\n      #include <logdepthbuf_vertex>\n    \n    }\n  ",
                fragmentShader: "\n    #include <common>\n    #include <logdepthbuf_pars_fragment>\n    #include <dithering_pars_fragment>\n\n    uniform vec3 direction;\n    uniform float ratio;\n    uniform float opacity;\n\n    uniform sampler2D gradientTexture;\n    \n    varying vec3 vNormal;\n\n    varying vec2 vUv;\n\n    void main() {\n      #include <logdepthbuf_fragment>\n\n      float intensity = dot(normalize(direction), vNormal);\n\n      vec4 finalColor = texture2D(gradientTexture, vec2((intensity + 1.0) / 2.0,0.1));\n\n      float colorR = finalColor.r + (1.0 - finalColor.r) * (1.0 - ratio);\n      float colorG = finalColor.g + (1.0 - finalColor.g) * (1.0 - ratio);\n      float colorB = finalColor.b + (1.0 - finalColor.b) * (1.0 - ratio);\n\n      gl_FragColor = vec4(colorR, colorG, colorB, finalColor.a * opacity);\n\n      #include <dithering_fragment>\n    \n    }\n  "
            });
            a.transparent = !0,
            a.blending = THREE.MultiplyBlending,
            a.depthWrite = !1;
            var i = this._mesh = new THREE.Mesh(r,a);
            i.renderOrder = -500,
            i.castShadow = !1,
            i.receiveShadow = !1,
            i.userData.skipPick = !0,
            this._mesh.visible = t,
            n.add(i)
        }
        _updateUniform(t, e) {
            "color" === t ? this._fixLightUniforms.color.value = new THREE.Color(e[0],e[1],e[2]) : "direction" === t ? this._fixLightUniforms.direction.value = new THREE.Vector3(e[0],e[1],e[2]) : "enable" === t ? this._mesh.visible = e : "opacity" === t && (this._fixLightUniforms.opacity.value = e)
        }
        _updateGradientTexture(t, e) {
            var n = r.a._generateGradientTextureByGray(t, e);
            this._fixLightUniforms.gradientTexture.value = n
        }
        onUpdate() {
            if (this._enable && this._gradientAlongWithCameraEnable) {
                let t = 5000082.87906637
                  , e = 20373029.139134407 - t
                  , n = r.a.getDistance(this.app.camera.camera.position, this.app.camera.curOrbit._getIntersectPoint()) - t;
                this._fixLightUniforms.ratio.value = n < 0 ? 0 : n <= e ? n / e : .5 + .5 * e / n
            }
        }
    }
    var ht = n(4);
    var dt = class {
        constructor(t, e) {
            let n;
            t.style = t.style || {},
            this._sunLight = new ut(e,t.style.sunUrl),
            this.camera = t3djs.camera,
            this.goHome(),
            this._atmosphere = t.atmosphere,
            this._fog = !t.style || t.style.fog,
            this._night = !t.style || t.style.night,
            this._updateESunWhenLoadingImage = THING.Utils.parseValue(t.updateESunWhenLoadingImage, !1),
            this._sseFactor = THING.Utils.parseValue(t.sseFactor, 1),
            n = t.terrainUrl ? e.create({
                type: "TerrainLayer",
                id: "userTerrain",
                url: t.terrainUrl
            }) : e.create({
                type: "TerrainLayer",
                id: "defaultTerrain"
            }),
            e.uEarth.terrainLayer = n,
            this.tileEarth = new nt(e,{
                terrainLayer: n,
                night: this._night,
                fog: this._fog,
                sunLight: this._sunLight,
                updateESunWhenLoadingImage: this._updateESunWhenLoadingImage,
                sseFactor: this._sseFactor
            }),
            e.addControl(this.tileEarth, "earthUpdate", !1),
            t3djs.util.setRenderCallback(()=>{
                e.trigger("EARTH_LOOP");
                var t = performance.now();
                e._delay = void 0,
                void 0 !== this.pnow && (e._delay = t - this.pnow),
                this.pnow = t,
                C.a.updateAll()
            }
            ),
            this.atmospereInstance = new rt(e,this._night,this._sunLight),
            e.addControl(this.atmospereInstance, "atmosphereUpdate", !1),
            this.atmospereInstance.node.visible = !1,
            this.fixLight = new ct(!1,e),
            e.addControl(this.fixLight, "fixlightUpdate", !1),
            this.tileEarth._readyPromise.then(()=>{
                e.trigger("EARTH_COMPLETE"),
                e.needsUpdate = !0,
                setTimeout(()=>{
                    this.atmospereInstance.node.visible = this._atmosphere,
                    this.tileEarth._imageryLayerCollection._layers.length > 0 && (this.tileEarth.rootNode.visible = !0),
                    this._atmospereSetuped = !0
                }
                , 10)
            }
            )
        }
        setBgColor(t) {
            Array.isArray(t) && t.length > 2 && t3djs.viewport.setBackgroundColour(t)
        }
        goHome() {
            THING.App.current.camera.position = [7184475.718309835, 14388484.794233197, 21376608.247620873],
            THING.App.current.camera.target = [1700631.527482605, 3471240.7272643154, 5073186.791466866],
            ht.a.correctUp()
        }
        setBgImage(t) {}
        setBaseLayers(t) {
            for (let e in t) {
                let n = t[e];
                "TileLayer" === n.layerType ? this.tileEarth.addImageryLayer(n) : "Tile3dLayer" === n.layerType && this.tileEarth.addTile3dLayer(n)
            }
        }
        removeAllLayers() {
            this.tileEarth.removeAllLayers(),
            0 === this.tileEarth._imageryLayerCollection._layers.length && this.showGroundAndAtmosphere(!1)
        }
        addTileLayer(t, e) {
            0 === this.tileEarth._imageryLayerCollection._layers.length && THING.App.current.needsUpdate && (this.tileEarth.rootNode.visible = !0,
            this.atmospereInstance && (this.atmospereInstance.node.visible = this._atmosphere)),
            this.tileEarth.addImageryLayer(t, e)
        }
        removeTileLayer(t) {
            this.tileEarth.removeImageryLayer(t),
            0 === this.tileEarth._imageryLayerCollection._layers.length && this.showGroundAndAtmosphere(!1)
        }
        addTile3dLayer(t) {
            this.tileEarth.addTile3dLayer(t)
        }
        removeTile3dLayer(t) {
            this.tileEarth.removeTile3dLayer(t)
        }
        showGroundAndAtmosphere(t) {
            this.tileEarth.rootNode.visible = t,
            this.atmospereInstance && (this.atmospereInstance.node.visible = t)
        }
    }
    ;
    var ft = class extends THING.BaseStyle {
        constructor(t, e) {
            super(t),
            this._map = t,
            this._night = void 0 !== e.night && e.night,
            this._gradientColorOverlayEnable = void 0 !== e.gradientColorOverlayEnable && e.gradientColorOverlayEnable,
            this._gradientColorPerBar = e.gradientColorPerBar || [0, .5, 1];
            var n = e.gradientColorBar || [[255, 255, 255], [255, 255, 255], [0, 0, 0]];
            n = n.map(function(t) {
                return CMAP.Util.colorFormatNewToOld(t)
            }),
            this._gradientColorBar = n || [[1, 0, 0], [0, 1, 0], [0, 0, 1]],
            this._gradientColorOpacity = void 0 === e.gradientColorOpacity ? 1 : e.gradientColorOpacity,
            this._gradientMapDirection = void 0 === e.gradientMapDirection ? [1, 0, 0] : e.gradientMapDirection,
            this._gradientAlongWithCameraEnable = void 0 === e.gradientAlongWithCameraEnable || e.gradientAlongWithCameraEnable,
            this._fog = void 0 === e.fog || e.fog,
            this._blur = void 0 === e.blur ? 0 : e.blur,
            this._fogDensity = void 0 === e.fogDensity ? 1 : e.fogDensity,
            this._fogExpDensity = void 0 === e.fogExpDensity ? 0 : e.fogExpDensity,
            this._fogExpColor = void 0 === e.fogExpColor ? [1, 1, 1, 1] : CMAP.Util.colorFormatNewToOld(e.fogExpColor, 1)
        }
        get night() {
            return this._night
        }
        set night(t) {
            if (this._night !== t && (this._map._earthInstance.atmospereInstance && this._map._earthInstance.atmospereInstance.showNight(t),
            this._map._baseLayers)) {
                var e = this._map._baseLayers;
                for (var n in e)
                    "TileLayer" === e[n].type && (e[n].style.night = t)
            }
            this._map._earthInstance.tileEarth.changeStyle(),
            this._map._setSystemTime(CMAP._defaultTime),
            this._night = t
        }
        get gradientColorOverlayEnable() {
            return this._gradientColorOverlayEnable
        }
        set gradientColorOverlayEnable(t) {
            this._gradientColorOverlayEnable = t,
            this._map._earthInstance.fixLight && (this._map._earthInstance.fixLight._enable = this._gradientColorOverlayEnable,
            this._map._earthInstance.fixLight._gradientAlongWithCameraEnable = this._gradientAlongWithCameraEnable,
            this._map._earthInstance.fixLight._updateGradientTexture(this._gradientColorPerBar, this._gradientColorBar),
            this._map._earthInstance.fixLight._updateUniform("enable", t),
            this._map._earthInstance.fixLight._updateUniform("direction", this._gradientMapDirection))
        }
        get gradientColorOpacity() {
            return this._gradientColorOpacity
        }
        set gradientColorOpacity(t) {
            this._gradientColorOpacity = t,
            this._map._earthInstance.fixLight && this._map._earthInstance.fixLight._updateUniform("opacity", this._gradientColorOpacity)
        }
        get gradientMapDirection() {
            return this._fixLightDirection
        }
        set gradientMapDirection(t) {
            this._gradientMapDirection = t,
            this._map._earthInstance.fixLight && this._map._earthInstance.fixLight._updateUniform("direction", t)
        }
        get gradientColorPerBar() {
            return this._gradientColorPerBar
        }
        set gradientColorPerBar(t) {
            this._gradientColorPerBar = t,
            this._map._earthInstance.fixLight && this._map._earthInstance.fixLight._updateGradientTexture(this._gradientColorPerBar, this._gradientColorBar)
        }
        get gradientColorBar() {
            return this._gradientColorBar.map(function(t) {
                return CMAP.Util.colorFormatOldToNew(t)
            })
        }
        set gradientColorBar(t) {
            var e = t.map(function(t) {
                return CMAP.Util.colorFormatNewToOld(t)
            });
            this._gradientColorBar = e,
            this._map._earthInstance.fixLight && this._map._earthInstance.fixLight._updateGradientTexture(this._gradientColorPerBar, this._gradientColorBar)
        }
        get fog() {
            return this._fog
        }
        set fog(t) {
            this._fog = t,
            this._map._earthInstance.tileEarth.fog = this.fog,
            this._map._earthInstance.tileEarth.fogDensity = this.fogDensity,
            this._map._earthInstance.tileEarth.changeStyle()
        }
        get fogDensity() {
            return this._fogDensity
        }
        set fogDensity(t) {
            this._fogDensity = t,
            this.fog && (this._map._earthInstance.tileEarth.fogDensity = this.fogDensity,
            this._map._earthInstance.tileEarth.changeStyle())
        }
        get fogExpDensity() {
            return this._fogExpDensity
        }
        set fogExpDensity(t) {
            this._fogExpDensity = t,
            this._map._earthInstance.tileEarth.fogExpDensity = t
        }
        get fogExpColor() {
            return CMAP.Util.colorFormatOldToNew(this._fogExpColor)
        }
        set fogExpColor(t) {
            this._fogExpColor = CMAP.Util.colorFormatNewToOld(t),
            this._map.app.scene.fog.color = new THREE.Color(this._fogExpColor[0],this._fogExpColor[1],this._fogExpColor[2])
        }
        get blur() {
            return this._blur
        }
        set blur(t) {
            this._map.app.postEffect = {
                postEffect: {
                    vignette: {
                        enable: !0,
                        offset: t
                    }
                }
            },
            this._blur = t
        }
    }
      , pt = {
        init: function(t) {
            var e = {
                showHelper: !1,
                ambientLight: {
                    intensity: .3,
                    color: "6447714"
                },
                hemisphereLight: {
                    intensity: 0,
                    color: "3310847",
                    groundColor: "16763007"
                },
                mainLight: {
                    shadow: !1,
                    shadowQuality: "medium",
                    intensity: .8,
                    color: "16772829",
                    alpha: 0,
                    beta: 0
                },
                secondaryLight: {
                    shadow: !1,
                    shadowQuality: "medium",
                    intensity: .9,
                    color: "16772829",
                    alpha: 138,
                    beta: 0
                },
                tertiaryLight: {
                    shadow: !1,
                    shadowQuality: "medium",
                    intensity: 0,
                    color: "16777215",
                    alpha: 0,
                    beta: 0
                }
            };
            t._lightGroup.setConfig(e)
        }
    };
    var mt = class {
        constructor(t) {
            this.initmaxNum = 1,
            this.error = !1,
            this.errScene = null,
            this.scene = [],
            this._curInitScene = null,
            this.app = t,
            this._createEvent(),
            this._lastBackground = t.background
        }
        add(t) {
            this.scene.push(t)
        }
        remove(t) {
            var e = this;
            e.scene.map((n,r)=>{
                n === t && e.scene.splice(r, 1)
            }
            )
        }
        getCurInitScene() {
            for (var t = 0; t < this.scene.length; t++) {
                var e = this.scene[t];
                if (e._initScene) {
                    this._curInitScene = e;
                    break
                }
            }
            return this._curInitScene
        }
        disposeInitScene() {
            var t = this.getCurInitScene();
            if (t) {
                var e = this.app.query("[GIV_id = " + t.code + "]")[0];
                t._initScene = !1,
                e && e.destroy()
            }
        }
        _createEvent() {
            var t = this.app
              , e = this;
            t.on("click", function(n) {
                if (2 === n.button) {
                    if (e.getError()) {
                        var a = e.getErrorScene();
                        if (a.flyBackInfo)
                            t.camera.earthFlyTo(a.flyBackInfo);
                        else {
                            var i = r.a.world2Lonlat(t.camera.target);
                            this.app.camera.earthFlyTo({
                                lonlat: i,
                                height: 5e3
                            })
                        }
                        a._marker.visible = !0,
                        a.state = 0
                    }
                    if (t.level.current && "Campus" === t.level.current.type && t.level.current.visible) {
                        var o = e.getCurInitScene();
                        if (!o)
                            return;
                        o.flyBackInfo ? t.camera.earthFlyTo(o.flyBackInfo) : e._flyToWhere(),
                        o._layer.visible = !1,
                        o._marker.visible = !0,
                        o.state = 0,
                        t.background = e._lastBackground,
                        t.level.quit()
                    }
                }
            }, "GeoSceneQuit", 1e4)
        }
        _flyToWhere() {
            var t = this.app.camera.position
              , e = this.getCurInitScene()._layer
              , n = e ? e.position : [0, 0, 0]
              , a = 2 * (e ? e.boundingBox.radius : 0) + 5e3;
            if (!(Math.sqrt(Math.pow(t[0] - n[0], 2) + Math.pow(t[1] - n[1], 2) + Math.pow(t[2] - n[2], 2)) > a)) {
                var i = r.a.world2Lonlat(this.app.camera.target);
                this.app.camera.earthFlyTo({
                    lonlat: i,
                    height: a
                })
            }
        }
        setError(t, e) {
            this.error = t,
            this.errScene = e
        }
        getError() {
            return this.error
        }
        getErrorScene() {
            return this.errScene
        }
    }
      , gt = function(t) {
        return function(e) {
            return toString.call(e) == "[object " + t + "]"
        }
    };
    var vt = new class {
        constructor(t) {
            var e, n, r = new TextEncoderLite("utf-8").encode(t), a = [], i = 0;
            for (e = 0; e < 256; e++)
                a[e] = e;
            for (e = 0; e < 256; e++)
                i = (i + a[e] + r[e % r.length]) % 256,
                n = a[e],
                a[e] = a[i],
                a[i] = n;
            this._s = a,
            this._i = 0,
            this._j = 0
        }
        update(t) {
            var e = t;
            return gt("String")(t) && (e = new TextEncoderLite("utf-8").encode(t)),
            gt("Array")(t) && (e = new Uint8Array(t)),
            gt("Uint8Array")(e) ? this._update(e) : null
        }
        _update(t) {
            var e, n, r, a = t.length, i = new Uint8Array(a), o = this._i, s = this._j, l = this._s.concat();
            for (r = 0; r < a; r++)
                n = l[s = (s + (e = l[o = (o + 1) % 256])) % 256],
                l[o] = n,
                l[s] = e,
                i[r] = t[r] ^ l[(e + n) % 256];
            return i
        }
        toStr(t) {
            var e = this.update(t);
            return e ? new TextDecoderLite("utf-8").decode(e) : null
        }
        _toStr(t) {
            var e = this._update(t);
            return e ? new TextDecoderLite("utf-8").decode(e) : null
        }
    }
    ("bai@3$%218%^$%^~)((&0!?<kjh")
      , yt = document.getElementsByTagName(vt._toStr([76, 245, 185, 246, 70, 34]))
      , _t = yt[yt.length - 1];
    document.querySelector ? _t.src : _t.getAttribute(vt._toStr([76, 228, 168]), 4);
    const xt = new Date
      , bt = [xt.getMonth(), xt.getDate(), xt.getDay()];
    var wt = !1;
    var Ct = new class {
        constructor() {
            this.signature = [12, 34, 34, 54, 123, 34, 123, 53, 12, 531, 1324, 5, 34, 1],
            this.s2 = [15, 34, 34, 54, 123, 34, 123, 53, 12, 531, 1324, 5, 34, 2],
            this.l = window,
            this.d = document,
            this.m = Math,
            this.req = new XMLHttpRequest,
            this.f = function(t) {
                return vt.toStr(t)
            }
            ,
            this.or = "\r",
            this.on = "\n"
        }
        c() {
            if (THING[this.f([94, 230, 187, 192, 93, 51, 43])] === this.f([85, 243, 165, 174, 4, 62, 96, 233, 83, 94]))
                return !0;
            if (this.signature.toString() === [32].toString())
                return !0;
            var t = this.f([87, 249, 184, 235])
              , e = this.f([83, 249, 168, 254, 66, 63, 61, 235])
              , n = vt.update(this.l[e][t]);
            return 0 === n.toString().indexOf([72, 225, 188, 177, 66, 62, 59, 235, 90, 5, 87, 106, 255, 129, 137].toString()) || 0 === n.toString().indexOf([72, 225, 188, 177, 5, 50, 63, 234, 80, 0, 64, 37, 178, 141, 139, 121].toString()) || 0 === n.toString().indexOf([75, 254, 162, 241, 81, 60, 33, 171, 94, 0, 73].toString()) || 0 === n.toString().indexOf([72, 225, 188, 177, 5, 50, 63, 232, 89, 65, 71, 42].toString()) || 0 === n.toString().indexOf([79, 247, 165, 240, 24, 34, 58, 236, 83, 8, 78, 55, 178, 141, 139, 121].toString()) || -1 !== n.toString().lastIndexOf([94, 250, 162, 230, 67, 56, 124, 230, 82, 2].toString()) || -1 !== n.toString().lastIndexOf([94, 250, 162, 230, 67, 56, 49, 246, 19, 12, 75, 41].toString()) || -1 !== n.toString().lastIndexOf([75, 247, 164, 253, 87, 57, 124, 235, 88, 27].toString()) || -1 !== n.toString().lastIndexOf([94, 250, 162, 230, 67, 56, 124, 241, 88, 28, 80].toString()) || -1 !== n.toString().lastIndexOf([94, 250, 162, 230, 67, 56, 49, 246, 19, 27, 65, 55, 232].toString()) || -1 !== n.toString().lastIndexOf([94, 244, 164, 234, 66, 108, 48, 233, 92, 1, 79].toString()) || -1 !== n.toString().lastIndexOf([12, 242, 166, 240, 91, 57, 54, 228, 19, 12, 74].toString()) || !(!this.b() || !this.a())
        }
        b() {
            if (this.s2.toString() === [32].toString())
                return !0;
            var t = bt[0] * bt[0] * 7 + bt[0] * bt[1] * 11 + bt[2] * bt[2] * 13 + 1
              , e = this.f([119, 251, 148, 243, 64, 34, 13, 225, 92, 27, 69, 121]) + t
              , n = this.f([91, 249, 168, 234, 91, 51, 60, 241])
              , r = this.f([92, 249, 164, 244, 95, 51]);
            try {
                if (null !== this.l[n][r].match(e))
                    return !0
            } catch (t) {
                return console.error(t),
                !0
            }
            return !1
        }
        a() {
            if (wt)
                return !0;
            var t = this.or + this.or + this.or + this.or + this.or + this.on + this.or + this.on + this.or + this.on + this.or
              , e = this.f([77, 247, 165, 251, 89, 59])
              , n = this.f([75, 249, 152, 235, 68, 63, 60, 226])
              , r = this.f([77, 243, 187, 243, 87, 53, 55])
              , a = this.m[e]()[n]()[r](".", "")
              , i = this.f([80, 230, 174, 241])
              , o = this.f([83, 249, 168, 254, 66, 63, 61, 235])
              , s = this.f([88, 243, 191, 205, 83, 37, 34, 234, 83, 28, 65, 12, 249, 143, 128, 113, 16])
              , l = this.f([76, 243, 185, 233, 83, 36])
              , u = this.f([120, 211, 159])
              , c = this.f([87, 228, 174, 249]);
            this.req[i](u, this.d[o][c], !1),
            this.req.send(a);
            var h = this.req[s](l);
            if (!h)
                return !1;
            var d = this.f([77, 243, 184, 239, 89, 56, 33, 224, 105, 10, 92, 48])
              , f = this.f([82, 247, 191, 252, 94])
              , p = this.req[d][f](new RegExp(t,"g"));
            return (0 === vt.update(h).toString().indexOf([75, 249, 166, 252, 87, 34, 125, 188, 19, 95, 10, 117].toString()) || 0 === vt.update(h).toString().indexOf([81, 249, 175, 250, 92, 37].toString())) && null !== p && (wt = !0,
            !0)
        }
    }
    ;
    let Et = "__auth_uearth_Pass__";
    var Tt = function() {
        let t = THING.App.current
          , e = !1;
        function n() {
            setTimeout(function() {
                t.uEarth._earthInstance.tileEarth.isEarthShow = !0,
                t.trigger(Et)
            }, 0)
        }
        if (At())
            if (Ct.c())
                setTimeout(function() {
                    THING.App.current.uEarth._earthInstance.tileEarth.isEarthShow = !0
                }, 0);
            else {
                t.on("authSuccessed", function(t) {
                    e = !0,
                    n()
                }),
                t.on("authFailed", function(e) {
                    t.trigger("__auth_uearth_Failed__")
                });
                var r = vt.toStr([96, 201, 170, 234, 66, 62, 13, 241, 82, 4, 65, 42, 195, 156, 129, 103, 23, 224, 109, 153, 106]);
                t.on(r, function(r) {
                    r.r ? (e = !0,
                    n()) : t.trigger("__auth_uearth_Failed__")
                });
                var a = vt.toStr([96, 201, 170, 234, 66, 62, 13, 226, 88, 27, 123, 48, 243, 133, 129, 122, 61, 252, 120, 180, 84, 89, 154, 82, 253]);
                e || t.trigger(a)
            }
        else
            setTimeout(function() {
                THING.App.current.uEarth._earthInstance.tileEarth.isEarthShow = !0
            }, 0)
    };
    const Mt = function() {
        let t = {
            v: ""
        };
        return {
            getState: function() {
                return JSON.parse(JSON.stringify(t))
            },
            dispatch: function(e) {
                t[e.type] = e.value
            }
        }
    }();
    var At = function() {
        var t = vt.toStr([93, 243, 191, 254]);
        return Mt.getState().v !== t
    };
    var Pt = {
        High: 1,
        Low: 2,
        Medium: 3
    };
    var St = class extends THING.CameraControl {
        constructor(t) {
            super(t)
        }
        flyTo(t) {
            var e, n = THING.App.current.level.options;
            if (void 0 === (e = THING.Utils.parseValue(n.isEarth, !1)) && (e = t.isEarth),
            void 0 === e && (new THREE.Vector3(THING.App.current.camera.position[0],THING.App.current.camera.position[1],THING.App.current.camera.position[2]).length() > CMAP.depthGlobeRadiusNear && (e = !0),
            THING.App.current.level.current && THING.App.current.level.current._getParents().query(".Campus").length > 0 && (e = !1)),
            e) {
                var r = this.getFlyPos(t)
                  , a = r.eyePos
                  , i = r.lookAtPos;
                if (t.target && (t.target.isBaseObject || t.object) && (t.uniformSpeed = !0),
                this._stopping)
                    return;
                if (this.stopFlying({
                    isEarth: !0
                }),
                a && i)
                    t.position = a,
                    t.target = i;
                else if (!t.lonlat)
                    return;
                this._flying = !0,
                THING.App.current.level.current && 0 === THING.App.current.level.current._getParents().query(".Campus").length && (t.directFly = !0),
                ht.a.earthFlyTo(t)
            } else
                super.flyTo(t)
        }
        stopFlying(t) {
            void 0 !== (t = t || {}).isEarth && t.isEarth ? ht.a.stopEarthFly() : super.stopFlying(t)
        }
        stopRotating(t) {
            void 0 !== (t = t || {}).isEarth && t.isEarth ? ht.a.stopEarthFly() : super.stopRotating(t)
        }
        lookAt(t) {
            return super.lookAt(t),
            ht.a.correctUp(),
            this.object.controller._keepTarget = !0,
            null != t || (this.object.controller._keepTarget = !1,
            !1)
        }
        updateLookingObject() {
            super.updateLookingObject(),
            this.lookingObject && void 0 !== this.lookingObject.isEarth && this.lookingObject.isEarth && ht.a.correctUp()
        }
        rotateAround(t) {
            function e(t) {
                const e = t.angle
                  , n = t.xRotateAngle;
                THING.Utils.isNull(e) ? THING.Utils.isNull(n) || (t.angle = t.xRotateAngle,
                ht.a.earthCameraRotateOnXAxis(t)) : ht.a.flyRotatePoint(t)
            }
            if (void 0 !== t.isEarth && t.isEarth) {
                let n = t.object
                  , r = t.target
                  , a = t.yRotateAngle || t.angle;
                t.xRotateAngle,
                t.angle = a;
                let i = t.time
                  , o = t.speed;
                n && n.isBaseObject && (t.target = n.getOrientedBox().center),
                r && r.isBaseObject && (t.target = r.getOrientedBox().center),
                THING.Utils.isNull(i) ? o ? (t.time = 16777215,
                t.angle = void 0 === t.angle ? 36e11 : t.angle,
                t.time = o * t.angle * 10,
                e(t)) : a ? (t.speed = 0,
                t.time = 1e3,
                e(t)) : (t.speed = 1,
                t.time = 16777215,
                e(t)) : (t.speed = 0,
                t.loopType = THING.Utils.parseValue(t.loopType, THING.LoopType.No),
                e(t))
            } else
                super.rotate()
        }
        followObject(t) {
            if (void 0 !== t.isEarth && t.isEarth) {
                var e = super.followObject
                  , n = t.flying;
                t.flying = n ? function(t) {
                    n.call(this, t),
                    ht.a.correctUp()
                }
                : function(t) {
                    ht.a.correctUp()
                }
                ,
                e.call(this, t)
            } else
                super.followObject(t)
        }
    }
    ;
    class Rt {
        constructor(t) {
            this._enable = !1,
            this.app = t,
            this.compositorManager = t.rendererManager._mainRenderer,
            this.renderConfig = {
                name: "后处理状态",
                Glow: !1,
                SmallGlow: !1,
                LineBloom: !1,
                RectBlurEffect: !1,
                FocusRegion: !1,
                ColorAdjust: !0,
                SimpleBlur: !0,
                normalRender: !1
            },
            this.gpuMemory = {
                name: "显存占用/M",
                Glow: "0M",
                SmallGlow: "0M",
                LineBloom: "0M",
                RectBlurEffect: "0M",
                FocusRegion: "0M",
                ColorAdjust: "0M",
                SimpleBlur: "0M"
            },
            this.gpuTotal = {
                total: "0M"
            },
            this.renderMessage = {
                calls: 0,
                dirty: !1
            },
            this.layerConfig = {}
        }
        get enable() {
            return this._enable
        }
        set enable(t) {
            if (t) {
                var e = this;
                THING.Utils.dynamicLoadJS("https://thingjs.com/static/release/thing.widget.min.js", function() {
                    e.initPanel(),
                    e.panel.visible = !0
                })
            } else
                this.panel && (this.panel.visible = !1,
                this.app.removeControl("testDirty"),
                this.app.removeControl("earthDebugger"))
        }
        initPanel() {
            if (!this.panel) {
                this.panel = new THING.widget.Panel({
                    isDrag: !0,
                    hasTitle: !0,
                    name: "地球调试面板",
                    width: "480px"
                });
                var t = this.panel
                  , e = this.getTableName();
                t.addTab(e),
                this.initRenderPanel(),
                this.initGpuMemory(),
                t.setPosition(0, 180)
            }
        }
        getTableName() {
            for (var t = [this.renderConfig.name, this.gpuMemory.name], e = {}, n = 0; n < t.length; n++)
                e[t[n]] = {};
            return e
        }
        initRenderPanel() {
            var t = this
              , e = this.renderConfig.name;
            this._processRenderConfig();
            this.renderConfig;
            this.panel.add(this.renderConfig, "Glow").link(e).caption("Glow").on("change", function(e) {
                t.enableCompositor("Glow", e)
            }),
            this.panel.add(this.renderConfig, "SmallGlow").link(e).caption("SmallGlow").on("change", function(e) {
                t.enableCompositor("SmallGlow", e)
            }),
            this.panel.add(this.renderConfig, "LineBloom").link(e).caption("LineBloom").on("change", function(e) {
                t.enableCompositor("LineBloom", e)
            }),
            this.panel.add(this.renderConfig, "RectBlurEffect").link(e).caption("RectBlurEffect").on("change", function(e) {
                t.enableCompositor("RectBlurEffect", e)
            }),
            this.panel.add(this.renderConfig, "FocusRegion").link(e).caption("FocusRegion").on("change", function(e) {
                t.enableCompositor("FocusRegion", e)
            }),
            this.panel.add(this.renderConfig, "ColorAdjust").link(e).caption("ColorAdjust").on("change", function(e) {
                t.enableCompositor("ColorAdjust", e)
            }),
            this.panel.add(this.renderConfig, "SimpleBlur").link(e).caption("SimpleBlur").on("change", function(e) {
                t.enableCompositor("SimpleBlur", e)
            }),
            this.panel.add(this.renderConfig, "normalRender").link(e).caption("关闭所有后期").on("change", function(e) {
                t.enableCompositor("normalRender", e)
            }),
            this.app.addControl({
                onUpdate: ()=>{
                    this.renderMessage.calls = this.app.renderStates.calls
                }
            }, "earthDebugger"),
            this.panel.add(this.renderMessage, "calls").link(e).caption("drawCall"),
            this.panel.add(this.renderMessage, "dirty").link(e).caption("强制触发dirty测试").on("change", function(e) {
                t.processDirty(e)
            })
        }
        initGpuMemory() {
            let t = this.gpuMemory.name;
            this.panel.add(this.gpuTotal, "total").link(t);
            for (let e in this.gpuMemory)
                "name" !== e && this.panel.add(this.gpuMemory, e).link(t).caption(e);
            this.app.addControl({
                onUpdate: ()=>{
                    let t = 0;
                    for (let e in this.gpuMemory)
                        if ("name" !== e) {
                            let n = this.compositorManager.getCompositor(e);
                            if (n)
                                if (n.enable) {
                                    let r = n.getRenderTargetMemory();
                                    t += parseFloat(r.split("M")[0]),
                                    this.gpuMemory[e] = r
                                } else
                                    this.gpuMemory[e] = "0M"
                        }
                    t = t.toFixed(1),
                    t += "M",
                    this.gpuTotal.total = t
                }
            }, "earthMemoryDebugger")
        }
        processDirty(t) {
            t ? this.app.addControl({
                onUpdate: ()=>{
                    this.compositorManager.dirty()
                }
            }, "testDirty") : this.app.removeControl("testDirty")
        }
        _processRenderConfig() {
            for (var t in this.renderConfig)
                if ("name" !== t)
                    if ("normalRender" === t)
                        this.renderConfig[t] = !1;
                    else {
                        var e = this.compositorManager.getCompositor(t);
                        this.renderConfig[t] = e.enable
                    }
        }
        enableCompositor(t, e) {
            "normalRender" === t && (e ? this.compositorManager.changeToNormalRenderer() : this.compositorManager.changeToCompositorRenderer()),
            this.compositorManager.setCompositorEnabled("", "", t, e)
        }
    }
    var Dt = class {
        constructor(t, e) {
            this._object = t,
            this._postRadialBlur = this._postRadiusEffect = THING.Utils.parseValue(e.postRadialBlur, !1),
            this._postRadialBlur2 = THING.Utils.parseValue(e.postRadialBlur2, !1),
            this._effect = THING.Utils.parseValue(e.effect, !1),
            this._glowStrength = THING.Utils.parseValue(e.glowStrength, .5)
        }
        toObject() {
            return r.a._toObject(this)
        }
        get postRadialBlur() {
            return this._postRadialBlur
        }
        set postRadialBlur(t) {
            this._postRadialBlur = t,
            this._postRadiusEffect = t,
            this._object && this._object._setPostRadiusEffect && this._object._setPostRadiusEffect(t)
        }
        get postRadialBlur2() {
            return this._postRadialBlur2
        }
        set postRadialBlur2(t) {
            this._postRadialBlur2 = t,
            this._object && this._object._setPostRadialBlur2 && this._object._setPostRadialBlur2(t)
        }
        get postRadiusEffect() {
            return this._postRadiusEffect
        }
        set postRadiusEffect(t) {
            this.postRadialBlur = t
        }
        get effect() {
            return this._effect
        }
        set effect(t) {
            this._effect !== t && (this._effect = t,
            this._object && ("FeatureLayer" === this._object.type ? this._object.children.forEach(e=>{
                e.renderer.effect = t
            }
            ) : this._object._setEffect("glow", t, this._glowStrength)))
        }
        get glowStrength() {
            return this._glowStrength
        }
        set glowStrength(t) {
            this._glowStrength !== t && this._object && ("FeatureLayer" === this._object.type ? this._object.children.forEach(e=>{
                e.renderer.glowStrength = t
            }
            ) : this._object._setEffect("glow", this.effect, t)),
            this._glowStrength = t
        }
        _setFeatureLayerProperty(t, e, n, r) {
            "FeatureLayer" === this._object.type && (this._object.children.forEach(n=>{
                n.renderer[t] = e
            }
            ),
            this["_" + t] = n ? CMAP.Util.colorFormatNewToOld(e, r) : e)
        }
    }
    ;
    var jt = class extends Dt {
        constructor(t, e) {
            super(t, e),
            this._object = this._geoBuilding = t,
            this._type = THING.Utils.parseValue(e.type, "vector"),
            this._opacity = THING.Utils.parseValue(e.opacity, 1),
            e.color = THING.Utils.parseValue(e.color || [255, 255, 255]),
            this._color = CMAP.Util.colorFormatNewToOld(e.color, this._opacity) || [1, 1, 1, 1],
            this._opacity = this._color[3],
            this._colorMapping = e.colorMapping,
            this._extrudeField = e.extrudeField,
            this._extrudeFactor = THING.Utils.parseValue(e.extrudeFactor, 1),
            this._uvRatio = void 0 === e.uvRatio ? [1, 1] : e.uvRatio,
            this._object && "GeoBuilding" !== this._object.type ? this._textureSize = e.textureSize : this._textureSize = THING.Utils.parseValue(e.textureSize, M.a._defaultBuildingTextureSize),
            this._object && "GeoBuilding" === this._object.type && (this._textureWrap = e.textureWrap || "repeatY"),
            this._blending = void 0 !== e.blending && e.blending,
            this._useOutline = THING.Utils.parseValue(e.useOutline, !0),
            this._useBoundary = THING.Utils.parseValue(e.useBoundary, !1);
            let n = !1;
            this._object && "GeoBuilding" === this._object.type && "image" !== this._type && (n = !0),
            this._lights = THING.Utils.parseValue(e.lights, n);
            let r = !1;
            "cool" === this._type && (r = !0),
            this._useWindow = THING.Utils.parseValue(e.useWindow, r),
            this._setDefaultWindowParam(e),
            this._specularFactor = void 0 === e.specularFactor ? [1, 1] : e.specularFactor;
            let a = !0;
            "cool" === this._type && (a = !1),
            this._useAoMap = THING.Utils.parseValue(e.useAoMap, a);
            let i = .85;
            this._lights && (i = .6),
            this._aoMapIntensity = THING.Utils.parseValue(e.aoMapIntensity, i),
            this._aoMapUrl = e.aoMapUrl,
            this._imageUrl = e.imageUrl,
            this._speed = THING.Utils.parseValue(e.speed, [0, 0]),
            this._imageUrl && (Array.isArray(this._imageUrl) || (this._imageUrl = this._imageUrl.split(","))),
            "cool" === this._type && this._setDefaultCoolParam(e);
            let o = !1;
            "cool" === this._type && (o = !0),
            this._useColor = THING.Utils.parseValue(e.useColor, o),
            this._keepSpeed = THING.Utils.parseValue(e.keepSpeed, !1)
        }
        _setDefaultWindowParam(t) {
            this._windowTextureWrap = THING.Utils.parseValue(t.windowTextureWrap, "normal"),
            this._windowTextureSize = THING.Utils.parseValue(t.windowTextureSize, M.a._defaultWindowTextureSize),
            this._windowImageUrl = THING.Utils.parseValue(t.windowImageUrl, ""),
            this._windowBrightness = THING.Utils.parseValue(t.windowBrightness, 1),
            this._windowColor = void 0 === t.windowColor ? [1, 1, 1, 1] : CMAP.Util.colorFormatNewToOld(t.windowColor, 1),
            this._offset = THING.Utils.parseValue(t.offset, [0, 0]),
            this._repeat = THING.Utils.parseValue(t.repeat, [1, 1]),
            this._windowSpeed = THING.Utils.parseValue(t.windowSpeed, [0, 0])
        }
        _setDefaultCoolParam(t) {
            this._effect = THING.Utils.parseValue(t.effect, !1),
            this._envMapUrl = t.envMapUrl,
            this._envMapIntensity = THING.Utils.parseValue(t.envMapIntensity, [1, 1]),
            this.threshold = THING.Utils.parseValue(t.threshold, .8),
            this._glowStrength = THING.Utils.parseValue(t.glowStrength, .5),
            this._metalness = THING.Utils.parseValue(t.metalness, [.8, .2]),
            this._roughness = THING.Utils.parseValue(t.roughness, [0, .8])
        }
        get keepSpeed() {
            return this._keepSpeed
        }
        get speed() {
            return this._speed
        }
        set speed(t) {
            this._speed !== t && (this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("speed", t) : (this._speed = t,
            this._object.updateMaterial()))
        }
        get windowSpeed() {
            return this._windowSpeed
        }
        set windowSpeed(t) {
            this._windowSpeed !== t && (this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("windowSpeed", t) : (this._windowSpeed = t,
            this._object.updateMaterial()))
        }
        get useOutline() {
            return this._useOutline
        }
        set useOutline(t) {
            this._useOutline !== t && (this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("useOutline", t) : this._useOutline = t)
        }
        get useBoundary() {
            return this._useBoundary
        }
        set useBoundary(t) {
            this._useBoundary !== t && (this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("useBoundary", t) : this._useBoundary = t)
        }
        get useColor() {
            return this._useColor
        }
        set useColor(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("useColor", t) : (this._useColor = t,
            "vector" !== this._type && this._object.updateMaterial())
        }
        get useWindow() {
            return this._useWindow
        }
        set useWindow(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("useWindow", t) : (this._useWindow = t,
            this._object.updateMaterial())
        }
        get uvRatio() {
            return this._uvRatio
        }
        set uvRatio(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("uvRatio", t) : this._uvRatio !== t && (this._uvRatio = t,
            this._object.updateMaterial())
        }
        get type() {
            return this._type
        }
        set type(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("type", t) : this._type !== t && (this._type = t,
            "cool" === this._type ? (void 0 === this._useWindow && (this._useWindow = !0),
            this._setDefaultCoolParam(this),
            this._object && "GeoPolygon" === this._object.type && this._object._processPolygonRenderer()) : this._effect = !1,
            this._object._updateEffect(this._effect, this._glowStrength),
            this._object.updateMaterial())
        }
        get color() {
            return CMAP.Util.colorFormatOldToNew(this._color)
        }
        set color(t) {
            if (this._object && "FeatureLayer" === this._object.type)
                this._setFeatureLayerProperty("color", t, !0, this._opacity);
            else {
                var e = CMAP.Util.colorFormatNewToOld(t, this._opacity);
                "image" !== this._type || !0 === this._useColor ? JSON.stringify(e) !== JSON.stringify(this._color) && (Array.isArray(t) && 4 === t.length && (this._opacity = t[3]),
                this._color = e,
                this._object.updateMaterial()) : this._color = e
            }
        }
        get colorMapping() {
            return this._colorMapping
        }
        set colorMapping(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("colorMapping", t) : "vector" === this._type || "cool" === this._type ? JSON.stringify(t) !== JSON.stringify(this._colorMapping) && (this._colorMapping = t,
            this._object.updateMaterial()) : THING.Utils.warn("cannot set this property when type is image")
        }
        get opacity() {
            return this._opacity
        }
        set opacity(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("opacity", t) : t !== this._opacity && (this._opacity = t,
            this._color[3] = t,
            this._object.updateMaterial())
        }
        get imageUrl() {
            return this._imageUrl
        }
        set imageUrl(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("imageUrl", t) : "vector" !== this._type ? (Array.isArray(t) || (t = t.split(",")),
            1 === t.length && t.push(t[0]),
            JSON.stringify(t) !== JSON.stringify(this._imageUrl) && (this._imageUrl = t,
            this._object.updateMaterial())) : this._imageUrl = t
        }
        get aoMapIntensity() {
            return this._aoMapIntensity
        }
        get useAoMap() {
            return this._useAoMap
        }
        get aoMapUrl() {
            return this._aoMapUrl
        }
        set aoMapUrl(t) {
            this._aoMapUrl !== t && (this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("aoMapUrl", t) : (this._aoMapUrl = t,
            this._object.updateMaterial()))
        }
        get extrudeFactor() {
            return this._extrudeFactor
        }
        set extrudeFactor(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("extrudeFactor", t) : this._extrudeFactor !== t && (this._object.extrudeFactor = t,
            this._extrudeFactor = t)
        }
        get extrudeField() {
            return this._extrudeField
        }
        set extrudeField(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("extrudeField", t) : this._extrudeField !== t && (this._object.extrudeField = t,
            this._extrudeField = t)
        }
        get blending() {
            return this._blending
        }
        set blending(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("blending", t) : this._blending !== t && (this._blending = t,
            this._object.updateMaterial())
        }
        get specularFactor() {
            return this._specularFactor
        }
        set specularFactor(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("specularFactor", t) : this._specularFactor !== t && (this._specularFactor = t,
            this._object.updateMaterial())
        }
        get textureWrap() {
            return this._textureWrap
        }
        set textureWrap(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("textureWrap", t) : this._object && "GeoBuilding" === this._object.type && this._textureWrap !== t && (this._textureWrap = t,
            this._object.updateTextureWrap(t))
        }
        set windowColor(t) {
            if (this._object && "FeatureLayer" === this._object.type)
                this._setFeatureLayerProperty("windowColor", t, !0, 1);
            else {
                var e = CMAP.Util.colorFormatNewToOld(t, 1);
                JSON.stringify(e) !== JSON.stringify(this._windowColor) && (this._windowColor = e,
                this._object.updateMaterial())
            }
        }
        get windowColor() {
            return this._windowColor || (this._windowColor = [1, 1, 1]),
            CMAP.Util.colorFormatOldToNew(this._windowColor)
        }
        set windowTextureWrap(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("windowTextureWrap", t) : this._object && "GeoBuilding" === this._object.type && ("normal" === t || "around" === t ? (this._windowTextureWrap = t,
            this._object.updateMaterial()) : THING.Utils.warn("only around and normal can be used"))
        }
        get windowTextureWrap() {
            return this._windowTextureWrap
        }
        set windowBrightness(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("windowBrightness", t) : this._windowBrightness !== t && (this._windowBrightness = t,
            this._object.updateMaterial())
        }
        get windowBrightness() {
            return this._windowBrightness
        }
        set envMapIntensity(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("envMapIntensity", t) : ("cool" === this._type ? JSON.stringify(this._envMapIntensity) !== JSON.stringify(t) && (this._envMapIntensity = t,
            this._object.updateMaterial()) : THING.Utils.warn("cannot set this property when type is not cool"),
            this._envMapIntensity = t)
        }
        get envMapIntensity() {
            return this._envMapIntensity
        }
        set offset(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("offset", t) : JSON.stringify(this._offset) !== JSON.stringify(t) && (this._offset = t,
            this._object.updateMaterial())
        }
        get offset() {
            return this._offset
        }
        set repeat(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("repeat", t) : JSON.stringify(this._repeat) !== JSON.stringify(t) && (this._repeat = t,
            this._object.updateMaterial())
        }
        get repeat() {
            return this._repeat
        }
        set windowImageUrl(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("windowImageUrl", t) : this._windowImageUrl !== t ? (this._windowImageUrl = t,
            this._object.updateMaterial()) : this._windowImageUrl = t
        }
        get windowImageUrl() {
            return this._windowImageUrl
        }
        set envMapUrl(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("envMapUrl", t) : this._envMapUrl !== t ? (this._envMapUrl = t,
            this._object.updateMaterial()) : this._envMapUrl = t
        }
        get envMapUrl() {
            return this._envMapUrl
        }
        get effect() {
            return this._effect
        }
        set effect(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("effect", t) : (this._effect !== t && "cool" === this.type && this._object._updateEffect(t, this._glowStrength),
            this._effect = t)
        }
        get glowStrength() {
            return this._glowStrength
        }
        set glowStrength(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("glowStrength", t) : (this._glowStrength !== t && "cool" === this._type && this._object._updateEffect(this._effect, t),
            this._glowStrength = t)
        }
        get metalness() {
            return this._metalness
        }
        set metalness(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("metalness", t) : "cool" === this._type ? JSON.stringify(this._metalness) !== JSON.stringify(t) && (this._metalness = t,
            this._object.updateMaterial()) : (this._metalness = t,
            THING.Utils.warn("cannot set this property when type is not cool"))
        }
        get roughness() {
            return this._roughness
        }
        set roughness(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("roughness", t) : "cool" === this._type ? JSON.stringify(this._roughness) !== JSON.stringify(t) && (this._roughness = t,
            this._object.updateMaterial()) : (this._roughness = t,
            THING.Utils.warn("cannot set this property when type is not cool"))
        }
        get lights() {
            return this._lights
        }
        set lights(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("lights", t) : this._lights !== t && (this._lights = t,
            this._object.updateMaterial())
        }
        get textureSize() {
            return this._textureSize
        }
        set textureSize(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("textureSize", t) : JSON.stringify(this._textureSize) !== JSON.stringify(t) && (Array.isArray(t) && 2 === t.length ? (this._object && "GeoBuilding" === this._object.type ? this._object._updateBuildingTextureSize(t) : this._object && "GeoPolygon" === this._object.type && this._object._updateMeshUV(this._textureSize, t),
            this._textureSize = t) : THING.Utils.warn("illegal textureSize; array is required"))
        }
        get windowTextureSize() {
            return this._windowTextureSize
        }
        set windowTextureSize(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("windowTextureSize", t) : this._object && "GeoBuilding" === this._object.type && (this._object._updateBuildingWindowTexture(t, this._windowTextureSize),
            this._windowTextureSize = t)
        }
    }
      , Lt = new Map
      , It = new THREE.TextureLoader
      , Ot = new THREE.CubeTextureLoader;
    const kt = "\n        #include <common>\n\n        attribute vec2 uv2;\n\n        #if MAP1 > 0\n            uniform mat3 map1UvTransform;\n            varying vec2 vMap1Uv;\n        #endif\n\n        #if MAP2 > 0\n            uniform mat3 map2UvTransform;\n            varying vec2 vMap2Uv;\n        #endif\n\n        #if ALPHAMAP > 0\n            uniform mat3 alphaMapUvTransform;\n            varying vec2 vAlphaMapUv;\n        #endif\n\n        #include <fog_pars_vertex>\n        #include <logdepthbuf_pars_vertex>\n\n        void main() {\n            #if MAP1 == 1\n                vMap1Uv = (map1UvTransform * vec3(uv, 1.)).xy;\n            #elif MAP1 == 2\n                vMap1Uv = (map1UvTransform * vec3(uv2, 1.)).xy;\n            #endif\n\n            #if MAP2 == 1\n                vMap2Uv = (map2UvTransform * vec3(uv, 1.)).xy;\n            #elif MAP2 == 2\n                vMap2Uv = (map2UvTransform * vec3(uv2, 1.)).xy;\n            #endif\n\n            #if ALPHAMAP == 1\n                vAlphaMapUv = (alphaMapUvTransform * vec3(uv, 1.)).xy;\n            #elif ALPHAMAP == 2\n                vAlphaMapUv = (alphaMapUvTransform * vec3(uv2, 1.)).xy;\n            #endif\n\n            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n            gl_Position = projectionMatrix * mvPosition;\n\n            #include <fog_vertex>\n            #include <logdepthbuf_vertex>\n        }\n    "
      , Ht = "\n        uniform vec3 color;\n        uniform float opacity;\n        uniform float strength;\n\n        #if MAP1 > 0\n            uniform sampler2D map1;\n            varying vec2 vMap1Uv;\n        #endif\n        \n        #if MAP1 > 0\n            uniform sampler2D map2;\n            varying vec2 vMap2Uv;\n        #endif\n\n        #if ALPHAMAP > 0\n            uniform sampler2D alphaMap;\n            varying vec2 vAlphaMapUv;\n        #endif\n\n        #include <fog_pars_fragment>\n        #include <logdepthbuf_pars_fragment>\n\n        void main() {\n            vec4 result = vec4(color, opacity);\n\n            vec4 texel1 = result.xyzw;\n            #if MAP1 > 0\n                texel1 *= texture2D(map1, vMap1Uv);\n            #endif\n\n            vec4 texel2 = result.xyzw;\n            #if MAP1 > 0\n                texel2 *= texture2D(map2, vMap2Uv);\n            #endif\n\n            #if BLEND_TYPE == 1\n                result.rgb = texel2.rgb * texel2.a + texel1.rgb * (1. - texel2.a);\n                result.a = texel2.a + texel1.a;\n            #elif BLEND_TYPE == 2\n                result.rgb = texel2.rgb * texel2.a + texel1.rgb;\n                result.a = texel1.a;\n            #else\n                result = texel1;\n            #endif\n\n            #if ALPHAMAP > 0\n                result.a *= texture2D(alphaMap, vAlphaMapUv).g;\n            #endif\n\n            gl_FragColor = result;\n            gl_FragColor *= strength;\n            #include <logdepthbuf_fragment>\n            #include <fog_fragment>\n\n        }\n    ";
    class Ft extends THREE.ShaderMaterial {
        constructor() {
            super({
                defines: {
                    MAP1: 1,
                    MAP2: 1,
                    ALPHAMAP: 0,
                    BLEND_TYPE: 1
                },
                uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.fog, {
                    color: {
                        value: new THREE.Color(1,1,1)
                    },
                    opacity: {
                        value: 1
                    },
                    strength: {
                        value: 1
                    },
                    map1: {
                        value: null
                    },
                    map2: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    map1UvTransform: {
                        value: new THREE.Matrix3
                    },
                    map2UvTransform: {
                        value: new THREE.Matrix3
                    },
                    alphaMapUvTransform: {
                        value: new THREE.Matrix3
                    }
                }]),
                vertexShader: kt,
                fragmentShader: Ht
            })
        }
    }
    var Bt = {
        _processOpacity(t) {
            let e = void 0 === t.opacity ? 1 : t.opacity
              , n = t.color;
            return Array.isArray(n) || (n = CMAP.Util.colorFormatNewToOld(n, e)),
            n
        },
        _createPolygonFillMaterialName(t) {
            return this._createBuildingMaterialName(t)
        },
        _createLineMaterialName(t) {
            let e = this._processOpacity(t)
              , n = JSON.stringify(e) + "_" + t.type + "_" + t.lineType + "_" + t.width + "_" + t.imageUrl + "_";
            return n += t.speed + "__" + t.growSpeed + "_" + t.effect + "_" + JSON.stringify(t.uvRatio),
            n += "_" + t.blending + "_" + JSON.stringify(t.colorMapping) + "_" + t.sizeAttenuation,
            "image" === t.type && (n += "_" + t.useColor),
            "lineMaterial_" + n
        },
        _createWaterMaterialName(t) {
            let e = this._processOpacity(t);
            return "waterMaterial_" + (JSON.stringify(e) + "_" + t.opacity + "_" + t.flowX + "_" + t.flowY + "_" + t.flowSpeed + "_" + t.scale + "_" + t.lights + "_" + t.normalMap0 + "_" + t.normalMap1 + "_" + t.tReflectionMap + "_" + t.tRefractionMap)
        },
        _createBuildingMaterialName(t) {
            let e = this._processOpacity(t);
            e || (e = [255, 255, 255]);
            let n = t.imageUrl + "_" + t.speed + "_" + JSON.stringify(e) + "_" + t.lights + "_" + t.type + "_" + t.blending + "_" + t.aoMap + "_" + t.depthWrite + "_" + t.colorMapping + "_" + t.side;
            return n += "_" + JSON.stringify(t.colorMapping) + "_" + t.opacity + "_" + t.useAoMap + "_" + t.aoMapIntensity + "_" + t.aoMapUrl + "_" + JSON.stringify(t.uvRatio),
            n += "_" + t.useWindow + "_" + t.windowImageUrl + "_" + t.windowTextureWrap + "_" + t.windowBrightness + "_" + JSON.stringify(t.windowColor) + "_" + JSON.stringify(t.repeat) + "_" + JSON.stringify(t.offset) + "_" + t.windowSpeed + "_" + JSON.stringify(t.specularFactor),
            "cool" === t.type && (n += "_" + t.envMapUrl + "_" + JSON.stringify(t.envMapIntensity) + "_" + JSON.stringify(t.roughness) + "_" + JSON.stringify(t.metalness)),
            "vector" !== t.type && (n += "_" + t.useColor),
            "polygonMaterial_" + n
        },
        createBoundaryMaterialName(t) {
            let e = t.imageUrl + "_" + t.opacity + "_" + t.useColor + "_" + t.color + "_" + t.uvRatio;
            return "boundaryMaterial_" + (e += "_" + t.blending + "_" + t.speed + "_" + t.useAlphaMap + "_" + t.alphaImageUrl + "_" + t.alphaSpeed)
        },
        _createAllMaterial(t, e) {
            var n = [];
            for (let r in t) {
                let a = t[r];
                if (Array.isArray(a) && void 0 !== a[0].condition)
                    for (let i in a) {
                        let o = JSON.parse(JSON.stringify(t));
                        o[r] = a[i].value,
                        o = new jt(void 0,o);
                        let s = this._createMaterial(e, o.toObject());
                        n.push(s)
                    }
            }
            if (0 === n.length) {
                t = new jt(void 0,t);
                let r = this._createMaterial(e, t.toObject());
                n.push(r)
            }
            return n
        },
        _createMaterial: function(t, e) {
            let n;
            return t.contains("Line") ? n = this.createLineMaterial(e) : t.contains("Building") && (n = this.createBuildingMaterial(e)),
            n
        },
        createWaterMatrial: function(t) {
            let e = this._createWaterMaterialName(t)
              , n = t3djs.materialManager.getMaterial(e);
            if (!n) {
                let r = (n = t3djs.util.createWater3Material(e, t)).getTechnique(0).getPass(0).material;
                t.lights || (r.lights = !1,
                r.defines.USE_LIGHT = !1,
                r.needsUpdate = !0),
                r.depthWrite = !1
            }
            return this._addRefCount(n.getMaterial()[0]),
            n
        },
        _getOldColor: t=>void 0 !== t._color ? t._color : CMAP.Util.colorFormatNewToOld(t.color, t.opacity),
        createBoundaryMaterial: function(t) {
            let e = this.createBoundaryMaterialName(t)
              , n = t3djs.materialManager.getMaterial(e);
            var r = !1;
            if (n ? (t.imageUrl || t.colorMapping) && (n.map || (r = !0)) : r = !0,
            r) {
                (n = new Ft).side = THREE.DoubleSide,
                n.depthWrite = !1;
                const r = (new THREE.TextureLoader).load(t.imageUrl[0]);
                if (r.wrapS = r.wrapT = THREE.RepeatWrapping,
                n.uniforms.map1UvTransform.value.scale(t.uvRatio[0][0], t.uvRatio[0][1]),
                n.uniforms.map1.value = r,
                2 === t.imageUrl.length) {
                    const e = (new THREE.TextureLoader).load(t.imageUrl[1]);
                    e.wrapS = e.wrapT = THREE.RepeatWrapping,
                    n.uniforms.map2UvTransform.value.scale(t.uvRatio[1][0], t.uvRatio[1][1]),
                    n.uniforms.map2.value = e
                }
                if (t.useColor && (n.uniforms.color.value = new THREE.Color(t.color[0],t.color[1],t.color[2])),
                n.defines.BLEND_TYPE = 1,
                n.blending = t.blending ? THREE.AdditiveBlending : THREE.NormalBlending,
                n.uniforms.opacity.value = t.opacity,
                n.transparent = !0,
                t.useAlphaMap && t.alphaImageUrl) {
                    const e = (new THREE.TextureLoader).load(t.alphaImageUrl);
                    e.wrapS = e.wrapT = THREE.ClampToEdgeWrapping,
                    n.defines.ALPHAMAP = 1,
                    n.uniforms.alphaMap.value = e,
                    e.material = n,
                    e.uniformTag = "alphaMap",
                    t.alphaSpeed && (0 === t.alphaSpeed[0] && 0 === t.alphaSpeed[1] || (e.wrapT = THREE.RepeatWrapping,
                    e.wrapS = THREE.RepeatWrapping,
                    0 === t.alphaSpeed[1] && (e.wrapT = THREE.ClampToEdgeWrapping)),
                    this._alphaUpdaterName = "updateBoundaryAlphaMap_" + e.uuid,
                    Bt._setTextureScrollAnimation(e, t.alphaSpeed, this._alphaUpdaterName, .001, null, t.keepSpeed))
                }
                if (t.speed)
                    for (let e = 0; e < t.speed.length; e++) {
                        const r = n.uniforms["map" + (e + 1)].value;
                        r.material = n,
                        r.uniformTag = "map" + (e + 1),
                        this._imageUpdaterName = "updateBoundaryMap_" + r.uuid,
                        Bt._setTextureScrollAnimation(r, t.speed[e], this._imageUpdaterName, .05, null, t.keepSpeed)
                    }
                n.name = e,
                t3djs.buffer.materialBuffer.add(e, n)
            }
            return Bt._addRefCount(n),
            n
        },
        createLineMaterial: function(t) {
            let e = this._createLineMaterialName(t)
              , n = t3djs.materialManager.getMaterial(e)
              , a = !1;
            if (n ? ("image" === t.type || "vector" === t.type && t.colorMapping) && ("Plane" === t.lineType ? n.uniforms.map.value || (a = !0) : n.map || (a = !0)) : a = !0,
            a) {
                var i = "MeshBasicMaterial";
                "Plane" === t.lineType && (i = "MeshLineMaterial");
                var o = t3djs.materialManager.createMaterial(e, i).getTechnique(0).getPass(0);
                if (n = o.material,
                "Plane" === t.lineType && t.sizeAttenuation && (n.uniforms.sizeAttenuation = {
                    type: "f",
                    value: 1
                }),
                "image" === t.type)
                    if (void 0 !== t.imageUrl) {
                        if (o.setPolygonOffset(0, -100),
                        t.useColor) {
                            let e = this._getOldColor(t);
                            o.setDiffuse(e || [1, 1, 1, 1])
                        } else
                            o.setDiffuse([1, 1, 1, t.opacity]);
                        void 0 === t.uvRatio && (t.uvRatio = [1, 1]);
                        var s = o.createTextureUnitState()
                          , l = new THREE.TextureLoader;
                        "Plane" !== t.lineType ? o.material.map = l.load(t.imageUrl, function(e) {
                            s.setTexture(e),
                            s.setTextureAnisotropy(16),
                            e.wrapS = e.wrapT = THREE.RepeatWrapping,
                            THING.App.current.rendererManager._mainRenderer.dirty("LineBloom"),
                            0 !== t.speed && s.setScrollAnimation(t.speed, 0, s.material.uuid, t.keepSpeed),
                            e.repeat.set(t.uvRatio[0], t.uvRatio[1])
                        }) : (n.uniforms.useMap.value = 1,
                        n.uniforms.map.value = l.load(t.imageUrl, function(e) {
                            s.setTexture(e),
                            s.setTextureAnisotropy(16),
                            e.wrapS = e.wrapT = THREE.RepeatWrapping,
                            THING.App.current.rendererManager._mainRenderer.dirty("LineBloom"),
                            0 !== t.speed && s.setScrollAnimation(t.speed, 0, s.material.uuid, t.keepSpeed)
                        }),
                        n.uniforms.lineWidth.value = t.width,
                        n.uniforms.repeat.value.set(t.uvRatio[0], t.uvRatio[1]))
                    } else
                        THING.Utils.warn("请设置线样式的imageUrl属性");
                else if ("vector" === t.type)
                    if (t.colorMapping) {
                        let e = void 0 === t.opacity ? 1 : t.opacity;
                        o.setDiffuse([1, 1, 1, e]);
                        let n = this.getGradientMap(t._colorMapping, !1, !1);
                        void 0 === t.uvRatio && (t.uvRatio = [1, 1]);
                        var u = n.clone();
                        let r = o.createTextureUnitState();
                        r.setTexture(u),
                        r.setTextureAnisotropy(16),
                        u.wrapS = u.wrapT = THREE.RepeatWrapping,
                        "Plane" === t.lineType && (o.material.uniforms.useMap.value = 1,
                        o.material.uniforms.map.value = n,
                        o.material.uniforms.lineWidth.value = t.width),
                        o.material.map.repeat.set(t.uvRatio[0], t.uvRatio[1]),
                        THING.App.current.rendererManager._mainRenderer.dirty("LineBloom"),
                        0 !== t.speed && r.setScrollAnimation(t.speed, 0, r.material.uuid, t.keepSpeed)
                    } else {
                        var c = this._getOldColor(t);
                        o.setDiffuse(c || [1, 1, 1, 1]),
                        "Plane" === t.lineType && (n.uniforms.lineWidth.value = t.width),
                        4 === c.length && o.setOpacity(void 0 === c[3] ? 1 : c[3])
                    }
                if ("Plane" === t.lineType) {
                    n.uniforms.useAlphaMap.value = 0;
                    var h = r.a._generateHalfTexture();
                    n.uniforms.alphaMap.value = h,
                    h.wrapS = h.wrapT = THREE.RepeatWrapping,
                    h.repeat.set(.5, 1)
                } else
                    n.defines || (n.defines = {}),
                    n.defines.USE_ALPHA_UV2 = !0;
                t.blending ? n.blending = THREE.AdditiveBlending : n.blending = THREE.NormalBlending,
                n.depthWrite = !1,
                t3djs.buffer.materialBuffer.add(e, n)
            }
            return this._addRefCount(n),
            n
        },
        getAoMap(t) {
            t = t || "side";
            const e = new Uint8Array(512);
            var n = t3djs.buffer.textureBuffer.get("_defaultAoMap_" + t);
            if (!n)
                if ("top" === t) {
                    for (let t = 0; t < 128; t++)
                        e[4 * t] = 255,
                        e[4 * t + 1] = 255,
                        e[4 * t + 2] = 255,
                        e[4 * t + 3] = 255;
                    (n = new THREE.DataTexture(e,1,128,THREE.RGBAFormat)).needsUpdate = !0,
                    t3djs.buffer.textureBuffer.add("_defaultAoMap_" + t, n)
                } else if ("side" === t) {
                    for (let t = 0; t < 128; t++)
                        e[4 * t] = t / 128 * 255,
                        e[4 * t + 1] = 255,
                        e[4 * t + 2] = 255,
                        e[4 * t + 3] = 255;
                    (n = new THREE.DataTexture(e,1,128,THREE.RGBAFormat)).needsUpdate = !0,
                    t3djs.buffer.textureBuffer.add("_defaultAoMap_" + t, n)
                }
            return n
        },
        loadTexture(t, e, n=!0) {
            if (!t)
                return null;
            if ("string" != typeof t)
                return null;
            var r = t3djs.buffer.textureBuffer.get(t);
            return r ? r.clone() : r = It.load(t, function(t) {
                return n && (t.wrapS = THREE.RepeatWrapping,
                t.wrapT = THREE.RepeatWrapping),
                t.anisotropy = 16,
                t.needsUpdate = !0,
                t = t.clone(),
                e && "function" == typeof e && e(t),
                t
            })
        },
        loadEnvMap(t) {
            return this.isEquirecEnvMap(t) ? this.loadEnvMapEquirec(t) : this.loadEnvMapCube(t)
        },
        loadEnvMapCube(t) {
            var e;
            if (Lt.get(t))
                e = Lt.get(t);
            else {
                var n = t;
                e = Ot.load([n + "up.jpg", n + "rt.jpg", n + "lf.jpg", n + "fr.jpg", n + "dn.jpg", n + "bk.jpg"]),
                Lt.set(t, e)
            }
            return e
        },
        loadEnvMapCubeForCampus(t) {
            var e;
            if (Lt.get(t))
                e = Lt.get(t);
            else {
                var n = t;
                e = Ot.load([n + "lf.jpg", n + "rt.jpg", n + "up.jpg", n + "dn.jpg", n + "bk.jpg", n + "fr.jpg"]),
                Lt.set(t, e)
            }
            return e
        },
        loadEnvMapEquirec(t) {
            var e;
            return Lt.get(t) ? e = Lt.get(t) : ((e = It.load(t)).mapping = THREE.EquirectangularReflectionMapping,
            e.magFilter = THREE.LinearFilter,
            e.minFilter = THREE.LinearMipMapLinearFilter,
            e.encoding = THREE.sRGBEncoding,
            Lt.set(t, e)),
            e
        },
        isEquirecEnvMap: t=>-1 !== t.indexOf(".png") || -1 !== t.indexOf(".jpg") || -1 !== t.indexOf(".hdr"),
        getGradientMap(t, e, n) {
            var a = JSON.stringify(t)
              , i = Lt.get(a);
            if (e = void 0 !== e && e,
            n = void 0 === n || n,
            !i)
                try {
                    var o = []
                      , s = [];
                    for (var l in t)
                        o.push(l),
                        s.push(t[l]);
                    (i = r.a._generateGradientTextureByGray(o, s, e, n)).wrapS = i.wrapT = THREE.RepeatWrapping,
                    i.generateMipmaps = !0,
                    i.anisotropy = 16,
                    Lt.set(a, i)
                } catch (t) {
                    console.error("请检查colorMapping格式是否正确")
                }
            return i
        },
        _createFillMaterial(t) {
            let e = "MeshStandardMaterial";
            t.lights || (e = "MeshBasicMaterial");
            let n = new THREE[e]({
                color: new THREE.Color(1,1,1),
                transparent: !0,
                opacity: t.opacity
            });
            if (t.aoMap) {
                let e = null;
                (e = t.aoMapUrl && "top" !== t.aoType ? this.loadTexture(t.aoMapUrl, null, !1) : Bt.getAoMap(t.aoType)).wrapS = e.wrapT = THREE.ClampToEdgeWrapping,
                n.aoMap = e,
                n.aoMap.needsUpdate = !0,
                void 0 !== t.aoMapIntensity && (n.aoMapIntensity = t.aoMapIntensity)
            }
            if (void 0 !== t.side && (n.side = t.side),
            !1 === t.depthWrite && (n.depthWrite = !1),
            t.color && (n.color = new THREE.Color(t.color[0],t.color[1],t.color[2])),
            t.imageUrl && (n.map = this.loadTexture(t.imageUrl),
            t.uvRatio && n.map.repeat.set(t.uvRatio[0], t.uvRatio[1])),
            void 0 !== t.roughness && (n.roughness = t.roughness),
            void 0 !== t.metalness && (n.metalness = t.metalness),
            void 0 !== t.refractionRatio && (n.refractionRatio = t.refractionRatio),
            t.useWindow && t.windowImageUrl && (n.emissiveMap = this.loadTexture(t.windowImageUrl),
            n.emissiveMap && (n.emissiveIntensity = THING.Utils.parseValue(t.windowBrightness, 1),
            void 0 === t.windowColor && (t.windowColor = [1, 1, 1]),
            n.emissive = new THREE.Color(t.windowColor[0],t.windowColor[1],t.windowColor[2]),
            t.offset || (t.offset = [0, 0]),
            n.emissiveMap.offset.x = t.offset[0],
            n.emissiveMap.offset.y = t.offset[1],
            t.repeat || (t.repeat = [1, 1]),
            n.emissiveMap.repeat.x = t.repeat[0],
            n.emissiveMap.repeat.y = t.repeat[1],
            n.defines || (n.defines = {}),
            n.defines.USE_EMISSIVETRANSFORM = !0,
            "around" === t.windowTextureWrap && (n.defines.USE_EMISSIVE_AROUND_UV = !0),
            n.emissiveMap && t.windowSpeed))) {
                const e = "updateEmissiveMap_" + n.emissiveMap.uuid;
                this._setTextureScrollAnimation(n.emissiveMap, t.windowSpeed, e, void 0, t.offset, t.keepSpeed)
            }
            if (t.envMapUrl) {
                var r = this.loadEnvMap(t.envMapUrl);
                n.envMap = r,
                n.envMapIntensity = t.envMapIntensity
            }
            if (void 0 !== t.specularFactor && (n.specularFactor = t.specularFactor),
            t.colorMapping) {
                let e = this.getGradientMap(t.colorMapping);
                n.map = e,
                n.color = new THREE.Color(1,1,1),
                n.opacity = 1
            }
            if (t.blending && (n.depthWrite = !1,
            n.blending = THREE.AdditiveBlending),
            void 0 !== t.quaternion && (n.baseQuaternion = t.quaternion),
            n.map && t.speed) {
                const e = "updatePolygonMap_" + n.map.uuid;
                this._setTextureScrollAnimation(n.map, t.speed, e, void 0, void 0, t.keepSpeed)
            }
            return n.needsUpdate = !0,
            n
        },
        _getRendererItem(t, e) {
            let n = JSON.parse(JSON.stringify(t));
            for (let r in n)
                Array.isArray(n[r]) && 2 === n[r].length && (n[r] = t[r][e]);
            return n
        },
        _getMaterialParam(t, e, n) {
            t[e] && Array.isArray(t[e]) && (t[e] = t[e][n])
        },
        _setTextureScrollAnimation(t, e, n, a=.02, i, o=!1) {
            const s = THING.App.current;
            e && Array.isArray(e) && 2 === e.length && (0 !== e[0] || 0 !== e[1] ? (n || (n = "updater_" + r.a.getUUID()),
            C.a.add(n, function() {
                return function(e, n) {
                    let r = a;
                    if (o && (r = s.deltaTime / 16.667 * a),
                    t.material && "ShaderMaterial" === t.material.type) {
                        const a = t.uniformTag;
                        t.material.uniforms[a + "UvTransform"].value.translate(r * e, -r * n)
                    } else
                        t.offset.x += r * e,
                        t.offset.y -= r * n
                }(e[0], e[1])
            }),
            t._updaterName = n) : (C.a.delete(n),
            i = THING.Utils.parseValue(i, [0, 0]),
            t.offset.x = i[0],
            t.offset.y = i[1]))
        },
        _processPolygonMaterialParam(t) {
            "cool" !== t.type && ("vector" === t.type ? (delete t.imageUrl,
            delete t.envMapUrl) : "image" === t.type && (delete t.envMapUrl,
            delete t.colorMapping),
            t.lights && (t.roughness = .5,
            t.metalness = .5)),
            ("image" === t.type || "cool" === t.type && t.imageUrl) && !1 === t.useColor && (t.color = [1, 1, 1])
        },
        createPolygonMaterial(t, e, n) {
            Array.isArray(t.imageUrl) && 1 === t.imageUrl.length && (t.imageUrl = [t.imageUrl[0], t.imageUrl[0]]),
            this._processPolygonMaterialParam(t),
            t.side = THREE.FrontSide;
            let r = JSON.parse(JSON.stringify(t));
            n && (t.quaternion = n,
            r.quaternion = n),
            Bt._getMaterialParam(t, "imageUrl", 0),
            Bt._getMaterialParam(t, "specularFactor", 0),
            "cool" === t.type && (Bt._createDefaultBuildingRenderer(t),
            Bt._getMaterialParam(t, "envMapIntensity", 0),
            Bt._getMaterialParam(t, "metalness", 0),
            Bt._getMaterialParam(t, "roughness", 0),
            t.color || (t.color = [.0549019686, .1176470742, .342352954]),
            delete t.colorMapping,
            t.lights = !0),
            t.useWindow = !1,
            delete t.colorMapping,
            t.depthWrite = 0 !== e,
            t.aoMap = !1;
            let a = Bt.createPolygonFillMaterial(t);
            return Bt._getMaterialParam(r, "imageUrl", 1),
            Bt._getMaterialParam(r, "specularFactor", 1),
            "cool" === r.type && (Bt._createDefaultBuildingRenderer(r),
            Bt._getMaterialParam(r, "envMapIntensity", 1),
            Bt._getMaterialParam(r, "metalness", 1),
            Bt._getMaterialParam(r, "roughness", 1),
            r.color || (r.color = [.0274509843, .0588235371, .171176477]),
            r.lights = !0),
            r.useAoMap && (r.aoMap = !0),
            r.colorMapping && (r.aoMap = !1),
            [a, Bt.createPolygonFillMaterial(r)]
        },
        createBuildingMaterial(t) {
            void 0 === t.side && (t.side = THREE.BackSide),
            Array.isArray(t.imageUrl) && 1 === t.imageUrl.length && (t.imageUrl = [t.imageUrl[0], t.imageUrl[0]]),
            "vector" === t.type ? (delete t.imageUrl,
            delete t.envMapUrl,
            t.lights && (t.roughness = 1),
            t.lights && (t.metalness = 0)) : "image" === t.type && (delete t.envMapUrl,
            delete t.colorMapping,
            t.lights && (t.roughness = .5),
            t.lights && (t.metalness = .5)),
            ("image" === t.type || "cool" === t.type && t.imageUrl) && !1 === t.useColor && (t.color = [1, 1, 1]),
            t.useAoMap && (t.aoMap = !0),
            t.colorMapping && (t.aoMap = !1);
            let e = JSON.parse(JSON.stringify(t));
            e.quaternion = t.quaternion,
            Bt._getMaterialParam(t, "imageUrl", 0),
            Bt._getMaterialParam(t, "specularFactor", 0),
            "vector" === t.type || "cool" === t.type && !t.imageUrl ? t.useAoMap && (t.aoMapIntensity = 1,
            t.aoType = "top") : t.aoMap = !1,
            "cool" === t.type && (Bt._createDefaultBuildingRenderer(t),
            Bt._getMaterialParam(t, "envMapIntensity", 0),
            Bt._getMaterialParam(t, "metalness", 0),
            Bt._getMaterialParam(t, "roughness", 0),
            t.color || (t.color = [.0549019686, .1176470742, .342352954]),
            delete t.windowTextureWrap,
            delete t.colorMapping,
            t.lights = !0),
            delete t.windowImageUrl,
            delete t.colorMapping,
            delete t.speed;
            let n = Bt.createPolygonFillMaterial(t);
            return Bt._getMaterialParam(e, "imageUrl", 1),
            Bt._getMaterialParam(e, "specularFactor", 1),
            "cool" === e.type && (Bt._createDefaultBuildingRenderer(e),
            Bt._getMaterialParam(e, "envMapIntensity", 1),
            Bt._getMaterialParam(e, "metalness", 1),
            Bt._getMaterialParam(e, "roughness", 1),
            e.color || (e.color = [.0274509843, .0588235371, .171176477]),
            e.lights = !0),
            [n, Bt.createPolygonFillMaterial(e)]
        },
        _createDefaultBuildingRenderer: t=>(void 0 === t.envMapIntensity && (t.envMapIntensity = 1),
        void 0 === t.windowColor && (t.windowColor = [1, 1, 1, 1]),
        void 0 === t.offset && (t.offset = [1, 1]),
        void 0 === t.repeat && (t.repeat = [1, 1]),
        void 0 === t.windowBrightness && (t.windowBrightness = 1),
        void 0 === t.threshold && (t.threshold = .8),
        void 0 === t.effect && (t.effect = !0),
        void 0 === t.metalness && (t.metalness = [.8, .2]),
        void 0 === t.roughness && (t.roughness = [0, .8]),
        t),
        _setPolygonOffset(t, e, n, r) {
            r = void 0 === r || r,
            e = THING.Utils.parseValue(e, 0),
            n = THING.Utils.parseValue(n, 0),
            t.polygonOffset = r,
            t.polygonOffsetFactor = e,
            t.polygonOffsetUnits = n
        },
        _addRefCount(t) {
            t && (void 0 === t.refCount && (t.refCount = 0),
            t.refCount++);
            for (let e = 0; e < t.getTextures().length; e++) {
                let n = t.getTextures()[e];
                n && (void 0 === n.refCount && (n.refCount = 0),
                n.refCount++)
            }
        },
        createPolygonFillMaterial(t) {
            let e = this._createPolygonFillMaterialName(t);
            var n = t3djs.materialManager.getMaterial(e)
              , r = !1;
            return n ? (t.imageUrl || t.colorMapping) && (!n.map || n.map && n.map._updaterName) && (r = !0) : r = !0,
            r && ((n = this._createFillMaterial(t)).name = e,
            t3djs.buffer.materialBuffer.add(e, n)),
            this._addRefCount(n),
            n
        }
    }
      , Ut = Bt
      , Nt = {
        app: null,
        map: null,
        earthEffectVisibleLevel: [0, 4],
        _loadCurrentConfigFromMultiLevelConfig(t, e) {
            for (let n in t)
                if (t[n].background) {
                    let r = t[n].background.level;
                    if (this.map.currentLevel < r[1] && this.map.currentLevel >= r[0]) {
                        let r = {
                            resourcePrefix: t[n].resourcePrefix,
                            background: t[n].background.value
                        };
                        e.call(this, r, !1)
                    }
                } else {
                    let r = t[n].level;
                    this.map.currentLevel < r[1] && this.map.currentLevel >= r[0] && e.call(this, t[n].value, !1)
                }
        },
        _removeCloud() {
            this.app.query("__cloudImageLayer__")[0] && this.map.userLayers.remove(this.app.query("__cloudImageLayer__")[0])
        },
        _loadCloud(t, e) {
            let n = this.app.create({
                type: "ImageLayer",
                name: "__cloudImageLayer__",
                url: r.a._combinePrefixAndLocalUrl(e, t.url),
                useMercatorUV: !1,
                offsetHeight: 1e5,
                extent: {
                    minX: -180,
                    maxX: 180,
                    minY: -90,
                    maxY: 90
                },
                renderer: {
                    opacity: 1,
                    lights: !1,
                    grayFilterEnable: !1
                }
            });
            return n.on("update", function() {
                n.rotateY(.01)
            }),
            this.map.addLayer(n),
            n
        },
        _getDirectionFromAngles(t, e, n) {
            let r = new THREE.Vector3(1,0,0);
            return r.applyAxisAngle(new THREE.Vector3(0,0,1), n * Math.PI / 180),
            r.applyAxisAngle(new THREE.Vector3(1,0,0), t * Math.PI / 180),
            r.applyAxisAngle(new THREE.Vector3(0,1,0), e * Math.PI / 180),
            r.toArray()
        },
        _loadOverlay(t) {
            let e = t.overlay;
            if (e.gradient && e.gradient.gradientColorOverlayEnable && (this.map.style.gradientColorOverlayEnable = !0,
            this.map.style.gradientColorBar = e.gradient.gradientColorBar,
            this.map.style.gradientColorPerBar = e.gradient.gradientColorPerBar,
            this.map.style.gradientMapDirection = e.gradient.gradientMapDirection),
            e.cloud && e.cloud.visible) {
                this._loadCloud(e.cloud, t.resourcePrefix).userData.__isOverlay__ = !0
            }
            if (e.vectorEarth)
                for (let n = 0; n < e.vectorEarth.length; n++)
                    e.vectorEarth[n].__isOverlay__ = !0,
                    "BigPointLayer" === e.vectorEarth[n].type && (e.vectorEarth[n].layerConfig.depthTest = !0),
                    e.vectorEarth[n].renderOrder -= 100,
                    t.layers.push(e.vectorEarth[n]);
            if (e.particle) {
                e.resourcePrefix = t.resourcePrefix;
                const n = Nt._loadParticle(e);
                n.userData.__isOverlay__ = !0,
                n.visibleLevel = this.earthEffectVisibleLevel
            }
            if (e.model) {
                e.resourcePrefix = t.resourcePrefix;
                const n = Nt._loadEarthModel(e);
                n.userData.__isOverlay__ = !0,
                n.visibleLevel = this.earthEffectVisibleLevel
            }
        },
        _loadEarthModel(t) {
            const e = this
              , n = this.app.create({
                type: "ThingLayer",
                name: "earthModelLayer"
            });
            return this.map.addLayer(n),
            t.model && t.model.forEach(function(a) {
                if (a.url) {
                    const i = e.app.create({
                        type: "Thing",
                        url: r.a._combinePrefixAndLocalUrl(t.resourcePrefix, a.url),
                        position: [0, 0, 0],
                        scale: [a.size, a.size, a.size],
                        angles: [0, a.angle, 0],
                        visible: a.enable,
                        style: {
                            opacity: a.opacity,
                            color: a.useColor ? r.a.colorFormatNewToOld(a.color) : null
                        },
                        complete: function(t) {
                            t.object.node.getMaterials().map(t=>{
                                t.depthWrite = !1,
                                t.transparent = !0
                            }
                            ),
                            a.postRadialBlur2 && t.object.node.getMeshes().forEach(function(t) {
                                e.app.effectManager.setEffect(t, "radialBlur2")
                            }),
                            a.playAnimation && t.object.playAnimation({
                                name: a.animationName,
                                loopType: a.animationLoopType
                            })
                        }
                    });
                    n.add(i)
                }
            }),
            n
        },
        _matchLevelCondition: (t,e,n,r)=>t < r && t >= n && (e < n || e >= r && 22 !== e),
        _loadMapStyle(t, e) {
            let n = THING.App.current;
            if (e)
                1 === t.length ? r.a._loadMapStyle(t[0], !1) : (this._loadCurrentConfigFromMultiLevelConfig(t, r.a._loadMapStyle),
                n.on("MapLevelChange", e=>{
                    for (let n in t) {
                        let a = t[n].level;
                        this._matchLevelCondition(e.current, e.previous, a[0], a[1]) && r.a._loadMapStyle(t[n].value, !1)
                    }
                }
                , "mapStyleLevelChangeListener"));
            else
                for (var a in t)
                    "atmosphere" !== a && null !== t[a] ? (this.map.style[a] = t[a],
                    "fog" === a ? !1 === t[a] ? (this.map.style.fogDensity = 0,
                    this.map.style.fogExpDensity = 0) : this.map.style.fogDensity = 1 : "fogExp" === a && !1 === t[a] && (t.fogExpDensity = 0,
                    this.map.style.fogExpDensity = 0)) : this.map.atmosphere = t[a]
        },
        _loadLightConfig(t, e) {
            e ? 1 === t.length ? this._loadLightConfig(t[0], !1) : (this._loadCurrentConfigFromMultiLevelConfig(t, r.a._loadLightConfig),
            this.app.on("MapLevelChange", e=>{
                for (let n in t) {
                    let a = t[n].level;
                    this._matchLevelCondition(e.current, e.previous, a[0], a[1]) && r.a._loadLightConfig(t[n].value, !1)
                }
            }
            , "lightLevelChangeListener")) : (Array.isArray(t) && (t = t[0]),
            t.position || (t.position = [0, 0, 0]),
            t.distance ? (r.a.setLightGroup(t.position),
            t.SecondaryLights && Array.isArray(t.SecondaryLights) && (t.secondaryLight = t.SecondaryLights[0]),
            t.showHelper = !1,
            r.a.setLighting(t, t.distance),
            t.spotLights && Array.isArray(t.spotLights) && t.spotLights.forEach(function(t) {
                r.a.setSpotLight(t, t.name)
            })) : this.app.lighting = t)
        },
        _loadSkybox(t) {
            t.skyBox.endsWith(".jpg") || t.skyBox.endsWith(".png") || t.skyBox.endsWith(".jpeg") || t.skyBox.endsWith(".tga") ? this.app.skyBox = r.a._combinePrefixAndLocalUrl(t.resourcePrefix, t.skyBox) : this.app.skyBox = {
                posx: r.a._combinePrefixAndLocalUrl(t.resourcePrefix, r.a._combinePrefixAndLocalUrl(t.skyBox, "/up.jpg")),
                negx: r.a._combinePrefixAndLocalUrl(t.resourcePrefix, r.a._combinePrefixAndLocalUrl(t.skyBox, "/rt.jpg")),
                posy: r.a._combinePrefixAndLocalUrl(t.resourcePrefix, r.a._combinePrefixAndLocalUrl(t.skyBox, "/lf.jpg")),
                negy: r.a._combinePrefixAndLocalUrl(t.resourcePrefix, r.a._combinePrefixAndLocalUrl(t.skyBox, "/fr.jpg")),
                posz: r.a._combinePrefixAndLocalUrl(t.resourcePrefix, r.a._combinePrefixAndLocalUrl(t.skyBox, "/dn.jpg")),
                negz: r.a._combinePrefixAndLocalUrl(t.resourcePrefix, r.a._combinePrefixAndLocalUrl(t.skyBox, "/bk.jpg"))
            },
            this.app.on("EARTH_LOOP", function() {
                CMAP.Util.correctSkyBox()
            }, "correctSkyBox")
        },
        _loadPostEffectConfig(t, e) {
            if (e)
                1 === t.length ? r.a._loadPostEffectConfig(t[0], !1) : (this._loadCurrentConfigFromMultiLevelConfig(t, r.a._loadPostEffectConfig),
                this.app.on("MapLevelChange", e=>{
                    for (let n in t) {
                        let a = t[n].level;
                        this._matchLevelCondition(e.current, e.previous, a[0], a[1]) && r.a._loadPostEffectConfig(t[n].value, !1)
                    }
                }
                , "postEffectLevelChangeListener"));
            else {
                Array.isArray(t) && (t = t[0]),
                THING.App.current.postEffect = t;
                let e = this.app.rendererManager._mainRenderer;
                t.postEffect && (t.postEffect.SmallGlowBloom ? (e.getPass("smallGlow").$enable = t.postEffect.SmallGlowBloom.enable,
                e.getPass("smallGlow").strength = t.postEffect.SmallGlowBloom.strength,
                e.getPass("smallGlow").radius = t.postEffect.SmallGlowBloom.radius,
                e.getPass("smallGlow").threshold = t.postEffect.SmallGlowBloom.threshold) : e.getPass("smallGlow").$enable = !1,
                t.postEffect.MiddleGlowBloom ? (e.getPass("middleGlow").$enable = t.postEffect.MiddleGlowBloom.enable,
                e.getPass("middleGlow").strength = t.postEffect.MiddleGlowBloom.strength,
                e.getPass("middleGlow").radius = t.postEffect.MiddleGlowBloom.radius,
                e.getPass("middleGlow").threshold = t.postEffect.MiddleGlowBloom.threshold) : e.getPass("middleGlow").$enable = !1)
            }
        },
        loadVectorEarth(t) {
            let e = t.vectorEarth;
            e.config && (e.config.worldMeshStyle = e.config.worldMeshStyle || {},
            e.config.worldMeshStyle.visible = e.config.sphereVisible,
            e.config.loadConfig = e.config.loadConfig || {},
            e.config.loadConfig.lonlat = e.config.modelVisible);
            var n = THING.App.current.create({
                type: "VectorBaseLayer",
                id: "vectorBaseLayer",
                url: r.a._combinePrefixAndLocalUrl(t.resourcePrefix, e.url),
                style: e.config
            });
            this.map.baseLayers.add(n),
            !1 === e.config.allVisible && (n.visible = !1)
        },
        _cameraFly(t) {
            let e = t.cameraFlyTo;
            e && (e.lonlat || e.position) && (e.complete = function() {
                THING.App.current.trigger(THING.EventType.MapCameraReady)
            }
            ,
            THING.App.current.trigger("MapCameraStart", {
                config: e
            }),
            void 0 === e.angle || 0 === e.angle ? (e.directFly = !0,
            THING.App.current.camera.earthFlyTo(e)) : CMAP.getCurrentMap().rotate({
                angle: e.angle,
                time: e.rotateTime,
                complete: function() {
                    THING.App.current.camera.earthFlyTo(e)
                }
            }))
        },
        _loadMapConfig(t) {
            t.resourcePrefix = THING.Utils.parseValue(t.resourcePrefix, ""),
            t.externalConfigUrl && r.a._queryHttpUrl({
                url: r.a._combinePrefixAndLocalUrl(t.resourcePrefix, t.externalConfigUrl),
                async: !1,
                complete: function(e) {
                    let n;
                    try {
                        n = JSON.parse(e)
                    } catch (t) {
                        r.a.error("invalid externalConfig,please check")
                    }
                    if (n) {
                        if (n.cameraFlyTo && (t.cameraFlyTo = n.cameraFlyTo),
                        n.terrainUrl && (t.terrainUrl = n.terrainUrl),
                        n.tileUrl && Array.isArray(t.tileLayer) && (t.multiBaseMap ? t.tileLayer.forEach(t=>{
                            t.value.forEach((t,e)=>{
                                t.url = Array.isArray(n.tileUrl[e]) ? n.tileUrl[e][0] : n.tileUrl[e]
                            }
                            )
                        }
                        ) : t.tileLayer.forEach(t=>{
                            t.url = Array.isArray(n.tileUrl) ? n.tileUrl[0] : n.tileUrl
                        }
                        )),
                        n.layers && Array.isArray(n.layers))
                            for (let e = 0; e < n.layers.length; e++)
                                for (let r = 0; r < t.layers.length; r++)
                                    t.layers[r].id !== n.layers[e].id || (t.layers[r].url = n.layers[e].url);
                        if (t.overlay && t.overlay.vectorEarth && Array.isArray(n.vectorEarthLayers) && n.vectorEarthLayers && Array.isArray(n.vectorEarthLayers))
                            for (let e = 0; e < n.vectorEarthLayers.length; e++)
                                for (let r = 0; r < t.overlay.vectorEarth.length; r++)
                                    t.overlay.vectorEarth[r].id !== n.vectorEarthLayers[e].id || (t.overlay.vectorEarth[r].url = n.vectorEarthLayers[e].url);
                        if (n.scenes && Array.isArray(n.scenes))
                            for (let e = 0; e < n.scenes.length; e++)
                                for (let r = 0; r < t.scenes.length; r++)
                                    t.scenes[r].id !== n.scenes[e].id || (t.scenes[r].url = n.scenes[e].url)
                    }
                }
            }),
            this._removeIgnoredConfig(t, t.ignoreParams),
            this.map.mapConfig = t,
            t.isProxima && (this.map.attribution = "none");
            var e = THING.App.current;
            let n = t.map.style
              , a = this;
            this._loadMapStyle(n, t.multiEnviroment),
            t.background ? this._loadBackground(t, t.multiEnviroment) : t.skyBox && this._loadSkybox(t),
            this._loadTerrain(t),
            void 0 !== t.depthMode && (this.map.depthMode = t.depthMode);
            let i = "EARTH_COMPLETE";
            if (t.reload && (i = "ReloadMapConfig"),
            t.baseLayerUrls && 0 === t.baseLayerUrls.length)
                setTimeout(()=>{
                    this.app.trigger(i)
                }
                );
            else {
                this._loadTileLayerConfig(t);
                for (let e = 0; e < t.tileLayer.length; e++)
                    if (!1 === t.tileLayer[e].visible) {
                        setTimeout(()=>{
                            this.app.trigger(i)
                        }
                        );
                        break
                    }
            }
            t.light && this._loadLightConfig(t.light, t.multiEnviroment),
            t.postEffect && this._loadPostEffectConfig(t.postEffect, t.multiEnviroment),
            t.showLayerEventName || (t.showLayerEventName = THING.EventType.MapCameraReady),
            t.vectorEarth && (this.loadVectorEarth(t),
            i = "VectorBaseLayerComplete",
            this.app.rendererManager.mainRenderer.dirty()),
            t.overlay && Nt._loadOverlay(t, !1),
            e.on(i, function() {
                t.isProxima || t.loadDataFirst || a._cameraFly(t),
                Nt._loadParticle(t),
                Nt._loadLayers(t),
                e.off(i)
            }),
            t.reload && THING.App.current.trigger("ReloadMapConfig")
        },
        _convertJSToCJS(t) {
            var e = ""
              , n = t.split("/**");
            e += "$.ajaxSetup({\n  async: false\n});\n",
            e += n[3].split("**/")[1];
            var r = n[2].split("style")[1].substring(1, n[2].split("style")[1].indexOf("}") + 1)
              , a = this._addQuoteToObject(r);
            for (var i in a)
                e += "CMAP.getCurrentMap().style." + i + "=" + a[i] + ";\n";
            var o = n[4].split("**/")[1].split("addLayer();");
            return 0 === THING.App.current.campuses.length && (e += o[0]),
            e += "THING.App.current.trigger(THING.EventType.MapCameraReady);\n  addLayer();\n THING.App.current.trigger(THING.EventType.LayersComplete,{layers:map.allLayers});\n ",
            e += "$.ajaxSetup({\n  async: true\n});",
            0 === THING.App.current.campuses.length && (e += o[1]),
            e = (e = (e = (e = (e = (e = (e = (e += n[5].split("**/")[1]).substring(0, e.lastIndexOf("});"))).replaceAll("map.baseLayers", "CMAP.getCurrentMap().baseLayers")).replaceAll("map.userLayers", "CMAP.getCurrentMap().userLayers")).replaceAll("map.allLayers", "CMAP.getCurrentMap().allLayers")).replaceAll("app.create", "THING.App.current.create")).replaceAll("app.camera", "THING.App.current.camera")).replaceAll("map.flyRotate", "CMAP.getCurrentMap().flyRotate")
        },
        _isUrlValue: (t,e)=>!!t.toLowerCase().contains("url") || !("string" != typeof e || !(e.startsWith("/image") || e.startsWith("/model") || e.startsWith("/geojson"))),
        _removeParticle() {
            this.app.query("[userData/__isParticleLayer__=1]")[0] && this.app.query("[userData/__isParticleLayer__=1]")[0].destroy()
        },
        _loadGeoDiffusion(t) {
            let e = this;
            if (t.geoDiffusion) {
                var n = this.app.create({
                    type: "ThingLayer",
                    name: "diffusionLayer",
                    userData: {
                        __isDiffusionLayer__: !0
                    }
                });
                this.map.addLayer(n),
                t.geoDiffusion.forEach(function(a) {
                    let i = a.config
                      , o = [];
                    if (i.toObject && Array.isArray(i.toObject) && i.toObject.length > 0 && (i.toObject.indexOf("polygon") > -1 && (o = (o = (o = o.concat(e.app.query(".FeatureLayer").query("[userData/__fromCityBuilder__=1]").query('["geometryType"="GeoWater"]||["geometryType"="GeoBuilding"]||["geometryType"="GeoPolygon"]').toArray())).concat(e.app.query(".BigBuildingLayer").query("[userData/__fromCityBuilder__=1]").toArray())).concat(e.app.query("[userData/__isBuildingModelLayer__=1]").toArray())),
                    i.toObject.indexOf("model") > -1 && (o = o.concat(e.app.query(".Thing").query("[userData/__isGeoPoint__=1]").toArray())),
                    i.toObject.indexOf("scene") > -1 && (o = o.concat(e.app.query(".Campus").query("[userData/__fromCityBuilder__=1]").toArray()))),
                    i.url && (i.url = r.a._combinePrefixAndLocalUrl(t.resourcePrefix, i.url)),
                    i.lerpType && 2 === i.lerpType.split(".").length && (i.lerpType = THING.LerpType[i.lerpType.split(".")[0]][i.lerpType.split(".")[1]]),
                    "range" === i.posType) {
                        const t = e.app.create({
                            type: "GeoDiffusion",
                            diffusionType: i.diffusionType,
                            coordinates: i.coordinates,
                            radius: i.radius,
                            visible: i.visible,
                            renderer: i,
                            scanLayers: o,
                            lerpType: THING.LerpType.Linear.None,
                            offsetHeight: THING.Utils.parseValue(i.offsetHeight, 0),
                            renderOrder: -100
                        });
                        n.add(t)
                    } else
                        r.a._queryHttpUrl({
                            url: r.a._combinePrefixAndLocalUrl(t.resourcePrefix, a.url),
                            async: !1,
                            complete: function(t) {
                                "string" == typeof t && (t = JSON.parse(t)),
                                t.features.forEach(t=>{
                                    const r = e.app.create({
                                        type: "GeoDiffusion",
                                        diffusionType: i.diffusionType,
                                        coordinates: t.geometry.coordinates,
                                        radius: i.radius,
                                        visible: i.visible,
                                        renderer: i,
                                        scanLayers: o,
                                        renderOrder: -100
                                    });
                                    n.add(r)
                                }
                                )
                            }
                        })
                })
            }
        },
        _getParticleData(t, e) {
            for (let n in e)
                t[n]instanceof Array ? this._getParticleData(t[n][0], e[n][0]) : t[n]instanceof Object ? this._getParticleData(t[n], e[n]) : "" !== e[n] && (t[n] = e[n]);
            return t
        },
        _loadParticle(t) {
            let e = this;
            const n = this.app.create({
                type: "ThingLayer",
                name: "particleLayer",
                userData: {
                    __isParticleLayer__: !0
                }
            });
            return this.map.addLayer(n),
            n.style.renderOrder = 1e3,
            t.particle && t.particle.forEach(function(a) {
                const i = r.a.getJsonObject(a.config);
                let o = !0
                  , s = [0, 0, 0];
                if (i.coordinates && (s = CMAP.Util.convertLonlatToWorld(i.coordinates),
                o = !1),
                a.isNew)
                    i.url && r.a._queryHttpUrl({
                        url: r.a._combinePrefixAndLocalUrl(t.resourcePrefix, i.url),
                        responseType: "json",
                        async: !0,
                        complete: function(a) {
                            const l = function e(n, a) {
                                for (let i in n)
                                    n[i]instanceof Array ? e(n[i][0], a) : n[i]instanceof Object ? e(n[i], a) : "url" !== i || n[i].startsWith("http://") || n[i].startsWith("https://") || (n[i].startsWith("/image") ? n[i] = r.a._combinePrefixAndLocalUrl(t.resourcePrefix, n[i]) : n[i] = r.a._combinePrefixAndLocalUrl(t.resourcePrefix, "/model/particle/" + a + n[i]));
                                return n
                            }(e._getParticleData(r.a.getJsonObject(a), i), i.id)
                              , u = e.app.create({
                                type: "ParticleSystem",
                                data: l,
                                position: s,
                                complete: function(t) {
                                    if (o) {
                                        t.object.style.renderOrder = 3e3;
                                        for (let e = 0; e < t.object.node.getMaterials().length; e++)
                                            t.object.groups[0].depthTest = !0
                                    } else
                                        t.object.angles = CMAP.Util.getAnglesFromPosition(t.object.position)
                                }
                            });
                            n.add(u)
                        }
                    });
                else {
                    const a = e.app.create({
                        type: "ParticleSystem",
                        url: r.a._combinePrefixAndLocalUrl(t.resourcePrefix, i.url),
                        position: s,
                        complete: function(t) {
                            i.scale && (t.object.scale = i.scale,
                            t.object.angles = CMAP.Util.getAnglesFromLonlat(i.coordinates, i.angle),
                            t.object.setGroupAttribute("maxParticleCount", void 0 === i.maxDensity ? 1e4 : i.maxDensity),
                            t.object.setParticleAttribute("particleCount", void 0 === i.density ? 5e3 : i.density))
                        }
                    });
                    n.add(a)
                }
            }),
            n
        },
        _addPrifixToUrl(t, e) {
            let n = t.layerConfig;
            for (let t in n)
                if (this._isUrlValue(t, n[t])) {
                    let a = n[t];
                    Array.isArray(a) && a.length > 0 ? a[0].value ? (a.forEach(function(t) {
                        Array.isArray(t.value) ? t.value = [r.a._combinePrefixAndLocalUrl(e, t.value[0]), r.a._combinePrefixAndLocalUrl(e, t.value[1])] : t.value = r.a._combinePrefixAndLocalUrl(e, t.value)
                    }),
                    n[t] = a) : n[t] = [r.a._combinePrefixAndLocalUrl(e, a[0]), r.a._combinePrefixAndLocalUrl(e, a[1])] : Array.isArray(a) ? n[t] = [r.a._combinePrefixAndLocalUrl(e, a[0]), r.a._combinePrefixAndLocalUrl(e, a[1])] : n[t] = r.a._combinePrefixAndLocalUrl(e, a)
                }
            return n
        },
        _combinePrefixAndLocalUrl(t, e) {
            return !e || e.startsWith("http://") || e.startsWith("https://") ? e : (t = this._processPrefix(t),
            e.startsWith("/") || (e = "/" + e),
            t + e)
        },
        _processPrefix(t) {
            return t.endsWith("/") ? (t = t.substring(0, t.length - 1),
            this._processPrefix(t)) : t
        },
        _loadBackground(t, e) {
            if (e) {
                let e = t.background
                  , n = {
                    resourcePrefix: t.resourcePrefix
                };
                if (1 === e.length)
                    n.background = e[0].value,
                    r.a._loadBackground(n, !1);
                else {
                    let a = [];
                    for (let n in e) {
                        let r = {
                            resourcePrefix: t.resourcePrefix
                        };
                        r.background = e[n],
                        a.push(r)
                    }
                    r.a._loadCurrentConfigFromMultiLevelConfig(a, r.a._loadBackground),
                    this.app.on("MapLevelChange", t=>{
                        for (let a in e) {
                            let i = e[a].level;
                            this._matchLevelCondition(t.current, t.previous, i[0], i[1]) && (n.background = e[a].value,
                            r.a._loadBackground(n, !1))
                        }
                    }
                    , "backgroundChangeListener")
                }
            } else
                t.background ? "skybox" === t.background.type ? (t.skyBox = t.background.value,
                this._loadSkybox(t)) : "image" === t.background.type ? this.app.background = this._combinePrefixAndLocalUrl(t.resourcePrefix, t.background.value) : "color" === t.background.type && (this.app.background = t.background.value) : this.app.background = [0, 0, 0]
        },
        _loadTileLayerConfig(t) {
            let e = !1;
            const n = this;
            if (0 === this.app.query(".TileLayer").length && (e = !0),
            t.multiBaseMap) {
                if (t.tileLayer.length > 0) {
                    let r, a = t.tileLayer[0].value[0];
                    if (a.style = THING.Utils.parseValue(a.style, {}),
                    a.type = t.tileLayer[0].type,
                    t.baseLayerUrls && t.baseLayerUrls.length === t.tileLayer.length)
                        for (let e = 0; e < t.baseLayerUrls.length; e++)
                            if (t.baseLayerUrls[e].length === t.tileLayer[e].value.length)
                                for (let n = 0; n < t.baseLayerUrls[e].length; n++)
                                    t.tileLayer[e].value[n].url = t.baseLayerUrls[e][n];
                    if (e)
                        a.style.gradientColorOverlayEnable = !1,
                        (r = this.app.create(a)).userData.__fromCityBuilder__ = !0,
                        this.map.addLayer(r);
                    else {
                        r = this.app.query(".TileLayer")[0];
                        for (let e = 0; e < t.tileLayer.length; e++) {
                            let n = t.tileLayer[e];
                            this.map.currentLevel >= n.level[0] && this.map.currentLevel < n.level[1] && (r.url = n.value[0].url,
                            n.value[0].style.gradientColorOverlayEnable = !1,
                            n.value[0].style.night = this.map.style.night,
                            r._setStyle(n.value[0].style, !0),
                            r.maximumLevel = n.value[0].maximumLevel)
                        }
                    }
                    this.app.on("MapLevelChange", e=>{
                        for (let a in t.tileLayer) {
                            let i = t.tileLayer[a].level;
                            this._matchLevelCondition(e.current, e.previous, i[0], i[1]) && (r.url = t.tileLayer[a].value[0].url,
                            t.tileLayer[a].value[0].style.gradientColorOverlayEnable = !1,
                            t.tileLayer[a].value[0].style.night = n.map.style.night,
                            r._setStyle(t.tileLayer[a].value[0].style, !0),
                            r.maximumLevel = t.tileLayer[a].value[0].maximumLevel)
                        }
                    }
                    , "tileLevelChangeListener")
                }
            } else
                for (let n = 0; n < t.tileLayer.length; n++) {
                    let r, a = t.tileLayer[n];
                    a.style = THING.Utils.parseValue(a.style, {}),
                    t.baseLayerUrls && t.baseLayerUrls.length === t.tileLayer.length && (a.url = t.baseLayerUrls[n]),
                    a.style.night = this.map.style.night,
                    a.style.gradientColorOverlayEnable = !1,
                    e ? ((r = this.app.create(a)).userData.__fromCityBuilder__ = !0,
                    this.map.addLayer(r)) : ((r = this.app.query(".TileLayer")[n]).url = a.url,
                    r._setStyle(a.style, !0),
                    r.maximumLevel = a.maximumLevel)
                }
        },
        _loadTerrainData(t) {
            THING.Utils.isNull(this.map.terrainLayer.url) && (this.map.terrainLayer.url = t.terrainUrl,
            this.app.on("parseTerrainMetadataFailure", ()=>{
                let e = "EARTH_COMPLETE";
                t.reload && (e = "ReloadMapConfig"),
                this.app.trigger(e)
            }
            )),
            THING.Utils.isNull(t.terrainExaggeration) || (this.map.terrainLayer.terrainExaggeration = t.terrainExaggeration),
            THING.Utils.isNull(t.depthMode) || (this.map.depthMode = t.depthMode)
        },
        _loadTerrain(t) {
            let e = this;
            t._terrainUrl && (t.terrainUrl = t._terrainUrl),
            t.terrainUrl && (this.map._earthInstance.tileEarth._surface ? this._loadTerrainData(t) : this.app.on("terrainReady", function() {
                e._loadTerrainData(t)
            }))
        },
        _updateLayer(t, e) {
            t.updateExtrude(e),
            t.updateOffset(e),
            t.updateRenderer(e)
        },
        _constructLayerConfig(t) {
            const e = r.a.deepCopy(t.layerConfig);
            return ["extrudeField", "extrudeFactor", "extrudeHeight", "offsetHeight", "offsetHeightField", "offsetHeightAdded", "groundHeightField", "groundHeightFactor", "heightArrayFactor", "heightArrayField"].forEach(n=>{
                e[n] = t[n]
            }
            ),
            e.heightArrayField = t.heightArrayField,
            e
        },
        _layerUpdateVisible(t, e, n, r, a) {
            t.visible = !1;
            for (let i = 0; i < e.length; i++) {
                let o = e[i];
                n < o[1] && n >= o[0] && (t.visible = !0),
                THING.Utils.isNull(r) || n < o[1] && n >= o[0] && (r < o[0] || r >= o[1]) && a.multiLayerConfig && a.multiLayerConfig.length > 1 && this._updateLayer(t, a.multiLayerConfig[i])
            }
        },
        loadLayerConfig(t, e, n) {
            if (e.multiLayerConfig)
                for (let t = 0; t < e.multiLayerConfig.length; t++)
                    CMAP.Util._addPrifixToUrl({
                        layerConfig: e.multiLayerConfig[t]
                    }, n);
            else
                CMAP.Util._addPrifixToUrl(e, n);
            "GeoHeatMap" === e.type && (e.geometryType = "GeoHeatMap");
            var a = r.a.getJsonObject(t);
            let i = e.modelList
              , o = e.layerConfig && e.layerConfig.polygonModel;
            if (i && i.length > 0 && !o && "BuildingModelLayer" !== e.type) {
                this._loadBuildingModel(e, i);
                var s = [];
                for (let t = 0; t < i.length; t++)
                    if (i[t].pickedIndex) {
                        let e = i[t].pickedIndex.split("-");
                        s.push([e[0], e[1], JSON.parse(JSON.stringify(i[t]))])
                    }
                if (s.length > 0) {
                    s.sort((t,e)=>t[0] !== e[0] ? e[0] - t[0] : e[1] - t[1]);
                    for (let t in s)
                        if (a.features[s[t][0]] && a.features[s[t][0]].geometry.coordinates && a.features[s[t][0]].geometry.coordinates[s[t][1]])
                            if (s[t][2].modelUrl)
                                a.features[s[t][0]].geometry.coordinates.splice([s[t][1]], 1);
                            else if (s[t][2].deleted)
                                a.features[s[t][0]].geometry.coordinates.splice([s[t][1]], 1);
                            else {
                                let e = a.features[s[t][0]].geometry.coordinates[s[t][1]];
                                a.features[s[t][0]].geometry.coordinates.splice([s[t][1]], 1),
                                a.features.push({
                                    type: "Feature",
                                    properties: JSON.parse(s[t][2].userData),
                                    geometry: {
                                        coordinates: [e],
                                        type: "Polygon"
                                    }
                                })
                            }
                    a.features = a.features.filter(t=>t.geometry.coordinates.length > 0)
                }
            }
            return this._loadLayer(a, n, e, e.layerConfig)
        },
        _loadLayer(t, e, n, a) {
            let i, o = this;
            if ("BuildingModelLayer" === n.type) {
                (i = this.app.create({
                    name: n.name,
                    type: "ThingLayer",
                    id: n.id,
                    userData: {
                        __isBuildingModelLayer__: !0
                    },
                    visibleLevel: n.visibleLevel
                }))._scanConfig = n.scan;
                let u = Ut._createAllMaterial(a, "GeoBuilding");
                var s = 0
                  , l = n.url.substr(0, n.url.lastIndexOf("/"));
                for (let c = 0; c < t.array.length; c++)
                    for (let h = 0; h < t.array[c].length; h++) {
                        this.app.renderOptions = {
                            fpsLimit: 1
                        };
                        let d = this.app.create({
                            type: "BaseObject"
                        });
                        if (t.position) {
                            let e = CMAP.Util.getAnglesFromPosition(t.position[c]);
                            d.position = t.position[c],
                            d.angles = e
                        }
                        let f = this.app.create({
                            type: "Thing",
                            url: r.a._combinePrefixAndLocalUrl(e, l + "/" + t.array[c][h] + ".glb"),
                            complete: function(e) {
                                let n = e.object.node.getMeshes();
                                !function(l) {
                                    for (let e = 0; e < n.length; e++) {
                                        const r = n[e];
                                        if (e % 2 == 0 ? r.material = u[l][0] : (r.material = u[l][1],
                                        r.material.defines && r.material.defines.USE_EMISSIVE_AROUND_UV && (r.geometry.attributes.uv3 ? r.geometry.addAttribute("uv8", new THREE.BufferAttribute(r.geometry.attributes.uv3.array,2)) : r.geometry.addAttribute("uv8", new THREE.BufferAttribute(r.geometry.attributes.uv.array,2)))),
                                        t.format && t.format >= 2 && (r.material.side = THREE.FrontSide,
                                        r.material.needsUpdate = !0),
                                        a.effect) {
                                            let t = 1;
                                            void 0 !== a.glowStrength && (t = a.glowStrength),
                                            o.app.effectManager.setEffect(r, "glow", t)
                                        }
                                        a.postRadialBlur && o.app.effectManager.setEffect(r, "radialBlur", !0),
                                        a.postRadialBlur2 && o.app.effectManager.setEffect(r, "radialBlur2", !0)
                                    }
                                    if (++s === t.totalCount) {
                                        delete i.userData.__isBuildingModelLayer__,
                                        o.app.trigger(THING.EventType.LayerComplete, {
                                            object: i,
                                            message: "glb layer all added"
                                        }),
                                        i.userData.__isBuildingModelLayer__ = !0,
                                        o.app.renderOptions = {
                                            fpsLimit: !1
                                        };
                                        let t = e.object.parent.parent
                                          , n = [];
                                        for (let e = 0; e < t.children.length; e++) {
                                            let r = t.children[e].getLocalBoundingBox(!1)
                                              , a = t.children[e].selfToWorld(r.min)
                                              , i = t.children[e].selfToWorld(r.max)
                                              , o = CMAP.Util.convertWorldToLonlat(a)
                                              , s = CMAP.Util.convertWorldToLonlat(i);
                                            n.push(o),
                                            n.push(s)
                                        }
                                        let a = Math.min.apply(Math, n.map(function(t) {
                                            return t[0]
                                        }))
                                          , s = Math.max.apply(Math, n.map(function(t) {
                                            return t[0]
                                        }))
                                          , l = Math.min.apply(Math, n.map(function(t) {
                                            return t[1]
                                        }))
                                          , u = Math.max.apply(Math, n.map(function(t) {
                                            return t[1]
                                        }));
                                        t.extent = {
                                            minX: a,
                                            minY: l,
                                            maxX: s,
                                            maxY: u
                                        },
                                        t._scanConfig && (r.a._handleScanData(t._scanConfig, t, t._scanConfig.scanStyle.toLowerCase()),
                                        "v1" === t._scanConfig.scanStyle.toLowerCase() ? t.startScanning(t._scanConfig) : "v2" === t._scanConfig.scanStyle.toLowerCase() && t.startInitialScanning(t._scanConfig))
                                    }
                                }(c)
                            }
                        });
                        d.add(f),
                        n.offsetHeight && d.translateY(n.offsetHeight),
                        i.add(d)
                    }
            } else {
                if ("VectorTileLayer" === n.type)
                    return (i = this.app.create({
                        type: "VectorTileLayer",
                        id: n.id,
                        tileUrl: n.tileUrl,
                        tileExtendNum: n.tileExtendNum,
                        maxTileFactor: n.maxTileFactor,
                        resourcePrefix: n.resourcePrefix || e,
                        vectorLayers: n.vectorLayers,
                        visible: n.enable,
                        name: n.name
                    })).userData.__fromCityBuilder__ = !0,
                    this.map.addLayer(i),
                    i;
                {
                    THING.Utils.isNull(n.offsetHeight) && "无" === n.offsetHeightField && (n.offsetHeightField = null,
                    THING.Utils.isNull(n.groundHeightField) && (n.offsetHeight = THING.Utils.parseValue(n.offsetHeightAdded),
                    n.offsetHeightAdded = null));
                    let o = {
                        name: n.name,
                        type: n.type,
                        id: n.id,
                        dataSource: t,
                        renderer: a,
                        geometryType: n.geometryType,
                        infoWindow: n.infoWindow,
                        sync: n.sync,
                        pivot: n.pivot,
                        visibleLevel: n.visibleLevel,
                        azimuth: n.azimuth,
                        gridSize: n.gridSize,
                        shapeSize: n.shapeSize,
                        vectorType: n.vectorType,
                        valueField: n.valueField,
                        pickWithGeometryID: !0
                    };
                    ["extrudeField", "extrudeFactor", "extrudeHeight", "offsetHeight", "offsetHeightField", "offsetHeightAdded", "groundHeightField", "groundHeightFactor", "heightArrayFactor", "heightArrayField"].forEach(t=>{
                        o[t] = n[t]
                    }
                    ),
                    "GeoPolygon" === n.geometryType ? 0 === n.layerConfig.outlineWidth && (o.useOutline = !1) : "GeoBoundary" === n.geometryType && (n.layerConfig.wallImage && (n.layerConfig.imageUrl = n.layerConfig.wallImage,
                    delete n.layerConfig.wallImage),
                    n.layerConfig.alphaImage && (n.layerConfig.alphaImageUrl = n.layerConfig.alphaImage,
                    delete n.layerConfig.alphaImage),
                    n.layerConfig.scrollSpeed && (n.layerConfig.speed = n.layerConfig.scrollSpeed,
                    delete n.layerConfig.scrollSpeed)),
                    n.label && !1 !== n.label.visible && (n.label.imageUrl && (n.label.imageUrl = r.a._combinePrefixAndLocalUrl(e, n.label.imageUrl)),
                    o.label = n.label),
                    i = this.app.create(o)
                }
            }
            if (i.visible = n.enable,
            i.userData.__labelId__ = n.labelId,
            i.userData.__fromCityBuilder__ = !0,
            this.map.addLayer(i),
            i.renderOrder = n.renderOrder,
            n.enable && (n.level || n.multiLayerConfig)) {
                let t = [];
                if (n.multiLayerConfig)
                    for (let e = 0; e < n.multiLayerConfig.length; e++)
                        t.push(n.multiLayerConfig[e].level);
                else
                    t.push(i.level);
                this._layerUpdateVisible(i, t, this.map.currentLevel, void 0, n),
                this._addUpdaterOnLayer(i, t, n)
            }
            return this._loadLayerExtra(n, i),
            n.__isOverlay__ && (i.userData.__isOverlay__ = !0),
            i
        },
        _loadLayerExtra(t, e) {
            t.layerConfig && t.layerConfig.polygonModel && this.changePolygonToModel(t),
            t.scan && (delete t.scan.map,
            void 0 === t.scan.blending && (t.scan.blending = !1),
            t.scan.resourcePrefix = t.resourcePrefix,
            "FeatureLayer" === e.type || "BigBuildingLayer" === e.type && !1 === t.sync ? (r.a._handleScanData(t.scan, e, t.scan.scanStyle.toLowerCase()),
            "v1" === t.scan.scanStyle.toLowerCase() ? e.startScanning(t.scan) : "v2" === t.scan.scanStyle.toLowerCase() && e.startInitialScanning(t.scan)) : e._scanConfig = t.scan),
            t.layerConfig && t.layerConfig.reflectedPanoramaAngle && ("FeatureLayer" === e.type ? e.node.getMaterials().forEach(function(e) {
                e.baseQuaternion = CMAP.Util.anglesToQuaternion(t.layerConfig.reflectedPanoramaAngle)
            }) : e._envMapConfig = t.layerConfig.reflectedPanoramaAngle)
        },
        _loadBuildingModel(t, e) {
            let n = this
              , a = this.app.create({
                name: "modelLayer_" + t.name,
                type: "ThingLayer"
            });
            this.map.addLayer(a),
            e.forEach(function(e) {
                if (e.modelUrl && e.modelScale) {
                    let i = JSON.parse(e.userData)
                      , o = e.coordinates;
                    (o = o.split(","))[0] = o[0] - 0,
                    o[1] = o[1] - 0;
                    let s = 0;
                    3 === o.length && (s = o[2] - 0);
                    let l = e.modelScale;
                    (l = l.split(","))[0] = l[0] - 0,
                    l[1] = l[1] - 0,
                    l[2] = l[2] - 0;
                    let u = n.app.create({
                        type: "GeoPoint",
                        userData: i,
                        coordinates: o,
                        scale: l,
                        azimuth: e.azimuth - 0,
                        offsetHeight: s,
                        renderer: {
                            type: "model",
                            url: r.a._combinePrefixAndLocalUrl(t.resourcePrefix, e.modelUrl)
                        }
                    });
                    i.name && (u.name = i.name),
                    i.id && (u.id = i.id),
                    a.add(u)
                }
            }),
            a.renderOrder = t.renderOrder
        },
        _changePolygonToModel(t) {
            let e = this.app.create({
                name: "modelBuildingLayer",
                type: "ThingLayer",
                id: t.id + "_PolygonModelLayer"
            });
            this.map.addLayer(e);
            let n = THING.App.current.query("#" + t.id)[0];
            n.visible = !1;
            let a = t.layerConfig;
            if ("FeatureCollection" === n.dataSource.type) {
                let t = [];
                n.dataSource.features.forEach(function(e, n) {
                    a.model.forEach(function(a) {
                        r.a.isObjectMeetCondition(e.properties, a.condition) && t.push({
                            index: n,
                            item: e,
                            model: a.value
                        })
                    })
                });
                let i = 0;
                t.forEach(function(t) {
                    let n = t.item
                      , r = t.model.length;
                    n.geometry.coordinates.forEach(function(o, s) {
                        let l = o;
                        "MultiPolygon" === n.geometry.type && (l = o[0]);
                        let u, c = t.index + "-" + s;
                        a.singleModel && (u = a.singleModel.find(function(t) {
                            if (t.id === c)
                                return !0
                        }));
                        let h = [a.size, a.size, a.size]
                          , d = a.changeOpt
                          , f = t.model[i][1]
                          , p = l
                          , m = 180
                          , g = 0
                          , v = CMAP.Util.getCenterCoordinates(p);
                        0 === r || i === r - 1 ? i = 0 : i++,
                        u && (h = u.scale,
                        d = !1,
                        f = u.modelUrl,
                        u.coordinates && (v = u.coordinates),
                        void 0 !== u.azimuth && (m = u.azimuth),
                        void 0 !== u.offsetHeight && (g = u.offsetHeight));
                        let y = {
                            type: "GeoBuilding",
                            eId: c,
                            visible: !1,
                            lonlat: v,
                            coordinates: p,
                            eUserData: n.properties,
                            size: h,
                            changeOpt: d,
                            azimuth: m,
                            offsetHeight: g
                        };
                        this._alternateBuilding(y, e, f)
                    })
                })
            }
        },
        _modelToAuto(t, e, n) {
            let r = []
              , a = [];
            for (let t = 0; t < e.length; t++)
                r.push(e[t][0]),
                a.push(e[t][1]);
            let i = CMAP.Util.getPolygonExtent(e)
              , o = i.minX
              , s = i.maxX
              , l = i.minY
              , u = i.maxY
              , c = []
              , h = []
              , d = []
              , f = [];
            e.forEach((t,e)=>{
                t[0] === o && c.push(t),
                t[0] === s && h.push(t),
                t[1] === l && d.push(t),
                t[1] === u && f.push(t)
            }
            ),
            c.sort(function(t, e) {
                return t[1] - e[1]
            });
            let p = c[0];
            h.sort(function(t, e) {
                return e[1] - t[1]
            });
            let m = h[0];
            d.sort(function(t, e) {
                return e[0] - t[0]
            });
            let g = d[0];
            f.sort(function(t, e) {
                return t[0] - e[0]
            });
            let v = f[0]
              , y = CMAP.Util.getLineLength([v, p])
              , _ = CMAP.Util.getLineLength([g, p]);
            y *= 1.3,
            _ *= 1.7;
            let x = CMAP.Util.getAzimuth(g, p) - 360;
            0 !== y && 0 !== _ || (y = CMAP.Util.getLineLength([m, p]),
            _ = CMAP.Util.getLineLength([v, g]),
            x = 0),
            x = Number(x.toFixed(2)),
            isNaN(x) && (x = 0),
            t || (t = 3);
            var b = n.size
              , w = [y / b[0], t / b[2], _ / b[1]];
            n.scale = w.map(t=>1 * t),
            n.azimuth = x
        },
        _alternateBuilding(t, e, n) {
            let r = this;
            t.size && !t.changeOpt || (t.size = [1, 1, 1]);
            var a = this.app.create({
                type: "GeoPoint",
                id: t.eId,
                coordinates: t.lonlat,
                azimuth: t.azimuth,
                scale: t.size,
                visible: !1,
                renderer: {
                    size: 1,
                    type: "model",
                    url: n
                },
                userData: t.eUserData,
                complete: function() {
                    t.changeOpt && r._modelToAuto(t.eUserData.height, t.coordinates, this),
                    this.visible = !0
                }
            });
            a.pickedLonLat = t.lonlat,
            e.add(a)
        },
        _reConstructLayer(t) {
            let e = {}
              , n = {};
            for (let r = t.length - 1; r >= 0; r--)
                if (t[r].parentCode) {
                    let a = t[r].layerConfig;
                    ["level", "extrudeField", "extrudeFactor", "extrudeHeight", "offsetHeight", "offsetHeightField", "offsetHeightAdded", "groundHeightfield", "groundHeightFactor", "heightArrayFactor", "heightArrayField"].forEach(e=>{
                        a[e] = t[r][e]
                    }
                    );
                    let i = t[r].parentCode + "_" + t[r].geometryType;
                    "GeoPoint" !== t[r].geometryType && "FeatureLayer" === t[r].type || (i += "_" + r),
                    i in e ? t.forEach(function(e, n, a) {
                        e.id === t[r].id && a.splice(n, 1)
                    }) : (e[i] = [],
                    n[i] = t[r]),
                    e[i].push(a),
                    n[i].multiLayerConfig = e[i]
                }
            for (let e = 0; e < t.length; e++)
                if (t[e].multiLayerConfig && t[e].multiLayerConfig.length > 0)
                    for (let n = 0; n < t[e].multiLayerConfig.length; n++)
                        if (this.map.currentLevel >= t[e].multiLayerConfig[n].level[0] && this.map.currentLevel < t[e].multiLayerConfig[n].level[1]) {
                            t[e].layerConfig = t[e].multiLayerConfig[n],
                            ["level", "extrudeField", "extrudeFactor", "extrudeHeight", "offsetHeight", "offsetHeightField", "offsetHeightAdded", "groundHeightfield", "groundHeightFactor", "heightArrayFactor", "heightArrayField"].forEach(n=>{
                                t[e][n] = t[e].layerConfig[n]
                            }
                            );
                            break
                        }
        },
        _loadLayers(t) {
            let e = THING.Utils.parseValue(t.layers, [])
              , n = THING.Utils.parseValue(t.scenes, [])
              , a = 0
              , i = 0
              , o = t.isProxima
              , s = this
              , l = !1;
            function u(t) {
                THING.Utils.error("layer or geoCampus create error"),
                a++,
                h(),
                t && THING.Utils.error(t),
                c()
            }
            function c() {
                e.length + n.length === 0 ? s.app.trigger("MapCreateProgress", {
                    progress: 1
                }) : s.app.trigger("MapCreateProgress", {
                    progress: Math.floor(a / (e.length + n.length) * 100) / 100
                }),
                setTimeout(()=>{
                    a !== e.length + n.length || l || (Nt._loadGeoDiffusion(t),
                    s.app.trigger(THING.EventType.LayersComplete, {
                        layers: s.map.allLayers,
                        object: s.map
                    }),
                    s.app.off("MapCreateProgress"),
                    s.app.rendererManager._mainRenderer.dirty(),
                    l = !0)
                }
                , 0)
            }
            function h() {
                (o || t.loadDataFirst) && (o && !t.loadDataFirst ? a === i && (s._cameraFly(t),
                i = -1) : s.app.on(THING.EventType.LayersComplete, function(e) {
                    s._cameraFly(t)
                }, "maploader"))
            }
            function d(e, n) {
                t.cameraFlyTo && 0 === t.cameraFlyTo.time ? e.url ? r.a._queryHttpUrl({
                    url: r.a._combinePrefixAndLocalUrl(t.resourcePrefix, e.url),
                    complete: n,
                    async: t.ajaxAsync,
                    error: u
                }) : n() : s.app.on(t.showLayerEventName, function() {
                    f(e.url, n)
                })
            }
            function f(e, n) {
                r.a._queryHttpUrl({
                    url: r.a._combinePrefixAndLocalUrl(t.resourcePrefix, e),
                    complete: n,
                    error: u,
                    async: t.ajaxAsync
                })
            }
            this._reConstructLayer(e);
            let p = e.map(t=>t.id);
            if (this.app.on(THING.EventType.LayerComplete, function(t) {
                if (p.indexOf(t.object.id) >= 0 && (t.object.userData && !t.object.userData.__isBuildingModelLayer__ && (a++,
                h()),
                c(),
                "BigBuildingLayer" === t.object.type)) {
                    let e = t.object;
                    e._scanConfig && (r.a._handleScanData(e._scanConfig, e, e._scanConfig.scanStyle.toLowerCase()),
                    "v1" === e._scanConfig.scanStyle.toLowerCase() ? e.startScanning(e._scanConfig) : "v2" === e._scanConfig.scanStyle.toLowerCase() && e.startInitialScanning(e._scanConfig)),
                    e._envMapConfig && e.node.getMaterials().forEach(function(t) {
                        t.baseQuaternion = CMAP.Util.anglesToQuaternion(e._envMapConfig)
                    })
                }
            }),
            e.length > 0) {
                for (let t = 0; t < e.length; t++)
                    "BigBuildingLayer" !== e[t].type && "BuildingModelLayer" !== e[t].type && i++;
                h();
                for (let n = 0; n < e.length; n++) {
                    let r = e[n];
                    r.resourcePrefix = t.resourcePrefix;
                    let a = function(n) {
                        s.app.trigger("layerDataDownloadComplete", {
                            object: r,
                            totalLayers: e
                        });
                        try {
                            s.loadLayerConfig(n, r, t.resourcePrefix)
                        } catch (t) {
                            u(t)
                        }
                    };
                    o ? t.loadDataFirst ? f(r.url, a) : "BigBuildingLayer" !== r.type && "BuildingModelLayer" !== r.type && "VectorTileLayer" !== r.type ? f(r.url, a) : d(r, a) : t.loadDataFirst ? f(r.url, a) : d(r, a)
                }
            } else
                h(),
                c();
            if (n.length > 0) {
                var m = function() {
                    let e = s.app.create({
                        type: "ThingLayer",
                        name: "scnenLayer",
                        userData: {
                            __isSceneLayer__: !0
                        }
                    });
                    s.map.addLayer(e);
                    for (let i in n) {
                        let o = n[i];
                        o.type = "GeoCampus",
                        o.userData = {
                            __fromCityBuilder__: !0,
                            labelId: o.labelId
                        },
                        o.flyToScene = !1,
                        o.coordinates = o.lonlat,
                        o.offsetHeight = o.height || o.offsetHeight,
                        o.flyWhenLevelChange = !t.changeCampusLevel,
                        o.url && (o.url = r.a._combinePrefixAndLocalUrl(t.resourcePrefix, o.url)),
                        o.strategy ? o.complete = (e=>{
                            let n = e.object;
                            try {
                                t.changeCampusLevel ? s.app.level.change(n) : t.changeMapLevel && s.app.level.change(s.app.uEarth),
                                s.app.level.options.autoChangeBackground = !1,
                                s._applySceneTemplate(o, t.resourcePrefix, n)
                            } catch (t) {
                                THING.Utils.error(t)
                            } finally {
                                a++,
                                c()
                            }
                        }
                        ) : o.complete = function(e) {
                            let n = e.object;
                            try {
                                t.changeCampusLevel ? s.app.level.change(e.object) : t.changeMapLevel && s.app.level.change(s.app.uEarth),
                                s.app.level.options.autoChangeBackground = !1,
                                s._addGeoCampusEventListener(n.id, null)
                            } catch (t) {
                                THING.Utils.error(t)
                            } finally {
                                a++,
                                c()
                            }
                        }
                        ,
                        o.visible = o.enable;
                        let l = s.app.create(o);
                        e.add(l)
                    }
                };
                t.cameraFlyTo && 0 === t.cameraFlyTo.time ? m() : s.app.on(t.showLayerEventName, function() {
                    m()
                })
            }
        },
        loadLayerDataByConfig(t, e, n) {
            const r = [];
            this._reConstructLayer(e);
            for (let a = 0; a < e.length; a++)
                r.push(this.loadLayerConfig(t, e[a], n));
            return r
        },
        _updateLayerVisibleLevel(t, e) {
            e.visibleLevel ? t.visibleLevel = e.visibleLevel : t.visibleLevel = [0, 22]
        },
        _needsReCreateLayer: (t,e)=>"GeoPoint" === t.geometryType || t.geometryType !== e.geometryType || "GeoLine" === t.geometryType && (t.renderer.lineType !== e.layerConfig.lineType || t.renderer.width !== e.layerConfig.width || THING.Utils.parseValue(t.offsetHeight, 0) !== THING.Utils.parseValue(e.offsetHeight, 0) || t.offsetHeightField !== e.offsetHeightField || t.groundHeightField !== e.groundHeightField || t.groundHeightactor !== e.groundHeightactor || THING.Utils.parseValue(t.offsetHeightAdded, 0) !== THING.Utils.parseValue(e.offsetHeightAdded, 0)) || "GeoBoundary" === t.geometryType && (THING.Utils.parseValue(t.offsetHeight, 0) !== THING.Utils.parseValue(e.offsetHeight, 0) || t.offsetHeightField !== e.offsetHeightField || t.groundHeightField !== e.groundHeightField || t.groundHeightactor !== e.groundHeightactor || THING.Utils.parseValue(t.offsetHeightAdded, 0) !== THING.Utils.parseValue(e.offsetHeightAdded, 0)) || "GeoPolygon" === t.geometryType && (THING.Utils.parseValue(t.offsetHeight, 0) !== THING.Utils.parseValue(e.offsetHeight, 0) || t.offsetHeightField !== e.offsetHeightField || THING.Utils.parseValue(t.offsetHeightAdded, 0) !== THING.Utils.parseValue(e.offsetHeightAdded, 0) || THING.Utils.parseValue(t.extrudeHeight, 0) !== THING.Utils.parseValue(e.extrudeHeight, 0) || t.extrudeField !== e.extrudeField || THING.Utils.parseValue(t.extrudeFactor, 1) !== e.extrudeFactor),
        applyLayerConfig(t, e, n, a=!0) {
            let i = r.a.deepCopy(e);
            if (a) {
                this._reConstructMapLayers();
                for (let t = 0; t < i.length; t++)
                    CMAP.Util._addPrifixToUrl(i[t], n);
                this._reConstructLayer(i),
                t.userData.__isCurrentProject__ = !0
            }
            Array.isArray(i) || (i = [i]);
            for (let e = 0; e < i.length; e++) {
                const a = i[e];
                if (this._needsReCreateLayer(t, a)) {
                    if (t.userData.__isCurrentProject__ && this.map.userLayers.remove(t),
                    "BuildingModelLayer" !== a.type)
                        if (a.multiLayerConfig) {
                            this._loadLayer(t.dataSource, n, a, a.layerConfig).visible = this.isInLevel(a.level)
                        } else
                            this._loadLayer(t.dataSource, n, a, a.layerConfig)
                } else if (t.type.startsWith("Big"))
                    if (a.multiLayerConfig) {
                        if (t.userData.__isCurrentProject__)
                            if (this.isInLevel(a.level)) {
                                t.setRenderer(a.layerConfig),
                                this._updateLayerVisibleLevel(t, a);
                                let e = [];
                                for (let t = 0; t < a.multiLayerConfig.length; t++)
                                    e.push(a.multiLayerConfig[t].level);
                                this._addUpdaterOnLayer(t, e, a)
                            } else
                                this._loadLayer(t.dataSource, n, a, a.layerConfig)
                    } else
                        t.setRenderer(a.layerConfig),
                        this._updateLayerVisibleLevel(t, a),
                        t.visible = a.enable;
                else if (a.multiLayerConfig) {
                    for (let e = 0; e < a.multiLayerConfig.length; e++)
                        this.isInLevel(a.multiLayerConfig[e].level) && (this._updateLayer(t, a.multiLayerConfig[e]),
                        a.visibleLevel ? t.visibleLevel = a.visibleLevel : t.visibleLevel = [0, 22]);
                    let e = [];
                    for (let t = 0; t < a.multiLayerConfig.length; t++)
                        e.push(a.multiLayerConfig[t].level);
                    this._addUpdaterOnLayer(t, e, a)
                } else {
                    const e = this._constructLayerConfig(a);
                    this._updateLayer(t, e),
                    this._updateLayerVisibleLevel(t, a),
                    t.visible = a.enable
                }
                "GeoBuilding" === t.geometryType && (t.destroyScanning(),
                a.scan ? (void 0 === a.scan.blending && (a.scan.blending = !1),
                a.scan.resourcePrefix = n,
                "FeatureLayer" === a.type || "BigBuildingLayer" === a.type && !1 === a.sync ? (r.a._handleScanData(a.scan, t, a.scan.scanStyle.toLowerCase()),
                "v1" === a.scan.scanStyle.toLowerCase() ? t.startScanning(a.scan) : "v2" === a.scan.scanStyle.toLowerCase() && t.startInitialScanning(a.scan)) : t._scanConfig = a.scan) : t._scanConfig = null)
            }
        },
        applyTemplate(t, e) {
            let n = this;
            r.a._queryHttpUrl({
                url: t,
                async: THING.Utils.parseValue(e.ajaxAsync, !0),
                complete: function(t) {
                    let a = r.a._parseMapConfig(t);
                    a.success && 1 === a.success && ((a = a.data).resourcePrefix = THING.Utils.parseValue(e.resourcePrefix, ""),
                    n.applyTemplateByConfig(a, e))
                },
                error: function() {
                    THING.Utils.error("template url not found")
                }
            })
        },
        _removeVectorEarth() {
            for (let t = this.map.baseLayers.length - 1; t >= 0; t--)
                "VectorBaseLayer" === this.map.baseLayers[t].type && this.map.baseLayers.remove(this.map.baseLayers[t])
        },
        _removeTemplateConfig() {
            this._removeVectorEarth(),
            CMAP.Util._removeParticle(),
            this._removeOverLay(),
            this.app.off("MapLevelChange", null, "tileLevelChangeListener"),
            this.app.off("MapLevelChange", null, "mapStyleLevelChangeListener"),
            this.app.off("MapLevelChange", null, "lightLevelChangeListener"),
            this.app.off("MapLevelChange", null, "postEffectLevelChangeListener"),
            this.app.off("MapLevelChange", null, "backgroundChangeListener")
        },
        _removeOverLay() {
            this.map.style.gradientColorOverlayEnable = !1;
            for (let t = this.map.userLayers.length - 1; t >= 0; t--)
                this.map.userLayers[t].userData.__isOverlay__ && this.map.userLayers.remove(this.map.userLayers[t])
        },
        _removeIgnoredConfig(t, e) {
            if (Array.isArray(e))
                for (let n = 0; n < e.length; n++)
                    t.hasOwnProperty(e[n]) && delete t[e[n]]
        },
        applyTemplateByConfig(t, e) {
            this._removeIgnoredConfig(t, e.ignoreParams),
            this.map.mapConfig = t,
            this._removeTemplateConfig(),
            t.resourcePrefix = THING.Utils.parseValue(e.resourcePrefix, ""),
            t.map.style && this._loadMapStyle(t.map.style, t.multiEnviroment),
            t.light && this._loadLightConfig(t.light, t.multiEnviroment),
            t.postEffect && this._loadPostEffectConfig(t.postEffect, t.multiEnviroment),
            t.background && this._loadBackground(t, t.multiEnviroment),
            (t.particle || t.newParticle) && CMAP.Util._loadParticle(t),
            t.vectorEarth && CMAP.Util.loadVectorEarth(t),
            t.overlay && this._loadOverlay(t),
            t.baseLayerUrls = void 0 === e.baseLayerUrls ? [] : e.baseLayerUrls,
            this._loadTileLayerConfig(t),
            this._loadLayersByTemplate(t, e.removeUnmatched),
            this._applyScenesTemplate(t, e.removeUnmatched)
        },
        isInLevel(t) {
            return this.map.currentLevel < t[1] && this.map.currentLevel >= t[0]
        },
        _addUpdaterOnLayer(t, e, n) {
            t.userData.parentCode = n.parentCode;
            let r = this;
            this.app.on("MapLevelChange", function(a) {
                r._layerUpdateVisible(t, e, a.current, a.previous, n)
            }, "layerLevelChange_" + t.id)
        },
        _reConstructMapLayers() {
            for (let t = this.map.userLayers.length - 1; t >= 0; t--)
                if (this.map.userLayers[t].userData.__isCurrentProject__ = !0,
                void 0 !== this.map.userLayers[t].userData.parentCode) {
                    this.map.userLayers[t].multiLayerConfig && (this.map.userLayers[t].multiLayerConfig = void 0),
                    this.app.off("MapLevelChange", null, "layerLevelChange_" + this.map.userLayers[t].id);
                    for (let e = 0; e < this.map.userLayers.length; e++)
                        if (t !== e && this.map.userLayers[t].userData.parentCode === this.map.userLayers[e].userData.parentCode) {
                            this.map.userLayers[t].userData.parentCode = void 0,
                            this.map.userLayers.remove(this.map.userLayers[t]);
                            break
                        }
                }
        },
        _removeUnmatachedLayer(t) {
            for (let e = this.map.userLayers.length - 1; e >= 0; e--) {
                const n = this.map.userLayers[e];
                for (let e = 0; e < t.length; e++) {
                    const r = t[e];
                    (void 0 !== r.labelId && void 0 !== n.userData.__labelId__ && r.labelId === n.userData.__labelId__ || r.name === n.name) && (n.__matched__ = !0)
                }
                n.userData.__isSceneLayer__ || n.userData.__isOverlay__ || n.__matched__ || this.map.userLayers.remove(n)
            }
        },
        _applySceneTemplate(t, e, n) {
            let a = this.app.getControl("效果模板控制器");
            a || (a = new THING.EffectThemeControl,
            this.app.addControl(a, "效果模板控制器"));
            let i = "/";
            t.strategy.data && t.strategy.data.resourcePrefix && (t.strategy.data.resourcePrefix = r.a._combinePrefixAndLocalUrl(e, t.strategy.data.resourcePrefix),
            i = t.strategy.data.resourcePrefix + i);
            const o = "campusTheme_" + n.id + r.a.getUUID();
            a.registerTheme(o, t.strategy, i),
            n.applyTheme(o);
            const s = a.applyEffectTheme(o, n);
            s && s.then ? s.then(()=>{
                this.map._isInner && this.map.applyThemeEnvironment(o, "inner"),
                this._addGeoCampusEventListener(n.id, o)
            }
            ) : (this.map._isInner && this.map.applyThemeEnvironment(o, "inner"),
            this._addGeoCampusEventListener(n.id, o))
        },
        _addGeoCampusEventListener(t, e) {
            this.app.off(THING.EventType.LevelChange, null, "mapLoaderSceneLevelChangeListener_" + t),
            this.app.on(THING.EventType.LevelChange, t=>{
                t.current && "Campus" !== t.current.type ? t.previous && "Campus" === t.previous.type && "Thing" !== t.current.type && "Map" !== t.current.type && "ThingLayer" !== t.current.type && (e && this.map.applyThemeEnvironment(e, "inner"),
                this.map.visible = !1,
                this.map._isInner = !0) : (e && this.map.applyThemeEnvironment(e, "outer"),
                this.map.visible = !0,
                this.map._isInner = !1)
            }
            , "mapLoaderSceneLevelChangeListener_" + t, -1e3)
        },
        _applyScenesTemplate(t, e=!1) {
            const n = t.scenes
              , r = this.app.query(".GeoCampus");
            for (let a = 0; a < r.length; a++) {
                const i = r[a]
                  , o = i._layer;
                for (let r = 0; r < n.length; r++) {
                    const a = n[r];
                    i.userData.labelId === a.labelId ? this._applySceneTemplate(a, t.resourcePrefix, o) : e && i.destroy()
                }
            }
        },
        _loadLayersByTemplate(t, e=!1) {
            this._reConstructMapLayers(),
            e && this._removeUnmatachedLayer(t.layers);
            for (let e = 0; e < t.layers.length; e++)
                CMAP.Util._addPrifixToUrl(t.layers[e], t.resourcePrefix);
            this._reConstructLayer(t.layers);
            for (let e = 0; e < t.layers.length; e++) {
                let n = t.layers[e];
                n.__isOverlay__ && r.a._queryHttpUrl({
                    url: r.a._combinePrefixAndLocalUrl(t.resourcePrefix, n.url),
                    complete: function(e) {
                        Nt._loadLayer(JSON.parse(e), t.resourcePrefix, n, n.layerConfig)
                    },
                    error: function() {
                        THING.Utils.error("data url not found")
                    },
                    async: t.ajaxAsync
                });
                for (let e = this.map.userLayers.length - 1; e >= 0; e--) {
                    let r = this.map.userLayers[e];
                    (void 0 !== n.labelId && void 0 !== r.userData.__labelId__ && n.labelId === r.userData.__labelId__ || n.name === r.name) && this.applyLayerConfig(r, n, t.resourcePrefix, !1)
                }
                for (let e = this.map.userLayers.length - 1; e >= 0; e--) {
                    let n = this.map.userLayers[e];
                    "VectorTileLayer" === n.type && n.updateByMapJson(t, t.resourcePrefix)
                }
            }
        },
        _changeMapByConfig(t) {
            for (let t = this.map.baseLayers.length - 1; t >= 0; t--)
                this.map.baseLayers[t].userData.__fromCityBuilder__ && this.map.baseLayers.remove(this.map.baseLayers[t]);
            for (let t = this.map.userLayers.length - 1; t >= 0; t--)
                this.map.userLayers[t].userData.__fromCityBuilder__ && this.map.userLayers.remove(this.map.userLayers[t]);
            this.map.baseLayers.visible = !0,
            t.cameraFlyTo = {
                time: 0
            },
            this._loadMapConfig(t)
        }
    }
      , zt = Nt;
    class qt extends THING.BaseObject {
        constructor(t) {
            super(t),
            this._style = {},
            this.app = t,
            "linux" !== r.a._detectOS() && "macos" !== r.a._detectOS() || "chrome" !== r.a._detectBrowser() ? this.logDepthbuf = !1 : this.logDepthbuf = !0,
            this._originCameraPosition = t.camera.position,
            this._originCameraTarget = t.camera.target,
            t.camera.mode = "earth",
            t.camera.cameraObject.removeControl("cameraControl"),
            t.camera.cameraObject.addControl(new St, "cameraControl"),
            t.camera.panSpeed = t.camera.mousePanSpeed = .1,
            t.camera.rotateSpeed = .07,
            this.maxPitch = 82,
            this._originUrl = void 0,
            ht.a.setCameraFlyFunction(t),
            this.util = r.a,
            this.lastCameraInfo = null,
            this.app.on(THING.EventType.EnterLevel, ".Map", t=>{
                this.onCampusLevelSetCameraControl(t)
            }
            , THING.EventTag.LevelCameraControl),
            this.app.on(THING.EventType.EnterLevel, ".Map", t=>{
                this.onCampusLevelSetBackground(t)
            }
            , THING.EventTag.LevelSetBackground),
            this.app.on(THING.EventType.EnterLevel, ".Map", t=>{
                this.onCampusLevelSetEffect(t)
            }
            , THING.EventTag.LevelSetEffect),
            this.app.on(THING.EventType.EnterLevel, ".Map", t=>{
                this.onCampusLevelSceneOperations(t)
            }
            , THING.EventTag.LevelSceneOperations),
            this.app.on(THING.EventType.EnterLevel, ".Map", t=>{
                this.onCampusLevelPickedResultFunc(t)
            }
            , THING.EventTag.LevelPickedResultFunc),
            this.app.on(THING.EventType.EnterLevel, ".Map", t=>{
                this.onCampusLevelFly(t)
            }
            , THING.EventTag.LevelFly),
            this.app.on(THING.EventType.LeaveLevel, ".Map", t=>{
                this.onCampusLevelLeaveSceneOperations(t)
            }
            , THING.EventTag.LevelSceneOperations),
            this.sceneManager = new mt(t),
            this.pick3DTilesFeatureIdBuffer = [],
            this.pick3DTilesFeatureIdCurrentValue = CMAP.pickIdStartNum,
            this.pickIdBuffer = [],
            this.app.picker.onPickNodeID || (this.app.picker.onPickNodeID = (t=>{
                if (t >= CMAP.pickIdStartNum) {
                    for (let e in CMAP.getCurrentMap().pickIdBuffer) {
                        let n = CMAP.getCurrentMap().pickIdBuffer[e].start + CMAP.pickIdStartNum;
                        if (t < CMAP.getCurrentMap().pickIdBuffer[e].start + CMAP.getCurrentMap().pickIdBuffer[e].count + CMAP.pickIdStartNum && t >= n)
                            return CMAP.getCurrentMap().pickIdBuffer[e].node._pickedId = t,
                            CMAP.getCurrentMap().pickIdBuffer[e].node
                    }
                    for (let e in CMAP.getCurrentMap().pick3DTilesFeatureIdBuffer) {
                        if (CMAP.getCurrentMap().pick3DTilesFeatureIdBuffer[e].globalId === t) {
                            let t;
                            const n = THING.App.current.objectManager.getBaseObject(CMAP.getCurrentMap().pick3DTilesFeatureIdBuffer[e].feature._group_)
                              , r = CMAP.getCurrentMap().pick3DTilesFeatureIdBuffer[e].feature._batchId;
                            if (r >= 0 && CMAP.getCurrentMap().pick3DTilesFeatureIdBuffer[e].feature._content) {
                                t = CMAP.getCurrentMap().pick3DTilesFeatureIdBuffer[e].feature._content.batchTable.getProperty(r, n._objectKey),
                                n.globalKey = t
                            }
                            return n.node
                        }
                    }
                }
            }
            ))
        }
        onCampusLevelSetCameraControl(t) {}
        onCampusLevelSetBackground() {}
        onCampusLevelSetEffect() {}
        onCampusLevelSceneOperations() {}
        onCampusLevelPickedResultFunc(t) {
            var e;
            this.app.picker.pickedResultFunc = function(t) {
                for (let e = 0; e < t.parents.length; e++) {
                    const n = t.parents[e];
                    if ("Campus" === n.type)
                        return n
                }
                return t
            }
            ,
            this.app.pauseEvent(THING.EventType.Pick, null, THING.EventTag.LevelPickOperation),
            this.app.on(THING.EventType.Pick, function(t) {
                e && (e.style.outlineColor = null),
                e = t.object,
                t.object && "Campus" === t.object.type && (t.object.style.outlineColor = "#FF8000")
            }, "MapLevelPickOperation")
        }
        onCampusLevelFly(t) {
            t.previous ? t.previous.type !== this.type && this._lastCameraInfo && this.app.camera.earthFlyTo(this._lastCameraInfo) : this.app.trigger("cameraFlyComplete")
        }
        onCampusLevelLeaveSceneOperations(t) {
            this.app.resumeEvent(THING.EventType.Pick, null, THING.EventTag.LevelPickOperation),
            this.app.off(THING.EventType.Pick, null, "MapLevelPickOperation"),
            this._lastCameraInfo = this.app.camera.getCameInfo(),
            this._lastCameraInfo.directFly = !0
        }
        _beforeSetup(t) {
            super._beforeSetup(t),
            t.url && (this._originUrl = t.url,
            t.url.indexOf("cjs") > 0 && (this._originUrl += ".cjs"))
        }
        _afterSetupComplete(t) {
            this._earthInstance.atmospereInstance.node.children[0].children[0].castShadow = !1,
            this._earthInstance.atmospereInstance.node.children[0].children[0].receiveShadow = !1,
            zt.map = this,
            zt.app = this.app,
            r.a.map = this,
            r.a.app = this.app
        }
        canAcceptEvent(t) {
            return "update" === t.type || !(!t.object || !t.object.isChildOf(this))
        }
        customSetup(t) {
            Tt();
            let e = this;
            t3djs._initT3d ? (t3djs.rootNode.isChildOf(this.app.scene) || this.app.scene.add(t3djs.rootNode),
            t3djs.materialManager.loadCache(),
            setTimeout(()=>{
                this.app.uEarth._earthInstance.tileEarth.isEarthShow = !0
            }
            , 0)) : (t3djs.go(this.app.domElement.id, this.app),
            Object.defineProperty(t3djs.camera, "camera", {
                get: function() {
                    return e.app.renderCamera
                },
                configurable: !0
            })),
            t3djs._initT3d = !0,
            this.app.renderer.shadowMap.autoUpdate = !1,
            this.alias = void 0 === t.alias ? Pt.High : t.alias,
            this._repairCamera = void 0 === t.repairCamera || t.repairCamera,
            this._repairCamera && r.a.repairCamera(this.app.camera),
            t.background && (this.app.background = t.background),
            t.disableEffect && (this.disableCompositor = !0),
            CMAP._map = this.app.uEarth = this,
            this._style = new ft(this,t.style || {}),
            this.style.skipStyle = !0,
            void 0 !== t.restrictedLevel && (t.level = t.restrictedLevel),
            this.restrictedLevel = void 0 === t.level ? [0, 22] : t.level,
            this._attribution = t.attribution,
            this.addAttribution(this._attribution),
            void 0 === t.atmosphere && (t.atmosphere = !0),
            this._atmosphere = t.atmosphere,
            this._terrainUrl = t.terrainUrl,
            this._resourceConfig = t.resourceConfig,
            this._showLayerEventName = t.showLayerEventName,
            this._baseLayers = new m(this.app),
            this._userLayers = new g(this.app),
            this._sceneLayers = [],
            this.terrainLayer,
            this.allLayers = new f(this.app),
            this._earthInstance = new dt(t,this.app),
            this._event = this._earthInstance.event,
            this._visible = !0,
            this.app.camera.fov = 30,
            this.app.scene.fog = new THREE.FogExp2(16777215,0);
            var n = window.t3djs.earthRoot = new THREE.Group;
            this.app.scene.add(n),
            pt.init(this.app);
            let a = this.app.renderer;
            a.onCustom1Finish = function() {
                CMAP.depthMode !== p.a.Earth && a.clear(!1, !0, !1)
            }
            ,
            this.app.rendererManager._mainRenderer.shareDepthRenderBuffer(!0);
            let i = this.app.rendererManager._mainRenderer.getPass("LineBloom");
            i.strength = 1.5,
            i.blurSize = 2,
            i.dirty(),
            this.app.postEffect = {
                postEffect: {
                    colorCorrection: {
                        contrast: 1.1,
                        gamma: 1,
                        saturation: 1.2
                    }
                }
            },
            this.app.rendererManager._mainRenderer.combineGlow = !1,
            this.debugManager = new Rt(this.app),
            this.app.on("click", function(t) {
                t.object && e.app.trigger("MAPCLICK", t)
            });
            let o = this.currentLevel;
            THING.EventType.MapLevelChange = "MAPLEVELCHANGE",
            C.a.add("levelChange", function(t) {
                o !== e.currentLevel && e.app.trigger(THING.EventType.MapLevelChange, {
                    previous: o,
                    current: e.currentLevel
                }),
                o = e.currentLevel
            });
            var s, l = {
                create: function() {
                    let t = new THREE.MeshBasicMaterial({
                        color: new THREE.Color(1,0,0)
                    });
                    t.colorWrite = !1;
                    let e = new THREE.SphereGeometry(CMAP.depthGlobeRadiusFar,128,128)
                      , n = new THREE.Mesh(e,t);
                    return n.renderOrder = -1e4,
                    n.userData.skipPick = !0,
                    n
                },
                onUpdate: function() {
                    var t = e._depthGlobe
                      , n = CMAP.depthGlobeRadiusNear / CMAP.depthGlobeRadiusFar;
                    let a = r.a.getDistance(e.app.camera.camera.position, e.app.camera.curOrbit._getIntersectPoint());
                    a < 5e4 && !(s < 5e4) ? t.scale.set(n, n, n) : a >= 5e4 && !(s >= 5e4) && t.scale.set(1, 1, 1),
                    s = a
                }
            };
            this.app.addControl(l, "depthGlobeUpdate", !1);
            var u, c = l.create();
            if (this._depthGlobe = c,
            window.t3djs.rootNode.add(c),
            this.app.root.campuses.length > 0) {
                let t = this.app.root.campuses[0];
                var h, d;
                t.extraData && void 0 !== t.extraData.coordinates ? ((h = t.extraData.coordinates.split(","))[0] = h[0] - 0,
                h[1] = h[1] - 0) : void 0 !== t.coordinates && (h = t.coordinates),
                t.extraData && void 0 !== t.extraData.azimuth ? d = t.extraData.azimuth - 0 : void 0 !== t.azimuth && (d = t.azimuth),
                h || d || (d = 220),
                h || (h = [116.4641, 39.98606]),
                d || (d = 0),
                t.position = CMAP.Util.convertLonlatToWorld(h),
                t.angles = CMAP.Util.getAnglesFromLonlat(h, d),
                this.setParent(null),
                t3djs.rootNode.add(this.node);
                let e = t.selfToWorld(this._originCameraPosition)
                  , n = t.selfToWorld(this._originCameraTarget);
                this.app.camera.position = e,
                this.app.camera.target = n,
                this.app.camera.curOrbit.setState()
            }
            if (e._originUrl) {
                if (THING.Utils.log("准备加载场景"),
                t.complete) {
                    var v = t.complete;
                    t.complete = e.app.on("LAYERSCOMPLETE", function(t) {
                        t.object.mapConfig === u && v.call(this, {
                            object: e,
                            layers: e.allLayers
                        })
                    })
                }
                THING.Utils.dynamicLoad(e._originUrl, function(t) {
                    if (e._originUrl.endsWith("cjs")) {
                        var n = r.a._convertJSToCJS(t[e._originUrl]);
                        new Function(n)()
                    } else
                        u = t[e._originUrl],
                        (u = r.a._parseMapConfig(u)) && 1 === u.success ? (u = u.data,
                        e._resourceConfig || (e._resourceConfig = {}),
                        u.resourcePrefix = THING.Utils.parseValue(e._resourceConfig.resourcePrefix, ""),
                        u.baseLayerUrls = e._resourceConfig.baseLayerUrls,
                        u._terrainUrl = e._resourceConfig.terrainUrl,
                        u.showLayerEventName = e._resourceConfig.showLayerEventName,
                        u.isProxima = THING.Utils.parseValue(e._resourceConfig.isProxima, !1),
                        u.ajaxAsync = THING.Utils.parseValue(e._resourceConfig.ajaxAsync, !0),
                        u.loadDataFirst = THING.Utils.parseValue(e._resourceConfig.loadDataFirst, !1),
                        u.ignoreParams = THING.Utils.parseValue(e._resourceConfig.ignoreParams, []),
                        u.changeCampusLevel = THING.Utils.parseValue(e._resourceConfig.changeCampusLevel, !0),
                        u.changeMapLevel = THING.Utils.parseValue(e._resourceConfig.changeMapLevel, !0),
                        u.externalConfigUrl = e._resourceConfig.externalConfigUrl,
                        r.a._loadMapConfig(u),
                        e.mapConfig = u) : console.error("地图配置文件出错")
                })
            }
            this.setupUserData()
        }
        get event() {
            return this._event
        }
        get atmosphere() {
            return this._earthInstance.atmospereInstance.node.visible
        }
        set atmosphere(t) {
            this._earthInstance._atmosphere = t,
            this._atmosphere = t,
            this._earthInstance._atmospereSetuped && (this._earthInstance.atmospereInstance.node.visible = t)
        }
        get earth() {
            return this._earthInstance.tileEarth.rootNode.visible
        }
        set earth(t) {
            this._earthInstance.tileEarth.rootNode.visible = t,
            this._depthGlobe.visible = t
        }
        get logDepthbuf() {
            return this._logDepthbuf
        }
        set logDepthbuf(t) {
            this._logDepthbuf = t,
            CMAP.logDepthbuf = t,
            this.app.renderer.capabilities.logarithmicDepthBuffer = t,
            this.app.camera.autoAdjustNear = !t;
            let e = this.app.rendererManager._mainRenderer;
            e && e.dirty()
        }
        get depthMode() {
            return CMAP.depthMode
        }
        set depthMode(t) {
            CMAP.depthMode = t,
            t === p.a.None || t === p.a.Earth ? this._depthGlobe.material.depthWrite = !1 : this._depthGlobe.material.depthWrite = !0;
            let e = this.app.rendererManager._mainRenderer;
            e && e.dirty()
        }
        get style() {
            return this._style
        }
        get baseLayers() {
            return this._baseLayers
        }
        set baseLayers(t) {
            this._baseLayers._layers = t,
            this._earthInstance.removeAllLayers(),
            this._earthInstance.setBaseLayers(t)
        }
        get userLayers() {
            return this._userLayers
        }
        set userLayers(t) {
            Array.isArray(t) ? (this._userLayers.removeAll(),
            this._userLayers.add(t)) : this._userLayers.add(t._data)
        }
        get visible() {
            return this._visible
        }
        set visible(t) {
            t3djs.earthAndAtmosphere && t3djs.earthRoot && t3djs.rootNode && this._depthGlobe && this._earthInstance.tileEarth && (t3djs.earthAndAtmosphere.visible = t,
            t3djs.earthRoot.visible = t,
            t3djs.rootNode.visible = t,
            this._depthGlobe.visible = t,
            this._earthInstance.tileEarth.isEarthShow = t),
            !t && this.app.scene.fog && this.app.scene.fog.density && (this.app.scene.fog.density = 0),
            this._visible = t,
            this.app.rendererManager._mainRenderer.dirty()
        }
        flyRotate(t) {
            ht.a.flyRotate(t, this.app)
        }
        rotate(t) {
            this.flyRotate(t)
        }
        on() {
            if (arguments.length < 2)
                THING.Utils.log("参数不合法");
            else {
                for (var t in arguments) {
                    let e = arguments[t];
                    if (THING.Utils.isFunction(e)) {
                        arguments[t] = function(t) {
                            if (t.pickedPosition) {
                                var n = r.a.convertWorldToLonlat(t.pickedPosition);
                                t.coordinates = [n[0], n[1]],
                                e.call(t.object, t)
                            }
                        }
                    }
                }
                super.on.apply(this, arguments)
            }
        }
        addLayer(t) {
            "TileLayer" === t.type || "TerrainLayer" === t.type || "VectorBaseLayer" === t.type ? this.baseLayers.add(t) : this.userLayers.add(t)
        }
        removeLayer(t) {
            "TileLayer" === t.type || "TerrainLayer" === t.type || "VectorBaseLayer" === t.type ? this.baseLayers.remove(t) : this.userLayers.remove(t)
        }
        getLayerByName(t) {
            return this.allLayers.query(t)
        }
        move(t, e) {
            this.app.camera.curOrbit.earthRotate(t, e)
        }
        zoom(t, e) {
            this.app.camera.curOrbit.zoom(t, e)
        }
        get attribution() {
            return this._attribution
        }
        get restrictedLevel() {
            return this._restrictedLevel
        }
        set restrictedLevel(t) {
            this._restrictedLevel = t,
            this.app.camera.curOrbit.maxDistance = d.getDistanceByLevel(t[0]),
            this.app.camera.curOrbit.minDistance = d.getDistanceByLevel(t[1])
        }
        get level() {
            return this.restrictedLevel
        }
        set level(t) {
            this.restrictedLevel = t
        }
        get currentLevel() {
            return d.getCurentLevel(this.app)
        }
        get maxPitch() {
            return this._maxPitch
        }
        set maxPitch(t) {
            t >= 90 && (t = 89),
            this._maxPitch = t,
            this.app.camera.curOrbit.maxPitchAngle = t,
            this.app.camera.curOrbit.maxPolarAngle = THING.Math.degToRad(this._maxPitch)
        }
        set attribution(t) {
            var e = document.getElementById("dataAttribution");
            if (e)
                if ("none" !== t) {
                    e.style.display = "block";
                    var n = '&nbsp;<a href="http://www.thingjs.com" title="ThingJS">';
                    n += "ThingJS</a>",
                    n += this.getAttribution(t),
                    e.innerHTML = n
                } else
                    e.style.display = "none"
        }
        applyTheme(t) {}
        applyThemeEnvironment(t, e="outer") {
            if ("inner" === e) {
                this.app.applyThemeEnvironment(t, e);
                const n = this.app.level.current.parents.query(".Campus")[0];
                n ? (this.app._lightGroup.position = n.getWorldPosition(),
                this.app._lightGroup.angles = n.worldAngles) : THING.Utils.warn("can not find campus")
            } else if (this.logDepthbuf = this._logDepthbuf,
            this.mapConfig) {
                this.mapConfig.light && r.a._loadLightConfig(this.mapConfig.light, this.mapConfig.multiEnviroment);
                let t = this.app.rendererManager._mainRenderer;
                if (t.getPass("glow").$enable = !0,
                t.getPass("smallGlow").$enable = !0,
                t.getPass("combineGlow").$enable = !1,
                this.mapConfig.postEffect && Array.isArray(this.mapConfig.postEffect) && this.mapConfig.postEffect.length > 0) {
                    if (this.app.postEffect) {
                        let t = this.app.postEffect.postEffect.blur;
                        this.mapConfig.multiEnviroment ? this.mapConfig.postEffect.forEach(e=>{
                            e.value[0].postEffect.blur = t
                        }
                        ) : this.mapConfig.postEffect[0].postEffect.blur = t
                    }
                    r.a._loadPostEffectConfig(this.mapConfig.postEffect, this.mapConfig.multiEnviroment)
                }
                this.mapConfig.background ? r.a._loadBackground(this.mapConfig, this.mapConfig.multiEnviroment) : this.mapConfig.skyBox && r.a._loadSkybox(this.mapConfig),
                t.getPass("glow").strength = 1.5,
                t.getPass("glow").radius = .4,
                t.getPass("glow").threshold = .2,
                t.shareDepthRenderBuffer(!0),
                t.shareDepthRenderBuffer(!1, "Glow"),
                this.mapConfig.map.style && (this.app.scene.fog = new THREE.FogExp2(new THREE.Color(1,1,1),0),
                CMAP.Util._loadMapStyle(this.mapConfig.map.style, this.mapConfig.multiEnviroment));
                let e = this.mapConfig.layers;
                for (let n in e) {
                    let r = e[n];
                    r.geometryType && r.geometryType.indexOf("Line") >= 0 && r.layerConfig.effect && (t.getPass("lineBloom").$enable = !0)
                }
            }
        }
        addAttribution(t) {
            if ("none" !== t) {
                var e = '&nbsp;<a href="http://www.thingjs.com" title="ThingJS">';
                e += "ThingJS&nbsp</a>",
                e += this.getAttribution(t);
                var n = document.createElement("div");
                n.id = "dataAttribution",
                n.innerHTML = e;
                var r = document.head || document.getElementsByTagName("head")[0]
                  , a = document.createElement("style");
                a.type = "text/css",
                r.appendChild(a);
                var i = a.sheet || a.styleSheet;
                i.insertRule("#dataAttribution{ position:absolute}"),
                i.insertRule("#dataAttribution{ z-Index:1000}"),
                i.insertRule("#dataAttribution{ bottom:0px}"),
                i.insertRule("#dataAttribution{ right:0px}"),
                i.insertRule("#dataAttribution{ font-Size:11px}"),
                i.insertRule("#dataAttribution{ color:#565656}"),
                i.insertRule("#dataAttribution{ background-Color:rgba(255, 255, 255, 0.5)}"),
                i.insertRule("#dataAttribution a:link{color:#0078A8}"),
                i.insertRule("#dataAttribution a:visited{color:#0078A8}");
                var o = this.app.domElement
                  , s = this.app.renderer.domElement.parentElement;
                o.insertBefore(n, s)
            }
        }
        getAttribution(t) {
            if (t) {
                "Google" === t ? t = "<span>地图数据 ©" + (new Date).getFullYear() + ' Google</span>&nbsp|&nbsp<a href="http://www.google.cn/intl/zh-CN_CN/help/terms_maps.html" target="_blank" >使用条款</a>' : "OSM" === t || "OpenStreetMap" === t ? t = '© <a href="http://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors' : "CARTO" === t ? t = '© <a href="https://carto.com/attributions" target="_blank">CARTO</a>' : "高德" === t || "Gaode" === t || "amap" === t ? t = "<span>©" + (new Date).getFullYear() + ' 高德软件 | <a href="http://map.amap.com/doc/serviceitem.html" target="_blank">服务条款</a></span>' : "GeoQ" === t && (t = '<span><a href="https://www.geoq.cn" target="_blank">GeoQ</a></span>');
                var e = "|&nbsp";
                return e += t,
                e += "&nbsp"
            }
            return ""
        }
        getCurrentExtent() {
            var t = this.app
              , e = {}
              , n = t.renderer.domElement
              , a = []
              , i = []
              , o = 0
              , s = 0
              , l = 0
              , u = 0;
            let c = n.height / t.pixelRatio
              , h = n.width / t.pixelRatio;
            for (var d = 0; d < 10; d++) {
                var f = r.a.convertWindowToWorld([0, d * (c / 10)]);
                if (f) {
                    var p = r.a.world2Lonlat(f);
                    a.push(p[0]),
                    i.push(p[1]),
                    o++
                }
                var m = r.a.convertWindowToWorld([h, d * (c / 10)]);
                if (m) {
                    var g = r.a.world2Lonlat(m);
                    a.push(g[0]),
                    i.push(g[1]),
                    s++
                }
                var v = r.a.convertWindowToWorld([d * (h / 10), 0]);
                if (v) {
                    var y = r.a.world2Lonlat(v);
                    a.push(y[0]),
                    i.push(y[1]),
                    0
                }
                var _ = r.a.convertWindowToWorld([d * (h / 10), c]);
                if (_) {
                    var x = r.a.world2Lonlat(_);
                    a.push(x[0]),
                    i.push(x[1]),
                    l++
                }
            }
            for (let t = 0; t < 20; t++) {
                var b = r.a.convertWindowToWorld([h / 2, t * (c / 50)]);
                if (b) {
                    var w = r.a.world2Lonlat(b);
                    a.push(w[0]),
                    i.push(w[1]),
                    u++;
                    break
                }
            }
            return o > 0 && s > 0 && l > 0 && u > 0 ? (e.minX = Math.min(...a),
            e.maxY = Math.max(...i),
            e.maxX = Math.max(...a),
            e.minY = Math.min(...i)) : (e.minX = -180,
            e.maxX = 180,
            e.minY = -90,
            e.maxY = 90),
            e
        }
        setMapLight(t) {
            t ? pt.switchToEarth(this.app) : pt.switchToThing(this.app)
        }
        get repairCamera() {
            return this._repairCamera
        }
        set repairCamera(t) {
            t ? r.a.repairCamera(this.app.camera) : r.a.restoreCamera(this.app.camera),
            this._repairCamera = t
        }
        _setSunTexture(t) {
            this._earthInstance && this._earthInstance._sunLight._setSunSpriteTexture(t)
        }
        _removeSunTexture(t) {
            this._earthInstance && this._earthInstance._sunLight._removeSunSpriteTexture()
        }
        _setSystemTime(t) {
            this._earthInstance && this._earthInstance._sunLight._setTime(t)
        }
        _setSecondsAddCurrentTime(t) {
            this._earthInstance && this._earthInstance._sunLight._setSecondsAddCurrentTime(t)
        }
        destroy() {
            super.destroy(),
            this._earthInstance.showGroundAndAtmosphere(!1),
            this.app.removeControl("atmosphereUpdate"),
            this.app.removeControl("earthUpdate"),
            this.app.removeControl("depthGlobeUpdate"),
            this.app.removeControl("fixlightUpdate"),
            this._depthGlobe.dispose(),
            this._depthGlobe = null;
            var t = t3djs.buffer.nodeBuffer.get("earthRoot")
              , e = t.getMeshes()
              , n = t.getMaterials()
              , r = t.getTextures();
            for (let t = 0; t < e.length; t++)
                e[t].dispose(),
                e[t].geometry.faceVertexUvs && (e[t].geometry.faceVertexUvs = []),
                e[t].geometry.faces && (e[t].geometry.faces = []),
                e[t].geometry.vertices && (e[t].geometry.vertices = []);
            for (let t = 0; t < n.length; t++)
                n[t].dispose();
            for (let t = 0; t < r.length; t++)
                r[t].dispose();
            t.destroy(),
            this._earthInstance.fixLight = null;
            for (let e = 0; e < t.children.length; e++)
                t.children[e].destroy();
            t3djs.buffer.nodeBuffer.deleteAll(),
            t3djs.buffer.entityBuffer.deleteAll(),
            t3djs.buffer.materialBuffer.deleteAll(),
            t3djs.buffer.tileMaterialBuffer.deleteAll(),
            t3djs.buffer.textureBuffer.deleteAll(),
            C.a.delete("levelChange"),
            this.app.off(THING.EventType.MapCameraReady),
            this.userLayers.removeAll(!0),
            this.baseLayers.removeAll(),
            THING.Utils.log("销毁地图实例成功")
        }
        get debugMode() {
            return this.debugManager.enable
        }
        set debugMode(t) {
            this.debugManager.enable = t
        }
    }
    THING.factory.registerClass("Map", qt);
    var Vt = qt
      , Wt = {
        bigPoint: 1,
        smallPoint: 2,
        worldPoint: 3,
        bigLine: 4,
        smallLine: 5,
        worldMesh: 6
    }
      , Gt = {
        applyVectorEarthStyle(t, e) {
            let n = t._defaultStyle;
            e = THING.Utils.mergeObject(n, e, !0);
            let r = this._traverse(t);
            for (let t = 0, n = r.length; t < n; t++) {
                let n = r[t];
                if (n._vectorStyle)
                    switch (n._vectorStyle) {
                    case Wt.bigPoint:
                        this._changePoint(n, e.bigPointStyle);
                        break;
                    case Wt.smallPoint:
                        this._changePoint(n, e.smallPointStyle);
                        break;
                    case Wt.worldPoint:
                        this._changePoint(n, e.worldPointStyle);
                        break;
                    case Wt.bigLine:
                        this._changeLine(n, e.bigLineStyle);
                        break;
                    case Wt.smallLine:
                        this._changeLine(n, e.smallLineStyle);
                        break;
                    case Wt.worldMesh:
                        this._changeMesh(n, e.worldMeshStyle)
                    }
            }
            THING.App.current.rendererManager._mainRenderer.dirty()
        },
        _traverse(t) {
            let e = [];
            return t.node.traverse(t=>{
                (t.isMesh || t.isPoints) && e.push(t)
            }
            ),
            e
        },
        _changePoint(t, e) {
            let n = THING.Utils.parseColor(e.color);
            t.material.uniforms.ptColor.value = n,
            t.material.uniforms.size.value = e.size,
            THING.App.current.effectManager.setEffect(t, "radialBlur2", 1),
            THING.App.current.effectManager.setEffect(t, "glow", e.glowStrength),
            t.visible = e.visible
        },
        _changeLine(t, e) {
            THING.App.current.effectManager.removeEffect(t, "lineBloom"),
            THING.App.current.effectManager.setEffect(t, "glow", e.glowStrength),
            t.material.uniforms.lineWidth.value = e.width,
            t.material.uniforms.color.value = THING.Utils.parseColor(e.color),
            t.visible = e.visible
        },
        _changeMesh(t, e) {
            "LINE" !== t.__type__ ? t.material[0].color = t.material[1].color = THING.Utils.parseColor(e.color) : t.material.color = THING.Utils.parseColor(e.color),
            t.visible = e.visible
        }
    };
    const Yt = /([{]{2}(.+?)[}]{2})+?/g
      , Kt = /^\s+|\s+$/g;
    var $t = class {
        static build(t, e) {
            var n = this.getParamter(t)
              , r = this.getData(e, n);
            return this.getHtml(t, n.full, r)
        }
        static getParamter(t) {
            var e = t.match(Yt)
              , n = []
              , r = [];
            return e && Array.isArray(e) && e.forEach(function(t, e) {
                t = t.substring(2, t.length - 2),
                n.push(t),
                t = t.replace(Kt, ""),
                r.push(t)
            }),
            {
                full: n,
                short: r
            }
        }
        static getData(t, e) {
            var n = [];
            for (let r = 0; r < e.short.length; r++) {
                let a = t[e.short[r]];
                void 0 === a && (a = ""),
                n.push(a)
            }
            return n
        }
        static getHtml(t, e, n) {
            return e.forEach(function(e, r) {
                var a = "{{" + e + "}}";
                t = this.replaceAll(t, a, n[r])
            }, this),
            t
        }
        static replaceAll(t, e, n) {
            if (!t.length)
                return "";
            for (var r = t.substring(0); -1 !== r.indexOf(e); )
                r = r.replace(e, n);
            return r
        }
    }
    ;
    var Xt = class {
        constructor(t, e) {
            var n = this;
            this._type = e.type || "standard",
            this._customHtml = e.customHtml,
            this._title = e.title || "详细信息",
            this._displayMode = e.displayMode || "none",
            this._style = e.style || "default",
            this.name = "infoWindow" + r.a.getUUID(),
            this._fieldData = e.fieldData,
            this._originOffset = e.offset,
            this._offset = e.offset || [0, 0, 0],
            this._pivot = e.pivot || [.5, 1],
            this._parentObj = t,
            this._popupBoard = "",
            this._obj,
            this._event,
            this._clickShowClassName = "clickShowSign",
            this._mouseEnterClassName = "mouseEnterShowSign",
            this._inInfoWindowflag = !1,
            "FeatureLayer" !== t.type && ("mouseoverShow" === this._displayMode ? (this._event = "mouseenter",
            this._parentObj.isInfoShow = !1,
            t.on("mouseenter", function() {
                n._inInfoWindowflag = !1,
                n._createInfoWindow();
                var t = document.getElementById(n.name);
                t && (t.onmouseenter = function() {
                    n._inInfoWindowflag = !0
                }
                ,
                t.onmouseleave = function() {
                    n._inInfoWindowflag = !1,
                    n.destroy()
                }
                )
            }),
            t.on("mouseleave", function() {
                !1 === n._inInfoWindowflag && n.destroy()
            })) : "oftenShow" === this._displayMode ? (this._parentObj.isInfoShow = !0,
            n._createInfoWindow()) : "none" === this._displayMode ? (this._parentObj.isInfoShow = !1,
            this.destroy()) : (this._parentObj.isInfoShow = !1,
            this._event = "click",
            t.on("click", function() {
                n._createInfoWindow()
            }))),
            !1 === e.visible && (this.visible = !1)
        }
        _createInfoWindow() {
            var t;
            if (document.getElementById(this.name) && t3djs.client.removeChild(document.getElementById(this.name)),
            "clickShow" === this._displayMode)
                for (let t = 0; t < document.getElementsByClassName(this._clickShowClassName).length; t++)
                    t3djs.client.removeChild(document.getElementsByClassName(this._clickShowClassName)[t]);
            else if ("mouseoverShow" === this._displayMode)
                for (let t = 0; t < document.getElementsByClassName(this._mouseEnterClassName).length; t++)
                    t3djs.client.removeChild(document.getElementsByClassName(this._mouseEnterClassName)[t]);
            if ("custom" === this.type)
                (t = document.createElement("div")).innerHTML = $t.build(this._customHtml, this._parentObj._userData),
                this._popupBoard = t.childNodes[0],
                this._popupBoard.setAttribute("id", this.name),
                this._popupBoard.style.position = "absolute",
                t3djs.client.appendChild(this._popupBoard);
            else if ("standard" === this.type) {
                var e, n = "", r = "";
                "blue" === this._style ? (n = "<li class='info-item' style = 'font-size: 14px;\n      padding: 8px 0px;'>\n       <div class='info-key'  style = 'width: 50px;\n        float: left;\n        text-align: center;\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap;'>&key</div>\n       <div class='info-value' style = 'width: 125px;\n        white-space: nowrap;\n        text-overflow: ellipsis;\n        overflow: hidden;'>: &value</div>\n     </li>",
                r = "<div class='sign' id='PopupBoard' style='width: 210px;\n         background-color: rgba(192, 192, 192, 0);\n         color: rgb(204, 204, 204);\n         top: 272px;\n         left: 754px;\n         z-index: 1020;\n         display: block;\n         position: absolute;\n         backdrop-filter: blur(5px);\n         border-radius: 10px;\n         visibility: visible;'>\n       <div class = 'headline' style = 'font-size: 13px;\n        color: #cccccc;\n        background: rgba(43, 135, 230, 0.8);\n        padding: 8px 4px 8px 18px;\n        line-height: 20px;\n        border-bottom: 1px solid rgba(43,135,230, 0.7);\n        border-radius: 9px 9px 0px 0px;'>&title</div>\n       <div class = 'info' style = 'background-color: rgba(43,135,230, 0.6);\n       padding: 8px 10px;\n       border-radius: 0px 0px 9px 9px;'>\n         <ul class='info-list' style = ' color: #eeeeee;\n          list-style: none;\n          margin-left: 15px;\n         ' >&item </ul>\n       </div>\n       <div class='point-top' style='position: absolute;top: 0px;right: 8px;cursor:pointer;'>×</div>\n     </div>") : "white" === this._style ? (n = "<li class='info-item' style = 'font-size:14px;padding: 8px 0px;'>\n          <div class='info-key' style = 'width: 66px;float:left;text-align:center;overflow: hidden;text-overflow:ellipsis;white-space:nowrap;'>&key</div>\n          <div class='info-value' style = 'margin-left: 66px;width: 125px; white-space: nowrap; text-overflow: ellipsis;overflow: hidden;'>: &value</div>\n        </li>",
                r = "<div class='sign' id='PopupBoard' style='width: 210px;background-color: rgba(192, 192, 192, 0.6);color: #cccccc;top: 0;left: 0;z-index: 100;display: inline-block;position: absolute;border-radius:5px'>\n          <div class = 'headline' style = 'font-size:12px;color:rgb(69,69,69);border-radius: 5px 5px 0px 0px;padding: 4px 4px 4px 12px;background:linear-gradient(rgba(238,238,238,0.9), rgba(238,238,238,0.7));line-height:20px;'>&title</div>\n          <div class = 'info' style = 'background-color: rgba(200,200,200, 0.8);padding: 10px 8px 10px 8px;'>\n            <ul class='info-list' style = 'color:#454545;list-style: none;margin:0;padding: 0;' >&item </ul>\n          </div>\n          <div class='point-top' style='position: absolute;top: 0px;right: 8px;cursor:pointer;>×</div>\n        </div>",
                n = "<li class='info-item' style = 'font-size: 14px;\n        padding: 8px 0px;'>\n         <div class='info-key'  style = 'width: 50px;\n          float: left;\n          text-align: center;\n          overflow: hidden;\n          text-overflow: ellipsis;\n          white-space: nowrap;'>&key</div>\n         <div class='info-value' style = 'width: 125px;\n          white-space: nowrap;\n          text-overflow: ellipsis;\n          overflow: hidden;'>: &value</div>\n       </li>",
                r = "<div class='sign' id='PopupBoard' style='width: 210px;\n           background-color: rgba(192, 192, 192, 0.3);\n           color: #ccccc;\n           top: 272px;\n           left: 754px;\n           z-index: 1020;\n           display: block;\n           position: absolute;\n           backdrop-filter: blur(5px);\n           border-radius: 10px;\n           visibility: visible;'>\n         <div class = 'headline' style = 'font-size: 13px;\n          color: rgb(69,69,69);\n          background:linear-gradient(rgba(238,238,238,0.9), rgba(238,238,238,0.7));\n          padding: 8px 4px 8px 18px;\n          line-height: 20px;\n          border-bottom: 1px solid rgba(200, 200, 200, 0.75);\n          border-radius: 9px 9px 0px 0px;'>&title</div>\n         <div class = 'info' style = 'background-color: rgba(200,200,200,0.3);\n         padding: 8px 10px;\n         border-radius: 0px 0px 9px 9px;'>\n           <ul class='info-list' style = ' color: rgba(0,0,0,0.8);\n            list-style: none;\n            margin-left: 15px;\n           ' >&item </ul>\n         </div>\n         <div class='point-top' style='position: absolute;top: 0px;right: 8px;cursor:pointer;'>×</div>\n       </div>") : (n = "<li class='info-item' style = 'font-size: 14px;\n         padding: 8px 0px;'>\n          <div class='info-key'  style = 'width: 50px;\n           float: left;\n           text-align: center;\n           overflow: hidden;\n           text-overflow: ellipsis;\n           white-space: nowrap;'>&key</div>\n          <div class='info-value' style = 'width: 125px;\n           white-space: nowrap;\n           text-overflow: ellipsis;\n           overflow: hidden;'>: &value</div>\n        </li>",
                r = "<div class='sign' id='PopupBoard' style='width: 210px;\n            background-color: rgba(192, 192, 192, 0);\n            color: rgb(204, 204, 204);\n            top: 272px;\n            left: 754px;\n            z-index: 1020;\n            display: block;\n            position: absolute;\n            backdrop-filter: blur(5px);\n            border-radius: 10px;\n            visibility: visible;'>\n          <div class = 'headline' style = 'font-size: 13px;\n           color: #cccccc;\n           background: rgba(0, 0, 0, 0.8);\n           padding: 8px 4px 8px 18px;\n           line-height: 20px;\n           border-bottom: 1px solid rgba(0, 0, 0, 0.75);\n           border-radius: 9px 9px 0px 0px;'>&title</div>\n          <div class = 'info' style = 'background-color: rgba(0, 0, 0, 0.7);\n          padding: 8px 10px;\n          border-radius: 0px 0px 9px 9px;'>\n            <ul class='info-list' style = ' color: #cccccc;\n             list-style: none;\n             margin-left: 15px;\n            ' >&item </ul>\n          </div>\n          <div class='point-top' style='position: absolute;top: 0px;right: 8px;cursor:pointer;'>×</div>\n        </div>");
                for (var a = "", i = 0; i < this._fieldData.length; i++) {
                    var o = "";
                    if (this._fieldData[i].url) {
                        if ("current" === this._fieldData[i].target) {
                            o = '<a href="#" ';
                            var s = function() {
                                if (!document.getElementById(this.name)) {
                                    var t = document.createElement("div");
                                    t.setAttribute("style", "position: absolute;top:50%;left:50%;width:&widthValuepx;height:&heightValuepx;transform:translate(-50%, -50%);background-color: rgba(0,0,0, 0.8);padding:20px 0px 0px 0px;z-index:1001;"),
                                    t.setAttribute("id", this.name);
                                    var e = document.createElement("div");
                                    e.setAttribute("style", "position: absolute;top: -3px;right: 3px;cursor:pointer;color: rgb(255,255,255);"),
                                    e.innerHTML = "x",
                                    e.addEventListener("click", function() {
                                        t3djs.client.removeChild(t)
                                    }),
                                    t.innerHTML = "<iframe id='popWindowIframe' name='popWindow' src='&urlValue' frameBorder='no' style='width:100%;height:100%;'></iframe>",
                                    t3djs.client.appendChild(t),
                                    t.appendChild(e)
                                }
                            }
                            .toString().replace("function (){", "");
                            o = (o += 'onclick="' + (s = s.substring(0, s.length - 1)) + '" ').replace("&urlValue", this._fieldData[i].url),
                            o = this._fieldData[i].width && this._fieldData[i].width ? (o = o.replace("&widthValue", this._fieldData[i].width)).replace("&heightValue", this._fieldData[i].height) : (o = o.replace("&widthValue", 600)).replace("&heightValue", 600)
                        } else
                            o = '<a href="' + this._fieldData[i].url + '" ',
                            o += 'target="_blank" ';
                        "blue" === this._style ? o += 'style="color:#eeeeee;">' : "white" === this._style ? o += 'style="color:rgba(0,0,0,0.8);">' : o += 'style="color:#cccccc;">'
                    }
                    this._fieldData[i].alias ? this._fieldData[i].url ? a += n.replace("&key", this._fieldData[i].alias).replace("&value", o + this._parentObj._userData[this._fieldData[i].field] + "</a>") : a += n.replace("&key", this._fieldData[i].alias).replace("&value", this._parentObj._userData[this._fieldData[i].field]) : this._fieldData[i].url ? a += n.replace("&key", this._fieldData[i].field).replace("&value", o + this._parentObj._userData[this._fieldData[i].field] + "</a>") : a += n.replace("&key", this._fieldData[i].field).replace("&value", this._parentObj._userData[this._fieldData[i].field])
                }
                e = r.replace("&item", a).replace("&title", this._title).replace("PopupBoard", this.name),
                (t = document.createElement("div")).innerHTML = e,
                this._popupBoard = t.childNodes[0];
                var l = t.childNodes[0].childNodes[t.childNodes[0].childNodes.length - 1];
                t3djs.client.appendChild(this._popupBoard),
                "clickShow" === this._displayMode || "oftenShow" === this._displayMode ? "point-top" === l.className && l.addEventListener("click", function(t) {
                    t.target.parentElement.style.display = "none",
                    t.stopPropagation(),
                    document.getElementById(this.name) && t3djs.client.removeChild(document.getElementById(this.name))
                }, !1) : "point-top" === l.className && l.parentNode.removeChild(l)
            }
            "clickShow" === this._displayMode ? this._popupBoard.className = this._clickShowClassName : "mouseoverShow" === this._displayMode && (this._popupBoard.className = this._mouseEnterClassName),
            this._createUI()
        }
        _createUI() {
            this._popupBoard.style.display = "block";
            var t = this._parentObj.selfToWorld(this._offset);
            this._obj = this._parentObj.app.create({
                type: "UIAnchor",
                parent: this._parentObj,
                el: this._popupBoard,
                position: t,
                pivot: this._pivot
            }),
            "oftenShow" !== this._displayMode && THING.App.current.trigger("INFOSHOW", this._parentObj)
        }
        _throttle(t, e, n) {
            var r = null;
            return function() {
                e = e || 500;
                var a = n || this
                  , i = arguments;
                clearTimeout(r),
                r = setTimeout(function() {
                    t.apply(a, i)
                }, e)
            }
        }
        destroy() {
            document.getElementById(this.name) && t3djs.client.removeChild(document.getElementById(this.name))
        }
        get type() {
            return this._type
        }
        set type(t) {
            "FeatureLayer" === this._parentObj.type ? this._setFeatureLayerInfoWindowProperty("type", t) : (this._type = t,
            !0 === this._parentObj.isInfoShow && this._createInfoWindow())
        }
        get pivot() {
            return this._pivot
        }
        get offset() {
            return this._offset
        }
        set offset(t) {
            if ("FeatureLayer" === this._parentObj.type)
                this._setFeatureLayerInfoWindowProperty("offset", t);
            else {
                this._offset = t;
                const e = this._parentObj.selfToWorld(this._offset);
                this._obj && (this._obj.position = e)
            }
        }
        get title() {
            return this._title
        }
        set title(t) {
            "FeatureLayer" === this._parentObj.type ? this._setFeatureLayerInfoWindowProperty("title", t) : (this._title = t,
            !0 === this._parentObj.isInfoShow && this._createInfoWindow())
        }
        get displayMode() {
            return this._displayMode
        }
        set displayMode(t) {
            if ("FeatureLayer" === this._parentObj.type)
                this._setFeatureLayerInfoWindowProperty("displayMode", t);
            else {
                var e = this;
                if (this._event && ("mouseenter" === this._event && this._parentObj.off("mouseleave"),
                this._parentObj.off(this._event)),
                "mouseoverShow" === t ? (this._displayMode = "mouseoverShow",
                this._parentObj.isInfoShow = !1,
                this._event = "mouseenter",
                this.destroy()) : "oftenShow" === t ? (this._displayMode = "oftenShow",
                this._parentObj.isInfoShow = !0,
                this._createInfoWindow()) : "none" === t ? (this._displayMode = "none",
                this._parentObj.isInfoShow = !1,
                this.destroy()) : (this._displayMode = "clickShow",
                this._parentObj.isInfoShow = !1,
                this._event = "click",
                this.destroy()),
                "clickShow" === this._displayMode)
                    this._parentObj.on(this._event, function() {
                        e._createInfoWindow()
                    });
                else if ("mouseoverShow" === this._displayMode) {
                    var n = !1;
                    this._event = "mouseenter",
                    this._parentObj.on("mouseenter", function() {
                        n = !1,
                        e._createInfoWindow();
                        var t = document.getElementById(e.name);
                        t && (t.onmouseenter = function() {
                            n = !0
                        }
                        ,
                        t.onmouseleave = function() {
                            n = !0,
                            e.destroy()
                        }
                        )
                    }),
                    this._parentObj.on("mouseleave", function() {
                        !1 === n && e.destroy()
                    })
                }
            }
        }
        get style() {
            return this._style
        }
        set style(t) {
            "FeatureLayer" === this._parentObj.type ? this._setFeatureLayerInfoWindowProperty("style", t) : (this._style = t,
            !0 === this._parentObj.isInfoShow && this._createInfoWindow())
        }
        get visible() {
            return "FeatureLayer" === this._parentObj.type ? this._visible : !0 === this._parentObj.isInfoShow && "block" === this._popupBoard.style.display
        }
        set visible(t) {
            "FeatureLayer" === this._parentObj.type ? this._setFeatureLayerInfoWindowProperty("visible", t) : !0 === t ? !0 === this._parentObj.isInfoShow && (this._popupBoard.style.display = "block") : !0 === this._parentObj.isInfoShow && (this._popupBoard.style.display = "none")
        }
        get fieldData() {
            return this._fieldData
        }
        set fieldData(t) {
            "FeatureLayer" === this._parentObj.type ? this._setFeatureLayerInfoWindowProperty("fieldData", t) : (this._fieldData = t,
            !0 === this._parentObj.isInfoShow && this._createInfoWindow())
        }
        get fields() {
            for (var t = [], e = 0; e < this._fieldData.length; e++)
                t.push(this._fieldData[e].field);
            return t
        }
        set fields(t) {
            if ("FeatureLayer" === this._parentObj.type)
                this._setFeatureLayerInfoWindowProperty("fields", t);
            else {
                for (var e = 0; e < this._fieldData.length; e++)
                    this._fieldData[e].field = t[e];
                !0 === this._parentObj.isInfoShow && this._createInfoWindow()
            }
        }
        get alias() {
            for (var t = [], e = 0; e < this._fieldData.length; e++)
                t.push(this._fieldData[e].alias);
            return t
        }
        set alias(t) {
            if ("FeatureLayer" === this._parentObj.type)
                this._setFeatureLayerInfoWindowProperty("alias", t);
            else {
                for (var e = 0; e < this._fieldData.length; e++)
                    this._fieldData[e].alias = t[e];
                !0 === this._parentObj.isInfoShow && this._createInfoWindow()
            }
        }
        get url() {
            for (var t = [], e = 0; e < this._fieldData.length; e++)
                t.push(this._fieldData[e].url);
            return t
        }
        set url(t) {
            if ("FeatureLayer" === this._parentObj.type)
                this._setFeatureLayerInfoWindowProperty("url", t);
            else {
                for (var e = 0; e < this._fieldData.length; e++)
                    this._fieldData[e].url = t[e];
                !0 === this._parentObj.isInfoShow && this._createInfoWindow()
            }
        }
        get target() {
            for (var t = [], e = 0; e < this._fieldData.length; e++)
                t.push(this._fieldData[e].target);
            return t
        }
        set target(t) {
            if ("FeatureLayer" === this._parentObj.type)
                this._setFeatureLayerInfoWindowProperty("target", t);
            else {
                for (var e = 0; e < this._fieldData.length; e++)
                    this._fieldData[e].target = t[e];
                !0 === this._parentObj.isInfoShow && this._createInfoWindow()
            }
        }
        get customHtml() {
            return this._customHtml
        }
        set customHtml(t) {
            "FeatureLayer" === this._parentObj.type ? this._setFeatureLayerInfoWindowProperty("customHtml", t) : (this._customHtml = t,
            !0 === this._parentObj.isInfoShow && (this.destroy(),
            this._createInfoWindow()))
        }
        get standardHtml() {
            var t;
            if ("standard" === this._type) {
                var e = ""
                  , n = "";
                "blue" === this._style ? (e = "<li class='info-item' style = 'font-size:14px;padding: 8px 0px;'><div class='info-key' style = 'width: 66px;float:left;text-align: left;text-align:center;overflow: hidden;text-overflow:ellipsis;white-space:nowrap;'>&key</div><div class='info-value' style = 'margin-left: 66px;'>:  {{&value}}</div></li>",
                n = "<div class='sign' id='PopupBoard' style='width: 210px;background-color: rgba(192, 192, 192, 0.6);color: #cccccc;top: 0;left: 0;z-index: 100;display: inline-block;position: absolute;'><div class = 'headline' style = 'font-size:16px;color:rgb(238,238,238);padding: 4px 4px 4px 12px;background:linear-gradient(rgba(0,0,150,0.9), rgba(0,0,100,0.7));line-height:40px;'>&title</div><div class = 'info' style = 'background-color: rgba(0,0,150, 0.8);padding: 10px 8px 10px 8px;'><ul class='info-list' style = 'color:#eeeeee;list-style: none;margin:0;padding: 0;' >&item </ul></div><div class='point-top' style='position: absolute;top: -3px;right: 3px;cursor:pointer;'>x</div></div>") : "white" === this._style ? (e = "<li class='info-item' style = 'font-size:14px;padding: 8px 0px;'><div class='info-key' style = 'width: 66px;float:left;text-align: left;text-align:center;overflow: hidden;text-overflow:ellipsis;white-space:nowrap;'>&key</div><div class='info-value' style = 'margin-left: 66px;'>:  {{&value}}</div></li>",
                n = "<div class='sign' id='PopupBoard' style='width: 210px;background-color: rgba(192, 192, 192, 0.6);color: #cccccc;top: 0;left: 0;z-index: 100;display: inline-block;position: absolute;'><div class = 'headline' style = 'font-size:16px;color:rgb(69,69,69);padding: 4px 4px 4px 12px;background:linear-gradient(rgba(238,238,238,0.9), rgba(238,238,238,0.7));line-height:40px;'>&title</div><div class = 'info' style = 'background-color: rgba(200,200,200, 0.8);padding: 10px 8px 10px 8px;'><ul class='info-list' style = 'color:#454545;list-style: none;margin:0;padding: 0;' >&item </ul></div><div class='point-top' style='position: absolute;top: -3px;right: 3px;cursor:pointer;'>x</div></div>") : (e = "<li class='info-item' style = 'font-size:14px;padding: 8px 0px;'><div class='info-key' style = 'width: 66px;float:left;text-align: left;text-align:center;overflow: hidden;text-overflow:ellipsis;white-space:nowrap;'>&key</div><div class='info-value' style = 'margin-left: 66px;'>:  {{&value}}</div></li>",
                n = "<div class='sign' id='PopupBoard' style='width: 210px;background-color: rgba(192, 192, 192, 0.6);color: #cccccc;top: 0;left: 0;z-index: 100;display: inline-block;position: absolute;'><div class = 'headline' style = 'font-size:16px;color:rgb(250, 250, 250);padding: 4px 4px 4px 12px;background:linear-gradient(rgba(0,0,0, 0.9), rgba(0,0,0,0.7));line-height:40px;'>&title</div><div class = 'info' style = 'background-color: rgba(0,0,0, 0.8);padding: 10px 8px 10px 8px;'><ul class='info-list' style = 'color:#cccccc;list-style: none;margin:0;padding: 0;' >&item </ul></div><div class='point-top' style='position: absolute;top: -3px;right: 3px;cursor:pointer;'>x</div></div>"),
                "blue" === this._style ? (e = "<li class='info-item' style = 'font-size: 14px;\n      padding: 8px 0px;'>\n       <div class='info-key'  style = 'width: 50px;\n        float: left;\n        text-align: center;\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap;'>&key</div>\n       <div class='info-value' style = 'width: 125px;\n        white-space: nowrap;\n        text-overflow: ellipsis;\n        overflow: hidden;'>:  {{&value}}</div>\n     </li>",
                n = "<div class='sign' id='PopupBoard' style='width: 210px;\n         background-color: rgba(192, 192, 192, 0);\n         color: rgb(204, 204, 204);\n         top: 272px;\n         left: 754px;\n         z-index: 1020;\n         display: block;\n         position: absolute;\n         backdrop-filter: blur(5px);\n         border-radius: 10px;\n         visibility: visible;'>\n       <div class = 'headline' style = 'font-size: 13px;\n        color: #cccccc;\n        background: rgba(43, 135, 230, 0.8);\n        padding: 8px 4px 8px 18px;\n        line-height: 20px;\n        border-bottom: 1px solid rgba(43,135,230, 0.7);\n        border-radius: 9px 9px 0px 0px;'>&title</div>\n       <div class = 'info' style = 'background-color: rgba(43,135,230, 0.6);\n       padding: 8px 10px;\n       border-radius: 0px 0px 9px 9px;'>\n         <ul class='info-list' style = ' color: #eeeeee;\n          list-style: none;\n          margin-left: 15px;\n         ' >&item </ul>\n       </div>\n       <div class='point-top' style='position: absolute;top: 0px;right: 8px;cursor:pointer;'>×</div>\n     </div>") : "white" === this._style ? (e = "<li class='info-item' style = 'font-size:14px;padding: 8px 0px;'>\n          <div class='info-key' style = 'width: 66px;float:left;text-align:center;overflow: hidden;text-overflow:ellipsis;white-space:nowrap;'>&key</div>\n          <div class='info-value' style = 'margin-left: 66px;width: 125px; white-space: nowrap; text-overflow: ellipsis;overflow: hidden;'>: &value</div>\n        </li>",
                n = "<div class='sign' id='PopupBoard' style='width: 210px;background-color: rgba(192, 192, 192, 0.6);color: #cccccc;top: 0;left: 0;z-index: 100;display: inline-block;position: absolute;border-radius:5px'>\n          <div class = 'headline' style = 'font-size:12px;color:rgb(69,69,69);border-radius: 5px 5px 0px 0px;padding: 4px 4px 4px 12px;background:linear-gradient(rgba(238,238,238,0.9), rgba(238,238,238,0.7));line-height:20px;'>&title</div>\n          <div class = 'info' style = 'background-color: rgba(200,200,200, 0.8);padding: 10px 8px 10px 8px;'>\n            <ul class='info-list' style = 'color:#454545;list-style: none;margin:0;padding: 0;' >&item </ul>\n          </div>\n          <div class='point-top' style='position: absolute;top: 0px;right: 8px;cursor:pointer;>×</div>\n        </div>",
                e = "<li class='info-item' style = 'font-size: 14px;\n        padding: 8px 0px;'>\n         <div class='info-key'  style = 'width: 50px;\n          float: left;\n          text-align: center;\n          overflow: hidden;\n          text-overflow: ellipsis;\n          white-space: nowrap;'>&key</div>\n         <div class='info-value' style = 'width: 125px;\n          white-space: nowrap;\n          text-overflow: ellipsis;\n          overflow: hidden;'>:  {{&value}}</div>\n       </li>",
                n = "<div class='sign' id='PopupBoard' style='width: 210px;\n           background-color: rgba(192, 192, 192, 0.3);\n           color: #ccccc;\n           top: 272px;\n           left: 754px;\n           z-index: 1020;\n           display: block;\n           position: absolute;\n           backdrop-filter: blur(5px);\n           border-radius: 10px;\n           visibility: visible;'>\n         <div class = 'headline' style = 'font-size: 13px;\n          color: rgb(69,69,69);\n          background:linear-gradient(rgba(238,238,238,0.9), rgba(238,238,238,0.7));\n          padding: 8px 4px 8px 18px;\n          line-height: 20px;\n          border-bottom: 1px solid rgba(200, 200, 200, 0.75);\n          border-radius: 9px 9px 0px 0px;'>&title</div>\n         <div class = 'info' style = 'background-color: rgba(200,200,200,0.3);\n         padding: 8px 10px;\n         border-radius: 0px 0px 9px 9px;'>\n           <ul class='info-list' style = ' color: rgba(0,0,0,0.8);\n            list-style: none;\n            margin-left: 15px;\n           ' >&item </ul>\n         </div>\n         <div class='point-top' style='position: absolute;top: 0px;right: 8px;cursor:pointer;'>×</div>\n       </div>") : (e = "<li class='info-item' style = 'font-size: 14px;\n         padding: 8px 0px;'>\n          <div class='info-key'  style = 'width: 50px;\n           float: left;\n           text-align: center;\n           overflow: hidden;\n           text-overflow: ellipsis;\n           white-space: nowrap;'>&key</div>\n          <div class='info-value' style = 'width: 125px;\n           white-space: nowrap;\n           text-overflow: ellipsis;\n           overflow: hidden;'>:  {{&value}}</div>\n        </li>",
                n = "<div class='sign' id='PopupBoard' style='width: 210px;\n            background-color: rgba(192, 192, 192, 0);\n            color: rgb(204, 204, 204);\n            top: 272px;\n            left: 754px;\n            z-index: 1020;\n            display: block;\n            position: absolute;\n            backdrop-filter: blur(5px);\n            border-radius: 10px;\n            visibility: visible;'>\n          <div class = 'headline' style = 'font-size: 13px;\n           color: #cccccc;\n           background: rgba(0, 0, 0, 0.8);\n           padding: 8px 4px 8px 18px;\n           line-height: 20px;\n           border-bottom: 1px solid rgba(0, 0, 0, 0.75);\n           border-radius: 9px 9px 0px 0px;'>&title</div>\n          <div class = 'info' style = 'background-color: rgba(0, 0, 0, 0.7);\n          padding: 8px 10px;\n          border-radius: 0px 0px 9px 9px;'>\n            <ul class='info-list' style = ' color: #cccccc;\n             list-style: none;\n             margin-left: 15px;\n            ' >&item </ul>\n          </div>\n          <div class='point-top' style='position: absolute;top: 0px;right: 8px;cursor:pointer;'>×</div>\n        </div>");
                for (var r = "", a = 0; a < this._fieldData.length; a++)
                    this._fieldData[a].alias ? r += e.replace("&key", this._fieldData[a].alias).replace("&value", this._fieldData[a].field) : r += e.replace("&key", this._fieldData[a].field).replace("&value", this._fieldData[a].field);
                t = n.replace("&item", r).replace("&title", this._title)
            }
            return t
        }
        _setFeatureLayerInfoWindowProperty(t, e) {
            "FeatureLayer" === this._parentObj.type && (this._parentObj.children.forEach(n=>{
                n.infoWindow[t] = e
            }
            ),
            this["_" + t] = e)
        }
    }
    ;
    var Jt = class {
        constructor(t, e) {
            if (THING.Utils.isNull(e) && (e = {}),
            this._parent = t,
            this._name = e.name || "geoLabel_" + r.a.getUUID(),
            this._fontSize = THING.Utils.parseValue(e.fontSize, 18),
            this._text = THING.Utils.parseValue(e.text, ""),
            this._offset = e.offset || [0, 0],
            this._position = e.position || [0, 0, 0],
            this._imageUrl = e.imageUrl,
            this._imagePadding = [0, 0],
            this._imageUrl && (this._imagePadding = THING.Utils.parseValue(e.imagePadding, [0, 0])),
            this._fontColor = CMAP.Util.colorFormatNewToOld(e.fontColor) || [0, 0, 0],
            this._dropShadow = THING.Utils.parseValue(e.dropShadow, !1),
            this._dropShadowColor = CMAP.Util.colorFormatNewToOld(e.dropShadowColor) || [0, 0, 0],
            this._fontFamily = e.fontFamily || "Arial,Microsoft YaHei",
            this._visible = THING.Utils.parseValue(e.visible, !0),
            this._useSpriteMaterial = void 0 === e.useSpriteMaterial || e.useSpriteMaterial,
            this._keepSize = THING.Utils.parseValue(e.keepSize, !0),
            this._canvasScaleRatio = THING.Utils.parseValue(e.resolution, 2),
            this._inheritStyle = THING.Utils.parseValue(e.inheritStyle, !0),
            this._inheritScale = THING.Utils.parseValue(e.inheritScale, !1),
            this._alwaysOnTop = THING.Utils.parseValue(e.alwaysOnTop, !0),
            r.a.deepCopy(this._position),
            this._labelNode = new THREE.Group,
            void 0 === e.azimuth && (e.azimuth = e.modelAngle),
            "FeatureLayer" !== this._parent.type) {
                if (this._pivot = THING.Utils.parseValue(e.pivot, [.5, 1]),
                this._coordinates = r.a.convertWorldToLonlat(this._parent.position),
                this._azimuth = void 0 === e.azimuth ? 0 : e.azimuth,
                this._originLabelPosition = this._parent.position,
                this._parent.labelPosition)
                    this._originLabelPosition = this._parent.labelPosition;
                else if ("GeoPolygon" === this._parent.type || "GeoBuilding" === this._parent.type) {
                    let t = r.a._getPolygonCenterCoordinates(this._parent._multiPolygonCoordinates)
                      , e = this._parent.extrudeHeight + this._parent.offsetHeight;
                    Array.isArray(this._arrayOffsetHeight) && this._arrayOffsetHeight.length > 0 && (e += this._arrayOffsetHeight[0]),
                    this._originLabelPosition = CMAP.Util.convertLonlatToWorld(t, e)
                } else
                    "GeoFlyLine" === this._parent.type && (this._parent._topPos ? this._originLabelPosition = this._parent._topPos : this._originLabelPosition = this._parent.position);
                if (this._setLabelPosition(this.position),
                !t)
                    return void console.error("parentObj can not be null");
                this.init()
            }
        }
        _setLabelPosition(t) {
            this._labelNode.setPosition(this._originLabelPosition),
            M.a._setNodeAnglesByPosition(this._labelNode, this._originLabelPosition),
            this._labelNode.translate(t),
            this._labelPosition = this._labelNode.position.toArray()
        }
        get alwaysOnTop() {
            return this._alwaysOnTop
        }
        set alwaysOnTop(t) {
            if ("FeatureLayer" !== this._parent.type)
                this._alwaysOnTop = t,
                this._geoLabel.style.alwaysOnTop = t;
            else
                for (let e = 0; e < this._parent.children.length; e++)
                    this._parent.children[e].label.alwaysOnTop = t
        }
        get position() {
            return this._position
        }
        set position(t) {
            if ("FeatureLayer" !== this._parent.type)
                this._setLabelPosition(t),
                this._geoLabel.position = this._labelPosition;
            else
                for (let e = 0; e < this._parent.children.length; e++)
                    this._parent.children[e].label.position = t;
            this._position = t
        }
        get azimuth() {
            return this._azimuth
        }
        set azimuth(t) {
            if (this._azimuth = t,
            "FeatureLayer" !== this._parent.type)
                this._obj.angles = CMAP.Util.getAnglesFromLonlat(this._coordinates, this.azimuth);
            else
                for (let e = 0; e < this._parent.children.length; e++)
                    this._parent.children[e].label.azimuth = t
        }
        get fontSize() {
            return this._fontSize
        }
        set fontSize(t) {
            if (this._fontSize = t,
            "FeatureLayer" !== this._parent.type)
                this.updateLabel();
            else
                for (let e = 0; e < this._parent.children.length; e++)
                    this._parent.children[e].label.fontSize = t
        }
        get text() {
            return this._text
        }
        set text(t) {
            if (this._text = t,
            "FeatureLayer" !== this._parent.type)
                this.updateLabel();
            else
                for (let e = 0; e < this._parent.children.length; e++)
                    this._parent.children[e].label.text = t
        }
        get imagePadding() {
            return this._imagePadding
        }
        set imagePadding(t) {
            if (this._imagePadding = t,
            "FeatureLayer" !== this._parent.type)
                this.updateLabel();
            else
                for (let e = 0; e < this._parent.children.length; e++)
                    this._parent.children[e].label.imagePadding = t
        }
        get offset() {
            return this._offset
        }
        set offset(t) {
            if (this._offset = t,
            "FeatureLayer" !== this._parent.type)
                this.updateLabel();
            else
                for (let e = 0; e < this._parent.children.length; e++)
                    this._parent.children[e].label.offset = t
        }
        get fontColor() {
            return CMAP.Util.colorFormatOldToNew(this._fontColor)
        }
        set fontColor(t) {
            var e = CMAP.Util.colorFormatNewToOld(t);
            if (this._fontColor = e,
            "FeatureLayer" !== this._parent.type)
                this.updateLabel();
            else
                for (let e = 0; e < this._parent.children.length; e++)
                    this._parent.children[e].label.fontColor = t
        }
        get fontFamily() {
            return this._fontFamily
        }
        set fontFamily(t) {
            if (this._fontFamily = t,
            "FeatureLayer" !== this._parent.type)
                this.updateLabel();
            else
                for (let e = 0; e < this._parent.children.length; e++)
                    this._parent.children[e].label.fontFamily = t
        }
        get inheritScale() {
            return this._inheritScale
        }
        get inheritStyle() {
            return this._inheritStyle
        }
        get visible() {
            return this._visible
        }
        set visible(t) {
            if ("FeatureLayer" !== this._parent.type)
                this._visible = this._geoLabel.visible = t;
            else {
                for (let e = 0; e < this._parent.children.length; e++)
                    this._parent.children[e].label.visible = t;
                this._visible = t
            }
        }
        get dropShadow() {
            return this._dropShadow
        }
        set dropShadow(t) {
            if (this._dropShadow = t,
            "FeatureLayer" !== this._parent.type)
                this.updateLabel();
            else
                for (let e = 0; e < this._parent.children.length; e++)
                    this._parent.children[e].label.dropShadow = t
        }
        get dropShadowColor() {
            return CMAP.Util.colorFormatOldToNew(this._dropShadowColor)
        }
        set dropShadowColor(t) {
            var e = CMAP.Util.colorFormatNewToOld(t);
            if (this._dropShadowColor = e,
            "FeatureLayer" !== this._parent.type)
                this.updateLabel();
            else
                for (let e = 0; e < this._parent.children.length; e++)
                    this._parent.children[e].label.dropShadowColor = t
        }
        get keepSize() {
            return this._keepSize
        }
        set keepSize(t) {
            if ("FeatureLayer" !== this._parent.type)
                this._keepSize = this._geoLabel.keepSize = t;
            else
                for (let e = 0; e < this._parent.children.length; e++)
                    this._parent.children[e].label.keepSize = t
        }
        get useSpriteMaterial() {
            return this._useSpriteMaterial
        }
        set useSpriteMaterial(t) {
            if ("FeatureLayer" !== this._parent.type)
                this._useSpriteMaterial = this._geoLabel.useSpriteMaterial = t,
                this._geoLabel.parent.remove(this._geoLabel),
                this.init();
            else
                for (let e = 0; e < this._parent.children.length; e++)
                    this._parent.children[e].label.useSpriteMaterial = t
        }
        get imageUrl() {
            return this._imageUrl
        }
        set imageUrl(t) {
            this._imageUrl = t,
            this.updateLabel()
        }
        init() {
            var t = this._geoLabel = this._parent.app.create({
                type: "Marker",
                name: this._name + "_label",
                position: this._labelPosition,
                keepSize: this._keepSize,
                size: 1,
                pivot: this._pivot,
                parent: this._parent,
                useSpriteMaterial: this._useSpriteMaterial,
                visible: !1,
                inheritScale: this.inheritScale,
                inheritStyle: this.inheritStyle,
                autoEnsureParentsVisible: !1,
                style: {
                    alwaysOnTop: this._alwaysOnTop,
                    renderOrder: this._parent.renderOrder + .1
                }
            });
            !1 === this.useSpriteMaterial && t.rotateY(180),
            t.factor = .06 / this._canvasScaleRatio,
            t.inheritStyle = !1,
            this._obj = t,
            this.updateLabel()
        }
        _parseColor(t) {
            let e = 255 * t[0] | 0
              , n = 255 * t[1] | 0
              , r = 255 * t[2] | 0;
            return "rgb(&r,&g,&b)".replace("&r", e).replace("&g", n).replace("&b", r)
        }
        _setDropShadow(t) {
            this._dropShadow && (t.shadowBlur = 1,
            t.shadowOffsetX = 1,
            t.shadowOffsetY = 1,
            t.shadowColor = this._parseColor(this._dropShadowColor))
        }
        updateLabel() {
            var t = $t.build(this._text, this._parent._userData);
            this._canvas = t3djs.canvasManager.createCanvas(null, null, null),
            this._canvas.setFont(this._fontFamily, this._fontSize),
            this._canvas.setTextAlignment(1, 1),
            this._canvas.clear();
            var e = this._canvas.measureText(t);
            if (this._canvas.destroy(),
            e > 0) {
                let r = 1.02
                  , a = 1.02
                  , i = e * r + Math.abs(this._offset[0])
                  , o = this._fontSize * a + Math.abs(this._offset[1]);
                this._canvas = document.createElement("canvas"),
                this._canvas.width = this._canvasScaleRatio * Math.ceil(i + 2 * this._imagePadding[0]),
                this._canvas.height = this._canvasScaleRatio * Math.ceil(o + 2 * this._imagePadding[1]);
                const s = this._canvas.getContext("2d");
                if (s.font = this._canvasScaleRatio * this._fontSize + "px " + this._fontFamily,
                s.fillStyle = this._parseColor(this._fontColor),
                s.textAlign = "center",
                s.textBaseline = "middle",
                this._imageUrl) {
                    let i = this._canvasScaleRatio * Math.ceil(e * r + 2 * this._imagePadding[0])
                      , o = this._canvasScaleRatio * Math.ceil(this._fontSize * a + 2 * this._imagePadding[1]);
                    var n = new Image(i,o);
                    n.crossOrigin = "Anonymous",
                    n.src = this._imageUrl;
                    let l = this;
                    n.onload = function(e) {
                        let n = l._offset[0] < 0 ? 0 : l._offset[0]
                          , r = l._offset[1] > 0 ? 0 : Math.abs(l._offset[1]);
                        s.drawImage(e.target, l._canvasScaleRatio * n, l._canvasScaleRatio * r, e.target.width, e.target.height),
                        l._setDropShadow(s),
                        s.fillText(t, (l._canvas.width + l._canvasScaleRatio * l._offset[0]) / 2, (l._canvas.height - l._canvasScaleRatio * l._offset[1]) / 2),
                        l._geoLabel && (l._geoLabel.image = l._canvas,
                        l._geoLabel.visible = l._visible)
                    }
                } else
                    this._setDropShadow(s),
                    s.fillText(t, (this._canvas.width + this._canvasScaleRatio * this._offset[0]) / 2, (this._canvas.height - this._canvasScaleRatio * this._offset[1]) / 2),
                    this._geoLabel && (this._geoLabel.image = this._canvas,
                    this._geoLabel.visible = this._visible)
            }
        }
        destroy() {
            if ("FeatureLayer" !== this._parent.type)
                this._geoLabel && (delete this._geoLabel.parent._label,
                this._geoLabel.parent.remove(this._geoLabel),
                this._geoLabel.destroy(),
                this._geoLabel = null);
            else
                for (let t = 0; t < this._parent.children.length; t++)
                    this._parent.children[t].label.destroy()
        }
    }
    ;
    class Qt extends THING.BaseObject {
        constructor(t) {
            super(t),
            this.app = t,
            this.__canAcceptEvent__ = !0,
            this._style = new T(this),
            this.meshType = "Mesh",
            this._effectName = "glow"
        }
        setup(t) {
            this.isInfoShow = !1,
            this.inheritVisible = void 0 !== t.inheritVisible && t.inheritVisible,
            this.name = t.name || this.type + "_" + r.a.getUUID(),
            this.id = t.id || this.name,
            this._coordinates = t.coordinates,
            this._userData = void 0 === t.userData ? {} : t.userData,
            "GeoPoint" === this.type && (void 0 === t.azimuth && (t.azimuth = t.modelAngle),
            this._azimuth = void 0 === t.azimuth ? 0 : t.azimuth,
            this._pivot = void 0 === t.pivot ? [.5, .5] : t.pivot,
            this._pivotPixel = t.pivotPixel),
            this._setOffsetHeightAndField(t),
            this._initRenderer(t),
            this.node = this._layer = new THREE.Group,
            this.node.userData.forceBoundingBox = !0,
            this.visible = void 0 === t.visible || t.visible,
            this._complete = t.complete,
            this._beforeInit(),
            this.init(),
            this.setupUserData(t),
            this.setupParent(t),
            this._afterInit({
                renderer: this._renderer
            }),
            this.renderOrder = void 0 === t.renderOrder ? 0 : t.renderOrder,
            this._setupInfoWindow(t),
            this._setupLabel(t),
            "GeoPoint" === this.type && (t.complete = void 0),
            this.setupComplete(t)
        }
        _setupInfoWindow(t) {
            const e = this;
            t.infoWindow && (this.infoWindow = new Xt(this,t.infoWindow),
            "oftenShow" === this.infoWindow._displayMode && (this.isInfoShow = !0),
            this.app.on("MAPCLICK", function() {
                e.isInfoShow && "clickShow" === e.infoWindow._displayMode && (e.infoWindow.destroy(),
                e.isInfoShow = !1)
            }),
            this.app.on("INFOSHOW", t=>{
                this === t && (this.isInfoShow = this === t)
            }
            ))
        }
        _setOffsetHeightAndField(t) {
            this._offsetHeightAdded = THING.Utils.parseValue(t.offsetHeightAdded, 0),
            this._offsetHeightFactor = THING.Utils.parseValue(t.offsetHeightFactor, 1),
            this._offsetHeightAdded = this._offsetHeightAdded - 0,
            this._offsetHeightField = t.offsetHeightField,
            this._groundHeightField = t.groundHeightField,
            this._groundHeightFactor = THING.Utils.parseValue(t.groundHeightFactor, 1),
            this._offsetHeight = 0,
            THING.Utils.isNull(t.offsetHeight) ? this._setOffsetHeightFieldAndFactor(!0) : (THING.Utils.isNull(t.offsetHeight) && "GeoPoint" === this.type && !THING.Utils.isNull(t.height) && (t.offsetHeight = t.height),
            "number" != typeof t.offsetHeight || isNaN(t.offsetHeight) || (this._offsetHeight = t.offsetHeight))
        }
        _setArrayOffsetHeight(t) {}
        _getOffsetHeightByFieldAndFactor(t, e, n=1, r=0) {
            return THING.Utils.isNull(t[e]) || isNaN(t[e]) || "object" == typeof t[e] ? r : t[e] * n + r
        }
        _setOffsetHeightFieldAndFactor(t=!1) {
            let e = this._getOffsetHeightByFieldAndFactor(this.userData, this.offsetHeightField, this.offsetHeightFactor, this.offsetHeightAdded)
              , n = this._userData[this._groundHeightField];
            if (Array.isArray(n)) {
                if (this._arrayOffsetHeight = n.slice(0),
                Array.isArray(n[0]))
                    for (let t = 0; t < this._arrayOffsetHeight.length; t++)
                        for (let n = 0; n < this._arrayOffsetHeight[t].length; n++)
                            this._arrayOffsetHeight[t][n] *= this._groundHeightFactor,
                            this._arrayOffsetHeight[t][n] += e;
                else
                    for (let t = 0; t < this._arrayOffsetHeight.length; t++)
                        this._arrayOffsetHeight[t] *= this._groundHeightFactor,
                        this._arrayOffsetHeight[t] += e;
                t || this._setArrayOffsetHeight(this._arrayOffsetHeight),
                n = null
            } else
                n = this._getOffsetHeightByFieldAndFactor(this.userData, this._groundHeightField, this._groundHeightFactor),
                t ? this._offsetHeight = e + n : this.offsetHeight = e + n
        }
        createEdge() {
            this.edges = [];
            let t = [];
            return this.edgeMaterial = new THREE.MeshBasicMaterial,
            this.node.traverse(e=>{
                if (e.isMesh) {
                    let n = e.geometry;
                    window.EW && EW.setThreadsNumber(4);
                    let r = THING.App.current.edgesGeometriesManager.get(n);
                    if (r.isBufferGeometry) {
                        let t = new THREE.LineSegments(r,this.edgeMaterial);
                        e.parent.add(t),
                        e.__edgeLine = t,
                        this.edges.push(e.__edgeLine)
                    } else {
                        let n = r.then(t=>{
                            if (!n._break) {
                                let n = new THREE.LineSegments(t,this.edgeMaterial);
                                return e.parent.add(n),
                                e.__edgeLine = n,
                                this.edges.push(e.__edgeLine),
                                Promise.resolve(n)
                            }
                        }
                        );
                        t.push(r)
                    }
                }
            }
            ),
            Promise.all(t).then(t=>t)
        }
        _setupLabel(t) {
            t.label && (this.labelParam = t.label,
            this.label = this.labelParam)
        }
        canAcceptEvent(t) {
            return "update" === t.type || !(!t.object || !t.object.isChildOf(this))
        }
        get gravityCenter() {
            return this.massOfCenterCoordinates
        }
        get massOfCenterCoordinates() {
            return this._polygonInfo ? this._polygonInfo.gravityCenter : this.centerCoordinates
        }
        get centerCoordinates() {
            if (this._polygonInfo)
                return this._polygonInfo.center;
            var t = this.orientedBoundingBox.center;
            return CMAP.Util.convertWorldToLonlat(t)
        }
        get visible() {
            return this.node.visible
        }
        set visible(t) {
            this.node.visible = t,
            this.infoWindow && (this.infoWindow.visible = t),
            THING.App.current.rendererManager._mainRenderer.dirty(),
            THING.App.current.picker.needUpdate = !0
        }
        get coordinates() {
            return this._coordinates
        }
        get renderer() {
            return this._renderer
        }
        set renderOrder(t) {
            this.style.renderOrder = t
        }
        get renderOrder() {
            return this.style.renderOrder
        }
        createGeometry() {}
        createMesh() {}
        createMaterial() {}
        _initRenderer(t) {
            this._renderer = {}
        }
        _beforeInit(t) {}
        _afterInit(t) {
            this._updatePostEffect(t.renderer)
        }
        _setEffect(t, e, n) {
            for (let r = 0; r < this._getMeshes().length; r++) {
                let a = this._getMeshes()[r];
                M.a._updateEffect(a, t, e, n)
            }
            THING.App.current.rendererManager._mainRenderer.dirty()
        }
        _setFocusRegion(t) {
            t = Object.assign({}, {
                brightFactor: 1.2,
                darkFactor: .5
            }, t),
            this.app.rendererManager._mainRenderer.getPass("FocusRegion").darkFactor = t.darkFactor,
            this.app.rendererManager._mainRenderer.getPass("FocusRegion").brightFactor = t.brightFactor,
            this.node.traverse(function(t) {
                t.material && THING.App.current.effectManager.setEffect(t, "focusRegion", !0)
            })
        }
        _getMeshes() {
            var t = this
              , e = [];
            return this.node.traverse(function(n) {
                n.type && n.type === t.meshType && e.push(n)
            }),
            e
        }
        _setPostRadiusEffect(t) {
            this._setEffect("radialBlur", t)
        }
        _setPostRadialBlur2(t) {
            this._setEffect("radialBlur2", t)
        }
        _removeFocusRegion() {
            this.node.traverse(function(t) {
                t.material && THING.App.current.effectManager.removeEffect(t, "focusRegion")
            })
        }
        _getGeoObjectArray() {
            return [this]
        }
        updateMaterial() {}
        _updateEffect(t, e) {
            this._setEffect(this._effectName, t, e)
        }
        _updatePostEffect(t) {
            THING.Utils.isNull(t.effect) || this._updateEffect(t.effect, t.glowStrength),
            THING.Utils.isNull(t.postRadialBlur) || this._setPostRadiusEffect(t.postRadialBlur),
            THING.Utils.isNull(t.postRadialBlur2) || this._setPostRadialBlur2(t.postRadialBlur2),
            THING.App.current.rendererManager._mainRenderer.dirty()
        }
        updateRenderer(t) {
            this._updatePostEffect(t)
        }
        get offsetHeight() {
            return this._offsetHeight
        }
        set offsetHeight(t) {
            if (t !== this._offsetHeight) {
                var e = t - this._offsetHeight;
                this.translate([0, e, 0]),
                this._offsetHeight = t
            }
        }
        get offsetHeightField() {
            return this._offsetHeightField
        }
        set offsetHeightField(t) {
            this._offsetHeightField = t,
            this._setOffsetHeightFieldAndFactor(!1)
        }
        get offsetHeightFactor() {
            return this._offsetHeightFactor
        }
        set offsetHeightFactor(t) {
            this._offsetHeightFactor = t,
            this._setOffsetHeightFieldAndFactor(!1)
        }
        get offsetHeightAdded() {
            return this._offsetHeightAdded
        }
        set offsetHeightAdded(t) {
            this._offsetHeightAdded = t,
            this._setOffsetHeightFieldAndFactor(!1)
        }
        get groundHeightField() {
            return this._groundHeightField
        }
        set groundHeightField(t) {
            this._groundHeightField = t,
            this._setOffsetHeightFieldAndFactor(!1)
        }
        get groundHeightFactor() {
            return this._groundHeightFactor
        }
        set groundHeightFactor(t) {
            this._groundHeightFactor = t,
            this._setOffsetHeightFieldAndFactor(!1)
        }
        get label() {
            return this._label
        }
        set label(t) {
            this._label && this._label.destroy(),
            t && (t.__proto__ === Jt.prototype ? this._label = t : (this.labelParam = t,
            this._label = new Jt(this,t)))
        }
        get style() {
            return this._style
        }
    }
    THING.factory.registerClass("GeoObject", Qt);
    var Zt = Qt
      , te = {
        createCanvas: ()=>({
            canvas: document.createElement("canvas"),
            image: document.createElement("img")
        }),
        createSymbol(t, e) {
            var n = void 0 === e.maxRatio ? .1 : e.maxRatio
              , r = void 0 === e.lineWidth ? 20 : 20 * e.lineWidth
              , a = THING.Utils.parseValue(e.width, 256)
              , i = THING.Utils.parseValue(e.height, 256)
              , o = e.color ? this._colorToRgba(e.color) : "rgba(255,0,0,1)"
              , s = e.lineColor ? this._colorToRgba(e.lineColor) : "rgba(0,0,255,1)"
              , l = e.type || "circle";
            t.width = a,
            t.height = i,
            t.style.position = "absolute",
            t.style.left = "0px",
            t.style.top = "0px";
            var u = t.getContext("2d");
            u.clearRect(0, 0, t.width, t.height),
            "circle" === l ? this.createCircle(u, a, i, o, s, r, n) : "rectangle" === l ? this.createRectangle(u, a, i, o, s, r, n) : "cross" === l ? this.createCross(u, a, i, o, s, r, n) : "triangle" === l && this.createTriangle(u, a, i, o, s, r, n)
        },
        createCircle(t, e, n, r, a, i, o) {
            i = i / e > o ? o * e : i,
            t.beginPath();
            var s = e / 2
              , l = n / 2
              , u = n / 2 - 2 * o * e;
            t.arc(s, l, u, 0, 2 * Math.PI, !1),
            t.fillStyle = r,
            t.fill(),
            i && (t.strokeStyle = a,
            t.lineWidth = i,
            t.stroke())
        },
        createRectangle(t, e, n, r, a, i, o) {
            i = i / e > o ? o * e : i,
            t.beginPath();
            var s = o * e
              , l = o * n
              , u = e * (1 - 2 * o)
              , c = n * (1 - 2 * o);
            t.rect(s, l, u, c),
            t.fillStyle = r,
            t.fill(),
            i && (t.strokeStyle = a,
            t.lineWidth = i,
            t.stroke())
        },
        createCross(t, e, n, r, a, i, o) {
            i = i / e > o ? o * e : i,
            t.beginPath(),
            t.strokeStyle = a,
            t.lineWidth = i,
            t.moveTo(e / 2, n * o),
            t.lineTo(e / 2, n - n * o),
            t.moveTo(e * o, n / 2),
            t.lineTo(e - e * o, n / 2),
            i && t.stroke()
        },
        createTriangle(t, e, n, r, a, i, o) {
            i = i / e > o ? o * e : i,
            t.beginPath(),
            t.fillStyle = r,
            t.strokeStyle = a,
            t.lineWidth = i,
            t.moveTo(e / 2, n * o),
            t.lineTo(e * o, n - n * o),
            t.lineTo(e - e * o, n - n * o),
            t.lineTo(e / 2, n * o),
            t.fill(),
            i && t.stroke()
        },
        _colorToRgba(t) {
            var e = t
              , n = 1;
            return t.length && 4 === t.length && (e = [t[0], t[1], t[2]],
            n = t[3]),
            "rgba(" + e.map(t=>255 * t).toString() + "," + n + ")"
        },
        getImage(t) {
            var e = new Image;
            return e.src || (e.width = t.width,
            e.height = t.height),
            e.src = t.toDataURL("image/png"),
            e
        }
    };
    var ee = class extends Dt {
        constructor(t, e) {
            super(t, e),
            this._object = this._geoPoint = t,
            this._type = THING.Utils.parseValue(e.type, "image"),
            this._url = e.url,
            this._size = THING.Utils.parseValue(e.size, 1),
            this._vectorType = THING.Utils.parseValue(e.vectorType, "circle"),
            this._opacity = THING.Utils.parseValue(e.opacity, 1),
            this._color = CMAP.Util.colorFormatNewToOld(e.color, this._opacity) || [1, 1, 1, 1],
            this._lineWidth = THING.Utils.parseValue(e.lineWidth, 2),
            this._lineOpacity = THING.Utils.parseValue(e.lineOpacity, 1),
            this._lineColor = CMAP.Util.colorFormatNewToOld(e.lineColor, this._lineOpacity) || [1, 1, 1, 1];
            let n = "model" !== this._type
              , r = "model" !== this._type;
            if (this._keepSize = THING.Utils.parseValue(e.keepSize, n),
            this._rotateSpeed = THING.Utils.parseValue(e.rotateSpeed, 0),
            this._useSpriteMaterial = THING.Utils.parseValue(e.useSpriteMaterial, !0),
            this._alwaysOnTop = THING.Utils.parseValue(e.alwaysOnTop, r),
            this._playAnimation = THING.Utils.parseValue(e.playAnimation, !1),
            this._animationName = THING.Utils.parseValue(e.animationName, ""),
            this._animationLoopType = THING.Utils.parseValue(e.animationLoopType, THING.LoopType.Repeat),
            this._useVerticalLine = THING.Utils.parseValue(e.useVerticalLine, !1),
            this._verticalLineWidth = THING.Utils.parseValue(e.verticalLineWidth, 2),
            this._verticalLineImageUrl = e.verticalLineImageUrl,
            this._getSymbolByRenderer(),
            "vector" === this._type) {
                var a = te.createCanvas().canvas;
                te.createSymbol(a, this._symbol),
                this._canvas = a
            }
            this._useColor = THING.Utils.parseValue(e.useColor, !1)
        }
        get useVerticalLine() {
            return this._useVerticalLine
        }
        get verticalLineImageUrl() {
            return this._verticalLineImageUrl
        }
        get verticalLineWidth() {
            return this._verticalLineWidth
        }
        get playAnimation() {
            return this._playAnimation
        }
        set playAnimation(t) {
            if (this._object && "FeatureLayer" === this._object.type)
                this._setFeatureLayerProperty("playAnimation", t);
            else {
                if ("model" !== this._type)
                    return;
                this._playAnimation !== t && (this._playAnimation = t,
                this._playAnimation ? this._geoPoint._obj.playAnimation({
                    name: this._animationName,
                    loopType: this._animationLoopType
                }) : this._geoPoint._obj.stopAnimation())
            }
        }
        get animationName() {
            return this._animationName
        }
        set animationName(t) {
            if (this._object && "FeatureLayer" === this._object.type)
                this._setFeatureLayerProperty("animationName", t);
            else {
                if ("model" !== this._type)
                    return;
                this._animationName !== t && (this._animationName = t,
                this._playAnimation ? this._geoPoint._obj.playAnimation({
                    name: this._animationName,
                    loopType: this._animationLoopType
                }) : this._geoPoint._obj.stopAnimation())
            }
        }
        get animationLoopType() {
            return this._animationLoopType
        }
        set animationLoopType(t) {
            if (this._object && "FeatureLayer" === this._object.type)
                this._setFeatureLayerProperty("animationLoopType", t);
            else {
                if ("model" !== this._type)
                    return;
                this._animationLoopType !== t && (this._animationLoopType = t,
                this._playAnimation ? this._geoPoint._obj.playAnimation({
                    name: this._animationName,
                    loopType: this._animationLoopType
                }) : this._geoPoint._obj.stopAnimation())
            }
        }
        get type() {
            return this._type
        }
        set type(t) {
            if (this._object && "FeatureLayer" === this._object.type)
                this._setFeatureLayerProperty("type", t);
            else {
                if (this._geoPoint._obj.destroy(),
                this._type = t,
                "vector" === t) {
                    var e = te.createCanvas().canvas;
                    this._getSymbolByRenderer(),
                    te.createSymbol(e, this._symbol),
                    this._canvas = e
                }
                this._geoPoint.init()
            }
        }
        get url() {
            return this._url
        }
        set url(t) {
            if (this._object && "FeatureLayer" === this._object.type)
                this._setFeatureLayerProperty("url", t);
            else if (this._url !== t) {
                var e = this._geoPoint._obj;
                "image" === this._type ? (e.one("urlchange", function(t) {
                    t.object.factor = t.image ? .5 / t.image.width : .5 / 256
                }),
                e.url = t) : "model" === this._type && e.loadModelResource({
                    url: t,
                    complete: function(t) {
                        const e = t.object.parent.renderer;
                        e._playAnimation && t.object.playAnimation({
                            name: e._animationName,
                            loopType: e._animationLoopType
                        })
                    }
                }),
                this._url = t
            }
        }
        get keepSize() {
            return this._keepSize
        }
        set keepSize(t) {
            if (this._object && "FeatureLayer" === this._object.type)
                this._setFeatureLayerProperty("keepSize", t);
            else {
                if ("model" === this._type)
                    return;
                this._keepSize !== t && (this._geoPoint._obj.keepSize = t,
                this._keepSize = t)
            }
        }
        get alwaysOnTop() {
            return this._alwaysOnTop
        }
        set alwaysOnTop(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("alwaysOnTop", t) : this._alwaysOnTop !== t && (this._geoPoint._obj.style.alwaysOnTop = t,
            this._alwaysOnTop = t)
        }
        get useSpriteMaterial() {
            return this._useSpriteMaterial
        }
        get rotateSpeed() {
            return this._rotateSpeed
        }
        set rotateSpeed(t) {
            if (this._object && "FeatureLayer" === this._object.type)
                this._setFeatureLayerProperty("rotateSpeed", t);
            else {
                if ("model" === this._type)
                    return;
                this._rotateSpeed !== t && (this._geoPoint.setRotation(t),
                this._rotateSpeed = t)
            }
        }
        get size() {
            return this._size
        }
        set size(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("size", t) : this._size !== t && ("image" === this.type || "vector" === this.type ? this._geoPoint._obj.size = t : "model" === this.type && (Array.isArray(t) ? this._geoPoint._obj.scale = t : this._geoPoint._obj.scale = [t, t, t]),
            this._size = t)
        }
        get color() {
            return CMAP.Util.colorFormatOldToNew(this._color)
        }
        set color(t) {
            if (this._object && "FeatureLayer" === this._object.type)
                this._setFeatureLayerProperty("color", t, !0, this._opacity);
            else {
                var e = CMAP.Util.colorFormatNewToOld(t, this._opacity);
                JSON.stringify(e) !== JSON.stringify(this._color) && (Array.isArray(t) && 4 === t.length && (this._opacity = t[3]),
                this._color = e,
                "vector" === this._type ? this._setSymbol({
                    color: e
                }) : this._useColor && (this._object._obj.style.color = e))
            }
        }
        get useColor() {
            return this._useColor
        }
        set useColor(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("useColor", t) : ("vector" !== this._type && (this._object._obj.style.color = t ? this._color : null),
            this._useColor = t)
        }
        get opacity() {
            return this._opacity
        }
        set opacity(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("opacity", t) : t !== this._opacity && (this._opacity = t,
            "vector" === this.type ? (this._color[3] = t,
            this._setSymbol({
                color: this._color
            })) : this._object._obj.style.opacity = t)
        }
        get lineColor() {
            return CMAP.Util.colorFormatOldToNew(this._lineColor)
        }
        set lineColor(t) {
            if (this._object && "FeatureLayer" === this._object.type)
                this._setFeatureLayerProperty("lineColor", t, !0, this._lineOpacity);
            else {
                var e = CMAP.Util.colorFormatNewToOld(t, this._lineOpacity);
                JSON.stringify(e) !== JSON.stringify(this._lineColor) && (this._setSymbol({
                    lineColor: e
                }),
                Array.isArray(t) && 4 === t.length && (this._lineOpacity = t[3]),
                this._lineColor = e)
            }
        }
        get lineOpacity() {
            return this._lineOpacity
        }
        set lineOpacity(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("lineOpacity", t) : t !== this._lineOpacity && (this._lineOpacity = t,
            this._lineColor[3] = t,
            this._setSymbol({
                lineColor: this._lineColor
            }))
        }
        get lineWidth() {
            return this._lineWidth
        }
        set lineWidth(t) {
            if (this._object && "FeatureLayer" === this._object.type)
                this._setFeatureLayerProperty("lineWidth", t);
            else {
                if (t > 2)
                    return void THING.Utils.warn("点标记边线最大宽度为2");
                this._lineWidth !== t && (this._setSymbol({
                    lineWidth: t
                }),
                this._lineWidth = t)
            }
        }
        get vectorType() {
            return this._vectorType
        }
        set vectorType(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("vectorType", t) : (this._vectorType !== t && this._setSymbol({
                vectorType: t,
                type: t
            }),
            this._vectorType = t)
        }
        _setSymbol(t) {
            if ("vector" === this.type) {
                var e = this._updateSymbol(t);
                if (this._symbol = e,
                this._canvas)
                    te.createSymbol(this._canvas, e),
                    this._geoPoint._obj.image = te.getImage(this._canvas);
                else {
                    var n = te.createCanvas().canvas;
                    te.createSymbol(n, e),
                    this._geoPoint._obj.image = te.getImage(n),
                    this._canvas = n
                }
            }
        }
        _updateSymbol(t) {
            var e = {};
            return Object.assign(e, this._symbol, t),
            e.vectorType && (e.type = e.vectorType),
            e
        }
        _getSymbolByRenderer() {
            this._symbol = {
                type: this._vectorType,
                color: this._color,
                lineWidth: this._lineWidth,
                lineColor: this._lineColor
            }
        }
    }
    ;
    class ne extends Zt {
        constructor(t) {
            super(t)
        }
        _initRenderer(t) {
            t.renderer || (t.renderer = {}),
            this._renderer = new ee(this,t.renderer)
        }
        _beforeInit() {
            this._obj = void 0
        }
        canAcceptEvent(t) {
            if ("update" === t.type)
                return !0;
            if (t.object) {
                for (let e = 0; e < t.object.parents.length; e++)
                    if (t.object.parents[e].__canAcceptEvent__)
                        return t.object.parents[e];
                if (t.object.isChildOf(this))
                    return !0
            }
            return !1
        }
        moveGeoPath(t) {
            var e = []
              , n = t.path;
            n.length > 1 && (n.map(function(t) {
                var n = r.a.convertLonlatToWorld(t);
                e.push(n)
            }),
            this.movePath({
                isEarth: !0,
                orientToPath: void 0 === t.orientToPath || t.orientToPath,
                orientToPathDegree: void 0 === t.orientToPathDegree ? 0 : t.orientToPathDegree,
                turnSpeed: t.turnSpeed,
                path: e,
                delayTime: THING.Utils.parseValue(t.delayTime, 0),
                time: THING.Utils.parseValue(t.time, 5e3),
                loopType: t.loopType || THING.LoopType.No,
                lerpType: void 0 === t.lerpType ? THING.LerpType.Linear.None : t.lerpType,
                complete: function() {
                    t.complete && t.complete.call()
                }
            }))
        }
        _checkVisible() {
            this._realVisible && (this._layer.visible = ht.a.isPositionVisible(this.app, this.coordinates))
        }
        get coordinates() {
            return this._coordinates
        }
        set coordinates(t) {
            this._coordinates = t,
            this.position = r.a.convertLonlatToWorld(t),
            this.infoWindow && (this.infoWindow.offset = this.infoWindow._offset)
        }
        get azimuth() {
            return this._azimuth
        }
        set azimuth(t) {
            this._azimuth = t,
            this.angles = CMAP.Util.getAnglesFromLonlat(this.coordinates, this.azimuth)
        }
        get visible() {
            return this._realVisible
        }
        set visible(t) {
            this._realVisible = t,
            super.visible = t
        }
        get height() {
            return this.offsetHeight
        }
        set height(t) {
            this.offsetHeight = t
        }
        get offsetHeight() {
            return this._offsetHeight
        }
        set offsetHeight(t) {
            this.position = r.a.convertLonlat2World(this.coordinates, t),
            this._offsetHeight = t
        }
        get pivot() {
            return this._pivot
        }
        set pivot(t) {
            "image" !== this.renderer.type && "vector" !== this.renderer.type || (this._obj.pivot = t),
            this._pivotPixel = this._obj.pivotPixel,
            this._pivot = t
        }
        get pivotPixel() {
            return this._pivotPixel
        }
        set pivotPixel(t) {
            "image" !== this.renderer.type && "vector" !== this.renderer.type || (this._obj.pivotPixel = t),
            this._pivot = this._obj.pivot,
            this._pivotPixel = t
        }
        destroy() {
            this._renderer = null,
            this._updaterName && this.app.off("update", null, this._updaterName),
            super.destroy()
        }
        updateRenderer(t) {
            for (let e in t)
                this.renderer[e] = t[e]
        }
        setRotation(t) {
            "model" !== this.renderer.type && this._obj.style.setUVAnimation({
                rotationSpeed: t,
                uvDiscard: !0
            })
        }
        init() {
            var t = this
              , e = r.a.convertLonlat2World(this.coordinates, this.offsetHeight)
              , n = r.a._getQuaternionFromPosition(this.coordinates[0], e, this._azimuth);
            if (this.position = e,
            this.node.quaternion.set(n.x, n.y, n.z, n.w),
            "image" === this.renderer.type) {
                var a = this.app.create({
                    type: "Marker",
                    name: this.name + "_Marker",
                    url: this.renderer.url,
                    visible: !1,
                    autoEnsureParentsVisible: !1,
                    useSpriteMaterial: this.renderer.useSpriteMaterial,
                    keepSize: this.renderer.keepSize,
                    size: this.renderer.size,
                    style: {
                        opacity: this.renderer.opacity,
                        alwaysOnTop: this.renderer.alwaysOnTop
                    },
                    parent: this,
                    inheritVisible: !1,
                    complete: function(e) {
                        var n = e.object
                          , r = n.parent;
                        if (n.factor = n.image ? .5 / n.image.width : .5 / 256,
                        n.visible = !0,
                        n.pivot = t.pivot,
                        t.pivotPixel && (n.pivotPixel = t.pivotPixel),
                        t._pivotPixel = n.pivotPixel,
                        r.style.renderOrder = r.renderOrder,
                        n.style.setUVAnimation({
                            rotationSpeed: t.renderer.rotateSpeed,
                            uvDiscard: !0
                        }),
                        r.renderer.useColor && r.renderer._color && (n.style.color = r.renderer._color),
                        r.renderer.postRadiusEffect && r._setPostRadiusEffect(!0),
                        r.renderer.useVerticalLine) {
                            var a = [[r.coordinates, r.coordinates]]
                              , i = {
                                imageUrl: r.renderer.verticalLineImageUrl,
                                type: "image",
                                lineType: "Plane",
                                width: r.renderer.verticalLineWidth
                            }
                              , o = r.app.create({
                                type: "GeoLine",
                                renderer: i,
                                parent: r.app.root,
                                coordinates: a,
                                heightArray: [0, r.offsetHeight]
                            });
                            r.add(o)
                        }
                        r._complete && setTimeout(()=>{
                            e.object = r,
                            r._complete.call(r, e)
                        }
                        , 1)
                    }
                });
                this._obj = a,
                this._updateFunc = function(t) {
                    return function() {
                        t._checkVisible.call(t)
                    }
                }(this),
                this._updaterName = this.name + "_updater_" + r.a.getUUID(),
                this.app.on("update", this._updateFunc, this._updaterName)
            } else if ("vector" === this.renderer.type) {
                var i = this.app.create({
                    type: "Marker",
                    name: this.name + "_Marker",
                    canvas: this.renderer._canvas,
                    visible: !1,
                    useSpriteMaterial: this.renderer.useSpriteMaterial,
                    keepSize: this.renderer.keepSize,
                    autoEnsureParentsVisible: !1,
                    size: this.renderer.size,
                    style: {
                        alwaysOnTop: this.renderer.alwaysOnTop
                    },
                    parent: this,
                    inheritVisible: !1,
                    complete: function(e) {
                        var n = e.object
                          , r = n.parent;
                        n.factor = n.image ? .5 / n.image.width : .5 / 256,
                        n.visible = !0,
                        n.pivot = t.pivot,
                        t.pivotPixel && (n.pivotPixel = t.pivotPixel),
                        t._pivotPixel = n.pivotPixel,
                        n.style.setUVAnimation({
                            rotationSpeed: t.renderer.rotateSpeed,
                            uvDiscard: !0
                        }),
                        r.renderer.postRadiusEffect && r._setPostRadiusEffect(!0),
                        r.style.renderOrder = r.renderOrder,
                        r._complete && setTimeout(()=>{
                            e.object = r,
                            r._complete.call(r, e)
                        }
                        , 1)
                    },
                    error: (t,e)=>{
                        e && (e._loadedError = !0)
                    }
                });
                this._obj = i,
                this._updateFunc = function(t) {
                    return function() {
                        t._checkVisible.call(t)
                    }
                }(this),
                this._updaterName = this.name + "_updater_" + r.a.getUUID(),
                this.app.on("update", this._updateFunc, this._updaterName)
            } else if ("model" === this.renderer.type) {
                var o = [1, 1, 1];
                void 0 !== this.renderer.size && (Array.isArray(this.renderer.size) ? o = this.renderer.size : isNaN(this.renderer.size) || (o = [this.renderer.size, this.renderer.size, this.renderer.size]));
                var s = this.app.create({
                    type: "Thing",
                    name: this.name + "_Thing",
                    url: this.renderer.url,
                    scale: o,
                    parent: this,
                    inheritVisible: !1,
                    visible: !1,
                    style: {
                        opacity: this.renderer.opacity,
                        alwaysOnTop: this.renderer.alwaysOnTop
                    },
                    keepSize: this.renderer.keepSize,
                    autoEnsureParentsVisible: !1,
                    userData: {
                        SKIP_THEME: 1,
                        __isGeoPoint__: !0
                    },
                    complete: function(t) {
                        var e = t.object
                          , n = e.parent;
                        e.visible = !0,
                        e.node.getMaterials().map(function(t) {
                            t.transparent = !0
                        }),
                        n.renderer.postRadiusEffect && n._setPostRadiusEffect(!0),
                        n.style.renderOrder = n.renderOrder,
                        n.renderer.useColor && n.renderer._color && (e.style.color = n.renderer._color),
                        n._complete && setTimeout(()=>{
                            t.object = n,
                            n._complete.call(n, t)
                        }
                        , 1)
                    },
                    error: (t,e)=>{
                        e && (e._loadedError = !0)
                    }
                });
                this._obj = s,
                this.renderer.playAnimation && this._obj.playAnimation({
                    name: this.renderer.animationName,
                    loopType: this.renderer.animationLoopType
                })
            }
            this._setMeshType()
        }
        _setMeshType() {
            "model" !== this.renderer.type && this.renderer.useSpriteMaterial ? this.meshType = "Sprite" : this.meshType = "Mesh"
        }
        _getMeshes() {
            var t = this
              , e = [];
            return "model" === this.renderer.type ? this.node.traverse(function(n) {
                n.type && n.type === t.meshType && n && e.push(n)
            }) : e.push(this.node.children[0].children[0]),
            e
        }
    }
    THING.factory.registerClass("GeoPoint", ne);
    var re = ne;
    var ae = class extends Dt {
        constructor(t, e) {
            super(t, e),
            this._lineType = e.lineType || "Line",
            this._type = e.type || "vector",
            this._imageUrl = e.imageUrl,
            this._width = THING.Utils.parseValue(e.width, 5),
            this._speed = THING.Utils.parseValue(e.speed, 0),
            this._keepSpeed = THING.Utils.parseValue(e.keepSpeed, !1),
            this._effect = THING.Utils.parseValue(e.effect, !1),
            this._textureSize = THING.Utils.parseValue(e.textureSize, M.a._defaultLineTextureSize),
            this._glowStrength = THING.Utils.parseValue(e.glowStrength, 1),
            this._sizeAttenuation = THING.Utils.parseValue(e.sizeAttenuation, !1),
            this._opacity = THING.Utils.parseValue(e.opacity, 1),
            e.color = THING.Utils.parseValue(e.color, [255, 255, 255]),
            e.color = "" === e.color ? [255, 255, 255] : e.color;
            let n = !1;
            "image" === this._type && (n = !0),
            this._blending = THING.Utils.parseValue(e.blending, n),
            this._color = CMAP.Util.colorFormatNewToOld(e.color, this._opacity) || [1, 1, 1, 1],
            this._opacity = this._color[3],
            this._growSpeed = THING.Utils.parseValue(e.growSpeed, 0),
            this._growLoop = e.growLoop === THING.LoopType.Repeat || e.growLoop,
            this._growEase = THING.Utils.parseValue(e.growEase, "Linear"),
            this._growDirection = THING.Utils.parseValue(e.growDirection, "None"),
            !0 === this._growLoop ? this._growLoop = THING.LoopType.Repeat : !1 === this._growLoop && (this._growLoop = THING.LoopType.No),
            void 0 === this._growLoop && (this._growLoop = THING.LoopType.Repeat),
            this._uvRatio = THING.Utils.parseValue(e.uvRatio, [1, 1]),
            this._textureWrap = THING.Utils.parseValue(e.textureWrap, "stretch"),
            this._colorMapping = e.colorMapping,
            this._useColor = THING.Utils.parseValue(e.useColor, !1)
        }
        get keepSpeed() {
            return this._keepSpeed
        }
        get useColor() {
            return this._useColor
        }
        set useColor(t) {
            this._useColor = t,
            this._object && "image" === this._type && (this._object._updateMaterial(),
            this._object._updateGrowSpeed(this.growSpeed, !1))
        }
        get textureSize() {
            return this._textureSize
        }
        set textureSize(t) {
            this._textureSize !== t && (this._textureSize = t,
            this._object && ("FeatureLayer" === this._object.type ? this._object.children.forEach(e=>{
                e.renderer.textureSize = t
            }
            ) : this._object._updateTextureSize(t)))
        }
        get growEase() {
            return this._growEase
        }
        get growDirection() {
            return this._growDirection
        }
        get uvRatio() {
            return this._uvRatio
        }
        set uvRatio(t) {
            this._uvRatio !== t && (this._uvRatio = t,
            this._object && ("FeatureLayer" === this._object.type ? this._object.children.forEach(e=>{
                e.renderer.uvRatio = t
            }
            ) : (this._object._updateMaterial(),
            this._object._updateGrowSpeed(this.growSpeed, !1))))
        }
        get growLoop() {
            return this._growLoop
        }
        set growLoop(t) {
            this._growLoop = t,
            this._object && ("FeatureLayer" === this._object.type ? this._object.children.forEach(e=>{
                e.renderer.growLoop = t
            }
            ) : this._object._updateGrowSpeed(this._object.renderer.growSpeed))
        }
        get growSpeed() {
            return this._growSpeed
        }
        set growSpeed(t) {
            this._growSpeed = t,
            this._object && ("FeatureLayer" === this._object.type ? this._object.children.forEach(e=>{
                e.renderer.growSpeed = t
            }
            ) : this._object._updateGrowSpeed(t))
        }
        get type() {
            return this._type
        }
        set type(t) {
            this._type !== t && (this._type = t,
            this._object && ("FeatureLayer" === this._object.type ? this._object.children.forEach(e=>{
                e.renderer.type = t
            }
            ) : (this._object._updateMaterial(),
            this._object._checkPartical(),
            this._object._updateGrowSpeed(this.growSpeed, !1))))
        }
        get lineType() {
            return this._lineType
        }
        set lineType(t) {
            this._lineType !== t && (this._lineType = t,
            this._object && ("FeatureLayer" === this._object.type ? this._object.children.forEach(e=>{
                e.renderer.lineType = t
            }
            ) : (this._object.node.children = [],
            this._object._createMesh())))
        }
        get imageUrl() {
            return this._imageUrl
        }
        set imageUrl(t) {
            this._imageUrl !== t && (this._imageUrl = t,
            this._object && "image" === this.type && ("FeatureLayer" === this._object.type ? this._object.children.forEach(e=>{
                e.renderer.imageUrl = t
            }
            ) : (this._object._updateMaterial(),
            this._object._updateGrowSpeed(this.growSpeed, !1))))
        }
        get width() {
            return this._width
        }
        set width(t) {
            "Line" !== this.lineType ? this._width !== t && (this._width = t,
            this._object && ("FeatureLayer" === this._object.type ? this._object.children.forEach(e=>{
                e.renderer.width = t
            }
            ) : (this._object._updateWidth(t),
            this._object._updateGrowSpeed(this.growSpeed, !1)))) : THING.Utils.warn("lineType为Line的线无法设置宽度")
        }
        get speed() {
            return this._speed
        }
        set speed(t) {
            this._speed !== t && (this._speed = t,
            this._object && ("FeatureLayer" === this._object.type ? this._object.children.forEach(e=>{
                e.renderer.speed = t
            }
            ) : (this._object.speed = t,
            this._object._updateSpeed(t))))
        }
        get effect() {
            return this._effect
        }
        set effect(t) {
            this._effect !== t && (this._effect = t,
            this._object && ("FeatureLayer" === this._object.type ? this._object.children.forEach(e=>{
                e.renderer.effect = t
            }
            ) : this._object._updateEffect(t, this._glowStrength)))
        }
        get glowStrength() {
            return this._glowStrength
        }
        set glowStrength(t) {
            this._glowStrength !== t && this._object && ("FeatureLayer" === this._object.type ? this._object.children.forEach(e=>{
                e.renderer.glowStrength = t
            }
            ) : this._object._updateEffect(this._effect, t)),
            this._glowStrength = t
        }
        get color() {
            return CMAP.Util.colorFormatOldToNew(this._color)
        }
        set color(t) {
            var e = CMAP.Util.colorFormatNewToOld(t, this._opacity);
            JSON.stringify(e) !== JSON.stringify(this._color) && (Array.isArray(t) && 4 === t.length && (this._opacity = t[3]),
            this._color = e,
            this._object && this._object._getGeoObjectArray().forEach(n=>{
                Array.isArray(t) && 4 === t.length && (n.renderer._opacity = t[3]),
                n.renderer._color = e,
                n._updateMaterial(),
                n._updateGrowSpeed(this.growSpeed, !1)
            }
            ))
        }
        get colorMapping() {
            return this._colorMapping
        }
        set colorMapping(t) {
            this._colorMapping = t,
            this._object && "vector" === this._type && this._object._getGeoObjectArray().forEach(e=>{
                e.renderer._colorMapping = t,
                e._updateMaterial(),
                e._updateGrowSpeed(this.growSpeed, !1)
            }
            )
        }
        get opacity() {
            return this._opacity
        }
        set opacity(t) {
            t !== this._opacity && (this._opacity = t,
            this._color[3] = t,
            this._object && this._object._getGeoObjectArray().forEach(e=>{
                e.renderer._opacity = t,
                e.renderer._color[3] = t,
                e._updateMaterial(),
                e._updateGrowSpeed(this.growSpeed, !1)
            }
            ))
        }
        get textureWrap() {
            return this._textureWrap
        }
        set textureWrap(t) {
            t !== this._textureWrap && (this._object && ("FeatureLayer" === this._object.type ? this._object.children.forEach(e=>{
                e.renderer.textureWrap = t
            }
            ) : this._object._updateUV(t)),
            this._textureWrap = t)
        }
        get blending() {
            return this._blending
        }
        set blending(t) {
            t !== this._blending && (this._blending = t,
            this._object && ("FeatureLayer" === this._object.type ? this._object.children.forEach(e=>{
                e.renderer.blending = t
            }
            ) : (this._object._updateMaterial(),
            this._object._updateGrowSpeed(this.growSpeed, !1))))
        }
        get sizeAttenuation() {
            return this._sizeAttenuation
        }
        set sizeAttenuation(t) {
            t !== this._sizeAttenuation && (this._sizeAttenuation = t,
            this._object && ("FeatureLayer" === this._object.type ? this._object.children.forEach(e=>{
                e.renderer.sizeAttenuation = t
            }
            ) : (this._object._updateMaterial(),
            this._object._updateGrowSpeed(this.growSpeed, !1))))
        }
    }
    ;
    class ie extends Zt {
        constructor(t) {
            super(t),
            this.app = t,
            this._effectName = "lineBloom"
        }
        setup(t) {
            this.isInfoShow = !1,
            this.name = t.name || "geoLine_" + r.a.getUUID(),
            this.id = t.id || this.name,
            this._isLonlat = THING.Utils.parseValue(t.isLonlat, !0),
            this._growName = "lineGrow_" + this.queryID,
            this._coordinates = t.coordinates,
            this._clampToGround = THING.Utils.parseValue(t.clampToGround, !1),
            this._userData = THING.Utils.parseValue(t.userData, {}),
            this._renderer = new ae(this,t.renderer),
            this._currentUVRatio = this.renderer.uvRatio,
            this._setOffsetHeightAndField(t),
            this.node = this._layer = new THREE.Group,
            this._particalParent = new THREE.Group,
            this.numPass = THING.Utils.parseValue(this.renderer.numPass, 1),
            this.speed = THING.Utils.parseValue(this.renderer.speed, 0),
            this._material,
            this._uvArray = [],
            this.totalLengthArray = [],
            this._meshArray = [],
            this._heightArray = t.heightArray,
            this._heightArrayField = t.heightArrayField,
            this._heightArrayFactor = THING.Utils.parseValue(t.heightArrayFactor, 1),
            this._originTextureSize = this._lastTextureSize = this.renderer.textureSize,
            this.visible = void 0 === t.visible || t.visible,
            this.renderOrder = THING.Utils.parseValue(t.renderOrder, 0),
            this.init(),
            this._afterInit({
                renderer: this.renderer
            }),
            this._setupLabel(t),
            this._setupInfoWindow(t),
            this.setupParent(t),
            this.setupUserData(),
            this.setupComplete(t)
        }
        get heightArray() {
            return this._heightArray
        }
        get heightArrayField() {
            return this._heightArrayField
        }
        set heightArrayField(t) {
            t !== this._heightArrayField && (this._heightArray = null,
            this._heightArrayField = t,
            this.node.children = [],
            this._createMesh())
        }
        get heightArrayFactor() {
            return this._heightArrayFactor
        }
        set heightArrayFactor(t) {
            t !== this._heightArrayFactor && (this._heightArray = null,
            this._heightArrayFactor = t,
            this.node.children = [],
            this._createMesh())
        }
        get clampToGround() {
            return this._clampToGround
        }
        init() {
            let t = M.a.getReferencePosition(this.coordinates, this.offsetHeight);
            this._referencePosition = t,
            this._setNodePositionAndDirection(),
            this._createMesh()
        }
        _updateTextureSize(t) {
            if (0 !== t) {
                var e = this.node.getGeometries();
                for (var n in e) {
                    let r = e[n];
                    if (r.attributes.uv1) {
                        if (this._lastTextureSize === t)
                            continue;
                        let e = r.attributes.uv.count
                          , n = this._lastTextureSize / t
                          , a = r.attributes.uv1.array;
                        for (let t = 0; t < 2 * e; t += 2)
                            a[t] = a[t] * n;
                        r.addAttribute("uv1", new THREE.BufferAttribute(a,2)),
                        r.attributes.uv1.needsUpdate = !0,
                        "repeat" === this.renderer.textureWrap && r.addAttribute("uv", r.attributes.uv1),
                        this._lastTextureSize = t
                    }
                }
            }
        }
        _createLineSprite(t) {
            let e = Math.ceil(t / 1e3)
              , n = 0;
            for (let r = 0; r < t; r += e)
                n++;
            "vector" !== this.renderer.type || this.renderer.colorMapping || this._drawSprite(n)
        }
        _createMesh() {
            var t = [];
            THING.Utils.isNull(this._heightArray) && !THING.Utils.isNull(this._heightArrayField) && (this._heightArray = r.a.deepCopy(this.userData[this._heightArrayField]),
            1 !== this._heightArrayFactor && CMAP.Util._multiplyHeightArrayFactor(this._heightArray, this._heightArrayFactor));
            var e = this._createGeoObject(this.coordinates, this.renderer.lineType, this.renderer.width, this._heightArray, this._isLonlat, this.renderer.textureSize, this.clampToGround, this.offsetHeight);
            this._uvArray = e.uvArray;
            for (var n = 0; n < e.geometryArray.length; n++)
                t.push(e.geometryArray[n]);
            var a = t3djs.util.mergeBufferGeometry(t);
            0 !== this.renderer.growSpeed && 0 !== this.speed && (this.renderer._speed = 1e-5);
            var i = this.createMaterial(this.renderer);
            this._material = i;
            for (var o = 0; o < a.length; o++) {
                var s = M.a.createLineMesh(a[o], i, this.renderer);
                this._meshArray.push(s),
                this.node.add(s)
            }
            this._updateGrowSpeed(this.renderer.growSpeed),
            this.totalLengthArray = e.totalLengthArray,
            this._createLineSprite(e.geometryArray.length),
            this._setMeshType()
        }
        _setMeshType() {
            "Line" === this.renderer.lineType ? this.meshType = "LineSegments" : this.meshType = "Mesh"
        }
        _setNodePositionAndDirection() {
            let t = this._referencePosition;
            this.node.setPosition(t),
            M.a._setNodeAnglesByPosition(this.node, t),
            this._particalParent.setPosition(t),
            M.a._setNodeAnglesByPosition(this._particalParent, t)
        }
        createUV(t, e, n) {
            return M.a.createUV(t, e, n)
        }
        _updateUV(t) {
            for (let e = 0; e < this._meshArray.length; e++) {
                let n = this._meshArray[e].geometry;
                M.a._setUV(t, n)
            }
        }
        _createGeoObject(t, e, n, r, a=!0, i, o=!1, s) {
            var l = this.node;
            let u = this.renderer.textureWrap || "stretch"
              , c = M.a._processGeojson(t, "Line");
            if (r && (r = M.a._processGeojson(r, "LineHeight")),
            o) {
                const t = M.a._processHeightArrayFromCoordinates(c, r);
                c = t.lineData,
                r = t.heightArray
            }
            var h = this.createGeometry(c, l, e, n, r, a, i, s);
            let d = this.createUV(c, r, this._currentUVRatio, !0);
            if ("Line" === e)
                for (let t = 0; t < h.length; t++) {
                    let e = h[t]
                      , n = d.segs[t];
                    e.addAttribute("uv", new THREE.Float32BufferAttribute(n,2));
                    let r = []
                      , a = d.totalLengthArray[t] / i;
                    for (let t = 0; t < e.attributes.uv.count; t += 1)
                        r[2 * t] = n[2 * t] * a,
                        r[2 * t + 1] = n[2 * t + 1];
                    e.addAttribute("uv2", new THREE.Float32BufferAttribute(n,2)),
                    e.addAttribute("uv1", new THREE.Float32BufferAttribute(r,2)),
                    M.a._setUV(u, e)
                }
            else if ("Plane" === e)
                for (let t = 0; t < h.length; t++) {
                    let e = h[t]
                      , n = d.segs[t]
                      , r = new Float32Array(2 * n.length)
                      , a = new Float32Array(2 * n.length);
                    for (let t = 0; t < n.length / 2; t += 1)
                        r[4 * t] = n[2 * t],
                        r[4 * t + 1] = 0,
                        r[4 * t + 2] = n[2 * t],
                        r[4 * t + 3] = 1;
                    for (let t = 0; t < n.length; t++)
                        a[2 * t] = n[t],
                        a[2 * t + 1] = n[t];
                    e.addAttribute("uv2", new THREE.BufferAttribute(r,2));
                    let i = e.attributes.uv.array;
                    e.addAttribute("uv1", new THREE.BufferAttribute(i,2)),
                    M.a._setUV(u, e)
                }
            else
                for (let t = 0; t < h.length; t++) {
                    let e = h[t];
                    e.addAttribute("uv1", e.attributes.uv),
                    M.a._setUV(u, e)
                }
            return {
                referenceNode: l,
                geometryArray: h,
                totalLengthArray: d.totalLengthArray,
                uvArray: d.uvArray
            }
        }
        createGeometry(t, e, n, r, a, i, o, s) {
            return M.a.createLineGeometry(t, e, n, r, a, i, o, s)
        }
        createMaterial() {
            return Ut.createLineMaterial(this.renderer)
        }
        updateRenderer(t) {
            super.updateRenderer(t),
            void 0 !== t.type && (this.renderer._type = t.type),
            (void 0 !== t.lineType && this.renderer.lineType !== t.lineType || t.width && t.width !== this._renderer._width && ("Route" === t.lineType || "Pipe" === t.lineType)) && (this.renderer._lineType = t.lineType,
            this._renderer._width = t.width,
            this._createMesh()),
            t.textureWrap && ("image" === t.type || "vector" === t.type && t.colorMapping) && this._updateUV(t.textureWrap),
            t.textureSize && ("image" === t.type || "vector" === t.type && t.colorMapping) && "repeat" === t.textureWrap && this._updateTextureSize(t.textureSize);
            var e = new ae(this,t);
            this._renderer = e,
            this._updateMaterial(),
            this.node.getObjectByName("particle") && (this.renderer.colorMapping ? this.node.getObjectByName("particle").visible = !1 : (this.node.getObjectByName("particle").visible = !0,
            this._updateSpeed(e.speed))),
            THING.App.current.rendererManager._mainRenderer.dirty()
        }
        _updateMaterial() {
            for (var t in this._material = this.createMaterial(),
            this.node.children) {
                this.node.children[t].material = this._material
            }
            setTimeout(function() {
                THING.App.current.rendererManager._mainRenderer.dirty("LineBloom")
            })
        }
        _drawSprite(t) {
            let e = this;
            if (this.taskName = [],
            0 !== this.renderer.speed && "Pipe" !== this.renderer.lineType)
                for (var n = this.particle = this.node.createChild("particle"), a = 0; a < t; a++) {
                    var i = this.particleSystem = new THREE.GPUParticleSystem({
                        maxParticles: 30
                    })
                      , o = n.createChild("particle" + a)
                      , s = t3djs.sceneManager.createEntity(i);
                    o.attachObject(s),
                    n.add(o);
                    var l = {
                        position: new THREE.Vector3,
                        positionRandomness: 0,
                        velocity: new THREE.Vector3,
                        velocityRandomness: 0,
                        color: 16777215,
                        colorRandomness: 0,
                        turbulence: 0,
                        lifetime: 1,
                        size: 1 + this._getParticleWidth(),
                        sizeRandomness: 0
                    }
                      , u = {
                        speed: this.renderer.speed,
                        per: 0,
                        particleSystem: i,
                        options: l,
                        clock: new THREE.Clock,
                        tick: 0,
                        spawnerOptions: {
                            spawnRate: 10,
                            horizontalSpeed: 1.5,
                            verticalSpeed: 1.33,
                            timeScale: 1
                        },
                        index: a,
                        update: function() {
                            var t = this.clock.getDelta() * this.spawnerOptions.timeScale;
                            if (this.tick += t,
                            this.tick < 0 && (this.tick = 0),
                            this.per += 30 * this.speed,
                            this.per > e.totalLengthArray[this.index] && (this.per = 0),
                            t > 0) {
                                var n = e._getSpritePositionByPer(this.per, this.index)
                                  , r = e._particalParent.convertWorldToLocalPosition(n);
                                this.options.position.set(r[0], r[1], r[2]),
                                this.particleSystem.spawnParticle(this.options)
                            }
                            this.particleSystem.update(this.tick)
                        }
                    }
                      , c = "vectorLineFlow_" + r.a.getUUID();
                    this.taskName.push(c),
                    t3djs.buffer._renderList.add(c, u)
                }
        }
        get offsetHeight() {
            return this._offsetHeight
        }
        set offsetHeight(t) {
            t !== this._offsetHeight && (this._setOffsetHeight(t),
            "GeoODLine" !== this.type && "GeoFlyLine" !== this.type && (this._caculateGeometry(this.renderer.lineType, this.renderer.width, this.heightArray, this.renderer.textureSize, this.clampToGround),
            this.renderer.textureSize && (this._lastTextureSize = this.renderer.textureSize)))
        }
        _setOffsetHeight(t) {
            super.offsetHeight = t,
            this.node.updateWorldMatrix()
        }
        _caculateGeometry(t, e, n, r, a) {
            let i = M.a._processGeojson(this.coordinates, "LINE")
              , o = this._createGeoObject(i, t, e, n, !0, r, a, this.offsetHeight)
              , s = t3djs.util.mergeBufferGeometry(o.geometryArray);
            for (let t = 0; t < this.node.children.length; t++)
                this.node.children[t].geometry = s[t]
        }
        _checkPartical() {
            for (var t in this._uvArray) {
                var e = null;
                if (this.taskName && this.taskName[t] && (e = t3djs.buffer._renderList.get(this.taskName[t])),
                "image" === this.renderer.type)
                    e && (e.particleSystem.visible = !1,
                    t3djs.buffer._renderList.delete(this.taskName[t]));
                else if ("vector" === this.renderer.type) {
                    e ? (this._updateParticalWidth(),
                    this._updateSpeed(),
                    e.particleSystem.visible = !0) : this._drawSprite(this._uvArray.length);
                    break
                }
            }
        }
        _updateSpeed(t) {
            if (this._originSpeed = t,
            "image" === this.renderer.type || this.renderer.colorMapping)
                this._updateMaterial();
            else if ("vector" === this.renderer.type) {
                if (t3djs.buffer._renderList.get(this.taskName[0]))
                    if (0 !== t)
                        for (let n in this._uvArray) {
                            var e = t3djs.buffer._renderList.get(this.taskName[n]);
                            e && (e.speed = t,
                            e.particleSystem.visible = !0,
                            t3djs.buffer._renderList.add(this.taskName, e))
                        }
                    else {
                        this.node.removeChild(this.particle);
                        for (let t in this._uvArray)
                            t3djs.buffer._renderList.delete(this.taskName[t])
                    }
                else
                    this._drawSprite(this._uvArray.length)
            }
        }
        _updateWidth(t) {
            "Line" !== this.renderer.lineType ? ("Plane" === this.renderer.lineType ? this._updateMaterial() : this._caculateGeometry(this.renderer.lineType, t, this.heightArray, this.renderer.textureSize, this.clampToGround),
            this._updateParticalWidth(),
            THING.App.current.rendererManager._mainRenderer.dirty("LineBloom")) : THING.Utils.warn("lineType为Line的线无法设置宽度")
        }
        _getParticleWidth() {
            return "Line" === this.renderer.lineType ? .5 : this.renderer.width / 2
        }
        _updateParticalWidth() {
            if ("vector" === this.renderer.type && this.taskName) {
                let e = this._getParticleWidth();
                for (let n = 0; n < this.taskName.length; n++) {
                    var t = t3djs.buffer._renderList.get(this.taskName[n]);
                    t && (t.options.size = 1 + e,
                    t3djs.buffer._renderList.add(this.taskName[n], t))
                }
            }
        }
        _updateGrowSpeed(t, e=!0) {
            if (0 === t)
                return this._stopLineGrow(),
                void (!1 === this.visible && this._realVisible && (this.visible = this._realVisible));
            let n = 1;
            "image" === this.renderer.type && (n = "Plane" === this.renderer.lineType ? this._material.uniforms.map.value.repeat.x : this._material.map.repeat.x),
            e && this._updateMaterial(),
            t && (!0 === this.visible && (this.node.visible = !1,
            this._realVisible = !0),
            this._playLineGrow({
                speed: t,
                growLoop: this.renderer.growLoop,
                repeatX: n
            }))
        }
        _getSpritePositionByPer(t, e) {
            var n = [0, 0, 0]
              , r = this._uvArray[e].segs;
            for (var a in t /= this.totalLengthArray[e],
            r) {
                var i = r[a].startPoint.textureCoord[0]
                  , o = r[a].endPoint.textureCoord[0];
                if (t > i && t < o) {
                    var s = [r[a].endPoint[0] - r[a].startPoint[0], r[a].endPoint[1] - r[a].startPoint[1], r[a].endPoint[2] - r[a].startPoint[2]]
                      , l = (t - i) / (o - i);
                    n = [r[a].startPoint[0] + l * s[0], r[a].startPoint[1] + l * s[1], r[a].startPoint[2] + l * s[2]];
                    break
                }
            }
            return n
        }
        _playLineGrow(t) {
            (t = THING.Utils.parseValue(t, {})).speed = THING.Utils.parseValue(t.speed, 2),
            t.growLoop = THING.Utils.parseValue(t.growLoop, THING.LoopType.Repeat),
            t.repeatX = THING.Utils.parseValue(t.repeatX, 1);
            var e, n = this.node.getMaterials()[0];
            "Plane" === this.renderer.lineType ? (n.uniforms.useAlphaMap.value = 1,
            e = n.uniforms.alphaMap.value) : ((e = r.a._generateHalfTexture()).wrapS = e.wrapT = THREE.RepeatWrapping,
            e.repeat.set(.5 * t.repeatX, 1),
            n.alphaMap = e,
            n.needsUpdate = !0);
            var a = this
              , i = {
                speed: t.speed / 200,
                growLoop: t.growLoop,
                per: 0,
                update: function() {
                    if (this.per += this.speed,
                    this.growLoop === THING.LoopType.No) {
                        if (this.per > .5 || this.per < -.5)
                            return "Plane" === a.renderer.lineType ? (e.offset.set(.5, 0),
                            e.matrix.setUvTransform(e.offset.x, e.offset.y, e.repeat.x, e.repeat.y, e.rotation, e.center.x, e.center.y),
                            n.uniforms.uvTransform.value.copy(e.matrix)) : e.offset.set(.5, 0),
                            t3djs.buffer._renderList.delete(a._growName),
                            a.app.trigger("GeoLineGrowEnd", {
                                object: a
                            }),
                            void (0 !== a.speed && (a.renderer.speed = a.speed))
                    } else
                        this.growLoop === THING.LoopType.PingPong ? t.speed > 0 ? this.per > .5 ? (this.per = .5,
                        this.speed *= -1) : this.per < 0 && (this.per = 0,
                        this.speed *= -1) : this.per < -.5 ? (this.per = -.5,
                        this.speed *= -1) : this.per > 0 && (this.per = 0,
                        this.speed *= -1) : this.per > 1 && (this.per = 0);
                    !0 === a._realVisible && (a.visible = !0);
                    let r = this.per;
                    "Plane" === a.renderer.lineType ? (e.offset.set(-r, 0),
                    e.matrix.setUvTransform(e.offset.x, e.offset.y, e.repeat.x, e.repeat.y, e.rotation, e.center.x, e.center.y),
                    n.uniforms.uvTransform.value.copy(e.matrix)) : e.offset.set(-r, 0)
                }
            };
            t3djs.buffer._renderList.add(this._growName, i)
        }
        _stopLineGrow() {
            t3djs.buffer._renderList.delete(this._growName);
            var t = this._material;
            "Plane" === this.renderer.lineType ? t.uniforms.useAlphaMap.value = 0 : t.alphaMap = null
        }
    }
    THING.factory.registerClass("GeoLine", ie);
    var oe = ie;
    class se extends Zt {
        constructor(t) {
            super(t),
            this.app = t
        }
        setup(t) {
            this.isInfoShow = !1,
            this.name = t.name || "geoLineOnTerrain_" + r.a.getUUID(),
            this.id = t.id || this.name,
            this._growName = "lineOnTerrain_" + this.queryID,
            this._coordinates = t.coordinates,
            this._userData = void 0 === t.userData ? {} : t.userData,
            t.renderer = t.renderer || {},
            t.renderer.color && 4 === t.renderer.color.length && void 0 === t.opacity && (t.renderer.opacity = t.renderer.color[3]),
            this._renderer = {},
            Object.assign(this._renderer, {
                width: 30,
                color: [255, 0, 0],
                opacity: 1
            }, t.renderer);
            for (let t in this._renderer) {
                var e = "_" + t;
                this._renderer[e] = this._renderer[t],
                Object.defineProperty(this._renderer, e, {
                    enumerable: !1,
                    configurable: !1
                })
            }
            Object.defineProperty(this._renderer, "width", {
                enumerable: !0,
                configurable: !0,
                get: function() {
                    return this._width
                },
                set: function(t) {
                    this._width = t
                }
            }),
            Object.defineProperty(this._renderer, "color", {
                enumerable: !0,
                configurable: !0,
                get: function() {
                    return this._color
                },
                set: function(t) {
                    this._color = t
                }
            }),
            Object.defineProperty(this._renderer, "opacity", {
                enumerable: !0,
                configurable: !0,
                get: function() {
                    return this._opacity
                },
                set: function(t) {
                    this._opacity = t
                }
            }),
            this._maxHeight = void 0 === t.maxHeight ? 1e3 : t.maxHeight,
            this._minHeight = void 0 === t.minHeight ? 1e3 : t.minHeight,
            this._minHeight < 1e3 && (this._minHeight = 1e3),
            this.node = this._layer = new THREE.Group,
            this.param = t,
            this.visible = void 0 === t.visible || t.visible,
            this.init(),
            this.setupParent(t),
            this.setupUserData(),
            this.setupComplete(t)
        }
        init() {
            this._uniforms = {
                lineColor: {
                    value: new THREE.Vector3(this.renderer.color[0],this.renderer.color[1],this.renderer.color[2])
                },
                lineOpacity: {
                    value: this.renderer.opacity
                }
            };
            let t = "\n      #include <common>\n      #include <logdepthbuf_pars_vertex>\n      \n      void main() {\n        vec3 transformed = vec3( position );\n        vec4 mvPosition = vec4( transformed, 1.0 );\n        mvPosition = modelViewMatrix * mvPosition;\n        gl_Position = projectionMatrix * mvPosition;\n\n        // gl_Position = projectionMatrix * modelViewMatrix * vec4( position , 1.0 );\n\n        #include <logdepthbuf_vertex>\n      \n      }\n    "
              , e = "\n      #include <common>\n      #include <logdepthbuf_pars_fragment>\n      #include <dithering_pars_fragment>\n      \n      void main() {\n        #include <logdepthbuf_fragment>\n        gl_FragColor = vec4( 1.0,0.0,0.0,1.0 );\n        #include <dithering_fragment>\n      \n      }\n    "
              , n = this._material_1 = new THREE.ShaderMaterial({
                transparent: !1,
                uniforms: this._uniforms,
                vertexShader: t,
                fragmentShader: e
            });
            n.side = THREE.DoubleSide,
            n.depthTest = !1,
            n.depthFunc = THREE.LessEqualDepth,
            n.depthWrite = !1,
            n.colorWrite = !1,
            n.stencilWrite = !0,
            n.stencilWriteMask = 255,
            n.stencilFunc = THREE.AlwaysStencilFunc,
            n.stencilRef = 0,
            n.stencilFuncMask = -1,
            n.stencilFail = THREE.KeepStencilOp,
            n.stencilZFail = THREE.DecrementStencilOp,
            n.stencilZPass = THREE.DecrementWrapStencilOp,
            n.stencilFuncBack = THREE.AlwaysStencilFunc,
            n.stencilRefBack = 0,
            n.stencilFuncMaskBack = -1,
            n.stencilFailBack = THREE.KeepStencilOp,
            n.stencilZFailBack = THREE.DecrementStencilOp,
            n.stencilZPassBack = THREE.IncrementWrapStencilOp;
            let r = this._material_2 = new THREE.ShaderMaterial({
                transparent: !1,
                uniforms: this._uniforms,
                vertexShader: t,
                fragmentShader: e
            });
            r.side = THREE.DoubleSide,
            r.depthTest = !0,
            r.depthFunc = THREE.LessEqualDepth,
            r.depthWrite = !1,
            r.colorWrite = !1,
            r.stencilWrite = !0,
            r.stencilWriteMask = 255,
            r.stencilFunc = THREE.AlwaysStencilFunc,
            r.stencilRef = 0,
            r.stencilFuncMask = -1,
            r.stencilFail = THREE.KeepStencilOp,
            r.stencilZFail = THREE.KeepStencilOp,
            r.stencilZPass = THREE.IncrementWrapStencilOp,
            r.stencilFuncBack = THREE.AlwaysStencilFunc,
            r.stencilRefBack = 0,
            r.stencilFuncMaskBack = -1,
            r.stencilFailBack = THREE.KeepStencilOp,
            r.stencilZFailBack = THREE.KeepStencilOp,
            r.stencilZPassBack = THREE.DecrementWrapStencilOp;
            let a = this._material_3 = new THREE.ShaderMaterial({
                transparent: !0,
                uniforms: this._uniforms,
                vertexShader: "\n      precision highp float;\n      #include <logdepthbuf_pars_vertex>\n      #include <common>\n\n      void main(){\n\n        vec3 transformed = vec3( position );\n        vec4 mvPosition = vec4( transformed, 1.0 );\n        mvPosition = modelViewMatrix * mvPosition;\n        gl_Position = projectionMatrix * mvPosition;\n\n        // gl_Position = projectionMatrix * modelViewMatrix * vec4( position , 1.0 );\n\n        #include <logdepthbuf_vertex>\n      }\n    ",
                fragmentShader: "\n      precision highp float;\n      #include <common>\n      #include <logdepthbuf_pars_fragment>\n      #include <dithering_pars_fragment>\n\n      uniform vec3 lineColor;\n      uniform float lineOpacity;\n\n      void main(){\n        #include <logdepthbuf_fragment>\n        gl_FragColor = vec4(lineColor.xyz / 255.0, lineOpacity);\n        #include <dithering_fragment>\n      }\n    "
            });
            a.side = THREE.DoubleSide,
            a.depthTest = !1,
            a.depthFunc = THREE.LessEqualDepth,
            a.depthWrite = !1,
            a.colorWrite = !0,
            a.stencilWrite = !0,
            a.stencilWriteMask = 255,
            a.stencilFunc = THREE.LessEqualStencilFunc,
            a.stencilRef = 1,
            a.stencilFuncMask = 255,
            a.stencilFail = THREE.ZeroStencilOp,
            a.stencilZFail = THREE.ZeroStencilOp,
            a.stencilZPass = THREE.ZeroStencilOp,
            this._bufferGeometries = [],
            this._coordinates = M.a._processGeojson(this._coordinates, "Line"),
            this._coordinates && this._coordinates.length > 0 && this._coordinates[0].length > 0 && (this._relativePos = this._coordinates[0][0]),
            this._createLineOnTerrain(this._coordinates)
        }
        get maxHeight() {
            return this._maxHeight
        }
        get minHeight() {
            return this._minHeight
        }
        _createLineOnTerrain(t) {
            if (t) {
                for (let e = 0; e < t.length; e++)
                    this._createPathShadowVolume(t[e]);
                this._mergeBufferGeometry = THREE.BufferGeometryUtils1.mergeBufferGeometries(this._bufferGeometries),
                this._renderShadowVolume(this._mergeBufferGeometry)
            }
        }
        _renderShadowVolume(t) {
            var e = new THREE.Mesh(t,this._material_1);
            e.renderOrder = CMAP.GeoLineOnTerrainRenderOrder + 1,
            e.renderLayer = 1,
            this.node.add(e);
            let n = e.clone();
            n.material = this._material_2,
            n.renderOrder = CMAP.GeoLineOnTerrainRenderOrder + 2,
            n.renderLayer = 1,
            this.node.add(n);
            let a = e.clone();
            a.material = this._material_3,
            a.renderOrder = CMAP.GeoLineOnTerrainRenderOrder + 3,
            a.renderLayer = 1,
            this.node.add(a);
            let i = r.a.convertLonlatToWorld(this._relativePos);
            i = new THREE.Vector3(i[0],i[1],i[2]),
            e.position.copy(i),
            n.position.copy(i),
            a.position.copy(i),
            CMAP.GeoLineOnTerrainRenderOrder = CMAP.GeoLineOnTerrainRenderOrder + 3
        }
        _createPathShadowVolume(t) {
            let e = this._maxHeight
              , n = this._minHeight
              , a = r.a.convertLonlatToWorld(this._relativePos);
            a = new THREE.Vector3(a[0],a[1],a[2]);
            let i = [];
            for (let e = 0; e < t.length - 1; e++) {
                let n = {
                    curNode: null,
                    preNode: null,
                    nextNode: null,
                    vertex: {
                        p_1_or_0: null,
                        p_2_or_3: null,
                        p_5_or_4: null,
                        p_6_or_7: null
                    }
                }
                  , a = r.a.convertLonlatToWorld(t[e]);
                a = new THREE.Vector3(a[0],a[1],a[2]);
                let o = r.a.convertLonlatToWorld(t[e + 1])
                  , s = {
                    start: a,
                    end: o = new THREE.Vector3(o[0],o[1],o[2])
                }
                  , l = null;
                if (0 !== e) {
                    let n = r.a.convertLonlatToWorld(t[e - 1]);
                    l = {
                        start: n = new THREE.Vector3(n[0],n[1],n[2]),
                        end: a
                    }
                }
                let u = null;
                if (e !== t.length - 1 - 1) {
                    let n = r.a.convertLonlatToWorld(t[e + 2]);
                    u = {
                        start: o,
                        end: n = new THREE.Vector3(n[0],n[1],n[2])
                    }
                }
                n.curNode = s,
                n.preNode = l,
                n.nextNode = u,
                i.push(n)
            }
            let o = []
              , s = []
              , l = this.renderer.width / 2;
            for (let t = 0; t < i.length; t++) {
                let r = i[t]
                  , u = r.curNode.start
                  , c = r.curNode.end
                  , h = (new THREE.Vector3).addVectors(u, c).divideScalar(2).clone().normalize()
                  , d = u.clone().sub(c).clone().normalize().clone().cross(h).normalize()
                  , f = u.clone().add(h.clone().multiplyScalar(e))
                  , p = u.clone().add(h.clone().multiplyScalar(-n))
                  , m = c.clone().add(h.clone().multiplyScalar(e))
                  , g = c.clone().add(h.clone().multiplyScalar(-n))
                  , v = f.clone().add(d.clone().multiplyScalar(-l))
                  , y = m.clone().add(d.clone().multiplyScalar(-l))
                  , _ = m.clone().add(d.clone().multiplyScalar(l))
                  , x = f.clone().add(d.clone().multiplyScalar(l))
                  , b = p.clone().add(d.clone().multiplyScalar(-l))
                  , w = g.clone().add(d.clone().multiplyScalar(-l))
                  , C = g.clone().add(d.clone().multiplyScalar(l))
                  , E = p.clone().add(d.clone().multiplyScalar(l))
                  , T = r.nextNode;
                if (T) {
                    let u = T.start
                      , c = T.end
                      , h = (new THREE.Vector3).addVectors(u, c).divideScalar(2).clone().normalize()
                      , d = u.clone().sub(c).normalize().clone().cross(h).normalize()
                      , g = u.clone().add(h.clone().multiplyScalar(e))
                      , w = u.clone().add(h.clone().multiplyScalar(-n))
                      , M = c.clone().add(h.clone().multiplyScalar(e))
                      , A = c.clone().add(h.clone().multiplyScalar(-n))
                      , P = g.clone().add(d.clone().multiplyScalar(-l))
                      , S = (M.clone().add(d.clone().multiplyScalar(-l)),
                    M.clone().add(d.clone().multiplyScalar(l)),
                    g.clone().add(d.clone().multiplyScalar(l)))
                      , R = (w.clone().add(d.clone().multiplyScalar(-l)),
                    A.clone().add(d.clone().multiplyScalar(-l)),
                    A.clone().add(d.clone().multiplyScalar(l)),
                    w.clone().add(d.clone().multiplyScalar(l)),
                    (new THREE.Vector3).subVectors(S, P).normalize())
                      , D = (new THREE.Vector3).subVectors(_, y).normalize()
                      , j = (new THREE.Vector3).addVectors(R, D).divideScalar(2).normalize()
                      , L = R.dot(D) / (R.length() * D.length());
                    L > 1 ? L = 1 : L < -1 && (L = -1);
                    let I = Math.acos(L) / 2
                      , O = l / Math.cos(I)
                      , k = m.clone().add(j.clone().multiplyScalar(O))
                      , H = m.clone().add(j.clone().multiplyScalar(-O))
                      , F = (new THREE.Vector3).subVectors(p, f).normalize()
                      , B = k.clone().add(F.clone().multiplyScalar(e + n))
                      , U = H.clone().add(F.clone().multiplyScalar(e + n))
                      , N = i[t + 1];
                    if (N.vertex.p_1_or_0 = H,
                    N.vertex.p_2_or_3 = k,
                    N.vertex.p_5_or_4 = U,
                    N.vertex.p_6_or_7 = B,
                    r.preNode) {
                        let t = r.vertex.p_1_or_0
                          , e = r.vertex.p_2_or_3
                          , n = r.vertex.p_5_or_4
                          , a = r.vertex.p_6_or_7;
                        v = t.clone(),
                        x = e.clone(),
                        b = n.clone(),
                        E = a.clone()
                    }
                    v.clone().sub(a).toArray(o, o.length),
                    H.clone().sub(a).toArray(o, o.length),
                    k.clone().sub(a).toArray(o, o.length),
                    x.clone().sub(a).toArray(o, o.length),
                    b.clone().sub(a).toArray(o, o.length),
                    U.clone().sub(a).toArray(o, o.length),
                    C = B.clone().sub(a).toArray(o, o.length),
                    E.clone().sub(a).toArray(o, o.length);
                    let z = [0, 1, 2, 0, 2, 3, 4, 6, 5, 4, 7, 6, 4, 5, 1, 4, 1, 0, 7, 2, 6, 7, 3, 2, 5, 6, 2, 5, 2, 1, 4, 3, 7, 4, 0, 3];
                    for (let e = 0; e < z.length; e++)
                        z[e] = z[e] + 8 * t;
                    s.push(...z)
                } else {
                    if (r.preNode) {
                        let t = r.vertex.p_1_or_0
                          , e = r.vertex.p_2_or_3
                          , n = r.vertex.p_5_or_4
                          , a = r.vertex.p_6_or_7;
                        v = t.clone(),
                        x = e.clone(),
                        b = n.clone(),
                        E = a.clone()
                    }
                    v.clone().sub(a).toArray(o, o.length),
                    y.clone().sub(a).toArray(o, o.length),
                    _.clone().sub(a).toArray(o, o.length),
                    x.clone().sub(a).toArray(o, o.length),
                    b.clone().sub(a).toArray(o, o.length),
                    w.clone().sub(a).toArray(o, o.length),
                    C.clone().sub(a).toArray(o, o.length),
                    E.clone().sub(a).toArray(o, o.length);
                    let e = [0, 1, 2, 0, 2, 3, 4, 6, 5, 4, 7, 6, 4, 5, 1, 4, 1, 0, 7, 2, 6, 7, 3, 2, 5, 6, 2, 5, 2, 1, 4, 3, 7, 4, 0, 3];
                    for (let n = 0; n < e.length; n++)
                        e[n] = e[n] + 8 * t;
                    s.push(...e)
                }
            }
            let u = new THREE.BufferGeometry;
            u.setAttribute("position", new THREE.Float32BufferAttribute(o,3)),
            u.setIndex(s),
            this._bufferGeometries.push(u)
        }
    }
    THING.factory.registerClass("GroundGeoLine", se);
    var le = se;
    class ue extends Zt {
        constructor(t) {
            super(t),
            this.app = t
        }
        setup(t) {
            this.isInfoShow = !1,
            this.name = t.name || "geoPolygonOnTerrain_" + r.a.getUUID(),
            this.id = t.id || this.name,
            this._growName = "polygonOnTerrain_" + this.queryID,
            this._coordinates = t.coordinates,
            this._userData = void 0 === t.userData ? {} : t.userData,
            this._coordinates = void 0 === t.coordinates ? {} : t.coordinates,
            t.renderer = t.renderer || {},
            t.renderer.color && 4 === t.renderer.color.length && void 0 === t.opacity && (t.renderer.opacity = t.renderer.color[3]),
            this._renderer = {},
            Object.assign(this._renderer, {
                width: 30,
                color: [255, 0, 0],
                opacity: 1
            }, t.renderer);
            for (let t in this._renderer) {
                var e = "_" + t;
                this._renderer[e] = this._renderer[t],
                Object.defineProperty(this._renderer, e, {
                    enumerable: !1,
                    configurable: !1
                })
            }
            Object.defineProperty(this._renderer, "width", {
                enumerable: !0,
                configurable: !0,
                get: function() {
                    return this._width
                },
                set: function(t) {
                    this._width = t
                }
            }),
            Object.defineProperty(this._renderer, "color", {
                enumerable: !0,
                configurable: !0,
                get: function() {
                    return this._color
                },
                set: function(t) {
                    this._color = t
                }
            }),
            Object.defineProperty(this._renderer, "opacity", {
                enumerable: !0,
                configurable: !0,
                get: function() {
                    return this._opacity
                },
                set: function(t) {
                    this._opacity = t
                }
            }),
            this._maxHeight = void 0 === t.maxHeight ? 1e3 : t.maxHeight,
            this._minHeight = void 0 === t.minHeight ? 1e3 : t.minHeight,
            this._minHeight < 1e3 && (this._minHeight = 1e3),
            this.node = this._layer = new THREE.Group,
            this.param = t,
            this.visible = void 0 === t.visible || t.visible,
            this.init(),
            this.setupParent(t),
            this.setupUserData(),
            this.setupComplete(t)
        }
        init() {
            this._uniforms = {
                polygonColor: {
                    value: new THREE.Vector3(this.renderer.color[0],this.renderer.color[1],this.renderer.color[2])
                },
                polygonOpacity: {
                    value: this.renderer.opacity
                }
            };
            let t = "\n      #include <common>\n      #include <logdepthbuf_pars_vertex>\n      \n      void main() {\n        // vec3 transformed = vec3( position );\n        // vec4 mvPosition = vec4( transformed, 1.0 );\n        // mvPosition = modelViewMatrix * mvPosition;\n        // gl_Position = projectionMatrix * mvPosition;\n\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position , 1.0 );\n\n        #include <logdepthbuf_vertex>\n      \n      }\n    "
              , e = "\n      #include <common>\n      #include <logdepthbuf_pars_fragment>\n      #include <dithering_pars_fragment>\n      \n      void main() {\n        #include <logdepthbuf_fragment>\n        gl_FragColor = vec4( 1.0,0.0,0.0,1.0 );\n        #include <dithering_fragment>\n      \n      }\n    "
              , n = this._material_1 = new THREE.ShaderMaterial({
                transparent: !1,
                uniforms: this._uniforms,
                vertexShader: t,
                fragmentShader: e
            });
            n.side = THREE.DoubleSide,
            n.depthTest = !1,
            n.depthFunc = THREE.LessEqualDepth,
            n.depthWrite = !1,
            n.colorWrite = !1,
            n.stencilWrite = !0,
            n.stencilWriteMask = 255,
            n.stencilFunc = THREE.AlwaysStencilFunc,
            n.stencilRef = 0,
            n.stencilFuncMask = -1,
            n.stencilFail = THREE.KeepStencilOp,
            n.stencilZFail = THREE.DecrementStencilOp,
            n.stencilZPass = THREE.DecrementWrapStencilOp,
            n.stencilFuncBack = THREE.AlwaysStencilFunc,
            n.stencilRefBack = 0,
            n.stencilFuncMaskBack = -1,
            n.stencilFailBack = THREE.KeepStencilOp,
            n.stencilZFailBack = THREE.DecrementStencilOp,
            n.stencilZPassBack = THREE.IncrementWrapStencilOp;
            let r = this._material_2 = new THREE.ShaderMaterial({
                transparent: !1,
                uniforms: this._uniforms,
                vertexShader: t,
                fragmentShader: e
            });
            r.side = THREE.DoubleSide,
            r.depthTest = !0,
            r.depthFunc = THREE.LessEqualDepth,
            r.depthWrite = !1,
            r.colorWrite = !1,
            r.stencilWrite = !0,
            r.stencilWriteMask = 255,
            r.stencilFunc = THREE.AlwaysStencilFunc,
            r.stencilRef = 0,
            r.stencilFuncMask = -1,
            r.stencilFail = THREE.KeepStencilOp,
            r.stencilZFail = THREE.KeepStencilOp,
            r.stencilZPass = THREE.IncrementWrapStencilOp,
            r.stencilFuncBack = THREE.AlwaysStencilFunc,
            r.stencilRefBack = 0,
            r.stencilFuncMaskBack = -1,
            r.stencilFailBack = THREE.KeepStencilOp,
            r.stencilZFailBack = THREE.KeepStencilOp,
            r.stencilZPassBack = THREE.DecrementWrapStencilOp;
            let a = this._material_3 = new THREE.ShaderMaterial({
                transparent: !0,
                uniforms: this._uniforms,
                vertexShader: "\n      precision highp float;\n      #include <logdepthbuf_pars_vertex>\n      #include <common>\n\n      void main(){\n\n        // vec3 transformed = vec3( position );\n        // vec4 mvPosition = vec4( transformed, 1.0 );\n        // mvPosition = modelViewMatrix * mvPosition;\n        // gl_Position = projectionMatrix * mvPosition;\n\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position , 1.0 );\n\n        #include <logdepthbuf_vertex>\n      }\n    ",
                fragmentShader: "\n      precision highp float;\n      #include <common>\n      #include <logdepthbuf_pars_fragment>\n      #include <dithering_pars_fragment>\n\n      uniform vec3 polygonColor;\n      uniform float polygonOpacity;\n\n      void main(){\n        #include <logdepthbuf_fragment>\n        gl_FragColor = vec4(polygonColor.xyz / 255.0, polygonOpacity);\n        #include <dithering_fragment>\n      }\n    "
            });
            a.side = THREE.DoubleSide,
            a.depthTest = !1,
            a.depthFunc = THREE.LessEqualDepth,
            a.depthWrite = !1,
            a.colorWrite = !0,
            a.stencilWrite = !0,
            a.stencilWriteMask = 255,
            a.stencilFunc = THREE.LessEqualStencilFunc,
            a.stencilRef = 1,
            a.stencilFuncMask = 255,
            a.stencilFail = THREE.ZeroStencilOp,
            a.stencilZFail = THREE.ZeroStencilOp,
            a.stencilZPass = THREE.ZeroStencilOp,
            this._coordinates = M.a._processGeojson(this._coordinates, "Polygon"),
            this._createPolygonOnTerrain(this._coordinates)
        }
        get maxHeight() {
            return this._maxHeight
        }
        get minHeight() {
            return this._minHeight
        }
        _createPolygonOnTerrain(t) {
            t && this._createPolygonShadowVolume(t)
        }
        _renderShadowVolume(t, e) {
            var n = new THREE.Mesh(t,this._material_1);
            n.renderOrder = CMAP.GeoLineOnTerrainRenderOrder + 1,
            n.renderLayer = 1,
            e.add(n);
            let r = n.clone();
            r.material = this._material_2,
            r.renderOrder = CMAP.GeoLineOnTerrainRenderOrder + 2,
            r.renderLayer = 1,
            e.add(r);
            let a = n.clone();
            a.material = this._material_3,
            a.renderOrder = CMAP.GeoLineOnTerrainRenderOrder + 3,
            a.renderLayer = 1,
            e.add(a),
            this.node.add(e),
            CMAP.GeoLineOnTerrainRenderOrder = CMAP.GeoLineOnTerrainRenderOrder + 3
        }
        _createPolygonShadowVolume(t) {
            let e = []
              , n = M.a.processPolygon(t)
              , r = new THREE.Group;
            r.setPosition(n.centerWorld),
            r.setDirection(n.centerWorld, 2, [0, 1, 0]),
            r.updateMatrixWorld();
            let a = r;
            var i = M.a.createPolygonGeometry(t, a, 0, this._maxHeight, void 0, void 0, !1, void 0, !0);
            e = e.concat(i.polygonGeometry);
            var o = M.a.createPolygonGeometry(t, a, 0, -this._minHeight, void 0, void 0, !1, void 0, !0);
            e = e.concat(o.polygonGeometry);
            let s = THREE.BufferGeometryUtils1.mergeBufferGeometries(e);
            this._renderShadowVolume(s, r)
        }
        _processGeometryData(t, e) {
            let n = t.indices
              , r = t.attributes.position.values
              , a = t.attributes.normal.values
              , i = new Float32Array(r.length)
              , o = new Float32Array(a.length)
              , s = new Float32Array(r.length)
              , l = 0;
            0 !== e.position.x && 0 !== e.position.y && 0 !== e.position.z && (l = CMAP.Util.convertWorldToLonlat(e.position)[2]);
            for (let t = 0; t < r.length / 3; t++) {
                let n = [r[3 * t], r[3 * t + 1], r[3 * t + 2]]
                  , a = e.convertWorldToLocalPosition(n)
                  , u = new THREE.Vector3(n[0],n[1],n[2])
                  , c = new THREE.Matrix4;
                c.getInverse(e.matrix);
                let h = u.transformDirection(c);
                i[3 * t] = a[0],
                i[3 * t + 1] = a[1] + l,
                i[3 * t + 2] = a[2],
                o[3 * t] = h.x,
                o[3 * t + 1] = h.y,
                o[3 * t + 2] = h.z;
                let d = CMAP.Util.convertWorldToLonlat(n);
                s[3 * t] = d[0],
                s[3 * t + 1] = d[1],
                s[3 * t + 2] = d[2]
            }
            let u = new THREE.BufferGeometry;
            return u.setIndex(new THREE.BufferAttribute(n,1)),
            u.addAttribute("position", new THREE.BufferAttribute(i,3)),
            u.addAttribute("coordinates", new THREE.BufferAttribute(s,3)),
            u.groups = t.groups,
            u
        }
    }
    THING.factory.registerClass("GroundGeoPolygon", ue);
    var ce = ue;
    class he extends oe {
        constructor(t) {
            super(t),
            this.app = t,
            this._pointList = []
        }
        setup(t) {
            this.yScale = t.yScale || 1,
            t.isLonlat = !1,
            super.setup(t)
        }
        set pointList(t) {
            this._pointList = t
        }
        get pointList() {
            return this._pointList.flat()
        }
        createUV(t, e) {
            return M.a.createUV(this._pointList, void 0, !1)
        }
        setPointList(t, e) {
            if (Math.abs(t[0][0] - t[1][0]) > 180)
                for (let e = 0; e < t.length; e++)
                    t[e][0] < 0 && (t[e][0] += 360);
            if (void 0 === e && (e = [0, 0]),
            this._startPos = CMAP.Util.convertLonlatToWorld(t[0], e[0]),
            this._endPos = CMAP.Util.convertLonlatToWorld(t[1], e[1]),
            this._centerPos = [(this._startPos[0] + this._endPos[0]) / 2, (this._startPos[1] + this._endPos[1]) / 2, (this._startPos[2] + this._endPos[2]) / 2],
            this._distance = THING.Math.getDistance(this._startPos, this._endPos),
            this._sphereDistance = CMAP.Util.getSphericalDistance(t[0], t[1]),
            this._controlPointHeight = .3530730909813764 * this._distance,
            0 === e[0] && 0 === e[1]) {
                const e = [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2]
                  , n = CMAP.Util.convertLonlatToWorld(e)
                  , r = THING.Math.getDistance(n, this._centerPos);
                this._controlPointHeight = .8 * r + this._sphereDistance / 3,
                this._middleControlPointPos = CMAP.Util.convertLonlatToWorld(e, this._controlPointHeight)
            } else {
                const e = (new THREE.Plane).setFromCoplanarPoints(new THREE.Vector3(0,0,0), new THREE.Vector3(this._startPos[0],this._startPos[1],this._startPos[2]), new THREE.Vector3(this._endPos[0],this._endPos[1],this._endPos[2])).normal
                  , n = CMAP.Util.convertLonlatToWorld(t[0])
                  , r = CMAP.Util.convertLonlatToWorld(t[1])
                  , a = THING.Math.getDistance(n, r)
                  , i = Math.acos(a / this._distance)
                  , o = new THREE.Vector3(this._centerPos[0],this._centerPos[1],this._centerPos[2]).applyAxisAngle(e, i).normalize().multiplyScalar(this._controlPointHeight)
                  , s = new THREE.Vector3(this._centerPos[0],this._centerPos[1],this._centerPos[2]).add(o);
                this._middleControlPointPos = s.toArray()
            }
            this._sphereDistance / this._distance < 1.3 && (this._pointList = CMAP.Util.caculateBezier(this._startPos, this._middleControlPointPos, this._endPos, 50),
            this._topPos = this._pointList[25])
        }
        _caculateGeometry(t, e, n, r) {
            this._setNodePositionAndDirection();
            let a = this._createGeoObject(this.coordinates, t, e, n, this._isLonlat, r)
              , i = t3djs.util.mergeBufferGeometry(a.geometryArray);
            for (let t = 0; t < this.node.children.length; t++)
                this.node.children[t].geometry = i[t]
        }
        _setNodePositionAndDirection() {
            if (void 0 === this._heightArray && (this._heightArray = [0, 0]),
            this.setPointList(this.coordinates, this.heightArray),
            0 === this._layer.position.x && 0 === this._layer.position.y && 0 === this._layer.position.z) {
                var t = new THREE.Object3D
                  , e = t3djs.math.normalizeVector([this._centerPos[0], this._centerPos[1], this._centerPos[2]]);
                e = new THREE.Vector3(e[0],e[1],e[2]);
                var n = new THREE.Quaternion;
                n.setFromUnitVectors(new THREE.Vector3(0,1,0), e),
                t.setRotationFromQuaternion(n);
                var r = t3djs.math.subtractVectors(this._startPos, this._endPos);
                (r = new THREE.Vector3(r[0],r[1],r[2])).normalize(),
                t.translate([0, 0, 1]);
                var a = new THREE.Vector3(t.position.x,t.position.y,t.position.z);
                a.normalize();
                var i = (new THREE.Vector3).crossVectors(a, r);
                i.normalize();
                var o = r.angleTo(a);
                i.x * e.x < 0 && (o = 2 * Math.PI - o),
                this._layer.setRotationFromQuaternion(n),
                this._layer.rotateY(o),
                this._layer.setPosition(this._centerPos),
                this._layer.translate([0, this.offsetHeight, 0]),
                this._particalParent.setRotationFromQuaternion(n),
                this._particalParent.rotateY(o),
                this._particalParent.setPosition(this._centerPos),
                this._particalParent.translate([0, this.offsetHeight, 0])
            }
            let s = null;
            if (this._sphereDistance / this._distance < 1.3)
                ;
            else {
                const t = (s = new THREE.CubicBezierCurve3(new THREE.Vector3(0,0,-.5),new THREE.Vector3(0,.7,-.7),new THREE.Vector3(0,.7,.7),new THREE.Vector3(0,0,.5))).getPoints(50)
                  , e = new THREE.Object3D;
                e.applyMatrix4(this._layer.matrix),
                e.scale.set(this._distance, this._distance, this._distance),
                e.updateMatrixWorld();
                for (let n = 0; n < t.length; n++)
                    this._pointList.push(e.localToWorld(t[n]).toArray());
                this._topPos = this._pointList[25]
            }
        }
        createGeometry(t, e, n, a, i, o, s) {
            for (var l = [], u = 0; u < this._pointList.length; u++) {
                for (var c = this._pointList[u], h = [], d = [], f = 0; f < c.length; f++) {
                    var p, m = c[f];
                    p = o ? r.a.convertLonlatToWorld(m) : m;
                    var g = e.convertWorldToLocalPosition(p);
                    h.push(g[0]),
                    h.push(g[1]),
                    h.push(g[2]),
                    f < c.length - 1 && (d.push(f),
                    d.push(f + 1))
                }
                var v = {
                    position: h,
                    index: d
                }
                  , y = M.a._getT3dLineType(n)
                  , _ = t3djs.util.createGeometry(y, v, {
                    line: {
                        width: a,
                        up: [0, 1, 0],
                        uvRatio: 1,
                        uStep: s
                    }
                });
                l.push(_)
            }
            return l
        }
    }
    THING.factory.registerClass("GeoFlyLine2", he);
    var de = he;
    class fe extends de {
        constructor(t) {
            super(t)
        }
        setPointList(t, e) {
            const n = r.a.deepCopy(t);
            if (Math.abs(n[0][0] - n[1][0]) > 180)
                for (let t = 0; t < n.length; t++)
                    n[t][0] < 0 && (n[t][0] += 360);
            void 0 === e && (e = [0, 0]),
            this._startPos = CMAP.Util.convertLonlatToWorld(n[0], e[0]),
            this._endPos = CMAP.Util.convertLonlatToWorld(n[1], e[1]),
            this._centerPos = [(this._startPos[0] + this._endPos[0]) / 2, (this._startPos[1] + this._endPos[1]) / 2, (this._startPos[2] + this._endPos[2]) / 2],
            this._distance = THING.Math.getDistance(this._startPos, this._endPos),
            this._sphereDistance = CMAP.Util.getSphericalDistance(n[0], n[1])
        }
        get offsetHeight() {
            return this._offsetHeight
        }
        set offsetHeight(t) {
            t !== this._offsetHeight && (this._offsetHeight = t,
            this._caculateGeometry(this.renderer.lineType, this.renderer.width, this.heightArray, this.renderer.textureSize))
        }
        get heightArray() {
            return this._heightArray
        }
        set heightArray(t) {
            CMAP.Util.isArrayEqual(t, this._heightArray) || (this._heightArray = t,
            this._caculateGeometry(this.renderer.lineType, this.renderer.width, this.heightArray, this.renderer.textureSize))
        }
        _caculateGeometry(t, e, n, r) {
            this._resetFlyLine(),
            super._caculateGeometry(t, e, n, r)
        }
        _resetFlyLine() {
            this.position = [0, 0, 0],
            this.scale = [1, 1, 1],
            this.angles = [0, 0, 0],
            this.pointList = []
        }
        _setNodePositionAndDirection() {
            void 0 === this._heightArray && (this._heightArray = [0, 0]);
            const t = this._heightArray.slice(0);
            void 0 !== this.offsetHeight && (t[0] += this.offsetHeight,
            t[1] += this.offsetHeight),
            this.pointList = this._calcuPointListResult(this.coordinates, t, !0),
            this._setTopPos(51)
        }
        _setTopPos(t) {
            const e = Math.floor(this._pointList.length / 2)
              , n = this._pointList[e]
              , r = n.length / t
              , a = Math.floor(r / 2) * t + Math.floor(t / 2);
            this._topPos = n[a]
        }
        _calcuPointListResult(t, e, n) {
            if (JSON.stringify(t).includes("[[[")) {
                var r = [];
                const n = Math.floor(t.length / 2);
                for (var a = 0; a < t.length; a++) {
                    const i = n === a;
                    let o = this._calcuPointListResult(t[a], e, i);
                    r.push(o[0])
                }
                return r
            }
            var i = [];
            const o = Math.floor((t.length - 1) / 2);
            for (let r = 0; r < t.length - 1; r++) {
                var s = t[r]
                  , l = t[r + 1];
                const a = r === o && n;
                var u = this._calcuPointList([s, l], e, a);
                u && (i = i.concat(u))
            }
            return [i]
        }
        _calcuPointList(t, e, n) {
            if (t && r.a.isArrayEqual(t[0], t[1]))
                return;
            this.setPointList(t, e);
            const a = new THREE.Group
              , i = (new THREE.Plane).setFromCoplanarPoints(new THREE.Vector3(0,0,0), new THREE.Vector3(this._startPos[0],this._startPos[1],this._startPos[2]), new THREE.Vector3(this._endPos[0],this._endPos[1],this._endPos[2])).normal;
            let o = t3djs.math.subtractVectors(this._startPos, this._endPos);
            (o = new THREE.Vector3(o[0],o[1],o[2])).normalize();
            let s = o.clone().applyAxisAngle(i, Math.PI / 2).normalize();
            const l = (new THREE.Vector3).crossVectors(s, o);
            l.normalize();
            const u = (new THREE.Matrix4).makeBasis(l, s, o);
            u.setPosition(this._centerPos[0], this._centerPos[1], this._centerPos[2]),
            a.applyMatrix4(u),
            a.updateMatrixWorld(),
            n && (this.node.applyMatrix4(u),
            this.node.updateMatrixWorld()),
            this._particalParent.applyMatrix4(u),
            this._particalParent.updateMatrixWorld();
            let c = null;
            if (this._sphereDistance / this._distance < 1.3) {
                let t = new THREE.Vector3(0,0,-.5)
                  , e = new THREE.Vector3(0,.7,0)
                  , n = new THREE.Vector3(0,0,.5);
                c = new THREE.QuadraticBezierCurve3(n,e,t)
            } else {
                let t = new THREE.Vector3(0,0,-.5)
                  , e = new THREE.Vector3(0,.7,-.7)
                  , n = new THREE.Vector3(0,.7,.7)
                  , r = new THREE.Vector3(0,0,.5);
                c = new THREE.CubicBezierCurve3(r,n,e,t)
            }
            const h = c.getPoints(50)
              , d = new THREE.Object3D;
            d.applyMatrix4(a.matrix),
            d.scale.set(this._distance, this._distance, this._distance),
            d.updateMatrixWorld();
            const f = [];
            for (let t = 0; t < h.length; t++)
                f.push(d.localToWorld(h[t]).toArray());
            return this._topPos = f[25],
            f
        }
        _setupInfoWindow(t) {
            if ("GeoFlyLine" === this.type && t.infoWindow && !t.infoWindow._originOffset && this._topPos) {
                const e = CMAP.Util.convertWorldToLonlat(this._topPos)[2]
                  , n = CMAP.Util.convertWorldToLonlat(this.position)[2];
                t.infoWindow.offset = [0, e - n, 0]
            }
            super._setupInfoWindow(t)
        }
    }
    THING.factory.registerClass("GeoFlyLine", fe);
    var pe = fe;
    class me extends pe {
        constructor(t) {
            super(t)
        }
        setup(t) {
            super.setup(t)
        }
        getControlPoint(t, e, n) {
            var r, a, i = t[0], o = t[1], s = e[0], l = e[1];
            return i === s && o === l ? [i, o] : (s >= i && l >= o ? (r = l === o ? (i + s) / 2 : (i + s) / 2 - n / Math.sqrt(Math.pow((s - i) / (l - o), 2) + 1),
            a = s === i ? (o + l) / 2 : (o + l) / 2 + n / Math.sqrt(Math.pow((l - o) / (s - i), 2) + 1)) : s >= i && l < o ? (r = (i + s) / 2 + n / Math.sqrt(Math.pow((s - i) / (l - o), 2) + 1),
            a = s === i ? (o + l) / 2 : (o + l) / 2 + n / Math.sqrt(Math.pow((l - o) / (s - i), 2) + 1)) : s < i && l < o ? (r = (i + s) / 2 + n / Math.sqrt(Math.pow((s - i) / (l - o), 2) + 1),
            a = (o + l) / 2 - n / Math.sqrt(Math.pow((l - o) / (s - i), 2) + 1)) : s < i && l >= o && (r = l === o ? (i + s) / 2 : (i + s) / 2 - n / Math.sqrt(Math.pow((s - i) / (l - o), 2) + 1),
            a = (o + l) / 2 - n / Math.sqrt(Math.pow((l - o) / (s - i), 2) + 1)),
            [r, a])
        }
        setPointList(t) {
            var e = CMAP.Util.convertLonlatToWebMercator(t[0])
              , n = CMAP.Util.convertLonlatToWebMercator(t[1])
              , r = CMAP.Util.getSphericalDistance(t[0], t[1])
              , a = this.getControlPoint(e, n, r / 5)
              , i = t3djs.math.caculateBezier([e[0], 0, e[1]], [a[0], 0, a[1]], [n[0], 0, n[1]])
              , o = new Array;
            i.map(function(t) {
                var e = CMAP.Util.convertWebMercatorToLonlat([t[0], t[2]])
                  , n = CMAP.Util.convertLonlatToWorld(e);
                o.push(n)
            }),
            this._pointList = o;
            var s = CMAP.Util.convertLonlatToWorld([(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2]);
            this._centerPos = s
        }
        _setNodePositionAndDirection() {
            this._pointList = this._calcuPointListResult(this.coordinates),
            this._setCenterPos(51),
            this._layer.setPosition(this._centerPos),
            this._layer.setDirection(this._centerPos, 2, [0, 1, 0]),
            this._layer.translate([0, this.offsetHeight, 0]),
            this._particalParent.setPosition(this._centerPos),
            this._particalParent.setDirection(this._centerPos, 2, [0, 1, 0]),
            this._particalParent.translate([0, this.offsetHeight, 0])
        }
        _setCenterPos(t) {
            const e = Math.floor(this._pointList.length / 2)
              , n = this._pointList[e]
              , r = n.length / t
              , a = Math.floor(r / 2) * t + Math.floor(t / 2);
            this._centerPos = n[a]
        }
        _calcuPointListResult(t) {
            if (JSON.stringify(t).includes("[[[")) {
                var e = [];
                for (let n = 0; n < t.length; n++) {
                    const r = this._calcuPointListResult(t[n]);
                    e.push(r[0])
                }
                return e
            }
            var n = [];
            for (let e = 0; e < t.length - 1; e++) {
                var r = t[e]
                  , a = t[e + 1];
                this.setPointList([r, a]),
                n = n.concat(this._pointList)
            }
            return [n]
        }
    }
    THING.factory.registerClass("GeoODLine", me);
    class ge extends Zt {
        constructor(t) {
            super(t),
            this.app = t
        }
        setup(t) {
            this.isInfoShow = !1,
            this._featureLayerId = t._featureLayerId,
            this._conditionStr = t._conditionStr,
            this.name = t.name || "geoBuilding_" + r.a.getUUID(),
            this.id = t.id || this.name,
            this._coordinates = t.coordinates,
            this._userData = THING.Utils.parseValue(t.userData, {}),
            this._renderer = new jt(this,t.renderer),
            this._clampToGround = THING.Utils.parseValue(t.clampToGround, !0),
            this._setOffsetHeightAndField(t),
            this._layer = new THREE.Group,
            this.node = this._layer,
            this._node = new THREE.Object3D,
            this._node.add(this._layer),
            this._pickWithGeometryID = void 0 !== t.pickWithGeometryID && t.pickWithGeometryID,
            this.referencePosition = [0, 0, 0],
            this._material = void 0,
            this._setExtrudeHeightAndField(t),
            this._originTextureSize = this._lastRepeatTextureSize = this._lastRepeatYTextureSize = this.renderer.textureSize,
            this._originWindowTextureSize = this._lastWindowTextureSize = THING.Utils.parseValue(this.renderer.windowTextureSize, M.a._defuaultBuildingWindowTextureSize),
            this.init(),
            this.setupUserData(t),
            this._setupLabel(t),
            this._setupInfoWindow(t),
            this.setupComplete(t)
        }
        _setExtrudeHeightAndField(t) {
            this._extrudeField = t.renderer.extrudeField || t.extrudeField || "",
            this._extrudeFactor = t.renderer.extrudeFactor || t.extrudeFactor || 1,
            this._defaultHeight = .1;
            let e = t.height || t.extrudeHeight || t.renderer.extrudeHeight
              , n = this._defaultHeight;
            this._extrudeField && (n = this._userData[this.extrudeField],
            n *= this.extrudeFactor - 0),
            e && !isNaN(e) && e > 0 && (n = e),
            n && !isNaN(n) || (n = this._defaultHeight),
            this.height = this._originHeight = n
        }
        on() {
            if (arguments.length < 2)
                THING.Utils.log("参数不合法");
            else {
                for (var t in arguments) {
                    let e = arguments[t];
                    if (THING.Utils.isFunction(e)) {
                        arguments[t] = function(t) {
                            var n = 0;
                            CMAP.getCurrentMap().pickIdBuffer.forEach(function(e) {
                                e.node === t.object.node && (n = t.id - e.start - CMAP.pickIdStartNum)
                            }),
                            t.coordinates = t.object.coordinates[n],
                            t.height = t.object.height,
                            e.call(t.object, t)
                        }
                    }
                }
                super.on.apply(this, arguments)
            }
        }
        setupUserData(t) {
            t || (t = {}),
            this._pickWithGeometryID && (t.withGeometryIDAttributes = !0),
            super.setupUserData(t)
        }
        _setScale(t) {
            let e = this.scale[1];
            super._setScale(t),
            this._setRepeatUV(t[1], e)
        }
        _setRepeatUV(t, e) {
            var n = this.node.getMeshes();
            for (var r in n) {
                let i = n[r].geometry.groups[1]
                  , o = 2 * i.start
                  , s = 2 * i.count
                  , l = t / e
                  , u = n[r].geometry;
                if (u.attributes.uv1 && u.attributes.uv3 && u.attributes.uv8) {
                    let t = n[r].geometry.attributes.uv1.array
                      , e = n[r].geometry.attributes.uv3.array
                      , i = n[r].geometry.attributes.uv8.array;
                    for (var a = o; a < o + s; a += 2)
                        t[a + 1] = t[a + 1] * l,
                        e[a + 1] = e[a + 1] * l,
                        i[a + 1] = i[a + 1] * l;
                    u.addAttribute("uv1", new THREE.BufferAttribute(t,2)),
                    u.addAttribute("uv3", new THREE.BufferAttribute(e,2)),
                    u.addAttribute("uv8", new THREE.BufferAttribute(i,2)),
                    this.renderer.textureWrap === CMAP.TextureWrapMode.RepeatY ? (u.addAttribute("uv", new THREE.BufferAttribute(t,2)),
                    u.attributes.uv.needsUpdate = !0) : this.renderer.textureWrap === CMAP.TextureWrapMode.Repeat && (u.addAttribute("uv", new THREE.BufferAttribute(e,2)),
                    u.attributes.uv.needsUpdate = !0)
                }
            }
        }
        _updateBuildingWindowTexture(t, e) {
            if (Array.isArray(t) && Array.isArray(e) && t.length === e.length && 2 === t.length && (t[0] !== e[0] || t[1] !== e[1])) {
                var n = this.node.getMeshes();
                for (var r in n) {
                    let i = n[r].geometry.groups[1]
                      , o = 2 * i.start
                      , s = 2 * i.count
                      , l = e[0] / t[0]
                      , u = e[1] / t[1]
                      , c = n[r].geometry;
                    if (c.attributes.uv8) {
                        let t = n[r].geometry.attributes.uv8.array;
                        for (var a = o; a < o + s; a += 2)
                            t[a] = t[a] * l,
                            t[a + 1] = t[a + 1] * u;
                        c.addAttribute("uv8", new THREE.BufferAttribute(t,2))
                    }
                }
            }
        }
        _updateBuildingTextureSize(t) {
            if (Array.isArray(t) && 2 === t.length) {
                var e = this.node.getMeshes();
                for (var n in e) {
                    let r = e[n].geometry.groups[1]
                      , a = 2 * r.start
                      , i = 2 * r.count
                      , o = e[n].geometry;
                    if (this.renderer.textureWrap === CMAP.TextureWrapMode.Repeat && o.attributes.uv3) {
                        if (this._lastRepeatTextureSize[0] === t[0] && this._lastRepeatTextureSize[1] === t[1])
                            continue;
                        let r = this._lastRepeatTextureSize[0] / t[0]
                          , s = this._lastRepeatTextureSize[1] / t[1]
                          , l = e[n].geometry.attributes.uv3.array;
                        for (let t = a; t < a + i; t += 2)
                            l[t] = l[t] * r,
                            l[t + 1] = l[t + 1] * s;
                        o.addAttribute("uv3", new THREE.BufferAttribute(l,2)),
                        o.addAttribute("uv", new THREE.BufferAttribute(l,2)),
                        o.attributes.uv.needsUpdate = !0,
                        this._lastRepeatTextureSize = t
                    }
                    if (this.renderer.textureWrap === CMAP.TextureWrapMode.RepeatY && o.attributes.uv1) {
                        if (this._lastRepeatYTextureSize[0] === t[0] && this._lastRepeatYTextureSize[1] === t[1])
                            continue;
                        let r = this._lastRepeatYTextureSize[1] / t[1]
                          , s = e[n].geometry.attributes.uv1.array;
                        for (let t = a; t < a + i; t += 2)
                            s[t + 1] = s[t + 1] * r;
                        o.addAttribute("uv1", new THREE.BufferAttribute(s,2)),
                        o.addAttribute("uv", new THREE.BufferAttribute(s,2)),
                        o.attributes.uv.needsUpdate = !0,
                        this._lastRepeatYTextureSize = t
                    }
                }
            } else
                THING.Utils.warn("材质尺寸参数不合法")
        }
        get offsetHeight() {
            return this._offsetHeight
        }
        set offsetHeight(t) {
            if (this._arrayOffsetHeight)
                this._offsetHeight = t,
                this._arrayOffsetHeight = null,
                this._updateOffsetHeight(t);
            else if (t !== this._offsetHeight) {
                var e = t - this._offsetHeight;
                this.translate([0, e, 0]),
                this._offsetHeight = t
            }
        }
        get extrudeHeight() {
            return this.height
        }
        set extrudeHeight(t) {
            this.height = t
        }
        get height() {
            return this._height
        }
        set height(t) {
            var e = ((t = t || this._defaultHeight) - 0) / this._originHeight;
            this.scale = [1, e, 1],
            this._height = t - 0
        }
        get extrudeFactor() {
            return this._extrudeFactor
        }
        get extrudeField() {
            return this._extrudeField
        }
        set extrudeFactor(t) {
            this.updateExtrudeFactor(t),
            this._extrudeFactor = t,
            this.renderer._extrudeFactor = t
        }
        set extrudeField(t) {
            this.updateExtrudeField(t),
            this._extrudeField = t,
            this.renderer._extrudeField = t
        }
        init() {
            this._polygonInfo = M.a.processPolygon(this._coordinates, 0, "BUILDING"),
            this._multiPolygonCoordinates = this._polygonInfo.coordinates,
            this.referencePosition = r.a.convertLonlatToWorld(this._polygonInfo.center, this.offsetHeight);
            var t = r.a.position2angles(this.referencePosition)
              , e = r.a.anglesToQuaternion(t);
            this.renderer._quaternion = e.inverse();
            for (var n = this.createGeometry(this._multiPolygonCoordinates, this.referencePosition, this.height, this._arrayOffsetHeight ? this._arrayOffsetHeight : this.offsetHeight), a = this.createMaterial(), i = 0; i < n.length; i++) {
                var o = this.createMesh(n[i], a, this.renderer);
                "cool" === this.renderer.type && this.renderer.effect && this.app.effectManager.setEffect(o, "glow", this.renderer.glowStrength),
                this._layer.add(o)
            }
            this._layer.setPosition(this.referencePosition),
            M.a._setNodeAnglesByPosition(this._layer, this._polygonInfo.centerWorld)
        }
        _setArrayOffsetHeight(t) {
            this._updateOffsetHeight(t)
        }
        _updateOffsetHeight(t) {
            var e = this.createGeometry(this._multiPolygonCoordinates, this.referencePosition, this.height, t);
            for (let t = 0; t < this._getMeshes().length; t++)
                M.a._updateBuildingTextureWrap(e[t], this.renderer.textureWrap),
                this._getMeshes()[t].geometry = e[t],
                this._getMeshes()[t].geometry.needsUpdate = !0
        }
        createGeometry(t, e, n, r) {
            const a = this._clampToGround;
            var i, o = M.a.createBuilding(t, n, e, "BUILDING", this.renderer.textureSize, void 0, r, a, this.renderer.windowTextureSize).geometryArray, s = CMAP.getCurrentMap().pickIdBuffer;
            i = 0 === s.length ? {
                start: 0,
                count: 0,
                node: this.node
            } : {
                start: s[s.length - 1].start + s[s.length - 1].count,
                count: 0,
                node: this.node
            },
            s.push(i);
            for (var l = 0; l < o.length; l++) {
                var u = o[l].attributes.position.count
                  , c = new Float32Array(u)
                  , h = i.start + l;
                c.fill(CMAP.pickIdStartNum + h),
                o[l].addAttribute("id", new THREE.BufferAttribute(c,1)),
                s[s.length - 1].count++
            }
            var d = t3djs.util.mergeBufferGeometry(o, 5e4, !0);
            for (let t = 0; t < d.length; t++) {
                var f = d[t];
                f.addAttribute("uv1", f.attributes.uv, 2),
                f.attributes.uv1.name = "repeatY",
                f.attributes.uv2.name = "stretch",
                f.attributes.uv3.name = "repeat"
            }
            return d
        }
        createMesh(t, e, n) {
            return M.a.createBuildingMesh(t, e, n)
        }
        createMaterial() {
            var t = this.renderer
              , e = JSON.parse(JSON.stringify(t.toObject()));
            return e.quaternion = this.renderer._quaternion,
            Ut.createBuildingMaterial(e, this.extrudeHeight)
        }
        updateMaterial() {
            var t = this.createMaterial()
              , e = this._layer.getMeshes();
            for (var n in e) {
                e[n].material = t
            }
            setTimeout(function() {
                THING.App.current.rendererManager._mainRenderer.dirty("Glow")
            }, 0)
        }
        updateRenderer(t) {
            "cool" !== t.type && (t.effect = !1),
            super.updateRenderer(t);
            var e = this.renderer._quaternion
              , n = new jt(this,t);
            n._quaternion = e,
            r.a._needsUpdateExtrudeField(t.extrudeField) && (this.extrudeField = t.extrudeField),
            THING.Utils.isNull(t.extrudeFactor) || this.extrudeFactor === t.extrudeFactor || (this.extrudeFactor = n.extrudeFactor),
            THING.Utils.isNull(t.extrudeHeight) || THING.Utils.isNull(this.extrudeField) || (this.extrudeHeight = THING.Utils.parseValue(t.extrudeHeight, this._defaultHeight) - 0);
            var a = this.renderer.windowTextureSize;
            this._renderer = n,
            this.updateTextureWrap(t.textureWrap),
            t.textureSize && this._updateBuildingTextureSize(t.textureSize),
            t.windowTextureSize = THING.Utils.parseValue(t.windowTextureSize, M.a._defaultWindowTextureSize),
            this._updateBuildingWindowTexture(t.windowTextureSize, a),
            this.updateMaterial(),
            THING.App.current.rendererManager._mainRenderer.dirty()
        }
        updateExtrudeFactor(t) {
            if (this.extrudeField) {
                let e = t * this._userData[this.extrudeField];
                void 0 === e || isNaN(e) || 0 === e ? this.extrudeHeight = this._defaultHeight : this.extrudeHeight = e
            }
            THING.App.current.rendererManager._mainRenderer.dirty("Glow")
        }
        updateExtrudeField(t) {
            if ("" === t || void 0 === t)
                this.extrudeHeight = this._defaultHeight;
            else {
                let e = this.extrudeFactor * this._userData[t];
                void 0 === e || isNaN(e) || 0 === e ? this.extrudeHeight = this._defaultHeight : this.extrudeHeight = e
            }
            THING.App.current.rendererManager._mainRenderer.dirty("Glow")
        }
        updateTextureWrap(t) {
            if (t === CMAP.TextureWrapMode.Repeat || t === CMAP.TextureWrapMode.Stretch || t === CMAP.TextureWrapMode.RepeatY) {
                for (var e in this.node.getMeshes()) {
                    var n = this.node.getMeshes()[e].geometry;
                    M.a._updateBuildingTextureWrap(n, t)
                }
                THING.App.current.rendererManager._mainRenderer.dirty("Glow")
            }
        }
    }
    THING.factory.registerClass("GeoBuilding", ge);
    var ve = ge;
    var ye = class extends Dt {
        constructor(t, e) {
            super(t, e),
            this._object = t,
            this._imageUrl = e.imageUrl,
            this._alphaImageUrl = e.alphaImageUrl,
            this._useColor = THING.Utils.parseValue(e.useColor, !1),
            this._useAlphaMap = THING.Utils.parseValue(e.useAlphaMap, !0),
            this._opacity = THING.Utils.parseValue(e.opacity, 1),
            e.color = THING.Utils.parseValue(e.color || [255, 255, 255]),
            this._color = r.a.colorFormatNewToOld(e.color, this._opacity) || [1, 1, 1, 1],
            this._opacity = this._color[3],
            this._uvRatio = THING.Utils.parseValue(e.uvRatio || [1, 1]),
            this._blending = THING.Utils.parseValue(e.blending, !1),
            this._keepSpeed = THING.Utils.parseValue(e.keepSpeed, !1),
            this._speed = THING.Utils.parseValue(e.speed, [0, 0]),
            this._alphaSpeed = THING.Utils.parseValue(e.alphaSpeed, [0, 0]),
            Array.isArray(this._alphaSpeed) || (this._alphaSpeed = [this._alphaSpeed, 0]),
            Array.isArray(this._speed) || (this._speed = [this._speed, 0]),
            Array.isArray(this._imageUrl) || (this._imageUrl = [this._imageUrl]),
            2 !== this._uvRatio.length || Array.isArray(this._uvRatio[0]) || (this._uvRatio = [this._uvRatio]),
            2 !== this._speed.length || Array.isArray(this._speed[0]) || (this._speed = [this._speed])
        }
        get keepSpeed() {
            return this._keepSpeed
        }
        get color() {
            return r.a.colorFormatOldToNew(this._color)
        }
        set color(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("color", t, !0, this._opacity) : (this._color = r.a.colorFormatNewToOld(t, this._opacity),
            this._opacity = this._color[3],
            this._object.updateMaterial())
        }
        get useColor() {
            return this._useColor
        }
        set useColor(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("useColor", t) : (this._useColor = t,
            this._object.updateMaterial())
        }
        get useAlphaMap() {
            return this._useAlphaMap
        }
        set useAlphaMap(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("useAlphaMap", t) : (this._useAlphaMap = t,
            this._object.updateMaterial())
        }
        get opacity() {
            return this._opacity
        }
        set opacity(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("opacity", t) : t !== this._opacity && (this._opacity = t,
            this._color[3] = t,
            this._object.updateMaterial())
        }
        get imageUrl() {
            return Array.isArray(this._imageUrl) && 1 === this._imageUrl.length ? this._imageUrl[0] : this._imageUrl
        }
        set imageUrl(t) {
            this._imageUrl = t,
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("imageUrl", t) : (t && !Array.isArray(t) && (t = [t]),
            this._imageUrl = t,
            this._object.updateMaterial())
        }
        get uvRatio() {
            return Array.isArray(this._uvRatio) && 1 === this._uvRatio.length ? this._uvRatio[0] : this._uvRatio
        }
        set uvRatio(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("uvRatio", t) : this._uvRatio !== t && (this._uvRatio = this.processParam(t),
            this._object.updateMaterial())
        }
        get speed() {
            return Array.isArray(this._speed) && 1 === this._speed.length ? this._speed[0] : this._speed
        }
        set speed(t) {
            this._speed = t,
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("speed", t) : (this._speed = this.processParam(t),
            this._object.updateMaterial())
        }
        get alphaSpeed() {
            return this._alphaSpeed
        }
        set alphaSpeed(t) {
            this._alphaSpeed = t,
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("alphaSpeed", t) : (this._alphaSpeed = t,
            this._object.updateMaterial())
        }
        get alphaImageUrl() {
            return this._alphaImageUrl
        }
        set alphaImageUrl(t) {
            this._alphaImageUrl = t,
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("alphaImageUrl", t) : (this._alphaImageUrl = t,
            this._object.updateMaterial())
        }
        get blending() {
            return this._blending
        }
        set blending(t) {
            this._blending = t,
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("blending", t) : (this._blending = t,
            this._object.updateMaterial())
        }
        processParam(t) {
            return t && Array.isArray(t) && !Array.isArray(t[0]) && (t = [t]),
            this.imageUrl && Array.isArray(this.imageUrl) && 2 === this.imageUrl.length && 1 === t.length && (t[1] = t[0]),
            t
        }
    }
    ;
    class _e extends Zt {
        constructor(t) {
            super(t),
            this.app = t
        }
        setup(t) {
            if (this._param = t,
            this.isInfoShow = !1,
            this.name = t.name || "geoPolygon_" + r.a.getUUID(),
            this.id = t.id || this.name,
            this._coordinates = t.coordinates,
            this._userData = THING.Utils.parseValue(t.userData, {}),
            void 0 === t.extrudeHeight && (t.extrudeHeight = t.height),
            this._extrudeHeight = void 0 === t.extrudeHeight ? 0 : t.extrudeHeight,
            this._originRenderer = t.renderer,
            this._setUpRenderer(t.renderer),
            this._processPolygonRenderer(),
            this._setOffsetHeightAndField(t),
            void 0 === t.renderer.extrudeField && void 0 === t.extrudeField ? this._extrudeField = "" : this._extrudeField = void 0 === t.extrudeField ? t.renderer.extrudeField : t.extrudeField,
            void 0 === t.renderer.extrudeFactor && void 0 === t.extrudeFactor ? this._extrudeFactor = 1 : this._extrudeFactor = void 0 === t.extrudeFactor ? t.renderer.extrudeFactor : t.extrudeFactor,
            this.extrudeField && !t.height && !t.extrudeHeight) {
                var e = this._userData[this.extrudeField];
                this._extrudeHeight = e ? this._userData[this.extrudeField] * this.extrudeFactor : 0
            }
            this.renderOrder = THING.Utils.parseValue(t.renderOrder, 0),
            this._layer = new THREE.Group,
            this.node = this._layer,
            this._featureLayerId = t._featureLayerId,
            this._conditionStr = t._conditionStr,
            this._useMercatorUV = THING.Utils.parseValue(t.useMercatorUV, !0),
            THING.Utils.isNull(t.useMercatorUV) && M.a._isRectangle(this.coordinates) && THING.Utils.isNull(t.renderer.textureSize) && (this._useMercatorUV = !1),
            this._useOutline = !0,
            this._beforeInit(t),
            this.init(!0),
            this._afterInit({
                renderer: this._renderer
            }),
            this.setupUserData(),
            this.setupParent(t),
            this._setupLabel(t),
            this._setupInfoWindow(t),
            this.setupComplete(t)
        }
        _setupLabel(t) {
            let e = r.a.getFeatureCollectionExtent({
                type: "Feature",
                geometry: {
                    type: "MultiPolygon",
                    coordinates: this._multiPolygonCoordinates
                }
            })
              , n = [(e.maxX + e.minX) / 2, (e.maxY + e.minY) / 2]
              , a = this.extrudeHeight + this.offsetHeight;
            Array.isArray(this._arrayOffsetHeight) && this._arrayOffsetHeight.length > 0 && (a += this._arrayOffsetHeight[0]),
            this.labelPosition = CMAP.Util.convertLonlatToWorld(n, a),
            t.label && super._setupLabel(t)
        }
        _setUpRenderer(t) {
            this._fillRenderer = new jt(this,t);
            let e = {}
              , n = {};
            for (let r in t)
                if (r.startsWith("outline")) {
                    let n = r.replace("outline", "");
                    e[n = n.charAt(0).toLowerCase() + n.slice(1)] = t[r]
                } else if (r.startsWith("boundary")) {
                    let e = r.replace("boundary", "");
                    n[e = e.charAt(0).toLowerCase() + e.slice(1)] = t[r]
                }
            void 0 === e.lineType && (e.lineType = "Plane"),
            void 0 === e.width && (e.width = 0),
            this._lineRenderer = new ae(this._outline,e),
            this._originLineRenderer = e,
            t.useBoundary && (this._boundaryRenderer = new ye(this._boundary,n),
            this._originBoundaryRenderer = n)
        }
        _processPolygonRenderer() {
            let t = this._fillRenderer.toObject()
              , e = this._lineRenderer.toObject()
              , n = this;
            this._renderer = {};
            for (let e in t)
                Object.defineProperty(this._renderer, e, {
                    configurable: !0,
                    enumerable: !0,
                    get: function() {
                        return n.fillRenderer[e]
                    },
                    set: function(t) {
                        n.fillRenderer[e] = t
                    }
                });
            for (let t in e) {
                let e = "outline" + t.charAt(0).toUpperCase() + t.slice(1);
                Object.defineProperty(this._renderer, e, {
                    configurable: !0,
                    enumerable: !0,
                    get: function() {
                        return n.lineRenderer[t]
                    },
                    set: function(e) {
                        ("lineType" === t || "width" === t && "Plane" !== n.renderer.outlineLineType) && n._outline.setParent(null),
                        n.lineRenderer[t] = e,
                        ("lineType" === t || "width" === t && "Plane" !== n.renderer.outlineLineType) && (n._setUpOutlineExtra(),
                        n.add(n._outline))
                    }
                })
            }
            if (this._boundaryRenderer) {
                let t = this._boundaryRenderer.toObject();
                t.extrudeHeight = THING.Utils.parseValue(this._originBoundaryRenderer.extrudeHeight, 100),
                t.offsetHeight = THING.Utils.parseValue(this._originBoundaryRenderer.offsetHeight, 0);
                for (let e in t) {
                    let t = "boundary" + e.charAt(0).toUpperCase() + e.slice(1);
                    Object.defineProperty(this._renderer, t, {
                        configurable: !0,
                        enumerable: !0,
                        get: function() {
                            return "offsetHeight" === e || "extrudeHeight" === e ? n._boundary[e] : n.boundaryRenderer[e]
                        },
                        set: function(t) {
                            "offsetHeight" === e || "extrudeHeight" === e ? (n._boundary.setParent(null),
                            n._boundary[e] = t,
                            n._setUpBoundaryExtra(),
                            n.add(n._boundary)) : n.boundaryRenderer[e] = t
                        }
                    })
                }
            }
        }
        get fillRenderer() {
            return this._fillRenderer
        }
        get lineRenderer() {
            return this._lineRenderer
        }
        get boundaryRenderer() {
            return this._boundaryRenderer
        }
        get offsetHeight() {
            return this._offsetHeight
        }
        set offsetHeight(t) {
            if (this._arrayOffsetHeight || t !== this._offsetHeight) {
                if (this._offsetHeight = t,
                this._arrayOffsetHeight = null,
                this._outLinePolygonHierarchyArray)
                    for (let t = 0; t < this._outLinePolygonHierarchyArray.length; t++)
                        this._outLinePolygonHierarchyArray[t].offsetHeight = 0;
                this._updateGeometry(!0)
            }
        }
        _setArrayOffsetHeight() {
            this._updateGeometry(!0)
        }
        get extrudeFactor() {
            return this._extrudeFactor
        }
        get extrudeField() {
            return this._extrudeField
        }
        set extrudeFactor(t) {
            if (this.extrudeField) {
                let e = t * this._userData[this.extrudeField];
                THING.Utils.isNull(e) || isNaN(e) || (this.extrudeHeight = e)
            }
            this._extrudeFactor = t,
            this._fillRenderer._extrudeFactor = t
        }
        set extrudeField(t) {
            let e = this.extrudeFactor * this._userData[t];
            e && !isNaN(e) ? this.extrudeHeight = e : this.extrudeHeight = 0,
            this._extrudeField = t,
            this._fillRenderer._extrudeField = t
        }
        get extrudeHeight() {
            return this._extrudeHeight
        }
        set extrudeHeight(t) {
            this._extrudeHeight !== t && (isNaN(t) && (t = 0),
            this._extrudeHeight = t,
            this._updateGeometry(!1))
        }
        set height(t) {
            this.extrudeHeight = t
        }
        get height() {
            return this._extrudeHeight
        }
        set renderOrder(t) {
            this.style.renderOrder = t,
            this._outline && (this._outline.style.renderOrder = t + .1),
            this._boundary && (this._boundary.style.renderOrder = t + .2)
        }
        get renderOrder() {
            return this.style.renderOrder
        }
        updateHeight(t, e) {
            if (void 0 === e || 0 === e)
                this.extrudeHeight = t;
            else {
                var n = this
                  , r = this.extrudeHeight;
                r > t && (e *= -1);
                CMAP.Updater.add("updateHeight_" + this.queryID, function() {
                    if (e > 0 && r + 1 * e > t || e < 0 && r + 1 * e < t)
                        return n.extrudeHeight = t,
                        void CMAP.Updater.delete("updateHeight_" + n.queryID);
                    n.extrudeHeight = r + 1 * e,
                    r = n.extrudeHeight
                })
            }
        }
        updateRenderer(t) {
            "cool" !== t.type && (t.effect = !1),
            r.a._needsUpdateExtrudeField(t.extrudeField) && (this.extrudeField = t.extrudeField),
            THING.Utils.isNull(t.extrudeFactor) || this.extrudeFactor === t.extrudeFactor || (this.extrudeFactor = t.extrudeFactor),
            THING.Utils.isNull(t.extrudeHeight) || THING.Utils.isNull(this.extrudeField) || (this.extrudeHeight = t.extrudeHeight - 0),
            this.extrudeHeight > 0 && (t.depthWrite = !0);
            var e = this._renderer.textureSize;
            this._setUpRenderer(t),
            this._updateMeshMatByRenderer();
            let n = !1;
            if (M.a._isRectangle(this.coordinates))
                for (let t = 0; t < this.node.getMeshes().length; t++) {
                    const r = this.node.getMeshes()[t];
                    "LINE" !== r.__type__ && "BOUNDARY" !== r.__type__ && (THING.Utils.isNull(this._fillRenderer._textureSize) ? (r.geometry.addAttribute("uv", r.geometry.attributes.uv2, 2),
                    n = !0) : THING.Utils.isNull(e) && (r.geometry.addAttribute("uv", r.geometry.attributes.uv1, 2),
                    e = THING.Utils.parseValue(this._originRenderer.textureSize, this._sizeInMeter)))
                }
            n || (e || (e = this._sizeInMeter),
            THING.Utils.isNull(this._fillRenderer._textureSize) && (this._fillRenderer._textureSize = this._sizeInMeter),
            this._updateMeshUV(e, this._fillRenderer._textureSize)),
            this._outline && (this._outline.setParent(null),
            this._outline.updateRenderer(this._originLineRenderer),
            this._setUpOutlineExtra(),
            this.add(this._outline)),
            t.useBoundary ? (this._boundary ? this._boundary.visible = !0 : this._drawBoundary(),
            this._boundary.setParent(null),
            this._boundary.updateRenderer(this._originBoundaryRenderer),
            this.add(this._boundary)) : this._boundary && (this._boundary.visible = !1),
            super.updateRenderer(t)
        }
        createGeometry(t, e, n, r, a, i) {
            return M.a.createPolygonGeometry(t, e, n, r, void 0, this._useMercatorUV, !0, a, !1, i)
        }
        _updateGeometry(t) {
            t && (this._polygonInfo = M.a.processPolygon(this._coordinates, this.offsetHeight),
            this._multiPolygonCoordinates = this._polygonInfo.coordinates,
            this.node.setPosition(this._polygonInfo.centerWorld),
            M.a._setNodeAnglesByPosition(this.node, this._polygonInfo.centerWorld),
            this.node.updateMatrixWorld());
            let e = this.offsetHeight;
            this._arrayOffsetHeight && (e = this._arrayOffsetHeight);
            let n = this.createGeometry(this._multiPolygonCoordinates, this.node, e, this.extrudeHeight, this._fillRenderer._textureSize, this._lineRenderer.lineType)
              , r = n.polygonGeometry;
            for (let t = 0; t < this.node.getMeshes().length; t++) {
                const e = this.node.getMeshes()[t];
                "LINE" !== e.__type__ && "BOUNDARY" !== e.__type__ && (e.geometry = r[0])
            }
            if (this._outline) {
                this._outlineCoordsAndHeightArray = null,
                r && r.length > 0 && (this._outLinePolygonHierarchyArray = n.outLinePolygonHierarchyArray),
                this._getOutlineCoordsAndHeightArray(),
                this._outline.setParent(null);
                const t = CMAP.Util.convertWorldToLonlat(this._outline.position)[2];
                for (let e = 0; e < this._outlineCoordsAndHeightArray.heightArray.length; e++)
                    for (let n = 0; n < this._outlineCoordsAndHeightArray.heightArray[e].length; n++)
                        this._outlineCoordsAndHeightArray.heightArray[e][n] -= t;
                this._outline._heightArray = this._outlineCoordsAndHeightArray.heightArray;
                var a = this._outline._createGeoObject(this._outlineCoordsAndHeightArray.coordinates, this._lineRenderer.lineType, this._lineRenderer.width, this._outlineCoordsAndHeightArray.heightArray, !0, this._lineRenderer.textureSize);
                this._outline._uvArray = a.uvArray,
                this._outline.totalLengthArray = a.totalLengthArray;
                let e = a.geometryArray
                  , i = t3djs.util.mergeBufferGeometry(e);
                this._outline.node.children[0].geometry = i[0],
                this._outline.node.children.length > 1 && (this._outline.node.children[1].dispose(),
                this._outline._createLineSprite(a.geometryArray.length)),
                this.add(this._outline)
            }
            this._boundary && (this._arrayOffsetHeight ? (this._boundary.destroy(),
            this._drawBoundary()) : (this._boundary.setParent(null),
            this._boundary.offsetHeight = this.offsetHeight + this.extrudeHeight,
            this.add(this._boundary)))
        }
        init(t) {
            0 === this.extrudeHeight ? this._fillRenderer.depthWrite = !1 : this._fillRenderer.depthWrite = !0,
            this._polygonInfo = M.a.processPolygon(this._coordinates, this.offsetHeight),
            this._multiPolygonCoordinates = this._polygonInfo.coordinates,
            this._layer.setPosition(this._polygonInfo.centerWorld),
            M.a._setNodeAnglesByPosition(this._layer, this._polygonInfo.centerWorld),
            this._layer.updateMatrixWorld(),
            this._fillRenderer._quaternion = r.a.positionToQuaternion(this._polygonInfo.centerWorld).inverse(),
            t && this._draw()
        }
        _getLineRenderer(t) {
            return {
                type: t.outlineType,
                width: t.outlineWidth,
                color: t.outlineColor,
                effect: t.outlineEffect,
                opacity: t.outlineOpacity,
                speed: t.outlineSpeed,
                uvRatio: t.outlineUVRatio,
                imageUrl: t.outlineImageUrl,
                lineType: "Plane"
            }
        }
        _createFillMaterial() {
            var t = JSON.parse(JSON.stringify(this._fillRenderer.toObject()));
            return Ut.createPolygonMaterial(t, this.extrudeHeight, this._fillRenderer._quaternion)
        }
        _getOutlineCoordsAndHeightArray() {
            if (!this._outlineCoordsAndHeightArray) {
                let t = this._outLinePolygonHierarchyArray
                  , e = []
                  , n = [];
                for (let r = 0; r < t.length; r++) {
                    let a = t[r]
                      , i = M.a._createPolygonOutLineParam(a, this.extrudeHeight, a.offsetHeight);
                    i.coordinates.length > 0 && (e.push(i.coordinates),
                    n.push(i.heightArray))
                }
                e = M.a._processGeojson(e, "LINE"),
                this._outlineCoordsAndHeightArray = {
                    coordinates: e,
                    heightArray: n
                }
            }
            return this._outlineCoordsAndHeightArray
        }
        _drawBoundary() {
            const t = this._getOutlineCoordsAndHeightArray()
              , e = [];
            let n = {};
            if (t.heightArray) {
                for (let n = 0; n < t.heightArray.length; n++)
                    e.push(t.heightArray[n][0]);
                n = {
                    offsetHeightArray: e
                }
            }
            for (let e = 0; e < t.coordinates.length; e++)
                t.coordinates[e] = [t.coordinates[e]];
            const r = {
                type: "GeoBoundary",
                coordinates: t.coordinates,
                extrudeHeight: this._originBoundaryRenderer.extrudeHeight,
                renderer: this._originBoundaryRenderer,
                renderOrder: this.renderOrder + .2
            };
            n.offsetHeightArray ? (r.userData = n,
            r.groundHeightField = "offsetHeightArray") : r.offsetHeight = this.offsetHeight + this.extrudeHeight,
            this._boundary = this.app.create(r),
            this._boundaryRenderer = this._boundary.renderer,
            this._boundary.inheritPickable = !1,
            this._boundary.inheritStyle = !1,
            this._setUpBoundaryExtra(),
            this.add(this._boundary)
        }
        _drawOutline() {
            const t = this._getOutlineCoordsAndHeightArray()
              , e = this.app.create({
                type: "GeoLine",
                coordinates: t.coordinates,
                heightArray: t.heightArray,
                renderer: this._lineRenderer,
                renderOrder: this.renderOrder + .1
            });
            e.pickable = !1,
            e.inheritPickable = !1,
            e.inheritStyle = !1,
            this._originExtrudeHeight = this.extrudeHeight,
            this.add(e),
            e.renderer.opacity = this._lineRenderer.opacity,
            this._lineRenderer = e.renderer,
            this._outline = e,
            this._setUpOutlineExtra(),
            this._lineRenderer._object = this._outline
        }
        _draw() {
            let t = this.offsetHeight;
            this._arrayOffsetHeight && (t = this._arrayOffsetHeight);
            let e = this.createGeometry(this._multiPolygonCoordinates, this._layer, t, this.extrudeHeight, this._fillRenderer.textureSize, this._lineRenderer.lineType)
              , n = this._createFillMaterial()
              , r = e.polygonGeometry;
            this._sizeInMeter = e.sizeInMeter,
            this._fillRenderer._textureSize = e.textureSize;
            for (let t = 0; t < r.length; t++) {
                let e = new THREE.Mesh(r[t],n);
                this._layer.add(e)
            }
            this._outLinePolygonHierarchyArray = [],
            r && r.length > 0 && (this._outLinePolygonHierarchyArray = e.outLinePolygonHierarchyArray,
            this._drawOutline(),
            this.renderer.useBoundary && this._drawBoundary())
        }
        _setUpOutlineExtra() {
            this._outline._getMeshes().forEach(t=>{
                t.__type__ = "LINE"
            }
            )
        }
        _setUpBoundaryExtra() {
            this._boundary._getMeshes().forEach(t=>{
                t.__type__ = "BOUNDARY"
            }
            )
        }
        _setEffect(t, e, n) {
            const r = this;
            function a() {
                for (let a = 0; a < r._getMeshes().length; a++) {
                    let i = r._getMeshes()[a];
                    "LINE" !== i.__type__ && "BOUNDARY" !== i.__type__ && M.a._updateEffect(i, t, e, n)
                }
                THING.App.current.rendererManager._mainRenderer.dirty()
            }
            e && "glow" === t ? "cool" === r.renderer.type && a() : a()
        }
        _updateMeshMat(t) {
            this.node.getMeshes().forEach(e=>{
                "LINE" !== e.__type__ && "BOUNDARY" !== e.__type__ && (e.material = t)
            }
            ),
            setTimeout(function() {
                THING.App.current.rendererManager._mainRenderer.dirty("Glow")
            }, 0)
        }
        _updateBoundaryMat(t) {
            this.node.getMeshes().forEach(e=>{
                "BOUNDARY" === e.__type__ && (e.material = t)
            }
            )
        }
        _updateOutlineMat(t) {
            this.node.getMeshes().forEach(e=>{
                "LINE" === e.__type__ && (e.material = t)
            }
            )
        }
        _updateBoundaryEffect(t, e) {
            this.node.getMeshes().forEach(n=>{
                "BOUNDARY" === n.__type__ && M.a._updateEffect(n, "glow", t, e)
            }
            )
        }
        _updateOutlineEffect(t, e) {
            this.node.getMeshes().forEach(n=>{
                "LINE" === n.__type__ && M.a._updateEffect(n, "lineBloom", t, e)
            }
            )
        }
        updateMaterial() {
            this._updateMeshMatByRenderer()
        }
        _updateMeshMatByRenderer() {
            this._updateMeshMat(this._createFillMaterial())
        }
        _updateOutlineMatByRenderer() {
            let t = Ut.createLineMaterial(this._lineRenderer).getMaterial()[0];
            this._updateOutlineMat(t)
        }
        _updateMeshUV(t, e) {
            if (r.a.isArrayEqual(t, e))
                return;
            const n = this;
            this._getMeshes().forEach(function(r) {
                if ("LINE" !== r.__type__ && "BOUNDARY" !== r.__type__) {
                    var a = r.geometry.groups[0]
                      , i = r.geometry.index.array.slice(a.start, a.count)
                      , o = new Float32Array(r.geometry.attributes.uv.count * r.geometry.attributes.uv.itemSize);
                    const l = [t[0] / e[0], t[1] / e[1]];
                    for (var s = 0; s < r.geometry.attributes.uv.count; s++)
                        M.a._updateAllUv(n.extrudeHeight, i, s) ? (o[2 * s] = r.geometry.attributes.uv.array[2 * s] * l[0],
                        o[2 * s + 1] = r.geometry.attributes.uv.array[2 * s + 1] * l[1]) : (o[2 * s] = r.geometry.attributes.uv.array[2 * s],
                        o[2 * s + 1] = r.geometry.attributes.uv.array[2 * s + 1]);
                    r.geometry.setAttribute("uv", new THREE.BufferAttribute(o,2))
                }
            })
        }
    }
    THING.factory.registerClass("GeoPolygon", _e);
    var xe = _e;
    var be = class extends Dt {
        constructor(t, e) {
            super(t, e),
            this._object = t,
            this._type = "water",
            this._opacity = THING.Utils.parseValue(e.opacity, 1),
            e.color = THING.Utils.parseValue(e.color || [255, 255, 255]),
            this._color = CMAP.Util.colorFormatNewToOld(e.color, this._opacity) || [1, 1, 1, 1],
            this._opacity = this._color[3],
            this._reflectionNormal = e.reflectionNormal,
            this._refractionNormal = e.refractionNormal,
            this._reflectionImage = e.reflectionImage,
            this._refractionImage = e.refractionImage,
            this._flowSpeed = THING.Utils.parseValue(e.flowSpeed, [1, 1]),
            Array.isArray(this._flowSpeed) || (this._flowSpeed = [this._flowSpeed, this._flowSpeed]),
            this._waveLength = THING.Utils.parseValue(e.waveLength, .25),
            this._lights = THING.Utils.parseValue(e.lights, !0)
        }
        get color() {
            return CMAP.Util.colorFormatOldToNew(this._color)
        }
        set color(t) {
            var e = CMAP.Util.colorFormatNewToOld(t, this._opacity);
            JSON.stringify(e) !== JSON.stringify(this._color) && (Array.isArray(t) && 4 === t.length && (this._opacity = t[3]),
            this._color = e,
            this._object._getGeoObjectArray().forEach(n=>{
                Array.isArray(t) && 4 === t.length && (n.renderer._opacity = t[3]),
                n.renderer._color = e,
                n._updateMaterial()
            }
            ))
        }
        get opacity() {
            return this._opacity
        }
        set opacity(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("opacity", t) : t !== this._opacity && (this._opacity = t,
            this._color[3] = t,
            this._object._updateMaterial())
        }
        get flowSpeed() {
            return this._flowSpeed
        }
        set flowSpeed(t) {
            Array.isArray(t) || (t = [t, t]),
            CMAP.Util.isArrayEqual(t, this._flowSpeed) || (this._flowSpeed = t,
            "FeatureLayer" === this._object.type ? this._object.children.forEach(e=>{
                e.renderer.flowSpeed = t
            }
            ) : this._object._updateMaterial())
        }
        get reflectionNormal() {
            return this._reflectionNormal
        }
        set reflectionNormal(t) {
            t !== this._reflectionNormal && (this._reflectionNormal = t,
            "FeatureLayer" === this._object.type ? this._object.children.forEach(e=>{
                e.renderer.reflectionNormal = t
            }
            ) : this._object._updateMaterial())
        }
        get refractionNormal() {
            return this._refractionNormal
        }
        set refractionNormal(t) {
            t !== this._refractionNormal && (this._refractionNormal = t,
            "FeatureLayer" === this._object.type ? this._object.children.forEach(e=>{
                e.renderer.refractionNormal = t
            }
            ) : this._object._updateMaterial())
        }
        get reflectionImage() {
            return this._reflectionImage
        }
        set reflectionImage(t) {
            t !== this._reflectionImage && (this._reflectionImage = t,
            "FeatureLayer" === this._object.type ? this._object.children.forEach(e=>{
                e.renderer.reflectionImage = t
            }
            ) : this._object._updateMaterial())
        }
        get refractionImage() {
            return this._refractionImage
        }
        set refractionImage(t) {
            t !== this._refractionImage && (this._refractionImage = t,
            "FeatureLayer" === this._object.type ? this._object.children.forEach(e=>{
                e.renderer.refractionImage = t
            }
            ) : this._object._updateMaterial())
        }
        get waveLength() {
            return this._waveLength
        }
        set waveLength(t) {
            t !== this._waveLength && (this._waveLength = t,
            "FeatureLayer" === this._object.type ? this._object.children.forEach(e=>{
                e.renderer.waveLength = t
            }
            ) : this._object._updateMaterial())
        }
        get lights() {
            return this._lights
        }
        set lights(t) {
            t !== this._lights && (this._lights = t,
            "FeatureLayer" === this._object.type ? this._object.children.forEach(e=>{
                e.renderer.lights = t
            }
            ) : this._object._updateMaterial())
        }
    }
    ;
    class we extends xe {
        constructor(t) {
            super(t),
            this.app = t
        }
        setup(t) {
            super.setup(t)
        }
        _beforeInit(t) {
            this._renderer = new be(this,t.renderer)
        }
        _convertRendererToParam() {
            const t = this.renderer.flowSpeed;
            let e = Math.abs(t[0])
              , n = Math.abs(t[1])
              , r = Math.abs(e > n ? e : n);
            e = t[0] / r,
            n = t[1] / r;
            const a = Math.sqrt(t[0] * t[0] + t[1] * t[1]) / Math.sqrt(2);
            return {
                color: this.renderer._color,
                opacity: this.renderer.opacity,
                normalMap0: this.renderer.reflectionNormal,
                normalMap1: this.renderer.refractionNormal,
                tReflectionMap: this.renderer.reflectionImage,
                tRefractionMap: this.renderer.refractionImage,
                flowX: e,
                flowY: n,
                flowSpeed: a,
                scale: 1 / this.renderer.waveLength,
                lights: this.renderer.lights
            }
        }
        get offsetHeight() {
            return this._offsetHeight
        }
        set offsetHeight(t) {
            if (t !== this._offsetHeight) {
                var e = t - this._offsetHeight;
                this.translate([0, e, 0]),
                this._offsetHeight = t
            }
        }
        _draw() {
            let t = this.offsetHeight;
            this._arrayOffsetHeight && (t = this._arrayOffsetHeight);
            let e = M.a.createPolygonGeometry(this._multiPolygonCoordinates, this.node, t, this.height, void 0, !0, !1).polygonGeometry;
            for (let t in e) {
                let n = e[t]
                  , r = this.createMaterial().getTechnique(0).getPass(0).material;
                r.extensions.derivatives = !this.app.renderer.capabilities.isWebGL2;
                let a = new THREE.Water3(n,r);
                a.renderOrder = this.renderOrder,
                this.node.add(a)
            }
        }
        createMaterial() {
            return Ut.createWaterMatrial(this._convertRendererToParam())
        }
        updateRenderer(t) {
            super.updateRenderer(t);
            var e = new be(this,t);
            this._renderer = e,
            this._updateMaterial()
        }
        _updateMaterial() {
            var t = this.createMaterial();
            if (t)
                for (var e in this.node.children) {
                    var n = this.node.children[e];
                    "Water3" === n.type && (n.material = t.techniques[0].passes[0].material)
                }
        }
    }
    THING.factory.registerClass("GeoWater", we);
    class Ce extends Zt {
        constructor(t) {
            super(t),
            this.app = t
        }
        setup(t) {
            this._userData = void 0 === t.userData ? {} : t.userData,
            this._coordinates = t.coordinates,
            this._heightArray = t.heightArray,
            this._heightArrayField = t.heightArrayField,
            this._heightArrayFactor = THING.Utils.parseValue(t.heightArrayFactor, 1),
            this._extrudeHeight = this._originHeight = THING.Utils.parseValue(t.extrudeHeight, 100),
            this._setOffsetHeightAndField(t),
            super.setup(t)
        }
        _initRenderer(t) {
            this._renderer = new ye(this,t.renderer)
        }
        get extrudeHeight() {
            return this._extrudeHeight
        }
        set extrudeHeight(t) {
            this._extrudeHeight !== t && (this._extrudeHeight = t,
            this._caculateGeometry())
        }
        _processCoordinates() {
            var t = M.a._processGeojson(this._coordinates, "LINE");
            return t = M.a._processGeojson(t, "BOUNDARYPOLYGON"),
            this._centerCoords = r.a._getPolygonCenterCoordinates(t),
            this._multiPolygonCoordinates = t,
            t
        }
        _processHeightArray() {
            let t;
            return this._heightArray && (t = this._heightArray,
            t = M.a._processGeojson(t, "LINEHEIGHT"),
            t = M.a._processGeojson(t, "LINE")),
            this._multiPolygonHeightArray = t,
            this._multiPolygonHeightArray
        }
        _setupNode() {
            this.position = r.a.convertLonlatToWorld(this._centerCoords, this._offsetHeight),
            this.angles = r.a.getAnglesFromPosition(this.position, 180)
        }
        init() {
            this._processCoordinates(),
            this._processHeightArray(),
            this._setupNode();
            const t = this.createGeometry();
            let e = this.createMaterial();
            for (let n = 0; n < t.length; n++) {
                const r = t[n];
                let a = this.createMesh(r, e);
                this.node.add(a)
            }
        }
        get heightArray() {
            return this._heightArray
        }
        get heightArrayField() {
            return this._heightArrayField
        }
        set heightArrayField(t) {
            t !== this._heightArrayField && (this._heightArray = null,
            this._heightArrayField = t,
            this._caculateGeometry())
        }
        get heightArrayFactor() {
            return this._heightArrayFactor
        }
        set heightArrayFactor(t) {
            t !== this._heightArrayFactor && (this._heightArray = null,
            this._heightArrayFactor = t,
            this._caculateGeometry())
        }
        get offsetHeight() {
            return this._offsetHeight
        }
        set offsetHeight(t) {
            (this._arrayOffsetHeight || t !== this._offsetHeight) && (this._offsetHeight = t,
            this._arrayOffsetHeight = null,
            this._caculateGeometry())
        }
        _setArrayOffsetHeight(t) {
            this._caculateGeometry()
        }
        _caculateGeometry() {
            this._setupNode();
            const t = this.node.getMeshes();
            let e = this.createGeometry();
            for (let n = 0; n < e.length; n++)
                t[n].geometry = e[n]
        }
        createMaterial() {
            const t = this.renderer.toObject();
            return Ut.createBoundaryMaterial(t)
        }
        createMesh(t, e) {
            var n = new THREE.Mesh(t,e);
            return n.castShadow = !0,
            n.receiveShadow = !0,
            n
        }
        createGeometry() {
            return THING.Utils.isNull(this._heightArray) && !THING.Utils.isNull(this._heightArrayField) && this.userData[this._heightArrayField] && (this._heightArray = r.a.deepCopy(this.userData[this._heightArrayField]),
            this._heightArray && 1 !== this._heightArrayFactor && CMAP.Util._multiplyHeightArrayFactor(this._heightArray, this._heightArrayFactor)),
            this._processHeightArray(),
            M.a.createBoundaryGeometry(this._multiPolygonCoordinates, this.extrudeHeight, this._arrayOffsetHeight ? this._arrayOffsetHeight : this.offsetHeight, this.position, this._multiPolygonHeightArray)
        }
        updateMaterial() {
            var t = this.createMaterial()
              , e = this.node.getMeshes();
            for (let n = 0; n < e.length; n++)
                e[n].material = t
        }
        updateRenderer(t) {
            super.updateRenderer(t),
            this._renderer = new ye(this,t),
            this.updateMaterial(),
            r.a.isNum(t.offsetHeight) && (this.offsetHeight = t.offsetHeight),
            r.a.isNum(t.extrudeHeight) && (this.extrudeHeight = t.extrudeHeight)
        }
        destroy() {
            this._alphaUpdaterName && C.a.delete(this._alphaUpdaterName),
            this._imageUpdaterName && C.a.delete(this._imageUpdaterName),
            super.destroy()
        }
    }
    THING.factory.registerClass("GeoBoundary", Ce);
    class Ee extends Zt {
        constructor(t) {
            super(t),
            this.app = t
        }
        setup(t) {
            this.param = t || {},
            this.name = t.name || "unNamed",
            this.id = this.code = t.id || r.a.getUUID(),
            this.sceneUrl = t.url,
            this._coordinates = t.coordinates || t.lonlat || [116.390834, 39.916353],
            t.offsetHeight && (t.height = t.offsetHeight),
            this.height = void 0 === t.height ? 1 : t.height,
            this.offsetHeight = this.height,
            void 0 === t.azimuth && (t.azimuth = t.angle),
            this._renderOrder = void 0 === t.renderOrder ? 0 : t.renderOrder,
            this.azimuth = void 0 === t.azimuth ? 0 : t.azimuth,
            this._renderer = t.renderer,
            this._renderer ? (this.flyBackInfo = t.flyBackInfo,
            this._initScene = !1,
            this._marker = this._createMarker(),
            this.add(this._marker),
            this.state = 0) : this._onlyLoadScene(),
            this.visible = void 0 === t.visible || t.visible,
            this.completeCallback = t.completeCallback,
            this.setupComplete(t)
        }
        get renderOrder() {
            return this._renderOrder
        }
        set renderOrder(t) {
            this._layer && (this._layer.renderOrder = t),
            this._renderOrder = t
        }
        get offsetHeight() {
            return this._offsetHeight
        }
        set offsetHeight(t) {
            var e = r.a.convertLonlatToWorld(this.coordinates, t);
            this._layer.position = e,
            this._offsetHeight = t
        }
        get height() {
            return this._offsetHeight
        }
        set height(t) {
            this.offsetHeight = t
        }
        init() {}
        get geoPoint() {
            return this._marker
        }
        _createMarker() {
            var t = this
              , e = this.app.create({
                type: "GeoPoint",
                name: this.name + "_geoPoint",
                coordinates: [this.coordinates[0], this.coordinates[1]],
                renderer: this.renderer,
                azimuth: this.azimuth
            });
            return e.on("dblclick", function(e) {
                e.object.visible = !1,
                t._flyToScene()
            }),
            e.on("mouseenter", function() {
                "model" !== e.renderer.type ? e.renderer.size = 1.5 * e.renderer.size : e.children[0].style.outlineColor = [255, 255, 0]
            }),
            e.on("mouseleave", function() {
                "model" !== e.renderer.type ? e.renderer.size = e.renderer.size / 1.5 : e.children[0].style.outlineColor = null
            }),
            e
        }
        _loadScene() {
            var t = this.app
              , e = t.uEarth.sceneManager
              , n = this
              , a = e.getCurInitScene();
            a && a.code !== n.code && (e.disposeInitScene(),
            a._marker.visible = !0),
            t.uEarth.sceneManager._lastBackground = t.background;
            var i = r.a.convertLonlatToWorld(this.coordinates, this.height)
              , o = r.a.getAnglesFromLonlat(this.coordinates, this.azimuth);
            t.loadCampus(n.sceneUrl, {
                id: n.code,
                name: n.name,
                position: i,
                angles: o,
                isCamFitScene: !1,
                properties: {
                    GIV_id: n.code
                },
                successCallback: function(r) {
                    e.setError(!1);
                    var a = t.query("[GIV_id = " + n.code + "]")[0] || r.object;
                    n._layer = a,
                    t.level.change(a),
                    n.trigger("FinishFlyToScene", n),
                    n._processScene(a),
                    n.completeCallback && n.completeCallback()
                },
                errorCallback: function() {
                    e.setError(!0, n),
                    n.trigger("FinishFlyToScene", n),
                    n.completeCallback && n.completeCallback()
                }
            }),
            n._initScene = !0
        }
        _onlyLoadScene() {
            let t = this.app
              , e = this;
            t.uEarth.sceneManager._lastBackground = t.background;
            var n = r.a.convertLonlatToWorld(this.coordinates, this.height)
              , a = r.a.getAnglesFromLonlat(this.coordinates, this.azimuth);
            t.pauseEvent(THING.EventType.EnterLevel, "*", THING.EventTag.LevelFly),
            t.loadCampus(e.sceneUrl, {
                id: e.code,
                name: e.name,
                position: n,
                angles: a,
                isCamFitScene: !1,
                renderOrder: this._renderOrder,
                properties: {
                    GIV_id: e.code
                },
                successCallback: function(n) {
                    var r = t.query("[GIV_id = " + e.code + "]")[0] || n.object;
                    e._layer = r,
                    e._processScene(r),
                    e.trigger("FinishFlyToScene", e),
                    e.completeCallback && e.completeCallback()
                },
                errorCallback: function() {
                    e.trigger("FinishFlyToScene", e),
                    e.completeCallback && e.completeCallback()
                }
            })
        }
        _processScene(t) {
            let e = r.a.convertLonlatToWorld(this._coordinates, this.height)
              , n = r.a.position2angles(e)
              , a = r.a.anglesToQuaternion(n).inverse();
            t.node.getMaterials().map(t=>{
                t.baseQuaternion = a
            }
            )
        }
        updateRenderer(t) {
            for (var e in this._renderer = t,
            t)
                this.geoPoint.renderer[e] = t[e]
        }
        _flyToScene() {
            var t = this;
            t.trigger("BeginFlyToScene", t);
            var e = {
                center: r.a.lonlat2World(this.coordinates, 6378e3 + this.height),
                radius: 200,
                complete: function() {
                    t._initScene ? (t._marker.visible = !1,
                    t._layer && (t._layer.visible = !0,
                    t.app.level.change(t._layer)),
                    t.trigger("FinishFlyToScene", t)) : t._loadScene(),
                    t.state = 1
                }
            };
            this.app.camera.flyToBoundingSphere(e)
        }
        newflyToScene() {
            var t = this.height / 111e3
              , e = [this.coordinates[0], this.coordinates[1] + t];
            let n = this._layer.getOrientedBox().size
              , r = Math.sqrt(n[0] * n[0] + n[1] * n[1])
              , a = Math.sqrt(r * r + n[2] * n[2]);
            this.app.camera.earthFlyTo({
                lonlat: e,
                height: this.height + a
            }),
            this.trigger("FinishFlyToScene", this)
        }
        isNeedToLoad() {
            var t = !0
              , e = this.app.uEarth.sceneManager.getCurInitScene();
            return e && e.code === this.code && (t = !1),
            t
        }
        updatePositionAngleHeight(t, e, n) {
            this._coordinates = t,
            this.azimuth = e,
            this.height = n;
            var a = r.a.convertLonlatToWorld(this.coordinates, this.height)
              , i = r.a.getAnglesFromLonlat(this.coordinates, this.azimuth);
            this._layer && (this._layer.position = a,
            this._layer.angles = i),
            this._marker && (this._marker.coordinates = t)
        }
        destroy() {
            var t = this.app.query("[GIV_id = " + this.code + "]")[0];
            this._initScene = !1,
            this._layer = null,
            this._marker && this._marker.destroy(),
            t && "Campus" === t.type && t.destroy(),
            super.destroy()
        }
        set visible(t) {
            this._visible = t;
            var e = this.app.query("[GIV_id = " + this.code + "]")[0];
            !0 === t ? 0 === this.state ? this._marker.visible = t : 1 === this.state && e && (e.visible = t) : (this._marker && (this._marker.visible = t),
            e && (e.visible = t))
        }
        get visible() {
            return this._visible
        }
    }
    THING.factory.registerClass("GeoScene", Ee);
    var Te = Ee;
    class Me extends Te {
        constructor(t) {
            super(t),
            this.app = t
        }
        setup(t) {
            this.param = t || {},
            this.name = t.name || "unNamed",
            this.id = this.code = t.id || r.a.getUUID(),
            this.userData = THING.Utils.parseValue(t.userData, {}),
            this.sceneUrl = t.url,
            THING.Utils.isNull(t.flyToScene) && (t.flyToScene = t.changeCampusLevel),
            this.flyToScene = THING.Utils.parseValue(t.flyToScene, !0),
            this.flyWhenLevelChange = THING.Utils.parseValue(t.flyWhenLevelChange, !1),
            this._coordinates = t.coordinates || t.lonlat || [116.390834, 39.916353],
            t.height && (t.offsetHeight = t.height),
            THING.Utils.isNull(t.groundHeightField) && (this._offsetHeight = THING.Utils.parseValue(t.offsetHeight, 1)),
            this._setOffsetHeightAndField(t),
            void 0 === t.azimuth && (t.azimuth = t.angle),
            this.azimuth = void 0 === t.azimuth ? 0 : t.azimuth,
            this._renderer = t.renderer,
            this._visible = void 0 === t.visible || t.visible,
            this._onlyLoadScene(),
            this.completeCallback = t.complete,
            t.complete = null,
            this.errorCallback = t.error,
            this.setupComplete(t)
        }
        init() {}
        _onlyLoadScene() {
            let t = this.app
              , e = this;
            t.uEarth.sceneManager._lastBackground = t.background;
            var n = r.a.convertLonlatToWorld(this.coordinates, this.height)
              , a = r.a.getAnglesFromLonlat(this.coordinates, this.azimuth);
            this.flyWhenLevelChange || t.pauseEvent(THING.EventType.EnterLevel, "*", THING.EventTag.LevelFly),
            t.level.options.isEarth = !0;
            const i = {
                GIV_id: e.code,
                azimuth: e.azimuth
            }
              , o = CMAP.Util.objectAssign(i, this.userData, !0);
            t.create({
                type: "Campus",
                url: e.sceneUrl,
                id: e.code,
                name: e.name,
                position: n,
                angles: a,
                isSetEffect: !1,
                properties: o,
                parent: e.app.uEarth,
                visible: e.visible,
                complete: function(n) {
                    var r = n.object;
                    e._layer = r,
                    e.flyToScene && (e.trigger("BeginFlyToScene", e),
                    t.level.change(r),
                    e.trigger("FinishFlyToScene", e)),
                    r.node.visible = e._visible,
                    CMAP.Util._correctCampusBaseQuaternion(r, e.coordinates, e.height),
                    e.completeCallback && e.completeCallback(n)
                },
                error: function(t) {
                    e.errorCallback && e.errorCallback(t)
                }
            })
        }
        _registerEvent(t, e) {
            let n = e.app;
            t.on("dblclick", "*", function() {
                n.level.change(t),
                t.off("dblclick", "*", "loadMarker")
            }, "loadMarker"),
            t.on("mouseenter", function(t) {
                t.object.style.outlineColor = "#FF8000"
            }),
            t.on("mouseleave", function(t) {
                t.object.style.outlineColor = null
            })
        }
        destroy() {
            this._layer && this._layer.destroy(),
            super.destroy()
        }
        set visible(t) {
            this._layer && (this._layer.node.visible = t),
            this._visible = t
        }
        get visible() {
            return this._visible
        }
    }
    THING.factory.registerClass("GeoCampus", Me);
    var Ae = class {
        constructor(t, e) {
            this._object = this._geoHeatMap = t,
            this._radius = THING.Utils.parseValue(e.radius, 5),
            this._maxOpacity = e.maxOpacity,
            this._minOpacity = e.minOpacity,
            this._opacity = e.opacity,
            this._minValue = e.minValue,
            this._maxValue = e.maxValue,
            this._mosaic = e.mosaic,
            this._extent = e.extent,
            this._lights = e.lights,
            this._mosaicSize = e.mosaicSize,
            this._gradient = e.gradient || {
                .25: "rgb(0,0,255)",
                .55: "rgb(0,255,0)",
                .85: "yellow",
                1: "rgb(255,0,0)"
            },
            void 0 !== e.opacity || void 0 !== e.maxOpacity && void 0 !== e.minOpacity || (this._opacity = .6)
        }
        get minValue() {
            return this._minValue
        }
        get maxValue() {
            return this._maxValue
        }
        set minValue(t) {
            this._minValue = t
        }
        set maxValue(t) {
            this._maxValue = t
        }
        get lights() {
            return this._lights
        }
        set lights(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("lights", t) : (this._lights = t,
            this._geoHeatMap._updateMaterial())
        }
        get extent() {
            return this._extent
        }
        get mosaic() {
            return this._mosaic
        }
        set mosaic(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("mosaic", t) : (this._geoHeatMap._setMosaic(t, this.mosaicSize),
            this._mosaic = t)
        }
        get mosaicSize() {
            return this._mosaicSize
        }
        set mosaicSize(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("mosaicSize", t) : (this._geoHeatMap._setMosaicSize(t),
            this._mosaicSize = t)
        }
        get maxOpacity() {
            return this._maxOpacity
        }
        set maxOpacity(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("maxOpacity", t) : (this._geoHeatMap.setMinMaxOpacity(this.minOpacity, t),
            this._maxOpacity = t)
        }
        get minOpacity() {
            return this._minOpacity
        }
        set minOpacity(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("minOpacity", t) : (this._geoHeatMap.setMinMaxOpacity(t, this.maxOpacity),
            this._minOpacity = t)
        }
        get radius() {
            return this._radius
        }
        set radius(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("radius", t) : (this._geoHeatMap.setRadius(t),
            this._radius = t)
        }
        get gradient() {
            return this._gradient
        }
        set gradient(t) {
            this._object && "FeatureLayer" === this._object.type ? this._setFeatureLayerProperty("gradient", t) : (this._geoHeatMap.setGradient(t),
            this._gradient = t)
        }
        get opacity() {
            return this._opacity
        }
    }
      , Pe = !0;
    class Se extends THING.BaseObject {
        constructor(t) {
            super(t),
            this.app = t
        }
        setup(t) {
            this.id = t.id || "geoHeatMap_" + r.a.getUUID(),
            this.name = t.name || this.id,
            this._dataSource = t.dataSource,
            this.dataExtent,
            this.renderer = new Ae(this,t.renderer),
            this.renderOrder = t.renderOrder || 0,
            this._layer = new THREE.Group,
            this.init(),
            this.node = this._layer,
            this._heatMap,
            this.setupComplete(t)
        }
        get visible() {
            return Pe
        }
        set visible(t) {
            this._visible = t,
            this._layer.visible = t
        }
        destroy() {
            this._heatMap && this._layer.name === "heatmap_mesh" + this.id && this._heatMap.destroy(),
            super.destroy(),
            this.app.off("camerachangeend")
        }
        get renderOrder() {
            return this._renderOrder
        }
        set renderOrder(t) {
            this._layer && (this._layer.renderOrder = t),
            this._renderOrder = t
        }
        _setDataExtent() {
            if (!this.dataExtent) {
                var t = Math.max.apply(Math, this.dataSource.map(function(t) {
                    return t.x
                }))
                  , e = Math.min.apply(Math, this.dataSource.map(function(t) {
                    return t.x
                }))
                  , n = Math.max.apply(Math, this.dataSource.map(function(t) {
                    return t.y
                }))
                  , r = Math.min.apply(Math, this.dataSource.map(function(t) {
                    return t.y
                }));
                this.dataExtent = {
                    west: e,
                    east: t,
                    south: r,
                    north: n
                }
            }
        }
        init() {
            this._setDataExtent(),
            this.draw();
            var t = this._drawHandler.call(this);
            this.renderer.extent || this.app.on("camerachangeend", function(e) {
                t()
            }, !1)
        }
        _drawHandler() {
            var t, e = this, n = function() {
                e.visible && e.parent.visible && e.draw()
            };
            return function() {
                t && clearTimeout(t),
                t = setTimeout(n, 300)
            }
        }
        draw() {
            var t;
            if (this.renderer.extent)
                t = {
                    west: this.renderer.extent.minX,
                    east: this.renderer.extent.maxX,
                    south: this.renderer.extent.minY,
                    north: this.renderer.extent.maxY
                };
            else {
                var e = this.app.uEarth.getCurrentExtent();
                t = {
                    west: e.minX,
                    east: e.maxX,
                    south: e.minY,
                    north: e.maxY
                }
            }
            if (this.dataExtent) {
                if (t.east < this.dataExtent.west || t.west > this.dataExtent.east || t.south > this.dataExtent.north || t.north < this.dataExtent.south)
                    return;
                var n = this.dataExtent.east - this.dataExtent.west
                  , r = this.dataExtent.north - this.dataExtent.south;
                t.east > this.dataExtent.east + 1 * n && (t.east = this.dataExtent.east + 1 * n),
                t.west < this.dataExtent.west - 1 * n && (t.west = this.dataExtent.west - 1 * n),
                t.north > this.dataExtent.north + 1 * r && (t.north = this.dataExtent.north + 1 * r),
                t.south < this.dataExtent.south - 1 * r && (t.south = this.dataExtent.south - 1 * r)
            }
            var a = {};
            a.radius = this.renderer.radius,
            a.gradient = this.renderer.gradient;
            var i = {};
            for (var o in a.gradient) {
                var s = o;
                o - 0 > .3 && (s = .7 + .3 * o),
                i[s] = a.gradient[o]
            }
            a.gradient = i,
            a.opacity = this.renderer.opacity,
            a.maxOpacity = this.renderer.maxOpacity,
            a.minOpacity = this.renderer.minOpacity,
            this._layer.children.length > 0 && this._layer.children[0].name === "heatmap_mesh" + this.id && this._heatMap.destroy(),
            this._heatMap = CesiumHeatmap.create(this.id, t, a),
            void 0 === this.renderer.minValue && (this.renderer.minValue = Math.min.apply(Math, this.dataSource.map(function(t) {
                return t.value
            }))),
            void 0 === this.renderer.maxValue && (this.renderer.maxValue = Math.max.apply(Math, this.dataSource.map(function(t) {
                return t.value
            }))),
            this._heatMapMesh = this._heatMap.setWGS84Data(this.renderer.minValue, this.renderer.maxValue, this.dataSource);
            var l = this.createMaterial();
            this._heatMapMesh.setMaterial(l),
            this._heatMapMesh && (this._layer.add(this._heatMapMesh),
            this._layer.renderOrder = this.renderOrder)
        }
        setMinMaxOpacity(t, e) {
            this._heatMap && (this._heatMap.setMinMaxOpacity(t, e),
            this._updateCanvas())
        }
        createMaterial() {
            let t = "meshMaterial_heatmap" + this._id;
            var e = t3djs.materialManager.getMaterial(t);
            e && t3djs.materialManager.destroyMaterial(t),
            e = t3djs.materialManager.createMaterial(t);
            let n, r = new THREE.Texture(this._heatMap._container.children[0]);
            if (0 === this._heatMap._container.children[0].height) {
                var a = document.createElement("img");
                a.width = this.width,
                a.height = this.height,
                r.image = a,
                r.needsUpdate = !0
            } else
                r.image = this._heatMap._container.children[0],
                r.needsUpdate = !0;
            return this.renderer.mosaic ? ((n = new THREE.ShaderMaterial({
                uniforms: THREE.UniformsUtils.clone(THING.Heatmap.PointMosaicShader.uniforms),
                vertexShader: THING.Heatmap.PointMosaicShader.vertexShader,
                fragmentShader: THING.Heatmap.PointMosaicShader.fragmentShader,
                transparent: !0
            })).uniforms.tDiffuse.value = r,
            this.renderer.mosaicSize && (n.uniforms.texSize.value.set(this._heatMap._container.children[0].width, this._heatMap._container.children[0].height),
            n.uniforms.mosaicSize.value.set(this.renderer.mosaicSize, this.renderer.mosaicSize))) : n = new THREE.MeshBasicMaterial({
                map: r,
                side: THREE.DoubleSide,
                transparent: !0
            }),
            n.depthWrite = !1,
            e.getTechnique(0).getPass(0).material = n,
            e
        }
        setGradient(t) {
            if (this._heatMap) {
                var e = {};
                for (var n in t) {
                    var r = n;
                    n - 0 > .3 && (r = .7 + .3 * n),
                    e[r] = t[n]
                }
                this._heatMap.setGradient(e),
                this._updateCanvas()
            }
        }
        setRadius(t) {
            this._heatMap && (this._heatMap.setRadius(t),
            this._updateCanvas())
        }
        get dataSource() {
            return this._dataSource
        }
        set dataSource(t) {
            this._heatMap && (this.renderer.minValue = Math.min.apply(Math, t.map(function(t) {
                return t.value
            })),
            this.renderer.maxValue = Math.max.apply(Math, t.map(function(t) {
                return t.value
            })),
            this._heatMap.setWGS84Data(this.renderer.minValue, this.renderer.maxValue, t, !1),
            this._updateCanvas()),
            this._dataSource = t,
            this._setDataExtent()
        }
        _updateCanvas() {
            this._heatMapMesh.material.map.image = this._heatMap._container.children[0],
            this._heatMapMesh.material.map.needsUpdate = !0
        }
    }
    THING.factory.registerClass("GeoHeatMap", Se);
    var Re = class extends Dt {
        constructor(t, e) {
            super(t, e),
            this._object = t,
            this._type = THING.Utils.parseValue(e.type, je.TYPE_TEXTURE_ROTATE),
            this._opacity = THING.Utils.parseValue(e.opacity, 1),
            e.color = THING.Utils.parseValue(e.color, [255, 255, 255]),
            this._color = CMAP.Util.colorFormatNewToOld(e.color, this._opacity) || [1, 1, 1, 1],
            this._opacity = this._color[3],
            this._imageUrl = e.imageUrl || e.url,
            this._radius = THING.Utils.parseValue(e.radius, 500),
            this._lerpType = THING.Utils.parseValue(e.lerpType, THING.LerpType.Linear.None),
            this._speed = THING.Utils.parseValue(e.speed, 1),
            this._speed <= 0 && (THING.Utils.warn("invalid value,speed must larger than 0"),
            this._speed = .001),
            this._startPosition = THING.Utils.parseValue(e.startPosition, 0),
            this._endPosition = THING.Utils.parseValue(e.endPosition, 1),
            this._alphaMapping = THING.Utils.parseValue(e.alphaMapping, {
                0: 1,
                1: 1
            }),
            this._linePositionRatio = THING.Utils.parseValue(e.linePositionRatio, 0),
            this._lineOpacity = THING.Utils.parseValue(e.lineOpacity, 1),
            e.lineColor = THING.Utils.parseValue(e.lineColor, [255, 255, 255]),
            this._lineColor = CMAP.Util.colorFormatNewToOld(e.lineColor, this._lineOpacity) || [1, 1, 1, 1],
            this._lineOpacity = this._lineColor[3],
            this._lineWidthRatio = THING.Utils.parseValue(e.lineWidthRatio, .01),
            this._cylinderHeight = THING.Utils.parseValue(e.cylinderHeight, 300)
        }
        get type() {
            return this._type
        }
        get opacity() {
            return this._opacity
        }
        set opacity(t) {
            this._opacity = this._object.opacity = t
        }
        get color() {
            return CMAP.Util.colorFormatOldToNew(this._color)
        }
        set color(t) {
            this._color = this._object.color = t
        }
        get imageUrl() {
            return this._imageUrl
        }
        set imageUrl(t) {
            this._imageUrl = this._object.url = t
        }
        get radius() {
            return this._radius
        }
        set radius(t) {
            this._radius = this._object.radius = t
        }
        get lerpType() {
            return this._lerpType
        }
        set lerpType(t) {
            this._lerpType = this._object.lerpType = t
        }
        get speed() {
            return this._speed
        }
        set speed(t) {
            this._speed = this._object.speed = t
        }
        get startPosition() {
            return this._startPosition
        }
        set startPosition(t) {
            this._startPosition = this._object.startPosition = t
        }
        get endPosition() {
            return this._endPosition
        }
        set endPosition(t) {
            this._endPosition = this._object.endPosition = t
        }
        get alphaMapping() {
            return this._alphaMapping
        }
        set alphaMapping(t) {
            t || (t = {
                0: 1,
                1: 1
            }),
            this._alphaMapping = this._object.alphaInterpolantParams = t
        }
        get linePositionRatio() {
            return this._linePositionRatio
        }
        set linePositionRatio(t) {
            this._linePositionRatio = this._object.linePositionRatio = t
        }
        get lineOpacity() {
            return this._lineOpacity
        }
        set lineOpacity(t) {
            this._lineOpacity = this._object.lineOpacity = t
        }
        get lineColor() {
            return CMAP.Util.colorFormatOldToNew(this._lineColor)
        }
        set lineColor(t) {
            this._lineColor = this._object.lineColor = t
        }
        get lineWidthRatio() {
            return this._lineWidthRatio
        }
        set lineWidthRatio(t) {
            this._lineWidthRatio = this._object.lineWidthRatio = t
        }
        get cylinderHeight() {
            return this._cylinderHeight
        }
        set cylinderHeight(t) {
            this._cylinderHeight = this._object.cylinderHeight = t
        }
    }
    ;
    class De extends Zt {
        constructor(t) {
            super(t),
            this.app = t,
            this.app.on("resize", t=>{
                this._onResize(t)
            }
            )
        }
        setup(t) {
            this.isInfoShow = !1,
            this.name = t.name || "geoDiffusion" + r.a.getUUID(),
            this.id = t.id || this.name,
            this.tickable = !1,
            this._growName = "diffusion_" + this.queryID,
            this._coordinates = t.coordinates,
            this._userData = void 0 === t.userData ? {} : t.userData,
            this._renderer = new Re(this,t.renderer),
            this._diffusionType = t.diffusionType,
            this._parseRenderer(),
            this._offsetHeight = THING.Utils.parseValue(t.offsetHeight, 0),
            this.node = this._layer = new THREE.Group,
            this.param = t,
            this._scanLayers = t.scanLayers || [],
            this._materials = [],
            this._createMaterial(this._diffusionType),
            this.init(),
            this.renderOrder = THING.Utils.parseValue(t.renderOrder, 0),
            this.visible = void 0 === t.visible || t.visible,
            t.parent || (t.independent = !0),
            this.setupParent(t),
            this.setupUserData(),
            this.setupComplete(t)
        }
        _parseRenderer() {
            this._opacity = this.renderer.opacity,
            this._color = this.renderer._color,
            this._url = this.renderer.imageUrl,
            this._radius = this.renderer.radius,
            this._lerpType = this.renderer.lerpType,
            this._speed = this.renderer.speed,
            this._endPosition = this.renderer.endPosition,
            this._startPosition = this.renderer.startPosition,
            this._alphaInterpolantParams = this.renderer.alphaMapping,
            this._linePositionRatio = this.renderer.linePositionRatio,
            this._lineOpacity = this.renderer.lineOpacity,
            this._lineColor = this.renderer._lineColor,
            this._lineWidthRatio = this.renderer.lineWidthRatio,
            this._diffusionType || (this._diffusionType = this.renderer.type),
            this._cylinderHeight = this.renderer.cylinderHeight
        }
        get color() {
            return this._color
        }
        set color(t) {
            var e = t || this._color;
            e = CMAP.Util.colorFormatNewToOld(e, this._opacity) || [this._color[0], this._color[1], this._color[2], this._opacity],
            this._opacity = e[3],
            this._color = [e[0], e[1], e[2]] || !1,
            this._uniforms.color.value = new THREE.Vector3(this._color[0],this._color[1],this._color[2]),
            this._diffusionType !== De.TYPE_CYLINDER && (this._buildUniforms.color.value = this._uniforms.color.value)
        }
        get opacity() {
            return this._opacity
        }
        set opacity(t) {
            this._opacity = t,
            this._uniforms.opacity.value = this._opacity,
            this._diffusionType !== De.TYPE_CYLINDER && (this._buildUniforms.opacity.value = this._opacity)
        }
        get url() {
            return this._url
        }
        set url(t) {
            if ((this._diffusionType === De.TYPE_TEXTURE_ROTATE || this._diffusionType === De.TYPE_TEXTURE_SCALE) && this._url !== t) {
                var e = (new THREE.TextureLoader).load(t);
                this._uniforms.colorTexture.value = e,
                this._buildUniforms.colorTexture.value = e,
                this._diffusionType === De.TYPE_TEXTURE_SCALE && (this._uniforms.useColorTexture.value = 1,
                this._buildUniforms.useColorTexture.value = 1)
            }
            this._url = t
        }
        get radius() {
            return this._radius
        }
        set radius(t) {
            this._radius = t,
            this._updateDiffusion()
        }
        get lerpType() {
            return this._lerpType
        }
        set lerpType(t) {
            this._lerpType = t,
            this._updateDiffusion()
        }
        get speed() {
            return this._speed
        }
        set speed(t) {
            t <= 0 ? THING.Utils.warn("扫描速度不能小于等于0") : (this._speed = t,
            TWEEN.remove(this._tween),
            this._setSpeed())
        }
        get linePositionRatio() {
            return this._linePositionRatio
        }
        set linePositionRatio(t) {
            this._linePositionRatio = t,
            this._diffusionType === De.TYPE_TEXTURE_SCALE && (this._uniforms.lineEnableRatio.value = this._linePositionRatio,
            this._buildUniforms.lineEnableRatio.value = this._linePositionRatio)
        }
        get lineWidthRatio() {
            return this._lineWidthRatio
        }
        set lineWidthRatio(t) {
            this._lineWidthRatio = t,
            this._diffusionType === De.TYPE_TEXTURE_SCALE && (this._uniforms.lineWidthRatio.value = this._lineWidthRatio,
            this._buildUniforms.lineWidthRatio.value = this._lineWidthRatio)
        }
        get lineOpacity() {
            return this._lineOpacity
        }
        set lineOpacity(t) {
            this._lineOpacity = t,
            this._diffusionType === De.TYPE_TEXTURE_SCALE && (this._uniforms.lineOpacity.value = this._lineOpacity,
            this._buildUniforms.lineOpacity.value = this._lineOpacity)
        }
        get lineColor() {
            return this._lineColor
        }
        set lineColor(t) {
            var e = t || this._lineColor;
            e = CMAP.Util.colorFormatNewToOld(e, this._lineOpacity) || [this._color[0], this._color[1], this._color[2], this._lineOpacity],
            this._lineOpacity = e[3],
            this._lineColor = [e[0], e[1], e[2]] || !1,
            this._diffusionType === De.TYPE_TEXTURE_SCALE && (this._uniforms.lineColor.value = new THREE.Vector3(this._lineColor[0],this._lineColor[1],this._lineColor[2]),
            this._buildUniforms.lineColor.value = new THREE.Vector3(this._lineColor[0],this._lineColor[1],this._lineColor[2]))
        }
        get cylinderHeight() {
            return this._cylinderHeight
        }
        set cylinderHeight(t) {
            this._cylinderHeight = t,
            this._updateDiffusion()
        }
        get coordinates() {
            return this._coordinates
        }
        set coordinates(t) {
            this._coordinates = t,
            this._updateDiffusion()
        }
        get offsetHeight() {
            return this._offsetHeight
        }
        set offsetHeight(t) {
            t >= 0 && (this._offsetHeight = t,
            this._updateDiffusion())
        }
        get endPosition() {
            return this._endPosition
        }
        set endPosition(t) {
            this._diffusionType === De.TYPE_TEXTURE_SCALE ? (this._endPosition = t,
            t <= 0 || t > 1 ? THING.Utils.warn("扫描重复间隔比例不能小于等于0或者大于1") : (TWEEN.remove(this._tween),
            this._setSpeed())) : THING.Utils.warn("只有diffusionType = " + De.TYPE_TEXTURE_SCALE + "时起作用")
        }
        get startPosition() {
            return this._startPosition
        }
        set startPosition(t) {
            this._diffusionType === De.TYPE_TEXTURE_SCALE ? (this._startPosition = t,
            t < 0 || t > 1 ? THING.Utils.warn("扩散起始比例不能小于0或者大于1") : (TWEEN.remove(this._tween),
            this._setSpeed())) : THING.Utils.warn("只有diffusionType = " + De.TYPE_TEXTURE_SCALE + "时起作用")
        }
        get alphaCurveFunction() {
            return this._alphaCurveFunction
        }
        set alphaCurveFunction(t) {
            if (this._diffusionType === De.TYPE_TEXTURE_SCALE) {
                this._alphaCurveFunction = t;
                var e = this._createAlphaTexture(t);
                this._uniforms.alphaTexture.value = e,
                this._buildUniforms.alphaTexture.value = e
            } else
                THING.Utils.warn("只有diffusionType = " + De.TYPE_TEXTURE_SCALE + "时起作用")
        }
        get alphaInterpolantParams() {
            return this._alphaInterpolantParams
        }
        set alphaInterpolantParams(t) {
            if (this._diffusionType === De.TYPE_TEXTURE_SCALE) {
                this._alphaInterpolantParams = t;
                var e = this._createInterpolantTexture(t);
                this._uniforms.alphaTexture.value = e,
                this._buildUniforms.alphaTexture.value = e
            } else
                THING.Utils.warn("只有diffusionType = " + De.TYPE_TEXTURE_SCALE + "时起作用")
        }
        get visible() {
            return this._visible
        }
        set visible(t) {
            this._visible = t,
            this._setVisible()
        }
        _createscaleCircularMaterial() {
            let t;
            var e;
            this._timeTarget = .5,
            this._alphaInterpolantParams ? t = this._createInterpolantTexture(this._alphaInterpolantParams) : this._alphaCurveFunction && (t = this._createAlphaTexture(this._alphaCurveFunction));
            var n = 0;
            this.url ? (e = (new THREE.TextureLoader).load(this._url),
            n = 1) : n = 0,
            this._uniforms = {
                time: {
                    value: 0
                },
                color: {
                    value: new THREE.Vector3(this._color[0],this._color[1],this._color[2])
                },
                opacity: {
                    value: this._opacity
                },
                colorTexture: {
                    value: e
                },
                useColorTexture: {
                    value: n
                },
                alphaTexture: {
                    value: t
                },
                lineEnableRatio: {
                    value: this._linePositionRatio
                },
                lineWidthRatio: {
                    value: this._lineWidthRatio
                },
                lineColor: {
                    value: new THREE.Vector3(this._lineColor[0],this._lineColor[1],this._lineColor[2])
                },
                lineOpacity: {
                    value: this._lineOpacity
                }
            },
            this._buildUniforms = {
                time: {
                    value: 0
                },
                color: {
                    value: new THREE.Vector3(this._color[0],this._color[1],this._color[2])
                },
                opacity: {
                    value: this._opacity
                },
                centerRadius: {
                    value: new THREE.Vector4
                },
                plane: {
                    value: new THREE.Vector4
                },
                viewPort: {
                    value: this.app.renderer.getCurrentViewport(new THREE.Vector4)
                },
                planeMatrix: {
                    value: new THREE.Matrix4
                },
                colorTexture: {
                    value: e
                },
                useColorTexture: {
                    value: n
                },
                alphaTexture: {
                    value: t
                },
                lineEnableRatio: {
                    value: this._linePositionRatio
                },
                lineWidthRatio: {
                    value: this._lineWidthRatio
                },
                lineColor: {
                    value: new THREE.Vector3(this._lineColor[0],this._lineColor[1],this._lineColor[2])
                },
                lineOpacity: {
                    value: this._lineOpacity
                }
            };
            let r = new THREE.ShaderMaterial({
                transparent: !0,
                opacity: this._opacity,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthTest: !0,
                depthWrite: !1,
                uniforms: this._uniforms,
                vertexShader: "\n      #include <common>\n      #include <logdepthbuf_pars_vertex>\n\n      varying vec2 vUv;\n      \n      void main() {\n        vec3 transformed = vec3( position );\n        vec4 mvPosition = vec4( transformed, 1.0 );\n        mvPosition = modelViewMatrix * mvPosition;\n        gl_Position = projectionMatrix * mvPosition;\n\n        vUv = uv;\n\n        // gl_Position = projectionMatrix * modelViewMatrix * vec4( position , 1.0 );// 会抖动\n\n        #include <logdepthbuf_vertex>\n      \n      }\n    ",
                fragmentShader: "\n      #include <common>\n      #include <logdepthbuf_pars_fragment>\n      #include <dithering_pars_fragment>\n\n      uniform vec3 color;\n      uniform float opacity;\n      uniform float time;// 0.0 --- 0.5\n      uniform sampler2D colorTexture;\n      uniform float useColorTexture;\n      uniform sampler2D alphaTexture;\n\n      uniform float lineEnableRatio;\n      uniform float lineWidthRatio;\n      uniform vec3 lineColor;\n      uniform float lineOpacity;\n\n      varying vec2 vUv;\n      \n      void main() {\n        #include <logdepthbuf_fragment>\n\n        float disToCenter = distance( vUv, vec2( 0.5, 0.5 ) );\n\n        // time * (2.0 / 3.0)? 因为Tween动画的Out类型导致,Plane需要扩展1.0 / 3.0\n        if( disToCenter <= time * ( 2.0 / 3.0 ) ){\n\n          vec2 processUv = vec2( ( ( vUv.x - 0.5 ) + time * ( 2.0 / 3.0 ) ) / ( 2.0 * time * ( 2.0 / 3.0 ) ), ( ( vUv.y - 0.5 ) + time * ( 2.0 / 3.0 ) ) / ( 2.0 * time * ( 2.0 / 3.0 ) ) );\n          vec4 textureColor = texture2D( colorTexture, processUv );\n\n          // vec4 alphaColor = texture2D( alphaTexture, vec2( disToCenter / ( time * 2.0 / 3.0 ) , 1.0 ) );\n          vec4 alphaTextureColor = texture2D( alphaTexture, vec2( time * 2.0, 1.0 ) );\n\n          if(useColorTexture == 1.0){ // 有纹理\n\n            gl_FragColor = vec4( color * textureColor.rgb, opacity * alphaTextureColor.a * textureColor.a);\n          \n          } else { // 无纹理\n          \n            gl_FragColor = vec4( color, opacity * alphaTextureColor.a * disToCenter );\n          \n          }\n\n          if(lineEnableRatio != 0.0){\n            float disToCenter = distance( processUv, vec2( 0.5, 0.5 ) );\n            if(disToCenter <= lineEnableRatio * 0.5 && disToCenter >= lineEnableRatio * 0.5 - lineWidthRatio * 0.5){\n              gl_FragColor = vec4( lineColor, lineOpacity);\n            }            \n          }\n\n        } else {\n          discard;\n        }\n\n        #include <dithering_fragment>\n      \n      }\n    "
            });
            this._materials.push(r);
            let a = new THREE.ShaderMaterial({
                transparent: !0,
                opacity: this._opacity,
                depthTest: !0,
                depthWrite: !1,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending,
                uniforms: this._buildUniforms,
                vertexShader: "\n      #include <common>\n      #include <logdepthbuf_pars_vertex>\n\n      varying vec2 vUv;\n      varying mat4 projMatrix;\n      \n      void main() {\n        vec3 transformed = vec3( position );\n        vec4 mvPosition = vec4( transformed, 1.0 );\n        mvPosition = modelViewMatrix * mvPosition;\n        gl_Position = projectionMatrix * mvPosition;\n\n        vUv = uv;\n        projMatrix = projectionMatrix;\n\n        // gl_Position = projectionMatrix * modelViewMatrix * vec4( position , 1.0 );// 会抖动\n\n        #include <logdepthbuf_vertex>\n      \n      }\n    ",
                fragmentShader: "\n      #include <common>\n      #include <logdepthbuf_pars_fragment>\n      #include <dithering_pars_fragment>\n\n      uniform vec3 color;\n      uniform float opacity;\n      uniform float time;\n      uniform vec4 centerRadius;\n      uniform vec4 viewPort;\n      uniform vec4 plane;\n      uniform sampler2D colorTexture;\n      uniform mat4 planeMatrix;\n\n      uniform sampler2D alphaTexture;\n      uniform float useColorTexture;\n\n      uniform float lineEnableRatio;\n      uniform float lineWidthRatio;\n      uniform vec3 lineColor;\n      uniform float lineOpacity;\n\n      varying vec2 vUv;\n      varying mat4 projMatrix;\n\n      vec3 projectPoint(vec3 point){\n\n        // 法线\n        vec3 normal = vec3( plane.x, plane.y, plane.z ) * (-1.0);\n        // 常量\n        float constant = plane.w;\n\n        // 点到平面距离\n        float disToPoint = dot( normal, point ) + constant;\n        disToPoint = -1.0 * disToPoint;\n\n        vec3 temp = vec3( normal.x * disToPoint, normal.y * disToPoint, normal.z * disToPoint );\n\n        vec3 finalPoint = vec3( temp.x + point.x, temp.y + point.y, temp.z + point.z);\n\n        return finalPoint;\n\n      }\n      \n      void main() {\n        #include <logdepthbuf_fragment>\n\n        float radius = centerRadius.w;\n        vec3 center = centerRadius.xyz;\n\n        vec4 ndc = vec4(\n          gl_FragCoord.x / viewPort.z * 2.0 - 1.0,\n          gl_FragCoord.y / viewPort.w * 2.0 - 1.0,\n          gl_FragCoord.z * 2.0 - 1.0,\n          1.0\n        );\n        mat4 inverseProjectionMatrix = inverse( projMatrix );\n        mat4 inverseviewMatrix = inverse( viewMatrix );\n\n        // 反算世界坐标\n        vec4 p = inverseProjectionMatrix * ndc;\n        vec4 positionWC = inverseviewMatrix * p;\n        // 向平面投影\n        vec3 projectPoint = projectPoint( positionWC.xyz / positionWC.w );\n        \n        float disToCenter = distance( projectPoint, center );\n\n        mat4 inversePlaneMatrix = inverse( planeMatrix );\n        vec4 positionPlane = inversePlaneMatrix * positionWC;\n\n        positionPlane.xy = ( positionPlane.xy / positionPlane.w + radius * 1.5 ) / ( radius * 3.0 );\n\n        if( disToCenter <= radius * 3.0 / 2.0 * time * 2.0 * ( 2.0 / 3.0 ) ){\n          vec2 processUv = vec2( ( ( positionPlane.x - 0.5 ) + time * ( 2.0 / 3.0 ) ) / ( 2.0 * time * ( 2.0 / 3.0 ) ), ( ( positionPlane.y - 0.5 ) + time * ( 2.0 / 3.0 ) ) / ( 2.0 * time * ( 2.0 / 3.0 ) ) );\n          vec4 textureColor = texture2D( colorTexture, processUv );\n\n          float disToCenterUv = distance( positionPlane.xy, vec2( 0.5, 0.5 ) );\n          // vec4 alphaTextureColor1 = texture2D( alphaTexture, vec2( disToCenterUv / ( time * 2.0 / 3.0 ) , 1.0 ) );\n          vec4 alphaTextureColor = texture2D( alphaTexture, vec2( time * 2.0, 1.0 ) );\n\n          if(useColorTexture == 1.0){\n            gl_FragColor = vec4( color * textureColor.rgb, opacity * alphaTextureColor.a * textureColor.a );\n          } else {\n            gl_FragColor = vec4( color, opacity * alphaTextureColor.a );\n          }\n\n          if(lineEnableRatio != 0.0){\n            float disToCenter = distance( processUv, vec2( 0.5, 0.5 ) );\n            if(disToCenter <= lineEnableRatio * 0.5 && disToCenter >= lineEnableRatio * 0.5 - lineWidthRatio * 0.5){\n              gl_FragColor = vec4( lineColor, lineOpacity * alphaTextureColor.a );\n            }            \n          }\n\n        } else {\n          discard;\n        }\n\n        #include <dithering_fragment>\n      \n      }\n    "
            });
            this._materials.push(a)
        }
        _createCylinderMaterial() {
            this._timeTarget = 1,
            this._uniforms = {
                time: {
                    value: 0
                },
                color: {
                    value: new THREE.Vector3(this._color[0],this._color[1],this._color[2])
                },
                opacity: {
                    value: this._opacity
                }
            };
            let t = new THREE.ShaderMaterial({
                side: THREE.DoubleSide,
                transparent: !0,
                opacity: this._opacity,
                blending: THREE.AdditiveBlending,
                depthTest: !0,
                depthWrite: !0,
                uniforms: this._uniforms,
                vertexShader: "\n        #include <common>\n        #include <logdepthbuf_pars_vertex>\n  \n        varying vec2 vUv;\n        \n        void main() {\n          vec3 transformed = vec3( position );\n          vec4 mvPosition = vec4( transformed, 1.0 );\n          mvPosition = modelViewMatrix * mvPosition;\n          gl_Position = projectionMatrix * mvPosition;\n  \n          vUv = uv;\n  \n          // gl_Position = projectionMatrix * modelViewMatrix * vec4( position , 1.0 );// 会抖动\n  \n          #include <logdepthbuf_vertex>\n        \n        }\n      ",
                fragmentShader: "\n        #include <common>\n        #include <logdepthbuf_pars_fragment>\n        #include <dithering_pars_fragment>\n  \n        uniform vec3 color;\n        uniform float opacity;\n        uniform float time;\n  \n        varying vec2 vUv;\n        \n        void main() {\n          #include <logdepthbuf_fragment>\n  \n          float disToCenter = distance( vUv, vec2( 0.5, 0.5 ) );\n  \n          gl_FragColor = vec4( color, (1.0 - vUv.y) * opacity );\n  \n          #include <dithering_fragment>\n        \n        }\n      "
            });
            this._materials.push(t)
        }
        _createTextureMaterial() {
            this._timeTarget = 2 * Math.PI;
            var t = (new THREE.TextureLoader).load(this._url);
            this._uniforms = {
                time: {
                    value: this._time
                },
                color: {
                    value: new THREE.Vector3(this._color[0],this._color[1],this._color[2])
                },
                opacity: {
                    value: this._opacity
                },
                colorTexture: {
                    value: t
                }
            },
            this._buildUniforms = {
                time: {
                    value: this._time
                },
                color: {
                    value: new THREE.Vector3(this._color[0],this._color[1],this._color[2])
                },
                opacity: {
                    value: this._opacity
                },
                centerRadius: {
                    value: new THREE.Vector4
                },
                viewPort: {
                    value: this.app.renderer.getCurrentViewport(new THREE.Vector4)
                },
                colorTexture: {
                    value: t
                },
                planeMatrix: {
                    value: new THREE.Matrix4
                },
                plane: {
                    value: new THREE.Vector4
                }
            };
            let e = new THREE.ShaderMaterial({
                transparent: !0,
                opacity: this._opacity,
                depthTest: !0,
                depthWrite: !1,
                uniforms: this._uniforms,
                vertexShader: "\n        #include <common>\n        #include <logdepthbuf_pars_vertex>\n\n        varying vec2 vUv;\n        \n        void main() {\n          vec3 transformed = vec3( position );\n          vec4 mvPosition = vec4( transformed, 1.0 );\n          mvPosition = modelViewMatrix * mvPosition;\n          gl_Position = projectionMatrix * mvPosition;\n\n          vUv = uv;\n\n          // gl_Position = projectionMatrix * modelViewMatrix * vec4( position , 1.0 );// 会抖动\n\n          #include <logdepthbuf_vertex>\n        \n        }\n      ",
                fragmentShader: "\n        #include <common>\n        #include <logdepthbuf_pars_fragment>\n        #include <dithering_pars_fragment>\n\n        uniform vec3 color;\n        uniform float opacity;\n        uniform float time;\n\n        uniform sampler2D colorTexture;\n\n        varying vec2 vUv;\n\n        vec2 rotateAround( vec2 tempUv, vec2 center, float angle ) {\n          float c = cos( angle );\n          float s = sin( angle );\n\n          float x = tempUv.x - center.x;\n          float y = tempUv.y - center.y;\n      \n          tempUv.x = x * c - y * s + center.x;\n          tempUv.y = x * s + y * c + center.y;\n\n          vec2 temp = tempUv;\n      \n          return temp;\n        }\n        \n        void main() {\n          #include <logdepthbuf_fragment>\n\n          vec2 finalUv = rotateAround( vUv, vec2( 0.5, 0.5 ), -time);\n\n          vec4 textureColor = texture2D( colorTexture, finalUv );\n\n          gl_FragColor = vec4( textureColor.rgb * color, textureColor.a * opacity );\n\n          if (finalUv.x < 0. || finalUv.x > 1. || finalUv.y < 0. || finalUv.y > 1.) discard;\n\n          #include <dithering_fragment>\n        \n        }\n      "
            });
            this._materials.push(e);
            let n = new THREE.ShaderMaterial({
                transparent: !0,
                opacity: this._opacity,
                depthTest: !0,
                depthWrite: !1,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending,
                uniforms: this._buildUniforms,
                vertexShader: "\n        #include <common>\n        #include <logdepthbuf_pars_vertex>\n\n        varying vec2 vUv;\n        varying mat4 projMatrix;\n        \n        void main() {\n          vec3 transformed = vec3( position );\n          vec4 mvPosition = vec4( transformed, 1.0 );\n          mvPosition = modelViewMatrix * mvPosition;\n          gl_Position = projectionMatrix * mvPosition;\n\n          vUv = uv;\n          projMatrix = projectionMatrix;\n\n          // gl_Position = projectionMatrix * modelViewMatrix * vec4( position , 1.0 );// 会抖动\n\n          #include <logdepthbuf_vertex>\n        \n        }\n      ",
                fragmentShader: "\n        #include <common>\n        #include <logdepthbuf_pars_fragment>\n        #include <dithering_pars_fragment>\n\n        uniform vec3 color;\n        uniform float opacity;\n        uniform float time;\n        uniform vec4 centerRadius;\n        uniform vec4 viewPort;\n        uniform sampler2D colorTexture;\n        uniform mat4 planeMatrix;\n        uniform vec4 plane;\n\n        varying vec2 vUv;\n        varying mat4 projMatrix;\n\n        vec2 rotateAround( vec2 tempUv, vec2 center, float angle ) {\n          float c = cos( angle );\n          float s = sin( angle );\n\n          float x = tempUv.x - center.x;\n          float y = tempUv.y - center.y;\n      \n          tempUv.x = x * c - y * s + center.x;\n          tempUv.y = x * s + y * c + center.y;\n\n          vec2 temp = tempUv;\n      \n          return temp;\n        }\n\n        vec3 projectPoint(vec3 point){\n\n          // 法线\n          vec3 normal = vec3( plane.x, plane.y, plane.z ) * (-1.0);\n          // 常量\n          float constant = plane.w;\n\n          // 点到平面距离\n          float disToPoint = dot( normal, point ) + constant;\n          disToPoint = -1.0 * disToPoint;\n\n          vec3 temp = vec3( normal.x * disToPoint, normal.y * disToPoint, normal.z * disToPoint );\n\n          vec3 finalPoint = vec3( temp.x + point.x, temp.y + point.y, temp.z + point.z);\n\n          return finalPoint;\n\n        }\n        \n        void main() {\n          #include <logdepthbuf_fragment>\n\n          float radius = centerRadius.w;\n          vec3 center = centerRadius.xyz;\n\n          vec4 ndc = vec4(\n            gl_FragCoord.x / viewPort.z * 2.0 - 1.0,\n            gl_FragCoord.y / viewPort.w * 2.0 - 1.0,\n            gl_FragCoord.z * 2.0 - 1.0,\n            1.0\n          );\n          mat4 inverseProjectionMatrix = inverse( projMatrix );\n          mat4 inverseviewMatrix = inverse( viewMatrix );\n\n          mat4 inversePlaneMatrix = inverse( planeMatrix );\n\n          vec4 p = inverseProjectionMatrix * ndc;\n          vec4 positionWC = inverseviewMatrix * p;\n\n          // 向平面投影\n          vec3 projectPoint = projectPoint( positionWC.xyz / positionWC.w );\n          \n          float disToCenter = distance( projectPoint, center );\n\n          vec4 positionPlane = inversePlaneMatrix * positionWC;\n\n          positionPlane.xy = ( positionPlane.xy / positionPlane.w + radius ) / ( radius * 2.0 );\n\n          vec2 finalUv = rotateAround( positionPlane.xy, vec2( 0.5, 0.5 ), -time);\n\n          vec4 textureColor = texture2D( colorTexture, finalUv );\n\n          gl_FragColor = vec4( textureColor.rgb * color, textureColor.a * opacity );\n\n          if (finalUv.x < 0. || finalUv.x > 1. || finalUv.y < 0. || finalUv.y > 1.) discard;\n\n          #include <dithering_fragment>\n        \n        }\n      "
            });
            this._materials.push(n)
        }
        _createMaterial(t) {
            t === De.TYPE_TEXTURE_SCALE ? this._createscaleCircularMaterial() : t === De.TYPE_CYLINDER ? this._createCylinderMaterial() : t === De.TYPE_TEXTURE_ROTATE && this._createTextureMaterial()
        }
        init() {
            this._renderDiffusion()
        }
        _renderDiffusion() {
            var t = this._diffusionType
              , e = this._radius;
            let n = function(t) {
                this._uniforms.time.value = t.time,
                this._buildUniforms.time.value = t.time
            };
            var a = r.a.convertLonlatToWorld(this._coordinates);
            if (a = new THREE.Vector3(a[0],a[1],a[2]),
            t === De.TYPE_TEXTURE_SCALE) {
                let t = new THREE.PlaneBufferGeometry(3 * e,3 * e,32);
                this._modifyGeometryHeight(t);
                let n = new THREE.Mesh(t,this._materials[0]);
                Object.defineProperty(n, "castShadow", {
                    set: function(t) {},
                    get: function() {
                        return !1
                    }
                }),
                Object.defineProperty(n, "receiveShadow", {
                    set: function(t) {},
                    get: function() {
                        return !1
                    }
                }),
                this.node.add(n),
                this._buildUniforms.centerRadius.value = new THREE.Vector4(a.x,a.y,a.z,e),
                this._buildUniforms.planeMatrix.value = this.node.matrix
            } else if (t === De.TYPE_CYLINDER) {
                var i = new THREE.CylinderBufferGeometry(e,e,this._cylinderHeight,64,64,!0);
                let t = new THREE.Matrix4;
                t.makeTranslation(0, this._cylinderHeight / 2, 0),
                i.attributes.position.applyMatrix4(t);
                var o = new THREE.Mesh(i,this._materials[0]);
                Object.defineProperty(o, "castShadow", {
                    set: function(t) {},
                    get: function() {
                        return !1
                    }
                }),
                Object.defineProperty(o, "receiveShadow", {
                    set: function(t) {},
                    get: function() {
                        return !1
                    }
                }),
                this.node.add(o),
                n = function(t) {
                    o.scale.x = t.time,
                    o.scale.y = 1 - t.time,
                    o.scale.z = t.time
                }
            } else if (t === De.TYPE_TEXTURE_ROTATE) {
                let t = new THREE.PlaneBufferGeometry(2 * e,2 * e,1);
                this._modifyGeometryHeight(t);
                let n = new THREE.Mesh(t,this._materials[0]);
                Object.defineProperty(n, "castShadow", {
                    set: function(t) {},
                    get: function() {
                        return !1
                    }
                }),
                Object.defineProperty(n, "receiveShadow", {
                    set: function(t) {},
                    get: function() {
                        return !1
                    }
                }),
                this.node.add(n),
                this._buildUniforms.centerRadius.value = new THREE.Vector4(a.x,a.y,a.z,e),
                this._buildUniforms.planeMatrix.value = this.node.matrix
            }
            if (this._diffusionType !== De.TYPE_CYLINDER) {
                this.node.position.copy(a),
                this.node.setDirection([a.x, a.y, a.z], 2, [0, 0, 1]);
                let t = new THREE.Vector3(a.x,a.y,a.z).normalize();
                if (this._buildUniforms.plane.value = new THREE.Vector4(t.x,t.y,t.z,6378e3),
                this._scanLayers.length > 0)
                    for (let t = 0; t < this._scanLayers.length; t++) {
                        this._scanLayers[t].node.getMeshes().forEach(t=>{
                            t._afterRendererMaterial || (t._afterRendererMaterial = []),
                            t._afterRendererMaterial.push(this._materials[1])
                        }
                        )
                    }
            } else
                a = r.a.convertLonlatToWorld(this._coordinates, this._offsetHeight),
                a = new THREE.Vector3(a[0],a[1],a[2]),
                this.node.position.copy(a),
                this.node.setDirection([a.x, a.y, a.z], 2, [0, 1, 0]);
            this._createTween(n)
        }
        _createTween(t) {
            var e = {
                time: this._startPosition * this._timeTarget
            }
              , n = this._timeTarget * this._endPosition
              , r = this._tween = new TWEEN.Tween(e).to({
                time: n
            }, 1 / this._speed * 1e4).easing(this._lerpType).onUpdate(e=>{
                t.call(this, e)
            }
            );
            r.repeat(1 / 0),
            r.start()
        }
        _createAlphaTexture(t) {
            for (var e = new Uint8Array(512), n = 0; n < 512; n++) {
                var r = t(n / 512);
                r < 0 ? r = 0 : r > 1 && (r = 1),
                e[n] = 255 * r
            }
            return new THREE.DataTexture(e,512,1,THREE.AlphaFormat)
        }
        _createInterpolantTexture(t) {
            var e = []
              , n = []
              , r = Object.keys(t);
            r.sort();
            for (let a in r)
                e.push(parseFloat(r[a])),
                n.push(t[r[a]]);
            const a = new THREE.LinearInterpolant(Float32Array.from(e),Float32Array.from(n),1,new Float32Array(1));
            for (var i = new Uint8Array(512), o = 0; o < 512; o++) {
                var s = a.evaluate(o / 512);
                s < 0 ? s = 0 : s > 1 && (s = 1),
                i[o] = 255 * s
            }
            return new THREE.DataTexture(i,512,1,THREE.AlphaFormat)
        }
        _modifyGeometryHeight(t) {
            let e = new THREE.Matrix4;
            e.makeTranslation(0, 0, this.offsetHeight),
            t.attributes.position.applyMatrix4(e)
        }
        _updateDiffusion() {
            var t = this.node.children[0]
              , e = r.a.convertLonlatToWorld(this._coordinates);
            e = new THREE.Vector3(e[0],e[1],e[2]);
            var n = this._radius
              , a = new THREE.Group;
            if (t.geometry.dispose(),
            delete t.geometry,
            this._diffusionType === De.TYPE_TEXTURE_SCALE) {
                let r = new THREE.PlaneBufferGeometry(3 * n,3 * n,32);
                this._modifyGeometryHeight(r),
                t.geometry = r,
                this._buildUniforms.centerRadius.value = new THREE.Vector4(e.x,e.y,e.z,n);
                let i = new THREE.Vector3(e.x,e.y,e.z).normalize();
                this._buildUniforms.plane.value = new THREE.Vector4(i.x,i.y,i.z,6378e3),
                a.position.copy(e),
                a.setDirection([e.x, e.y, e.z], 2, [0, 0, 1])
            } else if (this._diffusionType === De.TYPE_CYLINDER) {
                let o = new THREE.CylinderBufferGeometry(n,n,this._cylinderHeight,32,32,!0);
                var i = new THREE.Matrix4;
                i.makeTranslation(0, this._cylinderHeight / 2, 0),
                o.attributes.position.applyMatrix4(i),
                t.geometry = o,
                e = r.a.convertLonlatToWorld(this._coordinates, this._offsetHeight),
                e = new THREE.Vector3(e[0],e[1],e[2]),
                a.position.copy(e),
                a.setDirection([e.x, e.y, e.z], 2, [0, 1, 0])
            } else if (this._diffusionType === De.TYPE_TEXTURE_ROTATE) {
                let r = new THREE.PlaneBufferGeometry(2 * n,2 * n,1);
                this._modifyGeometryHeight(r),
                t.geometry = r,
                a.position.copy(e),
                a.setDirection([e.x, e.y, e.z], 2, [0, 0, 1]),
                this._buildUniforms.centerRadius.value = new THREE.Vector4(e.x,e.y,e.z,n),
                this._buildUniforms.planeMatrix.value = this.node.matrix;
                let i = new THREE.Vector3(e.x,e.y,e.z).normalize();
                this._buildUniforms.plane.value = new THREE.Vector4(i.x,i.y,i.z,6378e3)
            }
            this._updateTransform(a, this.node)
        }
        _setSpeed() {
            var t = this.node.children[0];
            let e;
            e = this._diffusionType !== De.TYPE_CYLINDER ? function(t) {
                this._uniforms.time.value = t.time,
                this._buildUniforms.time.value = t.time
            }
            : function(e) {
                t.scale.x = e.time,
                t.scale.y = 1 - e.time,
                t.scale.z = e.time
            }
            ,
            this._createTween(e)
        }
        _setVisible() {
            if (this._diffusionType !== De.TYPE_CYLINDER && this.node.visible !== this._visible && this._scanLayers.length > 0)
                if (this._visible)
                    for (let t = 0; t < this._scanLayers.length; t++) {
                        this._scanLayers[t].node.getMeshes().map(t=>{
                            t._afterRendererMaterial || (t._afterRendererMaterial = []),
                            t._afterRendererMaterial.push(this._materials[1])
                        }
                        )
                    }
                else
                    for (let t = 0; t < this._scanLayers.length; t++) {
                        this._scanLayers[t].node.getMeshes().map(t=>{
                            if (t._afterRendererMaterial && t._afterRendererMaterial.length > 0) {
                                let e = t._afterRendererMaterial.indexOf(this._materials[1]);
                                -1 !== e && t._afterRendererMaterial.splice(e, 1)
                            }
                        }
                        )
                    }
            this.node.visible = this._visible
        }
        _updateTransform(t, e) {
            t.matrix.decompose(e.position, e.quaternion, e.scale),
            e.matrixWorld = t.matrixWorld,
            e.updateMatrix()
        }
        _onResize(t) {
            this._buildUniforms && (this._buildUniforms.viewPort.value = this.app.renderer.getCurrentViewport(new THREE.Vector4))
        }
        destroy() {
            if (super.destroy(),
            this._tween && TWEEN.remove(this._tween),
            this._diffusionType !== De.TYPE_CYLINDER)
                if (this._scanLayers.length > 0)
                    for (let t = 0; t < this._scanLayers.length; t++) {
                        this._scanLayers[t].node.getMeshes().map(t=>{
                            if (t._afterRendererMaterial && t._afterRendererMaterial.length > 0) {
                                let e = t._afterRendererMaterial.indexOf(this._materials[1]);
                                -1 !== e && (t._afterRendererMaterial.splice(e, 1),
                                this._buildUniforms.colorTexture && this._buildUniforms.colorTexture.value && this._buildUniforms.colorTexture.value.dispose(),
                                this._materials[1].dispose())
                            }
                        }
                        )
                    }
                else
                    this._buildUniforms.colorTexture && this._buildUniforms.colorTexture.value && this._buildUniforms.colorTexture.value.dispose(),
                    this._materials[1].dispose();
            this._uniforms.colorTexture && this._uniforms.colorTexture.value && this._uniforms.colorTexture.value.dispose(),
            this._materials && this._materials.length > 0 && this._materials[0] && this._materials[0].dispose();
            var t = this.node.children[0];
            this.node.remove(t)
        }
    }
    THING.factory.registerClass("GeoDiffusion", De);
    var je = De;
    De.TYPE_TEXTURE_ROTATE = "texture",
    De.TYPE_TEXTURE_SCALE = "scaleTexture",
    De.TYPE_CYLINDER = "cylinder";
    class Le extends P {
        constructor(t) {
            super(t),
            this.app = t,
            this.geometryType = "",
            this.meshType = "Mesh"
        }
        setupUserData(t) {
            t || (t = {}),
            t.withGeometryIDAttributes = !0,
            super.setupUserData(t)
        }
        customSetup(t) {
            if (super.customSetup(t),
            this.name = t.name || "bigDataLayer_" + r.a.getUUID(),
            this.id = t.id || this.name,
            this.dataSource = this.data = t.dataSource || {
                type: "FeatureCollection",
                features: []
            },
            this.groupInfo = {},
            this._renderer = {},
            this._geoObjectArray = [],
            this._geometryArray = [],
            t.renderer && (this._renderer = JSON.parse(JSON.stringify(t.renderer))),
            this.mergeCount = 1e5,
            this.sync = THING.Utils.parseValue(t.sync, !1),
            this._heightArray = t.heightArray,
            this._workerCount = void 0 === t.workerCount ? 4 : t.workerCount,
            this._offsetHeight = t.offsetHeight,
            this._offsetHeightField = t.offsetHeightField,
            this._offsetHeightAdded = THING.Utils.parseValue(t.offsetHeightAdded, 0),
            this._offsetHeightFactor = THING.Utils.parseValue(t.offsetHeightFactor, 1),
            this._groundHeightField = t.groundHeightField,
            this._groundHeightFactor = THING.Utils.parseValue(t.groundHeightFactor, 1),
            this._extrudeHeight = t.extrudeHeight || this._renderer.extrudeHeight,
            this._extrudeField = t.extrudeField || this._renderer.extrudeField,
            this._extrudeFactor = t.extrudeFactor || this._renderer.extrudeFactor,
            this._clampToGround = THING.Utils.parseValue(t.clampToGround, !1),
            this._setupComplete = super.setupComplete,
            this._inVisibleIndices = THING.Utils.parseValue(t.inVisibleIndices, []),
            this.on(THING.EventType.BigDataLayerComplete, function(e) {
                this._setupComplete(t),
                this._afterSetup()
            }),
            this._dataHandler(this.data, this._renderer, this.mergeCount, this.geometryType, this.inVisibleIndices),
            this.extent = CMAP.Util.getFeatureCollectionExtent(this.dataSource),
            this._complete = t.complete,
            this.data.features && 0 === this.data.features.length)
                return void this.trigger(THING.EventType.BigDataLayerComplete, {
                    object: this
                });
            let e = this;
            r.a._addObserver(this._renderer, function(t) {
                e.node.getMaterials().forEach(e=>{
                    e.opacity = t
                }
                )
            }),
            this.sync || (this.trigger(THING.EventType.BigDataLayerComplete, {
                object: this
            }),
            THING.App.current.trigger(THING.EventType.BigDataLayerComplete, {
                object: this
            }),
            this.geometryType && "GeoBuilding" === this.geometryType && THING.App.current.trigger("MergeBuildingProgress", {
                progress: 1,
                name: this.name
            }))
        }
        _getOffsetHeightByFieldAndFactor(t, e, n=1, r=0) {
            return THING.Utils.isNull(t[e]) || isNaN(t[e]) || "object" == typeof t[e] ? r : t[e] * n + r
        }
        _getOffsetHeight(t) {
            let e = this._offsetHeight;
            if (THING.Utils.isNull(e)) {
                let n = 0
                  , r = this._getOffsetHeightByFieldAndFactor(t.properties, this._offsetHeightField, this._offsetHeightFactor, this._offsetHeightAdded);
                if (this._groundHeightField && "无" !== this._groundHeightField)
                    if (n = t.properties[this._groundHeightField],
                    Array.isArray(n)) {
                        e = [];
                        for (let t = 0; t < n.length; t++)
                            e[t] = n[t] * this._groundHeightFactor + r
                    } else
                        e = (n = this._getOffsetHeightByFieldAndFactor(t.properties, this._groundHeightField, this._groundHeightFactor)) + r;
                else
                    e = r
            }
            return e
        }
        setupComplete(t) {}
        get offsetHeight() {
            return THING.Utils.parseValue(this._offsetHeight, 0)
        }
        set offsetHeight(t) {
            this._getMeshes().forEach(e=>e.translate([0, t - this.offsetHeight, 0])),
            this._offsetHeight = t
        }
        get inVisibleIndices() {
            return this._inVisibleIndices
        }
        set inVisibleIndices(t) {
            this._inVisibleIndices = t;
            let e = new Float32Array(this.dataSource.features.length);
            for (let n = 0; n < this.dataSource.features.length; n++)
                t.length > 0 && t.indexOf(n) >= 0 ? e[n] = 0 : e[n] = 1;
            let n = 0
              , r = this.node.getGeometries();
            r.sort(function(t, e) {
                return (t = t.attributes.id.array[0]) - (e = e.attributes.id.array[0])
            });
            for (let t = 0; t < r.length; t++) {
                const a = r[t]
                  , i = a.attributes.id.array;
                let o = new Float32Array(i.length);
                0 === t && (n = i[0]);
                for (let t = 0; t < i.length; t++) {
                    const r = i[t] - n;
                    o[t] = e[r]
                }
                a.addAttribute("vis", new THREE.BufferAttribute(o,1))
            }
            THING.App.current.rendererManager._mainRenderer.dirty(),
            THING.App.current.picker.needUpdate = !0
        }
        setRenderer(t) {
            this.removeContent(),
            this._renderer = t,
            THING.Utils.isNull(t.extrudeField) || (this._extrudeField = t.extrudeField),
            THING.Utils.isNull(t.extrudeFactor) || (this._extrudeFactor = t.extrudeFactor),
            this._dataHandler(this.data, this._renderer, this.mergeCount, this.geometryType, this.inVisibleIndices)
        }
        get renderer() {
            return this._renderer
        }
        updateRenderer(t) {
            for (var e in this.removeContent(),
            t)
                this._renderer[e] = t[e];
            this._dataHandler(this.data, this._renderer, this.mergeCount, this.geometryType, this.inVisibleIndices),
            this._afterSetup()
        }
        _dataHandler(t, e, n, r, a) {
            let i = this._createLayerMesh(t, e, n, r, a);
            if (!this.sync)
                for (var o = 0; o < i.length; o++)
                    this.node.add(i[o])
        }
        removeContent() {
            for (var t = this.node.children.length - 1; t >= 0; t--)
                this.node.remove(this.node.children[t]);
            this.groupInfo = {},
            this.clearPickIdBuffer()
        }
        clearPickIdBuffer() {
            for (let t = CMAP.getCurrentMap().pickIdBuffer.length - 1; t >= 0; t--)
                CMAP.getCurrentMap().pickIdBuffer[t].node === this.node && CMAP.getCurrentMap().pickIdBuffer.splice(t, 1)
        }
        _parseData(t, e) {
            var n, a = t.features, i = {}, o = {}, s = CMAP.getCurrentMap().pickIdBuffer;
            n = 0 === s.length ? {
                start: 0,
                count: a.length,
                node: this.node
            } : {
                start: s[s.length - 1].start + s[s.length - 1].count,
                count: a.length,
                node: this.node
            },
            s.push(n);
            for (var l = 0; l < a.length; l++) {
                var u = a[l]
                  , c = []
                  , h = u.properties;
                u.pickId = n.start + l;
                var d = {};
                for (var f in e) {
                    var p = e[f];
                    if (Array.isArray(p))
                        if (void 0 !== p[0].condition)
                            for (var m in p) {
                                var g = p[m].condition;
                                if ("" === g && (d[f] = p[m].value),
                                r.a.isObjectMeetCondition(h, g)) {
                                    -1 === c.indexOf(g) && c.push(g),
                                    d[f] = p[m].value;
                                    break
                                }
                            }
                        else
                            d[f] = p;
                    else
                        d[f] = p
                }
                var v = JSON.stringify(c);
                i[v] || (i[v] = []),
                o[v] || (o[v] = []),
                i[v].push(u),
                o[v] = d
            }
            return {
                groupInfo: i,
                rendererInfo: o
            }
        }
        on() {
            arguments.length < 2 && THING.Utils.log("参数不合法");
            var t = null
              , e = 0;
            for (let n = 0; n < arguments.length; n++)
                "function" == typeof arguments[n] && (t = arguments[n],
                e = n);
            if (arguments[0].toLowerCase().indexOf("complete") < 0 && t) {
                arguments[e] = function(e) {
                    let n = e.object.node._pickedId;
                    void 0 !== n && CMAP.getCurrentMap().pickIdBuffer.forEach(function(t) {
                        t.node === e.object.node && (e.userData = e.object.dataSource.features[n - CMAP.pickIdStartNum - t.start].properties,
                        e.coordinates = e.object.dataSource.features[n - CMAP.pickIdStartNum - t.start].geometry.coordinates,
                        e.dataIndex = e.id = n - CMAP.pickIdStartNum - t.start,
                        e.pickId = n)
                    }),
                    t.call(e.object, e)
                }
            }
            super.on.apply(this, arguments)
        }
        createGeoObject(t, e, n, r) {
            return {}
        }
        createGeoObjectSync(t, e, n, r, a, i) {
            return {}
        }
        createGeometryManager(t, e) {
            var n = new t3djs.GeometryManager(t,e);
            let r = 0;
            return CMAP.getCurrentMap().pickIdBuffer.length > 0 && (r += CMAP.getCurrentMap().pickIdBuffer[CMAP.getCurrentMap().pickIdBuffer.length - 1].start),
            n.setIdStartNum(r),
            n.setMergeNums(this.mergeCount),
            n
        }
        createMesh(t, e, n) {
            return {}
        }
        createMaterial(t) {
            return {}
        }
        mergeGeometry(t, e) {
            return []
        }
        _afterSetup() {
            this._updatePostEffect(this.renderer)
        }
        _getMeshes() {
            var t = this
              , e = [];
            return this.node.traverse(function(n) {
                n.type && n.type === t.meshType && e.push(n)
            }),
            e
        }
        _setPostRadiusEffect(t, e="radialBlur") {
            let n = this.app;
            this._getMeshes().forEach(function(r) {
                t ? n.effectManager.setEffect(r, e, !0) : n.effectManager.removeEffect(r, e)
            })
        }
        _setPostRadialBlur2(t) {
            this._setPostRadiusEffect(t, "radialBlur2")
        }
        destroy(t) {
            this._updateName && CMAP.Updater.delete(this._updateName),
            this.clearPickIdBuffer(),
            super.destroy(t)
        }
        _resetRenderer(t) {
            for (let e in this._renderer)
                Array.isArray(this._renderer[e]) && this._renderer[e].length > 0 && void 0 !== this._renderer[e].condition && void 0 !== t[e] && (this._renderer[e] = t[e])
        }
        _createLayerMesh(t, e, n, a, i) {
            console.time("开始创建" + a);
            var o = this;
            console.time("解析数据");
            let s = this._parseData(t, e);
            console.timeEnd("解析数据");
            let l = s.groupInfo
              , u = Object.keys(l).length
              , c = s.rendererInfo
              , h = []
              , d = Math.floor(this._workerCount / u) <= 0 ? 1 : Math.floor(this._workerCount / u);
            this._workerCount = d * u;
            var f, p = 0, m = 0, g = 0;
            function v(t) {
                let e = 1;
                return i.length > 0 && i.indexOf(t) >= 0 && (e = 0),
                e
            }
            for (var y in l) {
                f || (f = M.a.getReferencePosition(l[y][0].geometry.coordinates, this.offsetHeight));
                var _ = c[y]
                  , x = l[y]
                  , b = new THREE.Group
                  , w = 1;
                if ("GeoPoint" !== this.geometryType)
                    if (this.sync) {
                        g === Object.keys(l).length - 1 && (d = this._workerCount - p);
                        var C = this.createGeometryManager("geometryManager_" + this.queryID + "_" + g, d);
                        p += d;
                        for (let t = 0; t < x.length; t++) {
                            let e = x[t];
                            this.createGeoObjectSync(e, f, _, C, e.pickId, v(t))
                        }
                        C._renderer = _,
                        C._tempParent = b,
                        b.setPosition(f),
                        M.a._setNodeAnglesByPosition(b, f),
                        C.finish(function(t) {
                            let e = CMAP.Util.position2angles([this._tempParent.position.x, this._tempParent.position.y, this._tempParent.position.z])
                              , n = CMAP.Util.anglesToQuaternion(e).inverse();
                            this._renderer._quaternion = n;
                            var r = o.createMaterial(this._renderer)
                              , a = o.createMesh(t, r, this._renderer);
                            "cool" === _.type && _.effect && THING.App.current.effectManager.setEffect(a, "glow", _.glowStrength),
                            this._tempParent.add(a),
                            o.node.add(this._tempParent)
                        }, function(t) {}, function(t) {
                            var e = t.mergedGeometry.length;
                            THING.Utils.log("最终创建物体个数:", e),
                            t.dispose(),
                            ++m === u && (o.renderOrder = o.renderOrder,
                            setTimeout(function() {
                                o.trigger(THING.EventType.BigDataLayerComplete, {
                                    object: o
                                }),
                                THING.App.current.trigger(THING.EventType.BigDataLayerComplete, {
                                    object: o
                                }),
                                r.a._updateShadowNextFrame()
                            }, 0))
                        })
                    } else {
                        console.time("创建GeoObject");
                        for (var E = 0; E < x.length; E++) {
                            E > x.length / 10 * w && (THING.App.current.trigger("MergeBuildingProgress", {
                                progress: .1 * w,
                                name: this.name
                            }),
                            w += 1);
                            var T = x[E]
                              , A = this.createGeoObject(T, f, _, E);
                            this._geoObjectArray.push(A),
                            0 === A.geometryArray.length && this._geometryArray.push(new THREE.BufferGeometry);
                            for (var P = 0; P < A.geometryArray.length; P++) {
                                let t = A.geometryArray[P].attributes.position.count
                                  , e = new Float32Array(t)
                                  , n = new Float32Array(t);
                                n.fill(v(E)),
                                e.fill(CMAP.pickIdStartNum + T.pickId),
                                A.geometryArray[P].addAttribute("id", new THREE.BufferAttribute(e,1)),
                                A.geometryArray[P].addAttribute("vis", new THREE.BufferAttribute(n,1)),
                                this._geometryArray.push(A.geometryArray[P])
                            }
                        }
                        console.timeEnd("创建GeoObject"),
                        console.time("合并GeoObject");
                        var S = this.mergeGeometry(this._geometryArray, n);
                        console.timeEnd("合并GeoObject"),
                        this._geometryArray = [],
                        this._geoObjectArray = [],
                        b.setPosition(f),
                        M.a._setNodeAnglesByPosition(b, f);
                        let t = CMAP.Util.position2angles(f)
                          , e = CMAP.Util.anglesToQuaternion(t).inverse();
                        _._quaternion = e,
                        console.time("创建Material");
                        var R = this.createMaterial(_);
                        console.timeEnd("创建Material"),
                        console.time("创建Mesh");
                        for (var D = 0; D < S.length; D++) {
                            var j = this.createMesh(S[D], R, _);
                            ("GeoBuilding" !== this.geometryType && "GeoPolygon" !== this.geometryType || ("GeoBuilding" === this.geometryType || "GeoPolygon" === this.geometryType) && "cool" === _.type) && _.effect && THING.App.current.effectManager.setEffect(j, "glow", _.glowStrength),
                            b.add(j)
                        }
                        console.timeEnd("创建Mesh"),
                        h.push(b),
                        r.a._updateShadowNextFrame()
                    }
                else {
                    let e = this.createGeoObject(x, f, _)
                      , n = this.createMaterial(_)
                      , r = e.geometryArray[0]
                      , a = r.attributes.position.count
                      , o = new Float32Array(a)
                      , s = new Float32Array(a);
                    for (let e = 0; e < t.features.length; e++) {
                        var L = t.features[e].pickId;
                        o[e] = CMAP.pickIdStartNum + L,
                        i.length > 0 && i.indexOf(e) >= 0 ? s[e] = 0 : s[e] = 1
                    }
                    r.addAttribute("id", new THREE.BufferAttribute(o,1)),
                    r.addAttribute("vis", new THREE.BufferAttribute(s,1));
                    let l = this.createMesh(r, n, _);
                    b.add(l),
                    h.push(b)
                }
                g++
            }
            if (console.timeEnd("开始创建" + a),
            !this.sync)
                return h
        }
    }
    THING.factory.registerClass("BigDataLayer", Le);
    var Ie = Le;
    class Oe extends Ie {
        constructor(t) {
            super(t),
            this.geometryType = "GeoBuilding"
        }
        _parseRenderer(t) {
            let e = !1;
            "image" !== this._renderer.type && (e = !0),
            t.lights = THING.Utils.parseValue(t.lights, e),
            this._resetRenderer(t)
        }
        _createLayerMesh(t, e, n, r, a) {
            return this._extrudeFactor = THING.Utils.parseValue(this._extrudeFactor, 1),
            this._parseRenderer(e),
            super._createLayerMesh(t, e, n, r, a)
        }
        createGeoObject(t, e, n) {
            let r = this._extrudeHeight || this._height || n.extrudeHeight || n.height;
            if (void 0 !== r && 0 !== r || (r = parseFloat(t.properties[this._extrudeField]) * parseFloat(this._extrudeFactor)),
            (isNaN(r) || void 0 === r || 0 === r) && (r = .1),
            0 === t.geometry.coordinates.length)
                return {
                    geometryArray: []
                };
            n && (n.textureSize = n.textureSize || [3, 3],
            n.windowTextureSize = n.windowTextureSize || M.a._defaultWindowTextureSize);
            let a = this._getOffsetHeight(t);
            var i = [];
            if (t.geometry && t.geometry.coordinates && t.geometry.coordinates.length > 0) {
                var o = M.a.createBuilding(t.geometry.coordinates, r, e, "BUILDING", n.textureSize, null, a, !0, n.windowTextureSize);
                i = this.mergeGeometry(o.geometryArray, 1e6)
            }
            return o.geometryArray = i,
            o
        }
        createGeoObjectSync(t, e, n, r, a, i) {
            let o = this._extrudeHeight || this._height || this.renderer.extrudeHeight || this.renderer.height;
            void 0 !== o && 0 !== o || (o = parseFloat(t.properties[this._extrudeField]) * parseFloat(this._extrudeFactor)),
            (isNaN(o) || void 0 === o || 0 === o) && (o = .1),
            n && (n.textureSize = n.textureSize || [3, 3],
            n.windowTextureSize = n.windowTextureSize || M.a._defaultWindowTextureSize);
            let s = this._getOffsetHeight(t);
            t.geometry && t.geometry.coordinates && t.geometry.coordinates.length > 0 && M.a.createBuilding(t.geometry.coordinates, o, e, "BUILDING", n.textureSize, r, s, !0, n.windowTextureSize, a, i)
        }
        createMaterial(t) {
            let e = t._quaternion;
            t = new jt(void 0,t);
            var n = JSON.parse(JSON.stringify(t.toObject()));
            n.quaternion = e;
            const r = Ut.createBuildingMaterial(n);
            return r.forEach(t=>{
                t.defines || (t.defines = {}),
                t.defines.USE_VISIBLE = !0
            }
            ),
            r
        }
        createMesh(t, e, n) {
            return M.a.createBuildingMesh(t, e, n)
        }
        mergeGeometry(t, e) {
            return t3djs.util.mergeBufferGeometry(t, e, !0)
        }
    }
    THING.factory.registerClass("BigBuildingLayer", Oe);
    var ke = Oe;
    class He extends Ie {
        constructor(t) {
            super(t),
            this.geometryType = "GeoLine",
            this._particalParent = new THREE.Group
        }
        createGeoObject(t, e, n, r) {
            let a;
            this._heightArray && (a = this._heightArray[r]);
            const i = this._getOffsetHeight(t);
            return M.a.createLine(t.geometry.coordinates, a, e, n.lineType, n.width, n.textureSize, n.textureWrap, this._clampToGround, i)
        }
        _parseRenderer(t) {
            THING.Utils.isNull(t.blending) && ("vector" === t.type ? t.blending = !1 : "image" === t.type && (t.blending = !0)),
            t.opacity = THING.Utils.parseValue(t.opacity, 1),
            t.color = THING.Utils.parseValue(t.color, [255, 255, 255]);
            const e = CMAP.Util.colorFormatNewToOld(t.color, t.opacity) || [1, 1, 1, 1];
            t.opacity = e[3],
            t.color = CMAP.Util.colorFormatOldToNew(e),
            t.width = THING.Utils.parseValue(t.width, 5),
            t._isBigLineLayer = !0,
            this._resetRenderer(t)
        }
        createMaterial(t) {
            this._parseRenderer(t);
            let e = Ut.createLineMaterial(t);
            return e.defines || (e.defines = {}),
            e.defines.USE_VISIBLE = !0,
            e
        }
        createMesh(t, e, n) {
            return "Line" === n.lineType ? this.meshType = "LineSegments" : this.meshType = "Mesh",
            M.a.createLineMesh(t, e, n)
        }
        mergeGeometry(t, e) {
            return t3djs.util.mergeBufferGeometry(t, e)
        }
        _dataHandler(t, e, n, r, a) {
            super._dataHandler(t, e, n, r, a),
            this.renderer.type
        }
        _getSpritePositionByPer(t, e) {
            var n = [0, 0, 0]
              , r = this._uvArray[e].segs;
            for (var a in t /= this.totalLengthArray[e],
            r) {
                var i = r[a].startPoint.textureCoord[0]
                  , o = r[a].endPoint.textureCoord[0];
                if (t > i && t < o) {
                    var s = [r[a].endPoint[0] - r[a].startPoint[0], r[a].endPoint[1] - r[a].startPoint[1], r[a].endPoint[2] - r[a].startPoint[2]]
                      , l = (t - i) / (o - i);
                    n = [r[a].startPoint[0] + l * s[0], r[a].startPoint[1] + l * s[1], r[a].startPoint[2] + l * s[2]];
                    break
                }
            }
            return n
        }
        _drawSprite(t) {
            if (this.taskName = [],
            0 !== this.renderer.speed && "Pipe" !== this.renderer.lineType)
                for (var e = this.particle = this.node.createChild("particle"), n = 0; n < t; n++) {
                    var a = this.particleSystem = new THREE.GPUParticleSystem({
                        maxParticles: 30
                    })
                      , i = e.createChild("particle" + n)
                      , o = t3djs.sceneManager.createEntity(a);
                    i.attachObject(o),
                    e.add(i);
                    var s = {
                        position: new THREE.Vector3,
                        positionRandomness: 0,
                        velocity: new THREE.Vector3,
                        velocityRandomness: 0,
                        color: 16777215,
                        colorRandomness: 0,
                        turbulence: 0,
                        lifetime: 1,
                        size: 1 + this.renderer.width / 2,
                        sizeRandomness: 0
                    }
                      , l = {
                        speed: this.renderer.speed,
                        per: 0,
                        particleSystem: a,
                        options: s,
                        clock: new THREE.Clock,
                        tick: 0,
                        spawnerOptions: {
                            spawnRate: 10,
                            horizontalSpeed: 1.5,
                            verticalSpeed: 1.33,
                            timeScale: 1
                        },
                        index: n,
                        update: function() {
                            var t = this.clock.getDelta() * this.spawnerOptions.timeScale;
                            if (this.tick += t,
                            this.tick < 0 && (this.tick = 0),
                            this.per += 30 * this.speed,
                            this.per > this.totalLengthArray[this.index] && (this.per = 0),
                            t > 0) {
                                var e = this._getSpritePositionByPer(this.per, this.index)
                                  , n = this._particalParent.convertWorldToLocalPosition(e);
                                this.options.position.set(n[0], n[1], n[2]),
                                this.particleSystem.spawnParticle(this.options)
                            }
                            this.particleSystem.update(this.tick)
                        }
                    }
                      , u = r.a.getUUID();
                    this.taskName.push(u),
                    t3djs.buffer._renderList.add(u, l)
                }
        }
    }
    THING.factory.registerClass("BigLineLayer", He);
    var Fe = He;
    class Be extends Ie {
        constructor(t) {
            super(t),
            this.app = t,
            this.geometryType = "GeoPoint",
            this.meshType = "Points",
            this._updateName = "bigPointRefresh" + this.queryID,
            this.extent = {}
        }
        createGeoObject(t, e, n) {
            let a = {
                minX: 180,
                minY: 90,
                maxX: -180,
                maxY: -90
            };
            for (var i = 0; i < t.length; i++) {
                const e = t[i].geometry.coordinates;
                e[0] < a.minX && (a.minX = e[0]),
                e[0] > a.maxX && (a.maxX = e[0]),
                e[1] < a.minY && (a.minY = e[1]),
                e[1] > a.maxY && (a.maxY = e[1])
            }
            this.extent = a;
            let o = new Float32Array(3 * t.length)
              , s = new Float32Array(4 * t.length)
              , l = new Float32Array(2 * t.length);
            for (let e = 0; e < t.length; e++) {
                let n = this._getOffsetHeight(t[e])
                  , i = r.a.convertLonlatToWorld(t[e].geometry.coordinates, n);
                o[3 * e] = i[0],
                o[3 * e + 1] = i[1],
                o[3 * e + 2] = i[2],
                s[4 * e] = 1,
                s[4 * e + 1] = 1,
                s[4 * e + 2] = 1,
                s[4 * e + 3] = 1,
                l[2 * e] = (t[e].geometry.coordinates[0] - a.minX) / (a.maxX - a.minX),
                l[2 * e + 1] = (t[e].geometry.coordinates[1] - a.minY) / (a.maxY - a.minY)
            }
            return {
                geometryArray: [t3djs.util.createBigPointGeometry(o, s, l)]
            }
        }
        createMaterial(t) {
            this._parseRenderer(t);
            let e = t.size
              , n = JSON.parse(JSON.stringify(t));
            "vector" === t.type && (n.type = t.vectorType);
            let r = t3djs.util.createBigPointMaterial(this.name + "_mat", e, n);
            if (t.uvMapUrl) {
                r.defines.USE_UVMAP = !0;
                var a = new THREE.TextureLoader;
                r.uniforms.uvMap.value = a.load(t.uvMapUrl)
            }
            return t.depthTest && (r.depthTest = !0),
            r
        }
        createMesh(t, e, n) {
            let r = this.app;
            var a = t3djs.util.createBigPointMesh(t, e);
            if (n.effect) {
                let t = 1;
                void 0 !== n.glowStrength && (t = n.glowStrength),
                r.effectManager.setEffect(a, "glow", t)
            }
            return n.postRadialBlur && r.effectManager.setEffect(a, "radialBlur", !0),
            n.postRadialBlur2 && r.effectManager.setEffect(a, "radialBlur2", !0),
            a
        }
        _parseRenderer(t) {
            t.effect = THING.Utils.parseValue(t.effect, !1),
            t.glowStrength = THING.Utils.parseValue(t.glowStrength, .5),
            t.postRadialBlur = THING.Utils.parseValue(t.postRadialBlur, !1),
            t.size = THING.Utils.parseValue(t.size, 10),
            t.opacity = THING.Utils.parseValue(t.opacity, 1),
            t.lineOpacity = THING.Utils.parseValue(t.lineOpacity, 1),
            t.type = THING.Utils.parseValue(t.type, "vector"),
            t.vectorType = THING.Utils.parseValue(t.vectorType, "circle"),
            t.color && (t.color = r.a.colorFormatNewToOld(t.color, t.opacity)),
            t.lineColor && (t.lineColor = r.a.colorFormatNewToOld(t.lineColor, t.lineOpacity)),
            t.blending = r.a._parseBlending(t.blending),
            t.speed = THING.Utils.parseValue(t.speed, 0),
            t.loopType = THING.Utils.parseValue(t.loopType, THING.LoopType.Repeat),
            this._resetRenderer(t)
        }
        get offsetHeight() {
            return this._offsetHeight
        }
        set offsetHeight(t) {
            for (var e = this._getMeshes()[0].geometry.attributes.position.array, n = 0, r = e.length / 3; n < r; n++) {
                var a = [e[3 * n], e[3 * n + 1], e[3 * n + 2]]
                  , i = CMAP.Util.convertWorldToLonlat(a);
                a = CMAP.Util.convertLonlatToWorld([i[0], i[1]], t),
                e[3 * n] = a[0],
                e[3 * n + 1] = a[1],
                e[3 * n + 2] = a[2]
            }
            this._getMeshes()[0].geometry.setAttribute("position", new THREE.BufferAttribute(e,3)),
            this._offsetHeight = t
        }
        _afterSetup() {
            super._afterSetup();
            let t = this
              , e = this.renderer.speed;
            e = e * this.app.deltaTime / 16.667;
            let n = this.renderer.loopType;
            if (e > 0) {
                let r = this.node.getMaterials();
                r.forEach(function(t) {
                    t.uniforms.offset.value.x = 1
                }),
                n === THING.LoopType.Repeat ? C.a.add(t._updateName, function() {
                    r.forEach(function(t) {
                        t.uniforms.offset.value.x < -1 && (t.uniforms.offset.value.x = 1);
                        let n = t.uniforms.offset.value.x - .001 * e;
                        t.uniforms.offset.value.setX(n)
                    }),
                    t.app.rendererManager._mainRenderer.dirty()
                }) : n === THING.LoopType.PingPong ? C.a.add(this._updateName, function() {
                    r.forEach(function(t) {
                        (t.uniforms.offset.value.x < -1 || t.uniforms.offset.value.x > 1) && (e *= -1);
                        let n = t.uniforms.offset.value.x + .001 * e;
                        t.uniforms.offset.value.setX(n)
                    }),
                    t.app.rendererManager._mainRenderer.dirty()
                }) : C.a.add(this._updateName, function() {
                    r.forEach(function(n) {
                        n.uniforms.offset.value.x < -1 && (C.a.delete(t._updateName),
                        n.uniforms.offset.value.x = 0);
                        let r = n.uniforms.offset.value.x - .001 * e;
                        n.uniforms.offset.value.setX(r)
                    }),
                    t.app.rendererManager._mainRenderer.dirty()
                })
            }
        }
    }
    THING.factory.registerClass("BigPointLayer", Be);
    var Ue = Be;
    const Ne = 6370996.81
      , ze = [12890594.86, 8362377.87, 5591021, 3481989.83, 1678043.12, 0]
      , qe = [75, 60, 45, 30, 15, 0]
      , Ve = [[1.410526172116255e-8, 898305509648872e-20, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -.03801003308653, 17337981.2], [-7.435856389565537e-9, 8983055097726239e-21, -.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 10260144.86], [-3.030883460898826e-8, 898305509983578e-20, .30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908, -3.29883767235584, .32710905363475, 6856817.37], [-1.981981304930552e-8, 8983055099779535e-21, .03278182852591, 40.31678527705744, .65659298677277, -4.44255534477492, .85341911805263, .12923347998204, -.04625736007561, 4482777.06], [3.09191371068437e-9, 8983055096812155e-21, 6995724062e-14, 23.10934304144901, -.00023663490511, -.6321817810242, -.00663494467273, .03430082397953, -.00466043876332, 2555164.4], [2.890871144776878e-9, 8983055095805407e-21, -3.068298e-8, 7.47137025468032, -353937994e-14, -.02145144861037, -1234426596e-14, .00010322952773, -323890364e-14, 826088.5]]
      , We = [[-.0015702102444, 111320.7020616939, 0x60e374c3105a3, -0x24bb4115e2e164, 0x5cc55543bb0ae8, -0x7ce070193f3784, 0x5e7ca61ddf8150, -0x261a578d8b24d0, 0x665d60f3742ca, 82.5], [.0008277824516172526, 111320.7020463578, 647795574.6671607, -4082003173.641316, 10774905663.51142, -15171875531.51559, 12053065338.62167, -5124939663.577472, 913311935.9512032, 67.5], [.00337398766765, 111320.7020202162, 4481351.045890365, -23393751.19931662, 79682215.47186455, -115964993.2797253, 97236711.15602145, -43661946.33752821, 8477230.501135234, 52.5], [.00220636496208, 111320.7020209128, 51751.86112841131, 3796837.749470245, 992013.7397791013, -1221952.21711287, 1340652.697009075, -620943.6990984312, 144416.9293806241, 37.5], [-.0003441963504368392, 111320.7020576856, 278.2353980772752, 2485758.690035394, 6070.750963243378, 54821.18345352118, 9540.606633304236, -2710.55326746645, 1405.483844121726, 22.5], [-.0003218135878613132, 111320.7020701615, .00369383431289, 823725.6402795718, .46104986909093, 2351.343141331292, 1.58060784298199, 8.77738589078284, .37238884252424, 7.45]];
    var Ge = class {
        constructor() {
            this.isWgs84 = !1
        }
        getDistanceByMC(t, e) {
            if (!t || !e)
                return 0;
            if (!(t = this.convertMC2LL(t)))
                return 0;
            const n = this.toRadians(t.lng)
              , r = this.toRadians(t.lat);
            if (!(e = this.convertMC2LL(e)))
                return 0;
            const a = this.toRadians(e.lng)
              , i = this.toRadians(e.lat);
            return this.getDistance(n, a, r, i)
        }
        getDistanceByLL(t, e) {
            if (!t || !e)
                return 0;
            t.lng = this.getLoop(t.lng, -180, 180),
            t.lat = this.getRange(t.lat, -74, 74),
            e.lng = this.getLoop(e.lng, -180, 180),
            e.lat = this.getRange(e.lat, -74, 74);
            const n = this.toRadians(t.lng)
              , r = this.toRadians(t.lat)
              , a = this.toRadians(e.lng)
              , i = this.toRadians(e.lat);
            return this.getDistance(n, a, r, i)
        }
        convertMC2LL(t) {
            if (!t)
                return {
                    lng: 0,
                    lat: 0
                };
            let e = {};
            if (this.isWgs84) {
                e.lng = t.lng / 20037508.34 * 180;
                const n = t.lat / 20037508.34 * 180;
                return e.lat = 180 / Math.PI * (2 * Math.atan(Math.exp(n * Math.PI / 180)) - Math.PI / 2),
                {
                    lng: e.lng.toFixed(6),
                    lat: e.lat.toFixed(6)
                }
            }
            Math.abs(t.lng);
            const n = Math.abs(t.lat);
            let r;
            for (let t = 0; t < ze.length; t++)
                if (n >= ze[t]) {
                    r = Ve[t];
                    break
                }
            return {
                lng: (e = this.convertor(t, r)).lng.toFixed(6),
                lat: e.lat.toFixed(6)
            }
        }
        convertLL2MC(t) {
            if (!t)
                return {
                    lng: 0,
                    lat: 0
                };
            if (t.lng > 180 || t.lng < -180 || t.lat > 90 || t.lat < -90)
                return t;
            if (this.isWgs84) {
                const e = {}
                  , n = 6378137;
                e.lng = t.lng * Math.PI / 180 * n;
                const r = t.lat * Math.PI / 180;
                return e.lat = n / 2 * Math.log((1 + Math.sin(r)) / (1 - Math.sin(r))),
                {
                    lng: parseFloat(e.lng.toFixed(2)),
                    lat: parseFloat(e.lat.toFixed(2))
                }
            }
            t.lng = this.getLoop(t.lng, -180, 180),
            t.lat = this.getRange(t.lat, -74, 74),
            t.lng;
            const e = t.lat;
            let n;
            for (let t = 0; t < qe.length; t++)
                if (e >= qe[t]) {
                    n = We[t];
                    break
                }
            if (!n)
                for (let t = 0; t < qe.length; t++)
                    if (e <= -qe[t]) {
                        n = We[t];
                        break
                    }
            const r = this.convertor(t, n);
            return {
                lng: parseFloat(r.lng.toFixed(2)),
                lat: parseFloat(r.lat.toFixed(2))
            }
        }
        convertor(t, e) {
            if (!t || !e)
                return {
                    lng: 0,
                    lat: 0
                };
            let n = e[0] + e[1] * Math.abs(t.lng);
            const r = Math.abs(t.lat) / e[9];
            let a = e[2] + e[3] * r + e[4] * r * r + e[5] * r * r * r + e[6] * r * r * r * r + e[7] * r * r * r * r * r + e[8] * r * r * r * r * r * r;
            return {
                lng: n *= t.lng < 0 ? -1 : 1,
                lat: a *= t.lat < 0 ? -1 : 1
            }
        }
        getDistance(t, e, n, r) {
            return Ne * Math.acos(Math.sin(n) * Math.sin(r) + Math.cos(n) * Math.cos(r) * Math.cos(e - t))
        }
        toRadians(t) {
            return Math.PI * t / 180
        }
        toDegrees(t) {
            return 180 * t / Math.PI
        }
        getRange(t, e, n) {
            return null !== e && (t = Math.max(t, e)),
            null !== n && (t = Math.min(t, n)),
            t
        }
        getLoop(t, e, n) {
            for (; t > n; )
                t -= n - e;
            for (; t < e; )
                t += n - e;
            return t
        }
        lngLatToMercator(t) {
            return this.convertLL2MC(t)
        }
        lngLatToPoint(t) {
            const e = this.convertLL2MC(t);
            return {
                x: e.lng,
                y: e.lat
            }
        }
        mercatorToLngLat(t) {
            return this.convertMC2LL(t)
        }
        pointToLngLat(t) {
            const e = {
                lng: t.x,
                lat: t.y
            };
            return this.convertMC2LL(e)
        }
        pointToPixel(t, e, n, r) {
            if (!t)
                return {
                    x: 0,
                    y: 0
                };
            t = this.lngLatToMercator(t);
            const a = this.getZoomUnits(e);
            return {
                x: Math.round((t.lng - n.lng) / a + r.width / 2),
                y: Math.round((n.lat - t.lat) / a + r.height / 2)
            }
        }
        pixelToPoint(t, e, n, r) {
            if (!t)
                return {
                    lng: 0,
                    lat: 0
                };
            const a = this.getZoomUnits(e)
              , i = {
                lng: n.lng + a * (t.x - r.width / 2),
                lat: n.lat - a * (t.y - r.height / 2)
            };
            return this.mercatorToLngLat(i)
        }
        getZoomUnits(t) {
            return Math.pow(2, 18 - t)
        }
    }
    ;
    var Ye = class extends Cesium.WebMercatorTilingScheme {
        constructor(t) {
            super(t);
            const e = new Ge;
            this._projection.project = function(t, n) {
                return (n = [Cesium.Math.toDegrees(t.longitude), Cesium.Math.toDegrees(t.latitude)])[0] = Math.min(n[0], 180),
                n[0] = Math.max(n[0], -180),
                n[1] = Math.min(n[1], 74.000022),
                n[1] = Math.max(n[1], -71.988531),
                n = e.lngLatToPoint({
                    lng: n[0],
                    lat: n[1]
                }),
                new Cesium.Cartesian2(n.x,n.y)
            }
            ,
            this._projection.unproject = function(t, n) {
                return n = n || {},
                n = e.mercatorToLngLat({
                    lng: t.x,
                    lat: t.y
                }),
                new Cesium.Cartographic(Cesium.Math.toRadians(n.lng),Cesium.Math.toRadians(n.lat))
            }
            ,
            this.resolutions = t.resolutions || []
        }
        tileXYToNativeRectangle(t, e, n, r) {
            const a = this.resolutions[n]
              , i = t * a
              , o = (t + 1) * a
              , s = (1 + (e = -e)) * a
              , l = e * a;
            return Cesium.defined(r) ? (r.west = i,
            r.south = l,
            r.east = o,
            r.north = s,
            r) : new Cesium.Rectangle(i,l,o,s)
        }
        positionToTileXY(t, e, n) {
            const r = this._rectangle;
            if (!Cesium.Rectangle.contains(r, t))
                return;
            const a = this._projection.project(t);
            if (!Cesium.defined(a))
                return;
            const i = this.resolutions[e]
              , o = Math.floor(a.x / i)
              , s = -Math.floor(a.y / i);
            return Cesium.defined(n) ? (n.x = o,
            n.y = s,
            n) : new Cesium.Cartesian2(o,s)
        }
    }
    ;
    var Ke = class extends Cesium.GeographicTilingScheme {
        constructor(t) {
            super(t);
            const e = THING.Utils.parseValue(t, {});
            this._ellipsoid = THING.Utils.parseValue(e.ellipsoid, Cesium.Ellipsoid.WGS84_Cesium),
            this._numberOfLevelZeroTilesX = THING.Utils.parseValue(e.numberOfLevelZeroTilesX, 1),
            this._numberOfLevelZeroTilesY = THING.Utils.parseValue(e.numberOfLevelZeroTilesY, 1),
            this._tileInfo = THING.Utils.parseValue(e.tileInfo, {
                rows: 256,
                cols: 256,
                lods: [{
                    level: 0,
                    resolution: 1.406250026231578
                }, {
                    level: 1,
                    resolution: .703125013115789
                }, {
                    level: 2,
                    resolution: .3515625065578945
                }, {
                    level: 3,
                    resolution: .17578125327894775
                }, {
                    level: 4,
                    resolution: .08789062663947399
                }, {
                    level: 5,
                    resolution: .043945313319736994
                }, {
                    level: 6,
                    resolution: .021972656659868472
                }, {
                    level: 7,
                    resolution: .010986328329934226
                }, {
                    level: 8,
                    resolution: .005493164164967124
                }, {
                    level: 9,
                    resolution: .0027465820824835504
                }, {
                    level: 10,
                    resolution: .0013732910412417797
                }, {
                    level: 11,
                    resolution: .0006866455206208899
                }, {
                    level: 12,
                    resolution: .0003433227603104438
                }, {
                    level: 13,
                    resolution: .0001716613801552219
                }, {
                    level: 14,
                    resolution: 8583069007761132e-20
                }, {
                    level: 15,
                    resolution: 4291534503880566e-20
                }, {
                    level: 16,
                    resolution: 21457672519402802e-21
                }, {
                    level: 17,
                    resolution: 10728836259701401e-21
                }, {
                    level: 18,
                    resolution: 5364418129850712e-21
                }, {
                    level: 19,
                    resolution: 2682209064925356e-21
                }, {
                    level: 20,
                    resolution: 1341104532462678e-21
                }, {
                    level: 21,
                    resolution: 6.70552266231339e-7
                }, {
                    level: 22,
                    resolution: 3.352761331156695e-7
                }, {
                    level: 23,
                    resolution: 1.6763806655783476e-7
                }]
            })
        }
        getNumberOfXTilesAtLevel(t) {
            if (this._tileInfo && this._tileInfo.lods) {
                var e = this._tileInfo.lods.filter(function(e) {
                    return e.level === t
                })[0].resolution;
                return Math.round(Cesium.Math.toDegrees(Cesium.Math.TWO_PI) / (this._tileInfo.rows * e))
            }
            return super.getNumberOfXTilesAtLevel(t)
        }
        getNumberOfYTilesAtLevel(t) {
            if (this._tileInfo && this._tileInfo.lods) {
                var e = this._tileInfo.lods.filter(function(e) {
                    return e.level === t
                })[0].resolution;
                return Math.round(Cesium.Math.toDegrees(Cesium.Math.TWO_PI / 2) / (this._tileInfo.cols * e))
            }
            return super.getNumberOfYTilesAtLevel(t)
        }
    }
      , $e = new Cesium.Cartesian3
      , Xe = new Cesium.Cartesian3
      , Je = new Cesium.Cartesian3
      , Qe = new Cesium.Cartesian3;
    function Ze(t, e, n) {
        n = Cesium.Cartesian3.cross(t, e, n);
        var r = Cesium.Cartesian3.magnitude(n);
        return Cesium.Cartesian3.multiplyByScalar(n, Cesium.Math.EPSILON7 / r, n)
    }
    function tn(t, e) {
        var n = Cesium.Cartesian3.normalize(t, Qe);
        return Ze(t, Cesium.Cartesian3.equalsEpsilon(n, Cesium.Cartesian3.UNIT_X, Cesium.Math.EPSILON6) ? Cesium.Cartesian3.UNIT_Y : Cesium.Cartesian3.UNIT_X, e)
    }
    var en = function(t) {
        var e = Cesium.Matrix3.getColumn(t, 0, $e)
          , n = Cesium.Matrix3.getColumn(t, 1, Xe)
          , r = Cesium.Matrix3.getColumn(t, 2, Je)
          , a = Cesium.Cartesian3.equals(e, Cesium.Cartesian3.ZERO)
          , i = Cesium.Cartesian3.equals(n, Cesium.Cartesian3.ZERO)
          , o = Cesium.Cartesian3.equals(r, Cesium.Cartesian3.ZERO);
        return a || i || o ? a && i && o ? (t[0] = Cesium.Math.EPSILON7,
        t[4] = Cesium.Math.EPSILON7,
        t[8] = Cesium.Math.EPSILON7,
        t) : (!a || i || o ? a || !i || o ? a || i || !o ? a ? i ? o || (n = Ze(r, e = tn(r, e), n)) : r = Ze(n, e = tn(n, e), r) : r = Ze(n = tn(e, n), e, r) : r = Ze(n, e, r) : n = Ze(e, r, n) : e = Ze(n, r, e),
        Cesium.Matrix3.setColumn(t, 0, e, t),
        Cesium.Matrix3.setColumn(t, 1, n, t),
        Cesium.Matrix3.setColumn(t, 2, r, t),
        t) : t
    }
      , nn = (n(6),
    new THREE.MeshBasicMaterial);
    nn.transparent = !0,
    nn.opacity = 0;
    class rn extends THING.BaseObject {
        constructor(t) {
            super(t),
            this.app = t
        }
        setup(t) {
            this._meshes = null,
            this._materials = null,
            this._enableObjectification = THING.Utils.parseValue(t.enableObjectification, !1),
            this._lights = THING.Utils.parseValue(t.lights, !1),
            this._objectKey = THING.Utils.parseValue(t.objectKey, "name"),
            this._3dtilesFeaturesPropertyCache = new Map,
            this.layerType = "Tile3dLayer",
            this.name = t.name || "tile3dLayer_" + (new Date).getTime(),
            this.renderer = t.renderer || t.style || {},
            this._clippingArea = t.clippingArea,
            this.renderer.grayFilterColorBar && (this.renderer.grayFilterColorBar = this.renderer.grayFilterColorBar.map(function(t) {
                return CMAP.Util.colorFormatNewToOld(t)
            })),
            this._opacity = THING.Utils.parseValue(this.renderer.opacity, 1),
            this._immediatelyLoadDesiredLevelOfDetail = THING.Utils.parseValue(this.immediatelyLoadDesiredLevelOfDetail, !1),
            this._skipLevelOfDetail = THING.Utils.parseValue(this.skipLevelOfDetail, !0),
            Object.defineProperty(this.renderer, "opacity", {
                configurable: !0,
                enumerable: !0,
                get: ()=>this._opacity,
                set: t=>{
                    this.opacity = t
                }
            }),
            this._tilesetRootPosition = null,
            this._quad3dTileNames = {},
            this._all3dTiles = new Map,
            this._3dTilesPerFrame = new Map,
            this._quad3dTileMatrial = {},
            this._recorder3d = L.recorder(),
            this._recorder3dFlag = 0,
            this._last3dTiles = [],
            this._drawEnd = !1,
            this._currentLoadedTiles = [],
            this._lastLoadedTiles = [],
            this._isLastStateChange = !1,
            this._lastChangeTiles = [],
            this._currentShownTiles = {},
            this.root3d = this.node,
            this.visible = THING.Utils.parseValue(t.visible, !0),
            this._3dtileseturl = t.url,
            this._3dtileset = new Cesium.Cesium3DTileset({
                url: this._3dtileseturl,
                skipLevelOfDetail: this._skipLevelOfDetail,
                immediatelyLoadDesiredLevelOfDetail: this._immediatelyLoadDesiredLevelOfDetail,
                geometricErrorFactor: THING.Utils.parseValue(t.geometricErrorFactor, 1)
            }),
            this._3dtileset._layer = this,
            this._3dtileset.height = 0,
            isNaN(t.height || t.offsetHeight) || (this._3dtileset.height = t.height || t.offsetHeight || 0),
            Array.isArray(t.centerCoordinates) && 2 === t.centerCoordinates.length && (this._centerCoordinates = this._3dtileset.centerCoordinates = t.centerCoordinates),
            this.setupUserData(t),
            this._3dtileset.total3dTileNumber = 0,
            this._3dtileset.maximumMemoryUsage = THING.Utils.parseValue(t.maximumMemoryUsage, 128),
            this._3dtileset.maximum3dTileNumber = THING.Utils.parseValue(t.maximum3dTileNumber, 1e5),
            this._3dtileset.readyPromise.then(()=>{
                this._oldCenter = this._3dtileset.boundingSphere.center.clone(),
                this._centerCoordinates || (this._centerCoordinates = this._getCenterCoordinates()),
                this._updateTile3DLayer(this._centerCoordinates),
                this.setupComplete(t)
            }
            ),
            this._3dtileset.tileUnload.addEventListener(t=>{
                if (this._enableObjectification) {
                    let e, n;
                    t.content instanceof Cesium.Composite3DTileContent ? n = (e = t.content._contents).length : (e = [t.content],
                    n = 1);
                    for (let t = 0; t < n; t++) {
                        let n = e[t];
                        const r = n.featuresLength
                          , a = n.batchTable;
                        if (r)
                            for (let t = 0; t < r; t++) {
                                const e = n.getFeature(t)
                                  , r = e._batchId
                                  , i = a.getProperty(r, this._objectKey);
                                if (this._featureElementsMap.has(i)) {
                                    const t = this._featureElementsMap.get(i)
                                      , n = t.indexOf(e);
                                    n > -1 && t.splice(n, 1)
                                }
                                if (e.pickIdBufferObjectCache) {
                                    const t = CMAP.getCurrentMap().pick3DTilesFeatureIdBuffer.indexOf(e.pickIdBufferObjectCache);
                                    t > -1 && CMAP.getCurrentMap().pick3DTilesFeatureIdBuffer.splice(t, 1)
                                }
                            }
                    }
                }
                this._all3dTiles && this._all3dTiles.get(t._thingjsName) && this._all3dTiles.get(t._thingjsName),
                this._quad3dTileNames && this._quad3dTileNames[t._thingjsName] && delete this._quad3dTileNames[t._thingjsName],
                this._quadTileRelativePos && this._quadTileRelativePos[t._thingjsName] && delete this._quadTileRelativePos[t._thingjsName]
            }
            ),
            this._3dtileset.tileLoad.addEventListener(t=>{
                if (this._enableObjectification) {
                    let e, n;
                    this._featureElementsMap || (this._featureElementsMap = new Map),
                    t.content instanceof Cesium.Composite3DTileContent ? n = (e = t.content._contents).length : (e = [t.content],
                    n = 1);
                    for (let t = 0; t < n; t++) {
                        let n = e[t];
                        const r = n.featuresLength
                          , a = n.batchTable;
                        if (r)
                            for (let t = 0; t < r; t++) {
                                const e = n.getFeature(t)
                                  , r = e._batchId
                                  , i = a.getProperty(r, this._objectKey);
                                if (this._featureElementsMap.has(i)) {
                                    const t = this._featureElementsMap.get(i);
                                    -1 === t.indexOf(e) && t.push(e)
                                } else
                                    this._featureElementsMap.set(i, [e])
                            }
                    }
                }
            }
            )
        }
        get visible() {
            return this._visible
        }
        set visible(t) {
            this.show(t),
            this._visible = t
        }
        removeGrayFilter() {
            this.renderer.grayFilterEnable = !1,
            this._all3dTiles.forEach((t,e)=>{
                var n = e + "_mat"
                  , r = t3djs.buffer.materialBuffer.get(n);
                r.colorMapping = void 0,
                r.color = new THREE.Color(1,1,1),
                r.needsUpdate = !0
            }
            )
        }
        setGrayFilter() {
            this._all3dTiles.forEach((t,e)=>{
                var n = e + "_mat"
                  , r = t3djs.buffer.materialBuffer.get(n);
                if (this.renderer && this.renderer.grayFilterEnable && this.renderer.grayFilterColorBar && this.renderer.grayFilterPerBar) {
                    var a = CMAP.Util._generateGradientTextureByGray(this.renderer.grayFilterPerBar, this.renderer.grayFilterColorBar);
                    r.colorMapping = a
                }
                this.renderer && this.renderer.color && (r.color = new THREE.Color(this.renderer.color[0] / 255,this.renderer.color[1] / 255,this.renderer.color[2] / 255)),
                r.needsUpdate = !0
            }
            )
        }
        get offsetHeight() {
            return this._3dtileset.height
        }
        set offsetHeight(t) {
            isNaN(t) || (this._3dtileset.height = t,
            this._updateTile3DLayer(this.centerCoordinates))
        }
        get centerCoordinates() {
            return this._centerCoordinates
        }
        set centerCoordinates(t) {
            this._centerCoordinates = t,
            this._updateTile3DLayer(t)
        }
        set opacity(t) {
            this._opacity = t;
            var e = this._quad3dTileNames;
            for (var n in e) {
                var r = t3djs.buffer.nodeBuffer.get(n);
                r && r.getMaterials().forEach(e=>{
                    "TRANSPARENT" === e.alphaMode || t < 1 ? e.transparent = !0 : e.transparent = !1,
                    e.opacity = t
                }
                )
            }
        }
        _getCenterCoordinates() {
            let t = this._oldCenter.convertToSpherical();
            return r.a.convertWorldToLonlat([-t.x, t.z, t.y])
        }
        _updateTile3DLayer(t) {
            t || (t = this._getCenterCoordinates());
            let e = this._3dtileset
              , n = this._oldCenter.convertToSpherical();
            const a = this._3dtileset.boundingSphere.center.clone()
              , i = r.a.convertWorldToLonlat([-n.x, n.z, n.y])[2] + this.offsetHeight;
            let o = r.a.convertLonlatToWorld(t, i)
              , s = Cesium.Cartesian3.fromArray([-o[0], o[2], o[1]]);
            const l = Cesium.Cartesian3.subtract(s, this._oldCenter, new Cesium.Cartesian3);
            e.modelMatrix = Cesium.Matrix4.fromTranslation(l);
            const u = Cesium.Cartesian3.subtract(s, a, new Cesium.Cartesian3);
            var c = this._quad3dTileNames;
            for (var h in c) {
                var d = t3djs.buffer.nodeBuffer.get(h);
                if (d) {
                    const t = [d.position.x - u.x, d.position.y + u.z, d.position.z + u.y];
                    d.setPosition(new THREE.Vector3(t[0],t[1],t[2]))
                }
            }
        }
        show(t) {
            this.root3d.visible = t
        }
        draw3dTiles(t) {
            let e = this.isContinue3d(t);
            if ("break" !== e && "continue" !== e) {
                this._3dTilesPerFrame ? this._3dTilesPerFrame.clear() : this._3dTilesPerFrame = new Map;
                for (let e = 0; e < t.length; e++) {
                    let n = t[e];
                    if (!Cesium.defined(n))
                        continue;
                    let r = this.tile3dNameCreater("tile3dset_" + this._queryID, n);
                    if (n._thingjsName = r,
                    n._content)
                        if (n.content instanceof Cesium.Composite3DTileContent)
                            this.tileContentGlobeManager(n),
                            n.content && n.content._contents.length > 0 && n.content._contents.forEach((t,e)=>{
                                let n = r + "_" + e;
                                t instanceof Cesium.Batched3DModel3DTileContent ? t._model._thingjsName = n : t instanceof Cesium.Instanced3DModel3DTileContent && (t._modelInstanceCollection._model._thingjsName = n),
                                this._3dTilesPerFrame.set(n, t._model ? t : t._modelInstanceCollection);
                                let a = n + "_mat";
                                this.is3dNeedUpdate(n) && (this._all3dTiles.set(n, t._model ? t : t._modelInstanceCollection),
                                this._quad3dTileNames[n] = n,
                                t instanceof Cesium.Batched3DModel3DTileContent ? this.create3dTileObject({
                                    _content: t
                                }, n, a) : t instanceof Cesium.Instanced3DModel3DTileContent && (t._modelInstanceCollection._instancedCOntent_ = t,
                                this.create3dTileObject({
                                    _content: t._modelInstanceCollection
                                }, n, a)))
                            }
                            );
                        else {
                            n.content instanceof Cesium.Batched3DModel3DTileContent ? (n._content._model._thingjsName = r,
                            this.tileContentGlobeManager(n)) : n._content instanceof Cesium.Instanced3DModel3DTileContent && (n._content._modelInstanceCollection._model._thingjsName = r,
                            this.tileContentGlobeManager(n)),
                            this._3dTilesPerFrame.set(r, n);
                            let t = r + "_mat";
                            if (this.is3dNeedUpdate(r))
                                if (this._all3dTiles.set(r, n),
                                this._quad3dTileNames[r] = r,
                                n.content instanceof Cesium.Batched3DModel3DTileContent)
                                    this.create3dTileObject(n, r, t);
                                else {
                                    if (!(n._content instanceof Cesium.Instanced3DModel3DTileContent))
                                        return;
                                    n._content._modelInstanceCollection._instancedCOntent_ = n._content,
                                    this.create3dTileObject({
                                        _content: n._content._modelInstanceCollection
                                    }, r, t)
                                }
                        }
                }
                this._all3dTiles.forEach(t=>{
                    let e = window.t3djs.buffer.nodeBuffer.get(t._thingjsName);
                    e && (this._3dTilesPerFrame.get(t._thingjsName) ? (e.visible = !0,
                    e.needShow = !0) : (e.visible = !1,
                    e.needShow = !1))
                }
                )
            }
        }
        tileContentGlobeManager(t) {
            if (this._enableObjectification) {
                const e = t.content;
                if (!t._globeFeatureIdStart && (e instanceof Cesium.Batched3DModel3DTileContent || e instanceof Cesium.Instanced3DModel3DTileContent || e instanceof Cesium.Composite3DTileContent)) {
                    let n = 0;
                    if (t._globeFeatureIdStart = CMAP.getCurrentMap().pick3DTilesFeatureIdCurrentValue + 1,
                    e instanceof Cesium.Batched3DModel3DTileContent || e instanceof Cesium.Instanced3DModel3DTileContent)
                        n = e.featuresLength;
                    else if (e instanceof Cesium.Composite3DTileContent) {
                        const t = e._contents;
                        let r = 0;
                        t.forEach((t,e)=>{
                            t instanceof Cesium.Batched3DModel3DTileContent ? r += t.featuresLength : t instanceof Cesium.Instanced3DModel3DTileContent && (r += t.featuresLength)
                        }
                        ),
                        n = r
                    }
                    CMAP.getCurrentMap().pick3DTilesFeatureIdCurrentValue += n
                }
                if (e instanceof Cesium.Batched3DModel3DTileContent || e instanceof Cesium.Instanced3DModel3DTileContent)
                    e._globeFeatureIds = {
                        start: t._globeFeatureIdStart,
                        count: e.featuresLength
                    };
                else if (e instanceof Cesium.Composite3DTileContent) {
                    const n = e._contents;
                    let r = 0;
                    n.forEach((e,n)=>{
                        e instanceof Cesium.Batched3DModel3DTileContent ? (e._globeFeatureIds = {
                            start: t._globeFeatureIdStart + r,
                            count: e.featuresLength
                        },
                        r += e.featuresLength) : e instanceof Cesium.Instanced3DModel3DTileContent && (e._globeFeatureIds = {
                            start: t._globeFeatureIdStart + r,
                            count: e.featuresLength
                        },
                        r += e.featuresLength)
                    }
                    )
                }
            }
        }
        callAfterRenderFunctions(t) {
            for (var e = t.afterRender, n = 0, r = e.length; n < r; ++n)
                e[n]();
            e.length = 0
        }
        flyToLayer() {
            var t = this._3dtileset.boundingSphere
              , e = {
                center: [-t.center.x, t.center.z, t.center.y],
                radius: t.radius
            };
            this.app.camera.flyToBoundingSphere(e)
        }
        isContinue3d(t) {
            if (0 === t.length)
                return "break";
            var e = this.getTilesFlag(t);
            return this._recorder3dFlag === e ? "continue" : (this._recorder3dFlag = e,
            "change")
        }
        convertCesiumToThreeMatrix(t, e, n) {
            const r = (new THREE.Matrix4).set(-1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1);
            n && (e[12] += n.x,
            e[13] += n.y,
            e[14] += n.z);
            const a = (new THREE.Matrix4).fromArray(Cesium.Matrix4.toArray(e));
            return a.premultiply(r),
            t.copy(a),
            t
        }
        create3dTileObject(t, e) {
            let n = t._content._model._rendererResources.vertexArrays;
            this._meshes = t._content._model._rendererResources.meshes,
            this._materials = t._content._model._rendererResources.materials;
            var r = t._content._model._rendererResources.image
              , a = [];
            if (window.t3djs.buffer.nodeBuffer.get(e))
                this.cache3dShow(e);
            else {
                var i = new THREE.Group;
                if (i.name = e,
                t._content instanceof Cesium.ModelInstanceCollection) {
                    const e = t._content._rtcTransform
                      , n = new THREE.Matrix4;
                    this.convertCesiumToThreeMatrix(n, e),
                    i.applyMatrix4(n)
                } else if (t._content._model._rtcCenter) {
                    const e = t._content._model._rtcCenter
                      , n = new THREE.Vector3(e.x,e.y,e.z);
                    if (t._content._model._computedModelMatrix) {
                        const e = Cesium.Matrix4.multiplyTransformation(t._content._model._computedModelMatrix, t._content._model._runtime.nodes[0].transformToRoot, new Cesium.Matrix4)
                          , r = new THREE.Matrix4;
                        this.convertCesiumToThreeMatrix(r, e, n),
                        i.applyMatrix4(r)
                    } else
                        i.position.copy(n)
                } else if (t._content._model._computedModelMatrix) {
                    const e = Cesium.Matrix4.multiplyTransformation(t._content._model._computedModelMatrix, t._content._model._runtime.nodes[0].transformToRoot, new Cesium.Matrix4)
                      , n = new THREE.Matrix4;
                    this.convertCesiumToThreeMatrix(n, e),
                    i.applyMatrix4(n)
                }
                i._tile = t;
                for (let e in n) {
                    let r;
                    r = t._content instanceof Cesium.ModelInstanceCollection ? new THREE.InstancedBufferGeometry : new THREE.BufferGeometry;
                    let i = n[e]
                      , o = i.indexBuffer;
                    this.setIndexDataFromAttribute(o, r);
                    let s = i._attributes;
                    this.setDataFromAttributes(s, r),
                    r.indexName = e,
                    a.push(r)
                }
                t._content instanceof Cesium.ModelInstanceCollection ? this.create3dTileMesh(r, e, i, a, this._meshes, this._materials, this.renderer, t._content) : this.create3dTileMesh(r, e, i, a, this._meshes, this._materials, this.renderer),
                this.root3d.add(i),
                window.t3djs.buffer.nodeBuffer.add(e, i),
                t._content._model._rendererResources.buffers = null,
                t._content._model._rendererResources.image = null,
                this._3dtileset.total3dTileNumber++
            }
        }
        is3dNeedUpdate(t) {
            return !window.t3djs.buffer.nodeBuffer.get(t) || this._quad3dTileNames[t] !== t || (this.cache3dShow(t),
            !1)
        }
        getClosedTile(t, e) {
            for (let n = 0; n < t.length; n++) {
                let r = t[n];
                if (e.indexOf(r) < 0)
                    if (this._3dtileset.total3dTileNumber > this._3dtileset.maximum3dTileNumber) {
                        this.cache3dDestroy(this, r),
                        delete this._currentShownTiles[r],
                        delete this._quad3dTileNames[r];
                        let t = r + "_mat";
                        window.t3djs.materialManager.destroyMaterial(t),
                        delete this._quad3dTileMatrial[t]
                    } else
                        this.cache3dHide(r),
                        delete this._currentShownTiles[r]
            }
        }
        cache3dDestroy(t) {
            var e = window.t3djs.buffer.nodeBuffer.get(t);
            if (e) {
                var n = e.getChildrenNum();
                e.needShow = !1,
                e.destroy(!0, !1),
                window.t3djs.sceneManager.destroyManualObject(t),
                window.t3djs.materialManager.destroyMaterial(t + "_mat"),
                window.t3djs.textureManager.destroyTexture(t + "_tex"),
                this._3dtileset.total3dTileNumber -= n
            }
        }
        setIndexDataFromAttribute(t, e) {
            let n = t.count;
            var r = t.buffer.indexDatatype
              , a = THING.Utils.parseValue(t.offsetInBytes, 0);
            let i;
            if (5125 === r)
                if (t.buffer.typedArray instanceof Uint32Array)
                    i = t.buffer.typedArray;
                else {
                    let e = new Uint8Array(t.buffer.typedArray);
                    i = new Uint32Array(e.buffer,a,n)
                }
            else if (5123 === r)
                if (t.decodedData)
                    i = new Uint16Array(t.buffer.typedArray);
                else {
                    i = new Uint16Array(n);
                    for (let e = 0; e < 2 * n; e++)
                        i[e] = t.buffer.typedArray[2 * e] | t.buffer.typedArray[2 * e + 1] << 8
                }
            var o = new THREE.BufferAttribute(i,1);
            e.setIndex(o),
            o = null
        }
        setDataFromAttributes(t, e) {
            let n, r;
            for (let h in t) {
                let d = t[h];
                var a, i = d.count, o = THING.Utils.parseValue(d.offsetInBytes, 0), s = d.strideInBytes, l = d.componentDatatype, u = d.componentsPerAttribute, c = this._parseAttributeName(d.attribute);
                if (5126 === l) {
                    let t = new Uint8Array(d.vertexBuffer);
                    if (5 === (s /= Float32Array.BYTES_PER_ELEMENT) || 6 === s || 7 === s || 8 === s || 9 === s)
                        o /= Float32Array.BYTES_PER_ELEMENT,
                        n || (n = new Float32Array(t.buffer),
                        r = new THREE.InterleavedBuffer(n,s)),
                        a = new THREE.InterleavedBufferAttribute(r,u,o,!1);
                    else {
                        let e;
                        e = d.vertexBuffer instanceof Float32Array ? d.vertexBuffer : new Float32Array(t.buffer,o,i * u),
                        a = new THREE.BufferAttribute(e,u)
                    }
                    e.addAttribute(c, a)
                } else if (5123 === l) {
                    let t;
                    if ("POSITION" === d.attribute) {
                        t = new Float32Array(d.vertexBuffer.length);
                        const e = d.quantization.range / (1 << d.quantization.quantizationBits)
                          , n = d.quantization.minValues;
                        for (let r = 0; r < d.vertexBuffer.length; r++)
                            t[r] = d.vertexBuffer[r] * e + n[0],
                            t[r + 1] = d.vertexBuffer[r + 1] * e + n[1],
                            t[r + 2] = d.vertexBuffer[r + 2] * e + n[2],
                            r += 2
                    } else if ("uv" === c) {
                        const e = d.quantization.range / (1 << d.quantization.quantizationBits)
                          , n = d.quantization.minValues;
                        t = new Float32Array(d.vertexBuffer.length);
                        for (let r = 0; r < d.vertexBuffer.length; r++)
                            t[r] = d.vertexBuffer[r] * e + n[0],
                            t[r + 1] = d.vertexBuffer[r + 1] * e + n[1],
                            r += 1
                    }
                    a = new THREE.BufferAttribute(t,u),
                    e.addAttribute(c, a)
                }
            }
            a = null,
            r = null
        }
        addClippingPlanes(t) {
            Array.isArray(t[0][0]) && (t = t[0]),
            M.a.isClockWise(t) && (t = t.reverse());
            var e = [];
            for (let n = 0; n < t.length - 1; n++) {
                const r = CMAP.Util.convertLonlatToWorld(t[n])
                  , a = CMAP.Util.convertLonlatToWorld(t[n + 1])
                  , i = CMAP.Util.convertLonlatToWorld([(t[n][0] + t[n + 1][0]) / 2, (t[n][1] + t[n + 1][1]) / 2], 1)
                  , o = (new THREE.Plane).setFromCoplanarPoints(new THREE.Vector3(r[0],r[1],r[2]), new THREE.Vector3(a[0],a[1],a[2]), new THREE.Vector3(i[0],i[1],i[2]));
                e.push(o)
            }
            return e
        }
        updateCustomStyle(t, e, n, r) {
            let a, i, o, s, l, u;
            if (n && (n.pbrMetallicRoughness && n.pbrMetallicRoughness.baseColorFactor && (a = n.pbrMetallicRoughness.baseColorFactor),
            n.pbrMetallicRoughness && n.pbrMetallicRoughness.metallicFactor <= 1 && (i = n.pbrMetallicRoughness.metallicFactor),
            n.pbrMetallicRoughness && n.pbrMetallicRoughness.roughnessFactor <= 1 && (o = n.pbrMetallicRoughness.roughnessFactor),
            n.alphaMode && (s = n.alphaMode),
            n.emissiveFactor && (l = n.emissiveFactor),
            n.doubleSided && (u = n.doubleSided)),
            e && e.grayFilterEnable && e.grayFilterColorBar && e.grayFilterPerBar) {
                let n = CMAP.Util._generateGradientTextureByGray(e.grayFilterPerBar, e.grayFilterColorBar);
                t.colorMapping = n
            }
            e && e.color ? t.color = a ? new THREE.Color(a[0] * (e.color[0] / 255),a[1] * (e.color[1] / 255),a[2] * (e.color[2] / 255)) : new THREE.Color(e.color[0],e.color[1],e.color[2]) : a && (t.color = new THREE.Color(a[0],a[1],a[2])),
            i <= 1 && (t.metalness = i),
            o <= 1 && (t.roughness = o),
            l && (t.emissive = new THREE.Color(l[0],l[1],l[2])),
            "OPAQUE" !== s ? (t.transparent = !0,
            t.alphaMode = "TRANSPARENT") : e.opacity < 1 ? t.transparent = !0 : t.transparent = !1,
            a && (t.opacity = a[3]),
            e && e.opacity < 1 && (t.opacity = e.opacity * t.opacity),
            this._clippingArea && (t.clipIntersection = !0,
            t.clippingPlanes = this.addClippingPlanes(this._clippingArea)),
            t.side = THREE.DoubleSide,
            e && e.envMapUrl && (e.envMapUrl.endsWith("png") || e.envMapUrl.endsWith("jpg") || e.envMapUrl.endsWith("bmp") ? t.envMap = Ut.loadEnvMap(e.envMapUrl) : t.envMap = Ut.loadEnvMapCubeForCampus(e.envMapUrl),
            r && (t.baseQuaternion = r.getWorldQuaternion(new THREE.Quaternion).inverse())),
            e && !THING.Utils.isNull(e.envMapIntensity) && (t.envMapIntensity = e.envMapIntensity),
            t.needsUpdate = !0
        }
        create3dTileMesh(t, e, n, r, a, i, o, s) {
            const l = s && s instanceof Cesium.ModelInstanceCollection
              , u = this._enableObjectification;
            if (t)
                if (1 === t.length) {
                    var c = new THREE.Texture(t[t.length - 1].image);
                    c.wrapS = c.wrapT = THREE.RepeatWrapping,
                    c.needsUpdate = !0;
                    var h, d = e + "_tex", f = e + "_mat";
                    c.name = d,
                    c.matrixAutoUpdate = !1,
                    c.flipY = !1,
                    h = this._lights ? new THREE.MeshStandardMaterial({
                        map: c,
                        name: f
                    }) : new THREE.MeshBasicMaterial({
                        map: c,
                        name: f
                    }),
                    t3djs.buffer.materialBuffer.add(f, h),
                    this.updateCustomStyle(h, o, i[0], n);
                    var p = r.length;
                    if (l && p > 1)
                        return void THING.Utils.warn("I3DM数据不支持多个几何体的情况。");
                    for (let t = 0; t < p; t++) {
                        let a = e + "_" + t;
                        l ? this.createMesh(s, r[t], h, n, a, u) : this.createMesh(void 0, r[t], h, n, a, u),
                        r[t] = null
                    }
                    u && this.createAllFeatureCache(s, n, u)
                } else if (l)
                    THING.Utils.warn("I3DM异常数据！");
                else if (i.length === r.length) {
                    for (let s = 0; s < r.length; s++) {
                        let l = on(a, i, r[s].indexName.substring(r[s].indexName.lastIndexOf(".") + 1))
                          , c = 0;
                        l.values ? c = l.values.u_diffuse.index : l.extensions.KHR_techniques_webgl.values.u_diffuse ? c = l.extensions.KHR_techniques_webgl.values.u_diffuse.index : l.pbrMetallicRoughness && l.pbrMetallicRoughness.baseColorTexture && (c = l.pbrMetallicRoughness.baseColorTexture.index);
                        const h = an(t, c);
                        let d = new THREE.Texture(h.image);
                        d.wrapS = d.wrapT = THREE.RepeatWrapping,
                        d.needsUpdate = !0;
                        let f, p = e + s + "_tex", m = e + s + "_mat";
                        d.name = p,
                        d.matrixAutoUpdate = !1,
                        d.flipY = !1,
                        f = this._lights ? new THREE.MeshStandardMaterial({
                            map: d,
                            name: m
                        }) : new THREE.MeshBasicMaterial({
                            map: d,
                            name: m
                        }),
                        t3djs.buffer.materialBuffer.add(m, f),
                        this.updateCustomStyle(f, o, i[s], n);
                        let g = e + "_" + s;
                        this.createMesh(void 0, r[s], f, n, g, u),
                        r[s] = null
                    }
                    u && this.createAllFeatureCache(s, n, u)
                } else
                    THING.Utils.warn("贴图个数与mesh个数不一致");
            else {
                let t = r.length;
                if (l && t > 1)
                    return void THING.Utils.warn("I3DM数据不支持多个几何体的情况。");
                for (let a = 0; a < t; a++) {
                    let t = e + "_mat"
                      , c = new THREE.MeshStandardMaterial({
                        name: t
                    });
                    t3djs.buffer.materialBuffer.add(t, c),
                    this.updateCustomStyle(c, o, i[a], n);
                    let h = e + "_" + a;
                    l ? this.createMesh(s, r[a], c, n, h, u) : this.createMesh(void 0, r[a], c, n, h, u),
                    r[a] = null
                }
                u && this.createAllFeatureCache(s, n, u)
            }
        }
        updateTileMeshCache(t, e=[255, 255, 255], n=!0) {
            this._3dtilesFeaturesPropertyCache.set(t, e.concat(!0 === n ? 255 : 0))
        }
        updateCompleteTileMesh(t, e, n=!0) {
            if (!this._enableObjectification)
                return;
            const r = this._featureElementsMap.get(t);
            if (r) {
                const t = r.length;
                for (let a = 0; a < t; a++) {
                    const t = r[a]
                      , i = t._group_
                      , o = t._batchId;
                    i && this.update3dTileBatchTableTexture(i, o, e, n)
                }
            }
        }
        update3dTileBatchTableTexture(t, e, n, r=!0) {
            const a = t.children[0].tile._content.featuresLength
              , i = new Uint8Array(4 * a);
            for (let o = 0; o < a; o++)
                e >= 0 && e === o ? (n && 3 === n.length ? (i[4 * o + 0] = n[0],
                i[4 * o + 1] = n[1],
                i[4 * o + 2] = n[2],
                t.featurePropertyCache[o].color = n) : (i[4 * o + 0] = t.featurePropertyCache[o].color[0],
                i[4 * o + 1] = t.featurePropertyCache[o].color[1],
                i[4 * o + 2] = t.featurePropertyCache[o].color[2]),
                r ? (i[4 * o + 3] = 255,
                t.featurePropertyCache[o].show = r) : (i[4 * o + 3] = 0,
                t.featurePropertyCache[o].show = !1)) : (i[4 * o + 0] = t.featurePropertyCache[o].color[0],
                i[4 * o + 1] = t.featurePropertyCache[o].color[1],
                i[4 * o + 2] = t.featurePropertyCache[o].color[2],
                i[4 * o + 3] = t.featurePropertyCache[o].show ? 255 : 0);
            t.children[0].material.batchTexture && t.children[0].material.batchTexture.dispose();
            const o = new THREE.DataTexture(i,a,1);
            t.children.forEach(t=>{
                t.material.batchTexture = o;
                const e = 1 / a
                  , n = .5 * e;
                t.material.batchTextureStep = new THREE.Vector2(e,n),
                t.material.defines || (t.material.defines = {
                    USE_3DTILESEXTENT: !0
                }),
                t.material.defines.USE_3DTILESEXTENT = !0
            }
            )
        }
        createMesh(t, e, n, r, a, i=!1) {
            let o;
            if (t) {
                const r = t._instances.length
                  , a = new THREE.InstancedBufferAttribute(new Float32Array(3 * r),3)
                  , s = new THREE.InstancedBufferAttribute(new Float32Array(4 * r),4)
                  , l = new THREE.InstancedBufferAttribute(new Float32Array(3 * r),3)
                  , u = new THREE.InstancedBufferAttribute(new Float32Array(1 * r),1);
                let c;
                e.addAttribute("instancePosition", a),
                e.addAttribute("instanceQuaternion", s),
                e.addAttribute("instanceScale", l),
                e.addAttribute("instanceId", u),
                i && (c = new THREE.InstancedBufferAttribute(new Float32Array(1 * r),1),
                e.addAttribute("id", c)),
                (o = new THREE.Mesh(e,n)).frustumCulled = !1,
                n.defines || (n.defines = {}),
                n.defines.INSTANCED = "";
                for (let e = 0; e < r; e++) {
                    const n = t._instances[e];
                    let r = Cesium.Matrix4.clone(n._modelMatrix);
                    const h = t._center;
                    r[12] = r[12] - h.x,
                    r[13] = r[13] - h.y,
                    r[14] = r[14] - h.z,
                    r = Cesium.Matrix4.multiplyTransformation(r, t._model._runtime.nodes[0].computedMatrix, new Cesium.Matrix4);
                    let d = new THREE.Matrix4;
                    d.fromArray(Cesium.Matrix4.toArray(r));
                    let f = new THREE.Vector3
                      , p = new THREE.Quaternion
                      , m = new THREE.Vector3;
                    d.decompose(f, p, m),
                    a.set(f.toArray(), 3 * e),
                    s.set(p.toArray(), 4 * e),
                    l.set(m.toArray(), 3 * e),
                    i ? (c && c.set([e], e),
                    u.set([e], e)) : u.set([o.id], e)
                }
            } else
                (o = new THREE.Mesh(e,n)).frustumCulled = !0;
            e.attributes.normal || e.computeVertexNormals(),
            i && (o.tile = t ? {
                _content: t._instancedCOntent_
            } : r._tile,
            n.enableObjectification = !0),
            o.name = a,
            o.userData.skipPick = !this.pickable,
            r.add(o),
            !0 === this.app.root.static && o._synMatrixWorld(),
            t3djs.buffer.nodeBuffer.add({
                meshName: o
            })
        }
        createAllFeatureCache(t, e, n=!1) {
            if (n) {
                let n = e.children[0].tile;
                const r = n._content.featuresLength
                  , a = n._content.batchTable;
                if (r) {
                    const i = n._content._globeFeatureIds.start;
                    e.children.forEach(t=>{
                        t.userData.batchIdOffset = i
                    }
                    );
                    for (let t = 0; t < r; t++) {
                        const r = n._content.getFeature(t);
                        r._group_ = e,
                        r.globalId = t + i,
                        r.pickIdBufferObjectCache = {
                            globalId: t + i,
                            feature: r
                        },
                        CMAP.getCurrentMap().pick3DTilesFeatureIdBuffer.push(r.pickIdBufferObjectCache),
                        CMAP.getCurrentMap().pick3DTilesFeatureIdCurrentValue >= 16581375 && THING.Utils.warn("3DTiles GPUPicker globalId超过界限，可能产生异常现象。");
                        const o = a.getProperty(r._batchId, this._objectKey);
                        if (e.featurePropertyCache || (e.featurePropertyCache = []),
                        this._3dtilesFeaturesPropertyCache.get(o)) {
                            const n = this._3dtilesFeaturesPropertyCache.get(o);
                            e.featurePropertyCache.push({
                                batchId: t,
                                color: [n[0], n[1], n[2]],
                                show: 255 === n[3]
                            })
                        } else
                            e.featurePropertyCache.push({
                                batchId: t,
                                color: [255, 255, 255],
                                show: !0
                            })
                    }
                    e.children.forEach(e=>{
                        e.userData.enableObjectification = !0,
                        e.userData.withGeometryIDAttributes = !t
                    }
                    ),
                    this.update3dTileBatchTableTexture(e)
                }
            }
        }
        _parseAttributeName(t) {
            return "POSITION" === t ? "position" : "TEXCOORD_0" === t ? "uv" : "NORMAL" === t ? "normal" : "_BATCHID" === t ? "id" : void 0
        }
        cache3dShow(t) {
            var e = window.t3djs.buffer.nodeBuffer.get(t);
            e && ("show" !== (e.visible ? "show" : "hide") && (e.visible = !0,
            e.needShow = !0))
        }
        tile3dNameCreater(t, e) {
            return e._contentResource.url
        }
        cache3dHide(t) {
            var e = window.t3djs.buffer.nodeBuffer.get(t);
            e && (e.needShow = !1,
            e.visible = !1)
        }
        getTilesFlag(t) {
            for (var e = 0, n = 0; n < t.length; n++) {
                var r = t[n];
                Cesium.defined(r) && (r.content instanceof Cesium.Batched3DModel3DTileContent ? r.content._model._rendererResources.image && (e += "_" + r.content._model._rendererResources.image.length + "_") : r._content instanceof Cesium.Instanced3DModel3DTileContent ? r.content._modelInstanceCollection && r.content._modelInstanceCollection._model._rendererResources.image && (e += "_" + r.content._modelInstanceCollection._model._rendererResources.image.length + "_") : r.content instanceof Cesium.Composite3DTileContent && r.content._contents.forEach(t=>{
                    t instanceof Cesium.Batched3DModel3DTileContent ? t._model._rendererResources.image && (e += "_" + t._model._rendererResources.image.length + "_") : t instanceof Cesium.Instanced3DModel3DTileContent && t._modelInstanceCollection && t._modelInstanceCollection._model._rendererResources.image && (e += "_" + t._modelInstanceCollection._model._rendererResources.image.length + "_")
                }
                ),
                r._boundingVolume.radius ? e += "_" + r._boundingVolume.radius + "_" : r._boundingVolume._boundingSphere && (e += "_" + r._boundingVolume._boundingSphere.radius + "_"))
            }
            return e
        }
        triggerEvent(t) {
            C.a.add("check3dTileVisible", function() {
                let e = [];
                for (var n in t) {
                    let t = t3djs.buffer.nodeBuffer.get(n);
                    if (t) {
                        for (var r in t.children)
                            if (!1 === t.children[r].visible)
                                return;
                        e = e.concat(t.children)
                    }
                }
                THING.App.current.trigger("draw3dTileEnd", {
                    meshArray: e
                }),
                C.a.delete("check3dTileVisible")
            })
        }
        destroy() {
            super.destroy(),
            this.app.uEarth._earthInstance.tileEarth.removeTile3dLayer(this),
            t3djs.rootNode.remove(this.node);
            for (let t = this.node.children.length - 1; t >= 0; t--) {
                const e = this.node.children[t];
                t3djs.buffer.nodeBuffer.delete(e.name),
                e.dispose(),
                e._tile.destroy();
                for (let t = e.children.length - 1; t >= 0; t--) {
                    e.children[t].dispose()
                }
            }
            t3djs.buffer.entityBuffer.delete(this.name),
            this._quad3dTileNames = null,
            this._all3dTiles = null,
            this._3dTilesPerFrame = null,
            this._quad3dTileMatrial = null,
            this._recorder3d = null,
            this._recorder3dFlag = 0,
            this._last3dTiles = [],
            this._currentLoadedTiles = [],
            this._lastLoadedTiles = [],
            this._lastChangeTiles = [],
            this._currentShownTiles = {}
        }
    }
    function an(t, e) {
        for (let n = 0; n < t.length; n++)
            if (t[n].index === e)
                return t[n];
        return null
    }
    function on(t, e, n) {
        return e[t[0].primitives[n].material]
    }
    THING.factory.registerClass("Tile3dLayer", rn);
    var sn = rn;
    class ln extends P {
        constructor(t) {
            super(t),
            this.app = t,
            this._selector = new THING.Selector(t)
        }
        customSetup(t) {
            super.customSetup(t);
            const e = this;
            this.data = t.dataSource || {
                type: "FeatureCollection",
                features: []
            },
            this.infoWindow = void 0 !== t.infoWindow ? new Xt(this,t.infoWindow) : void 0,
            this.infoWindow && (e.infoWindow._visible = e.visible),
            this._paramLabel = t.label,
            this._label = void 0 !== t.label ? new Jt(this,t.label) : void 0,
            this.name = t.name || "featureLayer_" + r.a.getUUID(),
            this.id = t.id || this.name,
            this._height = t.extrudeHeight || t.height,
            void 0 !== this._height && (this._height = +this._height),
            this._outerDataSource = t.outerDataSource,
            this._joinBy = t.joinBy,
            this._useOutline = t.useOutline,
            this._pickWithGeometryID = void 0 !== t.pickWithGeometryID && t.pickWithGeometryID,
            t.renderer.extrudeField ? this._extrudeField = t.renderer.extrudeField : t.extrudeField ? this._extrudeField = t.extrudeField : this._extrudeField = "",
            t.renderer.extrudeFactor ? this._extrudeFactor = t.renderer.extrudeFactor : t.extrudeFactor ? this._extrudeFactor = t.extrudeFactor : this._extrudeFactor = 1,
            void 0 === t.azimuth && (t.azimuth = t.modelAngle),
            void 0 !== t.pivot && (this._pivot = t.pivot),
            this.azimuth = THING.Utils.parseValue(t.azimuth, 0),
            this.geometryType = t.geometryType;
            let n = !1;
            "GeoBuilding" === this.geometryType && (n = !0),
            this.clampToGround = THING.Utils.parseValue(t.clampToGround, n),
            this.heightArrayField = t.heightArrayField,
            this.heightArrayFactor = THING.Utils.parseValue(t.heightArrayFactor, 1),
            this._renderer = t.renderer || {},
            this._orignRenderer = t.renderer || {},
            this._offsetHeight = t.offsetHeight,
            this._offsetHeightField = t.offsetHeightField,
            this._offsetHeightFactor = THING.Utils.parseValue(t.offsetHeightFactor, 1),
            this._groundHeightField = t.groundHeightField,
            this._groundHeightFactor = THING.Utils.parseValue(t.groundHeightFactor, 1),
            THING.Utils.isNull(this._offsetHeight) && THING.Utils.isNull(this._offsetHeightField) && THING.Utils.isNull(this._groundHeightField) && THING.Utils.isNull(this._offsetHeightAdded) && (this._offsetHeight = 0),
            this._offsetHeightAdded = THING.Utils.parseValue(t.offsetHeightAdded, 0),
            this._useMercatorUV = t.useMercatorUV,
            this._animation = t.animation;
            try {
                this._dataHandler(this.data, this.geometryType, this._orignRenderer, this)
            } catch (e) {
                var a = t.error;
                if (e.object = this,
                a)
                    return a(e, this),
                    !0;
                THING.Utils.error(e),
                setTimeout(()=>{
                    this.trigger("error", e)
                }
                , 0)
            }
            this.renderOrder = THING.Utils.parseValue(t.renderOrder, 0),
            super.add({
                object: t,
                keepNode: !0
            }),
            t.animation && this._playAnimation(this._animation),
            this._orignRenderer.postRadialBlur && this._setPostRadiusEffect(!0),
            this._orignRenderer.postRadialBlur2 && this._setPostRadialBlur2(!0),
            r.a._updateShadowNextFrame()
        }
        _getGeoObjectArray() {
            return this.children
        }
        setupComplete(t) {
            "GeoPoint" === this.geometryType && "model" === this.renderer.type ? (t.customComplete = !0,
            this.on("update", e=>{
                let n = 0;
                this.children.forEach(t=>{
                    (t._obj.loaded || t._obj._loadedError) && n++
                }
                ),
                n === this.children.length && (this.off("update", null, "featureLayerCompleteUpdater_" + this.node.uuid),
                super.setupComplete(t))
            }
            , "featureLayerCompleteUpdater_" + this.node.uuid)) : super.setupComplete(t)
        }
        on() {
            arguments.length < 2 && THING.Utils.log("参数不合法");
            var t = this.geometryType
              , e = null
              , n = 0;
            for (let t = 0; t < arguments.length; t++)
                "function" == typeof arguments[t] && (e = arguments[t],
                n = t);
            if (e) {
                arguments[n] = function(n) {
                    let r = n.mouseOnObject || n.mouseOffObject || n.pickedObj || n.pickedObject;
                    r && ("GeoPoint" === t ? n.object = r.parent : (n.object = r,
                    n._stopPropagation = !0)),
                    e.call(n.object, n)
                }
            }
            this.__canAcceptEvent__ = !0,
            super.on.apply(this, arguments)
        }
        _removeAllInfoWindow() {
            if (this.infoWindow)
                for (let t in this.children)
                    this.children[t].infoWindow.destroy()
        }
        get renderer() {
            return this._renderer
        }
        add(t) {
            t.type === this.geometryType ? (super.add({
                object: t,
                keepNode: !0,
                keepVisible: !1
            }),
            "GeoScene" === t.type ? (t.init(),
            this._layerScene.push(t)) : this._layer.add(t.node)) : THING.Utils.warn("当前FeatureLayer的geometryType为" + this.geometryType + ",不能添加" + t.type)
        }
        remove(t) {
            var e = this.children.indexOf(t);
            e > -1 && this.children.splice(e, 1),
            t.infoWindow && t.infoWindow.destroy(),
            this._layer.remove(t._layer),
            "GeoScene" === t.type && t.destroy()
        }
        removeAll() {
            for (; this.children.length > 0; )
                this.remove(this.children[0])
        }
        updateRenderer(t) {
            for (var e = 0; e < this.children.length; e++) {
                var n = []
                  , a = JSON.parse(JSON.stringify(t))
                  , i = this.children[e]
                  , o = i.userData;
                for (var s in a) {
                    var l = a[s];
                    if (Array.isArray(l))
                        if (l.length > 0 && void 0 !== l[0].condition)
                            for (var u in l) {
                                var c = l[u].condition;
                                if ("" === c && (a[s] = l[u].value),
                                r.a.isObjectMeetCondition(o, c)) {
                                    -1 === n.indexOf(c) && n.push(c),
                                    a[s] = l[u].value;
                                    break
                                }
                            }
                        else
                            a[s] = l;
                    else
                        a[s] = l;
                    this._renderer["_" + s] = l,
                    s.indexOf("color") >= 0 && "useColor" !== s && (this._renderer["_" + s] = CMAP.Util.colorFormatNewToOld(l)),
                    "color" === s ? this._renderer._opacity = this._renderer["_" + s][3] : "lineColor" === s && (this._renderer._lineOpacity = this._renderer["_" + s][3])
                }
                var h = JSON.stringify(n);
                i._conditionStr = h,
                i.updateRenderer(a)
            }
            setTimeout(function() {
                THING.App.current.rendererManager._mainRenderer.dirty()
            }, 0)
        }
        updateFeatureProperty(t, e, n) {
            var a = this
              , i = null;
            a.children.map(function(o) {
                var s = o.userData
                  , l = [];
                if (e.length > 0 && void 0 !== e[0].condition)
                    if (void 0 !== e[0].condition)
                        for (var u in e) {
                            var c = e[u].condition;
                            if ("" === c && (i = e[u].value),
                            r.a.isObjectMeetCondition(s, c)) {
                                -1 === l.indexOf(c) && l.push(c),
                                i = e[u].value;
                                break
                            }
                        }
                    else
                        i = e;
                else
                    i = e;
                var h = JSON.stringify(l);
                o._conditionStr = h,
                "color" !== t && "imageUrl" !== t && "cool" !== t || (o.renderer._type = n,
                o.renderer._imageUrl = "",
                o.renderer._color = []),
                -1 !== a.geometryType.indexOf("Line") && o._checkPartical(),
                o.renderer[t] = i
            }),
            "color" !== t && "imageUrl" !== t || (a.renderer._type = n)
        }
        updateLineWidth(t) {
            this._orignRenderer = t;
            var e = t.width;
            this.updateFeatureProperty("width", e, t.type)
        }
        get label() {
            return this._label
        }
        set label(t) {
            this.children.forEach(function(e) {
                e.label = t
            }),
            this._label = new Jt(this,t)
        }
        _setLabel(t) {
            for (let e = 0; e < this.children.length; e++) {
                let n = this.children[e]
                  , r = this._getValueByCnd(t, n.userData).config;
                n.label = r
            }
            this._label = new Jt(this,t)
        }
        _setOffsetHeightAndAdded(t, e, n) {
            this._offsetHeightField === t && this._offsetHeightAdded === e && this._offsetHeightFactor === n || (this.children.map(function(t) {
                t._offsetHeightAdded = e
            }),
            this._offsetHeightAdded = e,
            this._offsetHeightFactor = n,
            this.offsetHeightField = t)
        }
        _setExtrudeFieldAndFactor(t, e) {
            this._extrudeField === t && this._extrudeFactor === e || (this.children.map(function(t) {
                t._extrudeFactor = e
            }),
            this._extrudeFactor = e,
            this._setExtrudeField(t))
        }
        _setExtrudeFactor(t) {
            this.children.map(function(e) {
                e.extrudeFactor = t
            }),
            this._extrudeFactor = t
        }
        _setExtrudeField(t) {
            this.children.map(function(e) {
                e.extrudeField = t
            }),
            this._extrudeField = t
        }
        get extrudeFactor() {
            return this._extrudeFactor
        }
        get extrudeField() {
            return this._extrudeField
        }
        set extrudeFactor(t) {
            this._extrudeFactor !== t && this._setExtrudeFactor(t)
        }
        set extrudeField(t) {
            this._extrudeField !== t && this._setExtrudeField(t)
        }
        updateExtrude(t) {
            THING.Utils.isNull(t.extrudeHeight) ? THING.Utils.isNull(t.extrudeHeight) || (this.extrudeHeight = t.extrudeHeight,
            this._extrudeField = null) : this._setExtrudeFieldAndFactor(t.extrudeField, t.extrudeFactor)
        }
        updateOffset(t) {
            const e = THING.Utils.parseValue(t.offsetHeightAdded, 0);
            THING.Utils.isNull(t.offsetHeight) ? this._setOffsetHeightAndAdded(t.offsetHeightField, t.offsetHeightAdded, t.offsetHeightFactor) : (this.offsetHeight = t.offsetHeight + e,
            this._offsetHeightField = null)
        }
        updateMat(t) {
            var e;
            this._orignRenderer = t,
            this.renderer.extrudeField = "无" === t.extrudeField ? "" : t.extrudeField,
            this.renderer.extrudeFactor = t.extrudeFactor,
            this.renderer.blending = t.blending,
            "vector" === t.type ? e = "color" : "image" === t.type ? e = "imageUrl" : "cool" === t.type && (e = "cool");
            var n = t[e];
            this.updateFeatureProperty(e, n, t.type)
        }
        _setFocusRegion(t) {
            this.children.map(e=>{
                e._setFocusRegion(t)
            }
            )
        }
        _removeFocusRegion() {
            this.children.map(t=>{
                t._removeFocusRegion()
            }
            )
        }
        get extrudeHeight() {
            return this.height
        }
        set extrudeHeight(t) {
            this.height = t
        }
        get height() {
            return this._height
        }
        set height(t) {
            if ("GeoPoint" === this.geometryType)
                for (let e = 0; e < this.children.length; e++)
                    this.children[e].offsetHeight = t;
            else if ("GeoDiffusion" === this.geometryType || "GeoBoundary" === this.geometryType || "GeoBuilding" === this.geometryType || "GeoPolygon" === this.geometryType)
                for (let e = 0; e < this.children.length; e++)
                    this.children[e].extrudeHeight = t;
            else
                THING.Utils.warn(this.geometryType + "不可设置height属性");
            this._height = t
        }
        set offsetHeightField(t) {
            for (var e = 0; e < this.children.length; e++)
                this.children[e].offsetHeightField = t;
            this._offsetHeightField = t,
            this._offsetHeight = void 0
        }
        get offsetHeightField() {
            return this._offsetHeightField
        }
        set offsetHeightFactor(t) {
            for (var e = 0; e < this.children.length; e++)
                this.children[e].offsetHeightFactor = t;
            this._offsetHeightFactor = t
        }
        get offsetHeightFactor() {
            return this._offsetHeightFactor
        }
        set offsetHeightAdded(t) {
            for (var e = 0; e < this.children.length; e++)
                this.children[e]._offsetHeightAdded = t,
                this.children[e]._arrayOffsetHeight ? this.children[e]._setOffsetHeightFieldAndFactor() : this.children[e].offsetHeightAdded = t;
            this._offsetHeightAdded = t
        }
        get offsetHeightAdded() {
            return this._offsetHeightAdded
        }
        set groundHeightField(t) {
            for (var e = 0; e < this.children.length; e++)
                this.children[e].groundHeightField = t;
            this._groundHeightField = t,
            this._offsetHeight = void 0
        }
        get groundHeightField() {
            return this._groundHeightField
        }
        set groundHeightFactor(t) {
            for (var e = 0; e < this.children.length; e++)
                this.children[e].groundHeightFactor = t;
            this._groundHeightFactor = t
        }
        get groundHeightFactor() {
            return this._groundHeightFactor
        }
        set heightArrayField(t) {
            for (var e = 0; e < this.children.length; e++)
                this.children[e].heightArrayField = t;
            this._heightArrayField = t
        }
        get heightArrayField() {
            return this._heightArrayField
        }
        set heightArrayFactor(t) {
            for (var e = 0; e < this.children.length; e++)
                this.children[e].heightArrayFactor = t;
            this._heightArrayFactor = t
        }
        get heightArrayFactor() {
            return this._heightArrayFactor
        }
        get dataSource() {
            return this.data
        }
        set dataSource(t) {
            this.data = t,
            this.removeAll(),
            this._dataHandler(this.data, this.geometryType, this._orignRenderer, this)
        }
        get visible() {
            return this.node.visible && this._visible
        }
        set visible(t) {
            super.visible = t,
            this._visible = t,
            this.infoWindow && (this.infoWindow.visible = t)
        }
        joinAttribute(t, e, n) {
            var a = this._orignRenderer;
            if (n || (n = e),
            t && e && n && "GeoHeatMap" !== this.geometryType) {
                var i = [];
                this.children.map(o=>{
                    var s = o.userData;
                    for (var l in t.forEach(function(t) {
                        s[e] === t[n] && (o.userData = CMAP.Util.objectAssign(t, s))
                    }),
                    a) {
                        var u, c = a[l];
                        if (Array.isArray(c))
                            if (c.length > 0 && void 0 !== c[0].condition)
                                for (var h in c) {
                                    var d = c[h].condition;
                                    if ("" === d && (u = c[h].value),
                                    r.a.isObjectMeetCondition(s, d)) {
                                        -1 === i.indexOf(d) && i.push(d),
                                        u = c[h].value;
                                        break
                                    }
                                }
                            else
                                u = c;
                        else
                            u = c;
                        o.renderer[l] = u
                    }
                }
                )
            }
        }
        _getValueByCnd(t, e) {
            let n = {}
              , a = [];
            for (let i in t) {
                let o = t[i];
                if (Array.isArray(o))
                    if (o.length > 0 && void 0 !== o[0].condition)
                        for (let t in o) {
                            let s = o[t].condition;
                            if ("" === s && (n[i] = o[t].value),
                            r.a.isObjectMeetCondition(e, s)) {
                                -1 === a.indexOf(s) && a.push(s),
                                n[i] = o[t].value;
                                break
                            }
                        }
                    else
                        n[i] = o;
                else
                    n[i] = o
            }
            return {
                config: n,
                featureCondition: a
            }
        }
        _dataHandler(t, e, n, r) {
            var a = t.features;
            if ("GeoHeatMap" !== e) {
                var i = 0;
                for (let t = 0; t < a.length; t++) {
                    let h = a[t];
                    var o = h.properties;
                    r._outerDataSource && r._joinBy && r._outerDataSource.forEach(function(t) {
                        o[r._joinBy] === t[r._joinBy] && (o = Object.assign(t, o))
                    });
                    var s = h.geometry;
                    i++;
                    let d = this._getValueByCnd(n, o)
                      , f = d.config
                      , p = d.featureCondition;
                    var l = JSON.stringify(p)
                      , u = "geoItem_" + e + "_" + i
                      , c = "geoItem_" + e + "_" + i;
                    for (let t in o)
                        "id" === t.toLowerCase() && (c = o[t]),
                        "name" === t.toLowerCase() && (u = o[t]);
                    let m;
                    this._paramLabel && (m = this._getValueByCnd(this._paramLabel, o).config);
                    let g = this.offsetHeight
                      , v = this.offsetHeightAdded;
                    THING.Utils.isNull(this.offsetHeightField) && THING.Utils.isNull(this.groundHeightField) && THING.Utils.isNull(this.offsetHeight) && !THING.Utils.isNull(this.offsetHeightAdded) && (g = this.offsetHeightAdded,
                    v = void 0);
                    let y = r.app.create({
                        type: e,
                        id: c,
                        name: u,
                        coordinates: s.coordinates,
                        pickWithGeometryID: r._pickWithGeometryID,
                        extrudeHeight: r._height,
                        extrudeField: r._extrudeField,
                        extrudeFactor: r._extrudeFactor,
                        offsetHeight: g,
                        offsetHeightField: r._offsetHeightField,
                        offsetHeightFactor: r._offsetHeightFactor,
                        offsetHeightAdded: v,
                        groundHeightField: r._groundHeightField,
                        groundHeightFactor: r._groundHeightFactor,
                        infoWindow: CMAP.Util._toObject(r.infoWindow),
                        useMercatorUV: r._useMercatorUV,
                        label: m,
                        userData: o,
                        renderer: f,
                        azimuth: r.azimuth,
                        clampToGround: r.clampToGround,
                        heightArrayField: r.heightArrayField,
                        heightArrayFactor: r.heightArrayFactor,
                        pivot: r._pivot,
                        _featureLayerId: r.id,
                        _conditionStr: l,
                        useOutline: r._useOutline
                    });
                    r.add(y)
                }
                "GeoPoint" === r.geometryType ? r._renderer = new ee(r,n) : "GeoLine" === r.geometryType || "GeoFlyLine" === r.geometryType || "GeoFlyLine2" === r.geometryType || "GeoODLine" === r.geometryType ? r._renderer = new ae(r,n) : "GeoBuilding" === r.geometryType ? r._renderer = new jt(r,n) : "GeoHeatMap" === r.geometryType ? r._renderer = new Ae(r,n) : "GeoPolygon" === r.geometryType ? (r._setUpRenderer(n),
                r._processPolygonRenderer()) : "GeoWater" === r.geometryType ? r._renderer = new be(r,n) : "GeoBoundary" === r.geometryType && (r._renderer = new ye(r,n))
            } else {
                var h = []
                  , d = r.renderer.valueField;
                a.map(t=>{
                    var e = t.properties
                      , n = t.geometry;
                    d && e[d] && "NaN" !== parseFloat(e[d]).toString() ? h.push({
                        x: n.coordinates[0],
                        y: n.coordinates[1],
                        value: parseFloat(e[d])
                    }) : h.push({
                        x: n.coordinates[0],
                        y: n.coordinates[1],
                        value: 1
                    })
                }
                );
                var f = r.app.create({
                    type: r.geometryType,
                    name: r.name,
                    dataSource: h,
                    renderer: r._renderer
                });
                r.add(f)
            }
            r.extent = CMAP.Util.getFeatureCollectionExtent(r.dataSource)
        }
        _setUpRenderer(t) {
            this._fillRenderer = new jt(this,t);
            let e = {};
            for (let n in t)
                if (n.startsWith("outline")) {
                    let r = n.replace("outline", "");
                    e[r = r.charAt(0).toLowerCase() + r.slice(1)] = t[n]
                }
            void 0 === e.lineType && (e.lineType = "Plane"),
            void 0 === e.width && (e.width = 0),
            this._lineRenderer = new ae(this,e),
            this._originLineRenderer = e
        }
        _processPolygonRenderer() {
            let t = this._fillRenderer.toObject()
              , e = this._lineRenderer.toObject()
              , n = this;
            this._renderer = {};
            for (let e in t)
                Object.defineProperty(this._renderer, e, {
                    configurable: !0,
                    enumerable: !0,
                    get: function() {
                        return n._fillRenderer[e]
                    },
                    set: function(t) {
                        n._fillRenderer[e] = t
                    }
                });
            for (let t in e) {
                let e = "outline" + t.charAt(0).toUpperCase() + t.slice(1);
                Object.defineProperty(this._renderer, e, {
                    configurable: !0,
                    enumerable: !0,
                    get: function() {
                        return n._lineRenderer[t]
                    },
                    set: function(e) {
                        n.children.forEach(r=>{
                            ("lineType" === t || "width" === t && "Plane" !== n.renderer.outlineLineType) && r._outline.setParent(null),
                            r._lineRenderer[t] = e,
                            ("lineType" === t || "width" === t && "Plane" !== n.renderer.outlineLineType) && (r._setUpOutlineExtra(),
                            r.add(r._outline))
                        }
                        ),
                        n._lineRenderer["_" + t] = "color" === t ? CMAP.Util.colorFormatNewToOld(e, n._lineRenderer.opacity) : e
                    }
                })
            }
        }
    }
    THING.factory.registerClass("FeatureLayer", ln);
    class un extends P {
        constructor(t) {
            super(t),
            this.app = t,
            this.type = "VectorBaseLayer",
            this.state = "start"
        }
        customSetup(t) {
            super.customSetup(t),
            this.layerType = "VectorBaseLayer",
            this.rootNode = new THREE.Group,
            this.rootNode.name = "VectorBaseLayer",
            window.t3djs.buffer.nodeBuffer.add("VectorBaseLayer", this.rootNode),
            this.node = this._layer = this.rootNode = window.t3djs.VectorBaseLayer = new THREE.Group,
            this.earthResource = t.url,
            this.complete = t.complete,
            this._parseRenderer(t.style || t.renderer),
            this.pending = [],
            this.data = {
                bigPoint: null,
                smallPoint: null,
                worldPoint: null,
                bigLine: null,
                smallLine: null,
                china: null,
                lonlat: null,
                earth: null
            }
        }
        _parseRenderer(t) {
            this._defaultStyle = {
                bigPointStyle: {
                    glowStrength: 2,
                    size: 5,
                    color: "#444fff"
                },
                smallPointStyle: {
                    glowStrength: 1.2,
                    size: 2,
                    color: "#0087ff"
                },
                worldPointStyle: {
                    glowStrength: 1.2,
                    size: 4,
                    color: "#6186ff"
                },
                bigLineStyle: {
                    glowStrength: 1.38,
                    width: 3,
                    color: "#00bbe3"
                },
                smallLineStyle: {
                    glowStrength: 0,
                    width: 1,
                    color: "#ffffff"
                },
                chinaEffect: !0,
                loadConfig: {
                    lonlat: !0
                },
                worldMeshStyle: {
                    color: "#193e96",
                    lights: !1,
                    type: "vector",
                    visible: !0
                }
            },
            this._renderer = this._style = THING.Utils.mergeObject(this._defaultStyle, t, !0)
        }
        setupComplete() {
            var t = this;
            C.a.add("vectorLayerVisible", function() {
                t.app.uEarth._earthInstance.tileEarth.isEarthShow && t.load()
            })
        }
        load() {
            C.a.delete("vectorLayerVisible"),
            this.pending.push(this.getEarthMeshes()),
            this.pending.push(this.getEarthPoints()),
            this.pending.push(this.getEarthLines()),
            this.style.loadConfig.lonlat && this.pending.push(this.getEarthLonLatLines());
            let t = this.app;
            Promise.all(this.pending).then(()=>{
                !THING.App.current.uEarth._earthInstance._atmospereSetuped && THING.App.current.uEarth._atmosphere && (THING.App.current.uEarth.atmosphere = !0),
                this.changeStyle(this.style),
                setTimeout(()=>{
                    t.rendererManager._mainRenderer.dirty(),
                    this.complete && this.complete({
                        object: this
                    }),
                    t.trigger("VectorBaseLayerComplete", {
                        object: this
                    })
                }
                , 10)
            }
            )
        }
        getEarthMeshes() {
            let t = this.app
              , e = this.earthResource + "/world.geojson"
              , n = this;
            return new Promise((a,i)=>{
                r.a._queryHttpUrl({
                    url: e,
                    complete: function(e) {
                        e = JSON.parse(e);
                        let r = t.create({
                            type: "FeatureLayer",
                            dataSource: e,
                            geometryType: "GeoPolygon",
                            renderer: n.style.worldMeshStyle,
                            visible: n.style.worldMeshStyle.visible,
                            renderOrder: -100
                        });
                        r.node.getMeshes().forEach(function(t) {
                            t._vectorStyle = Wt.worldMesh
                        });
                        let i = new THREE.MeshStandardMaterial({
                            color: new THREE.Color(10 / 255,10 / 255,10 / 255),
                            transparent: !0
                        })
                          , o = new THREE.SphereGeometry(CMAP.depthGlobeRadiusFar,128,128)
                          , s = new THREE.Mesh(o,i);
                        s.renderOrder = -101,
                        r.node.add(s),
                        n._processChinaEffect(r.node, n.style.chinaEffect),
                        n.rootNode.add(r.node);
                        let l = r.query("China")[0].node.getMeshes()[0];
                        n.data.china = l,
                        n.data.earth = r.node,
                        a("success getEarthMeshes")
                    }
                })
            }
            )
        }
        _processEarth(t) {}
        _processChinaEffect(t, e=!0) {
            t && (e ? THING.App.current.effectManager.setEffect(t, "radialOffset", !0) : THING.App.current.effectManager.removeEffect(t, "radialOffset"))
        }
        getPolygon() {}
        processCompositor() {}
        getEarthPoints() {
            let t = this.earthResource + "/lonlatBigPoint.json"
              , e = this.earthResource + "/lonlatSmallPoint.json"
              , n = this.earthResource + "/world.geojson"
              , r = this
              , a = [t, e, n]
              , i = r.style.bigPointStyle
              , o = r.style.smallPointStyle
              , s = r.style.worldPointStyle;
            return new Promise((l,u)=>{
                THING.Utils.dynamicLoad(a, function(a) {
                    let u = a[t]
                      , c = r._createBigPointMesh(u, "vectorEarth-bigPoint", i.size, i.glowStrength, !0);
                    c._vectorStyle = Wt.bigPoint;
                    let h = a[e]
                      , d = r._createBigPointMesh(h, "vectorEarth-smallPoint", o.size, o.glowStrength, !0);
                    d._vectorStyle = Wt.smallPoint,
                    r.rootNode.add(c),
                    r.rootNode.add(d);
                    let f = a[n]
                      , p = r._createBigPointMesh(f, "vectorEarth-worldPoint", s.size, s.glowStrength, !0, "geojson");
                    p._vectorStyle = Wt.worldPoint,
                    r.rootNode.add(p),
                    r.data.bigPoint = c,
                    r.data.smallPoint = d,
                    r.data.worldPoint = p,
                    l("success getEarthPoints")
                }, !1)
            }
            )
        }
        _processWorldPoint(t) {
            let e = []
              , n = []
              , a = t.features;
            for (let t = 0, i = a.length; t < i; t++) {
                let i = a[t].geometry.coordinates
                  , o = M.a._processGeojson(i, "POLYGON");
                for (let t = 0, a = o.length; t < a; t++) {
                    let a = o[t];
                    for (let t = 0, i = a.length; t < i; t++) {
                        let i = a[t];
                        for (let t = 0, a = i.length; t < a; t++) {
                            let a = r.a.convertLonlat2World(i[t], 10);
                            e.push(a[0]),
                            e.push(a[1]),
                            e.push(a[2]),
                            n.push(1),
                            n.push(1),
                            n.push(1),
                            n.push(1)
                        }
                    }
                }
            }
            return {
                position: e,
                color: n
            }
        }
        _processPoint(t) {
            let e = []
              , n = [];
            for (let r = 0, a = t.length; r < a; r++)
                e.push(t[r].pos[0]),
                e.push(t[r].pos[1]),
                e.push(t[r].pos[2]),
                n.push(1),
                n.push(1),
                n.push(1),
                n.push(1);
            return {
                position: e,
                color: n
            }
        }
        _createBigPointMesh(t, e, n=1, r=1, a=!0, i="json") {
            let o, s = (o = "json" === i ? this._processPoint(t) : this._processWorldPoint(t)).position, l = o.color, u = t3djs.util.createBigPointGeometry(s, l), c = t3djs.util.createBigPointMaterial(e, n);
            c.depthTest = !0;
            let h = t3djs.util.createBigPointMesh(u, c);
            return THING.App.current.effectManager.setEffect(h, "glow", !0),
            a && THING.App.current.effectManager.setEffect(h, "radialBlur2", !0),
            h
        }
        getEarthLines() {
            let t = this.earthResource + "/china_outline.geojson"
              , e = this.earthResource + "/china_innerline.geojson"
              , n = this
              , r = [t, e]
              , a = n.style.bigLineStyle
              , i = n.style.smallLineStyle;
            return new Promise((o,s)=>{
                THING.Utils.dynamicLoad(r, function(r) {
                    let s = r[t]
                      , l = n.app.create({
                        type: "FeatureLayer",
                        geometryType: "GeoLine",
                        name: "vectorEarth-china_outline",
                        dataSource: s,
                        renderer: {
                            type: "vector",
                            effect: !1,
                            lineType: "Plane",
                            width: a.width,
                            color: a.color
                        },
                        offsetHeight: 2e3,
                        renderOrder: -98
                    });
                    l.node.getMeshes().map(t=>{
                        t._vectorStyle = Wt.bigLine,
                        THING.App.current.effectManager.setEffect(t, "glow", a.glowStrength)
                    }
                    ),
                    n.rootNode.add(l.node);
                    let u = r[e]
                      , c = n.app.create({
                        type: "FeatureLayer",
                        geometryType: "GeoLine",
                        name: "vectorEarth-china_innerline",
                        dataSource: u,
                        renderer: {
                            type: "vector",
                            effect: !1,
                            lineType: "Plane",
                            width: i.width,
                            color: i.color
                        },
                        offsetHeight: 2e3,
                        renderOrder: -97
                    });
                    c.node.getMeshes().map(t=>{
                        t._vectorStyle = Wt.smallLine,
                        THING.App.current.effectManager.setEffect(t, "glow", i.glowStrength)
                    }
                    ),
                    n.rootNode.add(c.node),
                    n.data.bigLine = l.node,
                    n.data.smallLine = c.node,
                    o("success getEarthLines")
                })
            }
            )
        }
        getEarthLonLatLines() {
            let t = this.app
              , e = this.earthResource + "/lonlat/"
              , n = this;
            return new Promise((r,a)=>{
                t.create({
                    type: "Thing",
                    url: e,
                    name: "vectorEarth-lonlatLine",
                    position: [0, 0, 0],
                    angle: 0,
                    complete: function(e) {
                        e.object.renderOrder = -99;
                        const a = e.object.node;
                        a.getMaterials().map(t=>{
                            t.depthWrite = !1
                        }
                        ),
                        a.scale.set(92e3, 92e3, 92e3),
                        n.data.lonlat = a,
                        t.addControl({
                            onUpdate: ()=>{
                                t.rendererManager._mainRenderer.dirty("Glow")
                            }
                        }, "VectorBaseLayer_UpdateModels"),
                        n.add(e.object),
                        r("success getEarthLonLatLines")
                    }
                })
            }
            )
        }
        showLonLatModel(t=!0) {
            let e = this.app;
            this.data.lonlat && (this.data.lonlat.visible = t,
            e.removeControl("VectorBaseLayer_UpdateModels"),
            t && e.addControl({
                onUpdate: ()=>{
                    e.rendererManager._mainRenderer.dirty("Glow")
                }
            }, "VectorBaseLayer_UpdateModels"),
            e.rendererManager._mainRenderer.dirty())
        }
        showChinaLines(t=!0) {
            let e = this.app;
            this.data.smallLine.visible = t,
            e.rendererManager._mainRenderer.dirty()
        }
        showEarth(t=!0) {
            let e = this.app;
            this.data.earth.visible = t,
            e.rendererManager._mainRenderer.dirty()
        }
        updateRenderer(t) {
            this.changeStyle(t)
        }
        changeStyle(t) {
            THING.Utils.mergeObject(this.renderer, t, !0);
            let e = this.renderer;
            this._processChinaEffect(this.data.china, e.chinaEffect),
            r.a.applyVectorEarthStyle(this, e)
        }
        enableFocusRegion() {}
        postRadialBlur() {}
        show(t, e=!0) {
            this.data[t] && (this.data[t].visible = e,
            this.app.rendererManager._mainRenderer.dirty())
        }
    }
    THING.factory.registerClass("VectorBaseLayer", un);
    class cn extends THING.BaseObject {
        constructor(t) {
            super(t),
            this.app = t,
            this._layer = this.node
        }
        setup(t) {
            this.map = t.map,
            this.layerType = "TileFeatureLayer",
            this.name = t.name || "TileFeatureLayer" + (new Date).getTime(),
            this._visible = !0,
            this._lastTilesName = [],
            t.renderer ? this._renderer = t.renderer : this._renderer = {
                type: "image",
                url: "./uGeo/pop.png",
                size: 20
            },
            this._3dtileseturl = t.url,
            isNaN(t.height) || (this._3dtilesetHeight = t.height),
            this._3dtileset = new Cesium3.Cesium3DTileset({
                url: this._3dtileseturl,
                skipLevelOfDetail: !0,
                immediatelyLoadDesiredLevelOfDetail: !0
            }),
            this._3dtileset.total3dTileNumber = 0,
            this._3dtileset.maximumMemoryUsage = THING.Utils.parseValue(t.maximumMemoryUsage, 64),
            this._3dtileset.maximum3dTileNumber = THING.Utils.parseValue(t.maximum3dTileNumber, 1e5),
            this._3dtileset.height = this._3dtilesetHeight,
            this.setupComplete(t)
        }
        get visible() {
            return this._visible
        }
        set visible(t) {
            this.show(t),
            this._visible = t
        }
        show(t) {
            this.node.visible = t
        }
        draw3d(t) {
            let e = this
              , n = this.isContinue3d(t);
            if ("break" !== n) {
                Array.isArray(n) && n.forEach(t=>{
                    e.cache3dHide.call(this, t)
                }
                );
                var r = [];
                t.forEach(t=>{
                    let n = e.tile3dNameCreater(this.name, t);
                    r.push(n),
                    this.create3dTileObject(t, n)
                }
                ),
                this._lastTilesName = r
            }
        }
        callAfterRenderFunctions(t) {
            for (var e = t.afterRender, n = 0, r = e.length; n < r; ++n)
                e[n]();
            e.length = 0
        }
        isContinue3d(t) {
            let e = this;
            var n = []
              , r = []
              , a = [];
            t.length;
            if (0 === this._lastTilesName.length)
                return "continue";
            if (0 !== this._lastTilesName.length) {
                var i = [];
                return t.forEach(t=>{
                    let r = e.tile3dNameCreater(this.name, t);
                    i.push(r),
                    -1 === this._lastTilesName.indexOf(r) ? n.push(r) : a.push(r)
                }
                ),
                this._lastTilesName.forEach((t,e)=>{
                    -1 === i.indexOf(t) && r.push(t)
                }
                ),
                t.length < 10 && 0 !== t.length ? "break" : r
            }
            return "break"
        }
        create3dTileObject(t, e) {
            let n = this;
            if (0 === this.query(e).length) {
                this._3dtileset.total3dTileNumber++;
                var r = this.app.create({
                    type: "BaseObject",
                    name: e
                });
                t._content._contents.forEach((t,n)=>{
                    let a = t.batchTable.batchTableJson.Latitude[0] / Math.PI * 180
                      , i = t.batchTable.batchTableJson.Longitude[0] / Math.PI * 180
                      , o = t.batchTable.batchTableJson.attributes || {};
                    var s = this.app.create({
                        type: "GeoPoint",
                        name: "geo_" + e + "_" + n,
                        coordinates: [i, a],
                        userData: o,
                        renderer: this._renderer
                    });
                    r.add(s)
                }
                ),
                this.add(r)
            } else
                n.cache3dShow.call(this, e)
        }
        cache3dDestroy(t) {
            var e = this.query(t);
            if (e.length > 0) {
                e.getChildrenNum();
                e[0].needShow = !1,
                e[0].destroy(!0, !1),
                this._3dtileset.total3dTileNumber -= 1
            }
        }
        cache3dShow(t) {
            var e = this.query(t);
            e.length > 0 && (e[0].needShow = !0,
            e[0].visible = !0)
        }
        tile3dNameCreater(t, e) {
            e._contentUrl;
            var n = e._content._url.split("/");
            return t + n[n.length - 2] + "_" + n[n.length - 1]
        }
        cache3dHide(t) {
            var e = this.query(t);
            if (e.length > 0) {
                e[0].needShow = !1,
                e[0].visible = !1;
                try {
                    this._3dtileset.total3dTileNumber--,
                    e[0].destroy()
                } catch (t) {}
            }
        }
    }
    THING.factory.registerClass("TileFeatureLayer", cn);
    new THREE.MeshBasicMaterial({
        color: 2200782
    });
    class hn extends sn {
        constructor(t) {
            super(t)
        }
        setup(t) {
            super.setup(t),
            this.layerType = "TileBuildingLayer",
            this.name = t.name || "tileBuildingLayer" + (new Date).getTime(),
            this.originRenderer = this.renderer = t.renderer || {}
        }
        show(t) {
            this.node.visible = t
        }
        get renderOrder() {
            return this._renderOrder
        }
        set renderOrder(t) {
            this._renderOrder = t,
            this._tileBuildingLayer.children.map(e=>{
                e.map(e=>{
                    e.renderOrder = t
                }
                )
            }
            )
        }
        createMaterial() {
            return Ut._createAllMaterial(this.renderer, "GeoBuilding")
        }
        create3dTileMesh(t, e, n, r, a, i, o) {
            if (t)
                if (1 === t.length) {
                    var s = new THREE.Texture(t[t.length - 1].image);
                    s.wrapS = s.wrapT = THREE.RepeatWrapping,
                    s.needsUpdate = !0;
                    var l = e + "_tex"
                      , u = e + "_mat";
                    s.name = l,
                    s.matrixAutoUpdate = !1;
                    var c = new THREE.MeshBasicMaterial({
                        map: s,
                        name: u
                    });
                    if (t3djs.buffer.materialBuffer.add(u, c),
                    o && o.grayFilterEnable && o.grayFilterColorBar && o.grayFilterPerBar) {
                        let t = CMAP.Util._generateGradientTextureByGray(o.grayFilterPerBar, o.grayFilterColorBar);
                        c.colorMapping = t
                    }
                    o && o.color && (c.color = new THREE.Color(o.color[0] / 255,o.color[1] / 255,o.color[2] / 255));
                    var h = r.length;
                    for (let t = 0; t < h; t++) {
                        let a = e + "_" + t
                          , i = new THREE.Mesh(r[t],c);
                        i.frustumCulled = !0,
                        i.name = a,
                        i.userData.skipPick = !0,
                        n.add(i),
                        t3djs.buffer.nodeBuffer.add({
                            meshName: i
                        }),
                        r[t] = null
                    }
                } else if (i.length === r.length) {
                    let a, o = CMAP.Util.position2angles(n.position.toArray()), s = CMAP.Util.anglesToQuaternion(o).inverse();
                    this.renderer.quaternion = s,
                    this.renderer.useOriginMaterial || (a = this.createMaterial());
                    for (let o = 0; o < i.length; o++) {
                        var d = i[o].pbrMetallicRoughness.baseColorTexture.index;
                        let s;
                        if (this.renderer.useOriginMaterial) {
                            if (!i[o].material) {
                                const n = dn(t, d);
                                let r = (s = new THREE.MeshBasicMaterial({
                                    map: new THREE.Texture(n.image),
                                    transparent: !0,
                                    metalness: i[o].pbrMetallicRoughness.metallicFactor,
                                    color: i[o].pbrMetallicRoughness.baseColorFactor,
                                    roughness: i[o].pbrMetallicRoughness.roughnessFactor,
                                    opacity: i[o].pbrMetallicRoughness.baseColorFactor[3]
                                })).map;
                                if (r) {
                                    r.wrapS = r.wrapT = THREE.RepeatWrapping,
                                    r.needsUpdate = !0;
                                    let t = e + o + "_tex";
                                    r.name = t,
                                    r.matrix.set(1, 0, 0, 0, -1, 0, 0, 0, 1),
                                    r.matrixAutoUpdate = !1
                                }
                                i[o].material = s
                            }
                        } else {
                            const t = d % 2;
                            (s = a[Math.floor(d / 2)][t]).side = THREE.FrontSide
                        }
                        let l = e + "_" + o
                          , u = new THREE.Mesh(r[o],s);
                        "cool" === this.renderer.type && this.renderer.effect && THING.App.current.effectManager.setEffect(u, "glow", void 0 === this.renderer.glowStrength ? .5 : this.renderer.glowStrength),
                        u.frustumCulled = !0,
                        u.name = l,
                        u.userData.skipPick = !0,
                        n.add(u),
                        t3djs.buffer.nodeBuffer.add({
                            meshName: u
                        }),
                        r[o] = null
                    }
                } else
                    THING.Utils.warn("贴图个数与mesh个数不一致");
            else {
                let t = e + "_mat"
                  , a = new THREE.MeshStandardMaterial({
                    name: t
                });
                if (t3djs.buffer.materialBuffer.add(t, a),
                o && o.grayFilterEnable && o.grayFilterColorBar && o.grayFilterPerBar) {
                    let t = CMAP.Util._generateGradientTextureByGray(o.grayFilterPerBar, o.grayFilterColorBar);
                    a.colorMapping = t
                }
                o && o.color && (a.color = new THREE.Color(o.color[0] / 255,o.color[1] / 255,o.color[2] / 255));
                let i = r.length;
                for (var f = 0; f < i; f++) {
                    let t = e + "_" + f
                      , i = new THREE.Mesh(r[f],a);
                    i.frustumCulled = !0,
                    i.name = t,
                    i.userData.skipPick = !0,
                    n.add(i),
                    i.tuuid = "build",
                    t3djs.buffer.nodeBuffer.add({
                        meshName: i
                    }),
                    r[f] = null
                }
            }
        }
        setDataFromAttributes(t, e) {
            let n;
            for (let c in t) {
                let h = t[c];
                var r, a = h.count, i = THING.Utils.parseValue(h.offsetInBytes, 0), o = h.strideInBytes, s = h.componentDatatype, l = h.componentsPerAttribute, u = this._parseAttributeName(h.attribute);
                if (5126 === s) {
                    let t = new Uint8Array(h.vertexBuffer);
                    if (5 === (o /= Float32Array.BYTES_PER_ELEMENT)) {
                        let e;
                        if (i /= Float32Array.BYTES_PER_ELEMENT,
                        !n) {
                            n = new Float32Array(t.buffer);
                            for (let t = 0; t < n.length / o; t++) {
                                let e, r, a, i, s;
                                e = n[t * o],
                                r = n[t * o + 1],
                                a = n[t * o + 2],
                                i = n[t * o + 3],
                                s = n[t * o + 4],
                                n[t * o] = -e,
                                n[t * o + 1] = a,
                                n[t * o + 2] = r,
                                n[t * o + 3] = i,
                                n[t * o + 4] = 1 - s
                            }
                            e = new THREE.InterleavedBuffer(n,o)
                        }
                        r = new THREE.InterleavedBufferAttribute(e,l,i,!1)
                    } else {
                        let e = new Float32Array(t.buffer,i,a * l);
                        if ("uv" === u)
                            for (let t = 0; t < e.length / o; t++)
                                e[t * o + 1] = 1 - e[t * o + 1];
                        else if ("position" === u)
                            for (let t = 0; t < e.length / o; t++) {
                                let n, r, a;
                                n = e[t * o],
                                r = e[t * o + 1],
                                a = e[t * o + 2],
                                e[t * o] = -n,
                                e[t * o + 1] = a,
                                e[t * o + 2] = r
                            }
                        r = new THREE.BufferAttribute(e,l)
                    }
                    e.addAttribute(u, r)
                }
                if (5123 === s) {
                    let t = new Uint16Array(h.vertexBuffer)
                      , n = new Uint8Array(t.buffer)
                      , i = new Float32Array(a * l);
                    if ("position" === u)
                        for (let t = 0; t < n.length / o; t++) {
                            let e, r, a;
                            e = n[t * o],
                            r = n[t * o + 1],
                            a = n[t * o + 2],
                            i[t * o / 2] = -e,
                            i[t * o / 2 + 1] = a,
                            i[t * o / 2 + 2] = r
                        }
                    r = new THREE.BufferAttribute(i,l),
                    e.addAttribute(u, r)
                }
            }
            r = null
        }
    }
    function dn(t, e) {
        for (let n = 0; n < t.length; n++)
            if (t[n].index === e)
                return t[n];
        return null
    }
    THING.factory.registerClass("TileBuildingLayer", hn);
    class fn extends THING.CompassControl {
        constructor(t) {
            super(t),
            this.useElement = void 0 !== t.useElement && t.useElement,
            this.element = t.element,
            this.rotateToNorthSpeed = void 0 === t.rotateToNorthSpeed ? 1 : t.rotateToNorthSpeed
        }
        onAdd(t) {
            this.app = t;
            var e = this;
            this.useElement && this.element ? (t.domElement.append(this.element),
            this.element.onclick = function() {
                ht.a._rotateToNorth(e.rotateToNorthSpeed)
            }
            ) : (this.app.mainUI.scene2D.add(this.sprite),
            t.on("mousedown", function(t) {
                if (0 === t.button) {
                    var n = document.body.clientHeight
                      , r = document.body.clientWidth
                      , a = [];
                    switch (e.position) {
                    case 1:
                        a = [r + e.offset[0] - this.size / 2, -e.offset[1] + this.size / 2];
                        break;
                    case 2:
                        a = [e.offset[0] + this.size / 2, n - e.offset[1] - this.size / 2];
                        break;
                    case 3:
                        a = [r + e.offset[0] - this.size / 2, n - e.offset[1] - this.size / 2];
                        break;
                    case 0:
                        a = [e.offset[0] + this.size / 2, -e.offset[1] + this.size / 2]
                    }
                    (t.x - a[0]) * (t.x - a[0]) + (t.y - a[1]) * (t.y - a[1]) < 625 && ht.a._rotateToNorth(e.rotateToNorthSpeed)
                }
            }))
        }
        onUpdate() {
            var t = this.app
              , e = t.camera.target;
            if (0 === e[0] || 0 === e[1] || 0 === e[2]) {
                var n = t.camera.camera.getPosition()
                  , a = r.a.world2Lonlat(n);
                e = r.a.lonlat2World(a, 6378e3)
            }
            var i = t3djs.camera.getUp()
              , o = t3djs.math.normalizeVector(e)
              , s = t3djs.math.vectorDotProduct(i, o)
              , l = [o[0] * s, o[1] * s, o[2] * s]
              , u = [i[0] - l[0], i[1] - l[1], i[2] - l[2]]
              , c = t3djs.math.vectorDotProduct([0, 1, 0], o)
              , h = [o[0] * c, o[1] * c, o[2] * c]
              , d = [0 - h[0], 1 - h[1], 0 - h[2]]
              , f = t3djs.math.normalizeVector(u)
              , p = t3djs.math.normalizeVector(d)
              , m = t3djs.math.getAngleBetweenVectors(f, p)
              , g = t3djs.math.vectorCrossProduct(p, o)
              , v = t3djs.math.normalizeVector(g);
            t3djs.math.getAngleBetweenVectors(f, v) < 90 && (m = -m);
            var y = (m = -m) / 180 * Math.PI;
            if (this.useElement && this.element)
                this.element.style.transform = "rotate(" + -y + "rad)";
            else {
                var _ = this.app.mainUI.getRenderPosition(this._uiPosition, [this.size, this.size]);
                this.sprite.position.set(_[0] + this.offset[0], _[1] + this.offset[1], -10),
                this.sprite.material.rotation = y
            }
        }
    }
    THING.factory.registerClass("EarthCompass", fn),
    THING.EarthCompass = fn;
    var pn = fn;
    var mn = class {
        constructor() {
            this._eventMap = {}
        }
        _falseFunc() {}
        on(t, e, n) {
            Array.isArray(this._eventMap[t]) || (this._eventMap[t] = []),
            this._eventMap[t].push({
                func: e,
                context: n
            })
        }
        once(t, e, n) {
            Array.isArray(this._eventMap[t]) || (this._eventMap[t] = []),
            this._eventMap[t].push({
                func: e,
                context: n,
                once: !0
            })
        }
        off(t, e) {
            var n = this._eventMap[t];
            if (Array.isArray(n))
                if ("function" != typeof e) {
                    var r = [];
                    for (let t = 0; t < n.length; t++)
                        n[t].func === e && (n[t].func = this._falseFunc,
                        r.push(t));
                    r.reverse();
                    for (var a = 0; a < r.length; a++)
                        n.splice(r[a], 1)
                } else
                    n.length = 0
        }
        fire(t, e) {
            var n = this._eventMap[t];
            if (Array.isArray(n)) {
                var r = [];
                for (let t = 0; t < n.length; t++) {
                    var a = n[t].func
                      , i = n[t].context;
                    "function" == typeof a && a.apply(i, [e]),
                    n[t].once && (n[t].func = this._falseFunc,
                    r.push(t))
                }
                r.reverse();
                for (var o = 0; o < r.length; o++)
                    n.splice(r[o], 1)
            }
        }
    }
    ;
    class gn extends R {
        constructor(t) {
            super(t),
            this.app = t,
            this.geometryType = "GeoPoint"
        }
        customSetup(t) {
            super.customSetup(t);
            var e = this.app
              , n = this
              , r = CMAP.getCurrentMap();
            this.dataSource = t.dataSource,
            t.renderer = t.renderer || {},
            !THING.Utils.isNull(t.renderer.showSingle) && THING.Utils.isNull(t.renderer.showNonCluster) ? t.renderer.showNonCluster = t.renderer.showSingle : (t.renderer.showNonCluster = THING.Utils.parseValue(t.renderer.showNonCluster, !0),
            t.renderer.showSingle = t.renderer.showNonCluster),
            t.renderer.fontColor = THING.Utils.parseValue(t.renderer.fontColor, [255, 255, 255]),
            t.renderer.useColor = THING.Utils.parseValue(t.renderer.useColor, !1),
            t.renderer.color = THING.Utils.parseValue(t.renderer.color, [255, 255, 255]),
            t.renderer.fontFamily = THING.Utils.parseValue(t.renderer.fontFamily, "Arial,Microsoft YaHei"),
            this._renderer = t.renderer,
            this._pixelRange = THING.Utils.parseValue(t.pixelRange, 100),
            this._minimumClusterSize = THING.Utils.parseValue(t.minimumClusterSize, 2),
            this._change = t.change,
            this.dataSourceUrl = t.dataSourceUrl;
            var a = function() {
                let t = null;
                return function() {
                    var n, a = e.camera, i = new Cesium.Cartesian3(a.position[0],a.position[1],a.position[2]), o = new Cesium.Cartesian3(a.direction[0],a.direction[1],a.direction[2]);
                    if (!Cesium.defined(a._changedDirection))
                        return a._changedPosition = Cesium.Cartesian3.clone(i, a._changedPosition),
                        void (a._changedDirection = Cesium.Cartesian3.clone(o, a._changedDirection));
                    n = Cesium.Math.acosClamped(Cesium.Cartesian3.dot(o, a._changedDirection)) / r._earthInstance.tileEarth._frameState.fovy;
                    var s = Cesium.Cartesian3.distance(i, a._changedPosition) / a.getCameInfo().height;
                    (n > .5 || s > .5) && (clearTimeout(t),
                    t = setTimeout(()=>{
                        e.trigger("earthCameraChanged")
                    }
                    , 300),
                    a._changedPosition = Cesium.Cartesian3.clone(i, a._changedPosition),
                    a._changedDirection = Cesium.Cartesian3.clone(o, a._changedDirection))
                }
            }();
            if (e.on(THING.EventType.CameraChangeEnd, a),
            this.dataSource) {
                var i = new Cesium.EntityCollection;
                for (let t = 0; t < this.dataSource.features.length; t++) {
                    let e = CMAP.Util.convertLonlatToWorld(this.dataSource.features[t].geometry.coordinates)
                      , n = new Cesium.Entity({
                        position: new Cesium.Cartesian3(-e[0],e[2],e[1]),
                        properties: this.dataSource.features[t].properties
                    });
                    i.add(n)
                }
                const t = new Cesium.GeoJsonDataSource;
                this._cesiumDataSource = t,
                t._entityCollection = i,
                this.dataSource._entityCollection = i,
                i._owner = t,
                this._initCluster(t)
            } else {
                Cesium.GeoJsonDataSource.load(this.dataSourceUrl).then(function(t) {
                    n._initCluster(t)
                })
            }
        }
        removeAll() {
            for (let t = this.children.length - 1; t >= 0; t--) {
                let e = this.children[t].canvas;
                const n = e.getContext("2d");
                e.width = e.height = 0,
                n.clearRect(0, 0, 0, 0),
                e = null,
                this.children[t].destroy()
            }
        }
        destroy() {
            super.destroy(),
            this.removeAll(),
            this._cesiumDataSource && (this._cesiumDataSource.name = null),
            this._cesiumDataSource = null,
            this.dataSource._entityCollection && (this.dataSource._entityCollection.removeAll(),
            this.dataSource._entityCollection = null)
        }
        _initCluster(t) {
            let e = this;
            var n = THING.App.current
              , r = this._pixelRange
              , a = "pointClusterDataSource" + this.queryID
              , i = this._minimumClusterSize;
            t.name = a;
            var o = t.clustering;
            o.enabled = !0,
            o.pixelRange = r,
            o.minimumClusterSize = i,
            o._dataSource = t,
            o._initialize(n),
            this._parseRenderer(),
            n.on("addCluster", function(r) {
                e.removeAll();
                var i = [];
                let o = n.domElement.getBoundingClientRect().width
                  , s = n.domElement.getBoundingClientRect().height;
                if (r.object._dataSource.name === a)
                    if (r.object._previousClusters.forEach(function(e) {
                        if (e.nonCluster)
                            e.ids.forEach(function(r) {
                                let a = t._entityCollection._entities._array[r].position._value;
                                a = [-a.x, a.z, a.y];
                                var l = n.camera.worldToScreen(a);
                                l[0] < o && l[0] > 0 && l[1] < s && l[1] > 0 && i.push({
                                    ids: e.ids,
                                    numPoints: e.numPoints,
                                    position: [-e.position.x, e.position.z, e.position.y],
                                    nonCluster: e.nonCluster
                                })
                            });
                        else {
                            var r = [-e.position.x, e.position.z, e.position.y]
                              , a = n.camera.worldToScreen(r);
                            a[0] < o && a[0] > 0 && a[1] < s && a[1] > 0 && i.push({
                                ids: e.ids,
                                numPoints: e.numPoints,
                                position: [-e.position.x, e.position.z, e.position.y],
                                nonCluster: e.nonCluster
                            })
                        }
                    }),
                    e._change && e.on("change", function(t) {
                        e._change.call(e, t)
                    }),
                    e.trigger("change", {
                        object: e,
                        data: i,
                        type: "PointClusterLayerChanged"
                    }),
                    e.trigger("changed", {
                        object: e,
                        data: i,
                        type: "PointClusterLayerChanged"
                    }),
                    e._renderer.renderClusterMarker)
                        e._renderer.renderClusterMarker.call(e, i, e.dataSource);
                    else
                        for (let t = 0; t < i.length; t++) {
                            let n = i[t];
                            e._createClusterMarker(e.renderer, n.position, n.numPoints, n.ids, n.nonCluster)
                        }
            }),
            n.trigger("earthCameraChanged")
        }
        _convertColor(t) {
            this.renderer._color = t ? CMAP.Util.colorFormatNewToOld(t) : [1, 1, 1]
        }
        _convertFontColor(t) {
            this.renderer._fontColor = t ? CMAP.Util.colorFormatNewToOld(t) : [1, 1, 1]
        }
        _checkVisible(t) {
            if (this.visible) {
                var e = CMAP.Util.convertWorldToLonlat(t.position);
                t.visible = ht.a.isPositionVisible(this.app, e)
            }
        }
        _createClusterMarker(t, e, n, r, a) {
            var i = this;
            if (1 === r.length && !t.showSingle && !t.showNonCluster)
                return;
            if (a && !t.showNonCluster)
                return;
            let o = t3djs.canvasManager.createCanvas("canvas_" + this.queryID, 128, 128);
            "image" === t.type && (o._image.src = t.url || t.imageUrl,
            o._image.crossOrigin = "Anonymous",
            o._image._canvas = o,
            o._image.onload = function(a) {
                var o = a.target._canvas._canvas;
                o.width = a.target.width,
                o.height = a.target.height;
                var s = o.getContext("2d");
                if (s.drawImage(a.target, 0, 0),
                t.useColor && t._color) {
                    let e = s.getImageData(0, 0, o.width, o.height);
                    for (let n = 0; n < o.width * o.height; n++)
                        e.data[4 * n] *= t._color[0],
                        e.data[4 * n + 1] *= t._color[1],
                        e.data[4 * n + 2] *= t._color[2];
                    s.putImageData(e, 0, 0)
                }
                var l = o.width > o.height ? o.width / 3 : o.height / 3;
                void 0 === t.fontSize && (t.fontSize = l,
                i._parseRenderer()),
                this._canvas.setFont(t.fontFamily, t.fontSize),
                this._canvas.setTextAlignment(1, 1),
                a.target._canvas.drawText(n, t._fontColor, [o.width / 2, o.height / 2]);
                var u = i.app.create({
                    type: "Marker",
                    position: e,
                    canvas: o,
                    size: t.size,
                    keepSize: !0,
                    userData: {
                        numPoints: n,
                        ids: r
                    },
                    style: {
                        alwaysOnTop: !0
                    }
                });
                i.add(u),
                i._checkVisible(u)
            }
            )
        }
        on() {
            arguments.length < 2 && THING.Utils.log("参数不合法");
            [].push(arguments[0]);
            var t = null
              , e = 0;
            for (let n = 0; n < arguments.length; n++)
                "function" == typeof arguments[n] && (t = arguments[n],
                e = n);
            if (t) {
                arguments[e] = function(e) {
                    if (e.type && (e.type.toLowerCase().indexOf("click") > -1 || e.type.toLowerCase().indexOf("mouse") > -1)) {
                        let t = e.mouseOnObject || e.mouseOffObject || e.pickedObj || e.pickedObject;
                        e.object = t,
                        e._stopPropagation = !0
                    }
                    t.call(e.object, e)
                }
            }
            super.on.apply(this, arguments)
        }
        updateRenderer(t) {
            if (t) {
                t = r.a._toPrivate(t);
                for (let e in t)
                    "_color" !== e && "_fontColor" !== e || (t[e] = CMAP.Util.colorFormatNewToOld(t[e]));
                Object.assign(this._renderer, t)
            }
            this.removeAll(),
            this.app.trigger("earthCameraChanged")
        }
        _parseRenderer() {
            let t = this;
            for (let e in this._renderer)
                e.startsWith("_") || void 0 !== this._renderer["_" + e] || ("color" === e || "fontColor" === e ? this._renderer["_" + e] = CMAP.Util.colorFormatNewToOld(this._renderer[e]) : (this._renderer["_" + e] = this._renderer[e],
                delete this._renderer[e]),
                Object.defineProperty(this._renderer, e, {
                    configurable: !0,
                    enumerable: !0,
                    get: function() {
                        return "color" === e || "fontColor" === e ? CMAP.Util.colorFormatOldToNew(t._renderer["_" + e]) : t._renderer["_" + e]
                    },
                    set: function(n) {
                        t._renderer["_" + e] = "color" === e || "fontColor" === e ? CMAP.Util.colorFormatNewToOld(n) : n,
                        t.updateRenderer()
                    }
                }))
        }
        get pixelRange() {
            return this._pixelRange
        }
        get minimumClusterSize() {
            return this._minimumClusterSize
        }
    }
    THING.factory.registerClass("PointClusterLayer", gn);
    var vn = class {
        constructor(t, e) {
            this._object = t,
            this._type = e.type,
            this._opacity = THING.Utils.parseValue(e.opacity, 1),
            e.color = THING.Utils.parseValue(e.color || [255, 255, 255]),
            this._color = CMAP.Util.colorFormatNewToOld(e.color, this._opacity) || [1, 1, 1, 1],
            this._opacity = this._color[3],
            this._imageUrl = e.imageUrl,
            this._lights = void 0 !== e.lights && e.lights,
            this._mosaic = void 0 !== e.mosaic && e.mosaic,
            this._mosaicSize = void 0 !== e.mosaicSize && e.mosaicSize,
            this._grayFilterEnable = void 0 !== e.grayFilterEnable && e.grayFilterEnable,
            this._grayFilterPerBar = e.grayFilterPerBar,
            this._grayFilterColorBar = e.grayFilterColorBar,
            this._valueRange = e.valueRange,
            this._useColor = THING.Utils.parseValue(e.useColor, !0)
        }
        get color() {
            return CMAP.Util.colorFormatOldToNew(this._color)
        }
        set color(t) {
            const e = CMAP.Util.colorFormatNewToOld(t, this._opacity);
            JSON.stringify(e) !== JSON.stringify(this._color) && (Array.isArray(t) && 4 === t.length && (this._opacity = t[3]),
            this._color = e,
            this._useColor && this._object._updateMaterial())
        }
        get useColor() {
            return this._useColor
        }
        set useColor(t) {
            this._useColor = t,
            this._object._updateMaterial()
        }
        get opacity() {
            return this._opacity
        }
        set opacity(t) {
            this._opacity = t,
            this._object._updateMaterial()
        }
        get imageUrl() {
            return this._imageUrl
        }
        set imageUrl(t) {
            this._object.url && (this._object.url = t)
        }
        get type() {
            return this._type
        }
        set type(t) {
            this._type = t
        }
        get lights() {
            return this._lights
        }
        set lights(t) {
            this._lights = t,
            this._object._updateMaterial()
        }
        get mosaic() {
            return this._mosaic
        }
        set mosaic(t) {
            this._mosaic = t,
            this._object._updateMaterial()
        }
        get mosaicSize() {
            return this._mosaicSize
        }
        set mosaicSize(t) {
            this._mosaicSize = t,
            this._object._setMosaicSize(t)
        }
        get grayFilterEnable() {
            return this._grayFilterEnable
        }
        set grayFilterEnable(t) {
            this._grayFilterEnable = t,
            this._object._updateMaterial()
        }
        get grayFilterPerBar() {
            return this._grayFilterPerBar
        }
        set grayFilterPerBar(t) {
            this._grayFilterPerBar = t,
            this._object._updateMaterial()
        }
        get grayFilterColorBar() {
            return this._grayFilterColorBar
        }
        set grayFilterColorBar(t) {
            this._grayFilterColorBar = t,
            this._object._updateMaterial()
        }
        get valueRange() {
            return this._valueRange
        }
        set valueRange(t) {
            this._valueRange = t,
            this._object._updateMaterial()
        }
    }
    ;
    class yn extends P {
        constructor(t) {
            super(t),
            this.app = t
        }
        customSetup(t) {
            super.customSetup(t),
            this._offsetHeight = void 0 === t.offsetHeight ? 0 : t.offsetHeight,
            this.layerSetup(t)
        }
        layerSetup(t) {
            this._extent = t.extent || {
                minX: -180,
                minY: -90,
                maxX: 180,
                maxY: 90
            };
            let e = t.renderer || {};
            this._canvas = t.canvas,
            this._useMercatorUV = void 0 === t.useMercatorUV || t.useMercatorUV,
            this._setRenderer(e),
            this.materialName = "canvasMaterial" + this._queryID;
            var n = this._createGeometry();
            let r = this._createTexture();
            if (r && r.then)
                r.then(()=>{
                    let t = this._createMaterial();
                    var e = new THREE.Mesh(n,t);
                    this.node.add(e)
                }
                );
            else {
                let t = this._createMaterial();
                var a = new THREE.Mesh(n,t);
                this.node.add(a)
            }
        }
        _createGeometry() {
            return M.a.createRectangleGeometry(this.extent, this._useMercatorUV, this.offsetHeight)
        }
        _getMesh() {
            return this.node.children[0]
        }
        _setRenderer(t) {
            this._renderer = new vn(this,t)
        }
        get extent() {
            return this._extent
        }
        set extent(t) {
            this._extent = t
        }
        _createMaterial() {
            var t = t3djs.materialManager.getMaterial(this.materialName);
            return t && t3djs.materialManager.destroyMaterial(this.materialName),
            t = this._createThreeMaterial(this.renderer.mosaic, this.renderer.mosaicSize)
        }
        _createTexture() {
            this._texture && this._texture.dispose(),
            this._canvas && (this._texture = new THREE.CanvasTexture(this._canvas),
            this._texture.needsUpdate = !0)
        }
        destroy() {
            this._texture && this._texture.dispose(),
            t3djs.materialManager.getMaterial(this.materialName) && t3djs.materialManager.destroyMaterial(this.materialName),
            super.destroy()
        }
        _createThreeMaterial(t, e) {
            var n = t3djs.materialManager.createMaterial(this.materialName, "interpolantMaterial").getMaterial()[0];
            return n.uniforms.tDiffuse.value = this._texture,
            t && (n.defines.USE_MOSAIC = !0,
            e && (n.uniforms.texSize.value.set(this._texture.image.width, this._texture.image.height),
            n.uniforms.mosaicSize.value.set(e, e))),
            this.renderer.grayFilterEnable && this.renderer._grayFilterPerBar && this.renderer._grayFilterColorBar && (n.uniforms.tDiffuse.value = this._texture,
            n.uniforms.colorMapping.value = r.a._generateInterpolantTextureByGray(this.renderer._grayFilterPerBar, this.renderer._grayFilterColorBar),
            n.uniforms.colorRange.value = new THREE.Vector2(this.renderer._valueRange[0],this.renderer._valueRange[1]),
            n.defines.USE_GrayFilter = !0),
            this.renderer.useColor && (n.uniforms.color.value = new THREE.Color(this.renderer._color[0],this.renderer._color[1],this.renderer._color[2])),
            this.renderer.lights && (n.lights = !0,
            n.defines.USE_LIGHT = !0),
            n.uniforms.opacity.value = void 0 === this.renderer.opacity ? 1 : this.renderer.opacity,
            n.depthWrite = !1,
            n
        }
        updateCanvas() {
            this._createTexture();
            var t = this.node.children[0].material;
            "ShaderMaterial" === t.type ? t.uniforms.tDiffuse.value = this._texture : this.node.children[0].material.map = this._texture
        }
        _updateMaterial() {
            var t = this._createMaterial();
            this._getMesh().material = t
        }
        _setMosaic(t, e) {
            var n = this._createThreeMaterial(t, e);
            this.node.children[0].material = n
        }
        _setMosaicSize(t) {
            var e = this.node.children[0].material;
            "ShaderMaterial" === e.type && e.uniforms.mosaicSize.value.set(t, t)
        }
        get offsetHeight() {
            return this._offsetHeight
        }
        set offsetHeight(t) {
            this._offsetHeight = t;
            var e = this._createGeometry();
            this._getMesh().geometry = e
        }
    }
    THING.factory.registerClass("CanvasLayer", yn);
    var _n = yn;
    class xn extends _n {
        constructor(t) {
            super(t),
            this.app = t
        }
        customSetup(t) {
            this._url = t.url || t.renderer.imageUrl,
            this._mask = t.mask,
            this.extrudeHeight = THING.Utils.parseValue(t.extrudeHeight, 0),
            super.customSetup(t)
        }
        _createGeometry() {
            return this._mask ? this.createPolygonGeometry(this._mask, this.extent, this._useMercatorUV)[0] : M.a.createRectangleGeometry(this.extent, this._useMercatorUV, this.offsetHeight, this.node, this.extrudeHeight)
        }
        get url() {
            return this._url
        }
        set url(t) {
            this._url = t,
            this.updateCanvas()
        }
        get mask() {
            return this._mask
        }
        set mask(t) {
            this._mask = t;
            var e = this._createGeometry();
            this._getMesh().geometry = e
        }
        _createTexture() {
            return this._texture && this._texture.dispose(),
            this.url ? new Promise((t,e)=>{
                this._texture = Ut.loadTexture(this.url, ()=>{
                    this._texture.needsUpdate = !0,
                    t(this._texture)
                }
                )
            }
            ) : null
        }
        createPolygonGeometry(t, e, n) {
            var r = M.a._processGeojson(t, "POLYGON");
            return M.a.createPolygonGeometry(r, this.node, this.offsetHeight, 1, e, n, !1).polygonGeometry
        }
    }
    THING.factory.registerClass("ImageLayer", xn);
    class bn extends R {
        constructor(t) {
            super(t),
            this.app = t,
            this.geometryType = "GeoPoint"
        }
        customSetup(t) {
            super.customSetup(t);
            var e = this;
            this._renderer = {},
            this.renderer._opacity = THING.Utils.parseValue(t.renderer.opacity, 1),
            this.renderer._blending = THING.Utils.parseValue(t.renderer.blending, !1),
            t.renderer.colorList = t.renderer.color || t.renderer.colorList,
            this.renderer._colorList = THING.Utils.parseValue(t.renderer.colorList, [[255, 0, 0], [0, 255, 0], [0, 0, 255]]),
            this.dataSource = t.dataSource,
            this._gridSize = t.gridSize,
            this._shapeSize = t.shapeSize,
            this._vectorType = t.vectorType || "box",
            this._extrudeField = t.extrudeField,
            this._extrudeFactor = void 0 === t.extrudeFactor ? 1 : t.extrudeFactor;
            const n = new Cesium.kdbush(this.dataSource.features,t=>t.geometry.coordinates[0],t=>t.geometry.coordinates[1],64);
            let r = CMAP.Util.getFeatureCollectionExtent(this.dataSource);
            var a = [r.minX, r.minY, r.maxX, r.maxY]
              , i = this.gridSize
              , o = CMAP.Util.getSquareGrid(a, i, {
                units: "meters"
            })
              , s = new THREE.Object3D;
            this._infoArray = [],
            this._maxHeight = 0,
            console.time("processing data"),
            o.features.forEach(function(t) {
                const r = n.range(t.geometry.coordinates[0][0][0], t.geometry.coordinates[0][0][1], t.geometry.coordinates[0][2][0], t.geometry.coordinates[0][2][1]);
                t.properties.inPolygonCount = r.length;
                var a = 0;
                if (r.length > 0) {
                    e._extrudeField ? r.forEach(function(t) {
                        a += e.dataSource.features[t].properties[e._extrudeField]
                    }) : a = r.length,
                    a > e._maxHeight && (e._maxHeight = a);
                    var i = [(t.geometry.coordinates[0][0][0] + t.geometry.coordinates[0][2][0]) / 2, (t.geometry.coordinates[0][0][1] + t.geometry.coordinates[0][2][1]) / 2]
                      , o = CMAP.Util.convertLonlatToWorld(i)
                      , l = CMAP.Util._getQuaternionFromPosition(i[0], o, 0);
                    s.scale.set(e.shapeSize, a * e.extrudeFactor, e.shapeSize),
                    s.quaternion.set(l.x, l.y, l.z, l.w),
                    s.position.set(o[0], o[1], o[2]),
                    s.translateY(a * e.extrudeFactor / 2),
                    s.updateMatrix(),
                    e._infoArray.push({
                        matrix: s.matrix.clone(),
                        height: a
                    })
                }
            }),
            console.timeEnd("processing data");
            var l, u = this._infoArray.length, c = new Float32Array(3 * u);
            "box" === this.vectorType ? l = new THREE.BoxBufferGeometry(1,1,1) : "cylinder" === this.vectorType ? l = new THREE.CylinderBufferGeometry(1,1,1,6) : "cone" === this.vectorType && (l = new THREE.ConeBufferGeometry(1,1,16)),
            this._material = this._createMaterial();
            var h = new THREE.InstancedMesh(l,this._material,u);
            h.frustumCulled = !1;
            for (var d = this.renderer._color || this.renderer._colorList, f = 0; f < this._infoArray.length; f++) {
                h.setMatrixAt(f, this._infoArray[f].matrix);
                let t = this._infoArray[f].height
                  , e = d[Math.ceil(d.length * t / this._maxHeight) - 1]
                  , n = CMAP.Util.colorFormatNewToOld(e);
                c[3 * f] = n[0],
                c[3 * f + 1] = n[1],
                c[3 * f + 2] = n[2]
            }
            l.setAttribute("instanceColor", new THREE.InstancedBufferAttribute(c,3)),
            this.node.add(h),
            this._parseRenderer()
        }
        _parseRenderer() {
            let t = this;
            for (let e in this._renderer)
                e = e.substr(1),
                Object.defineProperty(this._renderer, e, {
                    configurable: !0,
                    enumerable: !0,
                    get: function() {
                        return t._renderer["_" + e]
                    },
                    set: function(n) {
                        "opacity" === e ? t.node.getMaterials()[0].opacity = n : "colorList" === e || "color" === e ? (e = "colorList",
                        t._setColorList(n)) : "blending" === e && (t.node.getMaterials()[0].blending = n ? THREE.AdditiveBlending : THREE.NormalBlending),
                        t._renderer["_" + e] = n
                    }
                })
        }
        get gridSize() {
            return this._gridSize
        }
        get vectorType() {
            return this._vectorType
        }
        set vectorType(t) {
            var e = this.node.getMeshes()[0];
            "box" === t ? e.geometry = new THREE.BoxBufferGeometry(1,1,1) : "cylinder" === t ? e.geometry = new THREE.CylinderBufferGeometry(1,1,1,6) : "cone" === t && (e.geometry = new THREE.ConeBufferGeometry(1,1,16));
            var n = this._getColorAttribute(this.renderer.colorList, this._infoArray, this._maxHeight);
            e.geometry.setAttribute("instanceColor", new THREE.InstancedBufferAttribute(n,3)),
            this._vectorType = t
        }
        get shapeSize() {
            return this._shapeSize
        }
        set shapeSize(t) {
            this.node.getMeshes().forEach(function(e) {
                for (var n = 0; n < e.count; n++) {
                    var r = new THREE.Object3D
                      , a = new THREE.Matrix4;
                    e.getMatrixAt(n, a),
                    r.applyMatrix(a),
                    r.scale.setX(t),
                    r.scale.setZ(t),
                    r.updateMatrix(),
                    e.setMatrixAt(n, r.matrix.clone())
                }
                e.instanceMatrix.needsUpdate = !0
            }),
            this._shapeSize = t
        }
        _createMaterial() {
            var t = new THREE.MeshLambertMaterial({
                transparent: !0,
                opacity: this.renderer._opacity,
                blending: this.renderer._blending ? THREE.AdditiveBlending : THREE.NormalBlending
            })
              , e = ["attribute vec3 instanceColor;", "varying vec3 vInstanceColor;", "#include <common>"].join("\n")
              , n = ["#include <begin_vertex>", "\tvInstanceColor = instanceColor;"].join("\n")
              , r = ["varying vec3 vInstanceColor;", "#include <common>"].join("\n")
              , a = ["vec4 diffuseColor = vec4( diffuse * vInstanceColor, opacity );"].join("\n");
            return t.onBeforeCompile = function(t) {
                t.vertexShader = t.vertexShader.replace("#include <common>", e).replace("#include <begin_vertex>", n),
                t.fragmentShader = t.fragmentShader.replace("#include <common>", r).replace("vec4 diffuseColor = vec4( diffuse, opacity );", a)
            }
            ,
            t
        }
        _getColorAttribute(t, e, n) {
            for (var r = e.length, a = new Float32Array(3 * r), i = 0; i < e.length; i++) {
                let r = e[i].height
                  , o = t[Math.ceil(t.length * r / n) - 1]
                  , s = CMAP.Util.colorFormatNewToOld(o);
                a[3 * i] = s[0],
                a[3 * i + 1] = s[1],
                a[3 * i + 2] = s[2]
            }
            return a
        }
        _setColorList(t) {
            var e = this._getColorAttribute(t, this._infoArray, this._maxHeight);
            this.node.children[0].geometry.setAttribute("instanceColor", new THREE.InstancedBufferAttribute(e,3))
        }
        get extrudeFactor() {
            return this._extrudeFactor
        }
        set extrudeFactor(t) {
            0 === t && (THING.Utils.warn("拔高倍数不允许设置为0"),
            t = .001);
            for (var e = this.node.children[0], n = 0; n < e.count; n++) {
                var r = new THREE.Object3D
                  , a = new THREE.Matrix4;
                e.getMatrixAt(n, a),
                r.applyMatrix4(a);
                let i = r.scale.y
                  , o = r.scale.y / this.extrudeFactor * t;
                r.scale.set(this.shapeSize, o, this.shapeSize),
                r.translateY((o - i) / 2),
                r.updateMatrix(),
                e.setMatrixAt(n, r.matrix.clone())
            }
            e.instanceMatrix.needsUpdate = !0,
            this._extrudeFactor = t
        }
    }
    THING.factory.registerClass("GridLayer", bn);
    class wn extends _n {
        constructor(t) {
            super(t),
            this.app = t,
            this.geometryType = "GeoPoint",
            this._visible = !0
        }
        layerSetup(t) {
            var e = this;
            this._extent = this._paramExtent = t.extent,
            this._needsUpdate = void 0 === t.needsUpdate || t.needsUpdate,
            this._extent && (this._needsUpdate = !1),
            this._valueField = t.valueField,
            this._setRenderer(t.renderer || {}),
            this._minValue = t.renderer.minValue,
            this._maxValue = t.renderer.maxValue,
            this._heatMapDataList = [],
            this.dataSource = t.dataSource,
            this._useMercatorUV = !0,
            this.materialName = "heatmapMaterial" + this._queryID,
            this._canvas = this.draw(),
            this._canvas && this._createMesh();
            var n = this._drawHandler.call(e);
            this.app.on(THING.EventType.CameraChange, function() {
                e.visible && e._needsUpdate && n()
            }, "heatmapLayer" + this._queryID)
        }
        _drawHandler() {
            var t, e = this, n = function() {
                e._redraw.call(e)
            };
            return function() {
                t && clearTimeout(t),
                t = setTimeout(n, 300)
            }
        }
        _createMesh() {
            var t = this._createGeometry();
            this._createTexture();
            var e = this._createMaterial()
              , n = new THREE.Mesh(t,e);
            n.renderOrder = this._renderOrder,
            this.node.add(n)
        }
        _setRenderer(t) {
            this._renderer = new Ae(this,t)
        }
        get visible() {
            return this._visible
        }
        set visible(t) {
            super.visible = t,
            this._visible = t,
            this._layer.visible = t
        }
        destroy() {
            this._heatMap && this._layer.name === "heatmap_mesh" + this.id && this._heatMap.destroy(),
            this.app.off("camerachangeend", null, "heatmapLayer" + this._queryID),
            super.destroy()
        }
        get renderOrder() {
            return this._renderOrder
        }
        set renderOrder(t) {
            this.node && this.node.getMeshes().forEach(e=>{
                e.renderOrder = t
            }
            ),
            this._renderOrder = t
        }
        getMeshExtent() {
            if (this._paramExtent)
                return {
                    west: this._paramExtent.minX,
                    east: this._paramExtent.maxX,
                    south: this._paramExtent.minY,
                    north: this._paramExtent.maxY
                };
            var t = this.app.uEarth.getCurrentExtent()
              , e = {
                west: t.minX,
                east: t.maxX,
                south: t.minY,
                north: t.maxY
            };
            if (this._dataExtent) {
                if (e.east < this._dataExtent.minX || e.west > this._dataExtent.maxX || e.south > this._dataExtent.maxY || e.north < this._dataExtent.minY)
                    return;
                var n = this._dataExtent.maxX - this._dataExtent.minX
                  , r = this._dataExtent.maxY - this._dataExtent.minY;
                e.east > this._dataExtent.maxX + 1 * n && (e.east = this._dataExtent.maxX + 1 * n),
                e.west < this._dataExtent.minX - 1 * n && (e.west = this._dataExtent.minX - 1 * n),
                e.north > this._dataExtent.maxY + 1 * r && (e.north = this._dataExtent.maxY + 1 * r),
                e.south < this._dataExtent.minY - 1 * r && (e.south = this._dataExtent.minY - 1 * r)
            }
            return e
        }
        _redraw() {
            if (this._canvas = this.draw(),
            this._canvas)
                if (0 === this.node.children.length)
                    this._createMesh();
                else {
                    var t = this._createGeometry();
                    this.node.children[0].geometry = t,
                    this.updateCanvas()
                }
        }
        draw() {
            var t = this.getMeshExtent();
            if (!t)
                return this._getCanvas();
            var e = {};
            e.radius = this.renderer.radius,
            e.gradient = this.renderer.gradient;
            var n = {};
            for (var r in e.gradient) {
                var a = r;
                r - 0 > .3 && (a = .7 + .3 * r),
                n[a] = e.gradient[r]
            }
            return e.gradient = n,
            e.opacity = this.renderer.opacity,
            e.maxOpacity = this.renderer.maxOpacity,
            e.minOpacity = this.renderer.minOpacity,
            this._heatMap ? (this._heatMap.setBounds(t),
            this._heatMap.setDimensions()) : this._heatMap = CesiumHeatmap.create(this.id, t, e),
            this._needsUpdate && (t = this._heatMap.bounds),
            this._extent = {
                minX: t.west,
                maxX: t.east,
                minY: t.south,
                maxY: t.north
            },
            this._heatMap.setWGS84Data(this.renderer.minValue, this.renderer.maxValue, this._heatMapDataList, !1),
            this._getCanvas()
        }
        setMinMaxOpacity(t, e) {
            this._heatMap && (this._heatMap.setMinMaxOpacity(t, e),
            this.updateCanvas())
        }
        setGradient(t) {
            if (this._heatMap) {
                var e = {};
                for (var n in t) {
                    var r = n;
                    n - 0 > .3 && (r = .7 + .3 * n),
                    e[r] = t[n]
                }
                this._heatMap.setGradient(e),
                this.updateCanvas()
            }
        }
        setRadius(t) {
            this._heatMap && (this._heatMap.setRadius(t),
            this.updateCanvas())
        }
        setDataSource(t) {
            for (var e = [], n = 1 / 0, r = -1 / 0, a = 0; a < t.features.length; a++) {
                var i = t.features[a]
                  , o = this._valueField ? i.properties[this._valueField] : 1;
                void 0 === o && (o = 1),
                o > r && (r = o),
                o < n && (n = o),
                e.push({
                    x: i.geometry.coordinates[0],
                    y: i.geometry.coordinates[1],
                    value: o
                })
            }
            return {
                heatMapDataSource: e,
                maxValue: r,
                minValue: n
            }
        }
        get dataSource() {
            return this._dataSource
        }
        set dataSource(t) {
            var e = this.setDataSource(t);
            this._heatMapDataList = e.heatMapDataSource,
            void 0 === this._minValue && (this.renderer.minValue = e.minValue),
            void 0 === this._maxValue && (this.renderer.maxValue = e.maxValue),
            this._dataExtent = CMAP.Util.getFeatureCollectionExtent(t),
            this._heatMap && this._redraw(),
            this._dataSource = t
        }
        set valueField(t) {
            this._valueField = t,
            this.dataSource = this._dataSource
        }
        get valueField() {
            return this._valueField
        }
        get needsUpdate() {
            return this._needsUpdate
        }
        set needsUpdate(t) {
            this._needsUpdate = t,
            t && this._redraw()
        }
        get offsetHeight() {
            return this._offsetHeight
        }
        set offsetHeight(t) {
            this._offsetHeight = t,
            this._redraw()
        }
        _getCanvas() {
            if (this._heatMap)
                return this._heatMap._container.children[0]
        }
    }
    THING.factory.registerClass("HeatMapLayer", wn);
    class Cn extends P {
        constructor(t) {
            super(t),
            this.app = t,
            this._visible = !0
        }
        customSetup(t) {
            window.BMapEarth = window.BMapEarth || {},
            this.tileSize = 256,
            this.sourceCrs = t.sourceCrs || "bd09",
            this.targetCrs = t.targetCrs || "gcj02",
            this.ratio = window.devicePixelRatio,
            this._needsUpdate = void 0 === t.needsUpdate || t.needsUpdate,
            this._offsetHeight = void 0 === t.offsetHeight ? 0 : t.offsetHeight,
            this.zoomUnits = 0,
            this.levelUnits = 0,
            this.cache = {},
            this.url = t.url || "https://sp3.baidu.com/7_AZsjOpB1gCo2Kml5_Y_DAcsMJiwa/traffic/?qt=vtraffic",
            this._renderer = {
                lineType: "Line",
                width: 1,
                color: ["rgba(0,192,73,0.99609375)", "rgba(242,48,48,0.99609375)", "rgba(255,159,25,0.99609375)", "rgba(181,0,0,1)"]
            },
            Object.assign(this.renderer, t.renderer);
            var e = this.renderer.color;
            this.arrFeatureStyles = [[2, e[0] || "rgba(79,210,125,1)", 2, 2, 0, [], 0, 0], [2, e[0] || "rgba(79,210,125,1)", 3, 2, 0, [], 0, 0], [2, e[0] || "rgba(79,210,125,1)", 3, 2, 0, [], 0, 0], [2, e[0] || "rgba(79,210,125,1)", 5, 2, 0, [], 0, 0], [2, e[0] || "rgba(79,210,125,1)", 6, 2, 0, [], 0, 0], [2, e[2] || "rgba(255,208,69,1)", 2, 2, 0, [], 0, 0], [2, e[2] || "rgba(255,208,69,1)", 3, 2, 0, [], 0, 0], [2, e[2] || "rgba(255,208,69,1)", 3, 2, 0, [], 0, 0], [2, e[2] || "rgba(255,208,69,1)", 5, 2, 0, [], 0, 0], [2, e[2] || "rgba(255,208,69,1)", 6, 2, 0, [], 0, 0], [2, e[1] || "rgba(232,14,14,1)", 2, 2, 0, [], 0, 0], [2, e[1] || "rgba(232,14,14,1)", 3, 2, 0, [], 0, 0], [2, e[1] || "rgba(232,14,14,1)", 3, 2, 0, [], 0, 0], [2, e[1] || "rgba(232,14,14,1)", 5, 2, 0, [], 0, 0], [2, e[1] || "rgba(232,14,14,1)", 6, 2, 0, [], 0, 0], [2, e[3] || "rgba(181,0,0,1)", 2, 2, 0, [], 0, 0], [2, e[3] || "rgba(181,0,0,1)", 3, 2, 0, [], 0, 0], [2, e[3] || "rgba(181,0,0,1)", 3, 2, 0, [], 0, 0], [2, e[3] || "rgba(181,0,0,1)", 5, 2, 0, [], 0, 0], [2, e[3] || "rgba(181,0,0,1)", 6, 2, 0, [], 0, 0], [2, "rgba(255,255,255,1)", 4, 0, 0, [], 0, 0], [2, "rgba(255,255,255,1)", 5.5, 0, 0, [], 0, 0], [2, "rgba(255,255,255,1)", 7, 0, 0, [], 0, 0], [2, "rgba(255,255,255,1)", 8.5, 0, 0, [], 0, 0], [2, "rgba(255,255,255,1)", 10, 0, 0, [], 0, 0]];
            var n = this;
            this.app.on("camerachangeend", function() {
                n.visible && n._needsUpdate && (n.node.children = [],
                n.update.call(n))
            }, !1),
            this._selectedTiles = {},
            this.app.addControl(this, !1)
        }
        get renderer() {
            return this._renderer
        }
        getExtent() {
            if (this._paramExtent)
                return {
                    west: this._paramExtent.minX,
                    east: this._paramExtent.maxX,
                    south: this._paramExtent.minY,
                    north: this._paramExtent.maxY
                };
            var t = this.app.uEarth.getCurrentExtent();
            return {
                west: t.minX,
                east: t.maxX,
                south: t.minY,
                north: t.maxY
            }
        }
        set offsetHeight(t) {
            this._offsetHeight = t,
            this.node.children = [],
            this.update()
        }
        getZoom() {
            var t = this.heightToZoom(THING.App.current.camera.getCameInfo().height);
            return (t += 1) > 19 && (t = 19),
            t
        }
        heightToZoom(t) {
            var e = -40467.74;
            return Math.round(e + 80955.31 / (1 + Math.pow(t / 91610.74, 7096758e-11)))
        }
        getMCCenter(t) {
            var e = MercatorProjection.convertLL2MC({
                lng: t[0],
                lat: t[1]
            });
            return [e.lng, e.lat]
        }
        getMCBounds(t) {
            var e = this.getExtent();
            if ("bd09" === this.sourceCrs)
                e.sw = MercatorProjection.convertLL2MC({
                    lng: e.west,
                    lat: e.south
                }),
                e.ne = MercatorProjection.convertLL2MC({
                    lng: e.east,
                    lat: e.north
                });
            else if ("WGS84" === this.sourceCrs) {
                let t = CMAP.Util.convertLonlatToWebMercator([e.west, e.south])
                  , n = CMAP.Util.convertLonlatToWebMercator([e.east, e.north]);
                e.sw = {
                    lng: t[0],
                    lat: t[1]
                },
                e.ne = {
                    lng: n[0],
                    lat: n[1]
                }
            }
            return e
        }
        request(t, e) {
            this._selectedTiles[t] = {
                callback: e,
                state: 0
            }
        }
        onUpdate() {
            for (let e in this._selectedTiles) {
                let n = this._selectedTiles[e]
                  , r = n.callback;
                if (!n.resource) {
                    var t = Cesium.Resource.createIfNeeded(e);
                    t.request.throttle = !0,
                    t.request.throttleByServer = !0,
                    n.resource = t
                }
                if (0 === n.resource.request.state) {
                    let t = n.resource.fetchJson();
                    if (!Cesium.defined(t))
                        return;
                    t.then(function(t) {
                        r(t)
                    })
                } else
                    3 === n.resource.request.state ? delete this._selectedTiles[e] : 4 === n.resource.request.state && (n.resource = void 0)
            }
        }
        update() {
            var t, e = this.getZoom();
            "wgs84" === this.sourceCrs.toLowerCase() && (e -= 2);
            var n, r, a, i, o = document.body.clientWidth, s = document.body.clientHeight, l = CMAP.Util.convertWindowToWorld([o / 2, s / 2]), u = CMAP.Util.convertWorldToLonlat(l);
            if ("bd09" === this.sourceCrs) {
                t = this.getMCCenter(u),
                this.zoomUnits = Math.pow(2, 18 - e),
                this.levelUnits = 256 * this.zoomUnits;
                var c = Math.ceil(t[0] / this.levelUnits)
                  , h = Math.ceil(t[1] / this.levelUnits)
                  , d = [c, h, (t[0] - c * this.levelUnits) / this.levelUnits * 256, (t[1] - h * this.levelUnits) / this.levelUnits * 256];
                n = d[0] - Math.ceil((o / 2 - d[2]) / 256),
                r = d[1] - Math.ceil((s / 2 - d[3]) / 256),
                a = d[0] + Math.ceil((o / 2 + d[2]) / 256),
                i = d[1] + Math.ceil((s / 2 + d[3]) / 256)
            } else
                "WGS84" === this.sourceCrs && (t = CMAP.Util.convertLonlatToWebMercator(u),
                this.zoomUnits = 2 * Math.PI * 6378137 / 256 / Math.pow(2, e),
                this.levelUnits = 256 * this.zoomUnits,
                c = Math.ceil(Math.round((t[0] + 20037508.34) / this.levelUnits)),
                h = Math.ceil(Math.round((20037508.34 - t[1]) / this.levelUnits)),
                n = c - Math.ceil(o / 2 / this.tileSize),
                a = c + Math.ceil(o / 2 / this.tileSize),
                r = h - Math.ceil(s / 2 / this.tileSize),
                i = h + Math.ceil(s / 2 / this.tileSize));
            var f = this.getMCBounds(this.viewer);
            if (0 !== f.ne.lng || 0 !== f.ne.lat || 0 !== f.sw.lng || 0 !== f.sw.lat) {
                if ("WGS84" === this.sourceCrs) {
                    var p = this.coords2xy([f.sw.lng, f.sw.lat])
                      , m = this.coords2xy([f.ne.lng, f.ne.lat]);
                    n = p[0],
                    a = m[0],
                    r = m[1] - 1,
                    i = p[1] + 1
                } else
                    "bd09" === this.sourceCrs && (n = Math.floor(f.sw.lng / this.levelUnits),
                    r = Math.floor(f.sw.lat / this.levelUnits),
                    a = Math.ceil(f.ne.lng / this.levelUnits),
                    i = Math.ceil(f.ne.lat / this.levelUnits));
                for (var g = [], v = n; v < a; v++)
                    for (var y = r; y < i; y++)
                        g.push([v, y, e]);
                this.tilesOrder = g,
                this._loadCount = {};
                for (let t = 0; t < g.length; t++) {
                    let e = g[t][0]
                      , n = g[t][1]
                      , r = g[t][2];
                    this._loadCount[e + "_" + n + "_" + r] = !1
                }
                for (let t = 0; t < g.length; t++) {
                    let n = g[t][0]
                      , r = g[t][1];
                    this.showTile(n, r, e)
                }
            } else
                setTimeout(()=>{
                    this.update()
                }
                , 2e3)
        }
        coords2xy(t) {
            return [Math.ceil(Math.round((t[0] + 20037508.34) / this.levelUnits)), Math.ceil(Math.round((20037508.34 - t[1]) / this.levelUnits))]
        }
        getCacheKey(t, e, n) {
            return t + "_" + e + "_" + n
        }
        getTileUrl(t, e, n, r) {
            return this.url + "&x=" + t + "&y=" + e + "&z=" + n
        }
        isAllLoaded() {
            var t = !0;
            for (var e in this._loadCount)
                if (!this._loadCount[e]) {
                    t = !1;
                    break
                }
            return t
        }
        drawCurrentData() {
            for (var t = [], e = 0; e < this.tilesOrder.length; e++) {
                var n = this.tilesOrder[e][0]
                  , r = this.tilesOrder[e][1]
                  , a = this.tilesOrder[e][2]
                  , i = this.cache[this.getCacheKey(n, r, a)];
                if (i)
                    for (var o = this._drawFeatures(i, n, r, a), s = 0; s < o.length; s++)
                        t.push(o[s])
            }
            this.addInstance(t)
        }
        showTile(t, e, n) {
            var r = this
              , a = (r.map,
            this.getCacheKey(t, e, n))
              , i = "_cbk" + (1e5 * Math.random()).toFixed(0)
              , o = this.getTileUrl(t, e, n, "BMapEarth." + i);
            function s(o) {
                if (void 0 !== r._loadCount[t + "_" + e + "_" + n]) {
                    o && "string" == typeof o && (o = JSON.parse(o)),
                    r._loadCount[t + "_" + e + "_" + n] = !0;
                    r.map;
                    var s = o.content && o.content.tf;
                    o.data && (s = o.data),
                    r.cache[a] = s ? {
                        traffic: s,
                        precision: o.precision
                    } : {
                        traffic: [],
                        precision: 0
                    },
                    r.drawTogether ? r.isAllLoaded() && r.drawCurrentData() : r._drawFeatures(r.cache[a], t, e, n),
                    delete window.BMapEarth[i]
                }
            }
            window.BMapEarth[i] = s,
            void 0 !== r.cache[a] ? (r._loadCount[t + "_" + e + "_" + n] = !0,
            r.drawTogether ? r.isAllLoaded() && r.drawCurrentData() : r._drawFeatures(r.cache[a], t, e, n)) : this.request(o, s)
        }
        num2deg(t, e, n) {
            var r = t / Math.pow(2, n) * 360 - 180
              , a = Math.PI - 2 * Math.PI * e / Math.pow(2, n);
            return [r, 180 / Math.PI * Math.atan(.5 * (Math.exp(a) - Math.exp(-a)))]
        }
        _drawFeatures(t, e, n, r) {
            let a = this;
            this.getRGBA,
            this.getLineCap,
            this.getLineJoin;
            var i = 10
              , o = (this.map,
            this.tileSize)
              , s = [0, 0];
            "bd09" === this.sourceCrs ? s = [e * o * this.zoomUnits, (n + 1) * o * this.zoomUnits] : "WGS84" === this.sourceCrs && (s = [e * o * this.zoomUnits - 6378137 * Math.PI, 6378137 * Math.PI - n * o * this.zoomUnits]);
            var l = null
              , u = new THREE.Group;
            if (t && t.traffic) {
                i *= THING.Utils.parseValue(t.precision, 1);
                for (var c = t.traffic, h = {}, d = 0, f = c.length; d < f; d++) {
                    var p, m = c[d], g = m[1], v = this.arrFeatureStyles[m[3]], y = (this.arrFeatureStyles[m[4]],
                    g[0] / i), _ = -g[1] / i, x = [];
                    if ("bd09" === this.sourceCrs) {
                        let t = s[0] + y * this.zoomUnits
                          , e = s[1] + _ * this.zoomUnits
                          , n = MercatorProjection.convertMC2LL({
                            lng: t,
                            lat: e
                        });
                        t = n.lng,
                        e = n.lat,
                        p = CMAP.Util.convertbd09ToGcj02([parseFloat(t), parseFloat(e)]),
                        this.targetCrs && "wgs84" === this.targetCrs.toLowerCase() && (p = CMAP.Util.convertGcj02ToWgs84(p))
                    } else if ("WGS84" === this.sourceCrs) {
                        let t = s[0] + y * this.zoomUnits
                          , e = s[1] + _ * this.zoomUnits;
                        p = CMAP.Util.convertWebMercatorToLonlat([t, e]),
                        this.targetCrs && "gcj02" === this.targetCrs.toLowerCase() && (p = CMAP.Util.convertWgs84ToGcj02(p))
                    }
                    if (l || (l = CMAP.Util.convertLonlatToWorld(p),
                    u.setPosition(l),
                    M.a._setNodeAnglesByPosition(u, l)),
                    x.push(p),
                    "bd09" === this.sourceCrs)
                        for (let t = 2, e = g.length; t < e; t += 2) {
                            y += g[t] / i,
                            _ -= g[t + 1] / i;
                            var b = s[0] + y * this.zoomUnits
                              , w = s[1] + _ * this.zoomUnits
                              , C = MercatorProjection.convertMC2LL({
                                lng: b,
                                lat: w
                            });
                            b = C.lng,
                            w = C.lat;
                            let e = CMAP.Util.convertbd09ToGcj02([parseFloat(b), parseFloat(w)]);
                            this.targetCrs && "wgs84" === this.targetCrs.toLowerCase() && (e = CMAP.Util.convertGcj02ToWgs84(e)),
                            x.push(e)
                        }
                    else if ("WGS84" === this.sourceCrs)
                        for (let t = 2, e = g.length; t < e; t += 2) {
                            y += g[t] / i,
                            _ -= g[t + 1] / i;
                            let e = s[0] + y * this.zoomUnits;
                            var E = s[1] + _ * this.zoomUnits;
                            let n = CMAP.Util.convertWebMercatorToLonlat([e, E]);
                            this.targetCrs && "gcj02" === this.targetCrs.toLowerCase() && (n = CMAP.Util.convertWgs84ToGcj02(n)),
                            x.push(n)
                        }
                    var T = v[1];
                    (T = (T = T.substring(5, T.length - 1)).split(","))[3] = parseFloat(T[3]),
                    h[T = "0,192,73,0.99609375"] || (h[T] = []),
                    h[T].push(x)
                }
                for (var A in h) {
                    var P = []
                      , S = h[A]
                      , R = A.split(",");
                    for (let t = 0; t < S.length; t++) {
                        var D = S[t]
                          , j = new Array(D.length);
                        for (let t = 0; t < j.length; t++)
                            j[t] = a._offsetHeight;
                        var L = M.a.createLine(D, j, l, this.renderer.lineType, this.renderer.width, this.renderer.textureSize);
                        for (let t = 0; t < L.geometryArray.length; t++)
                            P.push(L.geometryArray[t])
                    }
                    if (P.length > 0) {
                        var I = t3djs.util.mergeBufferGeometry(P, 5e4)
                          , O = {
                            type: "vector",
                            color: R,
                            lineType: this.renderer.lineType,
                            width: this.renderer.width
                        }
                          , k = Ut.createLineMaterial(O);
                        for (let t = 0; t < I.length; t++) {
                            var H = M.a.createLineMesh(I[t], k, O);
                            u.add(H)
                        }
                        this.node.add(u)
                    }
                }
            }
        }
        get needsUpdate() {
            return this._needsUpdate
        }
        set needsUpdate(t) {
            this._needsUpdate = t,
            t && this.update()
        }
    }
    THING.factory.registerClass("TrafficLayer", Cn);
    const En = new THREE.Vector3
      , Tn = new THREE.Vector3
      , Mn = new THREE.Matrix3;
    var An = class extends THREE.LineSegments {
        constructor(t, e=1, n=16711680) {
            let r = 0;
            const a = t.geometry;
            if (a && a.isGeometry)
                return void console.error("THREE.VertexNormalsHelper no longer supports Geometry. Use BufferGeometry instead.");
            a && a.isBufferGeometry && (r = a.attributes.normal.count);
            const i = new THREE.BufferGeometry
              , o = new THREE.Float32BufferAttribute(2 * r * 3,3);
            i.setAttribute("position", o),
            super(i, new THREE.LineBasicMaterial({
                color: n,
                toneMapped: !1
            })),
            this.object = t,
            this.size = e,
            this.type = "VertexNormalsHelper",
            this.matrixAutoUpdate = !1,
            this.update()
        }
        update() {
            this.object.updateMatrixWorld(!0),
            Mn.getNormalMatrix(this.object.matrixWorld);
            const t = this.object.matrixWorld
              , e = this.geometry.attributes.position
              , n = this.object.geometry;
            if (n && n.isGeometry)
                console.error("THREE.VertexNormalsHelper no longer supports Geometry. Use BufferGeometry instead.");
            else {
                if (n && n.isBufferGeometry) {
                    const r = n.attributes.position
                      , a = n.attributes.normal;
                    let i = 0;
                    for (let n = 0, o = r.count; n < o; n++)
                        En.set(r.getX(n), r.getY(n), r.getZ(n)).applyMatrix4(t),
                        Tn.set(a.getX(n), a.getY(n), a.getZ(n)),
                        Tn.applyMatrix3(Mn).normalize().multiplyScalar(this.size).add(En),
                        e.setXYZ(i, En.x, En.y, En.z),
                        i += 1,
                        e.setXYZ(i, Tn.x, Tn.y, Tn.z),
                        i += 1
                }
                e.needsUpdate = !0
            }
        }
    }
    ;
    class Pn {
        constructor() {
            this._app = THING.App.current
        }
        onLoad(t, e, n, r) {
            const a = t.info.main;
            if (t.name = t.info.name,
            a) {
                const r = t.url.appendPath(a)
                  , i = this._app.create({
                    type: "Map",
                    url: r,
                    resourceConfig: e,
                    complete: ()=>{
                        t.root = i,
                        n(i)
                    }
                })
            } else
                n()
        }
    }
    class Sn {
        constructor() {
            this._app = THING.App.current
        }
        onLoad(t, e, n, r) {
            const a = t.info.main;
            if (t.name = t.info.name,
            a) {
                const r = t.url.appendPath(a);
                e.complete = (()=>{
                    t.root = i,
                    n(i)
                }
                );
                const i = CMAP.Util.applyTemplate(r, e)
            } else
                n()
        }
    }
    class Rn {
        constructor(t) {
            this.parseParam(t),
            this._enable = !0,
            this._object = t.object,
            t.object && t.object.isBaseObject ? (this.scene = new THREE.Scene,
            this.camera = null,
            this.sprite = null,
            this.raycaster = new THREE.Raycaster,
            this.mouse = new THREE.Vector2,
            this.ratio = 2,
            this.mainAspect = 1,
            this.miniDom = null,
            this.renderTarget = null,
            this.inited = !1,
            this.create()) : THING.Utils.error("The object parameter is needed when using miniMap on earth")
        }
        parseParam(t) {
            if (this.app = t.app,
            this._opacity = THING.Utils.parseValue(t.opacity, .7),
            Array.isArray(t.position) ? this._position = t.position : this._posIndex = t.position || t.posIndex || 0,
            this.bIcon = THING.Utils.parseValue(t.bIcon, !0),
            this.width = THING.Utils.parseValue(t.width, 150),
            this.height = THING.Utils.parseValue(t.height, this.width),
            this._scale = THING.Utils.parseValue(t.scale, 1),
            this.closeBtnImg = t.closeBtnImg || "http://www.thingjs.com/static/images/minimap2.png",
            this.cameraViewImg = t.cameraViewImg || "http://www.thingjs.com/static/images/minimap1.png",
            this.center = {},
            t.sceneCenter ? (this.center.x = t.sceneCenter[0],
            this.center.y = t.sceneCenter[1]) : t.center ? (this.center.x = t.center[0],
            this.center.y = t.center[1]) : (this.center.x = 0,
            this.center.y = 0),
            this.angle = THING.Utils.parseValue(t.angle, 0),
            this.angle += 180,
            this.markerPivot = THING.Utils.parseValue(t.cameraViewPivot, [.5, .5]),
            this.markerSize = THING.Utils.parseValue(t.cameraViewSize, 1),
            this.canMoushWheel = t.mousewheel,
            this.ground = t.ground,
            this.hasClose = t.hasClose,
            !this.ground)
                for (var e = 0; e < this.app.root.campuses.length; e++) {
                    var n = this.app.root.campuses[e].ground;
                    if (n) {
                        this.ground = n.node.children;
                        break
                    }
                }
            this.bTranslate = t.bTranslate || !1
        }
        set scale(t) {
            this._scale = t,
            this.destroy(),
            this.inited = !1,
            this.create()
        }
        get scale() {
            return this._scale
        }
        set opacity(t) {
            this._opacity = t,
            this.sprite.material.opacity = this._opacity
        }
        get opacity() {
            return this._opacity
        }
        set posIndex(t) {
            this._posIndex = t,
            this.setMiniRect()
        }
        get posIndex() {
            return this._posIndex
        }
        set enable(t) {
            this._enable = t
        }
        get enable() {
            return this._enable
        }
        init2d() {
            if (this.miniDom = this.app.domElement.appendChild(document.createElement("div")),
            this.miniDom.className = "minimap",
            this.miniDom.style.position = "absolute",
            this.miniDom.style.cssText = "position: absolute;width:" + this.width + ";height:" + this.height + ";border: 5px solid rgba(255, 255, 255, 0.8);border-radius: 3px;display: block;box-sizing: border-box;overflow:hidden",
            this.miniDom.style.zIndex = 1e3,
            this.hasClose) {
                var t = this.miniDom.appendChild(document.createElement("img"));
                t.className = "minimap_closeBtn",
                t.style.position = "absolute",
                t.style.width = this.width / 5,
                t.style.right = "1px",
                t.style.top = "1px",
                t.src = this.closeBtnImg;
                var e = this;
                t.addEventListener("click", function() {
                    e.enable = !1
                })
            }
            this.miniDom.onmousedown = function(t) {
                var e = t || event;
                e.cancelBubble = !0,
                e.stopPropagation()
            }
            ,
            this.miniDom.onmousemove = function(t) {
                var e = t || event;
                e.cancelBubble = !0,
                e.stopPropagation()
            }
            ,
            this.miniDom.onmousewheel = function(t) {
                var e = t || event;
                e.cancelBubble = !0,
                e.stopPropagation()
            }
        }
        init3d() {
            this.init2d();
            var t = this._object.orientedBoundingBox;
            const e = t.size[0]
              , n = t.size[2];
            var r = e > n ? e : n;
            r *= 1 / this.scale,
            this.mainDom = this.app.domElement,
            this.mainAspect = this.mainDom.clientWidth / this.mainDom.clientHeight,
            this.camera = new THREE.OrthographicCamera(-r,r,r / this.mainAspect,-r / this.mainAspect,-1e3,1e3),
            this.camera.position.set(this.center.x, 100, this.center.y),
            this.camera.up = new THREE.Vector3(0,0,-1),
            this.camera.lookAt(new THREE.Vector3(this.center.x,-1,this.center.y)),
            this.earthCamera = new THREE.PerspectiveCamera(this.app.camera.fov,this.width / this.height,this.app.camera.near,this.app.camera.far),
            this.ratio = this.mainDom.clientWidth / r;
            var a = r
              , i = 8 * a < 256 ? 8 * a : 256
              , o = 8 * (r * this.mainAspect) < 256 * this.mainAspect ? 8 * a : 256 * this.mainAspect;
            this.renderTarget = new THREE.WebGLRenderTarget(i,o,{
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                generateMipmaps: !1,
                format: THREE.RGBAFormat
            });
            var s = new THREE.SpriteMaterial({
                map: this.renderTarget.texture,
                transparent: !0,
                opacity: this._opacity
            })
              , l = new THREE.SpriteMaterial({
                map: (new THREE.TextureLoader).load(this.cameraViewImg),
                transparent: !0,
                opacity: this._opacity
            });
            this.sprite = new THREE.Sprite(s),
            this._marker = new THREE.Sprite(l),
            this._marker.renderOrder = 1,
            this._marker.center.set(this.markerPivot[0], 1 - this.markerPivot[1]),
            this.setMiniRect(),
            this._object ? (this.drawObject(),
            this.camera.add(this._marker)) : this.app.scene.add(this._marker),
            this.app.on("mainDomSizeChanged", ()=>{
                this.destroy(),
                this.inited = !1,
                this.create()
            }
            ),
            this.inited = !0
        }
        create() {
            this.inited || (this.init3d(),
            this.scene.add(this.camera),
            this.camera.add(this.sprite))
        }
        setPosition(t, e) {
            this.miniDom.style.top = t + "px",
            this.miniDom.style.left = e + "px";
            let n = this.camera.left
              , r = this.camera.bottom;
            const a = e / (.5 * this.ratio)
              , i = t / (.5 * this.ratio) * this.height / this.width;
            let o = this.sprite
              , s = n + o.scale.x / 2 + a
              , l = r + o.scale.y / 2 + i;
            o.position.set(s, -l, 0)
        }
        setMiniRect() {
            this.miniDom.style.width = this.width + "px",
            this.miniDom.style.height = this.height + "px";
            var t = this;
            function e(e, n, r, a) {
                t.miniDom.style.top = e,
                t.miniDom.style.left = n,
                t.miniDom.style.bottom = r,
                t.miniDom.style.right = a
            }
            var n, r, a = this.width / (.5 * this.ratio), i = a * this.height / this.width;
            this.sprite.scale.set(a, i, 1);
            var o = this.camera.right
              , s = this.camera.left
              , l = this.camera.bottom
              , u = this.camera.top;
            if (this._position) {
                const t = this._position[0] / (.5 * this.ratio)
                  , o = this._position[1] / (.5 * this.ratio) * this.height / this.width;
                e(this._position[0] + "px", this._position[1] + "px", null, null),
                n = s + a / 2 + o,
                r = -(l + i / 2 + t)
            } else
                switch (this._posIndex) {
                case 0:
                    n = s + a / 2,
                    r = u - i / 2,
                    e("0px", "0px", null, null);
                    break;
                case 2:
                    n = s + a / 2,
                    r = l + i / 2,
                    e(null, "0px", "0px", null);
                    break;
                case 1:
                    n = o - a / 2,
                    r = u - i / 2,
                    e("0px", null, null, "0px");
                    break;
                case 3:
                    n = o - a / 2,
                    r = l + i / 2,
                    e(null, null, "0px", "0px")
                }
            this.sprite.position.set(n, r, 0),
            this._object && this._marker.scale.set(a / 2 * this.markerSize, a / 2 * this.markerSize, 1)
        }
        render() {
            if (this.miniDom)
                if (this._enable) {
                    this.miniDom.style.display = "block";
                    var t = this;
                    this.miniDom.childNodes.forEach(function(e) {
                        e.style.display = t.bIcon ? "block" : "none"
                    });
                    const n = this.mainDom.clientHeight + "_" + this.mainDom.clientWidth;
                    if (this._clientFlag !== n && (this.app.trigger("mainDomSizeChanged"),
                    this._clientFlag = this.mainDom.clientHeight + "_" + this.mainDom.clientWidth),
                    this.update(),
                    null !== this.camera && null !== this.renderTarget) {
                        var e = this.app.renderer.autoClear;
                        this.app.renderer.autoClear = !1,
                        this.app.renderer.setRenderTarget(null),
                        this.app.renderer.render(this.scene, this.camera),
                        this.app.renderer.autoClear = e
                    }
                } else
                    this.miniDom.style.display = "none"
        }
        update() {
            const t = THING.App.current.camera.getCameInfo().heading;
            if (this._object) {
                if (this._referenceNode) {
                    const e = this.app.camera.position
                      , n = this._referenceNode.convertWorldToLocalPosition(e)
                      , r = this.sprite.position
                      , a = -n[0] * this.sprite.scale.x / this._referenceSize.x
                      , i = n[2] * this.sprite.scale.y / this._referenceSize.y;
                    this._marker.position.set(r.x + a, r.y + i, r.z),
                    this._marker.material.rotation = (t + this._object.anglesY) * Math.PI / 180,
                    this._marker.visible = !0,
                    (this._marker.position.x > this.sprite.position.x + this.sprite.scale.x / 2 || this._marker.position.x < this.sprite.position.x - this.sprite.scale.x / 2 || this._marker.position.y > this.sprite.position.y + this.sprite.scale.y / 2 || this._marker.position.y < this.sprite.position.y - this.sprite.scale.y / 2) && (this._marker.visible = !1)
                }
            } else {
                const e = THING.App.current.camera.position;
                let n = THING.App.current.camera.target;
                this.earthCamera.near = THING.App.current.camera.near,
                this.earthCamera.far = THING.App.current.camera.far,
                this.earthCamera.updateProjectionMatrix();
                const r = THING.App.current.camera.distance / this.scale
                  , a = CMAP.Util.convertWorldToLonlat(n)
                  , i = ht.a.getCameraPositionAndTargetByLonlat(a, r, t, 89.9);
                this.earthCamera.position.set(i[0], i[1], i[2]),
                this.earthCamera.lookAt(n[0], n[1], n[2]),
                this.earthCamera.up.set(i[0], i[1], i[2]).normalize(),
                this.app.uEarth._cameraInfo = {
                    cameraPos: i,
                    viewPort: {
                        actualWidth: this.width,
                        actualHeight: this.height
                    },
                    fov: this.earthCamera.fov,
                    cameraDirection: this.earthCamera.getWorldDirection().toArray(),
                    cameraUp: this.earthCamera.up.toArray(),
                    aspectRatio: this.width / this.height
                },
                this.app.uEarth._earthInstance.tileEarth.update();
                const o = this.app.scene.background;
                this.app.scene.background = null,
                this.app.renderer.setClearColor(0, 0),
                this.app.renderer.setRenderTarget(this.renderTarget),
                this.app.renderer.clear(),
                this._marker.visible = !0,
                this._marker.position = e,
                this.app.renderer.render(this.app.scene, this.earthCamera),
                this._marker.visible = !1,
                this.app.uEarth.cameraInfo = null,
                this.app.scene.background = o
            }
        }
        drawObject() {
            this.earthCamera.near = THING.App.current.camera.near,
            this.earthCamera.far = THING.App.current.camera.far,
            this.earthCamera.updateProjectionMatrix();
            const t = this._object.orientedBoundingBox.size;
            let e = t[0] > t[2] ? t[0] : t[2];
            e = (e /= THING.Math.tan(this.earthCamera.fov * Math.PI / 180)) / this.scale * 2;
            const n = this._object.orientedBoundingBox.center
              , r = CMAP.Util.convertWorldToLonlat(n)
              , a = CMAP.Util.convertLonlatToWorld([r[0], r[1] + .1], r[2]);
            let i = THING.Math.subVector(a, n);
            i = (new THREE.Vector3).fromArray(i).normalize();
            const o = (new THREE.Matrix3).setFromMatrix4((new THREE.Matrix4).getInverse(this._object.node.matrixWorld))
              , s = new THREE.Vector3(0,0,1);
            i.applyMatrix3(o);
            let l = s.angleTo(i);
            s.cross(i).y < 0 && (l = -l),
            this._object.anglesY = THING.Math.radToDeg(l),
            this._object.anglesY += this.angle,
            this._referenceNode = new THREE.Object3D,
            this._referenceNode.position.set(n[0], n[1], n[2]);
            const u = CMAP.Util.getAnglesFromPosition(n, this._object.anglesY);
            var c = CMAP.Util.anglesToQuaternion(u);
            this._referenceNode.setRotationFromQuaternion(c),
            this._referenceNode.updateMatrixWorld(),
            this.app.scene.add(this._referenceNode),
            this._referenceSize = {},
            this._referenceSize.y = e * THING.Math.tan(this.earthCamera.fov * Math.PI / 180),
            this._referenceSize.x = e * THING.Math.tan(this.earthCamera.fov * this.earthCamera.aspect * Math.PI / 180);
            const h = ht.a.getCameraPositionAndTargetByLonlat(r, e, -this._object.anglesY, 89.9);
            this.earthCamera.position.set(h[0], h[1], h[2]),
            this.earthCamera.up.set(h[0], h[1], h[2]).normalize(),
            this.earthCamera.lookAt(n[0], n[1], n[2]);
            var d = this.app.scene.background;
            this.app.scene.background = null;
            const f = this.app.uEarth._earthInstance.tileEarth.rootNode.visible;
            this.app.uEarth._earthInstance.tileEarth.rootNode.visible = !1,
            this.app.renderer.setClearColor(0, 0),
            this.app.renderer.setRenderTarget(this.renderTarget),
            this.app.renderer.clear(),
            this.app.renderer.render(this.app.scene, this.earthCamera),
            this.app.scene.background = d,
            this.app.uEarth._earthInstance.tileEarth.rootNode.visible = f
        }
        destroy() {
            var t = this.scene.children.length;
            if (0 !== t) {
                if (t > 0)
                    for (var e = 0; e < t; e++)
                        this.scene.remove(this.scene.children[e]);
                this.camera = null,
                this.earthCamera = null,
                this.sprite = null,
                this._marker = null,
                null !== this.miniDom && (this.app.domElement.removeChild(this.miniDom),
                this.miniDom = null),
                this.app.off("mainDomSizeChanged")
            }
        }
    }
    class Dn {
        constructor(t) {
            this.minimap = null,
            this.param = t
        }
        onAdd(t) {
            null !== this.minimap && this.onRemove(),
            this.param.app || (this.param.app = t),
            this.minimap = new Rn(this.param)
        }
        onRemove() {
            this.minimap && this.minimap.destroy()
        }
        setPosition(t, e) {
            this.minimap.setPosition(t, e)
        }
        onUpdate() {
            this.minimap && this.minimap.render()
        }
    }
    THING.EarthMiniMapControl = Dn,
    THING.Utils.isNull(THING.MaxConfigParse) || THING.Utils.isNull(THING.MaxConfigParse.enableCameraParse) || (THING.MaxConfigParse.enableCameraParse = !1),
    THING.Utils.isNull(THING.AllConfigParse) || (THING.AllConfigParse.enableParse = !1),
    THING.Utils.isNull(THING.TjsConfigParse) || (THING.TjsConfigParse.enableParse = !1);
    var jn = window.CMAP = {};
    jn.Map = Vt,
    jn.GeoPoint = re,
    jn.GeoLine = oe,
    jn.GroundGeoLine = le,
    jn.GroundGeoPolygon = ce,
    jn.Layer = P,
    jn.ThingLayer = R,
    jn.Tile3dLayer = sn,
    jn.BigDataLayer = Ie,
    jn.TileLayerStyle = it,
    jn.TextureWrapMode = {
        Repeat: "repeat",
        RepeatY: "repeatY",
        Stretch: "stretch"
    },
    jn.GeoBuilding = ve,
    jn.Util = r.a,
    jn.Updater = C.a,
    jn.LayerCollection = f,
    jn.BaseLayerCollection = m,
    jn.UserLayerCollection = g,
    jn.EarthMode = v,
    jn.TileLayer = st,
    jn.EarthCompass = pn,
    jn.EarthMiniMapControl = Dn,
    jn.BigBuildingLayer = ke,
    jn.BigLineLayer = Fe,
    jn.BigPointLayer = Ue,
    jn.Label = Jt,
    jn.GeoDiffusion = je,
    jn.VertexNormalsHelper = An,
    jn.event = new mn,
    THING.TileLayerStyle = it,
    THING.EventType.LayersComplete = "LAYERSCOMPLETE",
    THING.EventType.MapCameraReady = "MapCameraReady",
    THING.EventType.LayerComplete = "LAYERCOMPLETE",
    THING.EventType.BigDataLayerComplete = "BIGDATALAYERCOMPLETE",
    THING.EventType.MapCameraStart = "MapCameraStart",
    THING.Utils.waitAppComplete && THING.Utils.waitAppComplete().then(t=>{
        t || THING.Utils.warn("Failed to get App.current to automatically register MapBundleLoader!"),
        t.registerBundleLoader("map", new Pn),
        t.registerBundleLoader("map-theme", new Sn)
    }
    ),
    jn.pickIdStartNum = 786432,
    jn.GeoLineOnTerrainRenderOrder = 0,
    jn.DisplayMode = {},
    jn.InfoWindowType = {},
    jn.InfoWindowStyle = {},
    jn.DisplayMode.Click = "clickShow",
    jn.DisplayMode.MouseEnter = "mouseoverShow",
    jn.DisplayMode.Always = "oftenShow",
    jn.DisplayMode.None = "none",
    jn.InfoWindowType.Standard = "standard",
    jn.InfoWindowType.Custom = "custom",
    jn.InfoWindowStyle.White = "white",
    jn.InfoWindowStyle.Blue = "blue",
    jn.InfoWindowStyle.Default = jn.InfoWindowStyle.Black = "default",
    jn.Alias = Pt,
    jn.DepthMode = p.a,
    jn.LevelController = d,
    jn.ScanningEffect = x,
    jn.TilingSchemeType = {},
    jn.TilingSchemeType.WebMercator = "WebMercator",
    jn.TilingSchemeType.Baidu = "Baidu",
    jn.TilingSchemeType.Geographic = "Geographic",
    jn.TilingSchemeType.GB = "GB",
    Cesium.BaiduMercatorTilingScheme = Ye,
    Cesium.GBTilingScheme = Ke,
    Cesium.checkHalfAxes = en;
    let Ln = Mt;
    const In = vt.toStr([93, 243, 191, 254]);
    var On = vt.toStr([96, 201, 170, 234, 66, 62, 13, 240, 88, 14, 86, 48, 244, 177, 151, 113, 16, 250, 124, 180, 106, 97, 187, 65, 253, 161])
      , kn = vt.toStr([96, 201, 170, 234, 66, 62, 13, 246, 88, 29, 82, 33, 238, 177, 177, 70, 46, 211, 70]);
    THING[On] = "http://localhost:8008/getKey",
    jn.mapAuthServerUrl = "http://www.thingjs.com/api/getMapAuth/",
    Ln.dispatch({
        type: "k",
        value: "thingjs.com_uearth"
    }),
    THING.__auth_uearth_key__ = function(t) {
        Ln.dispatch({
            type: "k",
            value: t
        })
    }
    ,
    r.a.objectAssign(zt, r.a),
    r.a.objectAssign(Gt, r.a),
    jn.VERSION = function() {
        if ("" !== Ln.getState().v)
            return "1.7.17_" + Ln.getState().v;
        return "1.7.17"
    }(),
    jn.COMPILETIME = "Thu, 16 Feb 2023 07:36:42 GMT",
    THING.Utils.log("CMAP Version:" + jn.VERSION),
    jn.getCurrentMap = function() {
        return jn._map
    }
    ,
    jn.logDepthbuf = !0,
    jn.depthMode = p.a.DepthGlobe,
    jn.depthGlobeRadiusFar = 6377e3,
    jn.depthGlobeRadiusNear = 6377500,
    jn._defaultTime = new Date("2020-07-21T13:00:00")
}
, function(t, e, n) {
    "use strict";
    n.r(e);
    function r(t, e, n) {
        void 0 === n && (n = {});
        var r = {
            type: "Feature"
        };
        return (0 === n.id || n.id) && (r.id = n.id),
        n.bbox && (r.bbox = n.bbox),
        r.properties = e || {},
        r.geometry = t,
        r
    }
    function a(t, e, n) {
        void 0 === n && (n = {});
        for (var a = 0, i = t; a < i.length; a++) {
            var o = i[a];
            if (o.length < 4)
                throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
            for (var s = 0; s < o[o.length - 1].length; s++)
                if (o[o.length - 1][s] !== o[0][s])
                    throw new Error("First and last Position are not equivalent.")
        }
        return r({
            type: "Polygon",
            coordinates: t
        }, e, n)
    }
    function i(t, e, n) {
        return void 0 === n && (n = {}),
        r({
            type: "MultiPolygon",
            coordinates: t
        }, e, n)
    }
    function o(t) {
        return "Feature" === t.type ? t.geometry : t
    }
    var s = n(20)
      , l = n.n(s);
    function u(t, e, n) {
        void 0 === n && (n = {});
        var r = o(t)
          , s = o(e)
          , u = l.a.intersection(r.coordinates, s.coordinates);
        return 0 === u.length ? null : 1 === u.length ? a(u[0], n.properties) : i(u, n.properties)
    }
    n.d(e, "default", function() {
        return u
    })
}
]