!function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? t(exports, require("crypto-js")) : "function" == typeof define && define.amd ? define(["exports", "crypto-js"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).effectTheme = {}, e.CryptoJS)
}(this, (function(exports, t) {
    "use strict";
    function r(e) {
        if (e && e.__esModule)
            return e;
        var t = Object.create(null);
        return e && Object.keys(e).forEach((function(r) {
            if ("default" !== r) {
                var i = Object.getOwnPropertyDescriptor(e, r);
                Object.defineProperty(t, r, i.get ? i : {
                    enumerable: true,
                    get: function() {
                        return e[r]
                    }
                })
            }
        }
        )),
        t.default = e,
        Object.freeze(t)
    }
    var crypto = r(t);
    class GroundObject extends THING.BaseObject {
        constructor(e) {
            super(e),
            this._mesh = null,
            this._url = "",
            this._maskUrl = "",
            this._opacity = 0,
            this._repeatFactor = 1,
            this._glowFactor = 1,
            this._color = null,
            this._sizeFactor = 2,
            this._speed = 1,
            this._flowColor = null,
            this._groundReflect = !1,
            this._groundClearance = .1,
            this._animationType = "flow",
            this._reflectFactor = 1,
            this._repeatFactorInner = 1,
            this._repeatFactorOuter = 1,
            this._repeatFactorX = 1,
            this._repeatFactorY = 1,
            this.targetCampus = null,
            this._isNewVersion = true,
            this._isOuter = true,
            this._isScaleZero = !1,
            this._cacheAllBbx = true,
            this._enableShadow = !1,
            this.tickable = true,
            this.pickable = !1
        }
        customSetup(e) {
            this._url = e.url,
            this._maskUrl = e.maskUrl || this._maskUrl,
            this._opacity = void 0 === e.opacity ? this._opacity : e.opacity,
            this._color = e.color || this._color,
            this._glowFactor = void 0 === e.glowFactor ? this._glowFactor : e.glowFactor,
            this._repeatFactor = void 0 === e.repeatFactor ? this._repeatFactor : e.repeatFactor,
            this._sizeFactor = void 0 === e.sizeFactor ? this._sizeFactor : e.sizeFactor,
            this._speed = void 0 === e.animationSpeed ? this._speed : e.animationSpeed,
            this._flowColor = e.flowColor || this._flowColor,
            this._groundReflect = e.groundReflect || this._groundReflect,
            this._groundClearance = void 0 === e.groundClearance ? this._groundClearance : e.groundClearance,
            this._animationType = e.animationType || this._animationType,
            this._reflectFactor = void 0 === e.reflectFactor ? this._reflectFactor : e.reflectFactor,
            this._reflectFactor = Math.min(this._reflectFactor, 1),
            this._repeatFactorInner = void 0 === e.repeatFactorInner ? this._repeatFactor : e.repeatFactorInner,
            this._repeatFactorOuter = void 0 === e.repeatFactorOuter ? this._repeatFactor : e.repeatFactorOuter,
            this._repeatFactorX = e.repeatFactorX,
            this._repeatFactorY = e.repeatFactorY,
            this._isNewVersion = void 0 === e.isNewVersion ? this._isNewVersion : e.isNewVersion,
            this._isOuter = void 0 === e.isOuter ? this._isOuter : e.isOuter,
            this._cacheAllBbx = void 0 === e.cacheAllBbx ? this._cacheAllBbx : e.cacheAllBbx,
            this._enableShadow = void 0 === e.enableShadow ? this._enableShadow : e.enableShadow,
            this._useShadow = this._enableShadow;
            let t = this._createMaterial(this._url, this._maskUrl, this._opacity, this._repeatFactor, this._color, this._glowFactor, this._speed, this._flowColor, this._groundReflect, this._animationType, this._repeatFactorX, this._repeatFactorY)
              , r = new THREE.PlaneGeometry(1,1)
              , i = new THREE.Mesh(r,t);
            i.receiveShadow = this._enableShadow;
            let n = THING.Utils.parseValue(e.skipBoundingBox, true);
            i.skipBoundingBox(n),
            this._mesh = i,
            this._mesh.rotation.x = -Math.PI / 2,
            this.node.add(this._mesh),
            this.pickable = !1,
            this.groundColorValue = this._color,
            this.flowColorValue = this._flowColor,
            this.targetCampus = void 0 === e.target ? this.app.query(".Campus")[0] : e.target,
            this.updateGround()
        }
        update(e) {
            return super.update(e),
            "ShaderMaterial" == this._mesh.material.type && (this._mesh.material.uniforms.time.value += e),
            true
        }
        destroy() {
            super.destroy()
        }
        setMaterialRoughness(e, t) {
            e.children.length > 0 && this.getChilds(e.children, t),
            e.material && (e.material.roughness = t)
        }
        getChilds(e, t) {
            for (let r = 0; r < e.length; r++)
                this.setMaterialRoughness(e[r], t)
        }
        updateGround() {
            let e = this.app.level.current;
            if ((!e || "Campus" === e.type || "GeoBasePoint" === e.type || e instanceof THING.Floor && e.parent.parent !== this.targetCampus || e instanceof THING.Building && e.parent !== this.targetCampus) && (e = this.targetCampus),
            e instanceof THING.Floor || e instanceof THING.Building || e instanceof THING.Campus) {
                let t;
                e._cacheForGround ? t = e._cacheForGround.bbx : (t = e.getOrientedBox(!1, !1),
                e._cacheForGround = {},
                e._cacheForGround.bbx = t,
                e._cacheForGround.up = e.up,
                e._cacheForGround.worldAngles = e.worldAngles);
                const r = t.size[1] / 2 + .2 - this.groundClearance
                  , i = THING.Math.scaleVector(e._cacheForGround.up, r);
                this.position = THING.Math.subVector(t.center, i),
                t.radius > 0 ? (this.scale = THING.Math.scaleVector([t.radius, 1, t.radius], this._sizeFactor),
                this._isScaleZero = !1) : this._isScaleZero = true,
                this.worldAngles = e._cacheForGround.worldAngles,
                this.groundReflect && (this.app.postEffect = {
                    postEffect: {
                        enable: true,
                        screenSpaceReflection: {
                            maxRayDistance: 200,
                            pixelStride: t.size[1] * this._reflectFactor / 2,
                            pixelStrideZCutoff: 900,
                            screenEdgeFadeStart: .9,
                            eyeFadeStart: .4,
                            eyeFadeEnd: .8
                        }
                    }
                }),
                e instanceof THING.Campus ? this._isNewVersion ? this.visible = this._isOuter && !this._isScaleZero && e.visible : this.repeatFactorOuter && (this.repeatFactorValue = this.repeatFactorOuter) : this._isNewVersion ? this.visible = !this._isOuter && !this._isScaleZero && e.visible : this.repeatFactorInner && (this.repeatFactorValue = this.repeatFactorInner)
            } else
                e || (this.position = [0, this._groundClearance, 0],
                this.scale = [this._sizeFactor, 1, this._sizeFactor])
        }
        _createMaterial(e, t, r, i, n, o, s, a, l, h, c, u) {
            let p = null
              , d = null;
            if (!l) {
                let r = new THREE.TextureLoader;
                p = r.load(e),
                p.wrapS = p.wrapT = THREE.RepeatWrapping,
                d = r.load(t),
                d.wrapS = d.wrapT = THREE.RepeatWrapping
            }
            let f = {
                map: {
                    value: p
                },
                time: {
                    value: 0
                },
                opacity: {
                    value: 1
                },
                alpha: {
                    value: r
                },
                repeatFactor: {
                    value: [c || i, u || i]
                },
                maskMap: {
                    value: d
                },
                color: {
                    value: n
                },
                glowFactor: {
                    value: o
                },
                speed: {
                    value: s
                },
                flowColor: {
                    value: a
                }
            }
              , g = l ? "\n\t\t#include <common>\n\t\t#include <fog_pars_vertex>\n\t\t#include <shadowmap_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\t#include <beginnormal_vertex>\n\t\t\t#include <defaultnormal_vertex>\n\n\t\t\t#include <begin_vertex>\n\t\t\t#include <project_vertex>\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <worldpos_vertex>\n\t\t\t#include <shadowmap_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t    " : "\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\tvarying vec2 vUv;\n\t\tvarying vec2 mapUv;\n\t\t\n\t\tuniform vec2 repeatFactor;\n\n\t\tvoid main() {\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.);\n\n\t\t\tvUv=uv;\n\t\t\tmapUv=uv*repeatFactor;\n\t\t\t#include <logdepthbuf_vertex>\n\t\t}\n\t    "
              , m = l ? "\n\t\tuniform float shadowOpacity;\n\n\t\t#include <common>\n\t\t#include <packing>\n\t\t#include <fog_pars_fragment>\n\t\t#include <bsdfs>\n\t\t#include <lights_pars_begin>\n\t\t#include <shadowmap_pars_fragment>\n\t\t#include <shadowmask_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tvoid main() {\n\n\t\t\tfloat shadowAlpha = 1. - getShadowMask();\n\t\t\tgl_FragColor = vec4( vec3(0.), shadowAlpha * shadowOpacity );\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}\n\t    " : "flow" === h ? "\n\t\t#include <logdepthbuf_pars_fragment>\n\t\tvarying vec2 vUv;\n\t\tvarying vec2 mapUv;  \n\t\tuniform sampler2D map; \n\t\tuniform sampler2D maskMap; \n\t\tuniform float time; \n\t\tuniform float opacity;\n\t\tuniform float alpha; \n\t\tuniform vec3 color; \n\t\tuniform vec3 flowColor; \n\t\tuniform float glowFactor; \n\t\tuniform float speed;  \n\t\tvoid main() {\t \n\t\t\tfloat t=mod(time/5.*speed,1.);       \n\t\t\tvec2 uv=abs((vUv-vec2(0.5))*2.0); \n\t\t\tfloat dis = length(uv); \n\t\t\tfloat r = t-dis;  \n\t\t\tvec4 col=texture2D( map, mapUv ); \n\t\t\tvec3 finalCol; \n\t\t\tvec4 mask = texture2D(maskMap, vec2(0.5,r)); \n\t\t\tfinalCol = mix(color,flowColor,clamp(0.,1.,mask.a*glowFactor)); \n\t\t\tgl_FragColor= vec4(finalCol.rgb,(alpha+mask.a*glowFactor)*col.a*(1.-dis)*opacity);\n\t\t\t#include <logdepthbuf_fragment>\n\t\t}\n\t    " : "\n\t\t#include <logdepthbuf_pars_fragment>\n\t\tvarying vec2 vUv; \n\t\tvarying vec2 mapUv; \n\t\tuniform sampler2D map; \n\t\tuniform sampler2D maskMap; \n\t\tuniform float time; \n\t\tuniform float opacity;\n\t\tuniform float alpha; \n\t\tuniform vec3 color; \n\t\tuniform vec3 flowColor; \n\t\tuniform float glowFactor; \n\t\tuniform float speed;\n\t\tvec2 newUV(vec2 coord,float c,float s) \n\t\t{ \n\t\t\tmat2 m=mat2(c,-s,s,c); \n\t\t\treturn m*coord;\n\t\t}\n\t\tvoid main() {\t \n\t\t\tfloat t=speed*time;       \n\t\t\tvec2 pivot=vec2(0.5,0.5); \n\t\t\tvec2 uv=newUV((vUv-pivot),cos(t),sin(t))+pivot; \n\t\t\tvec4 finalCol;\n\t\t\tif(uv.x>0.&&uv.x<1.&&uv.y>0.&&uv.y<1.) \n\t\t\t{ \n\t\t\t\tfinalCol=vec4(color,opacity*alpha*texture2D( map, uv ).a);\n\t\t\t}\n\t\t\tgl_FragColor= clamp(finalCol,0.,1.); \n\t\t\t#include <logdepthbuf_fragment>\n\t\t}\n        "
              , _ = new THREE.ShaderMaterial({
                uniforms: f,
                vertexShader: g,
                fragmentShader: m,
                transparent: true,
                depthWrite: !1
            });
            return l ? (_.roughness = .1,
            _.lights = true,
            _.uniforms = THREE.UniformsUtils.merge([THREE.UniformsLib.lights, _.uniforms]),
            _.uniforms.shadowOpacity = {
                value: 1
            }) : _.roughness = 1,
            _
        }
        set groundReflect(e) {
            this._groundReflect = e,
            this.tickable = !this._groundReflect;
            let t = this.app.level.current;
            t && ("GeoBasePoint" === t.type && (t = this.app.query(".Campus")[0]),
            this.groundReflect ? (this._mesh.material.roughness = .1,
            this.updateGround()) : this._mesh.material.roughness = 1)
        }
        get groundReflect() {
            return this._groundReflect
        }
        set sizeFactor(e) {
            this._sizeFactor = e,
            this.updateGround()
        }
        get sizeFactor() {
            return this._sizeFactor
        }
        set imageUrl(e) {
            this._url = e;
            let t = (new THREE.TextureLoader).load(this._url);
            t.wrapS = t.wrapT = THREE.RepeatWrapping,
            this._mesh.material.uniforms.map.value = t
        }
        get imageUrl() {
            return this._url
        }
        set maskUrl(e) {
            this._maskUrl = e;
            let t = (new THREE.TextureLoader).load(this._maskUrl);
            t.wrapS = t.wrapT = THREE.RepeatWrapping,
            this._mesh.material.uniforms.maskMap.value = t
        }
        get maskUrl() {
            return this._maskUrl
        }
        set opacityValue(e) {
            this._opacity = e,
            this._mesh.material.uniforms.alpha.value = this._opacity
        }
        get opacityValue() {
            return this._opacity
        }
        set glowFactorValue(e) {
            this._glowFactor = e,
            this._mesh.material.uniforms.glowFactor.value = this._glowFactor
        }
        get glowFactorValue() {
            return this._glowFactor
        }
        set repeatFactorValue(e) {
            this._repeatFactor = e,
            this._mesh.material.uniforms.repeatFactor.value = [this._repeatFactor, this._repeatFactor]
        }
        get repeatFactorValue() {
            return this._repeatFactor
        }
        set repeatFactorOuter(e) {
            this._repeatFactorOuter = e
        }
        get repeatFactorOuter() {
            return this._repeatFactorOuter
        }
        set repeatFactorInner(e) {
            this._repeatFactorInner = e
        }
        get repeatFactorInner() {
            return this._repeatFactorInner
        }
        set repeatFactorX(e) {
            this._mesh.material.uniforms.repeatFactor.value = [e, this._repeatFactorY],
            this._repeatFactorX = e
        }
        get repeatFactorX() {
            return this._repeatFactorX
        }
        set repeatFactorY(e) {
            this._mesh.material.uniforms.repeatFactor.value = [this._repeatFactorX, e],
            this._repeatFactorY = e
        }
        get repeatFactorY() {
            return this._repeatFactorY
        }
        set groundColorValue(e) {
            this._color = new THREE.Color(e),
            this._mesh && (this._mesh.material.uniforms.color.value = this._color)
        }
        get groundColorValue() {
            return this._color
        }
        set flowColorValue(e) {
            this._flowColor = new THREE.Color(e),
            this._mesh && (this._mesh.material.uniforms.flowColor.value = this._flowColor)
        }
        get flowColorValue() {
            return this._flowColor
        }
        set animationSpeed(e) {
            this._speed = e,
            this._mesh.material.uniforms.speed.value = this._speed
        }
        get animationSpeed() {
            return this._speed
        }
        set groundClearance(e) {
            this._groundClearance = e,
            this.updateGround()
        }
        get groundClearance() {
            return this._groundClearance
        }
        set animationType(e) {
            this._animationType = e,
            this._mesh.material = this._createMaterial(this._url, this._maskUrl, this._opacity, this._repeatFactor, this._color, this._glowFactor, this._speed, this._flowColor, this._groundReflect, this._animationType)
        }
        get animationType() {
            return this._animationType
        }
        set reflectFactor(e) {
            this._reflectFactor = e,
            this.updateGround()
        }
        get reflectFactor() {
            return this._reflectFactor
        }
        set shadowOpacityValue(e) {
            this.groundReflect && (this._mesh.material.uniforms.shadowOpacity.value = e)
        }
        get shadowOpacityValue() {
            return this.groundReflect ? this._mesh.material.uniforms.shadowOpacity.value : (console.warn("非反射地面，设置该属性不生效"),
            null)
        }
        set enableShadow(e) {
            this._enableShadow = e,
            this._mesh.receiveShadow = e
        }
        get enableShadow() {
            return this._enableShadow
        }
    }
    function o(e, t) {
        return t.angle - e.angle
    }
    THING.factory.hasClass("GroundObject") || THING.factory.registerClass("GroundObject", GroundObject);
    var s = 0;
    function a(e, t) {
        this.id = s++,
        this.x = e,
        this.y = t,
        this.hedgelist = []
    }
    Object.assign(a.prototype, {
        sortincident: function() {
            this.hedgelist.sort(o)
        },
        dispose: function() {
            this.hedgelist.length = 0
        }
    });
    var l = 0;
    function h(e, t) {
        var r, i, n;
        this.id = l++,
        this.origin = t,
        this.twin = null,
        this.face = null,
        this.nexthedge = null,
        this.angle = (r = t.x - e.x,
        i = t.y - e.y,
        n = Math.sqrt(r * r + i * i),
        i > 0 ? Math.acos(r / n) : 2 * Math.PI - Math.acos(r / n)),
        this.prevhedge = null,
        this.length = Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2))
    }
    function c() {
        this.minX = 1 / 0,
        this.minY = 1 / 0,
        this.maxX = -1 / 0,
        this.maxY = -1 / 0
    }
    function u(e, t) {
        var r, i, n, o, s = 0, a = e.length;
        for (n = e[0],
        r = 1; r <= a; r++)
            o = e[r % a],
            t.x > Math.min(n.x, o.x) && t.x <= Math.max(n.x, o.x) && t.y <= Math.max(n.y, o.y) && n.x != o.x && (i = (t.x - n.x) * (o.y - n.y) / (o.x - n.x) + n.y,
            (n.y == o.y || t.y <= i) && s++),
            n = o;
        return s % 2 != 0
    }
    Object.assign(h.prototype, {
        dispose: function() {
            this.origin = null,
            this.twin = null,
            this.face = null,
            this.nexthedge = null,
            this.prevhedge = null
        }
    }),
    Object.defineProperties(c.prototype, {
        width: {
            get: function() {
                return this.maxX - this.minX
            }
        },
        height: {
            get: function() {
                return this.maxY - this.minY
            }
        }
    }),
    Object.assign(c.prototype, {
        reset: function() {
            this.minX = 1 / 0,
            this.minY = 1 / 0,
            this.maxX = -1 / 0,
            this.maxY = -1 / 0
        },
        expand: function(e) {
            this.minX = Math.min(e.x, this.minX),
            this.minY = Math.min(e.y, this.minY),
            this.maxX = Math.max(e.x, this.maxX),
            this.maxY = Math.max(e.y, this.maxY)
        },
        expands: function(e) {
            for (var t = 0, r = e.length; t < r; t++)
                this.expand(e[t])
        },
        intersects: function(e) {
            return !(e.maxX < this.minX || e.minX > this.maxX || e.maxY < this.minY || e.minY > this.maxY)
        },
        containsPoint: function(e) {
            return e.x <= this.maxX && e.x >= this.minX && e.y <= this.maxY && e.y >= this.minY
        },
        containsPoints: function(e) {
            for (var t = 0, r = e.length; t < r; t++)
                if (!this.containsPoint(e[t]))
                    return !1;
            return true
        },
        size: function() {
            return {
                width: this.maxX - this.minX,
                height: this.maxY - this.minY
            }
        }
    });
    var p = 0;
    function d(e) {
        this.id = p++,
        this.wedge = null,
        this._area = 0,
        this._areaDirty = true,
        this._vertexlist = [],
        this._vertexlistDirty = true,
        this._dcel = e,
        this._holes = [],
        this._holesDirty = true,
        this._aabb = null,
        this._aabbDirty = true
    }
    function f(e, t) {
        this.vertices = [],
        this.hedges = [],
        this.faces = [],
        e && t && this.setDatas(e, t)
    }
    Object.defineProperties(d.prototype, {
        area: {
            get: function() {
                if (this._areaDirty) {
                    for (var e = this.wedge, t = 0; e.nexthedge !== this.wedge; ) {
                        var r = e.origin
                          , i = e.nexthedge.origin;
                        t += r.x * i.y - i.x * r.y,
                        e = e.nexthedge
                    }
                    r = e.origin,
                    i = this.wedge.origin,
                    t = (t + r.x * i.y - i.x * r.y) / 2,
                    this._area = t,
                    this._areaDirty = !1
                }
                return this._area
            }
        },
        areaExceptHoles: {
            get: function() {
                for (var e = this.holes, t = this.area, r = 0, i = e.length; r < i; r++)
                    t += e[r].area;
                return t
            }
        },
        internal: {
            get: function() {
                return this.area > 0
            }
        },
        external: {
            get: function() {
                return this.area <= 0
            }
        },
        vertexlist: {
            get: function() {
                if (this._vertexlistDirty) {
                    var e = this.wedge
                      , t = this._vertexlist;
                    for (t.length = 0,
                    t.push(e.origin); e.nexthedge !== this.wedge; )
                        e = e.nexthedge,
                        t.push(e.origin);
                    this._vertexlistDirty = !1
                }
                return this._vertexlist
            }
        },
        holes: {
            get: function() {
                if (this._holesDirty && (this._holesDirty = !1,
                this._holes.length = 0,
                this.internal))
                    for (var e = this._dcel.faces, t = 0, r = e.length; t < r; t++)
                        this.tryAddHole(e[t]);
                return this._holes
            }
        },
        aabb: {
            get: function() {
                return this._aabb || (this._aabb = new c),
                this._aabbDirty && (this._aabb.reset(),
                this._aabb.expands(this.vertexlist),
                this._aabbDirty = !1),
                this._aabb
            }
        }
    }),
    Object.assign(d.prototype, {
        tryAddHole: function(e) {
            this._holesDirty || e.external && this.area > Math.abs(e.area) && this.aabb.containsPoints(e.vertexlist) && function(e, t) {
                for (var r = 0, i = t.length; r < i; r++)
                    if (!u(e, t[r]))
                        return !1;
                return true
            }(this.vertexlist, e.vertexlist) && this._holes.push(e)
        },
        equals: function(e) {
            var t = this.vertexlist
              , r = e.vertexlist;
            if (t.length !== r.length)
                return !1;
            for (var i = t.length, n = 0; n < i; n++)
                for (var o = 0; o < i && t[o] === r[(n + o) % i]; o++)
                    if (o === i - 1)
                        return true;
            return !1
        },
        dirty: function() {
            this._areaDirty = true,
            this._vertexlistDirty = true,
            this._holesDirty = true,
            this._aabbDirty = true
        },
        dispose: function() {
            this.wedge = null,
            this._vertexlist.length = 0,
            this._holes.length = 0,
            this._aabb = null,
            this._dcel = null
        }
    }),
    Object.assign(f.prototype, {
        setDatas: function(e, t) {
            for (var r = this.vertices, i = this.hedges, n = this.faces, o = 0, s = e.length; o < s; o++) {
                var l = e[o]
                  , c = new a(l[0],l[1]);
                r.push(c)
            }
            for (o = 0,
            s = t.length; o < s; o++) {
                var u = t[o]
                  , p = new h(r[u[0]],r[u[1]])
                  , f = new h(r[u[1]],r[u[0]]);
                p.twin = f,
                f.twin = p,
                r[u[1]].hedgelist.push(p),
                r[u[0]].hedgelist.push(f),
                i.push(f),
                i.push(p)
            }
            for (var g = 0, m = r.length; g < m; g++) {
                if ((c = r[g]).sortincident(),
                0 != (s = c.hedgelist.length))
                    if (s < 2)
                        c.hedgelist[0].prevhedge = c.hedgelist[0].twin,
                        c.hedgelist[0].twin.nexthedge = c.hedgelist[0];
                    else {
                        for (o = 0; o < s - 1; o++)
                            c.hedgelist[o].twin.nexthedge = c.hedgelist[o + 1],
                            c.hedgelist[o + 1].prevhedge = c.hedgelist[o].twin;
                        c.hedgelist[s - 1].twin.nexthedge = c.hedgelist[0],
                        c.hedgelist[0].prevhedge = c.hedgelist[s - 1].twin
                    }
            }
            for (var _ = i.slice(0), v = i.length; v > 0; ) {
                var y = _.pop();
                if (v -= 1,
                null == y.face) {
                    var T = new d(this);
                    for (T.wedge = y,
                    T.wedge.face = T; y.nexthedge !== T.wedge; )
                        (y = y.nexthedge).face = T;
                    n.push(T)
                }
            }
        },
        internalFaces: function() {
            for (var e = [], t = this.faces, r = 0, i = t.length; r < i; r++) {
                var n = t[r];
                n.internal && e.push(n)
            }
            return e
        },
        externalFaces: function() {
            for (var e = [], t = this.faces, r = 0, i = t.length; r < i; r++) {
                var n = t[r];
                n.external && e.push(n)
            }
            return e
        },
        dispose: function() {
            for (var e = this.vertices, t = this.hedges, r = this.faces, i = 0, n = e.length; i < n; i++)
                e[i].dispose();
            for (i = 0,
            n = t.length; i < n; i++)
                t[i].dispose();
            for (i = 0,
            n = r.length; i < n; i++)
                r[i].dispose();
            e.length = 0,
            t.length = 0,
            r.length = 0
        },
        findVertex: function(e, t) {
            for (var r, i = this.vertices, n = 0, o = i.length; n < o; n++)
                if ((r = i[n]).x === e && r.y === t)
                    return r;
            return null
        },
        findHedge: function(e, t, r, i) {
            for (var n, o, s = this.hedges, a = 0, l = s.length; a < l; a++)
                if (o = (n = s[a]).twin,
                n.origin.x === e && n.origin.y === t && o.origin.x === r && o.origin.y === i)
                    return n;
            return null
        },
        addEdge: function(e, t, r, i) {
            var n = this.vertices
              , o = this.hedges
              , s = this.faces
              , l = !1
              , c = !1
              , u = !1
              , p = this.findVertex(e, t);
            p || (p = new a(e,t),
            n.push(p),
            l = true);
            var f = this.findVertex(r, i);
            f || (f = new a(r,i),
            n.push(f),
            c = true);
            var g = new h(f,p);
            o.push(g),
            p.hedgelist.push(g),
            p.sortincident();
            var m = new h(p,f);
            if (o.push(m),
            f.hedgelist.push(m),
            f.sortincident(),
            g.twin = m,
            m.twin = g,
            l)
                g.prevhedge = m,
                m.nexthedge = g;
            else {
                if (0 === (E = p.hedgelist.indexOf(g)))
                    var _ = p.hedgelist[p.hedgelist.length - 1]
                      , v = p.hedgelist[(E + 1) % p.hedgelist.length];
                else
                    _ = p.hedgelist[E - 1],
                    v = p.hedgelist[(E + 1) % p.hedgelist.length];
                g.prevhedge = _.twin,
                _.twin.nexthedge = g,
                m.nexthedge = v,
                v.prevhedge = m
            }
            if (c)
                m.prevhedge = g,
                g.nexthedge = m;
            else {
                if (0 === (E = f.hedgelist.indexOf(m)))
                    _ = f.hedgelist[f.hedgelist.length - 1],
                    v = f.hedgelist[(E + 1) % f.hedgelist.length];
                else
                    _ = f.hedgelist[E - 1],
                    v = f.hedgelist[(E + 1) % f.hedgelist.length];
                m.prevhedge = _.twin,
                _.twin.nexthedge = m,
                g.nexthedge = v,
                v.prevhedge = g
            }
            var y = g.nexthedge
              , T = m.nexthedge;
            y.face && ((E = s.indexOf(y.face)) > -1 && s.splice(E, 1),
            y.face.dispose(),
            y.face.area <= 0 && (u = true));
            var E = s.indexOf(T.face);
            T.face && ((E = s.indexOf(T.face)) > -1 && s.splice(E, 1),
            T.face.dispose(),
            T.face.area <= 0 && (u = true));
            var x = new d(this);
            x.wedge = y;
            var b = new d(this);
            if (b.wedge = T,
            x.equals(b) && (b.dispose(),
            b = null),
            x) {
                for ((w = x.wedge).face = x; w.nexthedge !== x.wedge; )
                    (w = w.nexthedge).face = x;
                x.area <= 0 && (u = true),
                s.push(x)
            }
            if (b) {
                var w;
                for ((w = b.wedge).face = b; w.nexthedge !== b.wedge; )
                    (w = w.nexthedge).face = b;
                b.area <= 0 && (u = true),
                s.push(b)
            }
            if (u)
                for (var F = 0, G = s.length; F < G; F++)
                    s[F]._holesDirty = true
        },
        removeEdge: function(e, t, r, i) {
            var n = this.vertices
              , o = this.hedges
              , s = this.faces
              , a = this.findHedge(e, t, r, i);
            a || console.warn("removeEdge: found no hedge to split!", e, t, r, i);
            var l = a.twin
              , h = a.nexthedge
              , c = l.nexthedge
              , u = true
              , p = true
              , f = !1
              , g = o.indexOf(a);
            o.splice(g, 1);
            g = o.indexOf(l);
            o.splice(g, 1),
            (g = s.indexOf(a.face)) > -1 && s.splice(g, 1),
            a.face.dispose(),
            a.face.area <= 0 && (f = true),
            (g = s.indexOf(l.face)) > -1 && s.splice(g, 1),
            l.face.dispose(),
            l.face.area <= 0 && (f = true);
            g = a.origin.hedgelist.indexOf(a);
            if (a.origin.hedgelist.splice(g, 1),
            a.origin.hedgelist.length > 0) {
                if (0 === g)
                    var m = a.origin.hedgelist[a.origin.hedgelist.length - 1]
                      , _ = a.origin.hedgelist[g];
                else
                    m = a.origin.hedgelist[g - 1],
                    _ = a.origin.hedgelist[g % a.origin.hedgelist.length];
                _.prevhedge = m.twin,
                m.twin.nexthedge = _
            } else {
                var v = n.indexOf(a.origin);
                n.splice(v, 1),
                a.origin.dispose(),
                p = !1
            }
            g = l.origin.hedgelist.indexOf(l);
            if (l.origin.hedgelist.splice(g, 1),
            l.origin.hedgelist.length > 0) {
                if (0 === g)
                    m = l.origin.hedgelist[l.origin.hedgelist.length - 1],
                    _ = l.origin.hedgelist[g];
                else
                    m = l.origin.hedgelist[g - 1],
                    _ = l.origin.hedgelist[g % l.origin.hedgelist.length];
                _.prevhedge = m.twin,
                m.twin.nexthedge = _
            } else {
                v = n.indexOf(l.origin);
                n.splice(v, 1),
                l.origin.dispose(),
                u = !1
            }
            a.dispose(),
            l.dispose();
            var y = u ? new d(this) : null;
            y && (y.wedge = h);
            var T = p ? new d(this) : null;
            if (T && (T.wedge = c),
            y && T && y.equals(T) && (T.dispose(),
            T = null),
            y) {
                for ((E = y.wedge).face = y; E.nexthedge !== y.wedge; )
                    (E = E.nexthedge).face = y;
                y.area <= 0 && (f = true),
                s.push(y)
            }
            if (T) {
                var E;
                for ((E = T.wedge).face = T; E.nexthedge !== T.wedge; )
                    (E = E.nexthedge).face = T;
                T.area <= 0 && (f = true),
                s.push(T)
            }
            if (f)
                for (var x = 0, b = s.length; x < b; x++)
                    s[x]._holesDirty = true
        },
        splitEdge: function(e, t, r, i, n, o) {
            var s = this.vertices
              , l = this.hedges
              , c = this.findHedge(e, t, r, i);
            c || console.warn("splitEdge: found no hedge to split!", e, t, r, i);
            var u = c.twin
              , p = new a(n,o);
            s.push(p);
            var d = new h(p,c.origin)
              , f = new h(u.origin,p);
            l.push(d),
            l.push(f);
            var g = new h(p,u.origin)
              , m = new h(c.origin,p);
            l.push(g),
            l.push(m),
            c.face.wedge === c && (c.face.wedge = d),
            c.face._vertexlistDirty = true,
            d.face = c.face,
            f.face = c.face,
            u.face.wedge === u && (u.face.wedge = g),
            u.face._vertexlistDirty = true,
            g.face = u.face,
            m.face = u.face,
            d.nexthedge = f,
            f.prevhedge = d,
            g.nexthedge = m,
            m.prevhedge = g,
            d.prevhedge = c.prevhedge !== u ? c.prevhedge : m,
            d.prevhedge.nexthedge = d,
            f.nexthedge = c.nexthedge !== u ? c.nexthedge : g,
            f.nexthedge.prevhedge = f,
            g.prevhedge = u.prevhedge !== c ? u.prevhedge : f,
            g.prevhedge.nexthedge = g,
            m.nexthedge = u.nexthedge !== c ? u.nexthedge : d,
            m.nexthedge.prevhedge = m,
            d.twin = m,
            f.twin = g,
            g.twin = f,
            m.twin = d,
            p.hedgelist.push(f, m);
            var _ = c.origin.hedgelist.indexOf(c);
            c.origin.hedgelist.splice(_, 1, d);
            _ = u.origin.hedgelist.indexOf(u);
            u.origin.hedgelist.splice(_, 1, g),
            c.dispose(),
            u.dispose();
            _ = l.indexOf(c);
            l.splice(_, 1);
            _ = l.indexOf(u);
            l.splice(_, 1)
        }
    });
    class g extends THING.Shape {
        constructor(e) {
            super(e)
        }
        createMesh(e) {
            const t = new THREE.Color;
            t.set(e.style.color),
            e.style.color = t,
            super.createMesh(e)
        }
        destroy() {
            super.destroy()
        }
        update(e) {
            super.update(e)
        }
        set color(e) {
            const t = new THREE.Color;
            t.set(e),
            this.style.color = t
        }
        get color() {
            return this.style.color
        }
        set opacity(e) {
            this.style.opacity = e
        }
        get opacity() {
            return this.style.opacity
        }
        set floorHeight(e) {
            this.scale = [1, e, 1],
            this.localPosition = [0, .5 * -e, 0]
        }
        get floorHeight() {
            return this.scale[1]
        }
    }
    THING.factory.hasClass("ClonedFloor") || THING.factory.registerClass("ClonedFloor", g);
    class m extends THING.Boundary {
        constructor(e) {
            super(e)
        }
        customSetup(e) {
            super.customSetup(e),
            this._floorHeight = e.floorHeight,
            this._lineHeight = e.height,
            this.localPositionType = e.localPositionType
        }
        destroy() {
            super.destroy()
        }
        update(e) {
            super.update(e)
        }
        set color(e) {
            const t = new THREE.Color;
            t.set(e),
            this._material.color = t
        }
        get color() {
            return this._material.color
        }
        set opacity(e) {
            this._material.opacity = e
        }
        get opacity() {
            return this._material.opacity
        }
        set lineHeight(e) {
            this.height = e,
            this._lineHeight = e,
            this.localPosition = [0, 1 === this.localPositionType ? .5 * -this._lineHeight : 2 === this.localPositionType ? .5 * this._floorHeight - this._lineHeight : .5 * -this._floorHeight, 0]
        }
        get lineHeight() {
            return this._lineHeight
        }
        set floorHeight(e) {
            this._floorHeight = e,
            this.localPosition = [0, 1 === this.localPositionType ? .5 * -this._lineHeight : 2 === this.localPositionType ? .5 * this._floorHeight - this._lineHeight : .5 * -this._floorHeight, 0]
        }
        get floorHeight() {
            return this._floorHeight
        }
    }
    THING.factory.hasClass("ClonedLine") || THING.factory.registerClass("ClonedLine", m);
    const _ = 1
      , v = 2
      , y = 3;
    function T(e, t, r) {
        for (let r = 0; r < t.length; r++) {
            if (E(t[r], e, .01))
                return r
        }
        return r.push([e[0], e[2]]),
        t.push(e) - 1
    }
    function E(e, t, r) {
        if (void 0 === e || void 0 === t)
            return !1;
        if (void 0 !== r && 0 != r || (r = .002),
        "number" == typeof e && "number" == typeof t)
            return Math.abs(e - t) <= r;
        if (e.length > 0 && t.length > 0 && e.length == t.length) {
            for (let i = 0; i < e.length; i++) {
                const n = e[i]
                  , o = t[i];
                if (Math.abs(n - o) > r)
                    return !1
            }
            return true
        }
        return !1
    }
    function x(e, t) {
        let r = [];
        for (let i = 0; i < e.length; i++) {
            let n = e[i]
              , o = e[i === e.length - 1 ? 0 : i + 1]
              , s = e[0 === i ? e.length - 1 : i - 1]
              , a = new THREE.Vector2(o.x - n.x,o.y - n.y)
              , l = new THREE.Vector2(n.x - s.x,n.y - s.y)
              , h = a.normalize().add(l.normalize()).normalize();
            r.push([e[i].x - h.y * t, e[i].y + h.x * t])
        }
        return r
    }
    function b(e, t, r, i, n, o, s, a, l, h) {
        if ("Building" === e.type) {
            let c, u, p, d, g, m;
            e.floors.forEach(((e,_)=>{
                if (o) {
                    if (_ % 2 == 0 && (p = [],
                    d = [],
                    g = [],
                    m = [],
                    e.rooms.length > 0)) {
                        e.rooms.forEach((t=>{
                            let r = t.points
                              , i = [];
                            r.forEach(((t,r)=>{
                                i.push(e.worldToSelf(t))
                            }
                            ));
                            let n = r.length;
                            i.forEach(((e,t)=>{
                                let r = t + 1 < n ? t + 1 : 0;
                                g.push([T(e, m, d), T(i[r], m, d)])
                            }
                            ))
                        }
                        )),
                        c = new f(d,g),
                        u = c.externalFaces().slice(0),
                        u.sort((function(e, t) {
                            return e.area - t.area
                        }
                        )),
                        x(u[0].vertexlist, n).forEach((function(e) {
                            p.push([e[0], e[1]])
                        }
                        ));
                        let o = s.create({
                            name: a,
                            id: l,
                            type: "ClonedFloor",
                            height: t,
                            points: p,
                            style: {
                                color: r
                            },
                            parent: e,
                            inheritTheme: !1
                        });
                        o.pickable = !1,
                        o.style.opacity = i,
                        o.localPosition = [0, 0, 0],
                        o.node.children[0].position.set(0, 0, 0),
                        o.node.children[0].rotation.set(0, 0, 0),
                        o.userData.SKIP_THEME = true,
                        o.style.renderOrder = 200,
                        o.userData.sceneId = h,
                        o.localPosition = [0, .5 * -t, 0],
                        c.dispose()
                    }
                } else if (p = [],
                d = [],
                g = [],
                m = [],
                e.rooms.length > 0) {
                    e.rooms.forEach((t=>{
                        let r = t.points
                          , i = [];
                        r.forEach(((t,r)=>{
                            i.push(e.worldToSelf(t))
                        }
                        ));
                        let n = r.length;
                        i.forEach(((e,t)=>{
                            let r = t + 1 < n ? t + 1 : 0;
                            g.push([T(e, m, d), T(i[r], m, d)])
                        }
                        ))
                    }
                    )),
                    c = new f(d,g),
                    u = c.externalFaces().slice(0),
                    u.sort((function(e, t) {
                        return e.area - t.area
                    }
                    )),
                    x(u[0].vertexlist, n).forEach((function(e) {
                        p.push([e[0], e[1]])
                    }
                    ));
                    let o = s.create({
                        name: a,
                        id: l,
                        type: "ClonedFloor",
                        height: t,
                        points: p,
                        style: {
                            color: r
                        },
                        parent: e,
                        inheritTheme: !1
                    });
                    o.pickable = !1,
                    o.style.opacity = i,
                    o.localPosition = [0, 0, 0],
                    o.node.children[0].position.set(0, 0, 0),
                    o.node.children[0].rotation.set(0, 0, 0),
                    o.userData.SKIP_THEME = true,
                    o.style.renderOrder = 200,
                    o.userData.sceneId = h,
                    o.localPosition = [0, .5 * -t, 0],
                    c.dispose()
                }
            }
            ))
        } else
            console.warn("传入的参数building不对，请传入正确的建筑类型！")
    }
    function w(e, t, r, i, n, o, s, a, l, h, c, u) {
        if ("Building" === e.type) {
            let p, d, g, m, _, v;
            e.floors.forEach(((e,y)=>{
                if (o) {
                    if (y % 2 == 0 && (g = [],
                    m = [],
                    _ = [],
                    v = [],
                    e.rooms.length > 0)) {
                        e.rooms.forEach((t=>{
                            let r = t.points
                              , i = [];
                            r.forEach(((t,r)=>{
                                i.push(e.worldToSelf(t))
                            }
                            ));
                            let n = r.length;
                            i.forEach(((e,t)=>{
                                let r = t + 1 < n ? t + 1 : 0;
                                m.push([T(e, _, g), T(i[r], _, g)])
                            }
                            ))
                        }
                        )),
                        p = new f(g,m),
                        d = p.externalFaces().slice(0),
                        d.sort((function(e, t) {
                            return e.area - t.area
                        }
                        ));
                        let o = x(d[0].vertexlist, t);
                        o.forEach((function(e) {
                            v.push([e[0], 0, e[1]])
                        }
                        )),
                        v.push([o[0][0], 0, o[0][1]]);
                        let y = s.create({
                            name: a,
                            id: l,
                            type: "ClonedLine",
                            height: r,
                            parent: e,
                            inheritTheme: !1,
                            floorHeight: u,
                            localPositionType: c
                        });
                        y.addPoints(v, THING.SpaceType.Self),
                        y._material.polygonOffset = true,
                        y._material.polygonOffsetFactor = -1,
                        y._material.polygonOffsetUnits = -1,
                        y._material.map = null,
                        y._material.color = new THREE.Color(i),
                        y._material.opacity = n,
                        y._material.transparent = true,
                        y._material.needsUpdate = true,
                        y.localPosition = [0, 1 === c ? .5 * -r : 2 === c ? .5 * u - r : .5 * -u, 0],
                        y.style.renderOrder = 200,
                        y.userData.SKIP_THEME = true,
                        y.userData.sceneId = h,
                        0 === r && (y.height = 0),
                        p.dispose()
                    }
                } else if (g = [],
                m = [],
                _ = [],
                v = [],
                e.rooms.length > 0) {
                    e.rooms.forEach((t=>{
                        let r = t.points
                          , i = [];
                        r.forEach(((t,r)=>{
                            i.push(e.worldToSelf(t))
                        }
                        ));
                        let n = r.length;
                        i.forEach(((e,t)=>{
                            let r = t + 1 < n ? t + 1 : 0;
                            m.push([T(e, _, g), T(i[r], _, g)])
                        }
                        ))
                    }
                    )),
                    p = new f(g,m),
                    d = p.externalFaces().slice(0),
                    d.sort((function(e, t) {
                        return e.area - t.area
                    }
                    ));
                    let o = x(d[0].vertexlist, t);
                    o.forEach((function(e) {
                        v.push([e[0], 0, e[1]])
                    }
                    )),
                    v.push([o[0][0], 0, o[0][1]]);
                    let y = s.create({
                        name: a,
                        id: l,
                        type: "ClonedLine",
                        height: r,
                        parent: e,
                        inheritTheme: !1,
                        floorHeight: u,
                        localPositionType: c
                    });
                    y.addPoints(v, THING.SpaceType.Self),
                    y._material.polygonOffset = true,
                    y._material.polygonOffsetFactor = -1,
                    y._material.polygonOffsetUnits = -1,
                    y._material.map = null,
                    y._material.color = new THREE.Color(i),
                    y._material.opacity = n,
                    y._material.transparent = true,
                    y._material.needsUpdate = true,
                    y.localPosition = [0, 1 === c ? .5 * -r : 2 === c ? .5 * u - r : .5 * -u, 0],
                    y.style.renderOrder = 200,
                    y.userData.SKIP_THEME = true,
                    y.userData.sceneId = h,
                    0 === r && (y.height = 0),
                    p.dispose()
                }
            }
            ))
        } else
            console.warn("传入的参数building不对，请传入正确的建筑类型！")
    }
    var ClonedFloorUtils = {
        createClonedFloors: function(e) {
            const t = e.buildings
              , r = e.floorHeight
              , i = e.color || "#0000ff"
              , n = e.scaleFactor
              , o = void 0 === e.opacity ? 1 : e.opacity
              , s = void 0 === e.isInterlayerDisplay || e.isInterlayerDisplay
              , a = THING.App.current
              , l = e.name || "楼板"
              , h = e.id || l
              , c = e.sceneId || 0;
            if (Array.isArray(t) || t.isSelector ? t.forEach((e=>{
                b(e, r, i, o, n, s, a, l, h, c)
            }
            )) : b(t, r, i, o, n, s, a, l, h, c),
            "Campus" === a.level.current.type) {
                a.query(l).forEach((e=>{
                    e.visible = true
                }
                ))
            }
            a.on(THING.EventType.EnterLevel, (e=>{
                if ("Campus" === e.current.type) {
                    a.query(l).forEach((e=>{
                        e.visible = true
                    }
                    ))
                }
            }
            ), "levelFlyEndToShowCloneGround")
        },
        destroyClonedFloors: function(e, t) {
            const r = THING.App.current;
            if (Array.isArray(e) || e.isSelector)
                e.forEach((e=>{
                    e.query(t).forEach((e=>{
                        e.destroy()
                    }
                    ))
                }
                ));
            else {
                e.query(t).forEach((e=>{
                    e.destroy()
                }
                ))
            }
            r.off(THING.EventType.EnterLevel, null, "levelFlyEndToShowCloneGround")
        },
        createDoubleLines: function(e) {
            const t = e.buildings
              , r = e.floorHeight
              , i = e.scaleFactor
              , n = e.lineHeight
              , o = e.color || "#ff0000"
              , s = void 0 === e.opacity ? 1 : e.opacity
              , a = void 0 === e.isInterlayerDisplay || e.isInterlayerDisplay
              , l = THING.App.current
              , h = e.name || "双线"
              , c = e.id || h
              , u = e.sceneId || 0;
            if (Array.isArray(t) || t.isSelector ? t.forEach((e=>{
                w(e, i, n, o, s, a, l, h, c, u, v, r),
                w(e, i, n, o, s, a, l, h, c, u, y, r)
            }
            )) : (w(t, i, n, o, s, a, l, h, c, u, v, r),
            w(t, i, n, o, s, a, l, h, c, u, y, r)),
            "Campus" === l.level.current.type) {
                l.query(h).forEach((e=>{
                    e.visible = true
                }
                ))
            }
            l.on(THING.EventType.EnterLevel, (e=>{
                if ("Campus" === e.current.type) {
                    l.query(h).forEach((e=>{
                        e.visible = true
                    }
                    ))
                }
            }
            ), "levelFlyEndToShowDoubleLines")
        },
        destroyDoubleLines: function(e, t) {
            const r = THING.App.current;
            if (Array.isArray(e) || e.isSelector)
                e.forEach((e=>{
                    e.query(t).forEach((e=>{
                        e.destroy()
                    }
                    ))
                }
                ));
            else {
                e.query(t).forEach((e=>{
                    e.destroy()
                }
                ))
            }
            r.off(THING.EventType.EnterLevel, null, "levelFlyEndToShowDoubleLines")
        },
        createSingleLines: function(e) {
            const t = e.buildings
              , r = e.floorHeight
              , i = e.scaleFactor
              , n = e.lineHeight
              , o = e.color || "#ff0000"
              , s = void 0 === e.opacity ? 1 : e.opacity
              , a = void 0 === e.isInterlayerDisplay || e.isInterlayerDisplay
              , l = THING.App.current
              , h = e.name || "单线"
              , c = e.id || h
              , u = e.sceneId || 0;
            if (Array.isArray(t) || t.isSelector ? t.forEach((e=>{
                w(e, i, n, o, s, a, l, h, c, u, _, r)
            }
            )) : w(t, i, n, o, s, a, l, h, c, u, _, r),
            "Campus" === l.level.current.type) {
                l.query(h).forEach((e=>{
                    e.visible = true
                }
                ))
            }
            l.on(THING.EventType.EnterLevel, (e=>{
                if ("Campus" === e.current.type) {
                    l.query(h).forEach((e=>{
                        e.visible = true
                    }
                    ))
                }
            }
            ), "levelFlyEndToShowLines")
        },
        destroySingleLines: function(e, t) {
            const r = THING.App.current;
            if (Array.isArray(e) || e.isSelector)
                e.forEach((e=>{
                    e.query(t).forEach((e=>{
                        e.destroy()
                    }
                    ))
                }
                ));
            else {
                e.query(t).forEach((e=>{
                    e.destroy()
                }
                ))
            }
            r.off(THING.EventType.EnterLevel, null, "levelFlyEndToShowLines")
        },
        getOuterContourWorldPoints: function(e, t=0) {
            if ("Floor" === e.type && "F1" === e.name) {
                let r, i, n, o, s, a, l;
                if (n = [],
                o = [],
                s = [],
                a = [],
                l = [],
                e.rooms.length > 0) {
                    e.rooms.forEach((t=>{
                        let r = t.points
                          , i = [];
                        r.forEach(((t,r)=>{
                            i.push(e.worldToSelf(t))
                        }
                        ));
                        let n = r.length;
                        i.forEach(((e,t)=>{
                            let r = t + 1 < n ? t + 1 : 0;
                            s.push([T(e, a, o), T(i[r], a, o)])
                        }
                        ))
                    }
                    )),
                    r = new f(o,s),
                    i = r.externalFaces().slice(0),
                    i.sort((function(e, t) {
                        return e.area - t.area
                    }
                    )),
                    x(i[0].vertexlist, t).forEach((function(e) {
                        n.push([e[0], 0, e[1]])
                    }
                    )),
                    n.forEach((function(t) {
                        l.push(e.selfToWorld(t))
                    }
                    ))
                }
                return r.dispose(),
                l
            }
            console.warn("传入的参数floor不对，请传入第一层的楼层！")
        }
    };
    function G(e, t) {
        const r = e.orientedBoundingBox;
        let i;
        e.facadeSize ? i = e.facadeSize : (i = r.size,
        e.facadeSize = JSON.parse(JSON.stringify(i)));
        const n = Math.min(...i) * (t.scaleFactor - 1);
        return i = THING.Math.divideVector(i, e.node.getWorldScale(new THREE.Vector3).toArray()),
        {
            orientSize: i,
            diff: n
        }
    }
    function C(e, t, r, i) {
        const n = []
          , o = THING.App.current.create({
            type: "Box",
            name: "facadeBox" + t.name,
            localPosition: r,
            width: i[0],
            height: i[1],
            depth: i[2],
            style: {
                color: t.color,
                opacity: t.opacity,
                doubleSide: true,
                renderOrder: void 0 === t.renderOrder ? 100 : t.renderOrder,
                _skipApplyTheme: true
            },
            parent: e,
            queryable: !1
        });
        n.push(o);
        const s = function(e, t, r) {
            const i = []
              , n = r.orientedBoundingBox.points;
            return [[0, 1], [1, 3], [3, 2], [2, 0], [4, 5], [5, 7], [7, 6], [6, 4], [0, 4], [1, 5], [2, 6], [3, 7]].forEach((r=>{
                const o = [];
                r.forEach((e=>{
                    o.push(n[e])
                }
                ));
                const s = THING.App.current.create({
                    type: "Line",
                    name: "facadeLine" + t.name,
                    points: o,
                    visible: t.wireframe.enable,
                    style: {
                        color: t.wireframe.color,
                        opacity: t.wireframe.opacity,
                        doubleSide: true,
                        renderOrder: void 0 === t.wireframe.renderOrder ? 99 : t.wireframe.renderOrder,
                        skipBoundingBox: true,
                        _skipApplyTheme: true
                    },
                    parent: e,
                    queryable: !1
                });
                s.style.skipOutline = true,
                s.pickable = !1,
                i.push(s)
            }
            )),
            i
        }(e, t, o);
        return o.style.skipBoundingBox = true,
        o.style.skipOutline = true,
        o.pickable = !1,
        o.inheritStyle = !1,
        n.push(...s),
        n
    }
    function H(e, t) {
        const {orientSize: r, diff: i} = G(e, t)
          , n = e.orientedBoundingBox.center
          , o = [r[0] + i, r[1] + i / 2, r[2] + i]
          , s = e.worldToSelf(n);
        return C(e, t, s, o)
    }
    function M(e, t) {
        const {orientSize: r, diff: i} = G(e, t)
          , n = e.orientedBoundingBox.center
          , o = [r[0] + i, t.thickness / e.scale[1], r[2] + i]
          , s = e.worldToSelf(n)
          , a = [];
        if ("norepeat" === t.repeat)
            for (let i = 0; i < t.count; i++) {
                const n = t.interval / e.scale[1] * i
                  , l = [s[0], s[1] + n - .5 * r[1], s[2]];
                a.push(...C(e, t, l, o))
            }
        else {
            let i = 0;
            for (; i <= r[1]; ) {
                const n = [s[0], s[1] + i - .5 * r[1], s[2]];
                a.push(...C(e, t, n, o)),
                i += t.interval / e.scale[1]
            }
        }
        return a
    }
    function I(e, t) {
        const {orientSize: r, diff: i} = G(e, t)
          , n = e.orientedBoundingBox.center
          , o = [r[0] + i, t.thickness / e.scale[1], r[2] + i]
          , s = e.worldToSelf(n)
          , a = [];
        if ("norepeat" === t.repeat)
            for (let i = 0; i < t.count; i++) {
                const n = r[1] - t.interval / e.scale[1] * i
                  , l = [s[0], s[1] + n - .5 * r[1], s[2]];
                a.push(...C(e, t, l, o))
            }
        else {
            let i = r[1];
            for (; i >= 0; ) {
                const n = [s[0], s[1] + i - .5 * r[1], s[2]];
                a.push(...C(e, t, n, o)),
                i -= t.interval / e.scale[1]
            }
        }
        return a
    }
    function O(e, t) {
        const {orientSize: r, diff: i} = G(e, t)
          , n = [t.thickness / e.scale[0], r[1] + i / 2, r[2] + i]
          , o = e.orientedBoundingBox.center
          , s = e.worldToSelf(o);
        let a = -r[0] / 2;
        const l = [];
        if ("norepeat" === t.repeat)
            for (let r = 0; r < t.count; r++) {
                const r = [s[0] + a, s[1], s[2]];
                l.push(...C(e, t, r, n)),
                a += t.interval / e.scale[0]
            }
        else
            for (; a <= r[0] / 2; ) {
                const r = [s[0] + a, s[1], s[2]];
                l.push(...C(e, t, r, n)),
                a += t.interval / e.scale[0]
            }
        return l
    }
    function S(e, t) {
        const {orientSize: r, diff: i} = G(e, t)
          , n = [t.thickness / e.scale[0], r[1] + i / 2, r[2] + i]
          , o = e.orientedBoundingBox.center
          , s = e.worldToSelf(o);
        let a = r[0] / 2;
        const l = [];
        if ("norepeat" === t.repeat)
            for (let r = 0; r < t.count; r++) {
                const r = [s[0] + a, s[1], s[2]];
                l.push(...C(e, t, r, n)),
                a -= t.interval / e.scale[0]
            }
        else
            for (; a >= -r[0] / 2; ) {
                const r = [s[0] + a, s[1], s[2]];
                l.push(...C(e, t, r, n)),
                a -= t.interval / e.scale[0]
            }
        return l
    }
    function N(e, t) {
        const {orientSize: r, diff: i} = G(e, t)
          , n = [r[0] + i, r[1] + i / 2, t.thickness / e.scale[2]]
          , o = e.orientedBoundingBox.center
          , s = e.worldToSelf(o);
        let a = r[2] / 2;
        const l = [];
        if ("norepeat" === t.repeat)
            for (let r = 0; r < t.count; r++) {
                const r = [s[0], s[1], s[2] + a];
                l.push(...C(e, t, r, n)),
                a -= t.interval / e.scale[2]
            }
        else
            for (; a >= -r[2] / 2; ) {
                const r = [s[0], s[1], s[2] + a];
                l.push(...C(e, t, r, n)),
                a -= t.interval / e.scale[2]
            }
        return l
    }
    function P(e, t) {
        const {orientSize: r, diff: i} = G(e, t)
          , n = [r[0] + i, r[1] + i / 2, t.thickness / e.scale[2]]
          , o = e.orientedBoundingBox.center
          , s = e.worldToSelf(o);
        let a = -r[2] / 2;
        const l = [];
        if ("norepeat" === t.repeat)
            for (let r = 0; r < t.count; r++) {
                const r = [s[0], s[1], s[2] + a];
                l.push(...C(e, t, r, n)),
                a += t.interval / e.scale[2]
            }
        else
            for (; a <= r[2] / 2; ) {
                const r = [s[0], s[1], s[2] + a];
                l.push(...C(e, t, r, n)),
                a += t.interval / e.scale[2]
            }
        return l
    }
    var FacadeEffectUtils = {
        addFacadeBoxToScene: function(e) {
            const t = function() {
                const e = THING.App.current.query(".Facade");
                for (var t = e.length - 1; t >= 0; t--) {
                    const r = e[t];
                    r.query(".CombinedObject").length > 0 ? (e.splice(t, 1),
                    e.add(r.query(".CombinedObject"))) : r.query(".Facade").length > 0 && e.splice(t, 1)
                }
                return e
            }();
            let r, i = [];
            for (let n = 0; n < t.length; n++) {
                switch (e.type) {
                case "box":
                    r = H(t[n], e);
                    break;
                case "top":
                    r = I(t[n], e);
                    break;
                case "down":
                    r = M(t[n], e);
                    break;
                case "left":
                    r = O(t[n], e);
                    break;
                case "right":
                    r = S(t[n], e);
                    break;
                case "front":
                    r = N(t[n], e);
                    break;
                case "back":
                    r = P(t[n], e)
                }
                i.push(...r)
            }
            return i
        }
    };
    class EffectThemeControl {
        constructor(e) {
            this._controls = null,
            e = e || {},
            this.autoUpdate = void 0 === e.autoUpdate || e.autoUpdate,
            this.fadeTween = null,
            this.isFadeIn = void 0 !== e.isFadeIn && e.isFadeIn,
            this.environmentMap = Object.create(null)
        }
        onResize() {}
        onUpdate() {}
        onAdd(e) {
            this.app = e,
            this.ThemeManager = {
                _objGround: new WeakMap,
                _objParticle: new WeakMap,
                _objFacade: new WeakMap
            },
            this.currentEnv = null,
            this.isFadeIn && this._onEnterAnimation()
        }
        onRemove() {
            this._controls && (this.app.off(THING.EventType.EnterLevel, null, "ThemeEnterLevelToUpdateEnv"),
            this.isFadeIn && this._offEnterAnimation(),
            this._controls.dispose(),
            this._controls = null)
        }
        getBackground(e="default") {
            let t = THING.ThemeManager.findStyle(e);
            return {
                inner: {
                    background: t.__innerBackground
                },
                outer: {
                    background: t.__outerBackground
                }
            }
        }
        registerTheme(e="default", modelData, modelDataUrl, i=true, n) {
            let o = this._decrypt(JSON.parse(JSON.stringify(modelData)));
            if (this._versiongt(THING.VERSION, "1.2.7.18") && (this._versiongt(o.version, "1.6.4") || console.warn("Theme version is out of date. Requires theme version 1.6.4 or later, but the current version is " + modelData.version + ".")),
            this._versiongt(o.version, "1.6.4") && (this._versiongt(THING.VERSION, "1.2.7.26") || console.warn("Theme version is " + o.version + ", recommended to use 1.2.7.26 or later version of thing.js")),
            modelDataUrl ? (this._validationEnd(modelDataUrl, "/") || (modelDataUrl += "/"),
            o.resourcePrefix = modelDataUrl) : modelDataUrl = o.resourcePrefix,
            o.ground && o.ground.enable && o.ground.item.length > 0) {
                let e = o.ground.item.length;
                for (let t = 0; t < e; t++) {
                    let e = o.ground.item[t];
                    this._isHttpUrl(e.url) || (e.url = modelDataUrl + e.url),
                    this._isHttpUrl(e.maskUrl) || (e.maskUrl = modelDataUrl + e.maskUrl)
                }
            }
            if (o.innerGround && o.innerGround.enable) {
                let e = o.innerGround.item.length;
                for (let t = 0; t < e; t++) {
                    let e = o.innerGround.item[t];
                    this._isHttpUrl(e.url) || (e.url = modelDataUrl + e.url),
                    this._isHttpUrl(e.maskUrl) || (e.maskUrl = modelDataUrl + e.maskUrl)
                }
            }
            if (o.particle && o.particle.enable && o.particle.item.length > 0) {
                let e = o.particle.item.length;
                for (let t = 0; t < e; t++) {
                    let e = o.particle.item[t];
                    this._isHttpUrl(e.url) || (e.url = modelDataUrl + e.url),
                    e.themePkg = modelDataUrl
                }
            }
            i ? (o.__innerBackground = o.inner.background,
            o.outer && (o.__outerBackground = o.outer.background)) : (o.__innerBackground = o.inner.background,
            o.inner.background = null,
            o.outer && (o.__outerBackground = o.outer.background,
            o.outer.background = null)),
            n && void 0 !== n.type && void 0 !== n.value && (o.enviroment = n,
            o.enviroment.noPrefix = true),
            THING.ThemeManager.register(e, o)
        }
        async applyEffectTheme(themeName="default", campus, r=true) {
            if (campus) {
                if ("Campus" !== campus.type)
                    throw new TypeError('第二个参数类型必须为"Campus"!')
            } else
                campus = this.app.query(".Campus")[0];
            if (!(campus && campus.ground && campus.ground.plan))
                throw new TypeError("此时园区未加载完成！请在园区加载完后,再应用效果模板。");
            if (themeName) {
                let style = THING.ThemeManager.findStyle(themeName);
                if (!style)
                    throw new TypeError("找不到该模板！请先注册模板后再应用");
                if (this._themePromise = [],
                !style.extFunc || style.extFunc.contains("THING.THEMEVERSION")) {
                    let params = {
                        ground: style.ground,
                        innerGround: style.innerGround,
                        particle: style.particle,
                        ThemeManager: this.ThemeManager,
                        inner: style.inner,
                        outer: style.outer,
                        floors: style.floors,
                        facadeEffect: style.facadeEffect
                    };
                    params = params || {},
                    campus = "Campus" === campus.type ? campus : "Building" === campus.type ? campus.parent : campus.parent.parent,
                    params.ground && Object.keys(params.ground).length > 0 || params.innerGround && Object.keys(params.innerGround).length > 0 ? this._versiongt(style.version, "1.8.0") ? (this._destroyGroundDecorate(campus, params),
                    this._setGroundDecorate(campus, params, true, r),
                    this._destroyClonedFloors(campus, params),
                    this._setClonedFloors(params, campus)) : (this._destroyGroundDecorate(campus, params),
                    this._setGroundDecorate(campus, params)) : this._destroyGroundDecorate(campus, params),
                    params.particle && Object.keys(params.particle).length > 0 ? (this._destroyParticle(campus, params),
                    this._setParticle(params, campus)) : this._destroyParticle(campus, params),
                    this._destroyFacadeEffect(campus, params.ThemeManager),
                    this._setFacadeEffect(params, campus)
                } else {
                    new Function(style.extFunc)("占个位", "用于兼容旧版", {
                        ground: style.ground,
                        particle: style.particle,
                        ThemeManager: this.ThemeManager,
                        inner: style.inner,
                        outer: style.outer
                    }, campus)
                }
                await Promise.all(this._themePromise),
                this._themePromise.length = 0
            } else
                this._destroyGroundDecorate(campus, this),
                this._destroyParticle(campus, this)
        }
        applyThemeEnvironment(e="default", t, r="inner", i=!1) {
            if (!this.app)
                throw new Error("[EffectThemeControl.js] : [this.app] : cannot found!");
            if (t) {
                if ("Campus" !== t.type)
                    throw new TypeError('第二个参数类型必须为"Campus"!')
            } else
                t = this.app.query(".Campus")[0];
            let n = "undefined" == typeof CMAP ? null : CMAP.getCurrentMap();
            if (!(t && t.ground && t.ground.plan))
                throw new TypeError("此时园区未加载完成！请在园区加载完后,再应用效果模板。");
            if (this.autoUpdate) {
                let r = !1;
                if (this.environmentMap.name && this.environmentMap.campus === t && this.environmentMap.name === e)
                    return r = true,
                    void (i || console.log("请不要重复注册"));
                this._autoApplyThemeEnvironment(e, n, t, true),
                r && !i || (this.app.on(THING.EventType.EnterLevel, null, (()=>{
                    e && this._autoApplyThemeEnvironment(e, n, t)
                }
                ), "ThemeEnterLevelToUpdateEnv"),
                this.environmentMap.name = e,
                this.environmentMap.campus = t)
            } else
                "undefined" != typeof CMAP && THING.Math.getVectorLength(t.position) > 63e5 ? console.warn("该接口在地球上不生效，请根据自己的业务需求选择使用CMAP或THING的applyThemeEnvironment接口。请注意CMAP的只认地球效果数据，THING只认园区效果模板数据！") : this.app.applyThemeEnvironment(e, r)
        }
        destroyEffectTheme(e="default", t) {
            if (t) {
                if ("Campus" !== t.type)
                    throw new TypeError('第二个参数类型必须为"Campus"!')
            } else
                t = this.app.query(".Campus")[0];
            if (!(t && t.ground && t.ground.plan))
                throw new TypeError("此时园区未加载完成！请在园区加载完后,再应用效果模板。");
            if (!THING.ThemeManager.findStyle(e))
                throw new TypeError("找不到该模板！请先注册模板后再应用");
            {
                const e = t.query(".GroundObject");
                e.length > 0 && (this.app.off(THING.EventType.EnterLevel, null, "EnterLevelToSetGround" + t.groundAndParticleTag),
                e.forEach((e=>{
                    e.destroy()
                }
                ))),
                this.ThemeManager._objGround = new WeakMap;
                const r = t.query(/粒子装饰模型父物体/);
                r.length > 0 && (this.app.off(THING.EventType.EnterLevel, null, "EnterLevelToSetParticle" + t.groundAndParticleTag),
                r.forEach((e=>{
                    e.destroy()
                }
                ))),
                this.ThemeManager._objParticle = new WeakMap,
                this._destroyFacadeEffect(t, this.ThemeManager),
                this.ThemeManager._objFacade = new WeakMap
            }
        }
        applyExtFunc(e="default", t) {
            if (t) {
                if ("Campus" !== t.type)
                    throw new TypeError('第二个参数类型必须为"Campus"!')
            } else
                t = this.app.query(".Campus")[0];
            if (!(t && t.ground && t.ground.plan))
                throw new TypeError("此时园区未加载完成！请在园区加载完后,再应用效果模板。");
            if (e) {
                let r = THING.ThemeManager.findStyle(e);
                if (!r)
                    throw new TypeError("找不到该模板！请先注册模板后再应用");
                new Function(r.onExtFunc)(r.itemConfig, this.app, t)
            }
        }
        cancelExtFunc(e="default", t) {
            if (t) {
                if ("Campus" !== t.type)
                    throw new TypeError('第二个参数类型必须为"Campus"!')
            } else
                t = this.app.query(".Campus")[0];
            if (!(t && t.ground && t.ground.plan))
                throw new TypeError("此时园区未加载完成！请在园区加载完后,再应用效果模板。");
            if (e) {
                let r = THING.ThemeManager.findStyle(e);
                if (!r)
                    throw new TypeError("找不到该模板！请先注册模板后再应用");
                new Function(r.offExtFunc)(r.itemConfig, this.app, t)
            }
        }
        resetCacheBbx(e) {
            this._resetBbx(e);
            e.query(".Building").forEach((t=>{
                this._resetBbx(t);
                e.query(".Floor").forEach((e=>{
                    this._resetBbx(e)
                }
                ))
            }
            ))
        }
        _resetBbx(e) {
            e._cacheForGround ? delete e._cacheForGround.bbx : e._cacheForGround = {};
            const t = e.getOrientedBox(!1, !1);
            e._cacheForGround.bbx = t,
            e._cacheForGround.up = e.up,
            e._cacheForGround.worldAngles = e.worldAngles
        }
        _autoApplyThemeEnvironment(e, t, r, i=!1) {
            const n = this.app.level.current ? this.app.level.current : this.app.query(".Campus")[0];
            "undefined" != typeof CMAP && THING.Math.getVectorLength(r.position) > 63e5 ? console.warn("该接口在地球上不生效，请根据自己的业务需求选择使用CMAP或THING的applyThemeEnvironment接口。请注意CMAP的只认地球效果数据，THING只认园区效果模板数据！") : e && ("Campus" === n.type ? this.currentEnv && "inner" !== this.currentEnv && !i || (this.currentEnv = "outer",
            this.app.applyThemeEnvironment(e, "outer")) : "Building" !== n.type && "Floor" !== n.type && "Room" !== n.type && "Campus" === this.app.level.previous.type && n.isThing || this.currentEnv && "outer" !== this.currentEnv && !i || (this.currentEnv = "inner",
            this.app.applyThemeEnvironment(e, "inner")))
        }
        _versiongt(e, t) {
            const r = e.split(".")
              , i = t.split(".")
              , n = Math.min(r.length, i.length);
            let o = !1;
            for (let e = 0; e < n; e++)
                if (e === n - 1) {
                    if (parseInt(r[e]) >= parseInt(i[e])) {
                        o = true;
                        break
                    }
                } else {
                    if (parseInt(r[e]) > parseInt(i[e])) {
                        o = true;
                        break
                    }
                    if (parseInt(r[e]) < parseInt(i[e])) {
                        o = !1;
                        break
                    }
                }
            return o
        }
        _setGroundDecorate(e, t, r=!1, i=true) {
            const n = THING.App.current
              , o = ()=>{
                if (t.ThemeManager._objGround.has(e) ? t.ThemeManager._objGround.get(e).length = 0 : t.ThemeManager._objGround.set(e, []),
                r) {
                    if (t.ground?.enable && t.ground.item.forEach((o=>{
                        let s = o;
                        Object.assign(s, {
                            parent: e,
                            target: e,
                            style: {
                                skipBoundingBox: true,
                                skipOutline: true
                            }
                        });
                        const a = {
                            type: "GroundObject",
                            ...s,
                            isNewVersion: r,
                            isOuter: true,
                            cacheAllBbx: i
                        };
                        let l = n.create(a);
                        l.style.skipBoundingBox = true,
                        l.style.renderOrder = -10,
                        t.ThemeManager._objGround.get(e).push(l)
                    }
                    )),
                    t.ground?.groundReflect) {
                        let o = n.create({
                            type: "GroundObject",
                            groundClearance: .1,
                            groundReflect: true,
                            parent: e,
                            target: e,
                            style: {
                                skipBoundingBox: true,
                                skipOutline: true
                            },
                            reflectFactor: t.ground.reflectFactor,
                            isNewVersion: r,
                            isOuter: true,
                            cacheAllBbx: i
                        });
                        o.style.skipBoundingBox = true,
                        t.ThemeManager._objGround.get(e).push(o)
                    }
                    if (t.innerGround?.enable && t.innerGround.item.forEach((o=>{
                        let s = o;
                        Object.assign(s, {
                            parent: e,
                            target: e,
                            style: {
                                skipBoundingBox: true,
                                skipOutline: true
                            }
                        });
                        const a = {
                            type: "GroundObject",
                            ...s,
                            isNewVersion: r,
                            isOuter: !1,
                            cacheAllBbx: i
                        };
                        let l = n.create(a);
                        l.style.skipBoundingBox = true,
                        l.style.renderOrder = -10,
                        t.ThemeManager._objGround.get(e).push(l)
                    }
                    )),
                    t.innerGround?.groundReflect) {
                        let o = n.create({
                            type: "GroundObject",
                            groundClearance: .1,
                            groundReflect: true,
                            parent: e,
                            target: e,
                            style: {
                                skipBoundingBox: true,
                                skipOutline: true
                            },
                            reflectFactor: t.innerGround.reflectFactor,
                            isNewVersion: r,
                            isOuter: !1,
                            cacheAllBbx: i
                        });
                        o.style.skipBoundingBox = true,
                        t.ThemeManager._objGround.get(e).push(o)
                    }
                } else if (t.ground?.enable && t.ground.item.forEach((o=>{
                    let s = o;
                    Object.assign(s, {
                        parent: e,
                        target: e,
                        style: {
                            skipBoundingBox: true,
                            skipOutline: true
                        }
                    });
                    const a = {
                        type: "GroundObject",
                        ...s,
                        isNewVersion: r,
                        cacheAllBbx: i
                    };
                    let l = n.create(a);
                    l.style.skipBoundingBox = true,
                    l.style.renderOrder = -10,
                    t.ThemeManager._objGround.get(e).push(l)
                }
                )),
                t.ground?.groundReflect) {
                    let o = n.create({
                        type: "GroundObject",
                        groundClearance: .1,
                        groundReflect: true,
                        parent: e,
                        target: e,
                        style: {
                            skipBoundingBox: true,
                            skipOutline: true
                        },
                        reflectFactor: t.ground.reflectFactor,
                        isNewVersion: r,
                        cacheAllBbx: i
                    });
                    o.style.skipBoundingBox = true,
                    t.ThemeManager._objGround.get(e).push(o)
                }
            }
              , s = (e=!1,i=!1,o)=>{
                if (e || "Building" === n.level.current.type || "Floor" === n.level.current.type && (!n.level.previous || "Room" !== n.level.previous.type) || "Campus" === n.level.current.type) {
                    const e = this
                      , s = function() {
                        r ? "Campus" === n.level.current.type ? o.visible && (t.ThemeManager._objGround.get(o)?.forEach((e=>{
                            e._isOuter && (e.updateGround(),
                            e.fadeIn({
                                time: 1e3
                            }))
                        }
                        )),
                        e._clearTimeoutAfterExecute(250, (e=>{
                            t.ThemeManager._objGround.get(o)?.forEach((e=>{
                                e.visible = e._isOuter && o.visible
                            }
                            )),
                            clearTimeout(e)
                        }
                        ))) : o.visible && (t.ThemeManager._objGround.get(o)?.forEach((e=>{
                            e._isOuter || (e.updateGround(),
                            e.fadeIn({
                                time: 1e3
                            }))
                        }
                        )),
                        e._clearTimeoutAfterExecute(250, (e=>{
                            t.ThemeManager._objGround.get(o)?.forEach((e=>{
                                e.visible = !e._isOuter && o.visible
                            }
                            )),
                            clearTimeout(e)
                        }
                        ))) : o.visible && (t.ThemeManager._objGround.get(o)?.forEach((e=>{
                            e.updateGround(),
                            e.fadeIn({
                                time: 1e3
                            })
                        }
                        )),
                        e._clearTimeoutAfterExecute(250, (e=>{
                            t.ThemeManager._objGround.get(o)?.forEach((e=>{
                                e.visible = true
                            }
                            )),
                            clearTimeout(e)
                        }
                        )))
                    };
                    t.ThemeManager._objGround.get(o)?.forEach((e=>{
                        e.visible = !1
                    }
                    )),
                    i ? s() : n.one(THING.EventType.LevelFlyEnd, (()=>{
                        this._clearTimeoutAfterExecute(0, (e=>{
                            s(),
                            clearTimeout(e)
                        }
                        ))
                    }
                    ), "levelFlyEndToUpdateGround")
                } else
                    "undefined" != typeof CMAP && THING.Math.getVectorLength(o.position) > 63e5 && "Thing" !== n.level.current.type && "Room" !== n.level.current.type && "Floor" !== n.level.current.type && "GeoBasePoint" === n.level.current.type && !n.level.current.isThing && void 0 !== t.ground.visibleOnEarth && (r ? t.ThemeManager._objGround.get(o)?.forEach((e=>{
                        e._isOuter ? e.visible = t.ground.visibleOnEarth : e.visible = !1
                    }
                    )) : t.ThemeManager._objGround.get(o)?.forEach((e=>{
                        e.visible = t.ground.visibleOnEarth
                    }
                    )))
            }
            ;
            t.ThemeManager._objGround.get(e) && 0 !== t.ThemeManager._objGround.get(e).length || o(),
            s(!1, true, e),
            e.groundAndParticleTag || (e.groundAndParticleTag = Math.random() + ""),
            n.on(THING.EventType.EnterLevel, (()=>{
                t.ThemeManager._objGround.get(e) && 0 !== t.ThemeManager._objGround.get(e).length || o(),
                s(!1, true, e)
            }
            ), "EnterLevelToSetGround" + e.groundAndParticleTag, 0)
        }
        _destroyGroundDecorate(e, t) {
            const r = THING.App.current
              , i = e.query(".GroundObject");
            i.length > 0 && (r.off(THING.EventType.EnterLevel, null, "EnterLevelToSetGround" + e.groundAndParticleTag),
            i.forEach((e=>{
                e.destroy()
            }
            )),
            t.ThemeManager._objGround.get(e).length = 0)
        }
        _readJson(e, t, r, i, n) {
            const o = THING.App.current
              , s = new THREE.FileLoader
              , a = o.level.current;
            s.load(e.concat("/index.json"), (json=>{
                try {
                    let l = json;
                    const h = i;
                    let c;
                    h._cacheForGround ? c = h._cacheForGround.bbx : (c = h.getOrientedBox(!1, !1),
                    h._cacheForGround = {},
                    h._cacheForGround.bbx = c,
                    h._cacheForGround.up = h.up,
                    h._cacheForGround.worldAngles = h.worldAngles);
                    const u = c.size[1] / 2 + .2
                      , p = THING.Math.scaleVector(h._cacheForGround.up, u)
                      , d = THING.Math.subVector(c.center, p);
                    json = JSON.parse(l);
                    const f = function(e, t) {
                        for (let r in t)
                            "iMaxParticleCount" !== r && "position" !== r && "iParticleCount" !== r && (e[r]instanceof Array ? f(e[r][0], t[r][0]) : e[r]instanceof Object ? f(e[r], t[r]) : "" !== t[r] && (e[r] = t[r]));
                        return e
                    };
                    json.listGroups = f(json.listGroups, t.content.listGroups);
                    let g = json.listGroups[0].listEmitters[0].position.vec3Spread;
                    "" === t.content.listGroups[0].texture.url ? (this._isHttpUrl(json.listGroups[0].texture.url) || (json.listGroups[0].texture.url = e.concat(json.listGroups[0].texture.url)),
                    this._isHttpUrl(json.listGroups[0].textureTrail.url) || (json.listGroups[0].textureTrail.url = e.concat(json.listGroups[0].textureTrail.url))) : (json.listGroups[0].texture.url = t.themePkg.concat(t.content.listGroups[0].texture.url),
                    json.listGroups[0].textureTrail.url = e.concat(json.listGroups[0].textureTrail.url));
                    let m = THING.Math.ceil(THING.Math.min(1e4, t.content.density * json.listGroups[0].iMaxParticleCount * c.size[0] * c.size[2] / g.x / g.z * 4))
                      , _ = THING.Math.ceil(json.listGroups[0].listEmitters[0].iParticleCount / json.listGroups[0].iMaxParticleCount * m);
                    json.listGroups[0].listEmitters[0].iParticleCount = _,
                    json.listGroups[0].iMaxParticleCount = m,
                    json.listGroups[0].listEmitters[0].position.vec3Spread = {
                        x: 2 * c.size[0],
                        y: t.content.height,
                        z: 2 * c.size[2]
                    };
                    let v = o.create({
                        type: "BaseObject",
                        id: `粒子装饰模型父物体_ ${t.code}`,
                        parent: i,
                        position: d,
                        visible: a && "Campus" === a.type
                    });
                    v.style.skipBoundingBox = true;
                    const y = this;
                    let T = o.create({
                        type: "ParticleSystem",
                        id: `粒子装饰模型_ ${t.code}`,
                        name: `粒子装饰模型_ ${t.code}`,
                        data: json,
                        parent: v,
                        localPosition: [0, t.content.offsetHeight + t.content.height / 2, 0],
                        angle: 0,
                        visible: a && "Campus" === a.type,
                        complete: function(e) {
                            y._clearTimeoutAfterExecute(1, (e=>{
                                v.style.skipBoundingBox = true,
                                T.worldAngles = h._cacheForGround.worldAngles,
                                "undefined" != typeof CMAP && THING.Math.getVectorLength(i.position) > 63e5 && ("GeoBasePoint" === o.level.current.type && !o.level.current.isThing || "Campus" === o.level.current.type) && (void 0 !== r.particle.visibleOnEarth ? T.visible = r.particle.visibleOnEarth : T.visible = i.visible),
                                clearTimeout(e)
                            }
                            ))
                        }
                    });
                    T.style.skipBoundingBox = true,
                    T.userData.cfg = T.userData.cfg || {},
                    T.userData.cfg.offsetHeight = t.content.offsetHeight + t.content.height / 2,
                    n(T)
                } catch (e) {
                    console.error(e)
                }
            }
            ), (()=>{}
            ), (()=>{}
            ))
        }
        _setParticle(e, t) {
            const r = THING.App.current
              , i = r=>new Promise((i=>{
                let n = r.url;
                n = n.substring(0, n.length - 1),
                this._readJson(n, r, e, t, i)
            }
            ))
              , n = r=>new Promise((n=>{
                e.ThemeManager._objParticle.has(t) ? e.ThemeManager._objParticle.get(t).length = 0 : e.ThemeManager._objParticle.set(t, []);
                let o = 0;
                r?.forEach((s=>{
                    i(s).then((i=>{
                        e.ThemeManager._objParticle.get(t).push(i),
                        o += 1,
                        o === r.length && n()
                    }
                    ))
                }
                ))
            }
            ))
              , o = (t=!1,i=!1,n)=>{
                const o = "undefined" != typeof CMAP && THING.Math.getVectorLength(n.position) > 63e5;
                if ("Campus" === r.level.current.type) {
                    const t = t=>{
                        e.ThemeManager._objParticle.get(n)?.forEach((r=>{
                            const i = t._cacheForGround.bbx
                              , s = i.size[1] / 2 + .2
                              , a = THING.Math.scaleVector(t._cacheForGround.up, s);
                            r.worldAngles = t._cacheForGround.worldAngles,
                            r.position = THING.Math.subVector(i.center, a),
                            r.visible = (!o || void 0 === e.particle.visibleOnEarth || e.particle.visibleOnEarth) && n.visible
                        }
                        ))
                    }
                    ;
                    i ? this._clearTimeoutAfterExecute(0, (e=>{
                        t(n),
                        clearTimeout(e)
                    }
                    )) : r.one(THING.EventType.LevelFlyEnd, (e=>{
                        const r = e.object;
                        this._clearTimeoutAfterExecute(250, (e=>{
                            t(r),
                            clearTimeout(e)
                        }
                        ))
                    }
                    ), "levelFlyEndToUpdateParticle")
                } else
                    "Building" === r.level.current.type || "Floor" === r.level.current.type || "Room" === r.level.current.type ? e.ThemeManager._objParticle.get(n)?.forEach((e=>{
                        e.visible && (e.visible = !1)
                    }
                    )) : "GeoBasePoint" !== r.level.current.type || r.level.current.isThing || void 0 !== e.particle.visibleOnEarth && e.ThemeManager._objParticle.get(n)?.forEach((t=>{
                        t.visible && (t.visible = e.particle.visibleOnEarth)
                    }
                    ))
            }
            ;
            e.ThemeManager._objParticle.get(t) && 0 !== e.ThemeManager._objParticle.get(t).length ? o(!1, true, t) : e.particle?.enable && this._themePromise.push(n(e.particle.item).then((()=>{
                o(!1, true, t)
            }
            ))),
            t.groundAndParticleTag || (t.groundAndParticleTag = Math.random() + ""),
            r.on(THING.EventType.EnterLevel, (()=>{
                e.ThemeManager._objParticle.get(t) && 0 !== e.ThemeManager._objParticle.get(t).length ? o(!1, true, t) : e.particle?.enable && this._themePromise.push(n(e.particle.item).then((()=>{
                    o(!1, true, t)
                }
                )))
            }
            ), "EnterLevelToSetParticle" + t.groundAndParticleTag, 0)
        }
        _destroyParticle(e, t) {
            const r = THING.App.current
              , i = e.query(/粒子装饰模型父物体/);
            i.length > 0 && (r.off(THING.EventType.EnterLevel, null, "EnterLevelToSetParticle" + e.groundAndParticleTag),
            i.forEach((e=>{
                e.destroy()
            }
            )),
            t.ThemeManager._objParticle.get(e).length = 0)
        }
        _setClonedFloors(e, t) {
            e.ThemeManager._objClonedFloors = [],
            e.floors && e.floors.enable && e.floors.item.forEach((e=>{
                e.clonedFloors.enable && effectTheme.ClonedFloorUtils.createClonedFloors({
                    buildings: t.query(".Building"),
                    ...e.clonedFloors
                }),
                e.singleLines.enable && effectTheme.ClonedFloorUtils.createSingleLines({
                    buildings: t.query(".Building"),
                    ...e.singleLines
                }),
                e.doubleLines.enable && effectTheme.ClonedFloorUtils.createDoubleLines({
                    buildings: t.query(".Building"),
                    ...e.doubleLines
                })
            }
            ))
        }
        _destroyClonedFloors(e, t) {
            const r = THING.App.current
              , i = e.query(".ClonedFloor");
            i.length > 0 && (i.forEach((e=>{
                e.destroy()
            }
            )),
            r.off(THING.EventType.EnterLevel, null, "levelFlyEndToShowCloneGround"));
            const n = e.query(".ClonedLine");
            n.length > 0 && (n.forEach((e=>{
                e.destroy()
            }
            )),
            r.off(THING.EventType.EnterLevel, null, "levelFlyEndToShowLines"),
            r.off(THING.EventType.EnterLevel, null, "levelFlyEndToShowDoubleLines"))
        }
        _setFacadeEffect(e, t) {
            e.ThemeManager._objFacade.has(t) ? e.ThemeManager._objFacade.get(t).length = 0 : e.ThemeManager._objFacade.set(t, []),
            e.facadeEffect && e.facadeEffect.enable && e.facadeEffect.item.forEach((r=>{
                if (void 0 === r.enable || true === r.enable) {
                    const i = effectTheme.FacadeEffectUtils.addFacadeBoxToScene(r);
                    e.ThemeManager._objFacade.get(t).push(...i)
                }
            }
            ))
        }
        _destroyFacadeEffect(e, t) {
            t._objFacade.get(e) && (t._objFacade.get(e).forEach((e=>{
                "Box" !== e.type && "Line" !== e.type || e.destroy()
            }
            )),
            t._objFacade.get(e).length = 0)
        }
        _fadeIn(e, t=1e3) {
            e.style.opacity = 0,
            this.fadeTween && (this.fadeTween.stop(),
            this.fadeTween = null);
            var r = {
                opacity: e.style.opacity
            };
            e.node.visible = true,
            fadeTween = new TWEEN.Tween(r).to({
                opacity: 1
            }, t).easing(TWEEN.Easing.Linear.None).onUpdate((function(t) {
                e.style.opacity = t.opacity
            }
            )).start()
        }
        _onEnterAnimation(e=3e3) {
            this.app.on(THING.EventType.EnterLevel, (()=>{
                if ("Campus" === this.app.level.current.type) {
                    let t = this.app.level.current;
                    t.node.visible = !1,
                    this._fadeIn(t, e)
                }
            }
            ), "EnterLevelAnimation", 0)
        }
        _offEnterAnimation() {
            this.app.off(THING.EventType.EnterLevel, null, "EnterLevelAnimation")
        }
        _decrypt(e) {
            if ("object" == typeof e)
                return e.data ? e.data : e;
            let t = crypto.enc.Utf8.parse("CityBuilder@2019")
              , r = crypto.AES.decrypt(e, t, {
                mode: crypto.mode.ECB,
                padding: crypto.pad.Pkcs7
            })
              , n = crypto.enc.Utf8.stringify(r).toString();
            return JSON.parse(n).data
        }
        _isHttpUrl(e) {
            return e.startsWith("http://") || e.startsWith("https://")
        }
        _validationEnd(e, t) {
            const r = e.length - t.length;
            return e.substr(r, t.length) == t
        }
        _clearTimeoutAfterExecute(e=1e3, t) {
            let r = setTimeout((()=>{
                t(r)
            }
            ), e)
        }
    }
    THING.EffectThemeControl = EffectThemeControl,
    THING.THEMEVERSION = "1.5.6";
    class ThemeLoader {
        constructor() {
            this._app = THING.App.current
        }
        onLoad(e, t, r, i) {
            const n = e.info.main;
            if (e.name = e.info.name,
            n && "frame.js" === n) {
                const i = e._url.appendPath(n)
                  , l = t.campus || this._app.campuses[0]
                  , h = t.name || "default";
                this._app.level.change(l);
                var o, s = this._app.getControl("效果模板控制器");
                if (!s) {
                    var a = new THING.EffectThemeControl;
                    this._app.addControl(a, "效果模板控制器"),
                    s = this._app.getControl("效果模板控制器")
                }
                THING.Utils.loadJSONFile(i, (t=>{
                    o = JSON.parse(t.slice(t.split("{")[0].length)),
                    s.registerTheme(h, o, e.url, !1, null),
                    l.applyTheme(h),
                    s.applyEffectTheme(h, l),
                    s.applyThemeEnvironment(h, l),
                    r()
                }
                ))
            }
        }
    }
    THING.ThemeLoader = ThemeLoader;
    class EffectRing extends THING.BaseObject {
        constructor(e) {
            super(e),
            this._mesh = null,
            this._url = "",
            this._roll = 0,
            this._pitch = 0,
            this._scale = 1,
            this._offset = 0,
            this._colorChanel = 1,
            this._size = [1, 1],
            this._pivot = [.5, .5],
            this._speed = 1,
            this._opacity = 1,
            this._color = new THREE.Color(14410472),
            this._map = null,
            this.tickable = true
        }
        customSetup(e) {
            this._url = e.url || this._url,
            this._roll = void 0 === e.roll ? this._roll : e.roll,
            this._pitch = void 0 === e.pitch ? this._pitch : e.pitch,
            this._scale = e.scale || this._scale,
            this._offset = void 0 === e.offsetY ? this._offset : e.offsetY,
            this._colorChanel = e.colorChanel || this._colorChanel,
            this._size = e.size || this._size,
            this._pivot = e.pivot || this._pivot,
            this._speed = void 0 === e.speed ? this._speed : e.speed,
            this._opacity = void 0 === e.opacity ? this._opacity : e.opacity,
            this._color = e.color ? this._color.set(e.color) : this._color,
            this._map = e.map || this._map;
            var t = function(e, t, r, i, n, o, s, a, l) {
                var h = (new THREE.TextureLoader).load(e);
                h.anisotropy = 16;
                var c = {
                    map: {
                        value: h
                    },
                    time: {
                        value: 0
                    },
                    speed: {
                        value: s
                    },
                    opacity: {
                        value: a
                    },
                    roll: {
                        value: t
                    },
                    pitch: {
                        value: r
                    },
                    scale: {
                        value: i
                    },
                    offset: {
                        value: n
                    },
                    colorChanel: {
                        value: o
                    },
                    color: {
                        value: l
                    }
                };
                return new THREE.ShaderMaterial({
                    uniforms: c,
                    vertexShader: "\n                    varying vec2 vUv;\n                    \n                    uniform float roll;\n                    uniform float pitch;\n                    uniform float scale;\n                    uniform float offset;\n                    \n                    vec3 rollMultiplyMat(vec3 pos,float c,float s)\n                    {\n                         mat3 m=mat3(1.,0.,0.,0.,c,-s,0.,s,c);\n                         return m*pos;\n                    }\n\n                    vec3 pitchMultiplyMat(vec3 pos,float c,float s)\n                    {\n                         mat3 m=mat3(c,-s,0.,s,c,0.,0.,0.,1.);\n                         return m*pos;\n                    }\n                    \n                    vec3 scaleMultiplyMat(vec3 pos,float scale)\n                    {\n                         mat3 m=mat3(scale,0.,0.,0.,scale,0.,0.,0.,scale);\n                         return m*pos;\n                    }\n                    \n                    vec4 offsetMultiplyMat(vec3 pos,float offset)\n                    {\n                         return vec4(pos.x,pos.y+offset,pos.z,1.);\n                    }\n\n                    void main() {\n                     vec4 pos=vec4(position,1.);   \n                     pos.xyz=rollMultiplyMat(pos.xyz,cos(roll),sin(roll));\n                     pos.xyz=pitchMultiplyMat(pos.xyz,cos(pitch),sin(pitch));\n                     pos.xyz=scaleMultiplyMat(pos.xyz,scale);\n                     pos=offsetMultiplyMat(pos.xyz,offset);\n                     gl_Position = projectionMatrix * modelViewMatrix * pos;\n\n                     vUv=uv;\n                    }\n                ",
                    fragmentShader: "\n                    #define PI 3.1415926535897932384626433832795\n                    \n                    varying vec2 vUv;\n                    \n                    uniform sampler2D map;\n                    uniform float time;\n                    uniform float speed;\n                    uniform float opacity;\n                    uniform int colorChanel;\n                    uniform vec3 color;\n                    \n                    vec2 newUV(vec2 coord,float c,float s)\n                    {\n                         mat2 m=mat2(c,-s,s,c);\n                         return m*coord;\n                    }\n\n                    void main() {\t\n                        vec4 finalCol=vec4(0.,0.,0.,0.);\n                        float val;\n                        float t=speed*time;      \n                        vec2 pivot=vec2(0.5,0.5);\n                        vec2 uv=newUV((vUv-pivot),cos(t),sin(t))+pivot;\n                        \n                        if(uv.x>0.&&uv.x<1.&&uv.y>0.&&uv.y<1.)\n                        {\n                            if(colorChanel==2)\n                            {\n                               val=texture2D( map, uv ).g;\n                               finalCol+=vec4(color,opacity*val);\n                            }else if(colorChanel==3)\n                            {\n                               val=texture2D( map, uv ).b;\n                               finalCol+=vec4(color,opacity*val);\n                            }else\n                            {\n                               val=texture2D( map, uv ).r;\n                               finalCol+=vec4(color,opacity*val);\n                            }\n                        }\n                        \n                        gl_FragColor= clamp(finalCol,0.,1.);                \n                    }\n                ",
                    transparent: true,
                    depthWrite: !1,
                    side: THREE.DoubleSide
                })
            }(this._url, this._roll, this._pitch, this._scale, this._offset, this._colorChanel, this._speed, this._opacity, this._color);
            this._map = t.uniforms.map.value;
            var r = new THREE.PlaneGeometry(this._size[0],this._size[1])
              , i = new THREE.Mesh(r,t);
            this._mesh = i,
            this.node.add(this._mesh)
        }
        update(e) {
            return super.update(e),
            "ShaderMaterial" == this._mesh.material.type && (this._mesh.material.uniforms.time.value += e),
            true
        }
        destroy() {
            super.destroy()
        }
        set size(e) {
            this._size = e
        }
        get size() {
            return this._size
        }
        set roll(e) {
            this._roll = e,
            this._mesh.material.uniforms.roll.value = e
        }
        get roll() {
            return this._roll
        }
        set pitch(e) {
            this._pitch = e,
            this._mesh.material.uniforms.pitch.value = e
        }
        get pitch() {
            return this._pitch
        }
        set scale(e) {
            this._scale = e,
            this._mesh.material.uniforms.scale.value = e
        }
        get scale() {
            return this._scale
        }
        set offsetY(e) {
            this._offset = e,
            this._mesh.material.uniforms.offset.value = e
        }
        get offsetY() {
            return this._offset
        }
        set speed(e) {
            this._speed = e,
            this._mesh.material.uniforms.speed.value = e
        }
        get speed() {
            return this._speed
        }
        set opacity(e) {
            this._opacity = e,
            this._mesh.material.uniforms.opacity.value = e
        }
        get opacity() {
            return this._opacity
        }
        set color(e) {
            this._color.set(e),
            this._mesh.material.uniforms.color.value = this._color
        }
        get color() {
            return this._color
        }
        set colorChanel(e) {
            this._colorChanel = e,
            this._mesh.material.uniforms.colorChanel.value = e
        }
        get colorChanel() {
            return this._colorChanel
        }
        set map(e) {
            this._map = e,
            this._mesh.material.uniforms.map.value = e
        }
        get map() {
            return this._map
        }
    }
    THING.factory.hasClass("EffectRing") || THING.factory.registerClass("EffectRing", EffectRing),
    THING.Utils.waitAppComplete().then((e=>{
        e || THING.Utils.warn("Failed to get App.current to automatically register ThemeLoader!"),
        e.registerBundleLoader("theme", new THING.ThemeLoader)
    }
    )),
    exports.ClonedFloorUtils = ClonedFloorUtils,
    exports.EffectRing = EffectRing,
    exports.EffectThemeControl = EffectThemeControl,
    exports.FacadeEffectUtils = FacadeEffectUtils,
    exports.GroundObject = GroundObject,
    exports.ThemeLoader = ThemeLoader,
    Object.defineProperty(exports, "__esModule", {
        value: true
    })
}
));
